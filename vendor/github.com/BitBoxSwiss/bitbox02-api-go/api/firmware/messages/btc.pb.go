// SPDX-License-Identifier: Apache-2.0

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        v3.21.12
// source: btc.proto

package messages

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type BTCCoin int32

const (
	BTCCoin_BTC  BTCCoin = 0
	BTCCoin_TBTC BTCCoin = 1
	BTCCoin_LTC  BTCCoin = 2
	BTCCoin_TLTC BTCCoin = 3
	// Regtest
	BTCCoin_RBTC BTCCoin = 4
)

// Enum value maps for BTCCoin.
var (
	BTCCoin_name = map[int32]string{
		0: "BTC",
		1: "TBTC",
		2: "LTC",
		3: "TLTC",
		4: "RBTC",
	}
	BTCCoin_value = map[string]int32{
		"BTC":  0,
		"TBTC": 1,
		"LTC":  2,
		"TLTC": 3,
		"RBTC": 4,
	}
)

func (x BTCCoin) Enum() *BTCCoin {
	p := new(BTCCoin)
	*p = x
	return p
}

func (x BTCCoin) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCCoin) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[0].Descriptor()
}

func (BTCCoin) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[0]
}

func (x BTCCoin) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCCoin.Descriptor instead.
func (BTCCoin) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0}
}

type BTCOutputType int32

const (
	BTCOutputType_UNKNOWN   BTCOutputType = 0
	BTCOutputType_P2PKH     BTCOutputType = 1
	BTCOutputType_P2SH      BTCOutputType = 2
	BTCOutputType_P2WPKH    BTCOutputType = 3
	BTCOutputType_P2WSH     BTCOutputType = 4
	BTCOutputType_P2TR      BTCOutputType = 5
	BTCOutputType_OP_RETURN BTCOutputType = 6
)

// Enum value maps for BTCOutputType.
var (
	BTCOutputType_name = map[int32]string{
		0: "UNKNOWN",
		1: "P2PKH",
		2: "P2SH",
		3: "P2WPKH",
		4: "P2WSH",
		5: "P2TR",
		6: "OP_RETURN",
	}
	BTCOutputType_value = map[string]int32{
		"UNKNOWN":   0,
		"P2PKH":     1,
		"P2SH":      2,
		"P2WPKH":    3,
		"P2WSH":     4,
		"P2TR":      5,
		"OP_RETURN": 6,
	}
)

func (x BTCOutputType) Enum() *BTCOutputType {
	p := new(BTCOutputType)
	*p = x
	return p
}

func (x BTCOutputType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCOutputType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[1].Descriptor()
}

func (BTCOutputType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[1]
}

func (x BTCOutputType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCOutputType.Descriptor instead.
func (BTCOutputType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{1}
}

// SimpleType is a "simple" script: one public key, no additional inputs.
type BTCScriptConfig_SimpleType int32

const (
	BTCScriptConfig_P2WPKH_P2SH BTCScriptConfig_SimpleType = 0
	BTCScriptConfig_P2WPKH      BTCScriptConfig_SimpleType = 1
	BTCScriptConfig_P2TR        BTCScriptConfig_SimpleType = 2
)

// Enum value maps for BTCScriptConfig_SimpleType.
var (
	BTCScriptConfig_SimpleType_name = map[int32]string{
		0: "P2WPKH_P2SH",
		1: "P2WPKH",
		2: "P2TR",
	}
	BTCScriptConfig_SimpleType_value = map[string]int32{
		"P2WPKH_P2SH": 0,
		"P2WPKH":      1,
		"P2TR":        2,
	}
)

func (x BTCScriptConfig_SimpleType) Enum() *BTCScriptConfig_SimpleType {
	p := new(BTCScriptConfig_SimpleType)
	*p = x
	return p
}

func (x BTCScriptConfig_SimpleType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCScriptConfig_SimpleType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[2].Descriptor()
}

func (BTCScriptConfig_SimpleType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[2]
}

func (x BTCScriptConfig_SimpleType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCScriptConfig_SimpleType.Descriptor instead.
func (BTCScriptConfig_SimpleType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0, 0}
}

type BTCScriptConfig_Multisig_ScriptType int32

const (
	BTCScriptConfig_Multisig_P2WSH      BTCScriptConfig_Multisig_ScriptType = 0 // native segwit v0 multisig (bech32 addresses)
	BTCScriptConfig_Multisig_P2WSH_P2SH BTCScriptConfig_Multisig_ScriptType = 1 // wrapped segwit for legacy address compatibility
)

// Enum value maps for BTCScriptConfig_Multisig_ScriptType.
var (
	BTCScriptConfig_Multisig_ScriptType_name = map[int32]string{
		0: "P2WSH",
		1: "P2WSH_P2SH",
	}
	BTCScriptConfig_Multisig_ScriptType_value = map[string]int32{
		"P2WSH":      0,
		"P2WSH_P2SH": 1,
	}
)

func (x BTCScriptConfig_Multisig_ScriptType) Enum() *BTCScriptConfig_Multisig_ScriptType {
	p := new(BTCScriptConfig_Multisig_ScriptType)
	*p = x
	return p
}

func (x BTCScriptConfig_Multisig_ScriptType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCScriptConfig_Multisig_ScriptType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[3].Descriptor()
}

func (BTCScriptConfig_Multisig_ScriptType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[3]
}

func (x BTCScriptConfig_Multisig_ScriptType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCScriptConfig_Multisig_ScriptType.Descriptor instead.
func (BTCScriptConfig_Multisig_ScriptType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0, 0, 0}
}

type BTCPubRequest_XPubType int32

const (
	BTCPubRequest_TPUB         BTCPubRequest_XPubType = 0
	BTCPubRequest_XPUB         BTCPubRequest_XPubType = 1
	BTCPubRequest_YPUB         BTCPubRequest_XPubType = 2
	BTCPubRequest_ZPUB         BTCPubRequest_XPubType = 3 // zpub
	BTCPubRequest_VPUB         BTCPubRequest_XPubType = 4 // vpub
	BTCPubRequest_UPUB         BTCPubRequest_XPubType = 5
	BTCPubRequest_CAPITAL_VPUB BTCPubRequest_XPubType = 6 // Vpub
	BTCPubRequest_CAPITAL_ZPUB BTCPubRequest_XPubType = 7 // Zpub
	BTCPubRequest_CAPITAL_UPUB BTCPubRequest_XPubType = 8 // Upub
	BTCPubRequest_CAPITAL_YPUB BTCPubRequest_XPubType = 9 // Ypub
)

// Enum value maps for BTCPubRequest_XPubType.
var (
	BTCPubRequest_XPubType_name = map[int32]string{
		0: "TPUB",
		1: "XPUB",
		2: "YPUB",
		3: "ZPUB",
		4: "VPUB",
		5: "UPUB",
		6: "CAPITAL_VPUB",
		7: "CAPITAL_ZPUB",
		8: "CAPITAL_UPUB",
		9: "CAPITAL_YPUB",
	}
	BTCPubRequest_XPubType_value = map[string]int32{
		"TPUB":         0,
		"XPUB":         1,
		"YPUB":         2,
		"ZPUB":         3,
		"VPUB":         4,
		"UPUB":         5,
		"CAPITAL_VPUB": 6,
		"CAPITAL_ZPUB": 7,
		"CAPITAL_UPUB": 8,
		"CAPITAL_YPUB": 9,
	}
)

func (x BTCPubRequest_XPubType) Enum() *BTCPubRequest_XPubType {
	p := new(BTCPubRequest_XPubType)
	*p = x
	return p
}

func (x BTCPubRequest_XPubType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCPubRequest_XPubType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[4].Descriptor()
}

func (BTCPubRequest_XPubType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[4]
}

func (x BTCPubRequest_XPubType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCPubRequest_XPubType.Descriptor instead.
func (BTCPubRequest_XPubType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{1, 0}
}

type BTCXpubsRequest_XPubType int32

const (
	BTCXpubsRequest_UNKNOWN BTCXpubsRequest_XPubType = 0
	BTCXpubsRequest_XPUB    BTCXpubsRequest_XPubType = 1
	BTCXpubsRequest_TPUB    BTCXpubsRequest_XPubType = 2
)

// Enum value maps for BTCXpubsRequest_XPubType.
var (
	BTCXpubsRequest_XPubType_name = map[int32]string{
		0: "UNKNOWN",
		1: "XPUB",
		2: "TPUB",
	}
	BTCXpubsRequest_XPubType_value = map[string]int32{
		"UNKNOWN": 0,
		"XPUB":    1,
		"TPUB":    2,
	}
)

func (x BTCXpubsRequest_XPubType) Enum() *BTCXpubsRequest_XPubType {
	p := new(BTCXpubsRequest_XPubType)
	*p = x
	return p
}

func (x BTCXpubsRequest_XPubType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCXpubsRequest_XPubType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[5].Descriptor()
}

func (BTCXpubsRequest_XPubType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[5]
}

func (x BTCXpubsRequest_XPubType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCXpubsRequest_XPubType.Descriptor instead.
func (BTCXpubsRequest_XPubType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{2, 0}
}

type BTCSignInitRequest_FormatUnit int32

const (
	// According to `coin` (BTC, LTC, etc.).
	BTCSignInitRequest_DEFAULT BTCSignInitRequest_FormatUnit = 0
	// Only valid for BTC/TBTC, formats as "sat"/"tsat".
	BTCSignInitRequest_SAT BTCSignInitRequest_FormatUnit = 1
)

// Enum value maps for BTCSignInitRequest_FormatUnit.
var (
	BTCSignInitRequest_FormatUnit_name = map[int32]string{
		0: "DEFAULT",
		1: "SAT",
	}
	BTCSignInitRequest_FormatUnit_value = map[string]int32{
		"DEFAULT": 0,
		"SAT":     1,
	}
)

func (x BTCSignInitRequest_FormatUnit) Enum() *BTCSignInitRequest_FormatUnit {
	p := new(BTCSignInitRequest_FormatUnit)
	*p = x
	return p
}

func (x BTCSignInitRequest_FormatUnit) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCSignInitRequest_FormatUnit) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[6].Descriptor()
}

func (BTCSignInitRequest_FormatUnit) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[6]
}

func (x BTCSignInitRequest_FormatUnit) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCSignInitRequest_FormatUnit.Descriptor instead.
func (BTCSignInitRequest_FormatUnit) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{4, 0}
}

type BTCSignNextResponse_Type int32

const (
	BTCSignNextResponse_INPUT  BTCSignNextResponse_Type = 0
	BTCSignNextResponse_OUTPUT BTCSignNextResponse_Type = 1
	BTCSignNextResponse_DONE   BTCSignNextResponse_Type = 2
	// For the previous transaction at input `index`.
	BTCSignNextResponse_PREVTX_INIT     BTCSignNextResponse_Type = 3
	BTCSignNextResponse_PREVTX_INPUT    BTCSignNextResponse_Type = 4
	BTCSignNextResponse_PREVTX_OUTPUT   BTCSignNextResponse_Type = 5
	BTCSignNextResponse_HOST_NONCE      BTCSignNextResponse_Type = 6
	BTCSignNextResponse_PAYMENT_REQUEST BTCSignNextResponse_Type = 7
)

// Enum value maps for BTCSignNextResponse_Type.
var (
	BTCSignNextResponse_Type_name = map[int32]string{
		0: "INPUT",
		1: "OUTPUT",
		2: "DONE",
		3: "PREVTX_INIT",
		4: "PREVTX_INPUT",
		5: "PREVTX_OUTPUT",
		6: "HOST_NONCE",
		7: "PAYMENT_REQUEST",
	}
	BTCSignNextResponse_Type_value = map[string]int32{
		"INPUT":           0,
		"OUTPUT":          1,
		"DONE":            2,
		"PREVTX_INIT":     3,
		"PREVTX_INPUT":    4,
		"PREVTX_OUTPUT":   5,
		"HOST_NONCE":      6,
		"PAYMENT_REQUEST": 7,
	}
)

func (x BTCSignNextResponse_Type) Enum() *BTCSignNextResponse_Type {
	p := new(BTCSignNextResponse_Type)
	*p = x
	return p
}

func (x BTCSignNextResponse_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCSignNextResponse_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[7].Descriptor()
}

func (BTCSignNextResponse_Type) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[7]
}

func (x BTCSignNextResponse_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCSignNextResponse_Type.Descriptor instead.
func (BTCSignNextResponse_Type) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{5, 0}
}

type BTCRegisterScriptConfigRequest_XPubType int32

const (
	// Automatically choose to match Electrum's xpub format (e.g. Zpub/Vpub for p2wsh multisig mainnet/testnet).
	BTCRegisterScriptConfigRequest_AUTO_ELECTRUM BTCRegisterScriptConfigRequest_XPubType = 0
	// Always xpub for mainnets, tpub for testnets.
	BTCRegisterScriptConfigRequest_AUTO_XPUB_TPUB BTCRegisterScriptConfigRequest_XPubType = 1
)

// Enum value maps for BTCRegisterScriptConfigRequest_XPubType.
var (
	BTCRegisterScriptConfigRequest_XPubType_name = map[int32]string{
		0: "AUTO_ELECTRUM",
		1: "AUTO_XPUB_TPUB",
	}
	BTCRegisterScriptConfigRequest_XPubType_value = map[string]int32{
		"AUTO_ELECTRUM":  0,
		"AUTO_XPUB_TPUB": 1,
	}
)

func (x BTCRegisterScriptConfigRequest_XPubType) Enum() *BTCRegisterScriptConfigRequest_XPubType {
	p := new(BTCRegisterScriptConfigRequest_XPubType)
	*p = x
	return p
}

func (x BTCRegisterScriptConfigRequest_XPubType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (BTCRegisterScriptConfigRequest_XPubType) Descriptor() protoreflect.EnumDescriptor {
	return file_btc_proto_enumTypes[8].Descriptor()
}

func (BTCRegisterScriptConfigRequest_XPubType) Type() protoreflect.EnumType {
	return &file_btc_proto_enumTypes[8]
}

func (x BTCRegisterScriptConfigRequest_XPubType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use BTCRegisterScriptConfigRequest_XPubType.Descriptor instead.
func (BTCRegisterScriptConfigRequest_XPubType) EnumDescriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{12, 0}
}

type BTCScriptConfig struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Config:
	//
	//	*BTCScriptConfig_SimpleType_
	//	*BTCScriptConfig_Multisig_
	//	*BTCScriptConfig_Policy_
	Config        isBTCScriptConfig_Config `protobuf_oneof:"config"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCScriptConfig) Reset() {
	*x = BTCScriptConfig{}
	mi := &file_btc_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCScriptConfig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCScriptConfig) ProtoMessage() {}

func (x *BTCScriptConfig) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCScriptConfig.ProtoReflect.Descriptor instead.
func (*BTCScriptConfig) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0}
}

func (x *BTCScriptConfig) GetConfig() isBTCScriptConfig_Config {
	if x != nil {
		return x.Config
	}
	return nil
}

func (x *BTCScriptConfig) GetSimpleType() BTCScriptConfig_SimpleType {
	if x != nil {
		if x, ok := x.Config.(*BTCScriptConfig_SimpleType_); ok {
			return x.SimpleType
		}
	}
	return BTCScriptConfig_P2WPKH_P2SH
}

func (x *BTCScriptConfig) GetMultisig() *BTCScriptConfig_Multisig {
	if x != nil {
		if x, ok := x.Config.(*BTCScriptConfig_Multisig_); ok {
			return x.Multisig
		}
	}
	return nil
}

func (x *BTCScriptConfig) GetPolicy() *BTCScriptConfig_Policy {
	if x != nil {
		if x, ok := x.Config.(*BTCScriptConfig_Policy_); ok {
			return x.Policy
		}
	}
	return nil
}

type isBTCScriptConfig_Config interface {
	isBTCScriptConfig_Config()
}

type BTCScriptConfig_SimpleType_ struct {
	SimpleType BTCScriptConfig_SimpleType `protobuf:"varint,1,opt,name=simple_type,json=simpleType,proto3,enum=shiftcrypto.bitbox02.BTCScriptConfig_SimpleType,oneof"`
}

type BTCScriptConfig_Multisig_ struct {
	Multisig *BTCScriptConfig_Multisig `protobuf:"bytes,2,opt,name=multisig,proto3,oneof"`
}

type BTCScriptConfig_Policy_ struct {
	Policy *BTCScriptConfig_Policy `protobuf:"bytes,3,opt,name=policy,proto3,oneof"`
}

func (*BTCScriptConfig_SimpleType_) isBTCScriptConfig_Config() {}

func (*BTCScriptConfig_Multisig_) isBTCScriptConfig_Config() {}

func (*BTCScriptConfig_Policy_) isBTCScriptConfig_Config() {}

type BTCPubRequest struct {
	state   protoimpl.MessageState `protogen:"open.v1"`
	Coin    BTCCoin                `protobuf:"varint,1,opt,name=coin,proto3,enum=shiftcrypto.bitbox02.BTCCoin" json:"coin,omitempty"`
	Keypath []uint32               `protobuf:"varint,2,rep,packed,name=keypath,proto3" json:"keypath,omitempty"`
	// Types that are valid to be assigned to Output:
	//
	//	*BTCPubRequest_XpubType
	//	*BTCPubRequest_ScriptConfig
	Output        isBTCPubRequest_Output `protobuf_oneof:"output"`
	Display       bool                   `protobuf:"varint,5,opt,name=display,proto3" json:"display,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPubRequest) Reset() {
	*x = BTCPubRequest{}
	mi := &file_btc_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPubRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPubRequest) ProtoMessage() {}

func (x *BTCPubRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPubRequest.ProtoReflect.Descriptor instead.
func (*BTCPubRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{1}
}

func (x *BTCPubRequest) GetCoin() BTCCoin {
	if x != nil {
		return x.Coin
	}
	return BTCCoin_BTC
}

func (x *BTCPubRequest) GetKeypath() []uint32 {
	if x != nil {
		return x.Keypath
	}
	return nil
}

func (x *BTCPubRequest) GetOutput() isBTCPubRequest_Output {
	if x != nil {
		return x.Output
	}
	return nil
}

func (x *BTCPubRequest) GetXpubType() BTCPubRequest_XPubType {
	if x != nil {
		if x, ok := x.Output.(*BTCPubRequest_XpubType); ok {
			return x.XpubType
		}
	}
	return BTCPubRequest_TPUB
}

func (x *BTCPubRequest) GetScriptConfig() *BTCScriptConfig {
	if x != nil {
		if x, ok := x.Output.(*BTCPubRequest_ScriptConfig); ok {
			return x.ScriptConfig
		}
	}
	return nil
}

func (x *BTCPubRequest) GetDisplay() bool {
	if x != nil {
		return x.Display
	}
	return false
}

type isBTCPubRequest_Output interface {
	isBTCPubRequest_Output()
}

type BTCPubRequest_XpubType struct {
	XpubType BTCPubRequest_XPubType `protobuf:"varint,3,opt,name=xpub_type,json=xpubType,proto3,enum=shiftcrypto.bitbox02.BTCPubRequest_XPubType,oneof"`
}

type BTCPubRequest_ScriptConfig struct {
	ScriptConfig *BTCScriptConfig `protobuf:"bytes,4,opt,name=script_config,json=scriptConfig,proto3,oneof"`
}

func (*BTCPubRequest_XpubType) isBTCPubRequest_Output() {}

func (*BTCPubRequest_ScriptConfig) isBTCPubRequest_Output() {}

type BTCXpubsRequest struct {
	state         protoimpl.MessageState   `protogen:"open.v1"`
	Coin          BTCCoin                  `protobuf:"varint,1,opt,name=coin,proto3,enum=shiftcrypto.bitbox02.BTCCoin" json:"coin,omitempty"`
	XpubType      BTCXpubsRequest_XPubType `protobuf:"varint,2,opt,name=xpub_type,json=xpubType,proto3,enum=shiftcrypto.bitbox02.BTCXpubsRequest_XPubType" json:"xpub_type,omitempty"`
	Keypaths      []*Keypath               `protobuf:"bytes,3,rep,name=keypaths,proto3" json:"keypaths,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCXpubsRequest) Reset() {
	*x = BTCXpubsRequest{}
	mi := &file_btc_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCXpubsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCXpubsRequest) ProtoMessage() {}

func (x *BTCXpubsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCXpubsRequest.ProtoReflect.Descriptor instead.
func (*BTCXpubsRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{2}
}

func (x *BTCXpubsRequest) GetCoin() BTCCoin {
	if x != nil {
		return x.Coin
	}
	return BTCCoin_BTC
}

func (x *BTCXpubsRequest) GetXpubType() BTCXpubsRequest_XPubType {
	if x != nil {
		return x.XpubType
	}
	return BTCXpubsRequest_UNKNOWN
}

func (x *BTCXpubsRequest) GetKeypaths() []*Keypath {
	if x != nil {
		return x.Keypaths
	}
	return nil
}

type BTCScriptConfigWithKeypath struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	ScriptConfig  *BTCScriptConfig       `protobuf:"bytes,2,opt,name=script_config,json=scriptConfig,proto3" json:"script_config,omitempty"`
	Keypath       []uint32               `protobuf:"varint,3,rep,packed,name=keypath,proto3" json:"keypath,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCScriptConfigWithKeypath) Reset() {
	*x = BTCScriptConfigWithKeypath{}
	mi := &file_btc_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCScriptConfigWithKeypath) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCScriptConfigWithKeypath) ProtoMessage() {}

func (x *BTCScriptConfigWithKeypath) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCScriptConfigWithKeypath.ProtoReflect.Descriptor instead.
func (*BTCScriptConfigWithKeypath) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{3}
}

func (x *BTCScriptConfigWithKeypath) GetScriptConfig() *BTCScriptConfig {
	if x != nil {
		return x.ScriptConfig
	}
	return nil
}

func (x *BTCScriptConfigWithKeypath) GetKeypath() []uint32 {
	if x != nil {
		return x.Keypath
	}
	return nil
}

type BTCSignInitRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Coin  BTCCoin                `protobuf:"varint,1,opt,name=coin,proto3,enum=shiftcrypto.bitbox02.BTCCoin" json:"coin,omitempty"`
	// used script configs in inputs and changes
	ScriptConfigs                []*BTCScriptConfigWithKeypath `protobuf:"bytes,2,rep,name=script_configs,json=scriptConfigs,proto3" json:"script_configs,omitempty"`
	Version                      uint32                        `protobuf:"varint,4,opt,name=version,proto3" json:"version,omitempty"` // must be 1 or 2
	NumInputs                    uint32                        `protobuf:"varint,5,opt,name=num_inputs,json=numInputs,proto3" json:"num_inputs,omitempty"`
	NumOutputs                   uint32                        `protobuf:"varint,6,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	Locktime                     uint32                        `protobuf:"varint,7,opt,name=locktime,proto3" json:"locktime,omitempty"` // must be <500000000
	FormatUnit                   BTCSignInitRequest_FormatUnit `protobuf:"varint,8,opt,name=format_unit,json=formatUnit,proto3,enum=shiftcrypto.bitbox02.BTCSignInitRequest_FormatUnit" json:"format_unit,omitempty"`
	ContainsSilentPaymentOutputs bool                          `protobuf:"varint,9,opt,name=contains_silent_payment_outputs,json=containsSilentPaymentOutputs,proto3" json:"contains_silent_payment_outputs,omitempty"`
	// used script configs for outputs that send to an address of the same keystore, but not
	// necessarily the same account (as defined by `script_configs` above).
	OutputScriptConfigs []*BTCScriptConfigWithKeypath `protobuf:"bytes,10,rep,name=output_script_configs,json=outputScriptConfigs,proto3" json:"output_script_configs,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *BTCSignInitRequest) Reset() {
	*x = BTCSignInitRequest{}
	mi := &file_btc_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignInitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignInitRequest) ProtoMessage() {}

func (x *BTCSignInitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignInitRequest.ProtoReflect.Descriptor instead.
func (*BTCSignInitRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{4}
}

func (x *BTCSignInitRequest) GetCoin() BTCCoin {
	if x != nil {
		return x.Coin
	}
	return BTCCoin_BTC
}

func (x *BTCSignInitRequest) GetScriptConfigs() []*BTCScriptConfigWithKeypath {
	if x != nil {
		return x.ScriptConfigs
	}
	return nil
}

func (x *BTCSignInitRequest) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *BTCSignInitRequest) GetNumInputs() uint32 {
	if x != nil {
		return x.NumInputs
	}
	return 0
}

func (x *BTCSignInitRequest) GetNumOutputs() uint32 {
	if x != nil {
		return x.NumOutputs
	}
	return 0
}

func (x *BTCSignInitRequest) GetLocktime() uint32 {
	if x != nil {
		return x.Locktime
	}
	return 0
}

func (x *BTCSignInitRequest) GetFormatUnit() BTCSignInitRequest_FormatUnit {
	if x != nil {
		return x.FormatUnit
	}
	return BTCSignInitRequest_DEFAULT
}

func (x *BTCSignInitRequest) GetContainsSilentPaymentOutputs() bool {
	if x != nil {
		return x.ContainsSilentPaymentOutputs
	}
	return false
}

func (x *BTCSignInitRequest) GetOutputScriptConfigs() []*BTCScriptConfigWithKeypath {
	if x != nil {
		return x.OutputScriptConfigs
	}
	return nil
}

type BTCSignNextResponse struct {
	state protoimpl.MessageState   `protogen:"open.v1"`
	Type  BTCSignNextResponse_Type `protobuf:"varint,1,opt,name=type,proto3,enum=shiftcrypto.bitbox02.BTCSignNextResponse_Type" json:"type,omitempty"`
	// index of the current input or output
	Index        uint32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	HasSignature bool   `protobuf:"varint,3,opt,name=has_signature,json=hasSignature,proto3" json:"has_signature,omitempty"` // only as a response to BTCSignInputRequest
	// 64 bytes (32 bytes big endian R, 32 bytes big endian S). Only if has_signature is true.
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// Previous tx's input/output index in case of PREV_INPUT or PREV_OUTPUT, for the input at `index`.
	PrevIndex                  uint32                      `protobuf:"varint,5,opt,name=prev_index,json=prevIndex,proto3" json:"prev_index,omitempty"`
	AntiKleptoSignerCommitment *AntiKleptoSignerCommitment `protobuf:"bytes,6,opt,name=anti_klepto_signer_commitment,json=antiKleptoSignerCommitment,proto3" json:"anti_klepto_signer_commitment,omitempty"`
	// Generated output. The host *must* verify its correctness using `silent_payment_dleq_proof`.
	GeneratedOutputPkscript []byte `protobuf:"bytes,7,opt,name=generated_output_pkscript,json=generatedOutputPkscript,proto3" json:"generated_output_pkscript,omitempty"`
	SilentPaymentDleqProof  []byte `protobuf:"bytes,8,opt,name=silent_payment_dleq_proof,json=silentPaymentDleqProof,proto3" json:"silent_payment_dleq_proof,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *BTCSignNextResponse) Reset() {
	*x = BTCSignNextResponse{}
	mi := &file_btc_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignNextResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignNextResponse) ProtoMessage() {}

func (x *BTCSignNextResponse) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignNextResponse.ProtoReflect.Descriptor instead.
func (*BTCSignNextResponse) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{5}
}

func (x *BTCSignNextResponse) GetType() BTCSignNextResponse_Type {
	if x != nil {
		return x.Type
	}
	return BTCSignNextResponse_INPUT
}

func (x *BTCSignNextResponse) GetIndex() uint32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *BTCSignNextResponse) GetHasSignature() bool {
	if x != nil {
		return x.HasSignature
	}
	return false
}

func (x *BTCSignNextResponse) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

func (x *BTCSignNextResponse) GetPrevIndex() uint32 {
	if x != nil {
		return x.PrevIndex
	}
	return 0
}

func (x *BTCSignNextResponse) GetAntiKleptoSignerCommitment() *AntiKleptoSignerCommitment {
	if x != nil {
		return x.AntiKleptoSignerCommitment
	}
	return nil
}

func (x *BTCSignNextResponse) GetGeneratedOutputPkscript() []byte {
	if x != nil {
		return x.GeneratedOutputPkscript
	}
	return nil
}

func (x *BTCSignNextResponse) GetSilentPaymentDleqProof() []byte {
	if x != nil {
		return x.SilentPaymentDleqProof
	}
	return nil
}

type BTCSignInputRequest struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	PrevOutHash  []byte                 `protobuf:"bytes,1,opt,name=prevOutHash,proto3" json:"prevOutHash,omitempty"`
	PrevOutIndex uint32                 `protobuf:"varint,2,opt,name=prevOutIndex,proto3" json:"prevOutIndex,omitempty"`
	PrevOutValue uint64                 `protobuf:"varint,3,opt,name=prevOutValue,proto3" json:"prevOutValue,omitempty"`
	Sequence     uint32                 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`      // must be 0xffffffff-2, 0xffffffff-1 or 0xffffffff
	Keypath      []uint32               `protobuf:"varint,6,rep,packed,name=keypath,proto3" json:"keypath,omitempty"` // all inputs must be ours.
	// References a script config from BTCSignInitRequest
	ScriptConfigIndex   uint32                         `protobuf:"varint,7,opt,name=script_config_index,json=scriptConfigIndex,proto3" json:"script_config_index,omitempty"`
	HostNonceCommitment *AntiKleptoHostNonceCommitment `protobuf:"bytes,8,opt,name=host_nonce_commitment,json=hostNonceCommitment,proto3" json:"host_nonce_commitment,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *BTCSignInputRequest) Reset() {
	*x = BTCSignInputRequest{}
	mi := &file_btc_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignInputRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignInputRequest) ProtoMessage() {}

func (x *BTCSignInputRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignInputRequest.ProtoReflect.Descriptor instead.
func (*BTCSignInputRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{6}
}

func (x *BTCSignInputRequest) GetPrevOutHash() []byte {
	if x != nil {
		return x.PrevOutHash
	}
	return nil
}

func (x *BTCSignInputRequest) GetPrevOutIndex() uint32 {
	if x != nil {
		return x.PrevOutIndex
	}
	return 0
}

func (x *BTCSignInputRequest) GetPrevOutValue() uint64 {
	if x != nil {
		return x.PrevOutValue
	}
	return 0
}

func (x *BTCSignInputRequest) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

func (x *BTCSignInputRequest) GetKeypath() []uint32 {
	if x != nil {
		return x.Keypath
	}
	return nil
}

func (x *BTCSignInputRequest) GetScriptConfigIndex() uint32 {
	if x != nil {
		return x.ScriptConfigIndex
	}
	return 0
}

func (x *BTCSignInputRequest) GetHostNonceCommitment() *AntiKleptoHostNonceCommitment {
	if x != nil {
		return x.HostNonceCommitment
	}
	return nil
}

type BTCSignOutputRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	Ours  bool                   `protobuf:"varint,1,opt,name=ours,proto3" json:"ours,omitempty"`
	Type  BTCOutputType          `protobuf:"varint,2,opt,name=type,proto3,enum=shiftcrypto.bitbox02.BTCOutputType" json:"type,omitempty"` // if ours is false
	// 20 bytes for p2pkh, p2sh, pw2wpkh. 32 bytes for p2wsh.
	Value   uint64   `protobuf:"varint,3,opt,name=value,proto3" json:"value,omitempty"`
	Payload []byte   `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`         // if ours is false. Renamed from `hash`.
	Keypath []uint32 `protobuf:"varint,5,rep,packed,name=keypath,proto3" json:"keypath,omitempty"` // if ours is true
	// If ours is true and `output_script_config_index` is absent. References a script config from
	// BTCSignInitRequest. This allows change output identification and allows us to identify
	// non-change outputs to the same account, so we can display this info to the user.
	ScriptConfigIndex   uint32  `protobuf:"varint,6,opt,name=script_config_index,json=scriptConfigIndex,proto3" json:"script_config_index,omitempty"`
	PaymentRequestIndex *uint32 `protobuf:"varint,7,opt,name=payment_request_index,json=paymentRequestIndex,proto3,oneof" json:"payment_request_index,omitempty"`
	// If provided, `type` and `payload` is ignored. The generated output pkScript is returned in
	// BTCSignNextResponse. `contains_silent_payment_outputs` in the init request must be true.
	SilentPayment *BTCSignOutputRequest_SilentPayment `protobuf:"bytes,8,opt,name=silent_payment,json=silentPayment,proto3" json:"silent_payment,omitempty"`
	// If ours is true. If set, `script_config_index` is ignored. References an output script config
	// from BTCSignInitRequest. This enables verification that an output belongs to the same keystore,
	// even if it is from a different account than we spend from, allowing us to display this info to
	// the user.
	OutputScriptConfigIndex *uint32 `protobuf:"varint,9,opt,name=output_script_config_index,json=outputScriptConfigIndex,proto3,oneof" json:"output_script_config_index,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *BTCSignOutputRequest) Reset() {
	*x = BTCSignOutputRequest{}
	mi := &file_btc_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignOutputRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignOutputRequest) ProtoMessage() {}

func (x *BTCSignOutputRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignOutputRequest.ProtoReflect.Descriptor instead.
func (*BTCSignOutputRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{7}
}

func (x *BTCSignOutputRequest) GetOurs() bool {
	if x != nil {
		return x.Ours
	}
	return false
}

func (x *BTCSignOutputRequest) GetType() BTCOutputType {
	if x != nil {
		return x.Type
	}
	return BTCOutputType_UNKNOWN
}

func (x *BTCSignOutputRequest) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *BTCSignOutputRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *BTCSignOutputRequest) GetKeypath() []uint32 {
	if x != nil {
		return x.Keypath
	}
	return nil
}

func (x *BTCSignOutputRequest) GetScriptConfigIndex() uint32 {
	if x != nil {
		return x.ScriptConfigIndex
	}
	return 0
}

func (x *BTCSignOutputRequest) GetPaymentRequestIndex() uint32 {
	if x != nil && x.PaymentRequestIndex != nil {
		return *x.PaymentRequestIndex
	}
	return 0
}

func (x *BTCSignOutputRequest) GetSilentPayment() *BTCSignOutputRequest_SilentPayment {
	if x != nil {
		return x.SilentPayment
	}
	return nil
}

func (x *BTCSignOutputRequest) GetOutputScriptConfigIndex() uint32 {
	if x != nil && x.OutputScriptConfigIndex != nil {
		return *x.OutputScriptConfigIndex
	}
	return 0
}

type BTCScriptConfigRegistration struct {
	state        protoimpl.MessageState `protogen:"open.v1"`
	Coin         BTCCoin                `protobuf:"varint,1,opt,name=coin,proto3,enum=shiftcrypto.bitbox02.BTCCoin" json:"coin,omitempty"`
	ScriptConfig *BTCScriptConfig       `protobuf:"bytes,2,opt,name=script_config,json=scriptConfig,proto3" json:"script_config,omitempty"`
	// Unused for policy registrations.
	Keypath       []uint32 `protobuf:"varint,3,rep,packed,name=keypath,proto3" json:"keypath,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCScriptConfigRegistration) Reset() {
	*x = BTCScriptConfigRegistration{}
	mi := &file_btc_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCScriptConfigRegistration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCScriptConfigRegistration) ProtoMessage() {}

func (x *BTCScriptConfigRegistration) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCScriptConfigRegistration.ProtoReflect.Descriptor instead.
func (*BTCScriptConfigRegistration) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{8}
}

func (x *BTCScriptConfigRegistration) GetCoin() BTCCoin {
	if x != nil {
		return x.Coin
	}
	return BTCCoin_BTC
}

func (x *BTCScriptConfigRegistration) GetScriptConfig() *BTCScriptConfig {
	if x != nil {
		return x.ScriptConfig
	}
	return nil
}

func (x *BTCScriptConfigRegistration) GetKeypath() []uint32 {
	if x != nil {
		return x.Keypath
	}
	return nil
}

type BTCSuccess struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCSuccess) Reset() {
	*x = BTCSuccess{}
	mi := &file_btc_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSuccess) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSuccess) ProtoMessage() {}

func (x *BTCSuccess) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSuccess.ProtoReflect.Descriptor instead.
func (*BTCSuccess) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{9}
}

type BTCIsScriptConfigRegisteredRequest struct {
	state         protoimpl.MessageState       `protogen:"open.v1"`
	Registration  *BTCScriptConfigRegistration `protobuf:"bytes,1,opt,name=registration,proto3" json:"registration,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCIsScriptConfigRegisteredRequest) Reset() {
	*x = BTCIsScriptConfigRegisteredRequest{}
	mi := &file_btc_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCIsScriptConfigRegisteredRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCIsScriptConfigRegisteredRequest) ProtoMessage() {}

func (x *BTCIsScriptConfigRegisteredRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCIsScriptConfigRegisteredRequest.ProtoReflect.Descriptor instead.
func (*BTCIsScriptConfigRegisteredRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{10}
}

func (x *BTCIsScriptConfigRegisteredRequest) GetRegistration() *BTCScriptConfigRegistration {
	if x != nil {
		return x.Registration
	}
	return nil
}

type BTCIsScriptConfigRegisteredResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	IsRegistered  bool                   `protobuf:"varint,1,opt,name=is_registered,json=isRegistered,proto3" json:"is_registered,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCIsScriptConfigRegisteredResponse) Reset() {
	*x = BTCIsScriptConfigRegisteredResponse{}
	mi := &file_btc_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCIsScriptConfigRegisteredResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCIsScriptConfigRegisteredResponse) ProtoMessage() {}

func (x *BTCIsScriptConfigRegisteredResponse) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCIsScriptConfigRegisteredResponse.ProtoReflect.Descriptor instead.
func (*BTCIsScriptConfigRegisteredResponse) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{11}
}

func (x *BTCIsScriptConfigRegisteredResponse) GetIsRegistered() bool {
	if x != nil {
		return x.IsRegistered
	}
	return false
}

type BTCRegisterScriptConfigRequest struct {
	state        protoimpl.MessageState       `protogen:"open.v1"`
	Registration *BTCScriptConfigRegistration `protobuf:"bytes,1,opt,name=registration,proto3" json:"registration,omitempty"`
	// If empty, the name is entered on the device instead.
	Name          string                                  `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	XpubType      BTCRegisterScriptConfigRequest_XPubType `protobuf:"varint,3,opt,name=xpub_type,json=xpubType,proto3,enum=shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest_XPubType" json:"xpub_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCRegisterScriptConfigRequest) Reset() {
	*x = BTCRegisterScriptConfigRequest{}
	mi := &file_btc_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCRegisterScriptConfigRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCRegisterScriptConfigRequest) ProtoMessage() {}

func (x *BTCRegisterScriptConfigRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCRegisterScriptConfigRequest.ProtoReflect.Descriptor instead.
func (*BTCRegisterScriptConfigRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{12}
}

func (x *BTCRegisterScriptConfigRequest) GetRegistration() *BTCScriptConfigRegistration {
	if x != nil {
		return x.Registration
	}
	return nil
}

func (x *BTCRegisterScriptConfigRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *BTCRegisterScriptConfigRequest) GetXpubType() BTCRegisterScriptConfigRequest_XPubType {
	if x != nil {
		return x.XpubType
	}
	return BTCRegisterScriptConfigRequest_AUTO_ELECTRUM
}

type BTCPrevTxInitRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Version       uint32                 `protobuf:"varint,1,opt,name=version,proto3" json:"version,omitempty"`
	NumInputs     uint32                 `protobuf:"varint,2,opt,name=num_inputs,json=numInputs,proto3" json:"num_inputs,omitempty"`
	NumOutputs    uint32                 `protobuf:"varint,3,opt,name=num_outputs,json=numOutputs,proto3" json:"num_outputs,omitempty"`
	Locktime      uint32                 `protobuf:"varint,4,opt,name=locktime,proto3" json:"locktime,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPrevTxInitRequest) Reset() {
	*x = BTCPrevTxInitRequest{}
	mi := &file_btc_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPrevTxInitRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPrevTxInitRequest) ProtoMessage() {}

func (x *BTCPrevTxInitRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPrevTxInitRequest.ProtoReflect.Descriptor instead.
func (*BTCPrevTxInitRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{13}
}

func (x *BTCPrevTxInitRequest) GetVersion() uint32 {
	if x != nil {
		return x.Version
	}
	return 0
}

func (x *BTCPrevTxInitRequest) GetNumInputs() uint32 {
	if x != nil {
		return x.NumInputs
	}
	return 0
}

func (x *BTCPrevTxInitRequest) GetNumOutputs() uint32 {
	if x != nil {
		return x.NumOutputs
	}
	return 0
}

func (x *BTCPrevTxInitRequest) GetLocktime() uint32 {
	if x != nil {
		return x.Locktime
	}
	return 0
}

type BTCPrevTxInputRequest struct {
	state           protoimpl.MessageState `protogen:"open.v1"`
	PrevOutHash     []byte                 `protobuf:"bytes,1,opt,name=prev_out_hash,json=prevOutHash,proto3" json:"prev_out_hash,omitempty"`
	PrevOutIndex    uint32                 `protobuf:"varint,2,opt,name=prev_out_index,json=prevOutIndex,proto3" json:"prev_out_index,omitempty"`
	SignatureScript []byte                 `protobuf:"bytes,3,opt,name=signature_script,json=signatureScript,proto3" json:"signature_script,omitempty"`
	Sequence        uint32                 `protobuf:"varint,4,opt,name=sequence,proto3" json:"sequence,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *BTCPrevTxInputRequest) Reset() {
	*x = BTCPrevTxInputRequest{}
	mi := &file_btc_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPrevTxInputRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPrevTxInputRequest) ProtoMessage() {}

func (x *BTCPrevTxInputRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPrevTxInputRequest.ProtoReflect.Descriptor instead.
func (*BTCPrevTxInputRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{14}
}

func (x *BTCPrevTxInputRequest) GetPrevOutHash() []byte {
	if x != nil {
		return x.PrevOutHash
	}
	return nil
}

func (x *BTCPrevTxInputRequest) GetPrevOutIndex() uint32 {
	if x != nil {
		return x.PrevOutIndex
	}
	return 0
}

func (x *BTCPrevTxInputRequest) GetSignatureScript() []byte {
	if x != nil {
		return x.SignatureScript
	}
	return nil
}

func (x *BTCPrevTxInputRequest) GetSequence() uint32 {
	if x != nil {
		return x.Sequence
	}
	return 0
}

type BTCPrevTxOutputRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Value         uint64                 `protobuf:"varint,1,opt,name=value,proto3" json:"value,omitempty"`
	PubkeyScript  []byte                 `protobuf:"bytes,2,opt,name=pubkey_script,json=pubkeyScript,proto3" json:"pubkey_script,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPrevTxOutputRequest) Reset() {
	*x = BTCPrevTxOutputRequest{}
	mi := &file_btc_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPrevTxOutputRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPrevTxOutputRequest) ProtoMessage() {}

func (x *BTCPrevTxOutputRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPrevTxOutputRequest.ProtoReflect.Descriptor instead.
func (*BTCPrevTxOutputRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{15}
}

func (x *BTCPrevTxOutputRequest) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *BTCPrevTxOutputRequest) GetPubkeyScript() []byte {
	if x != nil {
		return x.PubkeyScript
	}
	return nil
}

type BTCPaymentRequestRequest struct {
	state         protoimpl.MessageState           `protogen:"open.v1"`
	RecipientName string                           `protobuf:"bytes,1,opt,name=recipient_name,json=recipientName,proto3" json:"recipient_name,omitempty"`
	Memos         []*BTCPaymentRequestRequest_Memo `protobuf:"bytes,2,rep,name=memos,proto3" json:"memos,omitempty"`
	Nonce         []byte                           `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	TotalAmount   uint64                           `protobuf:"varint,4,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	Signature     []byte                           `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPaymentRequestRequest) Reset() {
	*x = BTCPaymentRequestRequest{}
	mi := &file_btc_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPaymentRequestRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPaymentRequestRequest) ProtoMessage() {}

func (x *BTCPaymentRequestRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPaymentRequestRequest.ProtoReflect.Descriptor instead.
func (*BTCPaymentRequestRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{16}
}

func (x *BTCPaymentRequestRequest) GetRecipientName() string {
	if x != nil {
		return x.RecipientName
	}
	return ""
}

func (x *BTCPaymentRequestRequest) GetMemos() []*BTCPaymentRequestRequest_Memo {
	if x != nil {
		return x.Memos
	}
	return nil
}

func (x *BTCPaymentRequestRequest) GetNonce() []byte {
	if x != nil {
		return x.Nonce
	}
	return nil
}

func (x *BTCPaymentRequestRequest) GetTotalAmount() uint64 {
	if x != nil {
		return x.TotalAmount
	}
	return 0
}

func (x *BTCPaymentRequestRequest) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type BTCSignMessageRequest struct {
	state               protoimpl.MessageState         `protogen:"open.v1"`
	Coin                BTCCoin                        `protobuf:"varint,1,opt,name=coin,proto3,enum=shiftcrypto.bitbox02.BTCCoin" json:"coin,omitempty"`
	ScriptConfig        *BTCScriptConfigWithKeypath    `protobuf:"bytes,2,opt,name=script_config,json=scriptConfig,proto3" json:"script_config,omitempty"`
	Msg                 []byte                         `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	HostNonceCommitment *AntiKleptoHostNonceCommitment `protobuf:"bytes,4,opt,name=host_nonce_commitment,json=hostNonceCommitment,proto3" json:"host_nonce_commitment,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *BTCSignMessageRequest) Reset() {
	*x = BTCSignMessageRequest{}
	mi := &file_btc_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignMessageRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignMessageRequest) ProtoMessage() {}

func (x *BTCSignMessageRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignMessageRequest.ProtoReflect.Descriptor instead.
func (*BTCSignMessageRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{17}
}

func (x *BTCSignMessageRequest) GetCoin() BTCCoin {
	if x != nil {
		return x.Coin
	}
	return BTCCoin_BTC
}

func (x *BTCSignMessageRequest) GetScriptConfig() *BTCScriptConfigWithKeypath {
	if x != nil {
		return x.ScriptConfig
	}
	return nil
}

func (x *BTCSignMessageRequest) GetMsg() []byte {
	if x != nil {
		return x.Msg
	}
	return nil
}

func (x *BTCSignMessageRequest) GetHostNonceCommitment() *AntiKleptoHostNonceCommitment {
	if x != nil {
		return x.HostNonceCommitment
	}
	return nil
}

type BTCSignMessageResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// 65 bytes (32 bytes big endian R, 32 bytes big endian S, 1 recid).
	Signature     []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCSignMessageResponse) Reset() {
	*x = BTCSignMessageResponse{}
	mi := &file_btc_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignMessageResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignMessageResponse) ProtoMessage() {}

func (x *BTCSignMessageResponse) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignMessageResponse.ProtoReflect.Descriptor instead.
func (*BTCSignMessageResponse) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{18}
}

func (x *BTCSignMessageResponse) GetSignature() []byte {
	if x != nil {
		return x.Signature
	}
	return nil
}

type BTCRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Request:
	//
	//	*BTCRequest_IsScriptConfigRegistered
	//	*BTCRequest_RegisterScriptConfig
	//	*BTCRequest_PrevtxInit
	//	*BTCRequest_PrevtxInput
	//	*BTCRequest_PrevtxOutput
	//	*BTCRequest_SignMessage
	//	*BTCRequest_AntikleptoSignature
	//	*BTCRequest_PaymentRequest
	//	*BTCRequest_Xpubs
	Request       isBTCRequest_Request `protobuf_oneof:"request"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCRequest) Reset() {
	*x = BTCRequest{}
	mi := &file_btc_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCRequest) ProtoMessage() {}

func (x *BTCRequest) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCRequest.ProtoReflect.Descriptor instead.
func (*BTCRequest) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{19}
}

func (x *BTCRequest) GetRequest() isBTCRequest_Request {
	if x != nil {
		return x.Request
	}
	return nil
}

func (x *BTCRequest) GetIsScriptConfigRegistered() *BTCIsScriptConfigRegisteredRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_IsScriptConfigRegistered); ok {
			return x.IsScriptConfigRegistered
		}
	}
	return nil
}

func (x *BTCRequest) GetRegisterScriptConfig() *BTCRegisterScriptConfigRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_RegisterScriptConfig); ok {
			return x.RegisterScriptConfig
		}
	}
	return nil
}

func (x *BTCRequest) GetPrevtxInit() *BTCPrevTxInitRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_PrevtxInit); ok {
			return x.PrevtxInit
		}
	}
	return nil
}

func (x *BTCRequest) GetPrevtxInput() *BTCPrevTxInputRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_PrevtxInput); ok {
			return x.PrevtxInput
		}
	}
	return nil
}

func (x *BTCRequest) GetPrevtxOutput() *BTCPrevTxOutputRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_PrevtxOutput); ok {
			return x.PrevtxOutput
		}
	}
	return nil
}

func (x *BTCRequest) GetSignMessage() *BTCSignMessageRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_SignMessage); ok {
			return x.SignMessage
		}
	}
	return nil
}

func (x *BTCRequest) GetAntikleptoSignature() *AntiKleptoSignatureRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_AntikleptoSignature); ok {
			return x.AntikleptoSignature
		}
	}
	return nil
}

func (x *BTCRequest) GetPaymentRequest() *BTCPaymentRequestRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_PaymentRequest); ok {
			return x.PaymentRequest
		}
	}
	return nil
}

func (x *BTCRequest) GetXpubs() *BTCXpubsRequest {
	if x != nil {
		if x, ok := x.Request.(*BTCRequest_Xpubs); ok {
			return x.Xpubs
		}
	}
	return nil
}

type isBTCRequest_Request interface {
	isBTCRequest_Request()
}

type BTCRequest_IsScriptConfigRegistered struct {
	IsScriptConfigRegistered *BTCIsScriptConfigRegisteredRequest `protobuf:"bytes,1,opt,name=is_script_config_registered,json=isScriptConfigRegistered,proto3,oneof"`
}

type BTCRequest_RegisterScriptConfig struct {
	RegisterScriptConfig *BTCRegisterScriptConfigRequest `protobuf:"bytes,2,opt,name=register_script_config,json=registerScriptConfig,proto3,oneof"`
}

type BTCRequest_PrevtxInit struct {
	PrevtxInit *BTCPrevTxInitRequest `protobuf:"bytes,3,opt,name=prevtx_init,json=prevtxInit,proto3,oneof"`
}

type BTCRequest_PrevtxInput struct {
	PrevtxInput *BTCPrevTxInputRequest `protobuf:"bytes,4,opt,name=prevtx_input,json=prevtxInput,proto3,oneof"`
}

type BTCRequest_PrevtxOutput struct {
	PrevtxOutput *BTCPrevTxOutputRequest `protobuf:"bytes,5,opt,name=prevtx_output,json=prevtxOutput,proto3,oneof"`
}

type BTCRequest_SignMessage struct {
	SignMessage *BTCSignMessageRequest `protobuf:"bytes,6,opt,name=sign_message,json=signMessage,proto3,oneof"`
}

type BTCRequest_AntikleptoSignature struct {
	AntikleptoSignature *AntiKleptoSignatureRequest `protobuf:"bytes,7,opt,name=antiklepto_signature,json=antikleptoSignature,proto3,oneof"`
}

type BTCRequest_PaymentRequest struct {
	PaymentRequest *BTCPaymentRequestRequest `protobuf:"bytes,8,opt,name=payment_request,json=paymentRequest,proto3,oneof"`
}

type BTCRequest_Xpubs struct {
	Xpubs *BTCXpubsRequest `protobuf:"bytes,9,opt,name=xpubs,proto3,oneof"`
}

func (*BTCRequest_IsScriptConfigRegistered) isBTCRequest_Request() {}

func (*BTCRequest_RegisterScriptConfig) isBTCRequest_Request() {}

func (*BTCRequest_PrevtxInit) isBTCRequest_Request() {}

func (*BTCRequest_PrevtxInput) isBTCRequest_Request() {}

func (*BTCRequest_PrevtxOutput) isBTCRequest_Request() {}

func (*BTCRequest_SignMessage) isBTCRequest_Request() {}

func (*BTCRequest_AntikleptoSignature) isBTCRequest_Request() {}

func (*BTCRequest_PaymentRequest) isBTCRequest_Request() {}

func (*BTCRequest_Xpubs) isBTCRequest_Request() {}

type BTCResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Response:
	//
	//	*BTCResponse_Success
	//	*BTCResponse_IsScriptConfigRegistered
	//	*BTCResponse_SignNext
	//	*BTCResponse_SignMessage
	//	*BTCResponse_AntikleptoSignerCommitment
	//	*BTCResponse_Pubs
	Response      isBTCResponse_Response `protobuf_oneof:"response"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCResponse) Reset() {
	*x = BTCResponse{}
	mi := &file_btc_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCResponse) ProtoMessage() {}

func (x *BTCResponse) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCResponse.ProtoReflect.Descriptor instead.
func (*BTCResponse) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{20}
}

func (x *BTCResponse) GetResponse() isBTCResponse_Response {
	if x != nil {
		return x.Response
	}
	return nil
}

func (x *BTCResponse) GetSuccess() *BTCSuccess {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_Success); ok {
			return x.Success
		}
	}
	return nil
}

func (x *BTCResponse) GetIsScriptConfigRegistered() *BTCIsScriptConfigRegisteredResponse {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_IsScriptConfigRegistered); ok {
			return x.IsScriptConfigRegistered
		}
	}
	return nil
}

func (x *BTCResponse) GetSignNext() *BTCSignNextResponse {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_SignNext); ok {
			return x.SignNext
		}
	}
	return nil
}

func (x *BTCResponse) GetSignMessage() *BTCSignMessageResponse {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_SignMessage); ok {
			return x.SignMessage
		}
	}
	return nil
}

func (x *BTCResponse) GetAntikleptoSignerCommitment() *AntiKleptoSignerCommitment {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_AntikleptoSignerCommitment); ok {
			return x.AntikleptoSignerCommitment
		}
	}
	return nil
}

func (x *BTCResponse) GetPubs() *PubsResponse {
	if x != nil {
		if x, ok := x.Response.(*BTCResponse_Pubs); ok {
			return x.Pubs
		}
	}
	return nil
}

type isBTCResponse_Response interface {
	isBTCResponse_Response()
}

type BTCResponse_Success struct {
	Success *BTCSuccess `protobuf:"bytes,1,opt,name=success,proto3,oneof"`
}

type BTCResponse_IsScriptConfigRegistered struct {
	IsScriptConfigRegistered *BTCIsScriptConfigRegisteredResponse `protobuf:"bytes,2,opt,name=is_script_config_registered,json=isScriptConfigRegistered,proto3,oneof"`
}

type BTCResponse_SignNext struct {
	SignNext *BTCSignNextResponse `protobuf:"bytes,3,opt,name=sign_next,json=signNext,proto3,oneof"`
}

type BTCResponse_SignMessage struct {
	SignMessage *BTCSignMessageResponse `protobuf:"bytes,4,opt,name=sign_message,json=signMessage,proto3,oneof"`
}

type BTCResponse_AntikleptoSignerCommitment struct {
	AntikleptoSignerCommitment *AntiKleptoSignerCommitment `protobuf:"bytes,5,opt,name=antiklepto_signer_commitment,json=antikleptoSignerCommitment,proto3,oneof"`
}

type BTCResponse_Pubs struct {
	Pubs *PubsResponse `protobuf:"bytes,6,opt,name=pubs,proto3,oneof"`
}

func (*BTCResponse_Success) isBTCResponse_Response() {}

func (*BTCResponse_IsScriptConfigRegistered) isBTCResponse_Response() {}

func (*BTCResponse_SignNext) isBTCResponse_Response() {}

func (*BTCResponse_SignMessage) isBTCResponse_Response() {}

func (*BTCResponse_AntikleptoSignerCommitment) isBTCResponse_Response() {}

func (*BTCResponse_Pubs) isBTCResponse_Response() {}

type BTCScriptConfig_Multisig struct {
	state     protoimpl.MessageState `protogen:"open.v1"`
	Threshold uint32                 `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold,omitempty"`
	// xpubs are acount-level xpubs. Addresses are going to be derived from it using: `m/<change>/<receive>`.
	// The number of xpubs defines the number of cosigners.
	Xpubs []*XPub `protobuf:"bytes,2,rep,name=xpubs,proto3" json:"xpubs,omitempty"`
	// Index to the xpub of our keystore in xpubs. The keypath to it is provided via
	// BTCPubRequest/BTCSignInit.
	OurXpubIndex  uint32                              `protobuf:"varint,3,opt,name=our_xpub_index,json=ourXpubIndex,proto3" json:"our_xpub_index,omitempty"`
	ScriptType    BTCScriptConfig_Multisig_ScriptType `protobuf:"varint,4,opt,name=script_type,json=scriptType,proto3,enum=shiftcrypto.bitbox02.BTCScriptConfig_Multisig_ScriptType" json:"script_type,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCScriptConfig_Multisig) Reset() {
	*x = BTCScriptConfig_Multisig{}
	mi := &file_btc_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCScriptConfig_Multisig) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCScriptConfig_Multisig) ProtoMessage() {}

func (x *BTCScriptConfig_Multisig) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCScriptConfig_Multisig.ProtoReflect.Descriptor instead.
func (*BTCScriptConfig_Multisig) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0, 0}
}

func (x *BTCScriptConfig_Multisig) GetThreshold() uint32 {
	if x != nil {
		return x.Threshold
	}
	return 0
}

func (x *BTCScriptConfig_Multisig) GetXpubs() []*XPub {
	if x != nil {
		return x.Xpubs
	}
	return nil
}

func (x *BTCScriptConfig_Multisig) GetOurXpubIndex() uint32 {
	if x != nil {
		return x.OurXpubIndex
	}
	return 0
}

func (x *BTCScriptConfig_Multisig) GetScriptType() BTCScriptConfig_Multisig_ScriptType {
	if x != nil {
		return x.ScriptType
	}
	return BTCScriptConfig_Multisig_P2WSH
}

// A policy as specified by 'Wallet policies':
// https://github.com/bitcoin/bips/pull/1389
type BTCScriptConfig_Policy struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Policy        string                 `protobuf:"bytes,1,opt,name=policy,proto3" json:"policy,omitempty"`
	Keys          []*KeyOriginInfo       `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCScriptConfig_Policy) Reset() {
	*x = BTCScriptConfig_Policy{}
	mi := &file_btc_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCScriptConfig_Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCScriptConfig_Policy) ProtoMessage() {}

func (x *BTCScriptConfig_Policy) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCScriptConfig_Policy.ProtoReflect.Descriptor instead.
func (*BTCScriptConfig_Policy) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{0, 1}
}

func (x *BTCScriptConfig_Policy) GetPolicy() string {
	if x != nil {
		return x.Policy
	}
	return ""
}

func (x *BTCScriptConfig_Policy) GetKeys() []*KeyOriginInfo {
	if x != nil {
		return x.Keys
	}
	return nil
}

// https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki
type BTCSignOutputRequest_SilentPayment struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Address       string                 `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCSignOutputRequest_SilentPayment) Reset() {
	*x = BTCSignOutputRequest_SilentPayment{}
	mi := &file_btc_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCSignOutputRequest_SilentPayment) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCSignOutputRequest_SilentPayment) ProtoMessage() {}

func (x *BTCSignOutputRequest_SilentPayment) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCSignOutputRequest_SilentPayment.ProtoReflect.Descriptor instead.
func (*BTCSignOutputRequest_SilentPayment) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{7, 0}
}

func (x *BTCSignOutputRequest_SilentPayment) GetAddress() string {
	if x != nil {
		return x.Address
	}
	return ""
}

type BTCPaymentRequestRequest_Memo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Memo:
	//
	//	*BTCPaymentRequestRequest_Memo_TextMemo_
	Memo          isBTCPaymentRequestRequest_Memo_Memo `protobuf_oneof:"memo"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPaymentRequestRequest_Memo) Reset() {
	*x = BTCPaymentRequestRequest_Memo{}
	mi := &file_btc_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPaymentRequestRequest_Memo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPaymentRequestRequest_Memo) ProtoMessage() {}

func (x *BTCPaymentRequestRequest_Memo) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPaymentRequestRequest_Memo.ProtoReflect.Descriptor instead.
func (*BTCPaymentRequestRequest_Memo) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{16, 0}
}

func (x *BTCPaymentRequestRequest_Memo) GetMemo() isBTCPaymentRequestRequest_Memo_Memo {
	if x != nil {
		return x.Memo
	}
	return nil
}

func (x *BTCPaymentRequestRequest_Memo) GetTextMemo() *BTCPaymentRequestRequest_Memo_TextMemo {
	if x != nil {
		if x, ok := x.Memo.(*BTCPaymentRequestRequest_Memo_TextMemo_); ok {
			return x.TextMemo
		}
	}
	return nil
}

type isBTCPaymentRequestRequest_Memo_Memo interface {
	isBTCPaymentRequestRequest_Memo_Memo()
}

type BTCPaymentRequestRequest_Memo_TextMemo_ struct {
	TextMemo *BTCPaymentRequestRequest_Memo_TextMemo `protobuf:"bytes,1,opt,name=text_memo,json=textMemo,proto3,oneof"`
}

func (*BTCPaymentRequestRequest_Memo_TextMemo_) isBTCPaymentRequestRequest_Memo_Memo() {}

type BTCPaymentRequestRequest_Memo_TextMemo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Note          string                 `protobuf:"bytes,1,opt,name=note,proto3" json:"note,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *BTCPaymentRequestRequest_Memo_TextMemo) Reset() {
	*x = BTCPaymentRequestRequest_Memo_TextMemo{}
	mi := &file_btc_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *BTCPaymentRequestRequest_Memo_TextMemo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*BTCPaymentRequestRequest_Memo_TextMemo) ProtoMessage() {}

func (x *BTCPaymentRequestRequest_Memo_TextMemo) ProtoReflect() protoreflect.Message {
	mi := &file_btc_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use BTCPaymentRequestRequest_Memo_TextMemo.ProtoReflect.Descriptor instead.
func (*BTCPaymentRequestRequest_Memo_TextMemo) Descriptor() ([]byte, []int) {
	return file_btc_proto_rawDescGZIP(), []int{16, 0, 0}
}

func (x *BTCPaymentRequestRequest_Memo_TextMemo) GetNote() string {
	if x != nil {
		return x.Note
	}
	return ""
}

var File_btc_proto protoreflect.FileDescriptor

const file_btc_proto_rawDesc = "" +
	"\n" +
	"\tbtc.proto\x12\x14shiftcrypto.bitbox02\x1a\fcommon.proto\x1a\x10antiklepto.proto\"\x9e\x05\n" +
	"\x0fBTCScriptConfig\x12S\n" +
	"\vsimple_type\x18\x01 \x01(\x0e20.shiftcrypto.bitbox02.BTCScriptConfig.SimpleTypeH\x00R\n" +
	"simpleType\x12L\n" +
	"\bmultisig\x18\x02 \x01(\v2..shiftcrypto.bitbox02.BTCScriptConfig.MultisigH\x00R\bmultisig\x12F\n" +
	"\x06policy\x18\x03 \x01(\v2,.shiftcrypto.bitbox02.BTCScriptConfig.PolicyH\x00R\x06policy\x1a\x85\x02\n" +
	"\bMultisig\x12\x1c\n" +
	"\tthreshold\x18\x01 \x01(\rR\tthreshold\x120\n" +
	"\x05xpubs\x18\x02 \x03(\v2\x1a.shiftcrypto.bitbox02.XPubR\x05xpubs\x12$\n" +
	"\x0eour_xpub_index\x18\x03 \x01(\rR\fourXpubIndex\x12Z\n" +
	"\vscript_type\x18\x04 \x01(\x0e29.shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptTypeR\n" +
	"scriptType\"'\n" +
	"\n" +
	"ScriptType\x12\t\n" +
	"\x05P2WSH\x10\x00\x12\x0e\n" +
	"\n" +
	"P2WSH_P2SH\x10\x01\x1aY\n" +
	"\x06Policy\x12\x16\n" +
	"\x06policy\x18\x01 \x01(\tR\x06policy\x127\n" +
	"\x04keys\x18\x02 \x03(\v2#.shiftcrypto.bitbox02.KeyOriginInfoR\x04keys\"3\n" +
	"\n" +
	"SimpleType\x12\x0f\n" +
	"\vP2WPKH_P2SH\x10\x00\x12\n" +
	"\n" +
	"\x06P2WPKH\x10\x01\x12\b\n" +
	"\x04P2TR\x10\x02B\b\n" +
	"\x06config\"\xac\x03\n" +
	"\rBTCPubRequest\x121\n" +
	"\x04coin\x18\x01 \x01(\x0e2\x1d.shiftcrypto.bitbox02.BTCCoinR\x04coin\x12\x18\n" +
	"\akeypath\x18\x02 \x03(\rR\akeypath\x12K\n" +
	"\txpub_type\x18\x03 \x01(\x0e2,.shiftcrypto.bitbox02.BTCPubRequest.XPubTypeH\x00R\bxpubType\x12L\n" +
	"\rscript_config\x18\x04 \x01(\v2%.shiftcrypto.bitbox02.BTCScriptConfigH\x00R\fscriptConfig\x12\x18\n" +
	"\adisplay\x18\x05 \x01(\bR\adisplay\"\x8e\x01\n" +
	"\bXPubType\x12\b\n" +
	"\x04TPUB\x10\x00\x12\b\n" +
	"\x04XPUB\x10\x01\x12\b\n" +
	"\x04YPUB\x10\x02\x12\b\n" +
	"\x04ZPUB\x10\x03\x12\b\n" +
	"\x04VPUB\x10\x04\x12\b\n" +
	"\x04UPUB\x10\x05\x12\x10\n" +
	"\fCAPITAL_VPUB\x10\x06\x12\x10\n" +
	"\fCAPITAL_ZPUB\x10\a\x12\x10\n" +
	"\fCAPITAL_UPUB\x10\b\x12\x10\n" +
	"\fCAPITAL_YPUB\x10\tB\b\n" +
	"\x06output\"\xf9\x01\n" +
	"\x0fBTCXpubsRequest\x121\n" +
	"\x04coin\x18\x01 \x01(\x0e2\x1d.shiftcrypto.bitbox02.BTCCoinR\x04coin\x12K\n" +
	"\txpub_type\x18\x02 \x01(\x0e2..shiftcrypto.bitbox02.BTCXpubsRequest.XPubTypeR\bxpubType\x129\n" +
	"\bkeypaths\x18\x03 \x03(\v2\x1d.shiftcrypto.bitbox02.KeypathR\bkeypaths\"+\n" +
	"\bXPubType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\b\n" +
	"\x04XPUB\x10\x01\x12\b\n" +
	"\x04TPUB\x10\x02\"\x82\x01\n" +
	"\x1aBTCScriptConfigWithKeypath\x12J\n" +
	"\rscript_config\x18\x02 \x01(\v2%.shiftcrypto.bitbox02.BTCScriptConfigR\fscriptConfig\x12\x18\n" +
	"\akeypath\x18\x03 \x03(\rR\akeypath\"\xbd\x04\n" +
	"\x12BTCSignInitRequest\x121\n" +
	"\x04coin\x18\x01 \x01(\x0e2\x1d.shiftcrypto.bitbox02.BTCCoinR\x04coin\x12W\n" +
	"\x0escript_configs\x18\x02 \x03(\v20.shiftcrypto.bitbox02.BTCScriptConfigWithKeypathR\rscriptConfigs\x12\x18\n" +
	"\aversion\x18\x04 \x01(\rR\aversion\x12\x1d\n" +
	"\n" +
	"num_inputs\x18\x05 \x01(\rR\tnumInputs\x12\x1f\n" +
	"\vnum_outputs\x18\x06 \x01(\rR\n" +
	"numOutputs\x12\x1a\n" +
	"\blocktime\x18\a \x01(\rR\blocktime\x12T\n" +
	"\vformat_unit\x18\b \x01(\x0e23.shiftcrypto.bitbox02.BTCSignInitRequest.FormatUnitR\n" +
	"formatUnit\x12E\n" +
	"\x1fcontains_silent_payment_outputs\x18\t \x01(\bR\x1ccontainsSilentPaymentOutputs\x12d\n" +
	"\x15output_script_configs\x18\n" +
	" \x03(\v20.shiftcrypto.bitbox02.BTCScriptConfigWithKeypathR\x13outputScriptConfigs\"\"\n" +
	"\n" +
	"FormatUnit\x12\v\n" +
	"\aDEFAULT\x10\x00\x12\a\n" +
	"\x03SAT\x10\x01\"\xc2\x04\n" +
	"\x13BTCSignNextResponse\x12B\n" +
	"\x04type\x18\x01 \x01(\x0e2..shiftcrypto.bitbox02.BTCSignNextResponse.TypeR\x04type\x12\x14\n" +
	"\x05index\x18\x02 \x01(\rR\x05index\x12#\n" +
	"\rhas_signature\x18\x03 \x01(\bR\fhasSignature\x12\x1c\n" +
	"\tsignature\x18\x04 \x01(\fR\tsignature\x12\x1d\n" +
	"\n" +
	"prev_index\x18\x05 \x01(\rR\tprevIndex\x12s\n" +
	"\x1danti_klepto_signer_commitment\x18\x06 \x01(\v20.shiftcrypto.bitbox02.AntiKleptoSignerCommitmentR\x1aantiKleptoSignerCommitment\x12:\n" +
	"\x19generated_output_pkscript\x18\a \x01(\fR\x17generatedOutputPkscript\x129\n" +
	"\x19silent_payment_dleq_proof\x18\b \x01(\fR\x16silentPaymentDleqProof\"\x82\x01\n" +
	"\x04Type\x12\t\n" +
	"\x05INPUT\x10\x00\x12\n" +
	"\n" +
	"\x06OUTPUT\x10\x01\x12\b\n" +
	"\x04DONE\x10\x02\x12\x0f\n" +
	"\vPREVTX_INIT\x10\x03\x12\x10\n" +
	"\fPREVTX_INPUT\x10\x04\x12\x11\n" +
	"\rPREVTX_OUTPUT\x10\x05\x12\x0e\n" +
	"\n" +
	"HOST_NONCE\x10\x06\x12\x13\n" +
	"\x0fPAYMENT_REQUEST\x10\a\"\xce\x02\n" +
	"\x13BTCSignInputRequest\x12 \n" +
	"\vprevOutHash\x18\x01 \x01(\fR\vprevOutHash\x12\"\n" +
	"\fprevOutIndex\x18\x02 \x01(\rR\fprevOutIndex\x12\"\n" +
	"\fprevOutValue\x18\x03 \x01(\x04R\fprevOutValue\x12\x1a\n" +
	"\bsequence\x18\x04 \x01(\rR\bsequence\x12\x18\n" +
	"\akeypath\x18\x06 \x03(\rR\akeypath\x12.\n" +
	"\x13script_config_index\x18\a \x01(\rR\x11scriptConfigIndex\x12g\n" +
	"\x15host_nonce_commitment\x18\b \x01(\v23.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitmentR\x13hostNonceCommitment\"\x9d\x04\n" +
	"\x14BTCSignOutputRequest\x12\x12\n" +
	"\x04ours\x18\x01 \x01(\bR\x04ours\x127\n" +
	"\x04type\x18\x02 \x01(\x0e2#.shiftcrypto.bitbox02.BTCOutputTypeR\x04type\x12\x14\n" +
	"\x05value\x18\x03 \x01(\x04R\x05value\x12\x18\n" +
	"\apayload\x18\x04 \x01(\fR\apayload\x12\x18\n" +
	"\akeypath\x18\x05 \x03(\rR\akeypath\x12.\n" +
	"\x13script_config_index\x18\x06 \x01(\rR\x11scriptConfigIndex\x127\n" +
	"\x15payment_request_index\x18\a \x01(\rH\x00R\x13paymentRequestIndex\x88\x01\x01\x12_\n" +
	"\x0esilent_payment\x18\b \x01(\v28.shiftcrypto.bitbox02.BTCSignOutputRequest.SilentPaymentR\rsilentPayment\x12@\n" +
	"\x1aoutput_script_config_index\x18\t \x01(\rH\x01R\x17outputScriptConfigIndex\x88\x01\x01\x1a)\n" +
	"\rSilentPayment\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\tR\aaddressB\x18\n" +
	"\x16_payment_request_indexB\x1d\n" +
	"\x1b_output_script_config_index\"\xb6\x01\n" +
	"\x1bBTCScriptConfigRegistration\x121\n" +
	"\x04coin\x18\x01 \x01(\x0e2\x1d.shiftcrypto.bitbox02.BTCCoinR\x04coin\x12J\n" +
	"\rscript_config\x18\x02 \x01(\v2%.shiftcrypto.bitbox02.BTCScriptConfigR\fscriptConfig\x12\x18\n" +
	"\akeypath\x18\x03 \x03(\rR\akeypath\"\f\n" +
	"\n" +
	"BTCSuccess\"{\n" +
	"\"BTCIsScriptConfigRegisteredRequest\x12U\n" +
	"\fregistration\x18\x01 \x01(\v21.shiftcrypto.bitbox02.BTCScriptConfigRegistrationR\fregistration\"J\n" +
	"#BTCIsScriptConfigRegisteredResponse\x12#\n" +
	"\ris_registered\x18\x01 \x01(\bR\fisRegistered\"\x9a\x02\n" +
	"\x1eBTCRegisterScriptConfigRequest\x12U\n" +
	"\fregistration\x18\x01 \x01(\v21.shiftcrypto.bitbox02.BTCScriptConfigRegistrationR\fregistration\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12Z\n" +
	"\txpub_type\x18\x03 \x01(\x0e2=.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubTypeR\bxpubType\"1\n" +
	"\bXPubType\x12\x11\n" +
	"\rAUTO_ELECTRUM\x10\x00\x12\x12\n" +
	"\x0eAUTO_XPUB_TPUB\x10\x01\"\x8c\x01\n" +
	"\x14BTCPrevTxInitRequest\x12\x18\n" +
	"\aversion\x18\x01 \x01(\rR\aversion\x12\x1d\n" +
	"\n" +
	"num_inputs\x18\x02 \x01(\rR\tnumInputs\x12\x1f\n" +
	"\vnum_outputs\x18\x03 \x01(\rR\n" +
	"numOutputs\x12\x1a\n" +
	"\blocktime\x18\x04 \x01(\rR\blocktime\"\xa8\x01\n" +
	"\x15BTCPrevTxInputRequest\x12\"\n" +
	"\rprev_out_hash\x18\x01 \x01(\fR\vprevOutHash\x12$\n" +
	"\x0eprev_out_index\x18\x02 \x01(\rR\fprevOutIndex\x12)\n" +
	"\x10signature_script\x18\x03 \x01(\fR\x0fsignatureScript\x12\x1a\n" +
	"\bsequence\x18\x04 \x01(\rR\bsequence\"S\n" +
	"\x16BTCPrevTxOutputRequest\x12\x14\n" +
	"\x05value\x18\x01 \x01(\x04R\x05value\x12#\n" +
	"\rpubkey_script\x18\x02 \x01(\fR\fpubkeyScript\"\xf1\x02\n" +
	"\x18BTCPaymentRequestRequest\x12%\n" +
	"\x0erecipient_name\x18\x01 \x01(\tR\rrecipientName\x12I\n" +
	"\x05memos\x18\x02 \x03(\v23.shiftcrypto.bitbox02.BTCPaymentRequestRequest.MemoR\x05memos\x12\x14\n" +
	"\x05nonce\x18\x03 \x01(\fR\x05nonce\x12!\n" +
	"\ftotal_amount\x18\x04 \x01(\x04R\vtotalAmount\x12\x1c\n" +
	"\tsignature\x18\x05 \x01(\fR\tsignature\x1a\x8b\x01\n" +
	"\x04Memo\x12[\n" +
	"\ttext_memo\x18\x01 \x01(\v2<.shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo.TextMemoH\x00R\btextMemo\x1a\x1e\n" +
	"\bTextMemo\x12\x12\n" +
	"\x04note\x18\x01 \x01(\tR\x04noteB\x06\n" +
	"\x04memo\"\x9c\x02\n" +
	"\x15BTCSignMessageRequest\x121\n" +
	"\x04coin\x18\x01 \x01(\x0e2\x1d.shiftcrypto.bitbox02.BTCCoinR\x04coin\x12U\n" +
	"\rscript_config\x18\x02 \x01(\v20.shiftcrypto.bitbox02.BTCScriptConfigWithKeypathR\fscriptConfig\x12\x10\n" +
	"\x03msg\x18\x03 \x01(\fR\x03msg\x12g\n" +
	"\x15host_nonce_commitment\x18\x04 \x01(\v23.shiftcrypto.bitbox02.AntiKleptoHostNonceCommitmentR\x13hostNonceCommitment\"6\n" +
	"\x16BTCSignMessageResponse\x12\x1c\n" +
	"\tsignature\x18\x01 \x01(\fR\tsignature\"\xc9\x06\n" +
	"\n" +
	"BTCRequest\x12y\n" +
	"\x1bis_script_config_registered\x18\x01 \x01(\v28.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequestH\x00R\x18isScriptConfigRegistered\x12l\n" +
	"\x16register_script_config\x18\x02 \x01(\v24.shiftcrypto.bitbox02.BTCRegisterScriptConfigRequestH\x00R\x14registerScriptConfig\x12M\n" +
	"\vprevtx_init\x18\x03 \x01(\v2*.shiftcrypto.bitbox02.BTCPrevTxInitRequestH\x00R\n" +
	"prevtxInit\x12P\n" +
	"\fprevtx_input\x18\x04 \x01(\v2+.shiftcrypto.bitbox02.BTCPrevTxInputRequestH\x00R\vprevtxInput\x12S\n" +
	"\rprevtx_output\x18\x05 \x01(\v2,.shiftcrypto.bitbox02.BTCPrevTxOutputRequestH\x00R\fprevtxOutput\x12P\n" +
	"\fsign_message\x18\x06 \x01(\v2+.shiftcrypto.bitbox02.BTCSignMessageRequestH\x00R\vsignMessage\x12e\n" +
	"\x14antiklepto_signature\x18\a \x01(\v20.shiftcrypto.bitbox02.AntiKleptoSignatureRequestH\x00R\x13antikleptoSignature\x12Y\n" +
	"\x0fpayment_request\x18\b \x01(\v2..shiftcrypto.bitbox02.BTCPaymentRequestRequestH\x00R\x0epaymentRequest\x12=\n" +
	"\x05xpubs\x18\t \x01(\v2%.shiftcrypto.bitbox02.BTCXpubsRequestH\x00R\x05xpubsB\t\n" +
	"\arequest\"\xa0\x04\n" +
	"\vBTCResponse\x12<\n" +
	"\asuccess\x18\x01 \x01(\v2 .shiftcrypto.bitbox02.BTCSuccessH\x00R\asuccess\x12z\n" +
	"\x1bis_script_config_registered\x18\x02 \x01(\v29.shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponseH\x00R\x18isScriptConfigRegistered\x12H\n" +
	"\tsign_next\x18\x03 \x01(\v2).shiftcrypto.bitbox02.BTCSignNextResponseH\x00R\bsignNext\x12Q\n" +
	"\fsign_message\x18\x04 \x01(\v2,.shiftcrypto.bitbox02.BTCSignMessageResponseH\x00R\vsignMessage\x12t\n" +
	"\x1cantiklepto_signer_commitment\x18\x05 \x01(\v20.shiftcrypto.bitbox02.AntiKleptoSignerCommitmentH\x00R\x1aantikleptoSignerCommitment\x128\n" +
	"\x04pubs\x18\x06 \x01(\v2\".shiftcrypto.bitbox02.PubsResponseH\x00R\x04pubsB\n" +
	"\n" +
	"\bresponse*9\n" +
	"\aBTCCoin\x12\a\n" +
	"\x03BTC\x10\x00\x12\b\n" +
	"\x04TBTC\x10\x01\x12\a\n" +
	"\x03LTC\x10\x02\x12\b\n" +
	"\x04TLTC\x10\x03\x12\b\n" +
	"\x04RBTC\x10\x04*a\n" +
	"\rBTCOutputType\x12\v\n" +
	"\aUNKNOWN\x10\x00\x12\t\n" +
	"\x05P2PKH\x10\x01\x12\b\n" +
	"\x04P2SH\x10\x02\x12\n" +
	"\n" +
	"\x06P2WPKH\x10\x03\x12\t\n" +
	"\x05P2WSH\x10\x04\x12\b\n" +
	"\x04P2TR\x10\x05\x12\r\n" +
	"\tOP_RETURN\x10\x06b\x06proto3"

var (
	file_btc_proto_rawDescOnce sync.Once
	file_btc_proto_rawDescData []byte
)

func file_btc_proto_rawDescGZIP() []byte {
	file_btc_proto_rawDescOnce.Do(func() {
		file_btc_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_btc_proto_rawDesc), len(file_btc_proto_rawDesc)))
	})
	return file_btc_proto_rawDescData
}

var file_btc_proto_enumTypes = make([]protoimpl.EnumInfo, 9)
var file_btc_proto_msgTypes = make([]protoimpl.MessageInfo, 26)
var file_btc_proto_goTypes = []any{
	(BTCCoin)(0),                                   // 0: shiftcrypto.bitbox02.BTCCoin
	(BTCOutputType)(0),                             // 1: shiftcrypto.bitbox02.BTCOutputType
	(BTCScriptConfig_SimpleType)(0),                // 2: shiftcrypto.bitbox02.BTCScriptConfig.SimpleType
	(BTCScriptConfig_Multisig_ScriptType)(0),       // 3: shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType
	(BTCPubRequest_XPubType)(0),                    // 4: shiftcrypto.bitbox02.BTCPubRequest.XPubType
	(BTCXpubsRequest_XPubType)(0),                  // 5: shiftcrypto.bitbox02.BTCXpubsRequest.XPubType
	(BTCSignInitRequest_FormatUnit)(0),             // 6: shiftcrypto.bitbox02.BTCSignInitRequest.FormatUnit
	(BTCSignNextResponse_Type)(0),                  // 7: shiftcrypto.bitbox02.BTCSignNextResponse.Type
	(BTCRegisterScriptConfigRequest_XPubType)(0),   // 8: shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType
	(*BTCScriptConfig)(nil),                        // 9: shiftcrypto.bitbox02.BTCScriptConfig
	(*BTCPubRequest)(nil),                          // 10: shiftcrypto.bitbox02.BTCPubRequest
	(*BTCXpubsRequest)(nil),                        // 11: shiftcrypto.bitbox02.BTCXpubsRequest
	(*BTCScriptConfigWithKeypath)(nil),             // 12: shiftcrypto.bitbox02.BTCScriptConfigWithKeypath
	(*BTCSignInitRequest)(nil),                     // 13: shiftcrypto.bitbox02.BTCSignInitRequest
	(*BTCSignNextResponse)(nil),                    // 14: shiftcrypto.bitbox02.BTCSignNextResponse
	(*BTCSignInputRequest)(nil),                    // 15: shiftcrypto.bitbox02.BTCSignInputRequest
	(*BTCSignOutputRequest)(nil),                   // 16: shiftcrypto.bitbox02.BTCSignOutputRequest
	(*BTCScriptConfigRegistration)(nil),            // 17: shiftcrypto.bitbox02.BTCScriptConfigRegistration
	(*BTCSuccess)(nil),                             // 18: shiftcrypto.bitbox02.BTCSuccess
	(*BTCIsScriptConfigRegisteredRequest)(nil),     // 19: shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest
	(*BTCIsScriptConfigRegisteredResponse)(nil),    // 20: shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse
	(*BTCRegisterScriptConfigRequest)(nil),         // 21: shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest
	(*BTCPrevTxInitRequest)(nil),                   // 22: shiftcrypto.bitbox02.BTCPrevTxInitRequest
	(*BTCPrevTxInputRequest)(nil),                  // 23: shiftcrypto.bitbox02.BTCPrevTxInputRequest
	(*BTCPrevTxOutputRequest)(nil),                 // 24: shiftcrypto.bitbox02.BTCPrevTxOutputRequest
	(*BTCPaymentRequestRequest)(nil),               // 25: shiftcrypto.bitbox02.BTCPaymentRequestRequest
	(*BTCSignMessageRequest)(nil),                  // 26: shiftcrypto.bitbox02.BTCSignMessageRequest
	(*BTCSignMessageResponse)(nil),                 // 27: shiftcrypto.bitbox02.BTCSignMessageResponse
	(*BTCRequest)(nil),                             // 28: shiftcrypto.bitbox02.BTCRequest
	(*BTCResponse)(nil),                            // 29: shiftcrypto.bitbox02.BTCResponse
	(*BTCScriptConfig_Multisig)(nil),               // 30: shiftcrypto.bitbox02.BTCScriptConfig.Multisig
	(*BTCScriptConfig_Policy)(nil),                 // 31: shiftcrypto.bitbox02.BTCScriptConfig.Policy
	(*BTCSignOutputRequest_SilentPayment)(nil),     // 32: shiftcrypto.bitbox02.BTCSignOutputRequest.SilentPayment
	(*BTCPaymentRequestRequest_Memo)(nil),          // 33: shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo
	(*BTCPaymentRequestRequest_Memo_TextMemo)(nil), // 34: shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo.TextMemo
	(*Keypath)(nil),                                // 35: shiftcrypto.bitbox02.Keypath
	(*AntiKleptoSignerCommitment)(nil),             // 36: shiftcrypto.bitbox02.AntiKleptoSignerCommitment
	(*AntiKleptoHostNonceCommitment)(nil),          // 37: shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment
	(*AntiKleptoSignatureRequest)(nil),             // 38: shiftcrypto.bitbox02.AntiKleptoSignatureRequest
	(*PubsResponse)(nil),                           // 39: shiftcrypto.bitbox02.PubsResponse
	(*XPub)(nil),                                   // 40: shiftcrypto.bitbox02.XPub
	(*KeyOriginInfo)(nil),                          // 41: shiftcrypto.bitbox02.KeyOriginInfo
}
var file_btc_proto_depIdxs = []int32{
	2,  // 0: shiftcrypto.bitbox02.BTCScriptConfig.simple_type:type_name -> shiftcrypto.bitbox02.BTCScriptConfig.SimpleType
	30, // 1: shiftcrypto.bitbox02.BTCScriptConfig.multisig:type_name -> shiftcrypto.bitbox02.BTCScriptConfig.Multisig
	31, // 2: shiftcrypto.bitbox02.BTCScriptConfig.policy:type_name -> shiftcrypto.bitbox02.BTCScriptConfig.Policy
	0,  // 3: shiftcrypto.bitbox02.BTCPubRequest.coin:type_name -> shiftcrypto.bitbox02.BTCCoin
	4,  // 4: shiftcrypto.bitbox02.BTCPubRequest.xpub_type:type_name -> shiftcrypto.bitbox02.BTCPubRequest.XPubType
	9,  // 5: shiftcrypto.bitbox02.BTCPubRequest.script_config:type_name -> shiftcrypto.bitbox02.BTCScriptConfig
	0,  // 6: shiftcrypto.bitbox02.BTCXpubsRequest.coin:type_name -> shiftcrypto.bitbox02.BTCCoin
	5,  // 7: shiftcrypto.bitbox02.BTCXpubsRequest.xpub_type:type_name -> shiftcrypto.bitbox02.BTCXpubsRequest.XPubType
	35, // 8: shiftcrypto.bitbox02.BTCXpubsRequest.keypaths:type_name -> shiftcrypto.bitbox02.Keypath
	9,  // 9: shiftcrypto.bitbox02.BTCScriptConfigWithKeypath.script_config:type_name -> shiftcrypto.bitbox02.BTCScriptConfig
	0,  // 10: shiftcrypto.bitbox02.BTCSignInitRequest.coin:type_name -> shiftcrypto.bitbox02.BTCCoin
	12, // 11: shiftcrypto.bitbox02.BTCSignInitRequest.script_configs:type_name -> shiftcrypto.bitbox02.BTCScriptConfigWithKeypath
	6,  // 12: shiftcrypto.bitbox02.BTCSignInitRequest.format_unit:type_name -> shiftcrypto.bitbox02.BTCSignInitRequest.FormatUnit
	12, // 13: shiftcrypto.bitbox02.BTCSignInitRequest.output_script_configs:type_name -> shiftcrypto.bitbox02.BTCScriptConfigWithKeypath
	7,  // 14: shiftcrypto.bitbox02.BTCSignNextResponse.type:type_name -> shiftcrypto.bitbox02.BTCSignNextResponse.Type
	36, // 15: shiftcrypto.bitbox02.BTCSignNextResponse.anti_klepto_signer_commitment:type_name -> shiftcrypto.bitbox02.AntiKleptoSignerCommitment
	37, // 16: shiftcrypto.bitbox02.BTCSignInputRequest.host_nonce_commitment:type_name -> shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment
	1,  // 17: shiftcrypto.bitbox02.BTCSignOutputRequest.type:type_name -> shiftcrypto.bitbox02.BTCOutputType
	32, // 18: shiftcrypto.bitbox02.BTCSignOutputRequest.silent_payment:type_name -> shiftcrypto.bitbox02.BTCSignOutputRequest.SilentPayment
	0,  // 19: shiftcrypto.bitbox02.BTCScriptConfigRegistration.coin:type_name -> shiftcrypto.bitbox02.BTCCoin
	9,  // 20: shiftcrypto.bitbox02.BTCScriptConfigRegistration.script_config:type_name -> shiftcrypto.bitbox02.BTCScriptConfig
	17, // 21: shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest.registration:type_name -> shiftcrypto.bitbox02.BTCScriptConfigRegistration
	17, // 22: shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.registration:type_name -> shiftcrypto.bitbox02.BTCScriptConfigRegistration
	8,  // 23: shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.xpub_type:type_name -> shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest.XPubType
	33, // 24: shiftcrypto.bitbox02.BTCPaymentRequestRequest.memos:type_name -> shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo
	0,  // 25: shiftcrypto.bitbox02.BTCSignMessageRequest.coin:type_name -> shiftcrypto.bitbox02.BTCCoin
	12, // 26: shiftcrypto.bitbox02.BTCSignMessageRequest.script_config:type_name -> shiftcrypto.bitbox02.BTCScriptConfigWithKeypath
	37, // 27: shiftcrypto.bitbox02.BTCSignMessageRequest.host_nonce_commitment:type_name -> shiftcrypto.bitbox02.AntiKleptoHostNonceCommitment
	19, // 28: shiftcrypto.bitbox02.BTCRequest.is_script_config_registered:type_name -> shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredRequest
	21, // 29: shiftcrypto.bitbox02.BTCRequest.register_script_config:type_name -> shiftcrypto.bitbox02.BTCRegisterScriptConfigRequest
	22, // 30: shiftcrypto.bitbox02.BTCRequest.prevtx_init:type_name -> shiftcrypto.bitbox02.BTCPrevTxInitRequest
	23, // 31: shiftcrypto.bitbox02.BTCRequest.prevtx_input:type_name -> shiftcrypto.bitbox02.BTCPrevTxInputRequest
	24, // 32: shiftcrypto.bitbox02.BTCRequest.prevtx_output:type_name -> shiftcrypto.bitbox02.BTCPrevTxOutputRequest
	26, // 33: shiftcrypto.bitbox02.BTCRequest.sign_message:type_name -> shiftcrypto.bitbox02.BTCSignMessageRequest
	38, // 34: shiftcrypto.bitbox02.BTCRequest.antiklepto_signature:type_name -> shiftcrypto.bitbox02.AntiKleptoSignatureRequest
	25, // 35: shiftcrypto.bitbox02.BTCRequest.payment_request:type_name -> shiftcrypto.bitbox02.BTCPaymentRequestRequest
	11, // 36: shiftcrypto.bitbox02.BTCRequest.xpubs:type_name -> shiftcrypto.bitbox02.BTCXpubsRequest
	18, // 37: shiftcrypto.bitbox02.BTCResponse.success:type_name -> shiftcrypto.bitbox02.BTCSuccess
	20, // 38: shiftcrypto.bitbox02.BTCResponse.is_script_config_registered:type_name -> shiftcrypto.bitbox02.BTCIsScriptConfigRegisteredResponse
	14, // 39: shiftcrypto.bitbox02.BTCResponse.sign_next:type_name -> shiftcrypto.bitbox02.BTCSignNextResponse
	27, // 40: shiftcrypto.bitbox02.BTCResponse.sign_message:type_name -> shiftcrypto.bitbox02.BTCSignMessageResponse
	36, // 41: shiftcrypto.bitbox02.BTCResponse.antiklepto_signer_commitment:type_name -> shiftcrypto.bitbox02.AntiKleptoSignerCommitment
	39, // 42: shiftcrypto.bitbox02.BTCResponse.pubs:type_name -> shiftcrypto.bitbox02.PubsResponse
	40, // 43: shiftcrypto.bitbox02.BTCScriptConfig.Multisig.xpubs:type_name -> shiftcrypto.bitbox02.XPub
	3,  // 44: shiftcrypto.bitbox02.BTCScriptConfig.Multisig.script_type:type_name -> shiftcrypto.bitbox02.BTCScriptConfig.Multisig.ScriptType
	41, // 45: shiftcrypto.bitbox02.BTCScriptConfig.Policy.keys:type_name -> shiftcrypto.bitbox02.KeyOriginInfo
	34, // 46: shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo.text_memo:type_name -> shiftcrypto.bitbox02.BTCPaymentRequestRequest.Memo.TextMemo
	47, // [47:47] is the sub-list for method output_type
	47, // [47:47] is the sub-list for method input_type
	47, // [47:47] is the sub-list for extension type_name
	47, // [47:47] is the sub-list for extension extendee
	0,  // [0:47] is the sub-list for field type_name
}

func init() { file_btc_proto_init() }
func file_btc_proto_init() {
	if File_btc_proto != nil {
		return
	}
	file_common_proto_init()
	file_antiklepto_proto_init()
	file_btc_proto_msgTypes[0].OneofWrappers = []any{
		(*BTCScriptConfig_SimpleType_)(nil),
		(*BTCScriptConfig_Multisig_)(nil),
		(*BTCScriptConfig_Policy_)(nil),
	}
	file_btc_proto_msgTypes[1].OneofWrappers = []any{
		(*BTCPubRequest_XpubType)(nil),
		(*BTCPubRequest_ScriptConfig)(nil),
	}
	file_btc_proto_msgTypes[7].OneofWrappers = []any{}
	file_btc_proto_msgTypes[19].OneofWrappers = []any{
		(*BTCRequest_IsScriptConfigRegistered)(nil),
		(*BTCRequest_RegisterScriptConfig)(nil),
		(*BTCRequest_PrevtxInit)(nil),
		(*BTCRequest_PrevtxInput)(nil),
		(*BTCRequest_PrevtxOutput)(nil),
		(*BTCRequest_SignMessage)(nil),
		(*BTCRequest_AntikleptoSignature)(nil),
		(*BTCRequest_PaymentRequest)(nil),
		(*BTCRequest_Xpubs)(nil),
	}
	file_btc_proto_msgTypes[20].OneofWrappers = []any{
		(*BTCResponse_Success)(nil),
		(*BTCResponse_IsScriptConfigRegistered)(nil),
		(*BTCResponse_SignNext)(nil),
		(*BTCResponse_SignMessage)(nil),
		(*BTCResponse_AntikleptoSignerCommitment)(nil),
		(*BTCResponse_Pubs)(nil),
	}
	file_btc_proto_msgTypes[24].OneofWrappers = []any{
		(*BTCPaymentRequestRequest_Memo_TextMemo_)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_btc_proto_rawDesc), len(file_btc_proto_rawDesc)),
			NumEnums:      9,
			NumMessages:   26,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_btc_proto_goTypes,
		DependencyIndexes: file_btc_proto_depIdxs,
		EnumInfos:         file_btc_proto_enumTypes,
		MessageInfos:      file_btc_proto_msgTypes,
	}.Build()
	File_btc_proto = out.File
	file_btc_proto_goTypes = nil
	file_btc_proto_depIdxs = nil
}
