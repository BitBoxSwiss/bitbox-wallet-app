// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/BitBoxSwiss/bitbox-wallet-app/backend/accounts"
	"github.com/BitBoxSwiss/bitbox-wallet-app/backend/coins/btc/blockchain"
	"github.com/BitBoxSwiss/bitbox-wallet-app/backend/coins/btc/transactions"
	"github.com/btcsuite/btcd/btcutil"
	"github.com/btcsuite/btcd/chaincfg/chainhash"
	"github.com/btcsuite/btcd/wire"
	"sync"
)

// Ensure, that InterfaceMock does implement transactions.Interface.
// If this is not the case, regenerate this file with moq.
var _ transactions.Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of transactions.Interface.
//
//	func TestSomethingThatUsesInterface(t *testing.T) {
//
//		// make and configure a mocked transactions.Interface
//		mockedInterface := &InterfaceMock{
//			BalanceFunc: func() (*accounts.Balance, error) {
//				panic("mock out the Balance method")
//			},
//			CloseFunc: func()  {
//				panic("mock out the Close method")
//			},
//			SpendableOutputsFunc: func() (map[wire.OutPoint]*transactions.SpendableOutput, error) {
//				panic("mock out the SpendableOutputs method")
//			},
//			SpendableOutputsForRBFFunc: func(txHash chainhash.Hash) (map[wire.OutPoint]*transactions.SpendableOutput, btcutil.Amount, btcutil.Amount, error) {
//				panic("mock out the SpendableOutputsForRBF method")
//			},
//			TransactionsFunc: func(isChange func(blockchain.ScriptHashHex) bool) (accounts.OrderedTransactions, error) {
//				panic("mock out the Transactions method")
//			},
//			UpdateAddressHistoryFunc: func(scriptHashHex blockchain.ScriptHashHex, txs []*blockchain.TxInfo)  {
//				panic("mock out the UpdateAddressHistory method")
//			},
//		}
//
//		// use mockedInterface in code that requires transactions.Interface
//		// and then make assertions.
//
//	}
type InterfaceMock struct {
	// BalanceFunc mocks the Balance method.
	BalanceFunc func() (*accounts.Balance, error)

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// SpendableOutputsFunc mocks the SpendableOutputs method.
	SpendableOutputsFunc func() (map[wire.OutPoint]*transactions.SpendableOutput, error)

	// SpendableOutputsForRBFFunc mocks the SpendableOutputsForRBF method.
	SpendableOutputsForRBFFunc func(txHash chainhash.Hash) (map[wire.OutPoint]*transactions.SpendableOutput, btcutil.Amount, btcutil.Amount, error)

	// TransactionsFunc mocks the Transactions method.
	TransactionsFunc func(isChange func(blockchain.ScriptHashHex) bool) (accounts.OrderedTransactions, error)

	// UpdateAddressHistoryFunc mocks the UpdateAddressHistory method.
	UpdateAddressHistoryFunc func(scriptHashHex blockchain.ScriptHashHex, txs []*blockchain.TxInfo)

	// calls tracks calls to the methods.
	calls struct {
		// Balance holds details about calls to the Balance method.
		Balance []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// SpendableOutputs holds details about calls to the SpendableOutputs method.
		SpendableOutputs []struct {
		}
		// SpendableOutputsForRBF holds details about calls to the SpendableOutputsForRBF method.
		SpendableOutputsForRBF []struct {
			// TxHash is the txHash argument value.
			TxHash chainhash.Hash
		}
		// Transactions holds details about calls to the Transactions method.
		Transactions []struct {
			// IsChange is the isChange argument value.
			IsChange func(blockchain.ScriptHashHex) bool
		}
		// UpdateAddressHistory holds details about calls to the UpdateAddressHistory method.
		UpdateAddressHistory []struct {
			// ScriptHashHex is the scriptHashHex argument value.
			ScriptHashHex blockchain.ScriptHashHex
			// Txs is the txs argument value.
			Txs []*blockchain.TxInfo
		}
	}
	lockBalance                sync.RWMutex
	lockClose                  sync.RWMutex
	lockSpendableOutputs       sync.RWMutex
	lockSpendableOutputsForRBF sync.RWMutex
	lockTransactions           sync.RWMutex
	lockUpdateAddressHistory   sync.RWMutex
}

// Balance calls BalanceFunc.
func (mock *InterfaceMock) Balance() (*accounts.Balance, error) {
	if mock.BalanceFunc == nil {
		panic("InterfaceMock.BalanceFunc: method is nil but Interface.Balance was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBalance.Lock()
	mock.calls.Balance = append(mock.calls.Balance, callInfo)
	mock.lockBalance.Unlock()
	return mock.BalanceFunc()
}

// BalanceCalls gets all the calls that were made to Balance.
// Check the length with:
//
//	len(mockedInterface.BalanceCalls())
func (mock *InterfaceMock) BalanceCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBalance.RLock()
	calls = mock.calls.Balance
	mock.lockBalance.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *InterfaceMock) Close() {
	if mock.CloseFunc == nil {
		panic("InterfaceMock.CloseFunc: method is nil but Interface.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedInterface.CloseCalls())
func (mock *InterfaceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// SpendableOutputs calls SpendableOutputsFunc.
func (mock *InterfaceMock) SpendableOutputs() (map[wire.OutPoint]*transactions.SpendableOutput, error) {
	if mock.SpendableOutputsFunc == nil {
		panic("InterfaceMock.SpendableOutputsFunc: method is nil but Interface.SpendableOutputs was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSpendableOutputs.Lock()
	mock.calls.SpendableOutputs = append(mock.calls.SpendableOutputs, callInfo)
	mock.lockSpendableOutputs.Unlock()
	return mock.SpendableOutputsFunc()
}

// SpendableOutputsCalls gets all the calls that were made to SpendableOutputs.
// Check the length with:
//
//	len(mockedInterface.SpendableOutputsCalls())
func (mock *InterfaceMock) SpendableOutputsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSpendableOutputs.RLock()
	calls = mock.calls.SpendableOutputs
	mock.lockSpendableOutputs.RUnlock()
	return calls
}

// SpendableOutputsForRBF calls SpendableOutputsForRBFFunc.
func (mock *InterfaceMock) SpendableOutputsForRBF(
	txHash chainhash.Hash,
) (map[wire.OutPoint]*transactions.SpendableOutput, btcutil.Amount, btcutil.Amount, error) {
	if mock.SpendableOutputsForRBFFunc == nil {
		panic("InterfaceMock.SpendableOutputsForRBFFunc: method is nil but Interface.SpendableOutputsForRBF was just called")
	}
	callInfo := struct {
		TxHash chainhash.Hash
	}{
		TxHash: txHash,
	}
	mock.lockSpendableOutputsForRBF.Lock()
	mock.calls.SpendableOutputsForRBF = append(mock.calls.SpendableOutputsForRBF, callInfo)
	mock.lockSpendableOutputsForRBF.Unlock()
	return mock.SpendableOutputsForRBFFunc(txHash)
}

// SpendableOutputsForRBFCalls gets all the calls that were made to SpendableOutputsForRBF.
// Check the length with:
//
//	len(mockedInterface.SpendableOutputsForRBFCalls())
func (mock *InterfaceMock) SpendableOutputsForRBFCalls() []struct {
	TxHash chainhash.Hash
} {
	var calls []struct {
		TxHash chainhash.Hash
	}
	mock.lockSpendableOutputsForRBF.RLock()
	calls = mock.calls.SpendableOutputsForRBF
	mock.lockSpendableOutputsForRBF.RUnlock()
	return calls
}

// Transactions calls TransactionsFunc.
func (mock *InterfaceMock) Transactions(isChange func(blockchain.ScriptHashHex) bool) (accounts.OrderedTransactions, error) {
	if mock.TransactionsFunc == nil {
		panic("InterfaceMock.TransactionsFunc: method is nil but Interface.Transactions was just called")
	}
	callInfo := struct {
		IsChange func(blockchain.ScriptHashHex) bool
	}{
		IsChange: isChange,
	}
	mock.lockTransactions.Lock()
	mock.calls.Transactions = append(mock.calls.Transactions, callInfo)
	mock.lockTransactions.Unlock()
	return mock.TransactionsFunc(isChange)
}

// TransactionsCalls gets all the calls that were made to Transactions.
// Check the length with:
//
//	len(mockedInterface.TransactionsCalls())
func (mock *InterfaceMock) TransactionsCalls() []struct {
	IsChange func(blockchain.ScriptHashHex) bool
} {
	var calls []struct {
		IsChange func(blockchain.ScriptHashHex) bool
	}
	mock.lockTransactions.RLock()
	calls = mock.calls.Transactions
	mock.lockTransactions.RUnlock()
	return calls
}

// UpdateAddressHistory calls UpdateAddressHistoryFunc.
func (mock *InterfaceMock) UpdateAddressHistory(scriptHashHex blockchain.ScriptHashHex, txs []*blockchain.TxInfo) {
	if mock.UpdateAddressHistoryFunc == nil {
		panic("InterfaceMock.UpdateAddressHistoryFunc: method is nil but Interface.UpdateAddressHistory was just called")
	}
	callInfo := struct {
		ScriptHashHex blockchain.ScriptHashHex
		Txs           []*blockchain.TxInfo
	}{
		ScriptHashHex: scriptHashHex,
		Txs:           txs,
	}
	mock.lockUpdateAddressHistory.Lock()
	mock.calls.UpdateAddressHistory = append(mock.calls.UpdateAddressHistory, callInfo)
	mock.lockUpdateAddressHistory.Unlock()
	mock.UpdateAddressHistoryFunc(scriptHashHex, txs)
}

// UpdateAddressHistoryCalls gets all the calls that were made to UpdateAddressHistory.
// Check the length with:
//
//	len(mockedInterface.UpdateAddressHistoryCalls())
func (mock *InterfaceMock) UpdateAddressHistoryCalls() []struct {
	ScriptHashHex blockchain.ScriptHashHex
	Txs           []*blockchain.TxInfo
} {
	var calls []struct {
		ScriptHashHex blockchain.ScriptHashHex
		Txs           []*blockchain.TxInfo
	}
	mock.lockUpdateAddressHistory.RLock()
	calls = mock.calls.UpdateAddressHistory
	mock.lockUpdateAddressHistory.RUnlock()
	return calls
}
