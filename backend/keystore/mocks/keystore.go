// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"sync"

	"github.com/btcsuite/btcd/btcutil/hdkeychain"
	"github.com/digitalbitbox/bitbox-wallet-app/backend/coins/coin"
	"github.com/digitalbitbox/bitbox-wallet-app/backend/keystore"
	"github.com/digitalbitbox/bitbox-wallet-app/backend/signing"
)

var (
	lockKeystoreMockCanSignMessage             sync.RWMutex
	lockKeystoreMockCanVerifyAddress           sync.RWMutex
	lockKeystoreMockCanVerifyExtendedPublicKey sync.RWMutex
	lockKeystoreMockExtendedPublicKey          sync.RWMutex
	lockKeystoreMockRootFingerprint            sync.RWMutex
	lockKeystoreMockSignBTCMessage             sync.RWMutex
	lockKeystoreMockSignETHMessage             sync.RWMutex
	lockKeystoreMockSignTransaction            sync.RWMutex
	lockKeystoreMockSupportsAccount            sync.RWMutex
	lockKeystoreMockSupportsCoin               sync.RWMutex
	lockKeystoreMockSupportsMultipleAccounts   sync.RWMutex
	lockKeystoreMockSupportsUnifiedAccounts    sync.RWMutex
	lockKeystoreMockType                       sync.RWMutex
	lockKeystoreMockVerifyAddress              sync.RWMutex
	lockKeystoreMockVerifyExtendedPublicKey    sync.RWMutex
)

// Ensure, that KeystoreMock does implement keystore.Keystore.
// If this is not the case, regenerate this file with moq.
var _ keystore.Keystore = &KeystoreMock{}

// KeystoreMock is a mock implementation of keystore.Keystore.
//
//     func TestSomethingThatUsesKeystore(t *testing.T) {
//
//         // make and configure a mocked keystore.Keystore
//         mockedKeystore := &KeystoreMock{
//             CanSignMessageFunc: func(in1 coin.Code) bool {
// 	               panic("mock out the CanSignMessage method")
//             },
//             CanVerifyAddressFunc: func(in1 coin.Coin) (bool, bool, error) {
// 	               panic("mock out the CanVerifyAddress method")
//             },
//             CanVerifyExtendedPublicKeyFunc: func() bool {
// 	               panic("mock out the CanVerifyExtendedPublicKey method")
//             },
//             ExtendedPublicKeyFunc: func(in1 coin.Coin, in2 signing.AbsoluteKeypath) (*hdkeychain.ExtendedKey, error) {
// 	               panic("mock out the ExtendedPublicKey method")
//             },
//             RootFingerprintFunc: func() ([]byte, error) {
// 	               panic("mock out the RootFingerprint method")
//             },
//             SignBTCMessageFunc: func(message []byte, keypath signing.AbsoluteKeypath, scriptType signing.ScriptType) ([]byte, error) {
// 	               panic("mock out the SignBTCMessage method")
//             },
//             SignETHMessageFunc: func(message []byte, keypath signing.AbsoluteKeypath) ([]byte, error) {
// 	               panic("mock out the SignETHMessage method")
//             },
//             SignTransactionFunc: func(in1 interface{}) error {
// 	               panic("mock out the SignTransaction method")
//             },
//             SupportsAccountFunc: func(coinInstance coin.Coin, meta interface{}) bool {
// 	               panic("mock out the SupportsAccount method")
//             },
//             SupportsCoinFunc: func(coinInstance coin.Coin) bool {
// 	               panic("mock out the SupportsCoin method")
//             },
//             SupportsMultipleAccountsFunc: func() bool {
// 	               panic("mock out the SupportsMultipleAccounts method")
//             },
//             SupportsUnifiedAccountsFunc: func() bool {
// 	               panic("mock out the SupportsUnifiedAccounts method")
//             },
//             TypeFunc: func() keystore.Type {
// 	               panic("mock out the Type method")
//             },
//             VerifyAddressFunc: func(in1 *signing.Configuration, in2 coin.Coin) error {
// 	               panic("mock out the VerifyAddress method")
//             },
//             VerifyExtendedPublicKeyFunc: func(in1 coin.Coin, in2 *signing.Configuration) error {
// 	               panic("mock out the VerifyExtendedPublicKey method")
//             },
//         }
//
//         // use mockedKeystore in code that requires keystore.Keystore
//         // and then make assertions.
//
//     }
type KeystoreMock struct {
	// CanSignMessageFunc mocks the CanSignMessage method.
	CanSignMessageFunc func(in1 coin.Code) bool

	// CanVerifyAddressFunc mocks the CanVerifyAddress method.
	CanVerifyAddressFunc func(in1 coin.Coin) (bool, bool, error)

	// CanVerifyExtendedPublicKeyFunc mocks the CanVerifyExtendedPublicKey method.
	CanVerifyExtendedPublicKeyFunc func() bool

	// ExtendedPublicKeyFunc mocks the ExtendedPublicKey method.
	ExtendedPublicKeyFunc func(in1 coin.Coin, in2 signing.AbsoluteKeypath) (*hdkeychain.ExtendedKey, error)

	// RootFingerprintFunc mocks the RootFingerprint method.
	RootFingerprintFunc func() ([]byte, error)

	// SignBTCMessageFunc mocks the SignBTCMessage method.
	SignBTCMessageFunc func(message []byte, keypath signing.AbsoluteKeypath, scriptType signing.ScriptType) ([]byte, error)

	// SignETHMessageFunc mocks the SignETHMessage method.
	SignETHMessageFunc func(message []byte, keypath signing.AbsoluteKeypath) ([]byte, error)

	// SignTransactionFunc mocks the SignTransaction method.
	SignTransactionFunc func(in1 interface{}) error

	// SupportsAccountFunc mocks the SupportsAccount method.
	SupportsAccountFunc func(coinInstance coin.Coin, meta interface{}) bool

	// SupportsCoinFunc mocks the SupportsCoin method.
	SupportsCoinFunc func(coinInstance coin.Coin) bool

	// SupportsMultipleAccountsFunc mocks the SupportsMultipleAccounts method.
	SupportsMultipleAccountsFunc func() bool

	// SupportsUnifiedAccountsFunc mocks the SupportsUnifiedAccounts method.
	SupportsUnifiedAccountsFunc func() bool

	// TypeFunc mocks the Type method.
	TypeFunc func() keystore.Type

	// VerifyAddressFunc mocks the VerifyAddress method.
	VerifyAddressFunc func(in1 *signing.Configuration, in2 coin.Coin) error

	// VerifyExtendedPublicKeyFunc mocks the VerifyExtendedPublicKey method.
	VerifyExtendedPublicKeyFunc func(in1 coin.Coin, in2 *signing.Configuration) error

	// calls tracks calls to the methods.
	calls struct {
		// CanSignMessage holds details about calls to the CanSignMessage method.
		CanSignMessage []struct {
			// In1 is the in1 argument value.
			In1 coin.Code
		}
		// CanVerifyAddress holds details about calls to the CanVerifyAddress method.
		CanVerifyAddress []struct {
			// In1 is the in1 argument value.
			In1 coin.Coin
		}
		// CanVerifyExtendedPublicKey holds details about calls to the CanVerifyExtendedPublicKey method.
		CanVerifyExtendedPublicKey []struct {
		}
		// ExtendedPublicKey holds details about calls to the ExtendedPublicKey method.
		ExtendedPublicKey []struct {
			// In1 is the in1 argument value.
			In1 coin.Coin
			// In2 is the in2 argument value.
			In2 signing.AbsoluteKeypath
		}
		// RootFingerprint holds details about calls to the RootFingerprint method.
		RootFingerprint []struct {
		}
		// SignBTCMessage holds details about calls to the SignBTCMessage method.
		SignBTCMessage []struct {
			// Message is the message argument value.
			Message []byte
			// Keypath is the keypath argument value.
			Keypath signing.AbsoluteKeypath
			// ScriptType is the scriptType argument value.
			ScriptType signing.ScriptType
		}
		// SignETHMessage holds details about calls to the SignETHMessage method.
		SignETHMessage []struct {
			// Message is the message argument value.
			Message []byte
			// Keypath is the keypath argument value.
			Keypath signing.AbsoluteKeypath
		}
		// SignTransaction holds details about calls to the SignTransaction method.
		SignTransaction []struct {
			// In1 is the in1 argument value.
			In1 interface{}
		}
		// SupportsAccount holds details about calls to the SupportsAccount method.
		SupportsAccount []struct {
			// CoinInstance is the coinInstance argument value.
			CoinInstance coin.Coin
			// Meta is the meta argument value.
			Meta interface{}
		}
		// SupportsCoin holds details about calls to the SupportsCoin method.
		SupportsCoin []struct {
			// CoinInstance is the coinInstance argument value.
			CoinInstance coin.Coin
		}
		// SupportsMultipleAccounts holds details about calls to the SupportsMultipleAccounts method.
		SupportsMultipleAccounts []struct {
		}
		// SupportsUnifiedAccounts holds details about calls to the SupportsUnifiedAccounts method.
		SupportsUnifiedAccounts []struct {
		}
		// Type holds details about calls to the Type method.
		Type []struct {
		}
		// VerifyAddress holds details about calls to the VerifyAddress method.
		VerifyAddress []struct {
			// In1 is the in1 argument value.
			In1 *signing.Configuration
			// In2 is the in2 argument value.
			In2 coin.Coin
		}
		// VerifyExtendedPublicKey holds details about calls to the VerifyExtendedPublicKey method.
		VerifyExtendedPublicKey []struct {
			// In1 is the in1 argument value.
			In1 coin.Coin
			// In2 is the in2 argument value.
			In2 *signing.Configuration
		}
	}
}

// CanSignMessage calls CanSignMessageFunc.
func (mock *KeystoreMock) CanSignMessage(in1 coin.Code) bool {
	if mock.CanSignMessageFunc == nil {
		panic("KeystoreMock.CanSignMessageFunc: method is nil but Keystore.CanSignMessage was just called")
	}
	callInfo := struct {
		In1 coin.Code
	}{
		In1: in1,
	}
	lockKeystoreMockCanSignMessage.Lock()
	mock.calls.CanSignMessage = append(mock.calls.CanSignMessage, callInfo)
	lockKeystoreMockCanSignMessage.Unlock()
	return mock.CanSignMessageFunc(in1)
}

// CanSignMessageCalls gets all the calls that were made to CanSignMessage.
// Check the length with:
//     len(mockedKeystore.CanSignMessageCalls())
func (mock *KeystoreMock) CanSignMessageCalls() []struct {
	In1 coin.Code
} {
	var calls []struct {
		In1 coin.Code
	}
	lockKeystoreMockCanSignMessage.RLock()
	calls = mock.calls.CanSignMessage
	lockKeystoreMockCanSignMessage.RUnlock()
	return calls
}

// CanVerifyAddress calls CanVerifyAddressFunc.
func (mock *KeystoreMock) CanVerifyAddress(in1 coin.Coin) (bool, bool, error) {
	if mock.CanVerifyAddressFunc == nil {
		panic("KeystoreMock.CanVerifyAddressFunc: method is nil but Keystore.CanVerifyAddress was just called")
	}
	callInfo := struct {
		In1 coin.Coin
	}{
		In1: in1,
	}
	lockKeystoreMockCanVerifyAddress.Lock()
	mock.calls.CanVerifyAddress = append(mock.calls.CanVerifyAddress, callInfo)
	lockKeystoreMockCanVerifyAddress.Unlock()
	return mock.CanVerifyAddressFunc(in1)
}

// CanVerifyAddressCalls gets all the calls that were made to CanVerifyAddress.
// Check the length with:
//     len(mockedKeystore.CanVerifyAddressCalls())
func (mock *KeystoreMock) CanVerifyAddressCalls() []struct {
	In1 coin.Coin
} {
	var calls []struct {
		In1 coin.Coin
	}
	lockKeystoreMockCanVerifyAddress.RLock()
	calls = mock.calls.CanVerifyAddress
	lockKeystoreMockCanVerifyAddress.RUnlock()
	return calls
}

// CanVerifyExtendedPublicKey calls CanVerifyExtendedPublicKeyFunc.
func (mock *KeystoreMock) CanVerifyExtendedPublicKey() bool {
	if mock.CanVerifyExtendedPublicKeyFunc == nil {
		panic("KeystoreMock.CanVerifyExtendedPublicKeyFunc: method is nil but Keystore.CanVerifyExtendedPublicKey was just called")
	}
	callInfo := struct {
	}{}
	lockKeystoreMockCanVerifyExtendedPublicKey.Lock()
	mock.calls.CanVerifyExtendedPublicKey = append(mock.calls.CanVerifyExtendedPublicKey, callInfo)
	lockKeystoreMockCanVerifyExtendedPublicKey.Unlock()
	return mock.CanVerifyExtendedPublicKeyFunc()
}

// CanVerifyExtendedPublicKeyCalls gets all the calls that were made to CanVerifyExtendedPublicKey.
// Check the length with:
//     len(mockedKeystore.CanVerifyExtendedPublicKeyCalls())
func (mock *KeystoreMock) CanVerifyExtendedPublicKeyCalls() []struct {
} {
	var calls []struct {
	}
	lockKeystoreMockCanVerifyExtendedPublicKey.RLock()
	calls = mock.calls.CanVerifyExtendedPublicKey
	lockKeystoreMockCanVerifyExtendedPublicKey.RUnlock()
	return calls
}

// ExtendedPublicKey calls ExtendedPublicKeyFunc.
func (mock *KeystoreMock) ExtendedPublicKey(in1 coin.Coin, in2 signing.AbsoluteKeypath) (*hdkeychain.ExtendedKey, error) {
	if mock.ExtendedPublicKeyFunc == nil {
		panic("KeystoreMock.ExtendedPublicKeyFunc: method is nil but Keystore.ExtendedPublicKey was just called")
	}
	callInfo := struct {
		In1 coin.Coin
		In2 signing.AbsoluteKeypath
	}{
		In1: in1,
		In2: in2,
	}
	lockKeystoreMockExtendedPublicKey.Lock()
	mock.calls.ExtendedPublicKey = append(mock.calls.ExtendedPublicKey, callInfo)
	lockKeystoreMockExtendedPublicKey.Unlock()
	return mock.ExtendedPublicKeyFunc(in1, in2)
}

// ExtendedPublicKeyCalls gets all the calls that were made to ExtendedPublicKey.
// Check the length with:
//     len(mockedKeystore.ExtendedPublicKeyCalls())
func (mock *KeystoreMock) ExtendedPublicKeyCalls() []struct {
	In1 coin.Coin
	In2 signing.AbsoluteKeypath
} {
	var calls []struct {
		In1 coin.Coin
		In2 signing.AbsoluteKeypath
	}
	lockKeystoreMockExtendedPublicKey.RLock()
	calls = mock.calls.ExtendedPublicKey
	lockKeystoreMockExtendedPublicKey.RUnlock()
	return calls
}

// RootFingerprint calls RootFingerprintFunc.
func (mock *KeystoreMock) RootFingerprint() ([]byte, error) {
	if mock.RootFingerprintFunc == nil {
		panic("KeystoreMock.RootFingerprintFunc: method is nil but Keystore.RootFingerprint was just called")
	}
	callInfo := struct {
	}{}
	lockKeystoreMockRootFingerprint.Lock()
	mock.calls.RootFingerprint = append(mock.calls.RootFingerprint, callInfo)
	lockKeystoreMockRootFingerprint.Unlock()
	return mock.RootFingerprintFunc()
}

// RootFingerprintCalls gets all the calls that were made to RootFingerprint.
// Check the length with:
//     len(mockedKeystore.RootFingerprintCalls())
func (mock *KeystoreMock) RootFingerprintCalls() []struct {
} {
	var calls []struct {
	}
	lockKeystoreMockRootFingerprint.RLock()
	calls = mock.calls.RootFingerprint
	lockKeystoreMockRootFingerprint.RUnlock()
	return calls
}

// SignBTCMessage calls SignBTCMessageFunc.
func (mock *KeystoreMock) SignBTCMessage(message []byte, keypath signing.AbsoluteKeypath, scriptType signing.ScriptType) ([]byte, error) {
	if mock.SignBTCMessageFunc == nil {
		panic("KeystoreMock.SignBTCMessageFunc: method is nil but Keystore.SignBTCMessage was just called")
	}
	callInfo := struct {
		Message    []byte
		Keypath    signing.AbsoluteKeypath
		ScriptType signing.ScriptType
	}{
		Message:    message,
		Keypath:    keypath,
		ScriptType: scriptType,
	}
	lockKeystoreMockSignBTCMessage.Lock()
	mock.calls.SignBTCMessage = append(mock.calls.SignBTCMessage, callInfo)
	lockKeystoreMockSignBTCMessage.Unlock()
	return mock.SignBTCMessageFunc(message, keypath, scriptType)
}

// SignBTCMessageCalls gets all the calls that were made to SignBTCMessage.
// Check the length with:
//     len(mockedKeystore.SignBTCMessageCalls())
func (mock *KeystoreMock) SignBTCMessageCalls() []struct {
	Message    []byte
	Keypath    signing.AbsoluteKeypath
	ScriptType signing.ScriptType
} {
	var calls []struct {
		Message    []byte
		Keypath    signing.AbsoluteKeypath
		ScriptType signing.ScriptType
	}
	lockKeystoreMockSignBTCMessage.RLock()
	calls = mock.calls.SignBTCMessage
	lockKeystoreMockSignBTCMessage.RUnlock()
	return calls
}

// SignETHMessage calls SignETHMessageFunc.
func (mock *KeystoreMock) SignETHMessage(message []byte, keypath signing.AbsoluteKeypath) ([]byte, error) {
	if mock.SignETHMessageFunc == nil {
		panic("KeystoreMock.SignETHMessageFunc: method is nil but Keystore.SignETHMessage was just called")
	}
	callInfo := struct {
		Message []byte
		Keypath signing.AbsoluteKeypath
	}{
		Message: message,
		Keypath: keypath,
	}
	lockKeystoreMockSignETHMessage.Lock()
	mock.calls.SignETHMessage = append(mock.calls.SignETHMessage, callInfo)
	lockKeystoreMockSignETHMessage.Unlock()
	return mock.SignETHMessageFunc(message, keypath)
}

// SignETHMessageCalls gets all the calls that were made to SignETHMessage.
// Check the length with:
//     len(mockedKeystore.SignETHMessageCalls())
func (mock *KeystoreMock) SignETHMessageCalls() []struct {
	Message []byte
	Keypath signing.AbsoluteKeypath
} {
	var calls []struct {
		Message []byte
		Keypath signing.AbsoluteKeypath
	}
	lockKeystoreMockSignETHMessage.RLock()
	calls = mock.calls.SignETHMessage
	lockKeystoreMockSignETHMessage.RUnlock()
	return calls
}

// SignTransaction calls SignTransactionFunc.
func (mock *KeystoreMock) SignTransaction(in1 interface{}) error {
	if mock.SignTransactionFunc == nil {
		panic("KeystoreMock.SignTransactionFunc: method is nil but Keystore.SignTransaction was just called")
	}
	callInfo := struct {
		In1 interface{}
	}{
		In1: in1,
	}
	lockKeystoreMockSignTransaction.Lock()
	mock.calls.SignTransaction = append(mock.calls.SignTransaction, callInfo)
	lockKeystoreMockSignTransaction.Unlock()
	return mock.SignTransactionFunc(in1)
}

// SignTransactionCalls gets all the calls that were made to SignTransaction.
// Check the length with:
//     len(mockedKeystore.SignTransactionCalls())
func (mock *KeystoreMock) SignTransactionCalls() []struct {
	In1 interface{}
} {
	var calls []struct {
		In1 interface{}
	}
	lockKeystoreMockSignTransaction.RLock()
	calls = mock.calls.SignTransaction
	lockKeystoreMockSignTransaction.RUnlock()
	return calls
}

// SupportsAccount calls SupportsAccountFunc.
func (mock *KeystoreMock) SupportsAccount(coinInstance coin.Coin, meta interface{}) bool {
	if mock.SupportsAccountFunc == nil {
		panic("KeystoreMock.SupportsAccountFunc: method is nil but Keystore.SupportsAccount was just called")
	}
	callInfo := struct {
		CoinInstance coin.Coin
		Meta         interface{}
	}{
		CoinInstance: coinInstance,
		Meta:         meta,
	}
	lockKeystoreMockSupportsAccount.Lock()
	mock.calls.SupportsAccount = append(mock.calls.SupportsAccount, callInfo)
	lockKeystoreMockSupportsAccount.Unlock()
	return mock.SupportsAccountFunc(coinInstance, meta)
}

// SupportsAccountCalls gets all the calls that were made to SupportsAccount.
// Check the length with:
//     len(mockedKeystore.SupportsAccountCalls())
func (mock *KeystoreMock) SupportsAccountCalls() []struct {
	CoinInstance coin.Coin
	Meta         interface{}
} {
	var calls []struct {
		CoinInstance coin.Coin
		Meta         interface{}
	}
	lockKeystoreMockSupportsAccount.RLock()
	calls = mock.calls.SupportsAccount
	lockKeystoreMockSupportsAccount.RUnlock()
	return calls
}

// SupportsCoin calls SupportsCoinFunc.
func (mock *KeystoreMock) SupportsCoin(coinInstance coin.Coin) bool {
	if mock.SupportsCoinFunc == nil {
		panic("KeystoreMock.SupportsCoinFunc: method is nil but Keystore.SupportsCoin was just called")
	}
	callInfo := struct {
		CoinInstance coin.Coin
	}{
		CoinInstance: coinInstance,
	}
	lockKeystoreMockSupportsCoin.Lock()
	mock.calls.SupportsCoin = append(mock.calls.SupportsCoin, callInfo)
	lockKeystoreMockSupportsCoin.Unlock()
	return mock.SupportsCoinFunc(coinInstance)
}

// SupportsCoinCalls gets all the calls that were made to SupportsCoin.
// Check the length with:
//     len(mockedKeystore.SupportsCoinCalls())
func (mock *KeystoreMock) SupportsCoinCalls() []struct {
	CoinInstance coin.Coin
} {
	var calls []struct {
		CoinInstance coin.Coin
	}
	lockKeystoreMockSupportsCoin.RLock()
	calls = mock.calls.SupportsCoin
	lockKeystoreMockSupportsCoin.RUnlock()
	return calls
}

// SupportsMultipleAccounts calls SupportsMultipleAccountsFunc.
func (mock *KeystoreMock) SupportsMultipleAccounts() bool {
	if mock.SupportsMultipleAccountsFunc == nil {
		panic("KeystoreMock.SupportsMultipleAccountsFunc: method is nil but Keystore.SupportsMultipleAccounts was just called")
	}
	callInfo := struct {
	}{}
	lockKeystoreMockSupportsMultipleAccounts.Lock()
	mock.calls.SupportsMultipleAccounts = append(mock.calls.SupportsMultipleAccounts, callInfo)
	lockKeystoreMockSupportsMultipleAccounts.Unlock()
	return mock.SupportsMultipleAccountsFunc()
}

// SupportsMultipleAccountsCalls gets all the calls that were made to SupportsMultipleAccounts.
// Check the length with:
//     len(mockedKeystore.SupportsMultipleAccountsCalls())
func (mock *KeystoreMock) SupportsMultipleAccountsCalls() []struct {
} {
	var calls []struct {
	}
	lockKeystoreMockSupportsMultipleAccounts.RLock()
	calls = mock.calls.SupportsMultipleAccounts
	lockKeystoreMockSupportsMultipleAccounts.RUnlock()
	return calls
}

// SupportsUnifiedAccounts calls SupportsUnifiedAccountsFunc.
func (mock *KeystoreMock) SupportsUnifiedAccounts() bool {
	if mock.SupportsUnifiedAccountsFunc == nil {
		panic("KeystoreMock.SupportsUnifiedAccountsFunc: method is nil but Keystore.SupportsUnifiedAccounts was just called")
	}
	callInfo := struct {
	}{}
	lockKeystoreMockSupportsUnifiedAccounts.Lock()
	mock.calls.SupportsUnifiedAccounts = append(mock.calls.SupportsUnifiedAccounts, callInfo)
	lockKeystoreMockSupportsUnifiedAccounts.Unlock()
	return mock.SupportsUnifiedAccountsFunc()
}

// SupportsUnifiedAccountsCalls gets all the calls that were made to SupportsUnifiedAccounts.
// Check the length with:
//     len(mockedKeystore.SupportsUnifiedAccountsCalls())
func (mock *KeystoreMock) SupportsUnifiedAccountsCalls() []struct {
} {
	var calls []struct {
	}
	lockKeystoreMockSupportsUnifiedAccounts.RLock()
	calls = mock.calls.SupportsUnifiedAccounts
	lockKeystoreMockSupportsUnifiedAccounts.RUnlock()
	return calls
}

// Type calls TypeFunc.
func (mock *KeystoreMock) Type() keystore.Type {
	if mock.TypeFunc == nil {
		panic("KeystoreMock.TypeFunc: method is nil but Keystore.Type was just called")
	}
	callInfo := struct {
	}{}
	lockKeystoreMockType.Lock()
	mock.calls.Type = append(mock.calls.Type, callInfo)
	lockKeystoreMockType.Unlock()
	return mock.TypeFunc()
}

// TypeCalls gets all the calls that were made to Type.
// Check the length with:
//     len(mockedKeystore.TypeCalls())
func (mock *KeystoreMock) TypeCalls() []struct {
} {
	var calls []struct {
	}
	lockKeystoreMockType.RLock()
	calls = mock.calls.Type
	lockKeystoreMockType.RUnlock()
	return calls
}

// VerifyAddress calls VerifyAddressFunc.
func (mock *KeystoreMock) VerifyAddress(in1 *signing.Configuration, in2 coin.Coin) error {
	if mock.VerifyAddressFunc == nil {
		panic("KeystoreMock.VerifyAddressFunc: method is nil but Keystore.VerifyAddress was just called")
	}
	callInfo := struct {
		In1 *signing.Configuration
		In2 coin.Coin
	}{
		In1: in1,
		In2: in2,
	}
	lockKeystoreMockVerifyAddress.Lock()
	mock.calls.VerifyAddress = append(mock.calls.VerifyAddress, callInfo)
	lockKeystoreMockVerifyAddress.Unlock()
	return mock.VerifyAddressFunc(in1, in2)
}

// VerifyAddressCalls gets all the calls that were made to VerifyAddress.
// Check the length with:
//     len(mockedKeystore.VerifyAddressCalls())
func (mock *KeystoreMock) VerifyAddressCalls() []struct {
	In1 *signing.Configuration
	In2 coin.Coin
} {
	var calls []struct {
		In1 *signing.Configuration
		In2 coin.Coin
	}
	lockKeystoreMockVerifyAddress.RLock()
	calls = mock.calls.VerifyAddress
	lockKeystoreMockVerifyAddress.RUnlock()
	return calls
}

// VerifyExtendedPublicKey calls VerifyExtendedPublicKeyFunc.
func (mock *KeystoreMock) VerifyExtendedPublicKey(in1 coin.Coin, in2 *signing.Configuration) error {
	if mock.VerifyExtendedPublicKeyFunc == nil {
		panic("KeystoreMock.VerifyExtendedPublicKeyFunc: method is nil but Keystore.VerifyExtendedPublicKey was just called")
	}
	callInfo := struct {
		In1 coin.Coin
		In2 *signing.Configuration
	}{
		In1: in1,
		In2: in2,
	}
	lockKeystoreMockVerifyExtendedPublicKey.Lock()
	mock.calls.VerifyExtendedPublicKey = append(mock.calls.VerifyExtendedPublicKey, callInfo)
	lockKeystoreMockVerifyExtendedPublicKey.Unlock()
	return mock.VerifyExtendedPublicKeyFunc(in1, in2)
}

// VerifyExtendedPublicKeyCalls gets all the calls that were made to VerifyExtendedPublicKey.
// Check the length with:
//     len(mockedKeystore.VerifyExtendedPublicKeyCalls())
func (mock *KeystoreMock) VerifyExtendedPublicKeyCalls() []struct {
	In1 coin.Coin
	In2 *signing.Configuration
} {
	var calls []struct {
		In1 coin.Coin
		In2 *signing.Configuration
	}
	lockKeystoreMockVerifyExtendedPublicKey.RLock()
	calls = mock.calls.VerifyExtendedPublicKey
	lockKeystoreMockVerifyExtendedPublicKey.RUnlock()
	return calls
}
