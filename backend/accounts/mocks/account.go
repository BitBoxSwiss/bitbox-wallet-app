// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"github.com/digitalbitbox/bitbox-wallet-app/backend/accounts"
	"github.com/digitalbitbox/bitbox-wallet-app/backend/coins/coin"
	"github.com/digitalbitbox/bitbox-wallet-app/util/observable"
	"io"
	"sync"
)

// Ensure, that InterfaceMock does implement accounts.Interface.
// If this is not the case, regenerate this file with moq.
var _ accounts.Interface = &InterfaceMock{}

// InterfaceMock is a mock implementation of accounts.Interface.
//
//	func TestSomethingThatUsesInterface(t *testing.T) {
//
//		// make and configure a mocked accounts.Interface
//		mockedInterface := &InterfaceMock{
//			BalanceFunc: func() (*accounts.Balance, error) {
//				panic("mock out the Balance method")
//			},
//			CanVerifyAddressesFunc: func() (bool, bool, error) {
//				panic("mock out the CanVerifyAddresses method")
//			},
//			CloseFunc: func()  {
//				panic("mock out the Close method")
//			},
//			CoinFunc: func() coin.Coin {
//				panic("mock out the Coin method")
//			},
//			ConfigFunc: func() *accounts.AccountConfig {
//				panic("mock out the Config method")
//			},
//			ExportCSVFunc: func(w io.Writer, transactions []*accounts.TransactionData) error {
//				panic("mock out the ExportCSV method")
//			},
//			FatalErrorFunc: func() bool {
//				panic("mock out the FatalError method")
//			},
//			FeeTargetsFunc: func() ([]accounts.FeeTarget, accounts.FeeTargetCode) {
//				panic("mock out the FeeTargets method")
//			},
//			FilesFolderFunc: func() string {
//				panic("mock out the FilesFolder method")
//			},
//			GetUnusedReceiveAddressesFunc: func() []accounts.AddressList {
//				panic("mock out the GetUnusedReceiveAddresses method")
//			},
//			InfoFunc: func() *accounts.Info {
//				panic("mock out the Info method")
//			},
//			InitializeFunc: func() error {
//				panic("mock out the Initialize method")
//			},
//			NotifierFunc: func() accounts.Notifier {
//				panic("mock out the Notifier method")
//			},
//			ObserveFunc: func(fn func(observable.Event)) func() {
//				panic("mock out the Observe method")
//			},
//			OfflineFunc: func() error {
//				panic("mock out the Offline method")
//			},
//			ProposeTxNoteFunc: func(s string)  {
//				panic("mock out the ProposeTxNote method")
//			},
//			SendTxFunc: func() error {
//				panic("mock out the SendTx method")
//			},
//			SetTxNoteFunc: func(txID string, note string) error {
//				panic("mock out the SetTxNote method")
//			},
//			SyncedFunc: func() bool {
//				panic("mock out the Synced method")
//			},
//			TransactionsFunc: func() (accounts.OrderedTransactions, error) {
//				panic("mock out the Transactions method")
//			},
//			TxNoteFunc: func(txID string) string {
//				panic("mock out the TxNote method")
//			},
//			TxProposalFunc: func(txProposalArgs *accounts.TxProposalArgs) (coin.Amount, coin.Amount, coin.Amount, error) {
//				panic("mock out the TxProposal method")
//			},
//			VerifyAddressFunc: func(addressID string) (bool, error) {
//				panic("mock out the VerifyAddress method")
//			},
//		}
//
//		// use mockedInterface in code that requires accounts.Interface
//		// and then make assertions.
//
//	}
type InterfaceMock struct {
	// BalanceFunc mocks the Balance method.
	BalanceFunc func() (*accounts.Balance, error)

	// CanVerifyAddressesFunc mocks the CanVerifyAddresses method.
	CanVerifyAddressesFunc func() (bool, bool, error)

	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CoinFunc mocks the Coin method.
	CoinFunc func() coin.Coin

	// ConfigFunc mocks the Config method.
	ConfigFunc func() *accounts.AccountConfig

	// ExportCSVFunc mocks the ExportCSV method.
	ExportCSVFunc func(w io.Writer, transactions []*accounts.TransactionData) error

	// FatalErrorFunc mocks the FatalError method.
	FatalErrorFunc func() bool

	// FeeTargetsFunc mocks the FeeTargets method.
	FeeTargetsFunc func() ([]accounts.FeeTarget, accounts.FeeTargetCode)

	// FilesFolderFunc mocks the FilesFolder method.
	FilesFolderFunc func() string

	// GetUnusedReceiveAddressesFunc mocks the GetUnusedReceiveAddresses method.
	GetUnusedReceiveAddressesFunc func() []accounts.AddressList

	// InfoFunc mocks the Info method.
	InfoFunc func() *accounts.Info

	// InitializeFunc mocks the Initialize method.
	InitializeFunc func() error

	// NotifierFunc mocks the Notifier method.
	NotifierFunc func() accounts.Notifier

	// ObserveFunc mocks the Observe method.
	ObserveFunc func(fn func(observable.Event)) func()

	// OfflineFunc mocks the Offline method.
	OfflineFunc func() error

	// ProposeTxNoteFunc mocks the ProposeTxNote method.
	ProposeTxNoteFunc func(s string)

	// SendTxFunc mocks the SendTx method.
	SendTxFunc func() error

	// SetTxNoteFunc mocks the SetTxNote method.
	SetTxNoteFunc func(txID string, note string) error

	// SyncedFunc mocks the Synced method.
	SyncedFunc func() bool

	// TransactionsFunc mocks the Transactions method.
	TransactionsFunc func() (accounts.OrderedTransactions, error)

	// TxNoteFunc mocks the TxNote method.
	TxNoteFunc func(txID string) string

	// TxProposalFunc mocks the TxProposal method.
	TxProposalFunc func(txProposalArgs *accounts.TxProposalArgs) (coin.Amount, coin.Amount, coin.Amount, error)

	// VerifyAddressFunc mocks the VerifyAddress method.
	VerifyAddressFunc func(addressID string) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// Balance holds details about calls to the Balance method.
		Balance []struct {
		}
		// CanVerifyAddresses holds details about calls to the CanVerifyAddresses method.
		CanVerifyAddresses []struct {
		}
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Coin holds details about calls to the Coin method.
		Coin []struct {
		}
		// Config holds details about calls to the Config method.
		Config []struct {
		}
		// ExportCSV holds details about calls to the ExportCSV method.
		ExportCSV []struct {
			// W is the w argument value.
			W io.Writer
			// Transactions is the transactions argument value.
			Transactions []*accounts.TransactionData
		}
		// FatalError holds details about calls to the FatalError method.
		FatalError []struct {
		}
		// FeeTargets holds details about calls to the FeeTargets method.
		FeeTargets []struct {
		}
		// FilesFolder holds details about calls to the FilesFolder method.
		FilesFolder []struct {
		}
		// GetUnusedReceiveAddresses holds details about calls to the GetUnusedReceiveAddresses method.
		GetUnusedReceiveAddresses []struct {
		}
		// Info holds details about calls to the Info method.
		Info []struct {
		}
		// Initialize holds details about calls to the Initialize method.
		Initialize []struct {
		}
		// Notifier holds details about calls to the Notifier method.
		Notifier []struct {
		}
		// Observe holds details about calls to the Observe method.
		Observe []struct {
			// Fn is the fn argument value.
			Fn func(observable.Event)
		}
		// Offline holds details about calls to the Offline method.
		Offline []struct {
		}
		// ProposeTxNote holds details about calls to the ProposeTxNote method.
		ProposeTxNote []struct {
			// S is the s argument value.
			S string
		}
		// SendTx holds details about calls to the SendTx method.
		SendTx []struct {
		}
		// SetTxNote holds details about calls to the SetTxNote method.
		SetTxNote []struct {
			// TxID is the txID argument value.
			TxID string
			// Note is the note argument value.
			Note string
		}
		// Synced holds details about calls to the Synced method.
		Synced []struct {
		}
		// Transactions holds details about calls to the Transactions method.
		Transactions []struct {
		}
		// TxNote holds details about calls to the TxNote method.
		TxNote []struct {
			// TxID is the txID argument value.
			TxID string
		}
		// TxProposal holds details about calls to the TxProposal method.
		TxProposal []struct {
			// TxProposalArgs is the txProposalArgs argument value.
			TxProposalArgs *accounts.TxProposalArgs
		}
		// VerifyAddress holds details about calls to the VerifyAddress method.
		VerifyAddress []struct {
			// AddressID is the addressID argument value.
			AddressID string
		}
	}
	lockBalance                   sync.RWMutex
	lockCanVerifyAddresses        sync.RWMutex
	lockClose                     sync.RWMutex
	lockCoin                      sync.RWMutex
	lockConfig                    sync.RWMutex
	lockExportCSV                 sync.RWMutex
	lockFatalError                sync.RWMutex
	lockFeeTargets                sync.RWMutex
	lockFilesFolder               sync.RWMutex
	lockGetUnusedReceiveAddresses sync.RWMutex
	lockInfo                      sync.RWMutex
	lockInitialize                sync.RWMutex
	lockNotifier                  sync.RWMutex
	lockObserve                   sync.RWMutex
	lockOffline                   sync.RWMutex
	lockProposeTxNote             sync.RWMutex
	lockSendTx                    sync.RWMutex
	lockSetTxNote                 sync.RWMutex
	lockSynced                    sync.RWMutex
	lockTransactions              sync.RWMutex
	lockTxNote                    sync.RWMutex
	lockTxProposal                sync.RWMutex
	lockVerifyAddress             sync.RWMutex
}

// Balance calls BalanceFunc.
func (mock *InterfaceMock) Balance() (*accounts.Balance, error) {
	if mock.BalanceFunc == nil {
		panic("InterfaceMock.BalanceFunc: method is nil but Interface.Balance was just called")
	}
	callInfo := struct {
	}{}
	mock.lockBalance.Lock()
	mock.calls.Balance = append(mock.calls.Balance, callInfo)
	mock.lockBalance.Unlock()
	return mock.BalanceFunc()
}

// BalanceCalls gets all the calls that were made to Balance.
// Check the length with:
//
//	len(mockedInterface.BalanceCalls())
func (mock *InterfaceMock) BalanceCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockBalance.RLock()
	calls = mock.calls.Balance
	mock.lockBalance.RUnlock()
	return calls
}

// CanVerifyAddresses calls CanVerifyAddressesFunc.
func (mock *InterfaceMock) CanVerifyAddresses() (bool, bool, error) {
	if mock.CanVerifyAddressesFunc == nil {
		panic("InterfaceMock.CanVerifyAddressesFunc: method is nil but Interface.CanVerifyAddresses was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCanVerifyAddresses.Lock()
	mock.calls.CanVerifyAddresses = append(mock.calls.CanVerifyAddresses, callInfo)
	mock.lockCanVerifyAddresses.Unlock()
	return mock.CanVerifyAddressesFunc()
}

// CanVerifyAddressesCalls gets all the calls that were made to CanVerifyAddresses.
// Check the length with:
//
//	len(mockedInterface.CanVerifyAddressesCalls())
func (mock *InterfaceMock) CanVerifyAddressesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCanVerifyAddresses.RLock()
	calls = mock.calls.CanVerifyAddresses
	mock.lockCanVerifyAddresses.RUnlock()
	return calls
}

// Close calls CloseFunc.
func (mock *InterfaceMock) Close() {
	if mock.CloseFunc == nil {
		panic("InterfaceMock.CloseFunc: method is nil but Interface.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedInterface.CloseCalls())
func (mock *InterfaceMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Coin calls CoinFunc.
func (mock *InterfaceMock) Coin() coin.Coin {
	if mock.CoinFunc == nil {
		panic("InterfaceMock.CoinFunc: method is nil but Interface.Coin was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCoin.Lock()
	mock.calls.Coin = append(mock.calls.Coin, callInfo)
	mock.lockCoin.Unlock()
	return mock.CoinFunc()
}

// CoinCalls gets all the calls that were made to Coin.
// Check the length with:
//
//	len(mockedInterface.CoinCalls())
func (mock *InterfaceMock) CoinCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCoin.RLock()
	calls = mock.calls.Coin
	mock.lockCoin.RUnlock()
	return calls
}

// Config calls ConfigFunc.
func (mock *InterfaceMock) Config() *accounts.AccountConfig {
	if mock.ConfigFunc == nil {
		panic("InterfaceMock.ConfigFunc: method is nil but Interface.Config was just called")
	}
	callInfo := struct {
	}{}
	mock.lockConfig.Lock()
	mock.calls.Config = append(mock.calls.Config, callInfo)
	mock.lockConfig.Unlock()
	return mock.ConfigFunc()
}

// ConfigCalls gets all the calls that were made to Config.
// Check the length with:
//
//	len(mockedInterface.ConfigCalls())
func (mock *InterfaceMock) ConfigCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockConfig.RLock()
	calls = mock.calls.Config
	mock.lockConfig.RUnlock()
	return calls
}

// ExportCSV calls ExportCSVFunc.
func (mock *InterfaceMock) ExportCSV(w io.Writer, transactions []*accounts.TransactionData) error {
	if mock.ExportCSVFunc == nil {
		panic("InterfaceMock.ExportCSVFunc: method is nil but Interface.ExportCSV was just called")
	}
	callInfo := struct {
		W            io.Writer
		Transactions []*accounts.TransactionData
	}{
		W:            w,
		Transactions: transactions,
	}
	mock.lockExportCSV.Lock()
	mock.calls.ExportCSV = append(mock.calls.ExportCSV, callInfo)
	mock.lockExportCSV.Unlock()
	return mock.ExportCSVFunc(w, transactions)
}

// ExportCSVCalls gets all the calls that were made to ExportCSV.
// Check the length with:
//
//	len(mockedInterface.ExportCSVCalls())
func (mock *InterfaceMock) ExportCSVCalls() []struct {
	W            io.Writer
	Transactions []*accounts.TransactionData
} {
	var calls []struct {
		W            io.Writer
		Transactions []*accounts.TransactionData
	}
	mock.lockExportCSV.RLock()
	calls = mock.calls.ExportCSV
	mock.lockExportCSV.RUnlock()
	return calls
}

// FatalError calls FatalErrorFunc.
func (mock *InterfaceMock) FatalError() bool {
	if mock.FatalErrorFunc == nil {
		panic("InterfaceMock.FatalErrorFunc: method is nil but Interface.FatalError was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFatalError.Lock()
	mock.calls.FatalError = append(mock.calls.FatalError, callInfo)
	mock.lockFatalError.Unlock()
	return mock.FatalErrorFunc()
}

// FatalErrorCalls gets all the calls that were made to FatalError.
// Check the length with:
//
//	len(mockedInterface.FatalErrorCalls())
func (mock *InterfaceMock) FatalErrorCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFatalError.RLock()
	calls = mock.calls.FatalError
	mock.lockFatalError.RUnlock()
	return calls
}

// FeeTargets calls FeeTargetsFunc.
func (mock *InterfaceMock) FeeTargets() ([]accounts.FeeTarget, accounts.FeeTargetCode) {
	if mock.FeeTargetsFunc == nil {
		panic("InterfaceMock.FeeTargetsFunc: method is nil but Interface.FeeTargets was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFeeTargets.Lock()
	mock.calls.FeeTargets = append(mock.calls.FeeTargets, callInfo)
	mock.lockFeeTargets.Unlock()
	return mock.FeeTargetsFunc()
}

// FeeTargetsCalls gets all the calls that were made to FeeTargets.
// Check the length with:
//
//	len(mockedInterface.FeeTargetsCalls())
func (mock *InterfaceMock) FeeTargetsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFeeTargets.RLock()
	calls = mock.calls.FeeTargets
	mock.lockFeeTargets.RUnlock()
	return calls
}

// FilesFolder calls FilesFolderFunc.
func (mock *InterfaceMock) FilesFolder() string {
	if mock.FilesFolderFunc == nil {
		panic("InterfaceMock.FilesFolderFunc: method is nil but Interface.FilesFolder was just called")
	}
	callInfo := struct {
	}{}
	mock.lockFilesFolder.Lock()
	mock.calls.FilesFolder = append(mock.calls.FilesFolder, callInfo)
	mock.lockFilesFolder.Unlock()
	return mock.FilesFolderFunc()
}

// FilesFolderCalls gets all the calls that were made to FilesFolder.
// Check the length with:
//
//	len(mockedInterface.FilesFolderCalls())
func (mock *InterfaceMock) FilesFolderCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockFilesFolder.RLock()
	calls = mock.calls.FilesFolder
	mock.lockFilesFolder.RUnlock()
	return calls
}

// GetUnusedReceiveAddresses calls GetUnusedReceiveAddressesFunc.
func (mock *InterfaceMock) GetUnusedReceiveAddresses() []accounts.AddressList {
	if mock.GetUnusedReceiveAddressesFunc == nil {
		panic("InterfaceMock.GetUnusedReceiveAddressesFunc: method is nil but Interface.GetUnusedReceiveAddresses was just called")
	}
	callInfo := struct {
	}{}
	mock.lockGetUnusedReceiveAddresses.Lock()
	mock.calls.GetUnusedReceiveAddresses = append(mock.calls.GetUnusedReceiveAddresses, callInfo)
	mock.lockGetUnusedReceiveAddresses.Unlock()
	return mock.GetUnusedReceiveAddressesFunc()
}

// GetUnusedReceiveAddressesCalls gets all the calls that were made to GetUnusedReceiveAddresses.
// Check the length with:
//
//	len(mockedInterface.GetUnusedReceiveAddressesCalls())
func (mock *InterfaceMock) GetUnusedReceiveAddressesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetUnusedReceiveAddresses.RLock()
	calls = mock.calls.GetUnusedReceiveAddresses
	mock.lockGetUnusedReceiveAddresses.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *InterfaceMock) Info() *accounts.Info {
	if mock.InfoFunc == nil {
		panic("InterfaceMock.InfoFunc: method is nil but Interface.Info was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	return mock.InfoFunc()
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedInterface.InfoCalls())
func (mock *InterfaceMock) InfoCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Initialize calls InitializeFunc.
func (mock *InterfaceMock) Initialize() error {
	if mock.InitializeFunc == nil {
		panic("InterfaceMock.InitializeFunc: method is nil but Interface.Initialize was just called")
	}
	callInfo := struct {
	}{}
	mock.lockInitialize.Lock()
	mock.calls.Initialize = append(mock.calls.Initialize, callInfo)
	mock.lockInitialize.Unlock()
	return mock.InitializeFunc()
}

// InitializeCalls gets all the calls that were made to Initialize.
// Check the length with:
//
//	len(mockedInterface.InitializeCalls())
func (mock *InterfaceMock) InitializeCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockInitialize.RLock()
	calls = mock.calls.Initialize
	mock.lockInitialize.RUnlock()
	return calls
}

// Notifier calls NotifierFunc.
func (mock *InterfaceMock) Notifier() accounts.Notifier {
	if mock.NotifierFunc == nil {
		panic("InterfaceMock.NotifierFunc: method is nil but Interface.Notifier was just called")
	}
	callInfo := struct {
	}{}
	mock.lockNotifier.Lock()
	mock.calls.Notifier = append(mock.calls.Notifier, callInfo)
	mock.lockNotifier.Unlock()
	return mock.NotifierFunc()
}

// NotifierCalls gets all the calls that were made to Notifier.
// Check the length with:
//
//	len(mockedInterface.NotifierCalls())
func (mock *InterfaceMock) NotifierCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNotifier.RLock()
	calls = mock.calls.Notifier
	mock.lockNotifier.RUnlock()
	return calls
}

// Observe calls ObserveFunc.
func (mock *InterfaceMock) Observe(fn func(observable.Event)) func() {
	if mock.ObserveFunc == nil {
		panic("InterfaceMock.ObserveFunc: method is nil but Interface.Observe was just called")
	}
	callInfo := struct {
		Fn func(observable.Event)
	}{
		Fn: fn,
	}
	mock.lockObserve.Lock()
	mock.calls.Observe = append(mock.calls.Observe, callInfo)
	mock.lockObserve.Unlock()
	return mock.ObserveFunc(fn)
}

// ObserveCalls gets all the calls that were made to Observe.
// Check the length with:
//
//	len(mockedInterface.ObserveCalls())
func (mock *InterfaceMock) ObserveCalls() []struct {
	Fn func(observable.Event)
} {
	var calls []struct {
		Fn func(observable.Event)
	}
	mock.lockObserve.RLock()
	calls = mock.calls.Observe
	mock.lockObserve.RUnlock()
	return calls
}

// Offline calls OfflineFunc.
func (mock *InterfaceMock) Offline() error {
	if mock.OfflineFunc == nil {
		panic("InterfaceMock.OfflineFunc: method is nil but Interface.Offline was just called")
	}
	callInfo := struct {
	}{}
	mock.lockOffline.Lock()
	mock.calls.Offline = append(mock.calls.Offline, callInfo)
	mock.lockOffline.Unlock()
	return mock.OfflineFunc()
}

// OfflineCalls gets all the calls that were made to Offline.
// Check the length with:
//
//	len(mockedInterface.OfflineCalls())
func (mock *InterfaceMock) OfflineCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockOffline.RLock()
	calls = mock.calls.Offline
	mock.lockOffline.RUnlock()
	return calls
}

// ProposeTxNote calls ProposeTxNoteFunc.
func (mock *InterfaceMock) ProposeTxNote(s string) {
	if mock.ProposeTxNoteFunc == nil {
		panic("InterfaceMock.ProposeTxNoteFunc: method is nil but Interface.ProposeTxNote was just called")
	}
	callInfo := struct {
		S string
	}{
		S: s,
	}
	mock.lockProposeTxNote.Lock()
	mock.calls.ProposeTxNote = append(mock.calls.ProposeTxNote, callInfo)
	mock.lockProposeTxNote.Unlock()
	mock.ProposeTxNoteFunc(s)
}

// ProposeTxNoteCalls gets all the calls that were made to ProposeTxNote.
// Check the length with:
//
//	len(mockedInterface.ProposeTxNoteCalls())
func (mock *InterfaceMock) ProposeTxNoteCalls() []struct {
	S string
} {
	var calls []struct {
		S string
	}
	mock.lockProposeTxNote.RLock()
	calls = mock.calls.ProposeTxNote
	mock.lockProposeTxNote.RUnlock()
	return calls
}

// SendTx calls SendTxFunc.
func (mock *InterfaceMock) SendTx() error {
	if mock.SendTxFunc == nil {
		panic("InterfaceMock.SendTxFunc: method is nil but Interface.SendTx was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSendTx.Lock()
	mock.calls.SendTx = append(mock.calls.SendTx, callInfo)
	mock.lockSendTx.Unlock()
	return mock.SendTxFunc()
}

// SendTxCalls gets all the calls that were made to SendTx.
// Check the length with:
//
//	len(mockedInterface.SendTxCalls())
func (mock *InterfaceMock) SendTxCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSendTx.RLock()
	calls = mock.calls.SendTx
	mock.lockSendTx.RUnlock()
	return calls
}

// SetTxNote calls SetTxNoteFunc.
func (mock *InterfaceMock) SetTxNote(txID string, note string) error {
	if mock.SetTxNoteFunc == nil {
		panic("InterfaceMock.SetTxNoteFunc: method is nil but Interface.SetTxNote was just called")
	}
	callInfo := struct {
		TxID string
		Note string
	}{
		TxID: txID,
		Note: note,
	}
	mock.lockSetTxNote.Lock()
	mock.calls.SetTxNote = append(mock.calls.SetTxNote, callInfo)
	mock.lockSetTxNote.Unlock()
	return mock.SetTxNoteFunc(txID, note)
}

// SetTxNoteCalls gets all the calls that were made to SetTxNote.
// Check the length with:
//
//	len(mockedInterface.SetTxNoteCalls())
func (mock *InterfaceMock) SetTxNoteCalls() []struct {
	TxID string
	Note string
} {
	var calls []struct {
		TxID string
		Note string
	}
	mock.lockSetTxNote.RLock()
	calls = mock.calls.SetTxNote
	mock.lockSetTxNote.RUnlock()
	return calls
}

// Synced calls SyncedFunc.
func (mock *InterfaceMock) Synced() bool {
	if mock.SyncedFunc == nil {
		panic("InterfaceMock.SyncedFunc: method is nil but Interface.Synced was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSynced.Lock()
	mock.calls.Synced = append(mock.calls.Synced, callInfo)
	mock.lockSynced.Unlock()
	return mock.SyncedFunc()
}

// SyncedCalls gets all the calls that were made to Synced.
// Check the length with:
//
//	len(mockedInterface.SyncedCalls())
func (mock *InterfaceMock) SyncedCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSynced.RLock()
	calls = mock.calls.Synced
	mock.lockSynced.RUnlock()
	return calls
}

// Transactions calls TransactionsFunc.
func (mock *InterfaceMock) Transactions() (accounts.OrderedTransactions, error) {
	if mock.TransactionsFunc == nil {
		panic("InterfaceMock.TransactionsFunc: method is nil but Interface.Transactions was just called")
	}
	callInfo := struct {
	}{}
	mock.lockTransactions.Lock()
	mock.calls.Transactions = append(mock.calls.Transactions, callInfo)
	mock.lockTransactions.Unlock()
	return mock.TransactionsFunc()
}

// TransactionsCalls gets all the calls that were made to Transactions.
// Check the length with:
//
//	len(mockedInterface.TransactionsCalls())
func (mock *InterfaceMock) TransactionsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockTransactions.RLock()
	calls = mock.calls.Transactions
	mock.lockTransactions.RUnlock()
	return calls
}

// TxNote calls TxNoteFunc.
func (mock *InterfaceMock) TxNote(txID string) string {
	if mock.TxNoteFunc == nil {
		panic("InterfaceMock.TxNoteFunc: method is nil but Interface.TxNote was just called")
	}
	callInfo := struct {
		TxID string
	}{
		TxID: txID,
	}
	mock.lockTxNote.Lock()
	mock.calls.TxNote = append(mock.calls.TxNote, callInfo)
	mock.lockTxNote.Unlock()
	return mock.TxNoteFunc(txID)
}

// TxNoteCalls gets all the calls that were made to TxNote.
// Check the length with:
//
//	len(mockedInterface.TxNoteCalls())
func (mock *InterfaceMock) TxNoteCalls() []struct {
	TxID string
} {
	var calls []struct {
		TxID string
	}
	mock.lockTxNote.RLock()
	calls = mock.calls.TxNote
	mock.lockTxNote.RUnlock()
	return calls
}

// TxProposal calls TxProposalFunc.
func (mock *InterfaceMock) TxProposal(txProposalArgs *accounts.TxProposalArgs) (coin.Amount, coin.Amount, coin.Amount, error) {
	if mock.TxProposalFunc == nil {
		panic("InterfaceMock.TxProposalFunc: method is nil but Interface.TxProposal was just called")
	}
	callInfo := struct {
		TxProposalArgs *accounts.TxProposalArgs
	}{
		TxProposalArgs: txProposalArgs,
	}
	mock.lockTxProposal.Lock()
	mock.calls.TxProposal = append(mock.calls.TxProposal, callInfo)
	mock.lockTxProposal.Unlock()
	return mock.TxProposalFunc(txProposalArgs)
}

// TxProposalCalls gets all the calls that were made to TxProposal.
// Check the length with:
//
//	len(mockedInterface.TxProposalCalls())
func (mock *InterfaceMock) TxProposalCalls() []struct {
	TxProposalArgs *accounts.TxProposalArgs
} {
	var calls []struct {
		TxProposalArgs *accounts.TxProposalArgs
	}
	mock.lockTxProposal.RLock()
	calls = mock.calls.TxProposal
	mock.lockTxProposal.RUnlock()
	return calls
}

// VerifyAddress calls VerifyAddressFunc.
func (mock *InterfaceMock) VerifyAddress(addressID string) (bool, error) {
	if mock.VerifyAddressFunc == nil {
		panic("InterfaceMock.VerifyAddressFunc: method is nil but Interface.VerifyAddress was just called")
	}
	callInfo := struct {
		AddressID string
	}{
		AddressID: addressID,
	}
	mock.lockVerifyAddress.Lock()
	mock.calls.VerifyAddress = append(mock.calls.VerifyAddress, callInfo)
	mock.lockVerifyAddress.Unlock()
	return mock.VerifyAddressFunc(addressID)
}

// VerifyAddressCalls gets all the calls that were made to VerifyAddress.
// Check the length with:
//
//	len(mockedInterface.VerifyAddressCalls())
func (mock *InterfaceMock) VerifyAddressCalls() []struct {
	AddressID string
} {
	var calls []struct {
		AddressID string
	}
	mock.lockVerifyAddress.RLock()
	calls = mock.calls.VerifyAddress
	mock.lockVerifyAddress.RUnlock()
	return calls
}
