function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e3 = m2[i];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k2 in e3) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e3, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e3[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$5(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$3 && a2[z$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e3 || B$3;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$2.prototype;
function G$3(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e3 || B$3;
}
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$3(H$3, E$2.prototype);
H$3.isPureReactComponent = true;
var I$2 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e3) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$3(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$2(a2, b2, e3, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$3:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$2(c2) ? (e3 = "", null != a2 && (e3 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e3, "", function(a3) {
      return a3;
    })) : null != c2 && (O$3(c2) && (c2 = N$3(c2, e3 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$2(k2, b2, e3, f2, c2);
    }
  else if (f2 = A$5(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$2(k2, b2, e3, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$3(a2, b2, e3) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$2(a2, d2, "", "", function(a3) {
    return b2.call(e3, a3, c2++);
  });
  return d2;
}
function T$3(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$3 = { current: null }, V$3 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e3) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a2) {
  var b2 = 0;
  S$3(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e3) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$2, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$3 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e3) {
  return U$3.current.useImperativeHandle(a2, b2, e3);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e3) {
  return U$3.current.useReducer(a2, b2, e3);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e3) {
  return U$3.current.useSyncExternalStore(a2, b2, e3);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a2, g2) {
  var b2, d2 = {}, e3 = null, h2 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a2.key && (e3 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e3, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (0 < g2(e3, b2))
          a2[d2] = b2, a2[c2] = e3, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e3 = a2.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e3 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e3 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F3 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H3(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H3, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e3 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H3, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F3)
    S2 = function() {
      F3(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c2 + e3;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H3, c2 - d2))) : (a2.sortIndex = e3, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a2, b2, c2, d2, e3, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$2[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e3 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e3, d2) && (c2 = null), d2 || null === e3 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$4 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2]) {
                var k2 = "\n" + e3[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e3 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c2.length; e3++)
      b2["$" + c2[e3]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e3 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c2) {
        a2[e3].selected = true;
        d2 && (a2[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e3].disabled || (b2 = a2[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$3(91));
  return A$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e3);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
}
var tb = A$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e3 = c2.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d2 = e3.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c2)
          return Xb(e3), a2;
        if (f2 === d2)
          return Xb(e3), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e3, d2 = f2;
    else {
      for (var g2 = false, h2 = e3.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e3;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e3;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e3;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e3;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (3 !== c2.tag)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e3 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e3;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e3, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e3 = 1 << c2, d2 |= a2[c2], b2 &= ~e3;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e3 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e3[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e3[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e3 = 31 - oc(c2), f2 = 1 << e3;
    b2[e3] = 0;
    d2[e3] = -1;
    a2[e3] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e3 = 1 << d2;
    e3 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e3;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e3, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a2;
}
function Uc(a2, b2, c2, d2, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e3)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e3 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e3, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e3 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e3, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e3 = Yc(a2, b2, c2, d2);
    if (null === e3)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e3, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e3[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e3[f2 - d2]; d2++)
    ;
  return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e3, f2, g2) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$2 || be$1 && 8 < be$1 && 11 >= be$1), ee$2 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$2 = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$2;
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$2(a2, b2) {
  if (ie$2)
    return "compositionend" === a2 || !ae$2 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$2(a2) {
  se$2(a2, 0);
}
function te$2(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$2(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2));
    Jb(re$2, b2);
  }
}
function Ce$2(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$2(qe$1);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te$2(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$2(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e3 = c2[d2];
    if (!ja.call(b2, e3) || !He$1(a2[e3], b2[e3]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e3 = c2.textContent.length, f2 = Math.min(d2.start, e3);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
        !a2.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
        e3 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e3 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e3.node || a2.anchorOffset !== e3.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$2(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e3 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$2(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c2 = e3.bind(null, b2, c2, a2);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d2 ? void 0 !== e3 ? a2.addEventListener(b2, c2, { capture: true, passive: e3 }) : a2.addEventListener(b2, c2, true) : void 0 !== e3 ? a2.addEventListener(b2, c2, { passive: e3 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e3) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e4 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F3 = u2.stateNode;
          5 === u2.tag && null !== F3 && (u2 = F3, null !== x2 && (F3 = Kb(w2, x2), null != F3 && t2.push(tf(w2, F3, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e4), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F3 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F3 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F3, w2 + "leave", k3, c2, e4);
            h3.target = J2;
            h3.relatedTarget = u2;
            F3 = null;
            Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e4), t2.target = u2, t2.relatedTarget = J2, F3 = t2);
            J2 = F3;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F3 = x2; F3; F3 = vf(F3))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$2;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e4);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e4);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e4);
      }
      var $a;
      if (ae$2)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je(a2, c2) : ke$2(a2, c2))
        d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c2, e4), g3.push({ event: e4, listeners: d3 }), e4.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e3 = a2, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e3)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e3)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e3) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e3 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e3 = c2.nextSibling;
    a2.removeChild(c2);
    if (e3 && 8 === e3.nodeType)
      if (c2 = e3.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e3;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$2(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c2)
    e3[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$3(168));
  G$2(H$2, b2);
  G$2(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e3 in d2)
    if (!(e3 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e3));
  return A$4({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$2(H$2, a2);
  G$2(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$2(H$2, a2)) : E$1(Wf);
  G$2(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e3;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e3 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e3);
  c2 += 1;
  var f2 = 32 - oc(b2) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b2) + e3 | c2 << e3 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e3 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I$1 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$1)
    return Fg(a2), I$1 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$4({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$3(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e3 = b2.interleaved;
  null === e3 ? (c2.next = c2, Xg(b2)) : (c2.next = e3.next, e3.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e3 = d2.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e3 = d2.interleaved;
  null === e3 ? (b2.next = b2, Xg(d2)) : (b2.next = e3.next, e3.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e3 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
    } else
      e3 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e3 = a2.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
  if (null !== h2) {
    e3.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e3.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$4({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e3.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e3.baseState = k2;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m2;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3)
          throw Error(p$3(191, e3));
        e3.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$4({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e3 = ch(c2, d2);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = dh(a2, e3, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e3, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e3, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e3 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e3) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e3 = a2.stateNode;
  e3.props = c2;
  e3.state = a2.memoizedState;
  e3.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e3.context = Yf(a2, f2));
  e3.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e3.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a2, c2, e3, d2), e3.state = a2.memoizedState);
  "function" === typeof e3.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e3 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e3.refs;
        b3 === jh && (b3 = e3.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e3(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e3(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e4 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e4 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e4 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e4 = c3._init, r2(
            a3,
            b3,
            e4(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e4 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e4) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e4);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e4);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e4);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e4);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e4, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e4, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e4, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e4, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e4, u2), I$1 && tg(e4, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e4, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (u2 = d2(e4, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function t2(e4, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e4, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e4, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e4,
        m3
      ), I$1 && tg(e4, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e3(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e3(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$3(174));
  return a2;
}
function Ih(a2, b2) {
  G$2(Gh, b2);
  G$2(Fh, a2);
  G$2(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh);
  G$2(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$3(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e3, f2) {
  Rh = f2;
  N$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$3(301));
      f2 += 1;
      P$1 = O$2 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e3);
    } while (Th);
  }
  Ph.current = ai$1;
  b2 = null !== O$2 && null !== O$2.next;
  Rh = 0;
  P$1 = O$2 = N$2 = null;
  Sh = false;
  if (b2)
    throw Error(p$3(300));
  return a2;
}
function bi$1() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di$1() {
  if (null === O$2) {
    var a2 = N$2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = null === P$1 ? N$2.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$2 = a2;
  else {
    if (null === a2)
      throw Error(p$3(310));
    O$2 = a2;
    a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
    null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e3 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e3 = f2;
    c2.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$2.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e3 = a2;
    do
      f2 = e3.lane, N$2.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a2);
  } else
    null === e3 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e3 = c2.pending, f2 = b2.memoizedState;
  if (null !== e3) {
    c2.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi$1() {
}
function ii$1(a2, b2) {
  var c2 = N$2, d2 = di$1(), e3 = b2(), f2 = !He$1(d2.memoizedState, e3);
  f2 && (d2.memoizedState = e3, Ug = true);
  d2 = d2.queue;
  ji$1(ki$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li$1(9, mi$1.bind(null, c2, d2, e3, b2), void 0, null);
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(c2, b2, e3);
  }
  return e3;
}
function ni$1(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi$1(b2) && pi$1(a2);
}
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi$1(a2) {
  var b2 = ci$1();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri$1.bind(null, N$2, a2);
  return [b2.memoizedState, a2];
}
function li$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si$1() {
  return di$1().memoizedState;
}
function ti$1(a2, b2, c2, d2) {
  var e3 = ci$1();
  N$2.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui$1(a2, b2, c2, d2) {
  var e3 = di$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$2) {
    var g2 = O$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e3.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, f2, d2);
}
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
function yi$1(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi$1(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
function Ai$1() {
}
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di$1(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei$1(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi$1() {
  return di$1().memoizedState;
}
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e3 = L$2();
    mh(c2, a2, d2, e3);
    Ji$1(c2, b2, d2);
  }
}
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e3 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, e3);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, Xg(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e3, d2);
    null !== c2 && (e3 = L$2(), mh(c2, a2, d2, e3), Ji$1(c2, b2, d2));
  }
}
function Hi$1(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || null !== b2 && b2 === N$2;
}
function Ii$1(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji$1(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai$1 = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi$1.bind(null, N$2, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(false), b2 = a2[0];
  a2 = Ei$1.bind(null, a2[1]);
  ci$1().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e3 = ci$1();
  if (I$1) {
    if (void 0 === c2)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(d2, b2, c2);
  }
  e3.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e3.queue = f2;
  vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi$1,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi$1, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return null === O$2 ? b2.memoizedState = a2 : Di$1(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: false };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e3 = c2;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e3, digest: null };
}
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi$1 || (Pi$1 = true, Qi$1 = d2);
    Mi$1(a2, b2);
  };
  return c2;
}
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e3 = b2.value;
    c2.payload = function() {
      return d2(e3);
    };
    c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi$1(a2, b2);
    "function" !== typeof d2 && (null === Si$1 ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni$1();
    var e3 = /* @__PURE__ */ new Set();
    d2.set(b2, e3);
  } else
    e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
  e3.has(c2) || (e3.add(c2), a2 = Ui$1.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi$1(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi$1(a2, b2, c2, d2, e3) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e3;
  return a2;
}
var Xi$1 = ua.ReactCurrentOwner, Ug = false;
function Yi$1(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi$1(a2, b2, c2, d2, e3) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e3);
  d2 = Xh(a2, b2, c2, d2, f2, e3);
  c2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, d2, e3);
  return b2.child;
}
function aj(a2, b2, c2, d2, e3) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e3);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e3);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e3);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e3) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e3))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e3);
  }
  return dj(a2, b2, c2, d2, e3);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$2(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$2(fj, gj), gj |= d2;
  Yi$1(a2, b2, e3, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e3) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e3);
  c2 = Xh(a2, b2, c2, d2, f2, e3);
  d2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, c2, e3);
  return b2.child;
}
function ij(a2, b2, c2, d2, e3) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e3);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e3), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e3);
}
function kj(a2, b2, c2, d2, e3, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e3 && dg(b2, c2, false), $i$1(a2, b2, f2);
  d2 = b2.stateNode;
  Xi$1.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi$1(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e3 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Yi$1(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e3 |= 1;
  G$2(M$1, e3 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e3 = a2.memoizedState;
  if (null !== e3 && (h2 = e3.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e3, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e3 = a2.child;
    h2 = e3.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e3, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li$1(Error(p$3(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e3 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e3, 0, null);
    f2 = Ah(f2, e3, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e3.data) {
    d2 = e3.nextSibling && e3.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Li$1(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d2.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a2, e3), mh(d2, a2, e3, -1));
    }
    uj();
    d2 = Li$1(Error(p$3(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e3.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e3._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e3) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e3);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
  Yi$1(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$2(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c2 = b2.child;
        for (e3 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b2.child, b2.child = null) : (e3 = c2.sibling, c2.sibling = null);
        xj(b2, false, e3, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i$1(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e3 = b2.memoizedProps.value;
      G$2(Mg, d2._currentValue);
      d2._currentValue = e3;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$2(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$2(M$1, M$1.current & 1);
        a2 = $i$1(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$2(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e3 = a2.memoizedProps;
  if (e3 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e3 = Ya(a2, e3);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e3 = A$4({}, e3, { value: void 0 });
        d2 = A$4({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e3)
      if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h2 = e3[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e3 ? e3[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$2(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a2, e3 = e3.sibling;
  else
    for (e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a2, e3 = e3.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$2(b2);
      return null;
    case 5:
      Lh(b2);
      var e3 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e3), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$3(166));
          S$2(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$2("cancel", d2);
              D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$2(lf[e3], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              );
              D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2);
          e3 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e3 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e3;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$2("cancel", a2);
                D$2("close", a2);
                e3 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2);
                e3 = d2;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$2(lf[e3], a2);
                e3 = d2;
                break;
              case "source":
                D$2("error", a2);
                e3 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                );
                D$2("load", a2);
                e3 = d2;
                break;
              case "details":
                D$2("toggle", a2);
                e3 = d2;
                break;
              case "input":
                Za(a2, d2);
                e3 = Ya(a2, d2);
                D$2("invalid", a2);
                break;
              case "option":
                e3 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e3 = A$4({}, d2, { value: void 0 });
                D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e3 = gb(a2, d2);
                D$2("invalid", a2);
                break;
              default:
                e3 = d2;
            }
            ub(c2, e3);
            h2 = e3;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$2(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$3(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$2(b2);
      return null;
    case 13:
      E$1(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$2(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$2 && (T$2 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$2(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$2(b2), null;
    case 10:
      return Rg(b2.type._context), S$2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 19:
      E$1(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$2(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$2 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$2(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S$2(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$2(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$2 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$2();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F3) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g2 + e3);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e3 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$2 = b2; null !== V$2; )
    if (b2 = V$2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$2 = a2;
    else
      for (; null !== V$2; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F3) {
          W$1(b2, b2.return, F3);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e3 = d2 = d2.next;
    do {
      if ((e3.tag & a2) === a2) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e3 = e3.next;
    } while (e3 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$2 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e3 = Yj;
      X$2 = null;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e3;
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2;
      e3 = Yj;
      X$2 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e3 = d2 = d2.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e3 = e3.next;
        } while (e3 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || null !== c2.memoizedState, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$2)
          throw Error(p$3(160));
        ak(f2, g2, e3);
        X$2 = null;
        Yj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W$1(e3, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e3 = a2.stateNode;
        try {
          ob(e3, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e3 = a2.stateNode, null != e3)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$3(162));
        e3 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e3 = a2.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B$2()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$2 = m2; null !== V$2; ) {
              r2 = V$2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e3 = d2.stateNode;
          d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$2 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$2; ) {
    var e3 = V$2, f2 = e3.child;
    if (22 === e3.tag && d2) {
      var g2 = null !== e3.memoizedState || Kj;
      if (!g2) {
        var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$2;
        h2 = Kj;
        var l2 = U$2;
        Kj = g2;
        if ((U$2 = k2) && !l2)
          for (V$2 = e3; null !== V$2; )
            g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e3) : null !== k2 ? (k2.return = g2, V$2 = k2) : kk(e3);
        for (; null !== f2; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e3;
        Kj = h2;
        U$2 = l2;
      }
      lk(a2);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$2 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e3 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e3, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e3 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e3, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$2 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi$1 = false, Qi$1 = null, Si$1 = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K$1 & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$2)
    return Z$2 & -Z$2;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$1)
    a2 === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$2 && Dk(a2, Z$2)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e3 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a2 || Z$2 !== b2)
      vk = null, Hj = B$2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e3;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$2 = 0, b2 = T$2);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a2), 0 !== e3 && (d2 = e3, b2 = Ok(a2, e3)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e3 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e3) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      a2.finishedWork = e3;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e3 = a2.suspendedLanes;
            if ((e3 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e3;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e3 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e3 && (e3 = g2);
            d2 &= ~f2;
          }
          d2 = e3;
          d2 = B$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Ek(a2, B$2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e3 = c2[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He$1(f2(), e3))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (6 === c2)
    throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$2 = gj = b2;
  T$2 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e3 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai$1;
      if (Sh) {
        for (var d2 = N$2.memoizedState; null !== d2; ) {
          var e3 = d2.queue;
          null !== e3 && (e3.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$2 = N$2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$2 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$2;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi$1(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti$1(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi$1(J2, g2, h2, f2, b2);
            Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2);
        4 !== T$2 && (T$2 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi$1(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si$1 || !Si$1.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F3 = Ri$1(f2, h2, b2);
                fh(f2, F3);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai$1;
  return null === a2 ? ai$1 : a2;
}
function uj() {
  if (0 === T$2 || 3 === T$2 || 2 === T$2)
    T$2 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$2);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a2 || Z$2 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a2, e3);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$3(261));
  R$1 = null;
  Z$2 = 0;
  return T$2;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$2 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$2 && (T$2 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e3 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e3, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e3 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$1 && (Y$1 = R$1 = null, Z$2 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e3);
  f2 = a2.pendingLanes;
  0 === f2 && (Si$1 = null);
  mc(c2.stateNode);
  Ek(a2, B$2());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e3 = b2[c2], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi$1)
    throw Pi$1 = false, a2 = Qi$1, Qi$1 = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$3(331));
        var e3 = K$1;
        K$1 |= 4;
        for (V$2 = a2.current; null !== V$2; ) {
          var f2 = V$2, g2 = f2.child;
          if (0 !== (V$2.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; null !== V$2; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; null !== V$2; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$2 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; null !== V$2; ) {
                f2 = V$2;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$2 = x2;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; null !== V$2; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; null !== V$2; ) {
                h2 = V$2;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F3 = h2.sibling;
                if (null !== F3) {
                  F3.return = h2.return;
                  V$2 = F3;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        K$1 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2);
  b2 = Oi$1(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si$1 || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2);
          a2 = Ri$1(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$1 === a2 && (Z$2 & c2) === c2 && (4 === T$2 || 3 === T$2 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e3 = a2.memoizedState;
      null !== e3 && (c2 = e3.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e3 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e3 = Xh(null, b2, d2, a2, e3, c2);
      var f2 = bi$1();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b2), e3.updater = nh, b2.stateNode = e3, e3._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi$1(null, b2, e3, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e3 = d2._init;
        d2 = e3(d2._payload);
        b2.type = d2;
        e3 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e3) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), dj(a2, b2, d2, e3, c2);
    case 1:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), ij(a2, b2, d2, e3, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e3 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ki$1(Error(p$3(423)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ki$1(Error(p$3(424)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e3) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi$1(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e3.children, Ef(d2, e3) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi$1(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi$1(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), Zi$1(a2, b2, d2, e3, c2);
    case 7:
      return Yi$1(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e3 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e3.value;
        G$2(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$3(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi$1(a2, b2, e3.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e3 = Vg(e3), d2 = d2(e3), b2.flags |= 1, Yi$1(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e3 = Lg(d2, b2.pendingProps), e3 = Lg(d2.type, e3), aj(a2, b2, d2, e3, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e3), rh(b2, d2, e3, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e3, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e3, f2, b2);
        case za:
          g2 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e3 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e3), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e3), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e3, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e3);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e3) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e3, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e3 = lh(c2);
  f2 = ch(d2, e3);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e3);
  a2.current.lanes = e3;
  Ac(a2, e3, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e3 = b2.current, f2 = L$2(), g2 = lh(e3);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e3, b2, g2);
  null !== a2 && (mh(a2, e3, g2, f2), eh(a2, e3, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$3(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e3) {
  if (e3) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e3 = a2.lastChild; )
    a2.removeChild(e3);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e3) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h2 = e3;
      e3 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e3);
  } else
    g2 = rl(c2, b2, a2, e3, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e3 = Db(d2);
            if (!e3)
              throw Error(p$3(90));
            Wa(d2);
            bb(d2, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$3(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$3(299));
  var c2 = false, d2 = "", e3 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e3);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e3 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e3 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e3, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e3 = c2._getVersion, e3 = e3(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e3] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e3
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$3(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$3 = reactDomExports;
{
  createRoot = m$3.createRoot;
  m$3.hydrateRoot;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true
};
var i18nInstance;
var I18nContext = React.createContext();
function getDefaults() {
  return defaultOptions;
}
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns2) {
        if (!_this.usedNamespaces[ns2])
          _this.usedNamespaces[ns2] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
function getI18n() {
  return i18nInstance;
}
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn.apply(void 0, args);
}
function loadNamespaces(i18n, ns2, cb2) {
  i18n.loadNamespaces(ns2, function() {
    if (i18n.isInitialized) {
      cb2();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function oldI18nextHasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  var loadNotPending = function loadNotPending2(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  };
  if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns2))
    return false;
  if (i18n.hasResourceBundle(lng, ns2))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)))
    return true;
  return false;
}
function hasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns2, i18n, options2);
  }
  return i18n.hasLoadedNamespace(ns2, {
    precheck: function precheck(i18nInstance2, loadNotPending) {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns2))
        return false;
    }
  });
}
function getDisplayName(Component) {
  return Component.displayName || Component.name || (typeof Component === "string" && Component.length > 0 ? Component : "Unknown");
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e3 = i.call(t2)).done) && (a2.push(e3.value), a2.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function useTranslation(ns2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref3 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref3.i18n, defaultNSFromContext = _ref3.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, getDefaults()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = ns2 || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var isMounted = reactExports.useRef(true);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces, function() {
        if (isMounted.current)
          setT(getT);
      });
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach(function(e3) {
          return i18n.off(e3, boundReset);
        });
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach(function(e3) {
          return i18n.store.off(e3, boundReset);
        });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces, function() {
      resolve();
    });
  });
}
var _excluded$8 = ["forwardedRef"];
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function withTranslation(ns2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function Extend(WrappedComponent) {
    function I18nextWithTranslation(_ref3) {
      var forwardedRef = _ref3.forwardedRef, rest = _objectWithoutProperties(_ref3, _excluded$8);
      var _useTranslation = useTranslation(ns2, rest), _useTranslation2 = _slicedToArray(_useTranslation, 3), t2 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2];
      var passDownProps = _objectSpread$7(_objectSpread$7({}, rest), {}, {
        t: t2,
        i18n,
        tReady: ready
      });
      if (options2.withRef && forwardedRef) {
        passDownProps.ref = forwardedRef;
      } else if (!options2.withRef && forwardedRef) {
        passDownProps.forwardedRef = forwardedRef;
      }
      return React.createElement(WrappedComponent, passDownProps);
    }
    I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName(WrappedComponent), ")");
    I18nextWithTranslation.WrappedComponent = WrappedComponent;
    var forwardRef = function forwardRef2(props, ref) {
      return React.createElement(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    };
    return options2.withRef ? React.forwardRef(forwardRef) : I18nextWithTranslation;
  };
}
function I18nextProvider(_ref3) {
  var i18n = _ref3.i18n, defaultNS = _ref3.defaultNS, children2 = _ref3.children;
  var value = reactExports.useMemo(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return reactExports.createElement(I18nContext.Provider, {
    value
  }, children2);
}
/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref3) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref3;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function createURL(location) {
  let base3 = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown";
  let href = typeof location === "string" ? location : createPath(location);
  return new URL(href, base3);
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options2;
  let globalHistory = window2.history;
  let action2 = Action.Pop;
  let listener = null;
  function handlePop() {
    action2 = Action.Pop;
    if (listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  function push(to, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error3) {
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  function replace2(to, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn3) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn3;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(location) {
      let url = createURL(createPath(location));
      return _extends$3({}, location, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route2, index2) => {
    let meta = {
      relativePath: route2.path || "",
      caseSensitive: route2.caseSensitive === true,
      childrenIndex: index2,
      route: route2
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route2.children && route2.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route2.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route2.children, branches, routesMeta, path);
    }
    if (route2.path == null && !route2.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route2.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route2 = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route: route2
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning$p(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_24, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error3) {
    warning$p(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error3 + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error3) {
    warning$p(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error3 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value, message2) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message2);
  }
}
function warning$p(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e3) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field2, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field2 + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$3({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
class ErrorResponse {
  constructor(status2, statusText, data) {
    this.status = status2;
    this.statusText = statusText || "";
    this.data = data;
  }
}
function isRouteErrorResponse(e3) {
  return e3 instanceof ErrorResponse;
}
const validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
/* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
const is$1 = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe2, getSnapshot, getServerSnapshot) {
  const value = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe2, value, getSnapshot]);
  useEffect(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe2(handleStoreChange);
  }, [subscribe2]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is$1(prevValue, nextValue);
  } catch (error3) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$1;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? ((module) => module.useSyncExternalStore)(React$1) : shim;
const DataStaticRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate2 = reactExports.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate2;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterStateContext = reactExports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error3 = useRouteError();
  let message2 = isRouteErrorResponse(error3) ? error3.status + " " + error3.statusText : error3 instanceof Error ? error3.message : JSON.stringify(error3);
  let stack = error3 instanceof Error ? error3.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ reactExports.createElement("p", null, " Hey developer "), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error3) {
    return {
      error: error3
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error3, errorInfo) {
    console.error("React Router caught the following error during render", error3, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref3) {
  let {
    routeContext,
    match: match2,
    children: children2
  } = _ref3;
  let dataStaticRouterContext = reactExports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match2.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children2);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error3 = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ reactExports.createElement(DefaultErrorElement, null) : null;
    let getChildren = () => /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      }
    }, error3 ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet);
    return dataRouterState && (match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error3,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteError() {
  var _state$errors;
  let error3 = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route2 = reactExports.useContext(RouteContext);
  let thisRoute = route2.matches[route2.matches.length - 1];
  if (error3) {
    return error3;
  }
  !route2 ? invariant(false) : void 0;
  !thisRoute.route.id ? invariant(false) : void 0;
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function Route(_props) {
  invariant(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children: children2 = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search, hash2, state, key]);
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children: children2,
    value: {
      location,
      navigationType
    }
  }));
}
function Routes(_ref5) {
  let {
    children: children2,
    location
  } = _ref5;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children2 ? dataRouterContext.router.routes : createRoutesFromChildren(children2);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children2, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children2, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let treePath = [...parentPath, index2];
    let route2 = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route2.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route2);
  });
  return routes;
}
/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event2) {
  return !!(event2.metaKey || event2.altKey || event2.ctrlKey || event2.shiftKey);
}
function shouldProcessLinkClick(event2, target) {
  return event2.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event2);
}
const _excluded$7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref3) {
  let {
    basename,
    children: children2,
    window: window2
  } = _ref3;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  reactExports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children: children2,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded$7);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event2) {
    if (onClick)
      onClick(event2);
    if (!event2.defaultPrevented) {
      internalOnClick(event2);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$1({}, rest, {
      href,
      onClick: reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to,
    children: children2
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2$2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let toPathname = path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$1({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to
  }), typeof children2 === "function" ? children2({
    isActive,
    isPending
  }) : children2);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate2 = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event2) => {
    if (shouldProcessLinkClick(event2, target)) {
      event2.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate2(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate2, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
const useMountedRef = () => {
  const isMountedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
};
const useSubscribeReset = (subscription) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const subscribe2 = () => {
    return subscription((data) => {
      if (mounted.current) {
        setResponse(data);
      }
    });
  };
  reactExports.useEffect(
    () => subscribe2(),
    // empty dependencies because it's only subscribed once
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return [response, () => setResponse(void 0)];
};
const useSubscribe = (subscription) => {
  const [response] = useSubscribeReset(subscription);
  return response;
};
const useLoad = (apiCall, dependencies) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const load = () => {
    if (apiCall === null) {
      return;
    }
    apiCall().then((data) => {
      if (mounted.current) {
        setResponse(data);
      }
    });
  };
  reactExports.useEffect(
    () => load(),
    // By default no dependencies are passed to only query once
    dependencies || []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return response;
};
const useSync = (apiCall, subscription) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const onData = (data) => {
    if (mounted.current) {
      setResponse(data);
    }
  };
  reactExports.useEffect(
    () => {
      apiCall().then(onData);
      return subscription(onData);
    },
    // we pass no dependencies because it's only queried once
    []
  );
  return response;
};
function useDefault(value, defaultValue) {
  return value !== void 0 ? value : defaultValue;
}
const usePrevious = (value) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    if (console && console[type2])
      console[type2].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [];
        _this.observers[event2].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event2, listener) {
      if (!this.observers[event2])
        return;
      if (!listener) {
        delete this.observers[event2];
        return;
      }
      this.observers[event2] = this.observers[event2].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject2) {
    res = resolve;
    rej = reject2;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy$1(a2, s, t2) {
  a2.forEach(function(m2) {
    if (s[m2])
      t2[m2] = s[m2];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat2)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat2)
    obj[k2].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i, i + j2).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i + j2) {
        j2++;
        p2 = paths.slice(i, i + j2).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (path.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$1(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns2) {
      if (this.options.ns.indexOf(ns2) < 0) {
        this.options.ns.push(ns2);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns2) {
      var index2 = this.options.ns.indexOf(ns2);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns2];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns2], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns2, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path = [lng, ns2];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns2;
        ns2 = path[1];
      }
      this.addNamespaces(ns2);
      setPath(this.data, path, value);
      if (!options2.silent)
        this.emit("added", lng, ns2, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns2, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources) {
        if (typeof resources[m2] === "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]")
          this.addResource(lng, ns2, m2, resources[m2], {
            silent: true
          });
      }
      if (!options2.silent)
        this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns2, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns2];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns2;
        ns2 = path[1];
      }
      this.addNamespaces(ns2);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path, pack);
      if (!options2.silent)
        this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns2) {
      if (this.hasResourceBundle(lng, ns2)) {
        delete this.data[lng][ns2];
      }
      this.removeNamespaces(ns2);
      this.emit("removed", lng, ns2);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns2) {
      return this.getResource(lng, ns2) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns2) {
      if (!ns2)
        ns2 = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns2));
      return this.getResource(lng, ns2);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options2, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options2, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1$1(Translator2);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy$1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate2(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2)
        options2 = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count, options2) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk2 = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: false
            }));
            if (fk2 && fk2.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send2 = function send3(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language2) {
                _this2.pluralResolver.getSuffixes(language2, options2).forEach(function(suffix) {
                  send2([language2], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send2(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options2.nest = false;
        }
        if (options2.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options2.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options2);
        if (options2.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options2.context !== void 0 && (typeof options2.context === "string" || typeof options2.context === "number") && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns2) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns2;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2);
              var zeroSuffix = "_zero";
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options2.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns2, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns2, key, options2);
      return this.resourceStore.getResource(code, ns2, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix2 = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options2[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc2) {
        if (codes.indexOf(fc2) < 0)
          addCode(_this2.formatLanguageCode(fc2));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n2) {
    return Number(n2 > 1);
  },
  2: function _2(n2) {
    return Number(n2 != 1);
  },
  3: function _3(n2) {
    return 0;
  },
  4: function _4(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _9(n2) {
    return Number(n2 >= 2);
  },
  10: function _10(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _11(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _12(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _13(n2) {
    return Number(n2 !== 0);
  },
  14: function _14(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _15(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _17(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _19(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options2);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options2).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options2);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options2);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options2);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation)
        options2.interpolation = {
          escapeValue: true
        };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options2) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match2, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += safeValue.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc2) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e3) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e3);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val.trim();
        if (val.trim() === "false")
          formatOptions[key.trim()] = false;
        if (val.trim() === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val.trim()))
          formatOptions[key.trim()] = parseInt(val.trim(), 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options2;
    this.formats = {
      number: function number(val, lng, options3) {
        return new Intl.NumberFormat(lng, options3).format(val);
      },
      currency: function currency2(val, lng, options3) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options3) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options3)).format(val);
      },
      relativetime: function relativetime(val, lng, options3) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options3)).format(val, options3.range || "day");
      },
      list: function list2(val, lng, options3) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options3)).format(val);
      }
    };
    this.init(options2);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }
  }, {
    key: "format",
    value: function format(value, _format, lng, options2) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function remove(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options2, callback2) {
      var _this2 = this;
      var toLoad = [];
      var pending2 = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns2) {
          var name = "".concat(lng, "|").concat(ns2);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns2)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending2.indexOf(name) < 0)
              pending2.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending2.indexOf(name) < 0)
              pending2.push(name);
            if (toLoad.indexOf(name) < 0)
              toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns2) < 0)
              toLoadNamespaces.push(ns2);
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending2.length) {
        this.queue.push({
          pending: pending2,
          loaded: {},
          errors: [],
          callback: callback2
        });
      }
      return {
        toLoad,
        pending: pending2,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split("|");
      var lng = s[0];
      var ns2 = s[1];
      if (err)
        this.emit("failedLoading", lng, ns2, err);
      if (data) {
        this.store.addResourceBundle(lng, ns2, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns2);
        remove(q2.pending, name);
        if (err)
          q2.errors.push(err);
        if (q2.pending.length === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = [];
            if (q2.loaded[l2].length) {
              q2.loaded[l2].forEach(function(ns3) {
                if (loaded2[l2].indexOf(ns3) < 0)
                  loaded2[l2].push(ns3);
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns2, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback2 = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback2(null, {});
      return this.backend[fcName](lng, ns2, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns2, fcName, tried + 1, wait2 * 2, callback2);
          }, wait2);
          return;
        }
        callback2(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback2 = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback2 && callback2();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options2, callback2);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback2();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {}, callback2);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback2);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns2 = s[1];
      this.read(lng, ns2, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns2, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns2, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function noop$1() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback2 = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback2 && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback2);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback2);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback2 = options2;
        options2 = {};
      }
      if (!options2.defaultNS && options2.ns) {
        if (typeof options2.ns === "string") {
          options2.defaultNS = options2.ns;
        } else if (options2.ns.indexOf("translation") < 0) {
          options2.defaultNS = options2.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options2.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options2.keySeparator;
      }
      if (options2.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options2.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init)
            s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init)
            m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback2)
        callback2 = noop$1;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish2 = function finish3(err, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback2(err, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish2(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish2);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language2) {
      var _this3 = this;
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
      var usedCallback = callback2;
      var usedLng = typeof language2 === "string" ? language2 : this.language;
      if (typeof language2 === "function")
        usedCallback = language2;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append2 = function append3(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        } else {
          append2(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e3) {
          if (!e3 && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e3);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns2, callback2) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns2)
        ns2 = this.options.ns;
      if (!callback2)
        callback2 = noop$1;
      this.services.backendConnector.reload(lngs, ns2, function(err) {
        deferred.resolve();
        callback2(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li2 = 0; li2 < this.languages.length; li2++) {
        var lngInLngs = this.languages[li2];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback2) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback2)
          callback2(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns2, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread$6({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = keyPrefix ? "".concat(keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns2;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns2) {
      this.options.defaultNS = ns2;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns2) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns2))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns2, callback2) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback2 && callback2();
        return Promise.resolve();
      }
      if (typeof ns2 === "string")
        ns2 = [ns2];
      ns2.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback2) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback2)
          callback2();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event2].concat(args));
      });
      clone.init(mergedOptions, callback2);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback2 = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback2);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
var t$1 = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const getNativeLocale = () => {
  return apiGet("native-locale");
};
const account$i = {
  disconnect: " .   ...",
  "export": "",
  exportTransactions: "        CSV",
  fatalError: "   ",
  incoming: " ",
  initializing: "   ...",
  maybeProxyError: "   .              ",
  reconnecting: " ,    ...",
  syncedAddressesCount: "  {{count}} "
};
const accountInfo$i = {
  address: "",
  buyCTA: {
    buy: " {{unit}}",
    buyCrypto: " ",
    information: {
      looksEmpty: "    ",
      start: "              BitBoxApp"
    }
  },
  extendedPublicKey: "  ",
  label: " ",
  scriptType: "  ",
  title: " ",
  verify: "    ",
  xpubTypeChangeBtn: {
    p2pkh: "      P2PKH ",
    p2tr: " ",
    p2wpkh: " Segwit ",
    "p2wpkh-p2sh": "      Segwit "
  },
  xpubTypeInfo: "   {{scriptType}}    ({{current}}  {{numberOfXPubs}})"
};
const accountSummary$i = {
  availableBalance: " ",
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: "  ",
  name: " ",
  noAccount: "   ",
  subtotalWithCoinName: " ({{coinName}})",
  title: " ",
  total: "",
  transactionHistory: " "
};
const addAccount$j = {
  chooseName: {
    nextButton: " ",
    step: " ",
    title: "  "
  },
  selectCoin: {
    nextButton: "",
    step: " ",
    title: "  "
  },
  success: {
    message: "  <strong>{{accountName}}</strong>  ",
    nextButton: "",
    step: "",
    title: "  "
  },
  title: " "
};
const aopp$c = {
  addressRequest: "{{host}}   ",
  addressRequestWithLogo: "  ",
  banner: "  ",
  errorTitle: "     ",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: " ",
  signing: ",      BitBox02",
  success: {
    message: "  {{host}}",
    title: "   "
  },
  syncing: "    ,  ",
  title: " "
};
const app$i = {
  upgrade: "     .    {{current}}  {{version}}"
};
const backup$i = {
  check: {
    checking: "   ...",
    confirmTitle: "    ",
    notOK: "    ",
    ok: "   ",
    password: {
      label: "  ",
      placeholder: "  ",
      showLabel: "  "
    },
    success: "     ",
    title: "    "
  },
  create: {
    alreadyExists: "    ,     ",
    fail: "    ",
    info: "         ",
    name: {
      label: "  ",
      placeholder: "   "
    },
    password: {
      label: "  ",
      placeholder: "    "
    },
    title: "   ",
    verificationFailed: "      .    .            "
  },
  description: "<strong>   </strong>",
  insert: "   microSD   ",
  insertButton: "    microSD",
  list: "     microSD  ",
  noBackups: "       microSD",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   microSD",
      general: "      "
    },
    password: {
      label: "       ",
      placeholder: "  ",
      repeatPlaceholder: "   ",
      showLabel: "  "
    },
    restoring: "  ...",
    selectedBackup: "<strong>{{backupName}}</strong>    {{createdDateTime}}  ",
    title: "",
    understand: "           "
  },
  showMnemonic: {
    description: "     ,       .      \n<strong>           </strong>\n<strong>       </strong>\n<strong>      </strong>\n      ",
    title: "  "
  },
  title: "  "
};
const bb02Bootloader$i = {
  abort: "   -  ",
  abort_noUpgrade: " ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "        \n"
  },
  flipscreen: " ",
  orientation: "      ",
  success: "  !    {{rebootSeconds}} ...",
  success_install: "  !    {{rebootSeconds}} ..."
};
const bitbox$i = {
  error: {
    e10000: "    ",
    e10001: "     ",
    e102: "         ",
    e112: "            "
  }
};
const bitbox02Interact$i = {
  confirmDate: "      BitBox02",
  confirmDateText: "      ",
  confirmName: "     BitBox02",
  followInstructions: "     BitBox02",
  followInstructionsMnemonic: "     BitBox02           ",
  followInstructionsMnemonicTitle: "     "
};
const bitbox02Settings$i = {
  deviceName: {
    current: "  ",
    input: " BitBox02",
    placeholder: "  ",
    title: "   BitBox02"
  },
  gotoStartupSettings: {
    description: "      BitBox02      ",
    title: "    "
  }
};
const bitbox02Wizard$i = {
  attestationFailed: "   ,              .      .     support@shiftcrypto.ch    ",
  backup: {
    point1: "      microSD",
    point2: "    ",
    restoreText: "    ",
    text1: ",      BitBox02   .       .      microSD   BitBox02  ",
    text2: "           ",
    text3: "       microSD   <strong> </strong>.   microSD    .           BitBox02  .",
    userConfirmation1: "          ",
    userConfirmation2: "       .             ",
    userConfirmation3: "     BitBox02              ",
    userConfirmation4: "          BitBox02    ",
    userConfirmation5: "        microSD             BitBox02"
  },
  create: {
    button: "    ",
    info: "         BitBox  : ",
    inputTitle: " ",
    point1: "  ",
    point2: "    ",
    point3: "   ",
    text: "     "
  },
  createBackupFailed: "       ",
  initialize: {
    passwordText: "     .     BitBox   ",
    passwordTitle: "     BitBox  ",
    text: "    BitBox02  !     .            . <strong>     microSD  BitBox02  </strong>",
    tip: "    ",
    title: "  BitBox  "
  },
  insertSDCard: "<strong>     microSD  BitBox02  .</strong>",
  noPasswordMatch: "   .   ",
  pairing: {
    failed: "   .    BitBox02  ",
    paired: "       .          ",
    title: "   ",
    unpaired: "  BitBox02 .             .         BitBox02           "
  },
  restoreFromMnemonic: {
    failed: "         "
  },
  stepBackup: {
    beforeProceed: "       :",
    createBackup: "       microSD  "
  },
  stepBackupSuccess: {
    fundsSafe: "       :",
    title: "    "
  },
  stepConnected: {
    unlock: "   BitBox02   "
  },
  stepCreate: {
    description: "        ",
    nameLabel: "  BitBox02",
    namePlaceholder: " BitBox02",
    title: "    BitBox02",
    toastMicroSD: "     microSD  BitBox02  "
  },
  stepCreateSuccess: {
    removeMicroSD: "   microSD  BitBox02    ",
    success: "     "
  },
  stepInsertSD: {
    insertSDCard: "   microSD  BitBox02 ",
    insertSDcardTitle: "   microSD"
  },
  stepPassword: {
    title: "    BitBox02",
    useControls: "     BitBox02   "
  },
  stepUninitialized: {
    create: "   BitBox02 ",
    restore: "     ",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "   ",
    title: "  BitBox02  "
  },
  success: {
    text: "!  BitBox02   \n\n       BitBox                ",
    title: "  "
  }
};
const blink$i = {
  button: ""
};
const bootloader$i = {
  button: "    ",
  button_install: "    ",
  progress: ": {{progress}}",
  progress_install: ": {{progress}}",
  success: "  !    .      "
};
const button$n = {
  abort: "",
  back: "",
  buy: "",
  changepin: "    ",
  check: "    ",
  "continue": "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: "",
  upgrade: " "
};
const buy$e = {
  info: {
    "continue": "  ",
    crypto: "",
    disclaimer: {
      intro: [
        "   MoonPay      {{name}}    BitBox.    ",
        " MoonPay    {{name}}      160 "
      ],
      payment: {
        details: "  {{name}}    MoonPay    .               .       .     4   /    ",
        footnote: "     MoonPay        BitBoxApp       ",
        table: {
          "1_description": "       3  ",
          "1_method": "  (SEPA)",
          "2_description": "    ",
          "2_method": "  ",
          description: "",
          fee: "",
          method: ""
        },
        title: "  "
      },
      privacyPolicy: "   MoonPay",
      protection: {
        description: "  BitBoxApp      {{name}}        .  MoonPay      .           ",
        title: " "
      },
      security: {
        description: "  {{name}}  MoonPay     .          BitBox02          BitBoxApp",
        link: "   ",
        title: " "
      },
      title: "      {{name}}"
    },
    next: "",
    selectLabel: " ",
    selectPlaceholder: " ",
    skip: "   ",
    title: " {{name}}"
  },
  title: " {{name}}"
};
const changePin$i = {
  newTitle: "   ",
  oldLabel: "   "
};
const chart$e = {
  dataMissing: "   ...  ",
  dataUpdating: " ...",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
};
const checkSDcard$i = "   microSD";
const clickHere$i = " ";
const confirm$k = {
  abortInfo: "  ",
  abortInfoRedText: "",
  approveInfo: "    4    ",
  approveInfoGreenText: "",
  info: "   BitBox  ",
  infoWhenPaired: "       BitBox  "
};
const confirmOnDevice$i = "   ";
const device$i = {
  appUpradeRequired: " BitBox        .     "
};
const deviceLock$i = {
  button: "   (2FA)",
  condition1: "   ",
  condition2: "      ",
  condition3: "  2FA        .        2FA!",
  confirm: "    (2FA)",
  title: "    (2FA)"
};
const deviceSettings$i = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: " ",
    upToDate: "  ",
    version: {
      label: ""
    }
  },
  hardware: {
    attestation: {
      "false": "   ",
      label: "  ",
      "true": " BitBox02   "
    },
    sdcard: {
      "false": "  ",
      label: " microSD",
      "true": " "
    },
    securechip: " ",
    title: ""
  },
  loading: "    ...",
  pairing: {
    lock: {
      "false": "",
      label: "   (2FA)",
      "true": ""
    },
    mobile: {
      "false": "",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": ""
    },
    title: " "
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
};
const deviceTampered$i = "   BitBox                .    Shift           ";
const dialog$j = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
};
const error$e = {
  accountAlreadyExists: "  ",
  accountLimitReached: "   .         ",
  aoppCallback: "      {{host}}",
  aoppInvalidRequest: "  ",
  aoppNoAccounts: "   ",
  aoppSigningAborted: "    ",
  aoppUnknown: "   ",
  aoppUnsupportedAsset: "  ",
  aoppUnsupportedFormat: "       ",
  aoppUnsupportedKeystore: "       ",
  aoppVersion: "  "
};
const fiat$k = {
  "default": " ",
  setDefault: " {{code}}  ",
  title: ""
};
const footer$k = {
  appVersion: " :"
};
const generic$e = {
  enabled_false: "",
  enabled_true: ""
};
const genericError$i = " .         ";
const goal$i = {
  buttons: {
    create: "  ",
    restore: "    "
  },
  paragraph: "     :",
  step: {
    "1": {
      title: " "
    },
    "2": {
      description: "    ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$j = {
  accountDescription: {
    text: '         .    ""         ',
    title: "      "
  },
  accountFiat: {
    text: ".         .      ",
    title: "     "
  },
  accountIncomingBalance: {
    text: "             ",
    title: "   "
  },
  accountInfo: {
    multipleXPubs: {
      text: '   xpub "" :  "Segwit (bech32)  "  "Segwit "  "Taproot" ( ).         {{coinName}}.  BitBoxApp           .        xpub    xpub  .\n\n        (Native Segwit)      xpub "bech32".         "Wrapped Segwit"  "Taproot"         "Wrapped Segwit"  "Taproot" ',
      title: "     xpub"
    },
    privacy: {
      text: "              .  xpub      \n\n  xpub                  .              ",
      title: "     xpub"
    },
    verify: {
      text: "        xpub  .             xpub    .           xpub   .          .",
      title: "     xpub  "
    },
    xpub: {
      text: "   (xpub)          .\n\n              Electrum  Sentinel.           xpub        .\n\n         Taproot xpubs  ",
      title: "    "
    }
  },
  accountRates: {
    text: "       CoinGecko",
    title: "    "
  },
  accountReload: {
    text: "  .     ",
    title: "     "
  },
  accountSendDisabled: {
    text: '   ""      ',
    title: "     {{unit}}"
  },
  accountSummaryAmount: {
    text: "        .        coingecko.com\n\n:     MyEtherWallet     BitBoxApp       ",
    title: "    "
  },
  accountSummaryDescription: {
    text: "       .       ",
    title: "      "
  },
  accountTransactionAttributesBTC: {
    text: " :   .           .\n:          .\n:      Segwit    .      Segwit        .                 ",
    title: "     "
  },
  accountTransactionAttributesGeneric: {
    text: ":                   .          .                    .\n :           .\n:              .       .",
    title: "      "
  },
  accountTransactionConfirmation: {
    text: "         ",
    title: "   "
  },
  accountTransactionLabel: {
    text: "         ",
    title: "       "
  },
  accountTransactionTime: {
    text: "    ",
    title: "   "
  },
  accounts: {
    howManyAccounts: {
      text: "        ",
      title: "     "
    },
    howtoAddTokens: {
      text: '     ERC20   Ethereum .        " "     Ethereum         ',
      title: "    "
    },
    moveFunds: {
      text: ".             ",
      title: "     "
    },
    recoverAccounts: {
      text: ".   BitBoxApp           ",
      title: "     "
    },
    whatAreAccounts: {
      text: "      .         ",
      title: "  "
    },
    whyIsThisUseful: {
      text: '         .    "  "          .                   ',
      title: "  "
    }
  },
  appendix: {
    link: " !",
    text: " "
  },
  backups: {
    check: {
      text: '  "   "            .             .            ',
      title: '  "  "'
    },
    encrypt: {
      text: "            ",
      title: "    "
    },
    howOften: {
      text: "        .            microSD           microSD  .\n         .                  ",
      title: "      "
    },
    whatIsABackup: {
      text: "        microSD.       ",
      title: "   "
    }
  },
  backupsBB02: {
    check: {
      text: '  "   "            ',
      title: '  "  "'
    },
    encrypt: {
      text: '.     microSD            .                   " "',
      title: "    "
    },
    whatIsABackup: {
      text: "        microSD",
      title: "   "
    }
  },
  bitbox: {
    "2FA": {
      text: "    (2FA)              .                      BitBox     .                   \n\n             2FA.       microSD    .        BitBox    ",
      title: "    (2FA)"
    },
    disable2FA: {
      text: '   (2FA)      BitBox          .        microSD          .    "  ".        "   ".            ""         ',
      title: "     (2FA)"
    },
    ejectBitbox: {
      text: "  BitBox        ",
      title: "   BitBox"
    },
    ejectSD: {
      text: "   microSD  BitBox            ",
      title: "    microSD"
    },
    hiddenWallet: {
      text: "                    .                 ",
      title: "   "
    },
    legacyHiddenWallet: {
      text: "      (     BitBox       2FA)     Bitbox         ",
      title: "      "
    },
    pairing: {
      text: "         iOS  Android                  .         ",
      title: "    "
    }
  },
  cointracking: {
    text: '   ""        CSV.          BitBox CSV             CoinTracking   ',
    title: "    CoinTracking"
  },
  device: {
    attestation: {
      link: {
        text: "      "
      },
      text: "  BitBoxApp      BitBox02      .       ",
      title: "     "
    },
    name: {
      text: "     .             .                   ",
      title: "    BitBox02 "
    },
    "secure-chip": {
      link: {
        text: "    "
      },
      text: "      .    ATECC608B       ",
      title: "    "
    }
  },
  receive: {
    address: {
      text: "       .        ",
      title: "  "
    },
    addressChange: {
      text: "              20        ",
      title: "  "
    },
    addressFormats: {
      text: "       Native Segwit.                      .           Taproot ( )                .            Native Segwit ( )        Segwit               .",
      title: '     "  "'
    },
    howVerify: {
      text: "   BitBox01     BitBox          ().          .\n   BitBox02             ",
      title: "     "
    },
    plugout: {
      text: "       BitBox        BitBox   .      BitBox  ",
      title: "     BitBox     "
    },
    why20: {
      text: '          (   )         .                  .            20     .   " "  20         .   20     ',
      title: "  20  "
    },
    whyMany: {
      text: "           .               .      20    .      .        .",
      title: "    "
    },
    whyVerify: {
      text: "            .                    .   BitBox01                        .   BitBox02         BitBox02 ",
      title: "      "
    }
  },
  send: {
    change: {
      text: "     Taproot    Taproot UTXO   .        Coin Control      Taproot       Taproot UTXO   UTXOs .           Segwit .",
      title: "    "
    },
    fee: {
      text: "       .             Bitcoin Core     .          .\n :   24  ( 4      )\n:   12  (     30  )\n:   6  (      15  )\n:    ( 20     5  )\n(       (2.5   )           )",
      title: "   "
    },
    plugout: {
      text: "          BitBox   .      BitBox  ",
      title: "    BitBox     "
    },
    priority: {
      text: "             ",
      title: "   "
    },
    revert: {
      text: "    (   )       .    (   )    !\n         (   )        ",
      title: "     (  )"
    },
    whyFee: {
      text: "     .          .\n    .             (      )              ( ).    ( )            ",
      title: "    "
    }
  },
  "settings-electrum": {
    connection: {
      text: "             (     wifi   )       .\n         Electrum    TLS  .\n             Tor   .     TLS   .",
      title: "      TCP  TLS  Tor"
    },
    instructions: {
      link: {
        text: "    "
      },
      text: "       :",
      title: "    BitBox     "
    },
    options: {
      text: "                Bitcoin Core    .\n      BitBoxApp          Electrum           .\n   Electrs  Electrum Personal Server (EPS)  Bitcoin Wallet Tracker (BTW).",
      title: "     "
    },
    tor: {
      text: ' Tor  "The Onion Router"                  Bitcoin.\n        Tor     Tor         Tor Proxy   BitBoxApp.\n        Tor:\n1.    Tor:    Tor   .    BitBoxApp   Tor       9150   Tor Proxy .\n2.  Tor    :   Tor daemon      .   BitBoxApp        9050   Tor Proxy.',
      title: "  Tor  Tor proxy      "
    },
    what: {
      text: "              Shift",
      title: " "
    },
    why: {
      text: "               .\n      Bitcoin      BitBox                   .\n                      .",
      title: "      "
    }
  },
  settings: {
    sats: {
      text: " ('sat' )     .        (0.00000001 BTC).        ",
      title: "  "
    },
    servers: {
      text: "     Shift Crypto            .\n       CoinGecko.                  .\n:   Ethereum   ERC20       Etherscan.io.",
      title: "     "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  trackingModePortfolioChart: {
    text: "        .         ",
    title: "       "
  },
  unlock: {
    forgotDevicePassword: {
      text: "             ",
      title: "      "
    },
    reset: {
      text: "     15 .        ",
      title: "    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "       .     .            .\n\nBitBox01     .    BitBox     BitBox01  ",
      title: "     BitBox01  "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox      :",
      title: "    "
    },
    internet: {
      text: "            ",
      title: "     "
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "     BitBox         ",
      title: "  .   "
    },
    useWithoutDevice: {
      text: "      ",
      title: "     "
    },
    welcome: {
      text: "       Shift Crypto  .       .       ",
      title: "    BitBoxApp!"
    }
  }
};
const headerssync$i = {
  blocksSynced: "{{blocks}}     "
};
const hiddenWallet$i = {
  info1HTML: "          <strong></strong>    +    ",
  info2HTML: "            .          <strong></strong>      ",
  passwordLabel: "    ",
  passwordPlaceholder: "      ",
  pinLabel: "    ",
  pinRepeatLabel: "     ",
  pinRepeatPlaceholder: "      ",
  success: "    .   BitBox  "
};
const initialize$i = {
  create: "   ",
  creating: "     ...",
  error: {
    e102: "       4   "
  },
  info: {
    description1: "   .      BitBox  ",
    description2: "    .       ",
    description3: "               ",
    subtitle: "     ",
    title: "  "
  },
  input: {
    label: "  ",
    labelRepeat: "   ",
    placeholderRepeat: "    "
  }
};
const invalidFormat$i = "  ";
const language$j = {
  title: " "
};
const legacyhiddenwallet$i = {
  disable: "     ",
  enable: "     ",
  successDisable: "     ",
  successEnable: "    .   BitBox          "
};
const loading$i = " ";
const manageAccounts$c = {
  editAccount: "",
  editAccountNameTitle: "  ",
  noAccounts: "    ",
  settings: {
    hideTokens: " ",
    showTokens: "  ({{activeTokenCount}})"
  },
  settingsButtonDescription: "    ",
  title: " "
};
const mobile$d = {
  usingMobileDataWarning: "   :                   .    Wi-Fi      .          "
};
const note$e = {
  input: {
    description: "()",
    placeholder: " "
  },
  title: ""
};
const notification$i = {
  newTxs_one: "  : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
};
const pairing$i = {
  aborted: {
    text: "      ",
    title: " "
  },
  button: "   ",
  confirm: "      BitBox              ",
  connectOnly: {
    button: "   ",
    title: '             "    "'
  },
  error: {
    text: "  .    ",
    title: ""
  },
  pullFailed: {
    text: "         .          ",
    title: " "
  },
  reconnectOnly: {
    button: "    "
  },
  scanningFailed: {
    text: "       .   ",
    title: " "
  },
  start: {
    hideAppQRCode: "    QR",
    revealAppQRCode: "    QR",
    step1: "            QR  Apple App Store  Google Play Store      ",
    step2: '              "Digital Bitbox 2FA"      iOS  Android:'
  },
  started: {
    text: "        ",
    title: ""
  },
  success: {
    text: "     ()  BitBox     !",
    title: ""
  },
  timeout: {
    text: "   ()  .            ",
    title: " "
  },
  title: "  "
};
const passphrase$c = {
  considerations: {
    button: "  ",
    message: "           ( microSD  24 ).                   .\n\n       <strong>    +   </strong>             BitBox02.                 .\n\n              .                 .",
    title: "  "
  },
  disable: "  ",
  disableInfo: {
    button: "",
    message: "                 BitBox02.      .\n\n                      BitBox02     .\n\n                           BitBox02.\n\n<strong>:</strong>            ."
  },
  enable: "  ",
  error: {
    e104: "     "
  },
  how: {
    button: " ",
    message: "         .          .   <strong>       </strong>.             .             .\n\n  BitBox02       .          .\n\n          .         .",
    title: " "
  },
  intro: {
    message: "        .\n   ",
    title: "  "
  },
  progressDisable: {
    message: "      <strong> </strong>   ",
    title: "   "
  },
  progressEnable: {
    message: "      <strong></strong>   ",
    title: "   "
  },
  successDisabled: {
    message: "<strong>  </strong>   !\n       .",
    messageEnd: "   BitBox02 ",
    title: "    "
  },
  successEnabled: {
    message: "<strong>   </strong>   !\n\n       .",
    messageEnd: "   BitBox02   ",
    tips: "",
    tipsList: [
      "          .    BitBox02         .          ",
      "                          .      "
    ],
    title: "   "
  },
  summary: {
    button: "  ",
    title: "",
    understand: "        ",
    understandList: [
      "        ",
      "        ",
      "   <strong>     </strong>",
      "          "
    ]
  },
  what: {
    button: "    ",
    message: "  ()           .       BitBox02        microSD  24 .                .\n\n    <strong> </strong>    ( ).               +   ( ).       :           .        +   .\n\n      BIP39            ",
    title: "   "
  },
  why: {
    button: "   ",
    message: ' BitBox02           ( microSD  24 )     .      !\n\n                   <strong>     </strong>.                         .\n\n                 " "    .',
    title: "   "
  }
};
const password$i = {
  show: " {{label}}",
  warning: {
    caps: ":   caps lock ()",
    paste: '    " {{label}}"'
  }
};
const random$j = {
  button: "  ",
  description: " BitBox     {{bits}}- :"
};
const receive$k = {
  changeScriptType: "  ",
  label: "",
  onlyThisCoin: {
    description: "       .          ",
    warning: "    {{coinName}}    "
  },
  scriptType: {
    p2tr: "Taproot ( )",
    p2wpkh: "Native Segwit ()",
    "p2wpkh-p2sh": " Segwit  ( )"
  },
  showFull: "      ",
  taprootWarning: ": Taproot             .        Taproot       .            Taproot",
  title: " {{accountName}}",
  verify: "    ",
  verifyBitBox01: "      ",
  verifyBitBox02: "    BitBox02",
  verifyInstruction: "          ",
  warning: {
    secureOutput: '  BitBox       .   " "   '
  }
};
const reset$i = {
  description: "      .    !",
  notReset: "    ",
  title: "   ",
  understand: "        ",
  understandBB02: "   "
};
const securityInformation$i = {
  create: {
    description1: "                   ",
    description2: "      ",
    description3: "  <strong>  </strong>    BitBox     ",
    description4: "  <strong>  </strong>   .       ",
    description5: "            microSD .          <strong>  </strong>.",
    title: " "
  },
  restore: {
    description1: "    microSD     ",
    description2: "         ",
    description3: "       .       .             ",
    title: " "
  }
};
const seed$i = {
  agreements: {
    "funds-access": "            ",
    "password-change": "      ",
    "password-required": "        "
  },
  create: " ",
  creating: " ",
  description: "  :",
  error: {
    e102: "      4   ",
    e200: "    microSD  BitBox            "
  },
  info: {
    button: "     ",
    description1: "  microSD  BitBox",
    description2: '       "    "',
    description3: "   microSD             BitBox  ",
    description4: "           ",
    title: "  "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "   "
  },
  walletName: {
    label: " "
  }
};
const seedRestore$i = {
  error: {
    e200: "         microSD"
  },
  info: {
    description1: '  microSD  BitBox    ""',
    description2: '      ""',
    description3: "   ",
    description4: "             ",
    title: "     "
  }
};
const send$k = {
  abort: "  ",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: " ",
  coincontrol: {
    address: "",
    outpoint: " ",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    erc20InsufficientGasFunds: "           ERC20 .           ",
    feeTooLow: "  ",
    feesNotAvailable: "   ",
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: "  ",
    invalidData: "  "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: " "
  },
  feeTarget: {
    customLabel: " ",
    customLabel_eth: "  ",
    description: {
      economy: "4  (24 )",
      economy_eth: "30   ",
      economy_ltc: "  (24 )",
      high: "20  ()",
      high_eth: "30   ",
      high_ltc: "5  ()",
      low: " (12 )",
      low_eth: "5   ",
      low_ltc: "30  (12 )",
      normal: "1  (6 )",
      normal_eth: "  ",
      normal_ltc: "15  (6 )"
    },
    estimate: "  :",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "   ..."
  },
  maximum: "  ",
  maximumSelectedCoins: "  ",
  priority: "",
  scanQR: "    QR",
  signprogress: {
    description: "      .        {{steps}} ",
    label: ""
  },
  success: "   ",
  title: " {{accountName}}",
  toggleCoinControl: "     coin control",
  transactionDetails: " "
};
const settings$j = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: "     {{host}}",
    checking: "",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "    ",
    resetConfirm: "       ",
    servers: "",
    step1: "1",
    "step1-text": "   ",
    step2: "2",
    "step2-text": "     .            ",
    "step2-text-tcp": "         TLS",
    step3: "3",
    "step3-text": "    ",
    step4: "4",
    "step4-text": "  .            ",
    "title-btc": " Electrum   ",
    "title-ltc": " Electrum   ",
    "title-tbtc": " Electrum     ",
    "title-tltc": " Electrum     "
  },
  expert: {
    coinControl: "     coin control",
    electrum: {
      title: "    "
    },
    fee: "   ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: " tor proxy",
    useSats: "    Satoshi"
  },
  header: {
    home: " "
  },
  info: {
    "out-of-date": "  ",
    title: "",
    "up-to-date": "   ",
    version: " "
  },
  restart: "    BitBox    ",
  services: {
    title: ""
  },
  success: "  BitBox      ",
  title: ""
};
const setup$i = " ";
const sidebar$j = {
  buy: "  ",
  device: " ",
  leave: "",
  settings: ""
};
const success$p = {
  create: {
    info1: "        microSD.         ",
    info2: "        BitBox",
    info3: "              ",
    summary: "    ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "       ",
    title: ""
  }
};
const transaction$j = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "  ()",
    fiatAmount: "   ",
    fiatAtTime: "    ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "   ",
  fee: "",
  fiatHistorical: "",
  gas: " ",
  note: {
    edit: " ",
    save: " "
  },
  pending: "  ",
  size: "",
  status: {
    complete: "",
    failed: " ",
    pending: " "
  },
  tx: {
    received: "  ",
    sent: "  "
  },
  vsize: " ",
  weight: ""
};
const transactions$i = {
  placeholder: "    "
};
const unknownError$i = "   : {{errorMessage}}";
const unlock$i = {
  description: "      ",
  error: {
    e109_normal: "   . {{remainingAttempts}}      ",
    e109_touch: "$t(unlock.error.e109_normal)        ",
    e113: "                  4 "
  },
  input: {
    label: "  ",
    placeholder: "      "
  },
  unlocking: "   ..."
};
const upgradeFirmware$j = {
  button: "  ",
  description: "       {{currentVersion}}  {{newVersion}}",
  label: "  BitBox   ",
  locked: "  {{currentVersion}}  {{newVersion}}     ",
  title: "  ",
  unlocked: "   .  :",
  unlocked1: "   Bitbox",
  unlocked2: " LED   BitBox  ",
  unlocked3: "       LED"
};
const warning$o = {
  receivePairing: '  BitBox     .   " "   ',
  sdcard: "  microSD    BitBox        ",
  sendPairing: "   BitBox        .       "
};
const welcome$i = {
  getStarted: "      BitBox02",
  insertBitBox02: "        BitBox02 ",
  insertDevice: "   ",
  title: ""
};
const appTranslationsAR = {
  account: account$i,
  accountInfo: accountInfo$i,
  accountSummary: accountSummary$i,
  addAccount: addAccount$j,
  aopp: aopp$c,
  app: app$i,
  backup: backup$i,
  bb02Bootloader: bb02Bootloader$i,
  bitbox: bitbox$i,
  bitbox02Interact: bitbox02Interact$i,
  bitbox02Settings: bitbox02Settings$i,
  bitbox02Wizard: bitbox02Wizard$i,
  blink: blink$i,
  bootloader: bootloader$i,
  button: button$n,
  buy: buy$e,
  changePin: changePin$i,
  chart: chart$e,
  checkSDcard: checkSDcard$i,
  clickHere: clickHere$i,
  confirm: confirm$k,
  confirmOnDevice: confirmOnDevice$i,
  device: device$i,
  deviceLock: deviceLock$i,
  deviceSettings: deviceSettings$i,
  deviceTampered: deviceTampered$i,
  dialog: dialog$j,
  error: error$e,
  fiat: fiat$k,
  footer: footer$k,
  generic: generic$e,
  genericError: genericError$i,
  goal: goal$i,
  guide: guide$j,
  headerssync: headerssync$i,
  hiddenWallet: hiddenWallet$i,
  initialize: initialize$i,
  invalidFormat: invalidFormat$i,
  language: language$j,
  legacyhiddenwallet: legacyhiddenwallet$i,
  loading: loading$i,
  manageAccounts: manageAccounts$c,
  mobile: mobile$d,
  note: note$e,
  notification: notification$i,
  pairing: pairing$i,
  passphrase: passphrase$c,
  password: password$i,
  random: random$j,
  receive: receive$k,
  reset: reset$i,
  securityInformation: securityInformation$i,
  seed: seed$i,
  seedRestore: seedRestore$i,
  send: send$k,
  settings: settings$j,
  setup: setup$i,
  sidebar: sidebar$j,
  success: success$p,
  transaction: transaction$j,
  transactions: transactions$i,
  unknownError: unknownError$i,
  unlock: unlock$i,
  upgradeFirmware: upgradeFirmware$j,
  warning: warning$o,
  welcome: welcome$i
};
const account$h = {
  disconnect: "Ztrta spojen. Pokus o optovn pipojen...",
  "export": "Export",
  exportTransactions: "Export transakc do sloky ke staen jako soubor CSV",
  fatalError: "Dolo k neoekvan chyb.",
  incoming: "Pichzejc",
  initializing: "Zskvn informac z blockchainu...",
  insuranceExpired: "<strong>et ji nen pojitn</strong>\n\nPln pojitn tohoto tu byl zmnn.\nPodrobnosti naleznete na strnkch tkajc se pojitn.",
  insured: "Pojitn et",
  maybeProxyError: "Tor proxy aktivn. Ujistte se, e proxy server Tor b sprvn, nebo nastaven proxy serveru deaktivujte.",
  reconnecting: "Ztrta spojen. Pokus o optovn pipojen...",
  syncedAddressesCount: "Naskenovno {{count}} adres",
  uncoveredFunds: "Mte prostedky na nsledujcch nepokrytch typech adresch vaeho <strong>{{name}}</strong> tu: {{uncovered}}.\nVzhledem k tomu, e et je pojitn, vztahuje se pouze na prostedky pijat prostednictvm adresy typu <strong>Native  Segwit</strong>. Prostedky na odlinch typech adres, i kdy jsou na stejnm tu, pojitny nejsou.\nPesute prosm vechny sv mince z nepodporovanch typ adres na adresy typu <strong>Native Segwit</strong>, aby byly vechny vae prostedky na tomto tu pojitny.",
  uncoveredFundsLink: "Postupujte podle tohoto prvodce, jak pesunout sv prostedky.",
  warning: "Varovn! "
};
const accountInfo$h = {
  address: "Adresa",
  buyCTA: {
    buy: "Koupit  {{unit}}",
    buyCrypto: "Koupit Krypto",
    information: {
      looksEmpty: "Zd se, e tato penenka je przdn.",
      start: "Zante vkladem do penenky, nebo nkupem pmo v BitBoxApp."
    }
  },
  extendedPublicKey: "Veejn kl",
  label: "Detaily tu",
  scriptType: "Typ tu",
  title: "Detaily tu",
  verify: "Ovte na zazen",
  xpubTypeChangeBtn: {
    p2pkh: "Zobrazit legacy P2PKH veejn kl",
    p2tr: "Zobrazit Taproot",
    p2wpkh: "Zobrazit nativn Segwit",
    "p2wpkh-p2sh": "Zobrazit star Segwit veejn kl"
  },
  xpubTypeInfo: "Aktuln se zobrazuje {{scriptType}} veejn kl ({{current}} z {{numberOfXPubs}})"
};
const accountSummary$h = {
  availableBalance: "Dostupn zstatek",
  balance: "Zstatek",
  exportSummary: "Exportovat pehled t do sloky ke staen jako soubor CSV",
  fiatBalance: "Fiat zstatek",
  name: "Nzev tu",
  noAccount: "dn ty k zobrazen.",
  subtotalWithCoinName: "Celkem ({{coinName}})",
  title: "Moje portfolio",
  total: "Celkem",
  transactionHistory: "Transakn historie"
};
const addAccount$i = {
  chooseName: {
    nextButton: "Pidat et",
    step: "Pojmenujte et",
    title: "Pojmenujte svj et"
  },
  selectCoin: {
    nextButton: "Dal",
    step: "Vybrat kryptomnu",
    title: "Vybrat kryptomnu"
  },
  success: {
    addAnotherAccount: "Pidat dal et",
    message: "<strong>{{accountName}}</strong> byl nyn pidn k vaim tm.",
    nextButton: "Hotovo",
    step: "Dokoneno",
    title: "et pidn"
  },
  title: "Pidat et"
};
const aopp$b = {
  addressRequest: "{{host}} poaduje pijmac adresu.",
  addressRequestWithLogo: "poaduje pijmac adresu.",
  banner: "Probh dost o adresu. Pro pokraovn pipojte zazen.",
  errorTitle: "Chyba pi poadavku na adresu ",
  labelAddress: "Adresa",
  labelMessage: "Zprva",
  reverifyInfoText: "Ovit adresu",
  signing: "Chcete-li pokraovat, podepite zprvu na svm BitBoxu",
  success: {
    message: "Pokraovat na {{host}}",
    title: "Adresa byla spn odeslna"
  },
  syncing: "Synchronizace tu, vykejte prosm.",
  title: "Poadavek na adresu"
};
const app$h = {
  upgrade: "K dispozici je nov verze tto aplikace! Aktualizuje prosm z {{current}} na {{version}}."
};
const auth$b = {
  authButton: "Ovit",
  title: "Chcete-li pokraovat, provete oven"
};
const backup$h = {
  check: {
    checking: "Kontrola zlohy...",
    confirmTitle: "Zkontrolovat zlohu",
    notOK: "Zloha NEODPOVD penence.",
    ok: "Zloha odpovd penence.",
    password: {
      label: "Heslo pro obnoven",
      placeholder: "Heslo pro obnoven",
      showLabel: "heslo pro obnoven"
    },
    success: "Zloha byla spn ovena:",
    title: "Zkontrolovat zlohu"
  },
  create: {
    alreadyExists: "Ji mte platnou zlohu. Chcete ji znovu vytvoit?",
    fail: "Vytvoen zlohy SELHALO!",
    info: "Pro oven zadejte heslo pro obnoven aktuln penenky.",
    name: {
      label: "Nzev zlohy",
      placeholder: "Pojmenujte prosm zlohu"
    },
    password: {
      label: "Heslo pro obnoven",
      placeholder: "Zadejte prosm heslo pro obnoven"
    },
    title: "Vytvoit zlohu",
    verificationFailed: 'Heslo pro obnoven se NESHODUJE s aktuln penenkou. Zloha byla vytvoena. Pro optovn oven hesla pro obnoven pouijte funkci "Zkontrolovat zlohu".'
  },
  description: "Vyberte <strong>soubor zlohy penenky</strong>",
  insert: "Pro sprvu zloh prosm vlote microSD kartu.",
  insertButton: "Vloil jsem microSD kartu.",
  list: "Vae zlohy na microSD kart",
  noBackups: "Na tto microSD kart nejsou dn zlohy.",
  restore: {
    confirmTitle: "Obnovit ze zlohy",
    error: {
      e200: "Karta microSD nenalezena",
      general: "Chyba pi obnov ze zlohy"
    },
    password: {
      label: "Heslo pro obnoven nebo skryt heslo pro obnoven",
      placeholder: "Heslo pro obnoven",
      repeatPlaceholder: "Zopakujte heslo pro obnoven",
      showLabel: "Heslo pro obnoven"
    },
    restoring: "Obnova ze zlohy...",
    selectedBackup: "<strong>{{backupName}}</strong> vytvoena {{createdDateTime}} bude obnovena.",
    title: "Obnovit",
    understand: "Rozumm, e nesprvn heslo pro obnoven vytvo jinou penenku."
  },
  showMnemonic: {
    description: "Zobraz se vm slova pro obnoven - obnovovac seed, ten tvo zlohu va penenky. Napite si je na papr.\n\n<strong>Neukldejte je digitln ani je nefote.</strong>\n\n<strong>Nekejte tato slova nahlas.</strong>\n\n<strong>Tato zloha nen chrnna heslem.</strong>\n\nPot budete vyzvni k potvrzen kadho slova.",
    title: "Zobrazit slova pro obnoven",
    warning: "<strong> Nikdy nikomu nesdlujte sv slova pro obnoven.</strong> Vae slova pro obnoven poskytuj pln pstup k va penence. Pokud vs nkdo d o vae slova pro obnoven, jedn se o podvodnka, nesdlejte je!"
  },
  title: "Spravovat zlohy"
};
const bb02Bootloader$h = {
  abort: "Neaktualizovat - zpt",
  abort_noUpgrade: "Zpt",
  advanced: {
    label: "Rozen nastaven",
    toggleShowFirmwareHash: "Zobrazit hash firmwaru pi kadm sputn"
  },
  flipscreen: "Oto obrazovku",
  orientation: "patn orientace zazen?",
  success: "Aktualizace spn! Pokraovn za {{rebootSeconds}} sekund...",
  success_install: "Instalace probhla spn! Pokraovn za {{rebootSeconds}} sekund..."
};
const bitbox$h = {
  error: {
    e10000: "Heslo pro aktuln zazen nen sprvn.",
    e10001: "Nepodailo se nahradit heslo zazen",
    e102: "Heslo mus obsahovat alespo 4 znaky.",
    e112: "Skryt heslo zazen neme bt stejn jako heslo hlavnho zazen."
  }
};
const bitbox02Interact$h = {
  confirmDate: "Potvrte dnen datum na svm BitBox02",
  confirmDateText: "Toto datum se pouije pro vytvoen zlohy.",
  confirmName: "Potvrte nzev na BitBox02",
  confirmWords: "Zapite si {{amount}} slov pro obnoven z vaeho BitBox02",
  confirmWordsText: "Pot vs BitBox02 pod o potvrzen kadho slova, aby se ovilo, e zloha je sprvn.",
  followInstructions: "Postupujte podle pokyn na vaem BitBox02.",
  followInstructionsMnemonic: "Postupujte dle pokyn na Vaem BitBox02  zadejte slova pro obnoven z va zlohy a obnovte penenku.",
  followInstructionsMnemonicTitle: "Obnovit ze slov pro obnoven"
};
const bitbox02Settings$h = {
  deviceName: {
    current: "Aktuln nzev zazen",
    error: "Nzev zazen se nepodailo nastavit",
    error_104: "Potvrzen nzvu zazen bylo na zazen zrueno.",
    input: "Nzev BitBox02",
    placeholder: "Nov nzev zazen",
    title: "Nastavit nzev pro BitBox02"
  },
  gotoStartupSettings: {
    description: "Tm se zazen BitBox02 restartuje a vstoup do nastaven pi sputn.",
    title: "Pejt do nastaven pi sputn"
  }
};
const bitbox02Wizard$h = {
  advanced: {
    button: "Pokroil nastaven",
    outOfDate: "Firmware je pro tuto funkci zastaral",
    seed12WordInfo: "Upozorujeme, e poet slov nelze po vytvoen penenky zmnit.",
    seed12WordLabel: "Vytvoit 12slovn namsto 24slovnho seed",
    seed12WordText: "Ve vchozm nastaven pouv BitBox02 seed s 24 slovy. Ob dlky seed jsou v praxi bezpen proti brute force toku. Nkte uivatel mohou msto toho upednostnit 12slovn seed.",
    skipSDCardLabel: "Peskote zlohovn na microSD kartu a msto toho si zapite slova pro obnoven.",
    skipSDCardText: "Po nastaven mte vdy monost vytvoit zlohu karty microSD nebo zapsat slova pro obnoven. To lze provst z nastaven.",
    title: "Pokroil monosti zlohovn"
  },
  attestationFailed: "Kontrola originality selhala, co mohlo bt zpsobeno restartovnm aplikace v dob, kdy zazen ekalo na vstup uivatele. Znovu se pipojte a zkuste to znovu. Pokud tento problm petrvv, obrate se prosm na support@bitbox.swiss.",
  backup: {
    point1: "Vyberte zlohu na microSD kart",
    point2: "Nastavit heslo pro zazen",
    restoreText: "Ok, obnovme ze zlohy!",
    text1: "Skvl, vae heslo pro BitBox02 je nyn nastaveno a penenka vytvoena. Nyn je as vytvoit prvn zlohu. Ujistte se, e je vae microSD karta vloena do vaeho BitBox02 a pokraujte.",
    text2: "Vytvote zlohu podle pokyn na obrazovce zazen.",
    text3: "Po vytvoen zlohy vyjmte microSD kartu a ulote ji na <strong>bezpen msto</strong>. Obsah microSD karty nen chrnn heslem. Nikdy jej nevkldejte do jinho zazen ne do vaeho BitBox02.",
    userConfirmation1: "Zlohu bych ml uloit na bezpenm mst.",
    userConfirmation2: "Moje zloha nen chrnna heslem. Kdokoli, kdo k n m pstup, m pstup k m penence.",
    userConfirmation3: "Pokud ztratm nebo pokodm svj BitBox02, jedin zpsob, jak zskat zpt sv prostedky, je obnovit penenku ze zlohy.",
    userConfirmation4: "Pokud ztratm nebo pokodm zlohu i BitBox02, pijdu o sv prostedky.",
    userConfirmation5: "MicroSD kartu s mou zlohou bych neml vkldat do potae, telefonu, tiskrny nebo jinho zazen ne BitBox02.",
    userConfirmation5mnemonic: "Neml bych vkldat slova pro obnoven do potae, telefonu, tiskrny nebo jinho zazen, ne je BitBox02."
  },
  create: {
    button: "Pojmenujte zazen a pokraujte",
    info: "Zde jsou zkladn kroky, kter je teba udlat pro nastaven vaeho BitBoxu: ",
    inputTitle: "Nzev penenky",
    point1: "Pojmenujte sv zazen",
    point2: "Nastavte heslo pro sv zazen",
    point3: "Vytvoit zlohu",
    text: "Ok, pojme vytvoit novou penenku!"
  },
  createBackupAborted: "Vytven zlohy bylo zrueno.",
  createBackupFailed: "Vytvoen zlohy se nezdailo, zkuste to znovu.",
  initialize: {
    passwordText: "Nyn nastavme heslo pro vae zazen. K zadn a vbru hesla pouijte ovldac prvky na BitBoxu.",
    passwordTitle: "Nastavte heslo pro svj BitBox",
    text: "V BitBox02 byl spn sprovn! Nyn inicializujeme vae zazen. Zante vbrem vytvoit novou penenku nebo obnovit penenku ze zlohy. <strong>Ujistte se, e je v Bitboxu vloena microSD karta</strong>",
    tip: "Doporuujeme, abyste pokraovali na bezpenm mst.",
    title: "Inicializujte svj BitBox"
  },
  insertSDCard: "<strong>Ujistte se, e je ve vaem BitBoxu vloena microSD karta.</strong>",
  noPasswordMatch: "Hesla se neshoduj, zkuste to prosm znovu.",
  pairing: {
    failed: "Sprovn nepotvrzeno. Znovu pipojte svj BitBox02.",
    paired: "Na svm zazen jste potvrdili nsledujc kd. Prosm pokraujte.",
    title: "Ovte provac kd",
    unpaired: "Byl zjitn nesprovan BitBox02. Prosm ovte, e provac kd odpovd tomu, co je zobrazeno na vaem BitBoxu."
  },
  restoreFromMnemonic: {
    e104: "Obnoven ze slov pro obnoven bylo zrueno.",
    failed: "Obnoven ze slov pro obnoven se nezdailo, zkuste to prosm znovu."
  },
  stepBackup: {
    beforeProceed: "Ne budete pokraovat, pette si tato dleit bezpenostn opaten:",
    createBackup: "Nyn vytvote zlohu na microSD kart.",
    createBackupMnemonic: "Nyn si zapete slova pro obnoven."
  },
  stepBackupSuccess: {
    fundsSafe: "Aby byly vae prostedky v bezpe, mjte na pamti nsledujc:",
    title: "Zloha obnovena!"
  },
  stepConnected: {
    unlock: "Pro odemknut zadejte heslo."
  },
  stepCreate: {
    description: "Tento nzev se pouv jako nzev zazen a pro zlohu. ",
    error: {
      genericMessage: "Pouvejte psmena, sla, zkladn symboly, mezery. Maximln 30 znak.",
      invalidChars: "Nzev obsahuje neplatn znaky: {{invalidChars}}.",
      tooLong: "Nzev je pli dlouh."
    },
    nameLabel: "Nzev BitBox02",
    namePlaceholder: "Mj BitBox02",
    title: "Vyberte nzev pro BitBox02",
    toastMicroSD: "Vlote prosm svou microSD kartu do vaeho BitBox02, kter bude pouita k uloen zlohy penenky."
  },
  stepCreateSuccess: {
    removeMicroSD: "Vyjmte microSD kartu z vaeho BitBox02 a ulote ji na bezpen msto.",
    storeMnemonic: "Ulote sv slova pro obnoven na bezpenm mst",
    success: "Vae zloha byla spn vytvoena."
  },
  stepInsertSD: {
    insertSDCard: "Chcete-li pokraovat, vlote do svho BitBox02 microSD kartu.",
    insertSDcardTitle: "Vlote microSD kartu"
  },
  stepPassword: {
    e104: "Nastaven hesla bylo zrueno.",
    title: "Nastavte heslo pro v Bitbox02",
    useControls: "K nastaven hesla pouijte ovldac prvky na vaem BitBox02."
  },
  stepUninitialized: {
    create: "Chci nastavit nov BitBox02.",
    restore: "Chci obnovit svou penenku ze zlohy.",
    restoreMicroSD: "Obnovit z microSD karty",
    restoreMnemonic: "Obnovit ze slov pro obnoven",
    title: "Nastavte svj BitBox02"
  },
  success: {
    text: "Hur! V BitBox02 je nyn pipraven k pouit.\n\nChcete-li zskat dal informace o tom, jak pouvat BitBoxApp, pouijte prvodce v aplikaci kliknutm na otaznk v pravm hornm rohu.",
    title: "Jste pipraveni!"
  }
};
const bitsurance$a = {
  dashboard: {
    active: "Pojistka aktivn",
    button: "Pojistit nov et",
    canceled: "Zrueno",
    coverage: "Maximln pokryt",
    inactive: "Neaktivn",
    processing: "Zpracovv se",
    refused: "Odmtnuto",
    supportLink: "Spravovat smlouvu",
    title: "Pojitn ty",
    waitpayment: "ekn na platbu"
  },
  detect: {
    button: "Zkontrolujte stvajc pojitn",
    insured: "Zjitn pojitn et:",
    notInsured: "Nebyly zjitny dn pojitn ty. Pokud jste si jisti, e mte pojitn et, zkontrolujte, zda mte pipojenou sprvnou penenku.",
    text: "Pokud jste se ji zaregistrovali u Bitsurance, aplikace BitBoxApp me automaticky synchronizovat vae stvajc pojitn.",
    title: "U jste pojitni?"
  },
  insure: {
    button: "Zkontrolujte dostupnost a cenu",
    faq: "Pette si vce na Bitsurance FAQ",
    listItem1: "Vloupn",
    listItem2: "Vydrn (nap.$5 wrench attack)",
    listItem3: "Znien v dsledku poru, vody nebo prodnch katastrof",
    month: "msc",
    text: "Pojistte si svj BitBox02 a bitcoiny v hodnot a 100 000 EUR",
    text2: "Pojistn plny zanaj na 30 /rok (2,50 /msc). Vce informac o spolenosti Bitsurance a jej pesn nabdce pojitn se dozvte na strnce",
    text3: "V souasn dob k dispozici v Nmecku, dal regiony budou nsledovat.",
    title: "Zante"
  },
  intro: {
    link: "Web Bitsurance",
    text1: "BitBox spolupracuje s Bitsurance na pidn dal vrstvy ochrany pro vae bitcoiny. Zatmco BitBox02 udruje vae finann prostedky v bezpe, Bitsurance pokrv domc hrozby, kter nelze zmrnit samotnou technologi, jako je vloupn, vydrn nebo znien samotn hardwarov penenky."
  },
  terms: {
    link: "Zsady ochrany osobnch daj Bitsurance",
    text1: "Bitsurance je nezvisl sluba tet strany. S dotazy tkajcmi se jejich nabdky a pojistnch nrok kontaktujte pmo Bitsurance.",
    text2: "Pojitn je aktuln dostupn v Nmecku a dal regiony budou nsledovat.",
    text3: "Maximln aktuln dostupn pokryt bitcoin je 100 000 EUR na osobu. Do budoucna se plnuj vy stky.",
    text4: "Osobn daje a rozen veejn kl (xpub) vaeho pojitnho tu jsou soust pojistn smlouvy a budou sdleny s Bitsurance a poskytovatelem pojitn.",
    text5: "Dal informace o ochran osobnch daj a zachovn soukrom naleznete na"
  },
  title: "Pojitn"
};
const bitsuranceAccount$a = {
  errorNoXpub: "Chyba: Nepodailo se zskat xpub z tu.",
  noAccount: "Neexistuj dn ty, kter lze pojistit.",
  select: "Vybrat et",
  title: "Pojitn"
};
const blink$h = {
  button: "Blik"
};
const bootloader$h = {
  button: "Nyn aktualizujte firmware",
  button_install: "Nyn nainstalujte firmware",
  progress: "Aktualizace: {{progress}}%",
  progress_install: "Instalace: {{progress}}%",
  success: "Aktualizace probhla spn! Zazen znovu zapojte. Tentokrt se tlatka nedotkejte."
};
const button$m = {
  abort: "Zruit",
  back: "Zpt",
  buy: "Koupit",
  changepin: "Zmit heslo zazen",
  check: "Zkontrolovat zlohu",
  "continue": "Pokraovat",
  copy: "Koprovat",
  create: "Vytvoit",
  dismiss: "Odmtnout",
  done: "Hotovo",
  download: "Sthnout",
  hiddenwallet: "Vytvoit skrytou penenku",
  next: "Dal",
  ok: "OK",
  previous: "Pedchoz",
  receive: "Pijmout",
  restore: "Obnovit",
  select: "Vybrat",
  send: "Poslat",
  unlock: "Odemknout",
  update: "Aktualizovat",
  upgrade: "Aktualizovat"
};
const buy$d = {
  exchange: {
    bankTransfer: "Bankovn pevod",
    bestDeal: "Nejvhodnj nabdka",
    creditCard: "Kreditn karta",
    fast: "Rychle",
    fee: "poplatek",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankovn pevod: {{fee}}%",
          creditDebitCard: "Kreditn / Debetn karta: {{fee}}%",
          learnMore: "Zjistte vce o Moonpay",
          title: "Poplatky"
        },
        fullCurrenciesList: "Kompletn seznam mn naleznete zde",
        payment: {
          asteriskText: "* Nen k dispozici pro rezidenty USA",
          bankTransfer: "Bankovn pevod*",
          bankTransferDetails: {
            pix: "PIX (transakce BR pouze v Brazlii)",
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemch SEPA)",
            uk: "Faster Payments - Spojen krlovstv (transakce v GBP pouze ve Spojenm krlovstv)"
          },
          creditDebitCard: "Kreditn / Debetn karta",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa a Maestro"
          },
          learnMore: "Dal podrobnosti o zpsobech platby",
          title: "Platebn metody"
        },
        supportedCurrencies: "Podpora vech hlavnch fiat mn: USD, EUR, CHF a dal."
      },
      pocket: {
        fees: {
          info: "Bankovn pevod: {{fee}}%",
          title: "Poplatky"
        },
        learnMore: "Zjistte vce o slub Pocket",
        payment: {
          bankTransfer: "Bankovn pevod",
          bankTransferDetails: {
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemch SEPA)",
            sic: "Swiss Interbank Clearing (transakce v CHF pouze v CH/LI)",
            uk: "Faster Payments - Spojen krlovstv (transakce v GBP pouze ve Spojenm krlovstv)"
          },
          bankTransferReccuring: "Jak nastavit opakovan nkupy pomoc trvalho pkazu?",
          title: "Platebn metody"
        },
        supportedCurrencies: "Podpora evropskch mn: EUR, GBP a CHF.",
        verification: {
          info: "Vyaduje oven identity pouze pokud jsou pekroeny denn a ron limity.",
          link: "Aktuln limity zde",
          title: "Oven identity"
        }
      },
      region: {
        title: "Vyberte oblast, ve kter je v bankovn et registrovn, a zjistte, kter monosti mte k dispozici."
      }
    },
    noExchanges: "Je nm lto, ale v tto oblasti nejsou k dispozici dn burzy.",
    region: "Oblast",
    selectRegion: "Nen uvedeno",
    title: "Koupit {{name}}"
  },
  info: {
    "continue": "Souhlasm, pokraovat",
    crypto: "krypto",
    disclaimer: {
      intro: [
        "Spolupracujeme s MoonPay, abychom vm nabdli bezproblmov zpsob nkupu {{name}} pmo v BitBoxApp. Je to jen pr kliknut.",
        "MoonPay je platforma, kter usnaduje a urychluje nkup {{name}} ve vce ne 160 zemch."
      ],
      payment: {
        details: "{{name}} si mete okamit zakoupit pes MoonPay pomoc nsledujcch platebnch metod. Nkupy kreditn nebo debetn kartou jsou okamit a pohodln, ale dra kvli zvenmu riziku chargebacku. Pro vt stky doporuujeme pout monost bankovnho pevodu. Minimln poplatek je 4 USD/EUR nebo ekvivalentn stka.",
        footnote: "Vezmte prosm na vdom, e smnn kurzy MoonPay se mohou liit od kurz pouvanch v BitBoxApp, co vede k mrn odlinm stkm.",
        table: {
          "1_description": "Nejni poplatky, me trvat a ti pracovn dny",
          "1_method": "Bankovn pevody (SEPA)",
          "2_description": "Vy poplatky, ale rychl a okamit",
          "2_method": "Kreditn a debetn karty",
          description: "Popis",
          fee: "Poplatek",
          method: "Metoda"
        },
        title: "Platebn metody a poplatky"
      },
      privacyPolicy: "Zsady ochrany osobnch daj MoonPay",
      protection: {
        description: "BitBoxApp pi nkupu {{name}} neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. MoonPay potebuje ke sv innosti shromaovat nkter osobn daje. Jejich Zsady ochrany osobnch daj podrobn vysvtluj, jak je s tmito daji nakldno.",
        descriptionGeneric: "BitBoxApp pi nkupu {{name}} neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. Partnersk burzy vak ke svmu fungovn potebuj shromaovat urit informace. Podrobnj informace o tom, jak je s daty nakldno, naleznete v jejich zsadch ochrany osobnch daj.",
        title: "Ochrana dat"
      },
      security: {
        description: "Pi nkupu {{name}} pes MoonPay vyuvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputena BitBoxApp.",
        descriptionGeneric: "Pi nkupu {{name}} prostednictvm partnersk burzy vyuvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputena BitBoxApp.",
        link: "Model bezpenostnch hrozeb",
        title: "Bezpenostn model"
      },
      title: "Vtejte ve vaem obchod pro nkup {{name}}"
    },
    next: "Dal",
    selectLabel: "Vyberte svj et",
    selectPlaceholder: "Vyberte mnu",
    skip: "Znovu nezobrazovat",
    title: "Koupit {{name}}"
  },
  pocket: {
    data: {
      link: "Zsady ochrany osobnch daj Pocket",
      p1: "BitBoxApp pi nkupu bitcoin neshromauje dn daje, s pchozmi prostedky se zachz jako s bnou transakc. Pocket potebuje ke svmu fungovn shromaovat nkter osobn daje. Jejich zsady ochrany osobnch daj podrobn vysvtluj, jak se s tmito daji nakld.",
      title: "Ochrana dat"
    },
    kyc: {
      link: "Pette si Pocket FAQ",
      p1: "Pocket se sna omezit KYC na minimum. U nkup do 950 EUR (1000 CHF) denn nejsou vyadovny dn dal dokumenty. Pi nkupech nad tuto stku si budete muset s Pocket domluvit hovor, abyste mohli dokonit potebn proces KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin si mete koupit okamit pomoc sluby Pocket bankovnm pevodem SEPA. Poplatek in 1,5 % a bitcoiny jsou poslny do vaeho BitBoxu ihned pot, co Pocket obdr bankovn pevod (obvykle bhem tho dne).",
      p2: "Upozorujeme, e smnn kurzy v aplikaci Pocket se mohou liit od kurz pouvanch v aplikaci BitBoxApp, co vede k mrn odlinm stkm.",
      title: "Platebn metody a poplatky"
    },
    previousTransactions: "Historie transakc tohoto tu nen przdn. Sdlenm tohoto tu se vechny jeho minul a budouc transakce stanou viditelnmi pro Pocket. Pokraovat?",
    security: {
      link: "Model bezpenostnch hrozeb BitBox02",
      p1: "Pi nkupu bitcoin pes Pocket pouvte extern slubu. Tato sluba je mimo oblast psobnosti modelu bezpenostnch hrozeb BitBox02 a spolh se na bezpenost a zabezpeen prosted, ve kterm je sputn BitBoxApp. Spolen pracujeme na zven bezpenosti pomoc dvoufaktorovho ovovacho mechanismu, kter ovuje adresu, na kterou pijmte.",
      title: "Bezpenostn model"
    },
    usedAddress: "Adresa {{address}} ji byla pouita, zante prosm znovu s novou adresou.",
    verifyBitBox02: "Zkontrolujte, zda adresa, kterou jste obdreli e-mailem, odpovd adrese zobrazen na vaem Bitboxu. Pokud je to mon, mli byste e-mail otevt na druhm zazen kvli lepmu zabezpeen.",
    welcome: {
      p1: "Spolupracujeme se spolenost Pocket, abychom vm nabdli bezproblmov zpsob nkupu bitcoin pmo v BitBoxApp. Je to jen pr kliknut.",
      p2: "Pocket je vcarsk platforma, kter umouje rychl a snadn nkup bitcoin ve vtin Evropy (kdekoli, kde jsou podporovny bankovn pevody SEPA).",
      p3: "S Pocket mete tak provdt pravideln nkupy prostednictvm trvalch bankovnch pkaz, take mete snadno zprmrovat sv nklady (DCA - dollar-cost averaging).",
      title: "Vtejte ve svm obchod pro nkup bitcoin"
    }
  },
  title: "Koupit {{name}}"
};
const changePin$h = {
  newTitle: "Nov heslo zazen",
  oldLabel: "Aktuln heslo zazen"
};
const chart$d = {
  dataMissing: "Sbrme historick data... zstate s nmi.",
  dataOldTimestamp: "Aktualizace historickch smnnch kurz. V grafu se nezobrazuj data po {{time}}.",
  dataUpdating: "aktualizace dat...",
  filter: {
    all: "Vechny",
    month: "Msc",
    week: "Tden",
    year: "Rok"
  }
};
const checkSDcard$h = "kontrola microSD karty";
const clickHere$h = "Kliknte zde.";
const confirm$j = {
  abortInfo: "Klepnte na ",
  abortInfoRedText: "zruit",
  approveInfo: "Podrte 4 a vce sekund ",
  approveInfoGreenText: "potvrdit",
  info: "Pokraujte na svm BitBoxu. ",
  infoWhenPaired: "Nejprve na sprovanm mobilu a pot na vaem BitBoxu"
};
const confirmOnDevice$h = "Potvrte na svm zazen.";
const connectKeystore$b = {
  promptNoName: "Chcete-li pokraovat, pipojte svj BitBox02",
  promptWithName: 'Chcete-li pokraovat, pipojte prosm svj BitBox02 s nzvem "{{name}}" '
};
const darkmode$b = {
  toggle: "Tmav reim"
};
const device$h = {
  appUpradeRequired: "V BitBox nen kompatibiln s touto aplikac. Sthnte si a nainstalujte nejnovj verzi.",
  keystoreConnected: "Pipojen penenka"
};
const deviceLock$h = {
  button: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  condition1: "Mte zlohu?",
  condition2: "Funguje oven mobiln aplikace?",
  condition3: "2FA ZABRN zlohovn a provn s mobiln aplikaci. Pro ukonen 2FA je nutn zazen RESETOVAT!",
  confirm: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  title: "Aktivovat dvoufaktorovou autorizaci (2FA)"
};
const deviceSettings$h = {
  backups: {
    manageBackups: {
      description: "Vytvote nebo ovte zlohu na microSD kart."
    },
    showRecoveryWords: {
      description: "Zobrazit a ovit slova pro obnoven."
    },
    title: "Zlohy"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp kontroluje, zda je vae zazen prav."
    },
    deviceName: {
      description: "Zmte nzev zazen."
    },
    rootFingerprint: {
      description: "Otisk je jedinen identifiktor prv pouvan penenky. Me vm pomoci rozliit rzn penenky, pokud pouvte pstupov frze."
    },
    securechip: {
      description: "Model bezpenho ipu."
    },
    title: "Informace o zazen"
  },
  expert: {
    factoryReset: {
      description: "Obnovte zazen do tovrnho nastaven. Tm se smae penenka z vaeho BitBox02! ",
      title: "Obnovit do tovrnho nastaven"
    },
    goToStartupSettings: {
      description: "Vstoupit do bootloaderu BitBox02. Zde mete povolit hash firmwaru."
    },
    passphrase: {
      description: "Aktivovat nebo deaktivovat funkci pstupov frze.",
      title: "Pstupov frze"
    }
  },
  firmware: {
    firmwareVersion: "Verze firmwaru",
    newVersion: {
      label: "Dostupn verze"
    },
    title: "Firmware",
    upToDate: "Vae zazen je aktuln",
    upgradeAvailable: "K dispozici je nov aktualizace",
    version: {
      label: "Verze"
    }
  },
  hardware: {
    attestation: {
      "false": "Kontrola pravosti se nezdaila",
      label: "Kontrola pravosti",
      "true": "V BitBox02 je autentick"
    },
    sdcard: {
      "false": "Nen vloena",
      label: "microSD karta",
      "true": "Vloena"
    },
    securechip: "Bezpen ip",
    title: "Hardware"
  },
  loading: "Natn informac o zazen",
  pairing: {
    lock: {
      "false": "Vypnuto",
      label: "Dvoufaktorov autorizace (2FA)",
      "true": "Zapnuto"
    },
    mobile: {
      "false": "Zaveno",
      label: "Mobiln aplikace",
      "true": "Oteveno"
    },
    status: {
      "false": "Nesprovno",
      label: "Stav",
      "true": "Sprovno"
    },
    title: "Provn"
  },
  secrets: {
    manageBackups: "Spravovat zlohy",
    title: "Secrets"
  }
};
const deviceTampered$h = "Bylo k vaemu BitBoxu dodno heslo pro obnoven? Pokud ano, zastavte proces nastaven a okamit kontaktujte podporu. Spolenost Shift vm nikdy neposkytne hotovou penenku ani vm ned doporuen ohledn hesla.";
const dialog$i = {
  cancel: "Zruit",
  confirm: "Potvrdit",
  confirmTitle: "Potvrzen"
};
const error$d = {
  accountAlreadyExists: "et ji existuje.",
  accountLimitReached: "Nelze pidat et. Maximln poet t pro tuto mnu byl dosaen.",
  aoppCallback: "Pi doruovn adresy na {{host}} dolo k chyb.",
  aoppInvalidRequest: "Neplatn poadavek.",
  aoppNoAccounts: "Nejsou k dispozici dn ty.",
  aoppSigningAborted: "dost o potvrzen vlastnictv adresy zruena.",
  aoppUnknown: "Nastala neznm chyba.",
  aoppUnsupportedAsset: "Toto aktivum nen podporovno.",
  aoppUnsupportedFormat: "Nejsou k dispozici dn ty, kter by podporovaly poadovan formt adresy.",
  aoppUnsupportedKeystore: "Pipojen zazen neme podepisovat zprvy pro toto aktivum.",
  aoppVersion: "Neznm verze.",
  keystoreTimeout: "Platnost poadavku vyprela. Prosm zkuste to znovu.",
  wrongKeystore: "Byla pipojena patn penenka. Ujistte se, e jste vloili sprvn zazen odpovdajc tomuto tu.",
  wrongKeystore2: " Pokud pouvte pstupovou frzi, zkontrolujte, zda jste zadali sprvnou pstupovou frzi pro tento et."
};
const fiat$j = {
  "default": "vchoz",
  setDefault: "Nastavit {{code}} jako vchoz",
  title: "Mny"
};
const footer$j = {
  appVersion: "Verze aplikace:"
};
const generic$d = {
  enabled_false: "Vypnuto",
  enabled_true: "Zapnuto"
};
const genericError$h = "Dolo k chyb. Pokud zaznamente njak problmy, restartujte prosm aplikaci.";
const goal$h = {
  buttons: {
    create: "Vytvoit novou penenku",
    restore: "Obnovte penenku ze zlohy"
  },
  paragraph: "Vyberte prosm jednu z nsledujcch monost:",
  step: {
    "1": {
      title: "Informace o zabezpeen"
    },
    "2": {
      description: "Nastavit heslo zazen",
      title: "Zazen"
    },
    "3-create": {
      description: "Vytvoit novou penenku",
      title: "Penenka"
    },
    "3-restore": {
      description: "ze zlohy",
      title: "Obnovit"
    },
    "4-create": {
      title: "Pehled"
    },
    "4-restore": {
      title: "Pehled"
    }
  }
};
const guide$i = {
  accountDescription: {
    text: 'V pehledu tu se zobrazuje disponibiln zstatek a pchoz a odchoz transakce. Vce informac o jednotlivch typech t najdete v naem prvodci v sti "Nastaven". ',
    title: "Co se mi na tto strnce zobrazuje?"
  },
  accountFiat: {
    text: "Ano. Kliknutm na libovoln ticker mete volit mezi fiat mnami. Seznam mn mete zmnit v nastaven.",
    title: "Mohu zobrazit jin smnn kurzy?"
  },
  accountIncomingBalance: {
    text: "Pichzejc transakce zahrnuj stky, kter vm byly pevedeny, ale jet nebyly potvrzeny st.",
    title: "Co znamen pichzejc transakce?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Kad xpub je svzn se zobrazenm typem: bu "Native Segwit (bech32)", "Wrapped Segwit" nebo "Taproot" (pouze u Bitcoinu). Jedn se o typy skript, kter pouv {{coinName}}. BitBoxApp je kombinuje a podporuje vce typ skript v rmci jednoho tu. Protoe kad typ skriptu dv jin xpub, existuje vce xpub pro jeden et.\n\nPokud soustavn pijmte na vchoz adrese (Native Segwit), potebujete pouze "bech32" xpub. Pokud vak pijmte prostedky tak na "Wrapped Segwit" nebo "Taproot", muste pouvat tak dal veejn kle "Wrapped Segwit", xpub respektive "Taproot" xpub.',
      title: "Pro existuje vce xpub?"
    },
    privacy: {
      text: "U tohoto konkrtnho tu odhaluje xpub veejn kl celou finann historii, zstatek na tu a vechny budouc transakce. Xpub vak nikomu neumouje utrcet vae prostedky.\n\nPokud xpub nkomu pedte, mli byste si bt vdomi toho, e tato osoba nebo spolenost me vidt vechny ostatn transakce tohoto tu. Proto je dobr pouvat tento et pouze k tomuto elu a ostatn prostedky dret na jinch tech.",
      title: "Musm svj xpub dret v tajnosti?"
    },
    verify: {
      text: "Ano, vdy je dobr si xpub pekontrolovat. Pokud z tohoto xpubu bude nkdo jin generovat adresy a poslat vm penze, je to obzvl dleit. Muste ho ovit na zazen, abyste se ujistili, e tento xpub pat vm; jinak by vechny prostedky mohly jt na nesprvn adresy.",
      title: "Musm ovit xpub na zazen?"
    },
    xpub: {
      text: "Veejn kl (xpub) je zkladn kl, z nho jsou odvozeny vechny adresy tu.\n\nJe zde uveden pro pokroil pouvn a interoperabilitu s penenkami urenmi pouze pro sledovn (watch-only wallets), jako je Electrum nebo Sentinel. Pokud jste pijmali na rzn typy adres, importujte prosm vechny rzn formty xpub do watch-only penenky, abyste vidli vechny sv prostedky.\n\nUpozorujeme, e penenky tetch stran nemus zatm podporovat Taproot xpub.",
      title: "Co je veejn kl (xpub)?"
    }
  },
  accountRates: {
    text: "Smnn kurzy aktualizujeme kadou minutu z CoinGecko.",
    title: "Jak smnn kurzy plat?"
  },
  accountReload: {
    text: "To nen poteba. Informace o transakci se aktualizuj automaticky.",
    title: "Mohu znovu nast historii transakc?"
  },
  accountSendDisabled: {
    text: "Tlatko Odeslat se aktivuje, kdy je v zstatek vy ne nula.",
    title: "Pro nemu poslat dn {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Celkov stka je soutem vech vaich t. Smnn kurzy jsou zskvny z coingecko.com.\n\nPoznmka: Pokud pouvte MyEtherWallet pro tokeny, kter nejsou podporovny v aplikaci BitBoxApp, nebudou do zobrazen stky zahrnuty.",
    title: "Jak se vypot celkov stka?"
  },
  accountSummaryDescription: {
    text: "Zde mete sledovat vkonnost svho portfolia v prbhu asu. Pod grafem se zobrazuje pehled vaich jednotlivch t.",
    title: "Co se mi na tto strnce zobrazuje?"
  },
  accountTransactionAttributesBTC: {
    text: "Virtuln velikost: Uruje sov poplatek. spn jste uetili na poplatcch, pokud je men ne velikost transakce.\nVelikost: Skuten velikost transakce v bajtech pi serializaci podle pslunho blockchainu.\nVha: Nov metrika zaveden se Segwitem pro vyhodnocovn velikosti transakc a blok. Kad byte segregovanho svdka {segregated witness) se pot jako jedna, ve ostatn jako tyi jednotky vhy. Msto jednoho megabajtu ve skuten velikosti je nyn limit velikosti bloku tyi miliony vhovch jednotek.",
    title: "A co podrobnosti transakce specifick pro bitcoiny?"
  },
  accountTransactionAttributesGeneric: {
    text: "Potvrzen: Vae prvn transakce je nepotvrzen, dokud ji ta nezaad do bloku, pot m jedno potvrzen. Kad dal blok v sti pidv k va transakci dal potvrzen. Obecn plat, e obchodnci a dal astnci st akceptuj transakce jako vypodan s minimem t a esti potvrzen.\nID transakce: Jedinen identifikan slo, kter umouje vyhledat transakci v blok exploreru.\nPoplatek: Tam se plat transakn poplatek jako pobdka k zahrnut transakc do blok, kter vyt. Chcete-li se dozvdt vce, kliknte na tlatko odeslat.",
    title: "Jak jsou informace v detailech transakce?"
  },
  accountTransactionConfirmation: {
    text: "Transakce odeslan do st, ale dosud nepotvrzen.",
    title: "Co je to ekajc transakce?"
  },
  accountTransactionLabel: {
    text: "Je to adresa, ze kter jste obdreli prostedky nebo na kterou jste je odeslali.",
    title: "Jak adresa se zobrazuje u kad transakce?"
  },
  accountTransactionTime: {
    text: "Doba potvrzen transakce v blockchainu.",
    title: "Jak as se zobrazuje?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin a Litecoin mohou mt libovoln mnostv t. Po pti tech mete pidat dal et pouze v ppad, e pedchoz et byl pouit. \nOstatn mny mohou mt maximln pt t.",
      title: "Kolik t mohu vytvoit?"
    },
    howtoAddTokens: {
      text: 'Tokeny vyuvajc standard ERC20 jsou vzny na konkrtn et Etherea. Chcete-li aktivovat nebo deaktivovat konkrtn token, otevete obrazovku "Sprva t", rozbalte svj et Ethereum a zapnte nebo vypnte poadovan token.',
      title: "Jak mohu pidat dal tokeny?"
    },
    moveFunds: {
      text: "Ano, ale protoe jsou ty nezvisl, muste sv prostedky poslat pomoc bn transakce.",
      title: "Mohu pesouvat prostedky mezi ty?"
    },
    recoverAccounts: {
      text: "Ano, BitBoxApp vytv ty pomoc zavedench standard kompatibilnch s vtinou ostatnch kryptopenenek.",
      title: "Mohu obnovit sv ty v jinch penenkch?"
    },
    whatAreAccounts: {
      text: "Vae penenka um spravovat vce t jedn mny. ty jsou uiten, kdy chcete mt prostedky oddlen.",
      title: "Co jsou ty?"
    },
    whatIsRememberWallet: {
      text: `Povolenm monosti "Zapamatovat si penenku" mete v aplikaci BitBoxApp vidt ty tto penenky, i kdy nen BitBox02 pipojen. Dky tomu mete kdykoli zkontrolovat svj zstatek a portfolio. BitBox02 mus bt stle pipojen a odemen, aby bylo mon odeslat nebo pijmat prostedky.

Pokud je monost "Zapamatovat si penenku' vypnut, muste znovu zapojit svj BitBox02 (nebo penenku s pstupovou frz) aby jste ty znovu vidli v aplikaci BitBoxApp.`,
      title: "Co se stane, kdy povolm nebo vypnu Zapamatovat penenku?"
    },
    whyIsThisUseful: {
      text: "ty jsou skvl pro sprvu prostedk pro rzn osoby nebo ely, protoe jsou oddlen. Mete tak sdlet veejn kl (xpub) tu, ani byste prozradili cokoli o svch ostatnch tech. To vm umouje opakovan pijmat finann prostedky bez opakovanho pouvn adres, napklad pi pobrn mzdy nebo pravidelnm nkupu kryptomn.",
      title: "Pro je to uiten?"
    }
  },
  appendix: {
    link: "Kontaktujte ns!",
    text: "Dal otzka?"
  },
  backups: {
    check: {
      text: '"Zkontrolovat zlohu" umouje ovit, zda mte funkn zlohu odpovdajc va aktuln penence. Lze ji tak pout k oven, zda mte stle sprvn heslo pro obnoven. Mete zkontrolovat hlavn heslo pro obnoven nebo skryt heslo pro obnoven.',
      title: "Co je to Zkontrolovat zlohu?"
    },
    encrypt: {
      text: "Ne, ale k zskn penenky z uloenho seedu {slov pro obnoven) je nutn vae heslo pro obnoven.",
      title: "Mohu zlohu zaheslovat?"
    },
    howOften: {
      text: "Zloha se generuje automaticky pi vytvoen nov penenky. Novou zlohu muste vytvoit pouze v ppad, e microSD kartu ztratte nebo pokodte, nebo pokud chcete jako zlohu pout vce microSD karet.\nPo uskutenn transakc nemuste vytvet nov zlohy. Vechna data transakc lze znovu vytvoit pomoc jedin zlohy, kter byla pro vs automaticky vytvoena.",
      title: "Jak asto musm vytvet zlohu?"
    },
    whatIsABackup: {
      text: "Jedn se o kopii obnovovacho seedu na microSD kart. Seed {slova pro obnoven) spolu s heslem pro obnoven vytv vai penenku.",
      title: "Co je zloha?"
    }
  },
  backupsBB02: {
    check: {
      text: "Zkontrolovat zlohu vm umouje ovit, e mte funkn zlohu odpovdajc va aktuln penence.",
      title: "Co je to Zkontrolovat zlohu?"
    },
    encrypt: {
      text: 'Ne. microSD kartu uchovvejte v bezpe, protoe obsahuje nezaifrovan obnovovac seed k obnoven penenky. Pokud si pejete chrnit seed heslem, mete aktivovat volitelnou pstupovou frzi v expertnm nastaven v sti "Sprva zazen".',
      title: "Mohu zlohu zaifrovat?"
    },
    whatIsABackup: {
      text: "Jedn se o kopii obnovovacho seedu na microSD kart.",
      title: "Co je zloha?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Kdy je aktivn funkce 2FA, mus bt vechny transakce schvleny na sprovanm mobilnm telefonu, aby bylo mon utrcet prostedky. Do mobiln aplikace je odeslno zaifrovan jednorzov slo, kter je tam deifrovno a po stisknut tlatka Pijmout je odeslno zpt do BitBoxu. Tato komunikace se zazenm probh prostednictvm kanlu mezi mobilnm telefonem a touto desktopovou aplikac vytvoenho bhem provn.\n\nPed zapnutm funkce 2FA nezapomete zlohovat penenku a sprovat mobiln aplikaci. Po aktivovn jsou microSD slot a provn s mobiln aplikac vypnuty. Lze je znovu aktivovat resetovnm BitBoxu, m se zazen vymae.",
      title: "Jak funguje dvoufaktorov autorizace (2FA)?"
    },
    disable2FA: {
      text: `Chcete-li 2FA deaktivovat, muste resetovat BitBox a pot obnovit penenku ze zlohy. Ujistte se, e stle mte microSD kartu se zlohou a e si stle pamatujete heslo pro obnoven. Pot stisknte tlatko "Resetovat zazen". Nastavte nov heslo zazen a zvolte 'Nebo obnovit ze zlohy'. Vyberte zlohu penenky, kliknte na 'Obnovit' a zadejte heslo pro obnoven, kter jste pouili pi vytven penenky.`,
      title: "Jak mohu deaktivovat dvoufaktorovou autorizaci (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox mete kdykoli odpojit, ani byste jej museli nejprve vysunout.",
      title: "Jak mohu vysunout BitBox?"
    },
    ejectSD: {
      text: "MicroSD kartu mete z BitBoxu kdykoli vyjmout, pokud prv nevytvte nebo neobnovujete zlohu.",
      title: "Jak mohu microSD kartu vysunout?"
    },
    hiddenWallet: {
      text: "Jedn se o druhou penenku na stejnm zazen chrnnou jinm heslem zazen a heslem pro obnoven, kter mete pout pro hodnovrn popen (plausible deniability). Pro normln i skrytou penenku se pouv stejn seed, take nen teba dn dal zlohovn.",
      title: "Co je to skryt penenka?"
    },
    legacyHiddenWallet: {
      text: "Nejprve kliknte na ne uveden tlatko (je k dispozici, pokud je BitBox odemen hlavnm heslem zazen a funkce 2FA je vypnut), pot Bitbox znovu pipojte a odemknte jej skrytm heslem.",
      title: "Jak se dostanu k legacy skryt penence?"
    },
    pairing: {
      text: "Po staen na mobiln aplikace pro iOS nebo Android naskenujete zobrazen QR kd, m se vytvo zabezpeen kanl mezi mobiln aplikac a touto aplikac. Po naskenovn postupujte podle pokyn v mobiln aplikaci.",
      title: "Jak bezpen sprovat s telefonem"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Dal podrobnosti naleznete na webovch strnkch Bitsurance a jejich FAQ.",
      title: "Dal otzky?"
    },
    privacy: {
      link: {
        text: "Zsady ochrany osobnch daj Bitsurance"
      },
      text: "Jako kad bn pojistka obsahuje vae cel jmno a adresu a specifikuje pojitn objekt (definovan rozenm veejnm klem (xpub) pojitnho bitcoinovho tu). Tato data jsou odeslna pmo spolenosti Bitsurance a nejsou sdlena se spolenost Shift Crypto. Dal informace naleznete v zsadch ochrany osobnch daj Bitsurance",
      title: "Jak osobn daje jsou pro pojitn poteba?"
    },
    renew: {
      text: "Pojitn se automaticky obnov na dal rok. Obnoven mete kdykoli zruit kliknutm na Spravovat smlouvu v aplikaci BitBoxApp, kter vs penese na zkaznick portl Bitsurance.",
      title: "Jak mohu obnovit nebo zruit pojitn?"
    },
    status: {
      text: 'spn pojitn ty jsou oznaeny zelenm odznakem "pojitno" v levm hornm rohu na kad strnce tu Bitcoin. V sekci "Pojitn" si mete prohldnout pehled vech pojitnch t Bitcoin a jejich aktuln stav pojitn. Aktualizace stavu pojitn me trvat a 48 hodin.',
      title: "Mohu zkontrolovat stav pojitnho tu?"
    },
    what: {
      text: "Kad bitcoinov pojistn smlouva se vztahuje na konkrtn et penenky. Sjednnm vce pojistek mete pojistit vce t. Pojitn ty jsou omezeny na pouvn bitcoinovch adres Native Segwit.",
      title: "Je pojitna cel penenka BitBox?"
    },
    who: {
      text: "Pojitn nabz Bitsurance, pojiovac makl postaven bitcoinery. Spolupracuj s pojitnm ELEMENT, aby poskytovali pojitn bitcoin. Ob spolenosti sdl v Nmecku.",
      title: "Kdo pojiuje moje bitcoiny?"
    },
    why: {
      text: "Bitsurance pokrv nkter rizika vlastn schovy (self-custody), kter nespadaj ani do t nejbezpenj penenky, nap. vloupn, vydrn nebo znien penenky. Je to vae osobn rozhodnut, zda potebujete pojitn pro tato rizika.",
      title: "Potebuji pojitn bitcoin?"
    }
  },
  cointracking: {
    text: 'Kliknte na tlatko "Export" a otevete sloku se staenmi soubory, kde najdete export CSV. Pot kliknte na ne uveden odkaz, nahrajte svj BitBox CSV soubor a importujte data, abyste je mohli pout pro sprvce portfolia CoinTracking a pro vytven daovch vkaz.',
    title: "Jak importovat m transakce do sluby CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Pette si vce o kontrole pravosti"
      },
      text: "BitBoxApp provede atestan kontrolu BitBox02, aby ovila, zda je zazen prav. Kontrola se provd lokln a nepipojuje se k dnm serverm.",
      title: "Jak probh kontrola pravosti?"
    },
    name: {
      text: "Jedn se o nzev va penenky a zlohy. Nzev se pouv pro budouc zlohy a me slouit k rozlien rznch penenek. Lze jej kdykoli zmnit, ale mjte na pamti, e zlohy vytvoen ped zmnou budou stle pouvat pedchoz nzev.",
      title: "K emu slou nzev BitBoxu?"
    },
    "secure-chip": {
      link: {
        text: "Dal informace o bezpenm ipu"
      },
      text: "Tato informace zobrazuje slo modelu zabezpeenho ipu, nejnovj ip je ATECC608B s vylepenmi bezpenostnmi funkcemi ve srovnn se starmi modely.",
      title: "Pro zobrazovat model bezpenho ipu?"
    }
  },
  receive: {
    address: {
      text: "Adresu mete dt ostatnm, aby vm poslali njak prostedky. Jen se ujistte, e je poslaj na sprvnou adresu.",
      title: "Co mohu dlat s adresou?"
    },
    addressChange: {
      text: "Jakmile provedete transakci, do seznamu se automaticky pid nov adresa, take je vdy k dispozici 20 adres, kter nikdy neobdrely dn prostedky.",
      title: "Kdy se adresy mn?"
    },
    addressFormats: {
      text: "Ve vchozm nastaven je typ adresy Native Segwit. Tento typ adresy je iroce rozen mezi ostatnmi penenkami/burzami poskytuje nejlep sazby poplatk za kadodenn transakce. Mete si vak tak zvolit odesln na Taproot (jen pro Bitcoin), co je nejnovj typ adresy, kter vak jet nemus bt vude podporovn. Ppadn, pokud mte problmy s odeslnm na Native Segwit (vchoz typ), mete zkusit pejt na star typ adresy Wrapped Segwit, kter me bt kompatibiln s vce penenkami/burzami.",
      title: 'Kdy mm pout "Zmnit typ adresy"?'
    },
    howVerify: {
      text: "V ppad BitBox01 kliknte na ikonu BitBox v postrannm panelu vlevo a podvejte se do sti Provn. Prvodce se aktualizuje a vy mete pokraovat podle pokyn odtud.\nU BitBox02 mete adresy ovit pmo v zazen bhem procesu odesln/pijmn.",
      title: "Jak mohu bezpen ovit adresu?"
    },
    plugout: {
      text: "Ne, po odesln prostedk na adresu BitBoxu nemuste nechvat BitBox pipojen. Svj BitBox mete kdykoli odpojit.",
      title: "Musm nechat svj BitBox bhem pijmn zapojen?"
    },
    why20: {
      text: 'Bhem sputn aplikace generuje adresy odvozen z vaeho seedu a zjiuje, zda obdrely prostedky. Protoe aplikace me generovat tm nekonen mnostv adres, mohla by zjiovnm zstatku strvit roky. Aby se toto hledn omezilo, zastav se, jakmile uvid 20 adres, kter nikdy neobdrely dn prostedky. To je "gap limit" a 20 je de facto standard, i kdy toto slo je libovoln. Z tchto 20 adres si mete vybrat.',
      title: "Pro jenom 20 adres?"
    },
    whyMany: {
      text: "V zjmu zachovn soukrom a bezpenosti nikdy pro pijman nepouvejte stejnou adresu dvakrt. Pokud jste adresu pouili, kliknte na ipku vpravo pro novou adresu. Najednou mete vygenerovat a 20 adres. Pedstavte si adresy jako sla faktur. Vechny adresy jsou odvozeny z vaeho jedinho obnovovacho seedu.",
      title: "Pro tolik adres?"
    },
    whyVerify: {
      text: "Nemli byste vit, e v pota generuje a zobrazuje autentick adresy. Jeho ton plocha (attack surface) jej in podstatn zranitelnjm ne hardwarovou penenku. U BitBox01 Tlatko pro oven adresy bezpen odele adresu do sprovanho mobilnho telefonu, ze kterho mete tak naskenovat a ovit kd QR. U BitBox02 lze adresu ovit pmo na displeji BitBoxu.",
      title: "Pro bych ml adresu bezpen ovit?"
    }
  },
  send: {
    change: {
      text: "Zstatek bude vrcen na adresu Taproot, pokud mte alespo jedno  Taproot UTXO. Pokud pouijete coin control, bude zstatek vrcen na adresu Taproot, pokud je mezi vybranmi UTXO alespo jedno Taproot UTXO. Ve vech ostatnch ppadech se zmna vrt na nativn adresu Segwit.",
      title: "Jak se uruje change output (hodnota zstatku)?"
    },
    fee: {
      text: "Poplatek se odvj od velikosti dat transakce, nikoli od jej ve. Clov hodnoty poplatk jsou vypotvny algoritmem pro odhad poplatk v Bitcoin Core pro kadou vmi zvolenou prioritu st. Jsou zobrazeny, pokud maj jinou hodnotu ne cl uveden ne.\nsporn: 24 blok (piblin 4 hodiny u Bitcoinu, 1 hodina u Litecoinu).\nNzk: 12 blok (piblin 2 hodiny pro Bitcoin, 30 minut pro Litecoin).\nNormln: 6 blok (piblin 1 hodina pro Bitcoin, 15 minut pro Litecoin).\nVysok: 2 bloky (piblin 20 minut pro Bitcoin, 5 minut pro Litecoin)\n(Vyten jednoho bloku trv u Bitcoinu v prmru deset minut (u Litecoinu 2,5 minuty) a zaten st se me ve ve uvedench obdobch znan liit).",
      title: "Jak se uruje poplatek?"
    },
    plugout: {
      text: "Ne, jakmile provedete transakci, nemuste nechvat svj BitBox pipojen. Mete svj BitBox kdykoli odpojit.",
      title: "Musm nechat svj BitBox bhem odesln pipojen?"
    },
    priority: {
      text: "m vy poplatek jste ochotni zaplatit, tm rychleji je obvykle vae transakce potvrzena st.",
      title: "Co je to priorita st (network priority)?"
    },
    revert: {
      text: "Jakmile je transakce podepsna a odeslna (tj. vyslna do st), nelze ji ji vrtit zpt. Ped podpisem transakce (vetn poplatku) ji podn ovte!\nPokud pjemce znte a je ochoten vm poslat stejnou stku (po odeten transaknch poplatk) zpt, mete mu poslat novou pijmac adresu.",
      title: "Mohu transakci vrtit zpt?"
    },
    whyFee: {
      text: "Transakce sout o jejich potvrzen taem. Tai vybraj transakce, kter maj bt zaazeny do blockchainu, na zklad jejich poplatk.\nTai hlasuj o historii transakc. Protoe neexistuje dvryhodn tet strana, kter by vynucovala jeden hlas na osobu (co je cel smysl blockchain), hlasuj tai o transakcch tak, e obtuj nkladn zdroj, jako je vpoetn vkon. Jako odmnu za svou prci si mohou nrokovat nov vytvoen mince a poplatek za vechny zahrnut transakce.",
      title: "Pro se plat sov poplatek?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Pokud se k uzlu hodlte pipojit pouze tehdy, kdy jste ve stejn sti (nap. domc wifi), pak vm posta bn sov komunikace.\nV takovm ppad je vhodn, aby v Electrum server poskytoval certifikt TLS pro ifrovn komunikace.\nPokud se hodlte k uzlu pipojit odkudkoli, je lep volbou pouit st Tor. V takovm ppad nen certifikt TLS nutn.",
      title: "Mm pout clearnet TCP, TLS nebo Tor?"
    },
    instructions: {
      link: {
        text: "Prvodce pro pipojen uzlu"
      },
      text: "pln nvod naleznete v naem prvodci:",
      title: "Jak pipojm BitBoxApp k vlastnmu uzlu?"
    },
    options: {
      text: "Existuje vce monost, jak provozovat vlastn uzel, napklad zakoupit hotov zazen, postavit si vlastn nebo pouvat Bitcoin Core.\nPokud chcete k uzlu pipojit BitBoxApp, ujistte se, e na nm b server Electrum. Jedn se o specializovan program, kter umouje  penence komunikovat s vam uzlem.\nMezi podporovan monosti pat Electrs, Electrum Personal Server (EPS) nebo Bitcoin Wallet Tracker (BTW).",
      title: "Jak jsou monosti provozovn uzlu?"
    },
    tor: {
      text: 'Tor je zkratka pro "The Onion Router", co je bezplatn software s open source kdem, kter nabz mnoho vhod v oblasti ochrany soukrom a je uiten zejmna pi pouvn Bitcoinu.\nPokud se hodlte pipojit k uzlu prostednictvm Toru, ujistte se, e je Tor na vaem potai nainstalovn, a pot aktivujte Tor Proxy v nastaven BitBoxApp.\nU vtiny operanch systm existuj dva zpsoby, jak Tor spustit:\n1. Prohle Tor: Sthnte si a otevete prohle Tor Browser. To umon aplikaci BitBoxApp pipojit se k sti Tor nastavenm portu 9150 v nastaven proxy serveru Tor.\n2. Sluba Tor na pozad: nainstalujte Tor daemon, kter vdy b na pozad. BitBoxApp se pak me pipojit nastavenm portu 9050 v nastaven proxy serveru Tor.',
      title: "Co je Tor, Tor proxy a jak port mm pout?"
    },
    what: {
      text: "Penenku je mon provozovat s vlastnm uzlem namsto server Shift.",
      title: "Co to je?"
    },
    why: {
      text: "Provozovn vlastnho uzlu nen nutn, ale zlepuje soukrom a sniuje potebu dvovat nkomu jinmu.\nZaprv to znamen, e pouvte Bitcoin soukromji, protoe BitBoxApp se nebude pipojovat k naim serverm, aby zskala historii vaich transakc; msto toho bude tyto informace zskvat z vaeho vlastnho uzlu.\nZa druh, sputn vlastnho uzlu znamen, e v uzel sm ovuje vechny transakce a zajiuje tak dodrovn pravidel konsensu (consensus rules).",
      title: "Pro bych ml provozovat vlastn uzel?"
    }
  },
  settings: {
    sats: {
      text: 'Satoshi (zkrcen "sat") je nejmen jednotka bitcoinu. Jeden satoshi je jedna stamiliontina bitcoinu (0,00000001 BTC). Je pojmenovna po tvrci bitcoinu Satoshi Nakamotovi.',
      title: "Co je to Satoshi?"
    },
    servers: {
      text: "Tato aplikace komunikuje se servery Shift Crypto a kontroluje aktualizace, nat transakce a odesl informace sprovanm mobilnm aplikacm.\nAplikace tak nat nejnovj smnn kurzy z CoinGecko. Vechny konverze se potaj lokln, co znamen, e se nikdy neodeslaj dn daje o vi va transakce.\nPoznmka: Pro tokeny Ethereum a ERC20 pouvme Etherscan.io API.",
      title: "S ktermi servery tato aplikace komunikuje?"
    }
  },
  title: "Prvodce",
  toggle: {
    close: "Zavt prvodce",
    open: "Prvodce"
  },
  trackingModePortfolioChart: {
    text: "Na potai najete kurzorem na graf. Na mobilnm telefonu podrte prst na grafu a pothnte vodorovn.",
    title: "Jak zobrazit historick hodnoty na grafu?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Muste zazen resetovat a obnovit penenku ze zlohy pomoc hesla pro obnoven.",
      title: "Co mm dlat, kdy jsem zapomnl heslo k zazen?"
    },
    reset: {
      text: "Zadejte 15krt patn heslo zazen. Nkolik poslednch pokus vyaduje dlouh dotyk na zazen.",
      title: "Jak resetuji zazen?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Zazen by mlo po pipojen jednou bliknout. Ujistte se, e je zapojeno sprvnou stranou. Pokud mte pote, kontaktujte ns prostednictvm ne uvedenho odkazu.\n\nZazen BitBox01 nen podporovno v mobilnch zazench. K pipojen zazen BitBox01 pouijte aplikaci BitBoxApp na stolnm potai.",
      title: "Mj BitBox01 nebyl rozpoznn"
    },
    getDevice: {
      link: {
        text: "Objednejte si BitBox"
      },
      text: "BitBox si mete zakoupit v naem internetovm obchod:",
      title: "Jak si mohu zazen podit?"
    },
    internet: {
      text: "Ano, k synchronizaci penenky, odesln transakc a natn nejnovjch smnnch kurz je nutn pipojen k internetu.",
      title: "Vyaduje tato aplikace pipojen k internetu?"
    },
    lostDevice: {
      link: {
        text: "Centrum zlohovn"
      },
      text: "Sv ty mete obnovit na novm BitBoxu nebo v naem centru zlohovn.",
      title: "Ztratil jsem zazen. Co te?"
    },
    useWithoutDevice: {
      text: "V souasn dob to bohuel nen mon.",
      title: "Mohu aplikaci pouvat i bez zazen?"
    },
    welcome: {
      text: "Dkujeme za pouvn tto aplikace vytvoen spolenost Shift Crypto ve vcarsku. Jsme rdi za jakkoli pspvek, o kter se s nmi podlte. Poskytnte prosm zptnou vazbu pomoc odkazu v doln sti.",
      title: "Vtejte v BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Pokud pouvte nov telefon/pota s BitBoxApp, budete se muset k dapps pipojit znovu. Pot opt uvidte sv prostedky v dapp jako obvykle.",
      title: "Nevidm sv pedchoz spojen."
    },
    supportedNetworks: {
      text: "V souasn dob je pomoc WalletConnect v BitBoxApp podporovn pouze Ethereum mainnet . Chcete-li pouvat jin st kompatibiln s EVM, pouijte prosm penenku z rozen prohlee Rabby.",
      title: "Kter st jsou podporovny?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikan protokol pro aplikace web3. Umouje pohodln pipojen k DApps a webovm penenkm zaloenm na Ethereu bez pouit aplikace tet strany, co je uiten zejmna pro uivatele BitBoxApp pro Android.",
      title: "Co je WalletConnect?"
    }
  }
};
const headerssync$h = {
  blocksSynced: "{{blocks}} blok zesynchronizovno"
};
const hiddenWallet$h = {
  info1HTML: "Pro ely hodnovrnho popen (plausible deniability) lze skrytou penenku vytvoit na zklad kombinace <strong>odlinho</strong> hesla zazen + hesla pro obnoven.",
  info2HTML: "Ne definujte heslo zazen a heslo pro obnoven, kter chcete piadit ke sv skryt penence. Heslo zazen a heslo pro obnoven mus bt <strong>odlin</strong> od tch, kter jste definovali pro svou primrn penenku.",
  passwordLabel: "Skryt heslo pro obnoven",
  passwordPlaceholder: "Potvrte prosm skryt heslo pro obnoven",
  pinLabel: "Heslo pro skryt zazen",
  pinRepeatLabel: "Zopakujte heslo pro skryt zazen",
  pinRepeatPlaceholder: "Potvrte prosm heslo pro skryt zazen",
  success: "Skryt penenka byla spn vytvoena. Znovu pipojte svj BitBox, abyste jej odemkli."
};
const initialize$h = {
  create: "Nastavit heslo zazen",
  creating: "Nastavovn hesla zazen",
  error: {
    e102: "Heslo zazen mus obsahovat alespo 4 znaky."
  },
  info: {
    description1: "Zvolte heslo zazen. To bude pouito k odemknut vaeho BitBoxu.",
    description2: "Mete pouvat sla, psmena a symboly. Del hesla poskytuj vy bezpenost.",
    description3: "Pokud heslo k zazen ztratte, budete muset zazen resetovat a obnovit ze zlohy.",
    subtitle: "Nyn nastavte heslo svho zazen",
    title: "Inicializace zazen"
  },
  input: {
    label: "Heslo zazen",
    labelRepeat: "Opakujte heslo zazen",
    placeholderRepeat: "Potvrte heslo zazen"
  }
};
const invalidFormat$h = "Nesprvn formt";
const language$i = {
  title: "Zvolte jazyk"
};
const legacyhiddenwallet$h = {
  disable: "Deaktivovat legacy skrytou penenku",
  enable: "Aktivovat legacy skrytou penenku",
  successDisable: "spn deaktivovna legacy skryt penenka.",
  successEnable: "Star legacy penenka byla spn aktivovna. Znovu zapojte svj BitBox a zadejte heslo skrytho zazen pro pstup k legacy skryt penence."
};
const loading$h = "natn";
const manageAccounts$b = {
  accountHidden: "Tento et byl skryt z vaich watch-only t. Chcete-li jej znovu zobrazit, pipojte prosm svj BitBox02.",
  editAccount: "Upravit",
  editAccountNameTitle: "Upravit nzev tu",
  noAccounts: "nebyly nalezeny dn ty",
  settings: {
    hideTokens: "Skrt tokeny",
    showTokens: "Zobrazit tokeny ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Pidat a zobrazit/skrt ty",
  title: "Spravovat ty",
  watchAccount: "Sledovat et",
  watchAccountDescription: "Tento et je soust watch-only t. Mete jej skrt ze svch watch-only t pomoc pepnae."
};
const mobile$c = {
  usingMobileDataWarning: "Vyuit mobilnch dat: tato aplikace me po odemen tu sthnout a nkolik set megabajt dat z blockchainu. Abyste se vyhnuli pouvn mobilnch dat, pipojte se k Wi-Fi. Po jejm zaven se tato zprva ji nebude zobrazovat."
};
const newSettings$a = {
  about: {
    appVersion: {
      title: "Verze aplikace"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Uzamen pstupu k aplikaci pomoc zmku obrazovky/otisku prstu.",
      title: "Uzamen obrazovky"
    },
    coinControl: {
      description: "Vyberte, kter UTXO jsou soust transakce, abyste zlepili soukrom."
    },
    customFees: {
      description: "Umouje zadat vlastn poplatek pi odesln."
    },
    torProxy: {
      description: "Pipojte se pes Tor pro lep soukrom."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Tyto dal mny mete pepnat na strnce svho tu.",
      title: "Aktivn mny"
    },
    darkmode: {
      description: "Podvejte se na BitBoxApp v tmavm reimu."
    },
    defaultCurrency: {
      description: "Vyberte vchoz mnu",
      title: "Vchoz mna"
    },
    enableAccount: {
      description: "Deaktivace tu znamen, e se nezobraz v postrannm panelu ani v portfoliu. Zde jej mete kdykoli znovu aktivovat. Prostedky na tomto tu nebudou ovlivnny a zstanou v bezpe.",
      title: "Aktivovat/deaktivovat et"
    },
    hideAmounts: {
      description: "Zobrazuje pepna pro skryt zstatku a stek pro ochranu soukrom pi pouvn aplikace na veejnosti.",
      hideAmounts: "Skrt stky",
      showAmounts: "Zobrazit stky",
      title: "Povolit skryt stek"
    },
    language: {
      description: "Jak jazyk chcete v BitBoxApp pouvat.",
      title: "Jazyk"
    },
    remebmerWallet: {
      name: "Zapamatovat penenku",
      warning: "Tm odstrante zapamatovanou penenku. Chcete-li ji znovu zobrazit, muste pipojit BitBox02 pro tuto penenku. dn prostedky v tto penence nebudou ovlivnny. Chcete pokraovat?",
      warningTitle: "Deaktivovat zapamatovn penenky"
    },
    toggleSats: {
      description: "Aktivovat nebo deaktivovat Satoshi."
    }
  }
};
const note$d = {
  input: {
    description: "(voliteln)",
    placeholder: "Pidat poznmku"
  },
  title: "Poznmka"
};
const notification$h = {
  newTxs_one: "Nov transakce v: {{accountName}}",
  newTxs_other: "{{count}} nov transakce v: {{accountName}}"
};
const pairing$h = {
  aborted: {
    text: "Provn bylo z mobiln aplikace zrueno.",
    title: "Zrueno"
  },
  button: "Sprovat mobiln aplikaci",
  confirm: "Jste si jisti, e chcete sprovat svj BitBox? Pamatujte, e pot je k proveden transakce vyadovn mobiln telefon.",
  connectOnly: {
    button: "Pipojte mobiln aplikaci",
    title: 'Naskenujte pomoc na mobiln aplikace vbrem poloky "Pipojit k nov aplikaci".'
  },
  error: {
    text: "Nco se pokazilo. Zante prosm znovu.",
    title: "Chyba"
  },
  pullFailed: {
    text: "Nepodailo se sthnout zprvu z mobilnho telefonu prostednictvm serveru. Server me bt offline, kontaktujte prosm podporu.",
    title: "Vytaen se nezdailo"
  },
  reconnectOnly: {
    button: "Znovu pipojte mobiln aplikaci"
  },
  scanningFailed: {
    text: "Mobiln telefon nebyl schopen zprvu spn naskenovat. Zkuste to prosm znovu.",
    title: "Skenovn se nezdailo "
  },
  start: {
    hideAppQRCode: "Skrt QR kd",
    revealAppQRCode: "Zobrazit QR kd",
    step1: "Pokud mobiln aplikaci nemte, mete naskenovat QR kd pro Apple App Store nebo Google Play Store podle toho, kter telefon mte.",
    step2: 'Naskenujte pomoc na mobiln aplikace, kterou najdete pod nzvem "Digital Bitbox 2FA" v obchodech s aplikacemi pro iOS a Android:'
  },
  started: {
    text: "Nyn postupujte podle pokyn v mobiln aplikaci.",
    title: "Skvl"
  },
  success: {
    text: "Gratulujeme, spn jste sprovali svj BitBox s mobiln aplikac!",
    title: "Hotovo"
  },
  timeout: {
    text: "Provn se po dvou minutch peruilo. Pokud chcete jet sprovat mobiln aplikaci, spuste ji znovu.",
    title: "Timeout"
  },
  title: "Provn mobilnho telefonu"
};
const passphrase$b = {
  considerations: {
    button: "vahy ohledn zlohovn",
    message: "Pstupov frze pidv vrstvu ochrany k va zloze penenky (zloha na microSD kart nebo obnovovac slova). Pokud m nkdo pstup k va zloze, bude k pstupu do penenky potebovat tak pstupovou frzi.\n\nTo vak znamen, e v ppad ztrty nebo rozbit vaeho BitBoxu budete potebovat <strong>i pstupovou frzi i zlohu penenky</strong> pro obnoven va penenky s pstupovou frz. Pokud zapomenete nebo ztratte svou pstupovou frzi, ztratte pstup ke vem prostedkm v tto penence.\n\nPi ukldn pstupov frze zvate jej umstn na jin msto ne kde mte zlohu. Pokud nkdo najde vai zlohu, nenajde tak vai pstupovou frzi.",
    title: "vahy ohledn zlohovn"
  },
  disable: "Deaktivovat pstupovou frzi",
  disableInfo: {
    button: "Deaktivovat",
    message: "Po vypnut pstupov frze ji nebudete po odemknut BitBoxu vyzvni k zadn pstupov frze. Proto vstoupte do sv vchoz penenky.\n\nVeker prostedky ve va penence s pstupovou frz budou stle v tto penence, avak nebudete k nim mt pstup, protoe po odemknut vaeho BitBoxu otevete svou vchoz penenku.\n\nPro optovn pstup k vaim penenkm s pstupovou frz jednodue znovu zapnte funkci pstupov frze a po odemknut BitBoxu zadejte pslunou pstupovou frzi.\n\n<strong>Tip:</strong> Do sv vchoz penenky mete pistoupit i ponechnm przdn pstupov frze, kdy ji mte aktivovanou."
  },
  enable: "Aktivovat pstupovou frzi",
  error: {
    e104: "Zmna nastaven pstupov frze byla zruena."
  },
  how: {
    button: "Jak to vypad",
    message: "A pstupov frze nefunguje jako heslo, na kter jste zvykl. Pokud heslo zadte chybn, nebudete na to upozornni. Je to proto, e <strong>kad pstupov frze vytv jinou, avak platnou penenku.</strong> To znamen, e mete pouvat vce pstupovch frz pro libovoln poet penenek. Kad penenka je vak pstupn pouze po zadn pslun pstupov frze.\n\nPo pipojen BitBoxu budete jako obvykle vyzvni k zadn hesla zazen. Pot budete vyzvni k zadn pstupov frze.\n\nPo zadn pstupov frze se zobraz vmi zadan pstupov frze. To proto, abyste mohli potvrdit, e jste ji zadali sprvn.",
    title: "Jak to funguje"
  },
  intro: {
    message: "Pstupov frze poskytuje dal vrstvu zabezpeen nad va penenkou.\nPojme se nauit, jak to funguje.",
    title: "Nastaven pstupov frze"
  },
  progressDisable: {
    message: "Potvrte na svm BitBoxu, e chcete <strong>deaktivovat</strong> volitelnou pstupovou frzi.",
    title: "Potvrte na zazen"
  },
  progressEnable: {
    message: "Potvrte na svm BitBoxu, e chcete <strong>aktivovat</strong> volitelnou pstupovou frzi.",
    title: "Potvrte na zazen"
  },
  successDisabled: {
    message: "Voliteln pstupov frze <strong>byla spn aktivovna</strong>!\nOd tto chvle budete vyzvni k zadn pstupov frze.",
    messageEnd: "Nyn znovu pipojte BitBox02.",
    title: "Pstupov frze aktivn"
  },
  successEnabled: {
    message: "Voliteln pstupov frze <strong>byla spn deaktivovna</strong>!\n\nJi nebudete vyzvni k zadn pstupov frze.",
    messageEnd: "Nyn znovu pipojte svj BitBox02.",
    tips: "Tipy",
    tipsList: [
      "Doporuujeme nejprve odeslat malou stku do penenky s pstupovou frz. Pot odpojte a znovu zapojte BitBox02 a zadejte heslo a pstupovou frzi. Pokud jste zadali pstupovou frzi sprvn, mli byste prostedky vidt ve sv penence.",
      "Pokud chcete vstoupit do sv pvodn penenky bez pstupov frze, mete to provst tak, e po vzv k zadn pstupov frze nezadte nic. Nebo mete funkci pstupov frze vypnout."
    ],
    title: "Pstupov frze deaktivovna"
  },
  summary: {
    button: "Aktivovat pstupovou frzi",
    title: "Pehled",
    understand: "Rozumm fungovn pstupov frze a rizikm s tm spojenm.",
    understandList: [
      "Pstupov frze pedstavuje dal vrstvu zabezpeen nad va zlohou.",
      "Zadnm jin pstupov frze se vdy vygeneruje jin penenka.",
      "K obnoven penenky potebujete <strong>pstupovou frzi i zlohu</strong>.",
      "Pokud zapomenete pstupovou frzi, <strong>ztratte pstup ke svm prostedkm</strong>."
    ]
  },
  what: {
    button: "Pette si, jak to funguje",
    message: "Penenka je vytvoena (odvozena) z velmi velkho nhodnho sla, znmho tak jako seed. Tento seed, nebo slova pro obnoven, je vytvoen pi prvnm nastaven BitBoxu a je zlohovn pomoc microSD karty anebo prostednictvm jin zlohy (papr, steelwallet apod.). Kad, kdo m pstup k seedu, m plnou kontrolu nad prostedky v tto penence.\n\nPstupov frze je <strong>voliteln tajemstv</strong>, kter se pidv k seedu. Pi pouit pstupov frze se pi kadm pouit vytvo nov penenka na zklad seedu + pstupov frze (nepovinnho tajemstv). Passphrase me bt jakkoli: psmena, slova, speciln znaky nebo me bt i przdn. Vchoz penenka je ve skutenosti odvozena od seedu + przdn pstupov frze.\n\nPstupov frze je soust standardu BIP39, co znamen, e je kompatibiln se vemi penenkami, kter tento standard podporuj.",
    title: "Co je pstupov frze?"
  },
  why: {
    button: "Pro pouvat pstupovou frzi",
    message: 'BitBox02 chrn seed ped staenm ze samotnho zazen, ale zloha (uloena na microSD kart nebo obnovovac slova zapsan na pape) umouje pln pstup k penence. Proto by mla bt uloena na bezpenm mst!\n\nVzhledem k tomu, e pstupov frze vytv novou penenku pomoc vaeho stvajcho seedu, vyaduje penenka s pstupovou frz k obnoven <strong>zlohu i pstupovou frzi</strong>. Vhodou je, e pokud nkdo najde vai zlohu, bude k pstupu do penenky s pstupovou frz stle potebovat pstupovou frzi.\n\nFunkce pstupov frze navc umouje vytvoit na stejnm zazen vce penenek nebo "skrytch penenek" krom t vchoz.',
    title: "Pro pouvat pstupovou frzi?"
  }
};
const password$h = {
  show: "Zobrazit {{label}}",
  warning: {
    caps: "VAROVN: Caps Lock () je zapnut",
    paste: 'pro vloen textu povolte "ZOBRAZIT {{label}}"'
  }
};
const random$i = {
  button: "Vygenerujovat nhodn slo",
  description: "V BitBox vygeneroval nsledujc {{bits}}-bit nhodn slo:"
};
const receive$j = {
  bitsuranceWarning: "Toto je pojitn et, co znamen, e me pijmat pouze na Native Segwit. Je to proto, abyste nhodou neobdreli Wrapped Segwit nebo Taproot, kter nejsou pojitny.",
  changeScriptType: "Zmit typ adresy",
  label: "Vae adresa",
  onlyThisCoin: {
    description: "Chcete-li pijmat dal tokeny, aktivujte je v nastaven. Pokud vlote jin tokeny, nemus bt pstupn.",
    warning: "Ujistte se, e pijmte pouze {{coinName}} na tto adrese."
  },
  scriptType: {
    p2tr: "Taproot (nejnovj formt)",
    p2wpkh: "Nativn Segwit (vchoz)",
    "p2wpkh-p2sh": "Wrapped Segwit (kompatibiln formt)"
  },
  selectAccount: "Vybrat et",
  showFull: "Zobrazit a ovit celou adresu na zazen",
  taprootWarning: "Poznmka: Taproot je nov funkce Bitcoinu a zatm nen iroce pouvna. Prostedky pijat na adresy Taproot nemus bt viditeln v penenkch tetch stran, kter jsou ureny pouze pro sledovn (watch-only wallets). Mnoho penenek a burz zatm nen schopno poslat na adresy Taproot.",
  title: "Pijmout {{accountName}}",
  verify: "Bezpen ovit adresu",
  verifyBitBox01: "Ovit adresu v mobiln aplikaci",
  verifyBitBox02: "Ovit adresu na BitBox02",
  verifyInstruction: "Zkontrolujte, zda se nsledujc adresa shoduje s adresou zobrazenou na vaem zazen.",
  warning: {
    secureOutput: 'Sprujte prosm svj BitBox s mobilnm zazenm, abyste mohli bezpen ovit adresu. Pejdte na "Spravovat zazen" v postrannm panelu.'
  }
};
const reset$h = {
  description: "Vechna data v zazen budou smazna. Vetn vaeho soukromho kle!",
  notReset: "Zazen nebylo resetovno",
  title: "Resetovat zazen do tovrnho nastaven",
  understand: "Mm zlohu a znm heslo pro obnoven",
  understandBB02: "Mm platnou zlohu"
};
const securityInformation$h = {
  create: {
    description1: "Doporuujeme nastavovat zazen v bezpenm prosted, to znamen mimo dosah dalch osob, kter by mohly vidt vmi zvolen heslo.",
    description2: "Budete vyzvni k vytvoen dvou hesel.",
    description3: "Prvn je <strong>heslo zazen</strong>, kter odemkne v BitBox a kter lze pozdji zmnit.",
    description4: "Druhm je <strong>heslo pro obnoven</strong>, kter odemkne vai penenku. Toto heslo nelze pozdji zmnit.",
    description5: "Penenka, kterou vytvote, bude zlohovna do souboru na dodan microSD kart. Ten mete v ppad nouze pout k obnoven svch prostedk pomoc hesla pro obnoven.",
    title: "Informace o zabezpeen"
  },
  restore: {
    description1: "Budete vyzvni k vloen microSD karty, kterou jste pouili k uloen zlohy.",
    description2: "K obnoven zazen budete potebovat heslo pro obnoven. ",
    description3: "Pi zadvn hesla pro obnoven bute opatrn. Jakkoli zadan heslo vytvo platnou penenku. Pokud zadte patn heslo, me se vm zobrazit zstatek penenky, kter neoekvte.",
    title: "Informace o zabezpeen"
  }
};
const seed$h = {
  agreements: {
    "funds-access": "Pokud zapomenu heslo pro obnoven, ZTRATM pstup ke svm finannm prostedkm.",
    "password-change": "Heslo pro obnoven NEMU pozdji zmnit",
    "password-required": "Heslo pro obnoven je nutn pro obnoven penenky ze zlohy."
  },
  create: "Vytvoit penenku",
  creating: "Vytven penenky",
  description: "Rozumm, e:",
  error: {
    e102: "Heslo mus obsahovat alespo 4 znaky.",
    e200: "Pro vytvoen penenky je teba do BitBoxu vloit microSD kartu, aby se mohla automaticky vytvoit zloha."
  },
  info: {
    button: "Nastavit heslo pro obnoven",
    description1: "Vlote microSD kartu do zazen BitBox",
    description2: 'Zvolte heslo pro obnoven penenky a vyberte monost "Nastavit heslo pro obnoven".',
    description3: "Zlohovn na microSD kartu a heslo pro obnoven je jedinou metodou, jak obnovit sv prostedky v ppad ztrty nebo krdee BitBoxu.",
    description4: "Heslo pro obnoven nelze pozdji zmnit bez pevodu finannch prostedk.",
    title: "Vytvoit novou penenku"
  },
  password: {
    label: "Heslo pro obnoven",
    repeatPlaceholder: "Zopakujte heslo pro obnoven"
  },
  walletName: {
    label: "Nzev penenky"
  }
};
const seedRestore$h = {
  error: {
    e200: "Obnoven penenky ze zlohy vyaduje microSD kartu."
  },
  info: {
    description1: 'Vlote microSD kartu do BitBoxu a kliknte na tlatko "Pokraovat".',
    description2: 'Vyberte zlohu a kliknte na tlatko "Obnovit".',
    description3: "Zadejte heslo pro obnoven",
    description4: "Je zapoteb potvrdit, abyste si uvdomili, e nesprvn heslo vytvo jinou penenku.",
    title: "Jak obnovit penenku ze zlohy"
  }
};
const send$j = {
  abort: "Transakce byla zruena.",
  address: {
    label: "Adresa pijemce",
    placeholder: "Zadejte adresu"
  },
  amount: {
    label: "stka",
    placeholder: "Zadejte stku"
  },
  availableBalance: "Dostupn zstatek",
  button: "Pekontrolovn",
  coincontrol: {
    address: "Adresa",
    outpoint: "Outpoint",
    title: "Odeslat z outputu"
  },
  confirm: {
    "selected-coins": "Vybran mince",
    title: "Potvrte a odelete transakci",
    total: "Celkem"
  },
  error: {
    erc20InsufficientGasFunds: "Zd se, e nemte dostatek ether na zaplacen tto ERC20 transakce. Ujistte se prosm, e mte v penence dostatek ether.",
    feeTooLow: "poplatek pli nzk",
    feesNotAvailable: "Nelze odhadnout poplatky",
    insufficientFunds: "nedostatek finannch prostedk",
    invalidAddress: "neplatn adresa",
    invalidAmount: "neplatn stka",
    invalidData: "neplatn data"
  },
  fee: {
    customPlaceholder: "Zadejte stku",
    label: "Sov poplatek",
    placeholder: "Nen dostupn"
  },
  feeTarget: {
    customLabel: "Ve poplatku",
    customLabel_eth: "Gas cena",
    description: {
      economy: "4 hodiny (24 blok)",
      economy_eth: "30 minut nebo mn",
      economy_ltc: "1 hodina (24 blok)",
      high: "20 minut (2 bloky)",
      high_eth: "30 sekund nebo mn",
      high_ltc: "5 minut (2 bloky)",
      low: "2 hodiny (12 blok)",
      low_eth: "5 minut nebo mn",
      low_ltc: "30 minut (12 blok)",
      normal: "1 hodina (6 blok)",
      normal_eth: "2 minuty nebo mn",
      normal_ltc: "15 minut (6 blok)"
    },
    estimate: "Odhadovan as potvrzen:",
    label: {
      custom: "Vlastn",
      economy: "sporn",
      high: "Vysok",
      low: "Nzk",
      normal: "Normln"
    },
    placeholder: "Vpoet poplatku"
  },
  maximum: "Poslat ve",
  maximumSelectedCoins: "Poslat vybran mince",
  noFeeTargets: "Odhady ve poplatk nejsou v souasn dob k dispozici. Zkuste to prosm pozdji nebo zadejte vlastn poplatek.",
  priority: "Priorita",
  scanQR: "Naskenujte QR kd",
  signprogress: {
    description: "Jedn se o transakci obsahujc velk mnostv dat. Chcete-li transakci pln podepsat, budete vyzvni k potvrzen {{steps}}krt.",
    label: "Prbh"
  },
  success: "Transakce byla podepsna a odeslna.",
  title: "Poslat {{accountName}}",
  toggleCoinControl: "Pepnout na coin control",
  transactionDetails: "Detaily transakce"
};
const settings$i = {
  about: "O aplikaci",
  accounts: "ty",
  advancedSettings: "Pokroil nastaven",
  appearance: "Vzhled",
  electrum: {
    add: "Pidat server",
    "add-server": "Pidat",
    check: "Kontrola",
    checkFailed: "Kontrola selhala",
    checkSuccess: "spn navzno spojen s {{host}}",
    checking: "Kontroluji",
    "download-cert": "Sthnout vzdlen certifikt",
    "remove-server": "Odstranit",
    removeConfirm: "Odstranit {{server}}?",
    reset: "Obnovit do zkladnho nastaven",
    resetConfirm: "Chcete odebrat vechny servery a nainstalovat vchoz servery?",
    servers: "Servery",
    step1: "1",
    "step1-text": "Zadejte endpoint.",
    step2: "2",
    "step2-text": "Zadejte certifikt etzce certifikt serveru. Ppadn sthnte vzdlen certifikt a vizuln jej porovnejte.",
    "step2-text-tcp": "Pokud nechcete pouvat TLS, mete tento krok peskoit.",
    step3: "3",
    "step3-text": "Zkontrolujte pipojen a pidejte server.",
    step4: "4",
    "step4-text": "Restartujte penenku. Pokud neodstrante vchoz servery, bude v vlastn uzel pidn jako nadbyten.",
    "title-btc": "Bitcoinov Electrum servery",
    "title-ltc": "Litecoin Electrum servery",
    "title-tbtc": "Bitcoin Testnet Electrum servery",
    "title-tltc": "Litecoin Testnet Electrum servery"
  },
  expert: {
    coinControl: "Aktivovat coin control",
    electrum: {
      description: "Mete se pipojit ke svmu vlastnmu Electrum uzlu (full node).",
      title: "Pipojte svj vlastn uzel (full node)"
    },
    fee: "Aktivovat vlastn poplatky",
    setProxyAddress: "Nastavit adresu proxy",
    title: "Expertn nastaven",
    useProxy: "Aktivovat tor proxy",
    useSats: "Zobrazit hodnoty BTC v satoshi"
  },
  header: {
    home: "Dom"
  },
  info: {
    "out-of-date": "K dispozici je nov aktualizace",
    title: "Info",
    "up-to-date": "Vae aplikace je aktuln",
    version: "Verze aplikace"
  },
  restart: "Restartujte BitBoxApp, aby se zmny projevily.",
  services: {
    title: "Sluby"
  },
  success: "Aby se zmny projevily, odpojte a znovu pipojte BitBox.",
  title: "Nastaven"
};
const setup$h = "Nastaven zazen";
const sidebar$i = {
  buy: "Koupit krypto",
  device: "Spravovat zazen",
  insurance: "Pojitn",
  leave: "Odejt",
  settings: "Nastaven"
};
const success$o = {
  create: {
    info1: "Vae penenka byla bezpen zlohovna na microSD kartu. Vyjmte ji a uschovejte v bezpe.",
    info2: "Vytvoili jste bezpen heslo zazen, kter odemyk BitBox.",
    info3: "Pro svou penenku jste si vytvoili bezpen heslo pro obnoven, kter odemkne vae prostedky a obnov vae zlohy.",
    summary: "Zde je shrnut toho, co jste udlali",
    title: "Hotovo"
  },
  getstarted: "Zante",
  restore: {
    summary: "spn jste obnovili penenku ze zlohy.",
    title: "Hotovo"
  }
};
const transaction$i = {
  confirmation: "Konfirmace",
  details: {
    activity: "Pehled aktivit",
    address: "Adresa",
    amount: "stka",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "stka ve fiatu",
    fiatAtTime: "Fiat v dob transakce",
    status: "Stav",
    title: "Detaily transakce",
    type: "Typ"
  },
  explorer: "ID transakce",
  explorerTitle: "Otevt v externm block exploreru",
  fee: "Poplatek",
  fiatHistorical: "Historick",
  gas: "Gas",
  note: {
    edit: "Upravit poznmku",
    save: "Uloit poznmku"
  },
  pending: "ekajc transakce",
  size: "Velikost",
  status: {
    complete: "Dokonen",
    failed: "Nespn",
    pending: "ekajc"
  },
  tx: {
    received: "Pijata na",
    sent: "Odeslna na"
  },
  vsize: "Virtuln velikost",
  weight: "Vha"
};
const transactions$h = {
  errorLoadTransactions: "Pi natn transakc dolo k chyb",
  placeholder: "Zatm dn transakce."
};
const unknownError$h = "Nastala neznm chyba: {{errorMessage}}";
const unlock$h = {
  description: "Pro odemknut zadejte heslo zazen.",
  error: {
    e109_normal: "Nesprvn heslo. Zbv jet {{remainingAttempts}} pokus, ne bude zazen resetovno.",
    e109_touch: "$t(unlock.error.e109_normal) Dal pihlen vyaduje podren dotykovho tlatka.",
    e113: "Vzhledem k mnoha pokusm o pihlen vyaduje dal pihlen podren dotykovho tlatka po dobu 4 sekund."
  },
  input: {
    label: "Heslo zazen",
    placeholder: "Zadejte heslo zazen pro odemknut"
  },
  unlocking: "Odemykn..."
};
const upgradeFirmware$i = {
  button: "Aktualizovat firmware",
  description: "Chcete aktualizovat firmware z {{currentVersion}} verze na {{newVersion}}?",
  label: "V BitBox vyaduje upgrade firmwaru.",
  locked: "Chcete-li provst upgrade z {{currentVersion}} na {{newVersion}}, provete dlouh dotyk.",
  title: "Upgradovat firmware",
  unlocked: "Bootloader je odemen. Chcete-li pokraovat, prosm:",
  unlocked1: "Odpojte a znovu zapojte v Bitbox",
  unlocked2: "Po optovnm zapojen vaeho BitBoxu se rozsvt LED dioda.",
  unlocked3: "Kdy se rozsvt LED dioda, klepnte na dotykov tlatko"
};
const walletConnect$c = {
  connect: {
    button: "Pipojit",
    dappLabel: "Zadejte URI adresu dapp",
    invalidPairingUri: "Neplatn provn uri"
  },
  dashboard: {
    allSessions: "Vechny relace",
    disclaimer: "Walletconnect je protokol pro pipojen k Dapps zaloenm na Ethereu. Tyto dapps jsou provozovny slubami tetch stran, take se pipojujte pouze k dapps, kterm dvujete, a vdy se ujistte, e vte, co podepisujete pi provdn transakce.",
    newConnection: "Nov pipojen",
    noConnectedSessions: "V tto chvli nejsou k dapps pipojeny dn ty."
  },
  invalidPairingChain: "Chyba pi schvalovn provn. Ujistte se, e pouvte jednu z podporovanch st: {{chains}}",
  pairingRequest: {
    approve: "Schvlit pipojen",
    reject: "Odmtnout",
    title: "Nov poadavek na pipojen od"
  },
  pairingSuccess: "Dapp se spn pipojil. Pokraovat mete na dapp webu",
  signingRequest: {
    account: "et",
    chain: "S",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Nepodailo se zpracovat data",
    decodeError: "Zprvu se nepodailo dekdova",
    method: {
      sendTransaction: "Podepite a odelete transakci",
      signMessage: "Podepsat zprvu",
      signTransaction: "Podepsat transakci",
      signTypedData: "Podepite zadan data"
    },
    successfullySigned: "dost byla spn podepsna",
    walletConnectRequest: "dost o pipojen k WalletConnect"
  },
  useNewUri: "Tento URI ji byl pouit k pokusu o pipojen. Pouijte prosm nov URI.",
  walletConnect: "WalletConnect"
};
const warning$n = {
  receivePairing: 'Sprujte BitBox, abyste mohli bezpen ovit adresu. Pejdte na "Spravovat zazen" v postrannm panelu.',
  sdcard: "MicroSD kartu mjte uloenou oddlen od BitBoxu, pokud ovem nechcete spravovat zlohy.",
  sendPairing: 'Sprujte prosm BitBox a bezpen ovte daje o transakci. Pejdte na "Spravovat zazen" v postrannm panelu.'
};
const welcome$h = {
  connect: "Pipojte BitBox02",
  getStarted: "Zanme instalac firmwaru na v BitBox02.",
  insertBitBox02: "Pro BitBox02 klepnte na zazen a pokraujte.",
  insertDevice: "Pipojte sv zazen a zante",
  title: "Vtejte"
};
const appTranslationsCS = {
  account: account$h,
  accountInfo: accountInfo$h,
  accountSummary: accountSummary$h,
  addAccount: addAccount$i,
  aopp: aopp$b,
  app: app$h,
  auth: auth$b,
  backup: backup$h,
  bb02Bootloader: bb02Bootloader$h,
  bitbox: bitbox$h,
  bitbox02Interact: bitbox02Interact$h,
  bitbox02Settings: bitbox02Settings$h,
  bitbox02Wizard: bitbox02Wizard$h,
  bitsurance: bitsurance$a,
  bitsuranceAccount: bitsuranceAccount$a,
  blink: blink$h,
  bootloader: bootloader$h,
  button: button$m,
  buy: buy$d,
  changePin: changePin$h,
  chart: chart$d,
  checkSDcard: checkSDcard$h,
  clickHere: clickHere$h,
  confirm: confirm$j,
  confirmOnDevice: confirmOnDevice$h,
  connectKeystore: connectKeystore$b,
  darkmode: darkmode$b,
  device: device$h,
  deviceLock: deviceLock$h,
  deviceSettings: deviceSettings$h,
  deviceTampered: deviceTampered$h,
  dialog: dialog$i,
  error: error$d,
  fiat: fiat$j,
  footer: footer$j,
  generic: generic$d,
  genericError: genericError$h,
  goal: goal$h,
  guide: guide$i,
  headerssync: headerssync$h,
  hiddenWallet: hiddenWallet$h,
  initialize: initialize$h,
  invalidFormat: invalidFormat$h,
  language: language$i,
  legacyhiddenwallet: legacyhiddenwallet$h,
  loading: loading$h,
  manageAccounts: manageAccounts$b,
  mobile: mobile$c,
  newSettings: newSettings$a,
  note: note$d,
  notification: notification$h,
  pairing: pairing$h,
  passphrase: passphrase$b,
  password: password$h,
  random: random$i,
  receive: receive$j,
  reset: reset$h,
  securityInformation: securityInformation$h,
  seed: seed$h,
  seedRestore: seedRestore$h,
  send: send$j,
  settings: settings$i,
  setup: setup$h,
  sidebar: sidebar$i,
  success: success$o,
  transaction: transaction$i,
  transactions: transactions$h,
  unknownError: unknownError$h,
  unlock: unlock$h,
  upgradeFirmware: upgradeFirmware$i,
  walletConnect: walletConnect$c,
  warning: warning$n,
  welcome: welcome$h
};
const account$g = {
  disconnect: "Verbindung unterbrochen. Erneut verbinden... ",
  "export": "Export",
  exportTransactions: "Exportiere Transaktionen im Download Ordner als CSV Datei",
  fatalError: "Ein unerwarteter Fehler ist aufgetreten.",
  incoming: "Eingehend",
  initializing: "Informationen werden von der Blockchain geladen",
  insuranceExpired: "<strong>Konto nicht mehr versichert</strong>\n\nDer Versicherungsplan fr dieses Konto wurde gendert.\nBitte sehe dir die Versicherungsseite fr Details an.",
  insured: "Versichertes Konto",
  maybeProxyError: "Tor-Proxy aktiviert. Stelle sicher, dass Tor-Proxy ordnungsgem ausgefhrt wird, oder deaktiviere die Proxy-Einstellung.",
  reconnecting: "Verbindung abgebrochen, neue Verbindung wird aufgebaut",
  syncedAddressesCount: "{{count}} Adressen gescannt",
  uncoveredFunds: "Du hast Coins auf den folgenden nicht abgesicherten Adresstypen von deinem <strong>{{name}}</strong> Konto: {{uncovered}}.\nDa das Konto versichert ist, sind nur Coins welche via den <strong>Native Segwit</strong> Adresstyp empfangen werden abgesichert. Coins auf anderen Adresstypen, auch wenn sie sich auf demselben Konto befinden, sind nicht versichert.\nBitte verschiebe alle deine Coins von den nicht untersttzten Adresstypen auf den <strong>Native Segwit</strong> Adresstyp, damit alle deine Coins auf diesem Konto versichert sind.",
  uncoveredFundsLink: "Folge dieser Anleitung fr das Verschieben deiner Coins.",
  warning: "Warnung!"
};
const accountInfo$g = {
  address: "Adresse",
  buyCTA: {
    buy: "{{unit}} kaufen",
    buyCrypto: "Krypto kaufen",
    information: {
      looksEmpty: "Sieht so aus, als wre dieses Wallet leer.",
      start: "Lege los, indem du einige Coins auf das Wallet einzahlst oder direkt in der BitBoxApp kaufst."
    }
  },
  extendedPublicKey: "Erweiterter Public Key",
  label: "Konto Informationen",
  scriptType: "Script-Typ",
  title: "Konto Informationen",
  verify: "Auf Gert besttigen",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy-P2PKH erweiterten Public Key anzeigen",
    p2tr: "Taproot anzeigen",
    p2wpkh: "Native Segwit anzeigen",
    "p2wpkh-p2sh": "lteren Segwit erweiterten ffentlichen Schlssel anzeigen"
  },
  xpubTypeInfo: "Derzeit wird der {{scriptType}} erweiterte Public Key angezeigt ({{current}} von {{numberOfXPubs}})"
};
const accountSummary$g = {
  availableBalance: "Kontostand",
  balance: "Saldo",
  exportSummary: "Kontozusammenfassung als CSV Datei zum Download Ordner exportieren",
  fiatBalance: "Fiat Kontostand",
  name: "Konto Name",
  noAccount: "Keine Konten verfgbar",
  subtotalWithCoinName: "Summe ({{coinName}})",
  title: "Kontenbersicht",
  total: "Gesamt",
  transactionHistory: "Transaktionsbersicht"
};
const addAccount$h = {
  chooseName: {
    nextButton: "Konto hinzufgen",
    step: "Konto benennen",
    title: "Benenne dein Konto"
  },
  selectCoin: {
    nextButton: "Weiter",
    step: "Coin whlen",
    title: "Kryptowhrung whlen"
  },
  success: {
    addAnotherAccount: "Neues Konto hinzufgen",
    message: "<strong>{{accountName}}</strong> wurde zu deinen Konten hinzugefgt.",
    nextButton: "Fertig",
    step: "Erledigt",
    title: "Konto hinzugefgt"
  },
  title: "Konto hinzufgen"
};
const aopp$a = {
  addressRequest: "{{host}} fordert eine Empfangsadresse an.",
  addressRequestWithLogo: "fordert eine Empfangsadresse an",
  banner: "Adressanfrage in Bearbeitung. Bitte verbinde dein Gert um fortzufahren.",
  errorTitle: "Fehler whrend Adressanfrage",
  labelAddress: "Adresse",
  labelMessage: "Nachricht",
  reverifyInfoText: "Adresse berprfen",
  signing: "Signiere die Nachricht auf deiner BitBox um fortzufahren",
  success: {
    message: "Weiter auf {{host}}",
    title: "Adresse erfolgreich bermittelt"
  },
  syncing: "Konto wird synchronisiert, bitte warten.",
  title: "Adressanfrage"
};
const app$g = {
  upgrade: "Eine neue Version der App ist verfgbar! Bitte aktualisiere von {{current}} auf {{version}}."
};
const auth$a = {
  authButton: "Authentifizieren",
  title: "Bitte authentifiziere dich, um fortzufahren"
};
const backup$g = {
  check: {
    checking: "Backup wird geprft",
    confirmTitle: "Backup berprfen",
    notOK: "Dein Backup entspricht NICHT deiner aktuellen Wallet.",
    ok: "Erfolg! Dein Backup entspricht deiner aktuellen Wallet.",
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Wiederherstellungspasswort",
      showLabel: "Wiederherstellungspasswort"
    },
    success: "Backup erfolgreich berprft:",
    title: "Backup berprfen"
  },
  create: {
    alreadyExists: "Du hast schon ein gltiges Backup. Willst du trotzdem ein weiteres Backup erstellen?",
    fail: "Erstellung des Backups FEHLGESCHLAGEN!",
    info: "Bitte gib dein Wiederherstellungspasswort ein, um deine aktuelle Wallet zu verifizieren.",
    name: {
      label: "Backup Name",
      placeholder: "Bitte benenne dein Backup."
    },
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Bitte gib dein Wiederherstellungspasswort ein."
    },
    title: "Backup erstellen",
    verificationFailed: "Das Wiederherstellungspasswort entspricht NICHT der aktuellen Wallet. Das Backup wurde erstellt. Bitte nutze Backup prfen um dein Wiederherstellungspasswort erneut zu berprfen. "
  },
  description: "Whle eine  <strong>Wallet Backup</strong> Datei aus.",
  insert: "Bitte stecke die Micro-SD-Karte ein um deine Backups zu verwalten.",
  insertButton: "Ich habe die Mikro-SD-Karte eingesteckt.",
  list: "Deine Backups auf der microSD Karte",
  noBackups: "Es befinden sich keine Backups auf der microSD Karte.",
  restore: {
    confirmTitle: "Von Backup wiederherstellen",
    error: {
      e200: "microSD Karte nicht gefunden",
      general: "Fehler beim Wiederherstellen von Backup"
    },
    password: {
      label: "Wiederherstellungspasswort oder verstecktes Wiederherstellungspasswort. ",
      placeholder: "Wiederherstellungspasswort",
      repeatPlaceholder: "Wiederherstellungspasswort erneut eingeben",
      showLabel: "Wiederherstellungspasswort"
    },
    restoring: "Wiederherstellen des Backups",
    selectedBackup: "<strong>{{backupName}}</strong>, erstellt am {{createdDateTime}}, wird wiederhergestellt.",
    title: "Wiederherstellen",
    understand: "Ich habe verstanden, dass ein falsches Wiederherstellungspasswort eine neue/andere Wallet erstellt."
  },
  showMnemonic: {
    description: "Dir werden Wiederherstellungswrter angezeigt, die ein Backup deiner Wallet sind. Schreibe diese auf ein Stck Papier. \n\n<strong>Bewahre diese Wrter nicht digital auf und mache kein Foto von ihnen.</strong>\n\n<strong>Sprich die Wrter nicht laut aus.</strong>\n\n<strong>Dieses Backup ist nicht Passwort geschtzt.</strong>\n\nNachdem du die Wrter aufgeschrieben hast wirst du gefragt werden sie nochmals zu besttigen.\n",
    title: "Recovery-Wrter anzeigen",
    warning: "<strong>Teile deine Wiederherstellungswrter niemals mit irgendjemandem.</strong> Deine Wiederherstellungswrter ermglichen vollen Zugriff zu deinem Wallet . Wenn dich jemand nach deinen Wiederherstellungswrtern fragt, handelt es sich um einen Betrger. Gebe diese nicht weiter!"
  },
  title: "Backups verwalten"
};
const bb02Bootloader$g = {
  abort: "Nicht upgraden - Zurck!",
  abort_noUpgrade: "Zurck",
  advanced: {
    label: "Erweiterte Einstellungen",
    toggleShowFirmwareHash: "Zeig mir den Hash der Firmware bei jedem Anstecken der BitBox"
  },
  flipscreen: "Bildschirm spiegeln",
  orientation: "Ist der Bildschirm kopfber?",
  success: "Upgrade erfolgreich. In {{rebootSeconds}}  geht es weiter....",
  success_install: "Installation erfolgreich! Es geht weiter in {{rebootSeconds}} Sekunden..."
};
const bitbox$g = {
  error: {
    e10000: "Aktuelles Gertepasswort ist falsch.",
    e10001: "Fehler beim ndern des Gertepassworts",
    e102: "Das Passwort muss aus 4 Zeichen bestehen.",
    e112: "Das versteckte Gertepasswort und das normale Gertepasswort knnen nicht identisch sein."
  }
};
const bitbox02Interact$g = {
  confirmDate: "Besttige das heutige Datum auf deiner BitBox02",
  confirmDateText: "Dieses Datum wird mit deinem Backup gespeichert. ",
  confirmName: "Besttige den Namen auf deiner BitBox02",
  confirmWords: "Notiere die {{amount}} Wiederherstellungswrter von deiner BitBox02",
  confirmWordsText: "Danach fordert dich die BitBox02 auf, jedes Wort zu besttigen, um zu berprfen, ob dein Backup korrekt ist.",
  followInstructions: "Bitte folge den Anweisungen auf deiner BitBox02.",
  followInstructionsMnemonic: "Bitte folge den Anweisungen auf deiner BitBox02 um deine Wallet mit deinen Wiederherstellungswrtern wieder herzustellen.",
  followInstructionsMnemonicTitle: "Mit Wiederherstellungs-Wrtern wiederherstellen"
};
const bitbox02Settings$g = {
  deviceName: {
    current: "Aktueller Gertename",
    error: "Gertename konnte nicht festgelegt werden",
    error_104: "Die Besttigung des Gertenamens wurde auf dem Gert abgebrochen.",
    input: "BitBox02 Name",
    placeholder: "Neuer Gertename",
    title: "BitBox02 Namen einstellen"
  },
  gotoStartupSettings: {
    description: "Dadurch wird deine BitBox02 neu gestartet und die Starteinstellungen angezeigt.",
    title: "Gehe zu den Starteinstellungen"
  }
};
const bitbox02Wizard$g = {
  advanced: {
    button: "Erweiterte Optionen",
    outOfDate: "Die Firmware ist fr diese Funktion zu veraltet",
    seed12WordInfo: "Bitte beachte, dass die Anzahl der Wrter nach dem Erstellen des Wallets nicht mehr gendert werden kann.",
    seed12WordLabel: "Erstelle einen Seed mit 12 Wrtern statt mit 24 Wrtern",
    seed12WordText: "Standardmig verwendet die BitBox02 einen 24-Wrter-Seed. Beide Seed-Lngen sind in der Praxis sicher gegen Brute-Forcing. Einige Benutzer bevorzugen mglicherweise die Bequemlichkeit eines 12-Wrter-Seeds.",
    skipSDCardLabel: "berspringe die Sicherung auf der MicroSD-Karte und notiere stattdessen die Wiederherstellungswrter",
    skipSDCardText: "Du hast jederzeit die Mglichkeit, nach der Einrichtung ein Backup auf der MicroSD-Karte zu erstellen und deine Wiederherstellungswrter aufzuschreiben. Dies kannst ber die Einstellungen tun.",
    title: "Erweiterte Backup-Optionen"
  },
  attestationFailed: "Echtheitsprfung fehlgeschlagen. Bitte stecke die BitBox aus und wieder ein.  Bitte kontaktiere support@bitbox.swiss, falls dieses Problem weiterhin besteht.",
  backup: {
    point1: "Whle ein Backup von der microSD Karte aus",
    point2: "Setze ein Passwort fr dein Gert",
    restoreText: "Ok, lass uns deine Wallet von deinem Backup wiederherstellen!",
    text1: "Perfekt, dein BitBox02 Passwort ist jetzt festgelegt und deine Wallet wurde erstellt. Jetzt ist es Zeit ein Backup der Wallet zu erstellen. Bitte stelle dazu sicher, dass die microSD Karte eingesteckt ist. ",
    text2: 'Sobald du "Backup erstellen" geklickt hast folge bitte den Anweisungen auf deiner BitBox um ein Backup zu erstellen. ',
    text3: "Nachdem das Backup erstellt wurde, bewahre die microSD-Karte bitte an einem <strong>sicheren Ort auf und stecke die microSD-Karte niemals in ein anderes Gert, das nicht eine BitBox ist. </strong> Das Backup auf der microSD-Karte ist nicht Passwort-geschtzt!",
    userConfirmation1: "Ich muss mein Backup an einem sicheren Ort aufbewahren.",
    userConfirmation2: "Mein Backup ist nicht passwortgeschtzt. Jeder, der Zugriff darauf hat, kann auf meine Wallet zugreifen.",
    userConfirmation3: "Wenn ich meine BitBox02 verliere oder beschdige, ist die Wiederherstellung von meinem Backup der einzige Weg wieder Zugriff auf mein Guthaben zu bekommen. ",
    userConfirmation4: "Sollte ich sowohl meine BitBox02 als auch mein Backup verlieren oder zerstren ist der Zugang zu meinen Coins fr immer verloren. ",
    userConfirmation5: "Ich darf meine microSD Karte nicht in einen Computer, Handy, Drucker oder anderes (nicht BitBox02) Gert stecken. ",
    userConfirmation5mnemonic: "Ich sollte meine Wiederherstellungswrter nicht in einen Computer, ein Telefon, einen Drucker oder irgendein anderes Gert als eine BitBox02 stecken."
  },
  create: {
    button: "Gert bennenen & weiter",
    info: "Hier sind die Schritte, die wir dazu durchlaufen werden:",
    inputTitle: "Wallet Name ",
    point1: "Gert benennen",
    point2: "Gertepasswort einstellen",
    point3: "Backup erstellen",
    text: "Ok, lass uns eine neue Wallet erstellen!"
  },
  createBackupAborted: "Backup-Erstellung abgebrochen.",
  createBackupFailed: "Erstellung des Backups fehlgeschlagen, erneut versuchen.",
  initialize: {
    passwordText: "Lass uns nun ein Passwort fr deine BitBox festlegen. Schaue dir die Animation unten an und benutze dann die Touch Slider auf den Seiten deiner BitBox, um ein Passwort einzugeben. ",
    passwordTitle: "Setze ein Passwort fr deine BitBox",
    text: "BitBox02 erfolgreich gekoppelt. Jetzt initialisieren wir deine BitBox02. Whle zuerst aus, ob du eine neue Wallet erstellen oder von einem Backup wieder herstellen mchtest.  <strong>Wenn du von einem Backup wieder herstellen mchtest, stelle sicher, dass deine microSD Karte in deiner BitBox02 eingesteckt ist.</strong>",
    tip: "Bitte fahre in einer sichern Umgebung fort. ",
    title: "Initialisiere deine BitBox"
  },
  insertSDCard: "<strong>Bitte stelle sicher, dass du die microSD Karte in der BitBox02 eingesteckt hast.</strong>",
  noPasswordMatch: "Passwrter stimmen nicht berein. Bitte versuche es erneut.",
  pairing: {
    failed: "Kopplungscode nicht besttigt. Bitte BitBox02 aus und wieder ein stecken.",
    paired: "Kopplungscode besttigt. Bitte fahre fort.",
    title: "Kopplungscode besttigen",
    unpaired: "Eine nicht gekoppelte BitBox02 wurde erkannt. Bitte besttige, dass der Kopplungscode mit dem auf der BitBox02 bereinstimmt. "
  },
  restoreFromMnemonic: {
    e104: "Die Wiederherstellung durch Wiederherstellungswrter wurde abgebrochen.",
    failed: "Wiederherstellung von Wiederherstellungswrtern fehlgeschlagen. Bitte versuche es erneut."
  },
  stepBackup: {
    beforeProceed: "Bevor du fortfhrst, lies bitte die folgenden wichtigen Sicherheitsaspekte:",
    createBackup: "Du erstellst jetzt ein Backup auf deiner microSD-Karte.",
    createBackupMnemonic: "Du wirst nun die Wiederherstellungswrter notieren."
  },
  stepBackupSuccess: {
    fundsSafe: "Beachte bitte Folgendes, um deine Coins zu schtzen:",
    title: "Backup wiederhergestellt!"
  },
  stepConnected: {
    unlock: "BitBox02 Passwort eingeben "
  },
  stepCreate: {
    description: "Dieser Name wird als Gertename und fr das Backup verwendet.",
    error: {
      genericMessage: "Verwende Buchstaben, Zahlen, einfache Symbole und Leerzeichen. Max. 30 Zeichen.",
      invalidChars: "Der Name enthlt ungltige Zeichen: {{invalidChars}}.",
      tooLong: "Name ist zu lang."
    },
    nameLabel: "BitBox02 Name",
    namePlaceholder: "Meine BitBox02",
    title: "Whle BitBox02 Name",
    toastMicroSD: "Bitte stelle sicher, dass deine microSD Karte in die BitBox02 eingesteckt ist. "
  },
  stepCreateSuccess: {
    removeMicroSD: "Bitte entnehme deine microSD Karte und bewahre diese an einem sicheren Ort auf.",
    storeMnemonic: "Bitte bewahre deine Wiederherstellungs-Wrter an einem sicheren Ort auf.",
    success: "Dein Backup wurde erfolgreich erstellt."
  },
  stepInsertSD: {
    insertSDCard: "Bitte stecke die microSD Karte in deine BitBox02 um fortzufahren",
    insertSDcardTitle: "MicroSD Karte einstecken"
  },
  stepPassword: {
    e104: "Das Festlegen des Passworts wurde abgebrochen.",
    title: "BitBox02 Passwort whlen",
    useControls: "Verwende die Touch Sensoren an den Seiten deiner BitBox02 um ein Passwort zu whlen."
  },
  stepUninitialized: {
    create: "Ich mchte eine neue BitBox02 einrichten.",
    restore: "Ich mchte meine Wallet von einem Backup wiederherstellen.",
    restoreMicroSD: "Von microSD Karte wiederherstellen",
    restoreMnemonic: "Von Wiederherstellungswrtern wiederherstellen",
    title: "BitBox02 einrichten"
  },
  success: {
    text: "Hurra! Deine BitBox02 ist bereit.\n\nFr weitere Informationen klicke auf das Fragezeichen Symbol in der oberen rechten Ecke. ",
    title: "Es kann los gehen!"
  }
};
const bitsurance$9 = {
  dashboard: {
    active: "Versicherungsvertrag aktiv",
    button: "Versichere ein neues Konto",
    canceled: "Abgebrochen",
    coverage: "Maximale Abdeckung",
    inactive: "Inaktiv",
    processing: "In Bearbeitung",
    refused: "Abgelehnt",
    supportLink: "Vertrag verwalten",
    title: "Versicherte Konten",
    waitpayment: "Warte auf Zahlung"
  },
  detect: {
    button: "Prfe auf bestehende Versicherungen",
    insured: "Versichertes Konto entdeckt:",
    notInsured: "Keine versicherten Konten gefunden. Wenn du sicher bist, dass du ein versichertes Konto hast, vergewissere dich bitte, dass du die richtige Wallet verbunden hast.",
    text: "Wenn du bereits bei Bitsurance angemeldet bist, kann die BitBoxApp deinen bestehenden Versicherungsschutz automatisch synchronisieren.",
    title: "Bereits versichert?"
  },
  insure: {
    button: "Verfgbarkeit und Preis prfen",
    faq: "Lese mehr in den Bitsurance FAQs",
    listItem1: "Diebstahl",
    listItem2: 'Erpressung (bspw. "$5 wrench attack")',
    listItem3: "Zerstrung durch Feuer, Wasser oder Naturkatastrophen",
    month: "Monat",
    text: "Versichere deine BitBox02 und Bitcoin im Wert von bis zu 100.000  gegen",
    text2: "Versicherungs-Plne beginnen ab 30 /Jahr (2,50 /Monat). Mehr ber Bitsurance und ihre genauen Versicherungsangebote erfhrst du auf der",
    text3: "Derzeit in Deutschland verfgbar, weitere Regionen werden folgen.",
    title: "Los geht's"
  },
  intro: {
    link: "Bitsurance Website",
    text1: "Die BitBox arbeitet mit Bitsurance zusammen, um deinen Bitcoin zustzlich zu schtzen. Whrend die BitBox02 dein Guthaben schtzt, deckt Bitsurance Bedrohungen zu Hause ab, die mit Technologie alleine nicht abgewehrt werden knnen, wie z.B. Einbruch, Erpressung oder die Zerstrung der Hardware-Wallet selbst."
  },
  terms: {
    link: "Bitsurance Datenschutzrichtlinie",
    text1: "Bitsurance ist ein unabhngiger Service von Dritten. Bei Fragen zu ihren Angeboten und Versicherungsansprchen wende dich bitte direkt an Bitsurance.",
    text2: "Versicherung ist derzeit in Deutschland verfgbar, weitere Regionen werden folgen.",
    text3: "Die maximale Bitcoin-Absicherung liegt derzeit bei 100.000  pro Person. Fr die Zukunft sind hhere Betrge geplant.",
    text4: "Persnliche Informationen und der erweiterte ffentliche Schlssel deines versicherten Kontos sind Teil der Versicherungspolice und werden mit Bitsurance und dem Versicherungsanbieter geteilt.",
    text5: "Weitere Informationen zum Datenschutz findest du in der"
  },
  title: "Versicherung"
};
const bitsuranceAccount$9 = {
  errorNoXpub: "Fehler: Es war nicht mglich, den xpub vom Konto zu erhalten.",
  noAccount: "Es gibt keine Konten, die versichert werden knnen.",
  select: "Konto whlen",
  title: "Versicherung"
};
const blink$g = {
  button: "Blinken"
};
const bootloader$g = {
  button: "Firmware jetzt aktualisieren",
  button_install: "Firmware jetzt installieren",
  progress: "Aktualisiere: {{progress}}%",
  progress_install: "Installation: {{progress}}%",
  success: "Aktualisierung erfolgreich! Bitte ziehe das Gert ab und stecke es dann wieder ein. Dieses mal brauchst du den Knopf nicht zu berhren. "
};
const button$l = {
  abort: "Abbrechen",
  back: "Zurck",
  buy: "Kaufen",
  changepin: "Gertepasswort ndern",
  check: "Backup berprfen",
  "continue": "Weiter",
  copy: "Kopieren",
  create: "Erstellen",
  dismiss: "Ausblenden",
  done: "Fertig",
  download: "Herunterladen",
  hiddenwallet: "Versteckte Wallet erstellen",
  next: "Weiter",
  ok: "OK",
  previous: "Zurck",
  receive: "Erhalten",
  restore: "Wiederherstellen",
  select: "Auswhlen",
  send: "Senden",
  unlock: "Entsperren",
  update: "Update",
  upgrade: "Aktualisieren"
};
const buy$c = {
  exchange: {
    bankTransfer: "berweisung",
    bestDeal: "Bestes Angebot",
    creditCard: "Kreditkarte",
    fast: "Schnell",
    fee: "Gebhr",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankberweisung: {{fee}}%",
          creditDebitCard: "Kredit-/Debitkarte: {{fee}}%",
          learnMore: "Erfahre mehr ber Moonpay",
          title: "Gebhren"
        },
        fullCurrenciesList: "Eine vollstndige Liste der Whrungen findest du hier",
        payment: {
          asteriskText: "* Nicht verfgbar fr Einwohner der USA",
          bankTransfer: "Bankberweisung*",
          bankTransferDetails: {
            pix: "PIX (BR-Transaktionen nur in Brasilien)",
            sepa: "SEPA und SEPA Instant (EUR-Transaktionen nur in SEPA-Lndern)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Grobritannien)"
          },
          creditDebitCard: "Kredit-/Debitkarte",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa und Maestro"
          },
          learnMore: "Weitere Details zu den Zahlungsmethoden findest du hier",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Untersttzt alle gngigen Fiat-Whrungen: USD, EUR, CHF und mehr."
      },
      pocket: {
        fees: {
          info: "Bankberweisung: {{fee}}%",
          title: "Gebhren"
        },
        learnMore: "Erfahre mehr ber Pocket",
        payment: {
          bankTransfer: "Bankberweisung",
          bankTransferDetails: {
            sepa: "SEPA und SEPA Echtzeit (EUR-Transaktionen nur in SEPA-Lndern)",
            sic: "Swiss Interbank Clearing (CHF-Transaktionen nur in CH/LI)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Grobritannien)"
          },
          bankTransferReccuring: "Wie richte ich wiederkehrende Kufe mit einem Dauerauftrag ein?",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Untersttzt europische Whrungen: EUR, GBP und CHF.",
        verification: {
          info: "Identittsprfung nur bei berschreitung der tglichen und jhrlichen Schwellenwerte ntig.",
          link: "Aktuelle Schwellenwerte hier einsehen",
          title: "Identittsprfung"
        }
      },
      region: {
        title: "Whle die Region aus, in der dein Bankkonto registriert ist, um zu sehen, welche Optionen dir zur Verfgung stehen."
      }
    },
    noExchanges: "Leider sind in dieser Region keine Brsen verfgbar.",
    region: "Region",
    selectRegion: "Nicht angegeben",
    title: "{{name}} kaufen "
  },
  info: {
    "continue": "Zustimmen und fortfahren",
    crypto: "Krypto",
    disclaimer: {
      intro: [
        "Wir arbeiten mit MoonPay zusammen, damit du mit nur ein paar Klicks ganz einfach {{name}} direkt in der BitBoxApp kaufen kannst. ",
        "MoonPay ist eine vollstndig regulierte Finanzdienstleistungsplattform, die den Kauf von {{name}} in ber 160 Lndern einfach und schnell macht."
      ],
      payment: {
        details: "Du kannst {{name}} ber MoonPay mit den folgenden Zahlungsmethoden kaufen. Mit Kredit- oder Debitkarten geht es sofort und bequem, ist aber aufgrund des erhhten Rckbuchungsrisikos teurer. Wir empfehlen die Verwendung der berweisungsoption fr grere Betrge. Die Mindestgebhr betrgt 4 USD / EUR oder gleichwertig.",
        footnote: "Bitte beachte, dass die Wechselkurse von MoonPay von den in der BitBoxApp verwendeten abweichen knnen, was zu geringfgig unterschiedlichen Betrgen fhren kann.",
        table: {
          "1_description": "Niedrigste Gebhren, kann bis zu 3 Werktage dauern",
          "1_method": "Bankberweisungen (SEPA)",
          "2_description": "Hhere Gebhren, aber schnell und sofort",
          "2_method": "Kredit & Debitkarten",
          description: "Beschreibung",
          fee: "Gebhr",
          method: "Methode"
        },
        title: "Zahlungsmethoden und Gebhren"
      },
      privacyPolicy: "MoonPay-Datenschutzrichtlinie",
      protection: {
        description: "Die BitBoxApp sammelt beim Kauf von {{name}} keine Daten. Die eingehenden Transaktionen werden wie regulre Transaktion behandelt. MoonPay muss einige persnliche Daten sammeln, um funktionieren zu knnen. In deren Datenschutzbestimmungen wird ausfhrlich erlutert, wie mit diesen Daten umgegangen wird.",
        descriptionGeneric: "Die BitBoxApp erhebt beim Kauf von {{name}} keinerlei Daten, die eingehenden Gelder werden wie eine normale Transaktion behandelt. Partnerbrsen mssen jedoch einige Informationen sammeln, um zu funktionieren. Einzelheiten zum Umgang mit Daten kannst du der jeweiligen Datenschutzerklrung entnehmen.",
        title: "Datenschutz"
      },
      security: {
        description: "Wenn du {{name}} ber MoonPay kaufst, dann nutzt du einen externen Dienst. Dieser Dienst liegt auerhalb des Anwendungsbereichs des BitBox02 Sicherheitsbedrohungsmodells und verlsst sich auf die Sicherheit des Gerts, auf dem die BitBoxApp Software luft.",
        descriptionGeneric: "Wenn du {{name}} ber eine Partnerbrse kaufst, nutzt du einen externen Dienst. Dieser Dienst liegt auerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hngt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgefhrt wird.",
        link: "Sicherheitsbedrohungsmodells",
        title: "Sicherheitsmodell"
      },
      title: "Willkommen in deinem One-Stop-Shop zum Kauf von {{name}}"
    },
    next: "Weiter",
    selectLabel: "Konto whlen",
    selectPlaceholder: "Whle einen Coin",
    skip: "Nicht mehr anzeigen",
    title: "{{name}} kaufen "
  },
  pocket: {
    data: {
      link: "Pocket-Datenschutzrichtlinie",
      p1: "Die BitBoxApp sammelt beim Kauf von Bitcoin keine Daten. Die eingehenden Gelder werden wie eine regulre Transaktion behandelt. Pocket muss einige personenbezogene Daten sammeln, um zu agieren. Ihre Datenschutzrichtlinie erklrt im Detail, wie diese Daten verwendet werden.",
      title: "Datenschutz"
    },
    kyc: {
      link: "Pocket-FAQ lesen",
      p1: "Pocket versucht, KYC auf ein Minimum zu beschrnken. Fr Einkufe unter 950 EUR (1000 CHF) pro Tag sind keine zustzlichen Dokumente erforderlich. Fr Kufe ber diesem Betrag musst du einen Anruf bei Pocket vereinbaren, um den erforderlichen KYC/AML-Prozess abzuschlieen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Du kannst Bitcoin sofort mit Pocket per SEPA-berweisung kaufen. Die Gebhr betrgt 1,5 % und die Bitcoin werden so schnell wie mglich nach Eingang der Bankberweisung bei Pocket (normalerweise am selben Tag) auf deiner BitBox hinterlegt.",
      p2: "Bitte beachte, dass die Wechselkurse von Pocket von denen in der BitBoxApp abweichen knnen, was zu leicht unterschiedlichen Betrgen fhren kann.",
      title: "Zahlungsmethoden und Gebhren"
    },
    previousTransactions: "Der Transaktionsverlauf dieses Kontos ist nicht leer. Durch die gemeinsame Nutzung dieses Kontos werden alle vergangenen und zuknftigen Transaktionen fr Pocket sichtbar. Dennoch fortfahren?",
    security: {
      link: "BitBox02 Bedrohungsmodell",
      p1: "Wenn du Bitcoin ber Pocket kaufst, verwendest du einen externen Dienst. Dieser Dienst liegt auerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hngt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgefhrt wird. Wir arbeiten jedoch zusammen, um die Sicherheit zu verbessern, indem wir einen Zwei-Faktor-Authentifizierungsmechanismus verwenden, um deine Empfangs-Adresse zu berprfen.",
      title: "Sicherheitsmodell"
    },
    usedAddress: "Die Adresse {{address}} wurde bereits verwendet. Bitte beginne erneut mit einer neuen Adresse.",
    verifyBitBox02: "Bitte vergewissere dich, dass die Adresse, die du per E-Mail erhalten hast, mit der auf deiner Bitbox angezeigten bereinstimmt. Wenn mglich, solltest du die E-Mail zur besseren Sicherheit auf einem zweiten Gert ffnen.",
    welcome: {
      p1: "Wir arbeiten mit Pocket zusammen, um dir eine nahtlose Mglichkeit zu bieten, Bitcoins direkt in der BitBoxApp zu kaufen. Es sind nur ein paar Klicks.",
      p2: "Pocket ist eine schweizer Plattform, mit der man fast in ganz Europa schnell und einfach Bitcoin kaufen kann (berall dort, wo SEPA-Bankberweisungen untersttzt werden).",
      p3: "Mit Pocket kannst du auch Sparplne ber Dauerauftrge betreiben, sodass du mit Leichtigkeit DCA (Dollar-Cost-Average) durchfhren kannst.",
      title: "Willkommen in deinem One-Stop-Shop fr den Kauf von Bitcoin"
    }
  },
  title: "{{name}} kaufen"
};
const changePin$g = {
  newTitle: "Neues Gertepasswort",
  oldLabel: "Aktuelles Gertepasswort"
};
const chart$c = {
  dataMissing: "Historische Daten werden gesammelt... gleich fertig.",
  dataOldTimestamp: "Historische Wechselkurse werden aktualisiert. Das Diagramm zeigt nach {{time}} keine Daten mehr an.",
  dataUpdating: "Daten aktualisieren",
  filter: {
    all: "Alles",
    month: "Monat",
    week: "Woche",
    year: "Jahr"
  }
};
const checkSDcard$g = "Micro-SD-Karte wird berprft";
const clickHere$g = "Hier klicken.";
const confirm$i = {
  abortInfo: "Tippe zum ",
  abortInfoRedText: "abbrechen",
  approveInfo: "4 Sekunden lang halten um zu ",
  approveInfoGreenText: "besttigen",
  info: "Fahre auf deiner BitBox fort.",
  infoWhenPaired: "Zuerst auf deinem gepaarten Mobiltelefon und dann auf deiner BitBox"
};
const confirmOnDevice$g = "Bitte besttige auf deinem Gert.";
const connectKeystore$a = {
  promptNoName: "Bitte verbinde deine BitBox02 um fortzufahren",
  promptWithName: 'Bitte verbinde deine BitBox02 mit dem Namen {{name}}" um fortzufahren'
};
const darkmode$a = {
  toggle: "Dark mode"
};
const device$g = {
  appUpradeRequired: "Deine BitBox ist mit dieser Desktopanwendung nicht kompatibel. Bitte lade die neueste Version herunter und installiere diese..",
  keystoreConnected: "Verbundene Wallet"
};
const deviceLock$g = {
  button: "Zwei-Faktor-Autorisierung (2FA) aktivieren",
  condition1: "Hast du ein Backup?",
  condition2: "Funktioniert die Verifikation auf deinem Smartphone?",
  condition3: 'Wenn du 2FA aktivierst wird "Backups verwalten", "Versteckte Wallet erstellen" und "Mit Smartphone App" koppeln deaktiviert. Um 2FA zu deaktivieren muss das Gert auf Werkseinstellungen zurck gesetzt werden.   ',
  confirm: "Zwei-Faktor Authentifizierung (2FA) aktivieren\n",
  title: "Zwei-Faktor-Autorisierung (2FA) aktivieren"
};
const deviceSettings$g = {
  backups: {
    manageBackups: {
      description: "Erstelle oder berprfe das MicroSD-Karten-Backup."
    },
    showRecoveryWords: {
      description: "Zeige und berprfe die Wiederherstellungswrter."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "Die BitBoxApp prft, ob dein Gert authentisch ist."
    },
    deviceName: {
      description: "ndere den Namen deines Gerts."
    },
    rootFingerprint: {
      description: "Der Root-Fingerabdruck ist eine eindeutige Kennung fr das aktuell verwendete Wallet. Es kann dir helfen, zwischen verschiedenen Wallets zu unterscheiden, falls du Passphrasen verwendest."
    },
    securechip: {
      description: "Das Modell des Secure-Chips."
    },
    title: "Gerteinformationen"
  },
  expert: {
    factoryReset: {
      description: "Setze dein Gert auf die Werkseinstellungen zurck. Dadurch wird das Wallet auf deiner BitBox02 gelscht!",
      title: "Auf Werkseinstellungen zurcksetzen"
    },
    goToStartupSettings: {
      description: "Den Bootloader der BitBox02 starten. Dort kannst du den Firmware-Hash aktivieren."
    },
    passphrase: {
      description: "Aktiviere oder deaktiviere die Passphrasen-Funktion.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Verfgbare Version"
    },
    title: "Firmware",
    upToDate: "Dein Gert ist auf dem aktuellen Stand  ",
    upgradeAvailable: "Neues Upgrade verfgbar",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "Echtheitscheck fehlgeschlagen",
      label: "Echtheitsprfung",
      "true": "Deine BitBox02 ist echt"
    },
    sdcard: {
      "false": "Nicht eingesteckt",
      label: "microSD Karte",
      "true": "Eingesteckt"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Gerteinformationen werden abgerufen...\n\n",
  pairing: {
    lock: {
      "false": "Deaktiviert",
      label: "Zwei-Faktor Autorisierung (2FA)",
      "true": "Eingeschaltet"
    },
    mobile: {
      "false": "Geschlossen",
      label: "Smartphone App",
      "true": "Offen"
    },
    status: {
      "false": "Nicht gekoppelt",
      label: "Status",
      "true": "Gekoppelt"
    },
    title: "Zwei-Faktor Autorisierung (2FA)"
  },
  secrets: {
    manageBackups: "Backups verwalten",
    title: "Sicherheit"
  }
};
const deviceTampered$g = "Falls deine BitBox mit einem Wiederherstellungspasswort geliefert wurde, beende das Setup SOFORT und kontaktiere den Support. \nSHIFT versendet niemals BitBoxen, die schon ein Passwort haben und wird nie Passwortempfehlungen aussprechen. \nBenutze diese BitBox auf keinen Fall !";
const dialog$h = {
  cancel: "Abbrechen",
  confirm: "Besttigen",
  confirmTitle: "Besttigung"
};
const error$c = {
  accountAlreadyExists: "Dieses Konto existiert bereits.",
  accountLimitReached: "Konto kann nicht hinzugefgt werden. Die maximale Kontenanzahl fr diese Whrung wurde erreicht.",
  aoppCallback: "Beim bermitteln der Adresse an {{host}} ist ein Fehler aufgetreten.",
  aoppInvalidRequest: "Ungltige Anfrage.",
  aoppNoAccounts: "Es sind keine Konten verfgbar.",
  aoppSigningAborted: "Adressinhaberanfrage wurde abgebrochen.",
  aoppUnknown: "Ein unbekannter Fehler ist aufgetreten.",
  aoppUnsupportedAsset: "Diese Kryptowhrung wird nicht untersttzt.",
  aoppUnsupportedFormat: "Es sind keine Konten verfgbar, die das angeforderte Adressformat untersttzen.",
  aoppUnsupportedKeystore: "Das verbundene Gert kann keine Nachrichten fr diese Kryptowhrung signieren.",
  aoppVersion: "Unbekannte Version.",
  keystoreTimeout: "Die Wallet-Anfrage ist abgelaufen. Bitte versuche es erneut.",
  wrongKeystore: "Falsches Wallet verbunden. Bitte verbinde das richtige Gert, zu dem diese Konto gehrt.",
  wrongKeystore2: "Falls du ein optionale Passphrase nutzt, stelle sicher, dass du die richtige Passphrase fr dieses Konto eingegeben hast."
};
const fiat$i = {
  "default": "Standard",
  setDefault: "{{code}} als Standard speichern\n",
  title: "Whrungen"
};
const footer$i = {
  appVersion: "App Version:"
};
const generic$c = {
  enabled_false: "Deaktiviert",
  enabled_true: "Aktiviert"
};
const genericError$g = "Ein Fehler ist aufgetreten. Falls du Probleme bemerkst, starte die Applikation bitte neu.";
const goal$g = {
  buttons: {
    create: "Neue Wallet erstellen",
    restore: "Wallet von Backup wiederherstellen "
  },
  paragraph: "Bitte whle eine der folgenden Optionen:",
  step: {
    "1": {
      title: "Sicherheitsinformationen"
    },
    "2": {
      description: "Passwort",
      title: "Gert"
    },
    "3-create": {
      description: "Neue Wallet erstellen",
      title: "Wallet"
    },
    "3-restore": {
      description: "von einem Backup",
      title: "Wiederherstellen"
    },
    "4-create": {
      title: "Zusammenfassung"
    },
    "4-restore": {
      title: "Zusammenfassung"
    }
  }
};
const guide$h = {
  accountDescription: {
    text: "Deine Kontobersicht zeigt deinen Kontostand und deine Transaktionen an. Stbere durch diesen Guide um mehr ber die verschiedenen Kontoarten zu erfahren. ",
    title: "Was wird mir auf dieser Seite angezeigt?"
  },
  accountFiat: {
    text: "Ja, du kannst auf das Whrungssymbol klicken, um zwischen den verschiedenen Whrungen zu wechseln. Die verfgbaren Whrungen kannst du in den Einstellungen anpassen.",
    title: "Knnen auch andere Wechselkurse angezeigt werden?"
  },
  accountIncomingBalance: {
    text: "Eingehend summiert alle eingehenden Transaktionen, die noch nicht besttigt sind. ",
    title: 'Was bedeutet "Eingehend"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Jeder xpub ist an den angezeigten "Typ" gebunden: Entweder "Native SegWit (bech32)", "Wrapped segwit" oder "Taproot". Dies sind Skripttypen, die von {{coinName}} verwendet werden. Die BitBoxApp kombiniert sie und untersttzt mehrere Skripttypen im selben Konto. Da jeder Skripttyp einen anderen xpub verwendet, gibt es mehrere xpubs pro Konto.\n\nWenn du nur auf den Standardadressen empfngst, bentigst du nur den "bech32" xpub. Wenn du jedoch auch Coins auf "kompatible Adresse" erhltst, werden diese auf dem xpub "wrapped SegWit" angezeigt.',
      title: "Warum gibt es mehrere xpubs?"
    },
    privacy: {
      text: "Fr dieses Konto zeigt der erweiterte ffentliche Schlssel die gesamte Transaktionshistorie, deinen Kontostand und alle zuknftigen Transaktionen an. Aber der xpub erlaubt niemandem, deine Coins auszugeben.\n\nWenn du jemandem ein xpub gibst, solltest du dir bewusst sein, dass diese Person oder Firma alle anderen Transaktionen desselben Kontos sehen kann. Daher ist es eine gute Idee, dieses Konto nur fr diesen Zweck zu verwenden und andere Coins in anderen Konten zu halten.",
      title: "Muss ich mein xpub geheim halten?"
    },
    verify: {
      text: "Ja, es ist immer eine gute Idee, deinen xpub zu berprfen. Wenn jemand anderes Empfangsadressen von diesem xpub generiert, um dir Coins zu senden, ist dies besonders wichtig. Du musst ihn auf deiner BitBox berprfen, um sicherzustellen, dass dieser xpub dir gehrt. Andernfalls knnten alle Coins an die falschen Adressen gehen.",
      title: "Muss ich den xpub auf dem Gert berprfen?"
    },
    xpub: {
      text: "Ein erweiterter ffentlicher Schlssel (xpub) ist ein Stammschlssel, von dem alle Empfngeradressen eines Kontos abgeleitet werden.\n\nEr wird hier fr die erweiterte Nutzung und die Interoperabilitt mit Watch-Only-Wallets wie Electrum oder Sentinel bereitgestellt. Wenn du auf verschiedene Adresstypen empfngst, importiere bitte alle verschiedenen xpub-Formate in die Watch-only-Wallet, damit du alle deine Coins sehen kannst.\n\nBitte beachte, dass Wallets von Drittanbietern Taproot xpubs mglicherweise noch nicht untersttzen.\n",
      title: "Was ist ein erweiterter Public Key?"
    }
  },
  accountRates: {
    text: "Die Wechselkurse werden mintlich von CoinGecko aktualisiert.",
    title: "Welche Wechselkurse werden benutzt?"
  },
  accountReload: {
    text: "Das ist nicht ntig. Alle Transaktionsinformationen werden automatisch aktualisiert. ",
    title: "Wie kann ich die Transaktionshistorie erneut laden?"
  },
  accountSendDisabled: {
    text: 'Der "Senden" Knopf wird aktiviert, wenn dein Guthaben grer als Null ist.',
    title: "Warum kann ich keine {{unit}} senden?"
  },
  accountSummaryAmount: {
    text: "Der Gesamtbetrag ist die Summe aller deiner Kryptokonten. Die Wechselkurse werden von coingecko.com abgerufen.\n\nHinweis: Wenn du MyEtherWallet fr Token verwendest, die in der BitBoxApp nicht untersttzt werden, dann sind diese nicht in dem angezeigten Gesamtbetrag einberechnet.",
    title: "Wie berechnet sich der Gesamtbetrag?"
  },
  accountSummaryDescription: {
    text: "Hier kannst du die Entwicklung deines Portfolios im Laufe der Zeit sehen. Eine bersicht ber deine einzelnen Krypto-Konten wird unter dem Diagramm angezeigt.",
    title: "Was kann ich auf dieser Seite sehen?"
  },
  accountTransactionAttributesBTC: {
    text: 'Virtuelle Gre: Wird zur Ermittlung der Netzwerkgebhr verwendet. Du hast erfolgreich Gebhren gespart, wenn sie kleiner als die Transaktion sind.\nGre: Aktuelle Transaktionsgre in Bytes nach der Serialisierung gem der zugrunde liegenden Blockchain.\nGewicht: Mit Segwit eingefhrt, ist dies eine neue Metrik zur Bewertung von Transaktions- und Blockgren. Jedes Segwit Byte zhlt als eins, alles andere als vier "Gewichtseinheiten". Statt eines Megabytes, betrgt die Blockgrenbegrenzung nun vier Millionen "Gewichtseinheiten".',
    title: "Was hat es mit den Bitcoin-spezifischen Transaktionsdetails  auf sich?"
  },
  accountTransactionAttributesGeneric: {
    text: 'Besttigungen: Nachdem du deine Transaktion gesendet hast ist diese zuerst unbesttigt. Du musst warten, bis sie von einem Miner in einen Block aufgenommen wird. Dann hat deine Transaktion die erste Besttigung. Jeder nachfolgende Block fgt deiner Transaktion eine weitere Besttigung hinzu. Meist sehen Hndler und andere Netzwerkakteure Transaktionen erst mit 3 bis 6 Besttigungen als erledigt.\nTransaktions-ID: Eine eindeutige Identifikationsnummer, die zum Nachschlagen einer Transaktion in einem Blockexplorer verwendet werden kann.\nGebhr: Miner erhalten eine Transaktionsgebhr als Anreiz, Transaktionen in die von ihnen erzeugten Blcke aufzunehmen. Um mehr zu erfahren, klicke auf  "Senden".',
    title: "Welche Informationen werden in den Transaktionsdetails angezeigt?"
  },
  accountTransactionConfirmation: {
    text: "Dies ist eine Transaktionen die ins Netzwerk geschickt wurde und darauf wartet besttigt zu werden.",
    title: "Was ist eine ausstehende Transaktion?"
  },
  accountTransactionLabel: {
    text: "Es ist die Adresse an die du Coins erhalten oder geschickt hast.",
    title: "Welche Adresse wird bei jeder Transaktion angezeigt?"
  },
  accountTransactionTime: {
    text: "Der Zeitpunkt, zu dem die Transaktion in der Blockchain besttigt wurde.",
    title: "Welche Zeit wird angezeigt?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin und Litecoin knnen eine beliebige Anzahl an Konten haben. Nach fnf Konten kannst du nur dann ein weiteres Konto hinzufgen, wenn das vorherige Konto verwendet wurde.\nAndere Coins knnen maximal fnf Konten haben.",
      title: "Wie viele Konten kann ich erstellen?"
    },
    howtoAddTokens: {
      text: 'ERC-20 Token sind an ein bestimmtes Ethereum-Konto gebunden. Um einen Token zu aktivieren oder zu deaktivieren, gehe zu "Konten verwalten", klicke auf das Ethereum-Konto und schalte den gewnschten Token ein oder aus.',
      title: "Wie kann ich zustzliche Token hinzufgen?"
    },
    moveFunds: {
      text: "Ja. Da Konten jedoch eigenstndig sind, mssen Coins mit einer regulre Transaktion zwischen den Konten verschoben werden.",
      title: "Kann ich Geld zwischen Konten verschieben?"
    },
    recoverAccounts: {
      text: "Ja. Die BitBoxApp erstellt Konten nach bewhrten Standards, die mit den meisten Krypto-Wallets kompatibel sind.",
      title: "Kann ich meine Konten in anderen Wallets wiederherstellen?"
    },
    whatAreAccounts: {
      text: "Deine Wallet kann mehrere Konten derselben Whrung verwalten. Konten machen es einfach, Coins separiert zu halten.",
      title: "Was sind Konten?"
    },
    whatIsRememberWallet: {
      text: "Durch die Aktivierung von Wallet merken kannst du die Konten von diesem Wallet in der BitBoxApp sehen, auch wenn die BitBox02 nicht verbunden ist. So kannst du deinen Kontostand und dein Portfolio jederzeit berprfen. Zum Senden oder Empfangen von Coins muss die BitBox02 jedoch eingesteckt und entsperrt werden.\n\nWenn du Wallet merken deaktivierst, musst du die BitBox02 (oder Passphrase-Wallet) verbinden, um diese Konten in der BitBoxApp zu sehen.",
      title: "Was passiert, wenn ich Wallet merken aktiviere/deaktiviere?"
    },
    whyIsThisUseful: {
      text: 'Separate Konten eignen sich hervorragend fr die Verwaltung von Coins fr verschiedene Personen oder Zwecke. Du kannst auch den "erweiterten ffentlichen Schlssel" (extended public key) eines Kontos freigeben, ohne etwas ber deine anderen Konten preiszugeben. Auf diese Weise kannst du wiederholt Geld erhalten, ohne Adressen wiederzuverwenden, z. B. um deinen Lohn zu erhalten oder um regelmig Krypto zu kaufen.',
      title: "Warum ist das ntzlich?"
    }
  },
  appendix: {
    link: "Kontaktiere uns!",
    text: "Du hast Fragen?"
  },
  backups: {
    check: {
      text: 'Mit "Check Backup" kannst du berprfen, ob du ber ein gltiges Backup fr deine aktuelle Wallet verfgst. Es kann auch verwendet werden, um zu berprfen, ob du das korrekte Wiederherstellungspasswort kennst.',
      title: 'Was bedeutet "Check Backup"?'
    },
    encrypt: {
      text: "Nein, aber dein Wiederherstellungspasswort wird bentigt, um deine Wallet aus dem gespeicherten Seed zu erzeugen.",
      title: "Kann ich mein Backup verschlsseln?"
    },
    howOften: {
      text: "Das Backup wird automatisch erstellt, wenn eine neue Wallet erstellt wird. Du musst nur dann ein neues Backup erstellen, wenn deine microSD-Karte verloren ist, beschdigt wurde oder wenn du dein Backup auf mehreren microSD Karten speichern willst.\nDu musst nach der Transaktionsaktivitt keine neuen Backups erstellen. Alle deine Transaktionsdaten knnen durch ein einzelnes Backup, das automatisch fr dich erstellt wurde, wiederhergestellt werden.",
      title: "Wie oft muss ich ein Backup erstellen?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie des Seed auf einer microSD-Karte. Der Seed zusammen mit deinem Wiederherstellungspasswort stellen dein Wallet wieder her.",
      title: "Was ist ein Backup?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Backup berprfen" checkt, dass sich auf deiner microSD Karte ein gtiges Backup zu deiner aktuell verwendeten Wallet befindet.',
      title: 'Was bedeutet "Backup berprfen"?'
    },
    encrypt: {
      text: 'Nein. Bitte bewahre deine microSD-Karte sicher auf, da sie den unverschlsseltes Seed enthlt, der zur Wiederherstellung deiner Wallet bentigt wird. Falls du dein Backup mit einem Passwort schtzen willst, aktiviere die "Optionale Passphrase" in den Gerteeinstellungen.',
      title: "Kann ich das Backup verschlsseln?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie deines Seeds auf deiner microSD Karte.",
      title: "Was ist das Backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: 'Wenn 2FA aktiviert ist, mssen alle Transaktionen auf dem gekoppelten Mobiltelefon genehmigt werden, um Coins zu versenden. Unter der Haube: Eine verschlsselte einmalige Nummer wird an die App gesendet, dort wird sie entschlsselt und beim Drcken der Schaltflche "Akzeptieren" zur BitBox zurckgegeben. Diese Kommunikation mit der BitBox erfolgt ber den Kanal zwischen dem Mobiltelefon und dieser Desktop-App, der whrend des Pairings eingerichtet wurde.  \n\nStelle sicher, dass du ein Backup deiner Wallet erstellst und die App verbindest, bevor du 2FA aktivierst. Nach der Aktivierung werden der Mikro-SD Kartenslot und das Mobile-App-Pairing deaktiviert. Du kannst es nur erneut aktivieren, indem du die BitBox zurcksetzt, wodurch das Gert gelscht wird.',
      title: "Wie funktioniert die Zwei-Faktor-Autorisierung (2FA)?"
    },
    disable2FA: {
      text: `Um 2FA zu deaktivieren, musst du deine BitBox zurcksetzen und anschlieend deine Wallet von deinem Backup wiederherstellen. Stelle sicher, dass du deine MicroSD-Karte mit deinem Backup hast und du das Wiederherstellungspasswort kennst. Dann drcke 'Reset Device'. Lege ein neues Gertekennwort fest und whle "Backup wiederherstellen". Whle Backup aus und klicke auf "Wiederherstellen". Dann gib dein Wiederherstellungskennwort ein, das du beim Erstellen der Wallet verwendet hast.`,
      title: "Wie schalte ich die Zwei-Faktor-Autorisierung (2FA) aus?"
    },
    ejectBitbox: {
      text: "Du kannst deine BitBox einfach aus dem Computer ziehen ohne sie vorher auszuwerfen.",
      title: "Wie werfe ich meine BitBox aus?"
    },
    ejectSD: {
      text: "Du kannst die Micro SD Karte jederzeit aus der BitBox entfernen, solange du nicht dabei bist, ein Backup zu erstellen oder zu berprfen",
      title: "Wie kann ich die Micro-SD-Karte auswerfen?"
    },
    hiddenWallet: {
      text: "Es ist eine sekundre Wallet, auf der selben BitBox, das mit einem anderen Passwort geschtzt ist. Dies erlaubt dir, einem Erpresser ein anderes Wallet zu ffnen, in welchem sich nur eine geringe Menge Coins befindet. Info: Fr beide Wallets, normal und versteckt, wird der selbe Seed verwendet, somit muss kein weiteres Backup erzeugt werden",
      title: "Was ist eine versteckte Wallet?"
    },
    legacyHiddenWallet: {
      text: "Klicke zunchst auf den Knopf unten (dazu muss die BitBox mit dem Hauptgertekennwort entsperrt sein und 2FA deaktiviert sein), schliee dann deine Bitbox an und entsperre diese mit deinem versteckten Gertekennwort.",
      title: "Wie greife ich auf die versteckte Wallet des Legacy Kontos zu?"
    },
    pairing: {
      text: "Nachdem du unsere mobile App fr iOS oder Android heruntergeladen hast, scanne den angezeigten QR-Code. Dadurch wird ein sicherer Kanal zwischen der mobilen App und dieser Anwendung eingerichtet. Befolge nach dem Scannen die Anweisungen in der Smartphone App.",
      title: "So, koppelst du dein Telefon sicher mit der BitBox"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Bitte besuche Bitsurances Website und deren FAQ fr mehr Details.",
      title: "Weitere Fragen?"
    },
    privacy: {
      link: {
        text: "Bitsurance Datenschutzrichtlinie"
      },
      text: "Wie jede regulre Versicherungspolice enthlt sie deinen vollstndigen Namen und deine Adresse und gibt das versicherte Objekt an (definiert durch den erweiterten ffentlichen Schlssel des versicherten Bitcoin-Kontos). Diese Daten werden direkt an Bitsurance bermittelt und nicht mit Shift Crypto geteilt. Weitere Informationen findest du in den Datenschutzbestimmungen von Bitsurance",
      title: "Welche persnlichen Informationen werden fr die Versicherung bentigt?"
    },
    renew: {
      text: 'Die Versicherung wird automatisch fr das nchste Jahr verlngert. Du kannst die Verlngerung jederzeit kndigen, indem du in der BitBoxApp auf "Vertrag verwalten" klickst, wodurch du zum Bitsurance-Kundenportal gelangst.',
      title: "Wie kann ich die Versicherung verlngern oder kndigen?"
    },
    status: {
      text: "Erfolgreich versicherte Konten sind auf jeder Bitcoin-Kontoseite in der oberen linken Ecke mit einem grnen versicherten Abzeichen gekennzeichnet. Im Bereich Versicherung siehst du die bersicht aller versicherten Bitcoin-Konten und dem aktuellen Versicherungsstatus. Die Aktualisierung des Versicherungsstatus kann bis zu 48 Stunden dauern.",
      title: "Kann ich den Status eines versicherten Kontos berprfen?"
    },
    what: {
      text: 'Jeder Bitcoin-Versicherungsvertrag deckt ein bestimmtes Wallet-Konto ab. Du kannst mehrere Konten versichern, indem du mehrere Versicherungsvertrge abschliet. Versicherte Konten drfen nur "Native Segwit"-Bitcoin-Adressen verwenden.',
      title: "Ist die gesamte BitBox Wallet versichert?"
    },
    who: {
      text: "Die Versicherung wird von Bitsurance angeboten, einem Versicherungsmakler, der von Bitcoinern gegrndet wurde. Sie arbeiten mit dem ELEMENT Versicherer zusammen, um Bitcoin-Versicherungen anzubieten. Beide Unternehmen sind in Deutschland ansssig.",
      title: "Wer versichert meine Bitcoin?"
    },
    why: {
      text: "Bitsurance deckt einige Risiken der Selbstverwahrung ab, die selbst bei der sichersten Wallet nicht abgedeckt werden knnen, z. B. Einbruch, Erpressung oder Zerstrung der Wallet. Es ist deine persnliche Entscheidung, ob du einen Versicherungsschutz fr diese Risiken brauchst.",
      title: "Brauche ich eine Bitcoin-Versicherung?"
    }
  },
  cointracking: {
    text: 'Klicke auf "Exportieren" und ffne den Download-Ordner. Dort findest du die exportierte CSV Datei. Klicke dann auf den untenstehenden Link, lade deine BitBox-CSV-Datei hoch und importiere die Daten, um sie fr deinen CoinTracking-Portfoliomanager zu verwenden und deine Steuerberichte zu erstellen.',
    title: "Wie importiere ich meine Transaktionen in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lese mehr ber den Echtheitscheck"
      },
      text: "Die BitBoxApp fhrt eine berprfung der BitBox02 durch, um festzustellen, ob das Gert echt ist. Die Prfung wird lokal durchgefhrt und stellt keine Verbindung zu unseren Servern her.",
      title: "Wie funktioniert die Echtheitsprfung?"
    },
    name: {
      text: "Dies ist der Name deiner Wallet und deines Backups. Der Name wird fr zuknftige Backups verwendet und kann dazu dienen, verschiedene Wallets zu unterscheiden. Er kann jederzeit gendert werden, aber beachte, dass Backups, die vor der nderung erstellt wurden, weiterhin den vorherigen Namen verwenden.",
      title: "Wofr wird der BitBox02-Name verwendet?"
    },
    "secure-chip": {
      link: {
        text: "Lese mehr ber den Secure-Chip"
      },
      text: "Diese Information zeigt die Modellnummer des Sicherheitschips. Der aktuellste Chip ist der ATECC608B mit verbesserten Sicherheitsfunktionen im Vergleich zu lteren Modellen.",
      title: "Warum das Modell des Secure-Chips anzeigen?"
    }
  },
  receive: {
    address: {
      text: "Du kannst die Adresse an andere weitergeben, damit sie dir Coins schicken knnen. Achte darauf, dass sie an die richtige Adresse schicken.",
      title: "Was mache ich mit einer Adresse?"
    },
    addressChange: {
      text: "Sobald eine Adresse fr eine Transaktion benutzt wurde, wird eine neue Adresse zu der Liste hinzugefgt um die Alte zu ersetzen. Es werden immer 20 ungenutzte Adressen angezeigt. ",
      title: "Wann ndern sich die Adressen?"
    },
    addressFormats: {
      text: "Standardmig ist der Adresstyp Native Segwit. Dieser Adresstyp wird von vielen anderen Wallets/Brsen akzeptiert und bietet dir die besten Gebhrenstze fr alltgliche Transaktionen. Du kannst aber auch an Taproot (nur Bitcoin) senden, den neuesten Adresstyp, der aber noch nicht berall untersttzt wird. Wenn du Probleme hast, an Native Segwit (den Standard-Adresstyp) zu senden, kannst du auch auf den lteren Wrapped Segwit-Adresstyp umsteigen, der mglicherweise mit mehr Wallets/Brsen kompatibel ist.",
      title: "Wann sollte ich den Adresstyp ndern?"
    },
    howVerify: {
      text: 'BitBox01: Klicke auf das BitBox-Symbol in der Seitenleiste links und siehe dir den Abschnitt "Zwei-Faktor Autorisierung" an. Die Anleitung wird aktualisiert und du kannst von dort aus den Anweisungen folgen.\n\nBitBox02: Dank des eingebauten Displays kannst du die Adresse direkt auf dem Gert whrend des Send-/Empfangsprozesses verifizieren. ',
      title: "Wie kann ich die Adresse sicher verifizieren?"
    },
    plugout: {
      text: "Nein, sobald du die Adresse auf dem Display besttigt und kopiert hast, musst du deine BitBox nicht mehr eingesteckt haben. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox whrend des Empfangs eingesteckt lassen?"
    },
    why20: {
      text: 'Die BitBoxApp generiert automatisch eine gewisse Anzahl an Adressen, die von deinem Seed abgeleitet werden. Sie berprft dann, ob diese Adressen schon Coins erhalten haben. Die App kann theoretisch eine nahezu unbegrenzte Anzahl von Adressen generieren, wodurch es Jahre dauern wrde, bis dein Kontostand ermittelt ist. Um diese Suche einzuschrnken stoppt die App diesen Prozess, nachdem sie 20 Adressen generiert hat, die noch nie Coins erhalten haben. Dies wird "gap-limit" genannt und 20 ist ein der de-facto-Standard. Deswegen siehst du immer nur 20 Adressen, aus denen du auswhlen kannst. ',
      title: "Warum werden nur 20 Adressen angezeigt?"
    },
    whyMany: {
      text: "Aus Grnden des Datenschutzes und der Sicherheit solltest du niemals dieselbe Empfangsadresse zweimal verwenden. Klicke auf 'Weiter', um eine neue Adresse zu erhalten. Du kannst bis zu 20 Adressen gleichzeitig generieren. Alle Adressen werden von deinem Backup abgeleitet. (Stell dir Adressen wie Rechnungsnummern vor.)",
      title: "Warum gibt es mehrere Adressen?"
    },
    whyVerify: {
      text: "Einer der Grnde fr den Kauf einer Hardwarewallet, ist dass du deinem Computer aufgrund der groen Angriffsflche nicht vertrauen solltest. Daher solltest du nicht darauf vertrauen, dass dein Computer authentische Adressen generiert und anzeigt. \nBitbox01: Mit dem Knopf zur sicheren berprfung der Adresse sendet die BitBox01 die Adresse an ein gekoppeltes Mobiltelefon, auf welchem du die Adresse  berprfen kannst. \nBitBox02: Die BitBox02 hat ein eingebautes Display, auf dem die Adresse sicher angezeigt werden kann. ",
      title: "Warum sollte ich die Adresse verifizieren?"
    }
  },
  send: {
    change: {
      text: "Der Change wird an eine Taproot-Adresse gesendet, wenn du mindestens eine Taproot UTXO besitzt. Wenn du Coin-Control verwendest, wird der Change an eine Taproot-Adresse gesendet, wenn mindestens eine der ausgewhlten UTXOs eine Taproot-UTXO ist. In allen anderen Fllen wird der Change an eine Native-Segwit-Adresse gesendet. ",
      title: "Wie wird der Change-Output bestimmt?"
    },
    fee: {
      text: "Die Gebhr basiert auf der Transaktionsdatengre und nicht auf dem Transaktionsbetrag. Die Gebhren werden durch den Gebhrenschtzungsalgorithmus von Bitcoin Core fr jede von dir gewhlte Netzwerkprioritt berechnet. Sie werden explizit angezeigt, wenn du einen anderen Wert als die unten stehenden Ziele haben.\nEconomy: 24 Blcke (ca. 4 Stunden fr Bitcoin, 1 Stunde fr Litecoin)\nNiedrig: 12 Blcke (etwa 2 Stunden fr Bitcoin, 30 Minuten fr Litecoin)\nNormal: 6 Blcke (ca. 1 Stunde fr Bitcoin, 15 Minuten fr Litecoin)\nHoch: 2 Blcke (ca. 20 Minuten fr Bitcoin, 5 Minuten fr Litecoin)\n(Ein Block bentigt durchschnittlich zehn Minuten fr Bitcoin (2,5 Minuten fr Litecoin)), und die Netzwerklast kann in den oben genannten Zeitrumen erheblich variieren.)",
      title: "Wie wird die Gebhr ermittelt?"
    },
    plugout: {
      text: "Nein, nachdem du eine Transaktion durchgefhrt hast, musst du deine BitBox nicht eingesteckt lassen. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox beim Senden eingesteckt lassen?"
    },
    priority: {
      text: "Je hher die Gebhr ist, die du bereit bist zu zahlen, desto schneller wird deine Transaktion vom Netzwerk besttigt. ",
      title: "Was ist Netzwerk Prioritt?"
    },
    revert: {
      text: "Sobald eine Transaktion signiert und gesendet (d.h. An das Netzwerk gesendet) wurde, kann sie nicht mehr rckgngig gemacht werden. berprfe die Transaktionen (einschlielich der Gebhr) deswegen, bevor du die Transaktion besttigst!\nWenn du den Empfnger kennst und dieser bereit ist, denselben Betrag (abzglich der Transaktionsgebhren) an dich zurckzuschicken, kannst du ihm eine neue Empfngeradresse senden.",
      title: "Kann ich eine Transaktion rckgngig machen?"
    },
    whyFee: {
      text: 'Transaktionen stehen im Wettbewerb, um von einem Miner besttigt zu werden. Die Miner whlen Transaktionen, die in die Blockchain aufgenommen werden sollen, basierend auf ihrer Gebhr aus. Miner bevorzugen Transaktionen mit hheren Gebhren. Deswegen wird eine Transaktion die bereit ist, eine hhere Gebhr zu bezahlen auch schneller in einem Block aufgenommen. \nDa es keinen Mittelsmann gibt, der eine Regelung, wie eine Stimme pro Person erzwingen kann, stimmen die Miner ber Transaktionen ab, indem sie eine kostspielige Ressource, wie Rechenleistung opfern. Als Belohnung dafr erhalten sie neu erstellte Coins und die Gebhren der Transaktionen in dem von ihnen "gemineten" Block (english: to mine a Block) .',
      title: "Warum gibt es eine Netzwerk Gebhr?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Wenn du nur dann eine Verbindung zu deinem Full Node herstellen mchtest, wenn du dich im selben Netzwerk befindest (z. B. in deinem Heim-WLAN), ist die Verwendung einer regulren Netzwerkkommunikation ausreichend.\nIn diesem Fall ist es ratsam, dass dein Electrum-Server ein TLS-Zertifikat zum Verschlsseln der Kommunikation bereitstellt.\nWenn du von berall aus eine Verbindung zu deinem Full Node herstellen mchtest, ist die Verwendung von Tor die bessere Option. In diesem Fall ist kein TLS-Zertifikat erforderlich.",
      title: "Soll ich Clearnet TCP, TLS oder Tor verwenden?"
    },
    instructions: {
      link: {
        text: "Anleitung zum Verbinden deines Full Nodes"
      },
      text: "Fr eine vollstndiges Anleitung, besuche bitte unseren Guide:",
      title: "Wie verbinde ich meine BitBoxApp mit meinem Full Node?"
    },
    options: {
      text: "Es gibt mehrere Mglichkeiten, einen eigenen Full Node zu betreiben, z. B. ein fertiges Gert zu kaufen, einen eigenen zu bauen oder Bitcoin Core auszufhren.\nWenn du deine BitBoxApp mit deinem Full Node verbinden mchtest, stelle sicher, dass dieser einen Electrum-Server bereitstellt. Dies ist ein spezielles Programm, mit dem eine Wallet-App mit deinem Full Node kommunizieren kann.\nUntersttzte Optionen sind Electrs, Electrum Personal Server (EPS) oder Bitcoin Wallet Tracker (BTW).",
      title: "Welche Optionen gibt es, um einen Full Node zu betreiben?"
    },
    tor: {
      text: 'Tor steht fr "The Onion Router", eine kostenlose Open-Source-Software, die viele Datenschutzvorteile bietet und besonders bei der Verwendung von Bitcoin ntzlich ist.\nWenn du ber Tor eine Verbindung zu deinem Full Node herstellen mchtest, stelle sicher, dass Tor auf deinem Computer installiert ist, und aktiviere dann den Tor-Proxy in den BitBoxApp-Einstellungen.\nAuf den meisten Betriebssystemen gibt es zwei Mglichkeiten, Tor auszufhren:\n1. Tor Browser: Lade den Tor Browser herunter und ffne ihn. Dadurch kann die BitBoxApp eine Verbindung zum Tor-Netzwerk herstellen, indem Port 9150 in den Tor-Proxy-Einstellungen festgelegt wird.\n2. Tor-Hintergrunddienst: Installiere den Tor-Daemon, der immer im Hintergrund ausgefhrt wird. Die BitBoxApp kann dann eine Verbindung herstellen, indem Port 9050 in den Tor-Proxy-Einstellungen festgelegt wird.',
      title: "Was ist Tor, Tor-Proxy und welchen Port soll ich verwenden?"
    },
    what: {
      text: "Es ist mglich, deine Wallet mit einem eigenen Fullnode zu betreiben, anstatt den Shift-Server zu verwenden.",
      title: "Was ist das?"
    },
    why: {
      text: "Einen eigenen Full Node zu betreiben ist nicht erforderlich. Er verbessert jedoch deine Privatsphre und verringert die Notwendigkeit, anderen Netzwerkteilnehmern zu vertrauen.\nZum einen erlaubt er dir Bitcoin privater verwenden, da die BitBoxApp dann keine Verbindung zu unseren Servern herstellt, um deinen Transaktionsverlauf abzurufen. Stattdessen werden diese Informationen von deinem eigenen Full Node abgerufen.\nDes Weiteren, verifiziert dein Full Node alle Transaktionen selbst, wodurch sichergestellt wird, dass die Konsensregeln eingehalten werden. ",
      title: "Warum sollte ich meinen eigenen Full Node betreiben?"
    }
  },
  settings: {
    sats: {
      text: 'Ein Satoshi (kurz "sat") ist die kleinste Einheit eines Bitcoins. Ein Satoshi ist ein Hundertmillionstel eines Bitcoins (0,00000001 BTC). Benannt ist er nach dem Erfinder von Bitcoin, Satoshi Nakamoto.',
      title: "Was ist ein Satoshi?"
    },
    servers: {
      text: "Diese App kommuniziert mit Servern von Shift Crypto, um nach Updates zu suchen, Transaktionen zu laden und Informationen an verbundene Smartphone Apps zu senden.\nAuerdem werden die neuesten Wechselkurse von CoinGecko abgerufen. (Die Conversions werden lokal berechnet, es werden keine Betrge von dir bertragen.)\nInfo: Fr Ethereum und ERC-20 tokens verwenden wir die Etherscan.io APIs.",
      title: "Mit welchen Servern kommuniziert die Applikation?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Guide schlieen",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Bewege auf dem Desktop den Mauszeiger ber das Diagramm. Halte auf Mobilgerten deinen Finger auf dem Diagramm und ziehe ihn horizontal.",
    title: "Wie kann man historische Werte auf dem Chart sehen?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Du musst das Gert zurcksetzen und die Wallet mithilfe des Wiederherstellungskennworts aus deinem Backup wiederherstellen.",
      title: "Was mache ich, wenn ich mein Passwort vergessen habe?"
    },
    reset: {
      text: "Gib 15 Mal ein falsches Gertekennwort ein. Die letzten Versuche erfordern eine lange Berhrung des Gerts.",
      title: "Wie stelle ich mein Gert wieder her?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Das Gert sollte beim Einstecken einmal blinken. Stelle sicher, dass es richtig herum eingesetzt ist. Bei Problemen kontaktiere uns bitte ber den untenstehenden Link.",
      title: "Meine BitBox01 wurde nicht erkannt"
    },
    getDevice: {
      link: {
        text: "Bestellen einer BitBox"
      },
      text: "Du kannst eine BitBox in unserem Online Shop bestellen:",
      title: "Wie bekomme ich ein Gert?"
    },
    internet: {
      text: "Ja, eine Internetverbindung ist erforderlich, um die Wallet zu synchronisieren, Transaktionen zu senden und die neuesten Wechselkurse abzurufen.",
      title: "Braucht diese Applikation eine Internet Verbindung?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Du kannst deine Konten auf einer neuen BitBox oder in unserem Backup-center wiederherstellen.",
      title: "Ich habe mein Gert verloren. Was nun?"
    },
    useWithoutDevice: {
      text: "Leider ist dies zum aktuellen Zeitpunkt nicht mglich. ",
      title: "Kann ich die App auch ohne Gert benutzen?"
    },
    welcome: {
      text: "Vielen Dank, dass du diese App benutzt. Sie wird von Shift Crypto in der Schweiz entwickelt. Wir freuen uns ber Anregungen und Fragen. Zgere nicht, uns zu kontaktieren.",
      title: "Willkommen in der BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Wenn du ein neues Telefon/Computer mit der BitBoxApp verwendest, musst du dich erneut mit den DApps verbinden. Anschlieend siehst du deine Coins wieder wie gewohnt auf der DApp.",
      title: "Ich sehe meine vorherigen Verbindungen nicht."
    },
    supportedNetworks: {
      text: "Derzeit wird nur das Ethereum-Mainnet mit WalletConnect in der BitBoxApp untersttzt. Um andere EVM-kompatible Netzwerke zu verwenden, verwende bitte das Rabby Browser-Extension Wallet.",
      title: "Welche Netzwerke werden untersttzt?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ist ein Kommunikationsprotokoll fr Web3-Anwendungen. Damit kannst du bequem eine Verbindung zu Ethereum basierten DApps und Web-Wallets herstellen, ohne eine Drittanbieter-App zu verwenden. Dies ist besonders ntzlich fr Android Nutzer der BitBoxApp.",
      title: "Was ist WalletConnect?"
    }
  }
};
const headerssync$g = {
  blocksSynced: "{{blocks}} Blcke synchronisiert\n"
};
const hiddenWallet$g = {
  info1HTML: "Zur glaubhaften Abstreitbarkeit kann eine versteckte Wallet erstellt werden, das auf einer <strong> anderen </strong> Gerte- und Wiederherstellungspasswort Kombination basiert.",
  info2HTML: "Gib das Gertepasswort und das Wiederherstellungspasswort ein, die du fr deine versteckte Wallet verwenden mchtest. Das Gertepasswort und das Wiederherstellungspasswort mssen sich von <strong> denen unterscheiden </strong> , die du fr dein primres Wallet verwendest.",
  passwordLabel: "Versteckte Wallet Passwort",
  passwordPlaceholder: "Bitte besttige das versteckte Wiederherstellungspasswort",
  pinLabel: "Verstecktes Gertepasswort",
  pinRepeatLabel: "Wiederhole das versteckte Gertepasswort",
  pinRepeatPlaceholder: "Bitte besttige das versteckte Gertepasswort",
  success: "Versteckte Wallet erfolgreich erstellt. Stecke die BitBox erneut ein und gib das versteckete Gertepasswort ein, um diese zu entsperren."
};
const initialize$g = {
  create: "Gertepasswort speichern",
  creating: "Gertekennwort wird eingestellt...",
  error: {
    e102: "Das Gertekennwort muss aus mindestens 4 Zeichen bestehen."
  },
  info: {
    description1: "Whle dein Gertekennwort. Dieses wird zum Entsperren deiner BitBox verwendet.",
    description2: "Du kannst Zahlen und Buchstaben verwenden. Lngere Passwrter sind in der Regel sicherer.",
    description3: "Wenn du das Gertepasswort vergisst, musst du dein Gert zurcksetzen und deine Wallet von deinem Backup wiederherstellen.",
    subtitle: "Jetzt legst du dein Gertepasswort fest",
    title: "Initialisierung deines Gertes"
  },
  input: {
    label: "Gertepasswort",
    labelRepeat: "Wiederhole das Gertepasswort",
    placeholderRepeat: "Bitte besttige das Gertepasswort"
  }
};
const invalidFormat$g = "Ungltiges Format";
const language$h = {
  title: "Sprache auswhlen"
};
const legacyhiddenwallet$g = {
  disable: "Versteckte Legacy Wallet deaktivieren",
  enable: "Versteckte Legacy Wallet aktivieren",
  successDisable: "Versteckte Legacy Wallet erfolgreich deaktiviert",
  successEnable: "Die versteckte legacy Wallet wurde erfolgreich aktiviert. Stecke deine BitBox erneut ein und gib das versteckte Gertepasswort ein, um auf die versteckte Wallet zuzugreifen."
};
const loading$g = "laden...";
const manageAccounts$a = {
  accountHidden: "Dieses Konto wurde aus deinen watch-only Konten ausgeblendet. Verbinde deine BitBox02 um es wieder anzuzeigen.",
  editAccount: "Bearbeiten",
  editAccountNameTitle: "Kontonamen bearbeiten",
  noAccounts: "Keine Konten gefunden",
  settings: {
    hideTokens: "Token ausblenden",
    showTokens: "Token anzeigen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Konten hinzufgen und aktivieren / deaktivieren",
  title: "Konten verwalten",
  watchAccount: "Konto merken",
  watchAccountDescription: "Dieses Konto ist Teil deines watch-only Kontos. Du kannst es mit diesem Schalter vor den watch-only Konten verstecken."
};
const mobile$b = {
  usingMobileDataWarning: "Mobile Datennutzung: Diese App downloaded ein paar hundert Megabytes an Blockchain Daten nachdem ein Konto geffnet wurde. Bitte verbinde dein Handy fr diesen einmaligen Download mit deinem Wifi. "
};
const newSettings$9 = {
  about: {
    appVersion: {
      title: "App-Version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Sperre den Zugriff zur App mit Displaysperre/Fingerabdruck.",
      title: "Displaysperre"
    },
    coinControl: {
      description: "Whle aus, welche UTXOs Teil einer Transaktion sind, um die Privatsphre zu verbessern."
    },
    customFees: {
      description: "Ermglicht es dir, beim Senden deine eigene Gebhr festzulegen."
    },
    torProxy: {
      description: "Stelle fr mehr Privatsphre eine Verbindung ber Tor her."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Diese zustzlichen Whrungen knnen auf Ihrer Kontoseite eingeschaltet werden.",
      title: "Aktive Whrungen"
    },
    darkmode: {
      description: "Aktiviere den dunklen Modus der BitBoxApp."
    },
    defaultCurrency: {
      description: "Whle deine Standardwhrung aus",
      title: "Standardwhrung"
    },
    enableAccount: {
      description: "Wenn du dein Konto deaktivierst, wird es weder in der Seitenleiste noch im Portfolio angezeigt. Du kannst es jederzeit von hier aus wieder aktivieren. Die Coins auf diesem Konto sind davon nicht betroffen und bleiben sicher.",
      title: "Konto aktivieren/deaktivieren"
    },
    hideAmounts: {
      description: "Zeigt einen Schalter zum Ausblenden deines Guthabens und Betrgen an, um deine Privatsphre zu verbessern, wenn du die App in der ffentlichkeit nutzt.",
      hideAmounts: "Betrge ausblenden",
      showAmounts: "Betrge anzeigen",
      title: "Ausblenden von Betrgen zulassen"
    },
    language: {
      description: "Welche Sprache die BitBoxApp verwenden soll.",
      title: "Sprache"
    },
    remebmerWallet: {
      name: "Wallet merken",
      warning: "Dies wird dein gemerktes Wallet entfernen. Um es wieder zu sehen musst du die BitBox02 fr dieses Wallet verbinden. Alle Coins auf diesem Wallet werden nicht beeinflusst. Mchtest du fortfahren?",
      warningTitle: 'Deaktiviere "Wallet merken"'
    },
    toggleSats: {
      description: "Aktiviere oder deaktiviere Satoshis."
    }
  }
};
const note$c = {
  input: {
    description: "(optional)",
    placeholder: "Notiz hinzufgen..."
  },
  title: "Notiz"
};
const notification$g = {
  newTxs_one: "Neue Transaktion in: {{accountName}}",
  newTxs_other: "{{count}} neue Transaktionen in: {{accountName}}"
};
const pairing$g = {
  aborted: {
    text: "Der Kopplungsprozess wurde von der Smartphone App abgebrochen.",
    title: "Abgebrochen"
  },
  button: "Mit Smartphone App koppeln",
  confirm: "Mchtest du deine BitBox wirklich koppeln? Danach wird dein Mobiltelefon zur Durchfhrung einer Transaktion unbedingt erforderlich sein.",
  connectOnly: {
    button: "Smartphone App verbinden",
    title: "Scanne den Code mit der Smartphone App. "
  },
  error: {
    text: "Etwas ist schief gelaufen. Bitte fang erneut an.",
    title: "Fehler"
  },
  pullFailed: {
    text: "Fehler beim Abrufen einer Nachricht von deinem Mobiltelefon ber den Relay-Server. Der Relay-Server ist mglicherweise offline. Wende dich an den Support.",
    title: "Laden fehlgeschlagen"
  },
  reconnectOnly: {
    button: "Smartphone App erneut verbinden"
  },
  scanningFailed: {
    text: "Das Handy konnte die Nachricht nicht scannen. Bitte versuche es erneut.",
    title: "Scannen fehlgeschlagen"
  },
  start: {
    hideAppQRCode: "QR Code ausblenden",
    revealAppQRCode: "QR Code anzeigen",
    step1: "Wenn du nicht ber die Smartphone App verfgst, kannst du den QR-Code fr den Apple App Store oder den Google Play Store scannen.",
    step2: "Scanne den Code mit der Smartphone App, die du im App Stores fr iOS und Android findst, wenn du nach 'Digital Bitbox 2FA' suchst."
  },
  started: {
    text: "Folge nun den Anweisungen in der mobilen App.",
    title: "Gut gemacht!"
  },
  success: {
    text: "Herzlichen Glckwunsch, du hast deine BitBox erfolgreich mit der mobilen App gekoppelt!",
    title: "Erfolg"
  },
  timeout: {
    text: "Der Kopplungsprozess ist nach 2 Minuten abgelaufen. Bitte versuche es erneut.",
    title: "Zeitberschreitung"
  },
  title: "Smartphone Kopplung"
};
const passphrase$a = {
  considerations: {
    button: "Backup-Hinweise",
    message: "Die Passphrase bietet zustzlichen Schutz fr dein Wallet-Backup (MicroSD oder 24 Wrter). Falls jemand Zugriff auf dein Backup hat, bentigt er zustzlich die Passphrase, um auf dein Wallet zuzugreifen. \n\nDies bedeutet jedoch, dass du <strong>sowohl die Passphrase als auch das Wallet Backup</strong> bentigst, um dein Passphrase-Wallet wiederherzustellen, falls deine BitBox02 verloren oder kaputt geht. Falls du die Passphrase verlierst, verlierst du auch Zugriff auf alle Coins in diesem Wallet.\n\nErwge, deine Passphrase an einem anderen Ort als dein Backup zu sichern. Falls jemand dein Backup findet, fehlt ihm immer noch die Passphrase. ",
    title: "Backup-Hinweise"
  },
  disable: "Passphrase deaktivieren",
  disableInfo: {
    button: "Deaktivieren",
    message: "Nachdem du die Passphrase deaktiviert hast, wirst du nach dem Entsperren deiner BitBox02 nicht mehr aufgefordert, eine Passphrase einzugeben. Daher wirst du deine Standard-Wallet aufrufen.\n\nAlle Coins in deiner Passphrase-Wallet befinden sich weiterhin in dieser Wallet, aber du kannst nicht darauf zugreifen, weil du nach dem Entsperren deiner BitBox02 deine Standard-Wallet ffnest.\n\nUm wieder auf deine Passphrase-Wallet zuzugreifen, aktiviere einfach wieder die Passphrase-Funktion und gib die entsprechende Passphrase ein, nachdem du die BitBox02 entsperrt hast.\n\n<strong>Tipp:</strong> Du kannst deine ursprngliche Wallet immer noch ffnen, indem du die Passphrase leer lsst."
  },
  enable: "Passphrase aktivieren",
  error: {
    e104: "nderung der Passphrase-Einstellung wurde abgebrochen. "
  },
  how: {
    button: "So sieht es aus",
    message: "Eine Passphrase funktioniert nicht wie ein Passwort, wie du es kennst. Wenn du deine Passphrase falsch eingibst, wirst du nicht benachrichtigt. Das liegt daran, dass <strong>jede Passphrase eine andere, aber gltige Wallet</strong> erstellt. Das heit, du kannst mehrere Passphrasen fr so viele Wallets verwenden, wie du willst. Auf jede Wallet kannst du aber nur zugreifen, wenn du die entsprechende Passphrase eingibst.\n\nWenn du deine BitBox02 einsteckst, wirst du wie blich nach dem Gertepasswort gefragt. Danach wirst du aufgefordert, eine Passphrase auf dem Gert einzugeben.\n\nNachdem du die Passphrase eingegeben hast, wird dir die eingegebene Passphrase angezeigt. So kannst du besttigen, dass du sie richtig eingegeben hast.",
    title: "Wie funktioniert die Passphrase?"
  },
  intro: {
    message: "Eine Passphrase bietet zustzliche Sicherheit fr deine Wallet.\nHier erfhrst du, wie sie funktioniert.",
    title: "Passphrase einrichten"
  },
  progressDisable: {
    message: "Besttige auf deiner BitBox, dass du die optionale Passphrase <strong>deaktivieren</strong> mchtest.",
    title: "Besttige am Gert"
  },
  progressEnable: {
    message: "Besttige auf deiner BitBox, dass du die optionale Passphrase <strong>aktivieren</strong> mchtest.",
    title: "Besttige am Gert"
  },
  successDisabled: {
    message: "Optionale Passphrase <strong>erfolgreich aktiviert</strong>!\nVon nun an wirst du dazu aufgefordert, eine Passphrase anzugeben.",
    messageEnd: "Bitte stecke die BitBox02 jetzt wieder ein.",
    title: "Passphrase aktiviert"
  },
  successEnabled: {
    message: "Optionale Passphrase <strong>erfolgreich deaktiviert</strong>!\nVon nun an wirst du nicht mehr dazu aufgefordert, eine Passphrase anzugeben.",
    messageEnd: "Bitte stecke deine BitBox02 jetzt wieder ein.",
    tips: "Tipps",
    tipsList: [
      "Wir empfehlen, zuerst einen kleinen Betrag in die Passphrase-Wallet zu senden. Dann musst du die BitBox02 aus- und wieder einstecken und dein Passwort und deine Passphrase eingeben. Wenn du die Passphrase richtig eingegeben hast, solltest du die Coins in deinem Wallet sehen.",
      "Wenn du deine ursprngliche Wallet ohne Passphrase betreten willst, kannst du das immer noch tun, indem du nichts eingibst, wenn du zur Eingabe der Passphrase aufgefordert wirst. Oder du kannst die Passphrase-Funktion deaktivieren."
    ],
    title: "Passphrase deaktiviert"
  },
  summary: {
    button: "Passphrase aktivieren",
    title: "bersicht",
    understand: "Ich verstehe, wie die Passphrase funktioniert und welche Risiken damit verbunden sind.",
    understandList: [
      "Die Passphrase ist eine zustzliche Sicherheitsmanahme fr mein Backup.",
      "Wenn ich eine andere Passphrase eingebe, wird immer ein anderes Wallet erstellt.",
      "Um mein Wallet wiederherzustellen bentige ich <strong>sowohl die Passphrase als auch das Backup</strong>.",
      "Wenn ich meine Passphrase vergesse, habe ich <strong>keinen Zugriff mehr auf meine Coins</strong>."
    ]
  },
  what: {
    button: "Verstehe, wie es funktioniert",
    message: "Eine Wallet wird aus einer sehr groen Zufallszahl erstellt (abgeleitet), die auch als Seed bezeichnet wird. Dieser Seed wird erstellt, wenn du deine BitBox02 zum ersten Mal einrichtest, und mit der microSD-Karte oder 24 Wrtern gesichert. Jeder, der Zugriff auf den Seed hat, hat die volle Kontrolle ber das Geld auf dieser Wallet.\n\nEine Passphrase ist ein <strong>optionales Geheimnis</strong>, das zum Seed hinzugefgt wird. Wenn du eine Passphrase verwendest, erstellt jede Passphrase eine neue Wallet, die auf dem Seed + Passphrase (optionales Geheimnis) basiert. Eine Passphrase kann alles sein: Buchstaben, Wrter, Sonderzeichen oder auch leer. Die Standard-Wallet wird aus dem Seed und der leeren Passphrase erstellt.\n\nDie Passphrase ist Teil des BIP39-Standards, was bedeutet, dass sie mit allen Wallets kompatibel ist, die denselben Standard untersttzen.",
    title: "Was ist eine Passphrase?"
  },
  why: {
    button: "Warum sollte man eine Passphrase benutzen?",
    message: 'Die BitBox02 schtzt den Seed vor der Extraktion aus dem Gert selbst, doch das Backup (microSD-Karte oder 24 Wrter) gibt vollen Zugriff auf die Wallet. Deshalb sollte es an einem sicheren Ort aufbewahrt werden!\n\nDa eine Passphrase eine neue Wallet mit deinem bestehenden Seed erstellt, bentigt die Passphrase-Wallet <strong>sowohl dein Backup als auch deine Passphrase zur Wiederherstellung</strong>. Das hat den Vorteil, dass jemand, der dein Backup findet, trotzdem die Passphrase braucht, um auf die Passphrase-Wallet zuzugreifen.\n\nAuerdem kannst du mit der Passphrase-Funktion mehrere Wallets auf demselben Gert erstellen, also "versteckte Wallets" zustzlich zur Standard-Wallet.',
    title: "Warum sollte man eine Passphrase benutzen?"
  }
};
const password$g = {
  show: "{{label}} anzeigen",
  warning: {
    caps: "WARNUNG: Feststelltaste  () ist aktiviert",
    paste: 'Um Text einzufgen, aktiviere "Anzeigen" {{label}}".'
  }
};
const random$h = {
  button: "Zufallszahl generieren",
  description: "Deine BitBox hat die folgende {{bits}}-Bit-Zufallszahl generiert:"
};
const receive$i = {
  bitsuranceWarning: "Dies ist ein versichertes Konto, das heit, es kann nur an Native Segwit empfangen. Dadurch wird verhinderst, dass du versehentlich an Wrapped Segwit oder Taproot empfngst, welche nicht versichert sind.",
  changeScriptType: "Adresstyp ndern",
  label: "Meine Adresse",
  onlyThisCoin: {
    description: "Um andere Token empfangen zu knnen, aktiviere diese in den Einstellungen. Solltest du Token empfangen, welche die BitBoxApp nicht untersttzt, hast du mglicherweise keinen Zugang mehr zu diesen. ",
    warning: "Stelle sicher, dass du nur {{coinName}} auf diese Adresse sendest."
  },
  scriptType: {
    p2tr: "Taproot (neuestes Format)",
    p2wpkh: "Native-Segwit (standard)",
    "p2wpkh-p2sh": "Wrapped-Segwit (kompatibles Format)"
  },
  selectAccount: "Konto auswhlen",
  showFull: "Adresse auf BitBox besttigen",
  taprootWarning: "Hinweis: Taproot ist ein neues Adressformat und noch nicht weit verbreitet. Gelder, die ber Taproot-Adressen eingehen, sind mglicherweise nicht in Watch-Only-Wallets von Drittanbietern sichtbar. Viele Wallets und Brsen sind noch nicht in der Lage, an Taproot-Adressen zu senden.",
  title: "{{accountName}} empfangen",
  verify: "Adresse sicher verifizieren",
  verifyBitBox01: "Adresse auf Smartphone berprfen",
  verifyBitBox02: "Adresse auf BitBox02 berprfen",
  verifyInstruction: "Bitte besttige, dass die folgende Adresse mit der Adresse auf deinem Gert bereinstimmt.",
  warning: {
    secureOutput: 'Bitte koppele deine BitBox mit deinem Smartphone, um eine sichere Adressberprfung zu ermglichen. Klicke in der Seitenleiste auf "Gert verwalten".'
  }
};
const reset$g = {
  description: "Alle Daten auf dem Gert werden gelscht. Inklusive deiner Private-Keys!",
  notReset: "Gert NICHT zurck gesetzt.",
  title: "Gert in Werkszustand zurcksetzen",
  understand: "Ich habe ein Backup und kenne mein Wiederherstellungskennwort",
  understandBB02: "Ich habe ein valides Backup"
};
const securityInformation$g = {
  create: {
    description1: "Bitte richte dein Gert in einer sicheren Umgebung ein, sodass niemand sehen kann, welches Passwort du whlst.",
    description2: "Whrend der Einrichtung wirst du aufgefordert, zwei verschiendene Passworter zu erstellen. ",
    description3: "Das erste Passwort ist das <strong> Gertepasswort </strong>, welches deine BitBox entsperrt und spter gendert werden kann.",
    description4: "Das zweite ist das <strong> Wiederherstellungspasswort </strong>, mit dem dein Wallet gesichert wird. Dieses Passwort kann spter nicht gendert werden",
    description5: "Die von dir erstellte Wallet wird in einer Datei auf der mitgelieferten microSD Karte gespeichert. Dieses Backup kann im Notfall verwendet werden, um den Zugriff auf deine Coins mithilfe deines <strong> Wiederherstellungskennworts </strong> wieder herzustellen.",
    title: "Sicherheitsinformationen"
  },
  restore: {
    description1: "Du wirst aufgefordert, die Micro-SD-Karte einzustecken, die du zum Speichern deines Backups verwendet hast.",
    description2: "Um dein Gert wiederherzustellen, bentigst du dein Wiederherstellungskennwort.",
    description3: "Bitte sei bei der Eingabe des Wiederherstellungskennworts aufmerksam. Jedes von dir eingegebene Passwort erstellt eine gltige Wallet, welche dann aber leer sind. Gibst du also ein falsches Kennwort ein, wird dir nicht die erwartete Wallet, sondern eine andere Wallet angezeigt.",
    title: "Sicherheitsinformationen"
  }
};
const seed$g = {
  agreements: {
    "funds-access": "Ich kann NICHT auf mein Geld zugreifen, wenn ich mein Wiederherstellungspasswort vergessen habe.",
    "password-change": "Ich kann das Wiederherstellungspasswort spter NICHT ndern.",
    "password-required": "Ich brauche mein Wiederherstellungspasswort, um meine Wallet von meinem Backup wiederherzustellen."
  },
  create: "Neue Wallet erstellen",
  creating: "Wallet wird erstellt",
  description: "Ich besttige, dass ich folgendes zu Kenntnis genommen habe:",
  error: {
    e102: "Das Passwort muss aus mindestens 4 Zeichen bestehen.",
    e200: "Du musst eine microSD Karte in deine BitBox einsetzen, damit ein Backup deiner Wallet erstellt und auf der Micro-SD Karte gespeichert werden kann."
  },
  info: {
    button: " Wiederherstellungspasswort festlegen",
    description1: "Steck die microSD Karte in die BitBox ein.",
    description2: 'Whle ein Wiederherstellungspasswort fr die Wallet und klicke "Wiederherstellungspasswort speichern".',
    description3: "Das Backup auf der microSD Karte, zusammen mit deinem Wiederherstellungspasswort, ist die einzige Methode, wie deine Wallet (= der Zugang zu deinen Coins) wieder hergestellt werden kann, falls deine BitBox gestohlen wird oder du dein Gertepasswort vergisst!",
    description4: "Das Wiederherstellungspasswort lsst sich spter nicht ohne Weiteres ndern. Dazu msstest du dein Coins auf ein neues Konto transferieren. Deswegen solltest du von Anfang an ein gutes Passwort whlen.",
    title: "Neue Wallet erstellen "
  },
  password: {
    label: "Wiederherstellungspasswort",
    repeatPlaceholder: "Wiederhestellungspasswort wiederholen"
  },
  walletName: {
    label: "Wallet Name"
  }
};
const seedRestore$g = {
  error: {
    e200: "Um eine Wallet von einem Backup wieder herzustellen wird deine microSD Karte bentigt."
  },
  info: {
    description1: 'Stecke die microSD-Karte in die BitBox ein und klicke auf "Weiter".',
    description2: 'Whle ein Backup aus und klicke "Wiederherstellen"',
    description3: "Gib das Wiederherstellungspasswort ein",
    description4: "Du musst besttigen, dass du zu Kenntnis genommen hast, dass ein falsches Passwort eine andere Wallet erstellt/ffnet.",
    title: "Wie wird eine Wallet von einem Backup wieder hergestellt?"
  }
};
const send$i = {
  abort: "Die Transaktion wurde abgebrochen",
  address: {
    label: "Empfangsadresse",
    placeholder: "Adresse eingeben oder scannen"
  },
  amount: {
    label: "Betrag",
    placeholder: "Betrag eingeben"
  },
  availableBalance: "Kontostand",
  button: "Prfen",
  coincontrol: {
    address: "Adresse",
    outpoint: "ID",
    title: "Outputs whlen"
  },
  confirm: {
    "selected-coins": "Ausgewhlte Coins",
    title: "Besttige und sende die Transaktion",
    total: "Gesamt"
  },
  error: {
    erc20InsufficientGasFunds: "Es scheint, als httest du nicht genug Ether, um fr diese ERC20-Transaktion zu bezahlen. Bitte vergewissere dich, dass du genug Ether in deiner Wallet hast.",
    feeTooLow: "Gebhr zu niedrig",
    feesNotAvailable: "Gebhren konnten nicht geschtzt werden",
    insufficientFunds: "Unzureichende Mittel",
    invalidAddress: "ungltige Adresse",
    invalidAmount: "ungltige Menge",
    invalidData: "ungltige Daten"
  },
  fee: {
    customPlaceholder: "Betrag eingeben",
    label: "Netzwerk Gebhr",
    placeholder: "Nicht verfgbar"
  },
  feeTarget: {
    customLabel: "Gebhren-Rate",
    customLabel_eth: "Gas-Preis",
    description: {
      economy: "4 Stunden (24 Blcke)",
      economy_eth: "30 Minuten oder weniger",
      economy_ltc: "1 Stunde (24 Blcke)",
      high: "20 Minuten (2 Blcke)",
      high_eth: "30 Sekunden oder weniger",
      high_ltc: "5 Minuten (2 Blcke)",
      low: "2 Stunden (12 Blcke)",
      low_eth: "5 Minuten oder weniger",
      low_ltc: "30 Minuten (12 Blcke)",
      normal: "1 Stunde (6 Blcke)",
      normal_eth: "2 Minuten oder weniger",
      normal_ltc: "15 Minuten (6 Blcke)"
    },
    estimate: "Geschtzte Wartezeit:",
    label: {
      custom: "Eigene Gebhr",
      economy: "Sehr niedrig",
      high: "Hoch",
      low: "Niedrig",
      normal: "Normal"
    },
    placeholder: "Gebhr wird berechnet...."
  },
  maximum: "Alles senden",
  maximumSelectedCoins: "Ausgewhlte Coins senden",
  noFeeTargets: "Gebhrenschtzungen sind derzeit nicht verfgbar. Bitte versuche es spter erneut oder gib eine benutzerdefinierte Gebhr ein.",
  priority: "Prioritt",
  scanQR: "QR Code scannen",
  signprogress: {
    description: "Dies ist eine Transaktion, die viele Daten enthlt. Um die Transaktion vollstndig zu signieren, wirst du aufgefordert, {{steps}} mal auf der BitBox zu besttigen.",
    label: "Fortschritt"
  },
  success: "Die Transaktion wurde signiert und versendet.",
  title: "{{accountName}} senden",
  toggleCoinControl: "Coin Control",
  transactionDetails: "Transaktionsdetails"
};
const settings$h = {
  about: "ber die App",
  accounts: "Konten",
  advancedSettings: "Erweiterte Einstellungen",
  appearance: "Ansicht",
  electrum: {
    add: "Server hinzufgen",
    "add-server": "Hinzufgen",
    check: "berprfen",
    checkFailed: "Fehlgeschlagen",
    checkSuccess: "Verbindung zu {{host}} wurde erfolgreich hergestellt",
    checking: "berprfen",
    "download-cert": "Remote-Zertifikat herunterladen",
    "remove-server": "Entfernen",
    removeConfirm: "Entfernen {{server}}?",
    reset: "In Werkszustand zurcksetzen",
    resetConfirm: "Mchtest du alle Server entfernen und die Standardserver installieren?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Gib den Endpunkt ein",
    step2: "2",
    "step2-text": "Gib ein Zertifikat der Zertifikatskette des Servers ein. Lade alternativ das Remote-Zertifikat herunter und vergleiche es visuell.",
    "step2-text-tcp": "berspringe diesen Schritt, wenn du kein TLS verwenden mchtest.",
    step3: "3",
    "step3-text": "berprfe die Verbindung und fge den Server hinzu.",
    step4: "4",
    "step4-text": "Starte die BitBoxApp neu. Wenn du die Standardserver nicht entfernst, wird dein eigener Node als Redundanz hinzugefgt.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Coin Control aktivieren",
    electrum: {
      description: "Du kannst dich mit deinem eigenen Electrum-Fullnode verbinden.",
      title: "Eigenen Full Node verbinden"
    },
    fee: "Eigene Gebhr aktivieren",
    setProxyAddress: "Proxy Adresse eingeben",
    title: "Erweiterte Einstellungen",
    useProxy: "Tor Proxy aktivieren",
    useSats: "BTC-Werte in Satoshis anzeigen"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Neues Update verfgbar",
    title: "Info",
    "up-to-date": "Deine App ist auf dem neuesten Stand",
    version: "App-Version"
  },
  restart: "Bitte starte die BitBoxApp neu, damit die nderungen wirksam werden.",
  services: {
    title: "Dienste"
  },
  success: "Bitte trenne die BitBox und stecke sie wieder ein, damit die nderungen wirksam werden.",
  title: "Einstellungen"
};
const setup$g = "Gertepasswort festlegen";
const sidebar$h = {
  buy: "Krypto kaufen",
  device: "Gert verwalten",
  insurance: "Versicherung",
  leave: "Verlassen",
  settings: "Einstellungen"
};
const success$n = {
  create: {
    info1: "Ein Backup deiner Wallet wurde sicher auf der microSD Karte gesichert. Entferne die Karte und bewahre diese an einem sicheren Ort auf.",
    info2: "Du hast ein Gertepasswort erstellt, mit dem die BitBox entsperrt wird.",
    info3: "Du hast ein Wiederherstellungspasswort fr deine Wallet erstellt, das deine Coins freigibt und dein Backup wiederherstellt.",
    summary: "Hier ist eine Zusammenfassung von dem, was du getan hast:",
    title: "Erfolg"
  },
  getstarted: "Loslegen",
  restore: {
    summary: "Du hast erfolgreich deine Wallet aus einem Backup wiederhergestellt.",
    title: "Erfolg"
  }
};
const transaction$h = {
  confirmation: "Besttigungen",
  details: {
    activity: "Aktivitt",
    address: "Adresse",
    amount: "Betrag",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Fiatbetrag",
    fiatAtTime: "Fiat zur Transaktionszeit",
    status: "Status",
    title: "Transaktionsdetails",
    type: "Typ"
  },
  explorer: "Transaktions ID",
  explorerTitle: "In externem Block Explorer ffnen.",
  fee: "Gebhr",
  fiatHistorical: "Historisch",
  gas: "Gas",
  note: {
    edit: "Notiz bearbeiten",
    save: "Notiz speichern"
  },
  pending: "Ausstehende Transaktion",
  size: "Gre",
  status: {
    complete: "Besttigt",
    failed: "Fehlgeschlagen",
    pending: "Ausstehend"
  },
  tx: {
    received: "Empfangen an",
    sent: "Gesendet an"
  },
  vsize: "Virtuelle Gre",
  weight: "Gewicht"
};
const transactions$g = {
  errorLoadTransactions: "Beim Laden der Transaktionen ist ein Fehler aufgetreten",
  placeholder: "Noch keine Transaktionen."
};
const unknownError$g = "Ein unbekannter Fehler ist aufgetreten {{errorMessage}}\n\n";
const unlock$g = {
  description: "Gib dein Gertepasswort ein um dein Gert zu entsperren.",
  error: {
    e109_normal: "Gertepasswort inkorrekt.  {{remainingAttempts}} Versuche verbleibend, bevor sich das Gert in den Werkszustand zurcksetzt. ",
    e109_touch: "$t(unlock.error.e109_normal) Beim nchsten Loginversuch musst du die LED lange halten.",
    e113: "Aufgrund zu vieler Loginversuche musst du beim nchsten Versuch die LED 4 Sekunden lang drcken."
  },
  input: {
    label: "Gertepasswort",
    placeholder: "Gib dein Gertepasswort ein um das Gert zu entsperren."
  },
  unlocking: "Entsperren..."
};
const upgradeFirmware$h = {
  button: "Firmware aktualisieren",
  description: "Mchtest du von Version  {{currentVersion}} zu Version {{newVersion}} upgraden?",
  label: "Deine BitBox bentigt eine Firmware Aktualisierung.",
  locked: "Um von Version  {{currentVersion}} zu Version  {{newVersion}} upzugraden, drcke die LED bitte lange. ",
  title: "Firmware upgraden",
  unlocked: "Der Bootloader ist gesperrt. Um fortzufahren:",
  unlocked1: "Steck deine BitBox aus und dann wieder ein.",
  unlocked2: "Die LED wird aufleuchten, wenn deine BitBox wieder eingesteckt ist.",
  unlocked3: "Tippe auf die LED, wenn diese aufleuchtet."
};
const walletConnect$b = {
  connect: {
    button: "Verbinden",
    dappLabel: "Gebe die URI-Adresse der Dapp ein",
    invalidPairingUri: "Ungltige Pairing-URI"
  },
  dashboard: {
    allSessions: "Alle Sitzungen",
    disclaimer: "Walletconnect ist ein Protokoll zur Verbindung mit Ethereum basierten Dapps. Diese Dapps werden von Drittanbieterdiensten betrieben. Stelle daher nur eine Verbindung zu Dapps her, denen du vertraust, und stelle sicher, dass du bei einer Transaktion immer weit, was du signierst.",
    newConnection: "Neue Verbindung",
    noConnectedSessions: "Derzeit sind keine Konten mit Dapps verbunden."
  },
  invalidPairingChain: "Fehler beim Genehmigen des Pairing. Bitte stelle sicher, dass du eines der untersttzten Netzwerke verwendest: {{chains}}",
  pairingRequest: {
    approve: "Verbindung erlauben",
    reject: "Ablehnen",
    title: "Neue Verbindungsanfrage von"
  },
  pairingSuccess: "Dapp erfolgreich verbunden. Du kannst auf der Dapp-Website fortfahren.",
  signingRequest: {
    account: "Konto",
    chain: "Netzwerk",
    dapp: "Dapp",
    data: "Daten",
    dataParsingError: "Parsen der Daten fehlgeschlagen",
    decodeError: "Nachricht konnte nicht dekodiert werden",
    method: {
      sendTransaction: "Transaktion signieren und senden",
      signMessage: "Nachricht signieren",
      signTransaction: "Transaktion signieren",
      signTypedData: "Signiere eingegebene Daten"
    },
    successfullySigned: "Anfrage erfolgreich signiert",
    walletConnectRequest: "WalletConnect Anfrage"
  },
  useNewUri: "Dieser URI wurde bereits fr den Verbindungsversuch verwendet. Bitte verwende eine neue URI.",
  walletConnect: "WalletConnect"
};
const warning$m = {
  receivePairing: 'Bitte aktiviere 2FA, um Adressen sicher zu verifizieren. Klicke dazu auf "Gerte verwalten" im Men auf der linken Seite.',
  sdcard: "Bewahre deine microSD Karte separat von deiner BitBox auf. Die microSD Karte wird nur bentigt, wenn du deine Backups verwalten willst. Fr den normalen Betrieb ist sie nicht erforderlich.",
  sendPairing: 'Bitte koppele deine BitBox mit einem Smartphone um Transaktionen sicher verifizieren zu knnen. Klicke dazu auf "Gerte verwalten" im Men auf der linken Seite.'
};
const welcome$g = {
  connect: "Verbinde eine BitBox02",
  getStarted: "Beginnen wir mit der Installation der Firmware auf deiner BitBox02.",
  insertBitBox02: "Tippe dann auf die BitBox02 zum weiter machen. ",
  insertDevice: "Bitte verbinde dein Gert, um loszulegen",
  title: "Willkommen"
};
const appTranslationsDE = {
  account: account$g,
  accountInfo: accountInfo$g,
  accountSummary: accountSummary$g,
  addAccount: addAccount$h,
  aopp: aopp$a,
  app: app$g,
  auth: auth$a,
  backup: backup$g,
  bb02Bootloader: bb02Bootloader$g,
  bitbox: bitbox$g,
  bitbox02Interact: bitbox02Interact$g,
  bitbox02Settings: bitbox02Settings$g,
  bitbox02Wizard: bitbox02Wizard$g,
  bitsurance: bitsurance$9,
  bitsuranceAccount: bitsuranceAccount$9,
  blink: blink$g,
  bootloader: bootloader$g,
  button: button$l,
  buy: buy$c,
  changePin: changePin$g,
  chart: chart$c,
  checkSDcard: checkSDcard$g,
  clickHere: clickHere$g,
  confirm: confirm$i,
  confirmOnDevice: confirmOnDevice$g,
  connectKeystore: connectKeystore$a,
  darkmode: darkmode$a,
  device: device$g,
  deviceLock: deviceLock$g,
  deviceSettings: deviceSettings$g,
  deviceTampered: deviceTampered$g,
  dialog: dialog$h,
  error: error$c,
  fiat: fiat$i,
  footer: footer$i,
  generic: generic$c,
  genericError: genericError$g,
  goal: goal$g,
  guide: guide$h,
  headerssync: headerssync$g,
  hiddenWallet: hiddenWallet$g,
  initialize: initialize$g,
  invalidFormat: invalidFormat$g,
  language: language$h,
  legacyhiddenwallet: legacyhiddenwallet$g,
  loading: loading$g,
  manageAccounts: manageAccounts$a,
  mobile: mobile$b,
  newSettings: newSettings$9,
  note: note$c,
  notification: notification$g,
  pairing: pairing$g,
  passphrase: passphrase$a,
  password: password$g,
  random: random$h,
  receive: receive$i,
  reset: reset$g,
  securityInformation: securityInformation$g,
  seed: seed$g,
  seedRestore: seedRestore$g,
  send: send$i,
  settings: settings$h,
  setup: setup$g,
  sidebar: sidebar$h,
  success: success$n,
  transaction: transaction$h,
  transactions: transactions$g,
  unknownError: unknownError$g,
  unlock: unlock$g,
  upgradeFirmware: upgradeFirmware$h,
  walletConnect: walletConnect$b,
  warning: warning$m,
  welcome: welcome$g
};
const account$f = {
  disconnect: "Connection lost. Retrying",
  "export": "Export",
  exportTransactions: "Export transactions to downloads folder as CSV file",
  fatalError: "There was an unexpected error.",
  incoming: "Incoming",
  initializing: "Getting information from the blockchain",
  insuranceExpired: "<strong>Account no longer insured</strong>\n\nThe insurance plan for this account has been modified.\nPlease check the insurance page for details.",
  insured: "Insured account",
  maybeProxyError: "Tor proxy enabled. Ensure that your Tor proxy is running properly, or disable the proxy setting.",
  reconnecting: "Lost connection, trying to reconnect",
  syncedAddressesCount: "Scanned {{count}} addresses",
  uncoveredFunds: "You have coins on the following uncovered address types of your <strong>{{name}}</strong> account: {{uncovered}}.\nSince the account is insured, only coins received via the <strong>Native Segwit</strong> address type are covered. Coins on different address types, even if they are on the same account, are not insured.\nPlease move all your coins from the unsupported address types to the <strong>Native Segwit</strong> address type, so all your coins on this account are insured.",
  uncoveredFundsLink: "Follow this guide on how to move your coins.",
  warning: "Warning!"
};
const accountInfo$f = {
  address: "Address",
  buyCTA: {
    buy: "Buy {{unit}}",
    buyCrypto: "Buy Crypto",
    information: {
      looksEmpty: "Looks like this wallet is empty.",
      start: "Get started by depositing some coins to the wallet or buying directly in the BitBoxApp."
    }
  },
  extendedPublicKey: "Extended public key",
  label: "Account info",
  scriptType: "Script type",
  title: "Account information",
  verify: "Verify on device",
  xpubTypeChangeBtn: {
    p2pkh: "View legacy P2PKH extended public key",
    p2tr: "View Taproot",
    p2wpkh: "View Native Segwit",
    "p2wpkh-p2sh": "View older Segwit extended public key"
  },
  xpubTypeInfo: "Currently displaying {{scriptType}} extended public key ({{current}} of {{numberOfXPubs}})"
};
const accountSummary$f = {
  availableBalance: "Available balance",
  balance: "Balance",
  exportSummary: "Export accounts summary to downloads folder as CSV file",
  fiatBalance: "Fiat balance",
  name: "Account name",
  noAccount: "There are no accounts to show.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "My portfolio",
  total: "Total",
  transactionHistory: "Transaction history"
};
const addAccount$g = {
  chooseName: {
    nextButton: "Add account",
    step: "Name account",
    title: "Name your account"
  },
  selectCoin: {
    nextButton: "Next",
    step: "Select coin",
    title: "Select cryptocurrency"
  },
  success: {
    addAnotherAccount: "Add another account",
    message: "<strong>{{accountName}}</strong> has now been added to your accounts.",
    nextButton: "Done",
    step: "Finished",
    title: "Account added"
  },
  title: "Add account"
};
const aopp$9 = {
  addressRequest: "{{host}} is requesting a receiving address.",
  addressRequestWithLogo: "is requesting a receiving address",
  banner: "Address request in progress. Please connect your device to continue.",
  errorTitle: "Error during address request ",
  labelAddress: "Address",
  labelMessage: "Message",
  reverifyInfoText: "Verify address",
  signing: "To proceed, sign message on your BitBox02",
  success: {
    message: "Proceed on {{host}}",
    title: "Address successfully sent"
  },
  syncing: "Syncing the account, please wait.",
  title: "Address request"
};
const app$f = {
  upgrade: "A new version of this app is available! Please upgrade from {{current}} to {{version}}."
};
const auth$9 = {
  authButton: "Authenticate",
  title: "Please authenticate to continue"
};
const backup$f = {
  check: {
    checking: "Checking backup",
    confirmTitle: "Check backup",
    notOK: "Backup does NOT match the wallet.",
    ok: "Backup matches the wallet.",
    password: {
      label: "Recovery password",
      placeholder: "Recovery password",
      showLabel: "recovery password"
    },
    success: "Successfully verified backup:",
    title: "Check backup"
  },
  create: {
    alreadyExists: "You already have a valid backup. Do you wish to re-create it?",
    fail: "Creating the backup FAILED!",
    info: "Please enter the recovery password of the current wallet for verification.",
    name: {
      label: "Backup name",
      placeholder: "Please name the backup"
    },
    password: {
      label: "Recovery password",
      placeholder: "Please enter your recovery password"
    },
    title: "Create backup",
    verificationFailed: "The recovery password does NOT MATCH the current wallet. The backup has been created. Please use 'Check backup' to verify your recovery password again."
  },
  description: "Select <strong>wallet backup file</strong>",
  insert: "Please insert the microSD card to manage backups.",
  insertButton: "I have inserted the microSD card",
  list: "Your microSD card backups",
  noBackups: "There are no backups on this microSD card.",
  restore: {
    confirmTitle: "Restore backup",
    error: {
      e200: "microSD card not found",
      general: "Error restoring the backup"
    },
    password: {
      label: "Recovery password or hidden recovery password",
      placeholder: "Recovery password",
      repeatPlaceholder: "Repeat recovery password",
      showLabel: "Recovery password"
    },
    restoring: "Restoring backup",
    selectedBackup: "<strong>{{backupName}}</strong> created on {{createdDateTime}} will be restored.",
    subtitle: "Please select backup to continue",
    title: "Restore",
    understand: "I understand that an incorrect recovery password will create a different wallet"
  },
  showMnemonic: {
    description: "You will be presented with your recovery words on your BitBox02, which form a backup of your wallet. Write them down on paper.\n\n<strong>Do not store them digitally or take pictures of it.</strong>\n\n<strong>Do not say the words out loud.</strong>\n\n<strong>This backup is not password-protected.</strong>\n\nAfterwards, you will be asked to confirm each word.",
    title: "Show recovery words",
    warning: "<strong>Never share your recovery words with anyone.</strong> Your recovery words give full access to your wallet. If someone is asking you for your recovery words, it's a scammer, do not share them!"
  },
  title: "Manage backups"
};
const bb02Bootloader$f = {
  abort: "Don't upgrade  take me back",
  abort_noUpgrade: "Take me back",
  advanced: {
    label: "Advanced settings",
    toggleShowFirmwareHash: "Show the firmware hash every time on startup"
  },
  flipscreen: "Flip screen",
  orientation: "Device oriented the wrong way?",
  success: "Upgrade successful! Continuing in {{rebootSeconds}} seconds...",
  success_install: "Installation successful! Continuing in {{rebootSeconds}} seconds..."
};
const bitbox$f = {
  error: {
    e10000: "Current device password incorrect.",
    e10001: "Failed to replace device password",
    e102: "The password must consist of at least 4 characters.",
    e112: "Hidden device password cannot be the same as the main device password."
  }
};
const bitbox02Interact$f = {
  confirmDate: "Confirm today's date on your BitBox02",
  confirmDateText: "This date will be used to create your backup.",
  confirmName: "Confirm name on BitBox02",
  confirmWords: "Write down the {{amount}} recovery words from your BitBox02",
  confirmWordsText: "After that the BitBox02 asks you to confirm each word to verify that the backup is correct.",
  followInstructions: "Please follow the instructions on your BitBox02.",
  followInstructionsMnemonic: "Follow the instructions on your BitBox02 to enter the recovery words from your backup and restore your wallet.",
  followInstructionsMnemonicTitle: "Restore from recovery words"
};
const bitbox02Settings$f = {
  deviceName: {
    current: "Current device name",
    error: "Device name could not be set",
    error_104: "Confirming device name was aborted on device.",
    input: "BitBox02 name",
    placeholder: "New device name",
    title: "Set BitBox02 name"
  },
  gotoStartupSettings: {
    description: "This will reboot your BitBox02 and enter the startup settings.",
    title: "Go to startup settings"
  }
};
const bitbox02Wizard$f = {
  advanced: {
    button: "Advanced options",
    outOfDate: "Firmware out of date for this feature",
    seed12WordInfo: "Please note that the number of words cannot be changed after creating the wallet.",
    seed12WordLabel: "Create 12-word instead of 24-word seed",
    seed12WordText: "By default the BitBox02 uses a 24-word seed. Both seed lengths are secure against brute forcing in practice. Some users may prefer the convenience of the 12-word seed instead.",
    skipSDCardLabel: "Skip microSD card backup and write down recovery words instead",
    skipSDCardText: "You always have the option to create a microSD card backup or write your recovery words after setup. This can be done from settings.",
    title: "Advanced backup options"
  },
  attestationFailed: "Genuine check failed, which could be due to restarting the app while the device was waiting for user input. Please reconnect and try again. Please contact support@bitbox.swiss if this persists.",
  backup: {
    point1: "Select a backup on the microSD card",
    point2: "Set a password for your device",
    restoreText: "Ok, let's restore a backup!",
    text1: "Great, your BitBox02 password is now set and wallet created. Now it's time to create your first backup. Please make sure your microSD card is inserted into your BitBox02 and continue.",
    text2: "Please follow the on-screen instruction on your device to create a backup.",
    text3: "After your backup is created, please remove the microSD card and store it in a <strong>secure location</strong>. The contents of the microSD card is not password-protected. Never insert it into any other device but your BitBox02.",
    userConfirmation1: "I should store my backup in a secure location.",
    userConfirmation2: "My backup is not password protected. Anyone with access to it can access my wallet.",
    userConfirmation3: "If I lose or damage my BitBox02, the only way to recover my funds is to restore from my backup.",
    userConfirmation4: "If I lose or damage both my backup and my BitBox02 then my funds will be lost.",
    userConfirmation5: "I should not insert my microSD card backup into a computer, phone, printer or any device other than a BitBox02.",
    userConfirmation5mnemonic: "I should not put my recovery words in a computer, phone, printer or any device other than a BitBox02."
  },
  create: {
    button: "Name device & continue",
    info: "Here are the basics steps you will be taking to set up your BitBox: ",
    inputTitle: "Wallet name",
    point1: "Name your device",
    point2: "Set a password for your device",
    point3: "Create a backup",
    text: "Ok, let's create a new wallet!"
  },
  createBackupAborted: "Creating backup aborted.",
  createBackupFailed: "Creating backup failed, try again.",
  initialize: {
    passwordText: "Now let's set a password for your device. Use the controls on your BitBox to enter and choose a password.",
    passwordTitle: "Set a password for your BitBox",
    text: "Successfully paired your BitBox02! Now let's initialize your device. Get started by choosing to create a new wallet, or to restore a wallet from an existing backup. <strong>Please make sure you have a microSD card inserted in your BitBox02</strong>",
    tip: "We recommend that you proceed in a secure location.",
    title: "Initialize your BitBox"
  },
  insertSDCard: "<strong>Please make sure you have a microSD card inserted in your BitBox02.</strong>",
  noPasswordMatch: "Passwords did not match, please try again.",
  pairing: {
    failed: "Unconfirmed pairing. Please replug your BitBox02.",
    paired: "You have confirmed the following code on your device. Please continue.",
    title: "Verify pairing code",
    unpaired: "An unpaired BitBox02 has been detected. Please verify the pairing code matches what is shown on your BitBox02."
  },
  restoreFromMnemonic: {
    e104: "Restoring from recovery words was canceled.",
    failed: "Restoring from recovery words failed, please try again."
  },
  stepBackup: {
    beforeProceed: "Before proceeding, please read these important security considerations:",
    createBackup: "You will now create a backup on your microSD card.",
    createBackupMnemonic: "You will now write down the recovery words."
  },
  stepBackupSuccess: {
    fundsSafe: "To keep your funds safe, please remember the following:",
    title: "Backup Restored!"
  },
  stepConnected: {
    unlock: "Enter BitBox02 password to unlock."
  },
  stepCreate: {
    description: "This name is used as the device name and for backups.",
    error: {
      genericMessage: "Use letters, numbers, basic symbols, spaces. Max 30 characters.",
      invalidChars: "Name contains invalid characters: {{invalidChars}}.",
      tooLong: "Name is too long."
    },
    nameLabel: "BitBox02 name",
    namePlaceholder: "My BitBox02",
    title: "Choose BitBox02 name",
    toastMicroSD: "Please insert your microSD card into your BitBox02 which will be used to store a backup of the wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Please remove the microSD card from your BitBox02 and store it in a secure location.",
    storeMnemonic: "Please store your recovery words in a secure location",
    success: "Youve successfully created your backup."
  },
  stepInsertSD: {
    insertSDCard: "Please insert a microSD card into your BitBox02 to continue.",
    insertSDcardTitle: "Insert microSD card"
  },
  stepPassword: {
    e104: "Setting password was canceled.",
    title: "Set BitBox02 password",
    useControls: "Use the controls on your BitBox02 to set a password."
  },
  stepUninitialized: {
    create: "I want to create a new wallet on my BitBox02.",
    restore: "I want to restore my wallet from a backup.",
    restoreMicroSD: "Restore from microSD card",
    restoreMnemonic: "Restore from recovery words",
    title: "Setup your wallet"
  },
  success: {
    text: "Hooray! Your BitBox02 is now ready to use. \n\nFor further information on how to use the BitBoxApp, please use the in-app guide by clicking the question mark on the top right corner.",
    title: "You're ready to go!"
  }
};
const bitsurance$8 = {
  dashboard: {
    active: "Insurance policy active",
    button: "Insure a new account",
    canceled: "Canceled",
    coverage: "Maximum coverage",
    inactive: "Inactive",
    processing: "Processing",
    refused: "Refused",
    supportLink: "Manage contract",
    title: "Insured accounts",
    waitpayment: "Waiting for payment"
  },
  detect: {
    button: "Check for existing insurance",
    insured: "Insured account detected:",
    notInsured: "No insured accounts detected. If you are sure you have an insured account, please make sure you have the correct wallet connected.",
    text: "If you already signed up with Bitsurance, the BitBoxApp can automatically synchronize your existing insurance coverage.",
    title: "Already insured?"
  },
  insure: {
    button: "Check availability and pricing",
    faq: "Read more on Bitsurance FAQs",
    listItem1: "Burglary",
    listItem2: "Extortion (e.g., $5 wrench attack)",
    listItem3: "Destruction due to fire, water or natural disasters",
    month: "month",
    text: "Insure your BitBox02 and up to 100,000 worth of bitcoin against",
    text2: "Insurance plans start at 30/year (2.50/month). You can learn more about Bitsurance and their exact insurance offerings on the",
    text3: "Currently available in Germany, with more regions to follow.",
    title: "Get started"
  },
  intro: {
    link: "Bitsurance website",
    text1: "BitBox works with Bitsurance to add an additional layer of protection for your bitcoin. While the BitBox02 keeps your funds secure, Bitsurance covers threats at home that cant be mitigated with technology alone, like burglary, extortion, or destruction of the hardware wallet itself."
  },
  terms: {
    link: "Bitsurance Privacy Policy",
    text1: "Bitsurance is an independent third-party service. For questions regarding their offerings and insurance claims, please contact Bitsurance directly.",
    text2: "Insurance is currently available in Germany, with more regions to follow.",
    text3: "The maximum Bitcoin coverage currently available is 100,000 per person. Higher amounts are planned for the future.",
    text4: "Personal information and the extended public key of your insured account is part of the insurance policy and will be shared with Bitsurance and the insurance provider.",
    text5: "For more on privacy, please consult the"
  },
  title: "Insurance"
};
const bitsuranceAccount$8 = {
  errorNoXpub: "Error: Was not able to get xpub from account.",
  noAccount: "There are no accounts that can be insured.",
  select: "Select account",
  title: "Insurance"
};
const blink$f = {
  button: "Blink"
};
const bootloader$f = {
  button: "Upgrade firmware now",
  button_install: "Install firmware now",
  progress: "Upgrading: {{progress}}%",
  progress_install: "Installing: {{progress}}%",
  success: "Upgrade successful! Please replug the device. This time, do not touch the button."
};
const button$k = {
  abort: "Abort",
  back: "Back",
  buy: "Buy",
  changepin: "Change device password",
  check: "Check backup",
  "continue": "Continue",
  copy: "Copy",
  create: "Create",
  dismiss: "Dismiss",
  done: "Done",
  download: "Download",
  hiddenwallet: "Create hidden wallet",
  next: "Next",
  ok: "OK",
  previous: "Previous",
  receive: "Receive",
  restore: "Restore",
  select: "Select",
  send: "Send",
  unlock: "Unlock",
  update: "Update",
  upgrade: "Upgrade"
};
const buy$b = {
  exchange: {
    bankTransfer: "Bank transfer",
    bestDeal: "Best deal",
    creditCard: "Credit card",
    fast: "Fast",
    fee: "fee",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bank Transfer: {{fee}}%",
          creditDebitCard: "Credit/debit card: {{fee}}%",
          learnMore: "Learn more about Moonpay",
          title: "Fees"
        },
        fullCurrenciesList: "See full list of currencies here",
        payment: {
          asteriskText: "* Not available for US residents",
          bankTransfer: "Bank transfer*",
          bankTransferDetails: {
            pix: "PIX (BR transactions in Brazil only)",
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          creditDebitCard: "Credit/debit Card",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "See more details about payment methods",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports all major fiat currencies: USD, EUR, CHF, and more."
      },
      pocket: {
        fees: {
          info: "Bank transfer: {{fee}}%",
          title: "Fees"
        },
        learnMore: "Learn more about Pocket",
        payment: {
          bankTransfer: "Bank transfer",
          bankTransferDetails: {
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            sic: "Swiss Interbank Clearing (CHF transactions in CH/LI only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          bankTransferReccuring: "How to set up recurring purchases with a standing order?",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports European currencies: EUR, GBP, and CHF.",
        verification: {
          info: "Only requires identity verification above daily and annual thresholds.",
          link: "Find current thresholds here",
          title: "Identity verification"
        }
      },
      region: {
        title: "Select the region your bank account is registered in to see which options are available to you."
      }
    },
    noExchanges: "Sorry, there are no available exchanges in this region.",
    region: "Region",
    selectRegion: "Not specified",
    title: "Buy {{name}}"
  },
  info: {
    "continue": "Agree and continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "We partner with MoonPay to offer you a seamless way to buy {{name}} directly within the BitBoxApp. It's just a few clicks.",
        "MoonPay is a platform that makes it easy and quick to buy {{name}} in over 160+ countries."
      ],
      payment: {
        details: "You can buy {{name}} instantly via MoonPay with the following payment methods. Credit or debit card orders are instant and convenient, but more expensive due to increased chargeback risk. We recommend using the bank transfer option for larger amounts. The minimum fee is 4 USD/EUR or equivalent.",
        footnote: "Please note that MoonPay's exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
        table: {
          "1_description": "Lowest fees, can take up to 3 working days",
          "1_method": "Bank transfers (SEPA)",
          "2_description": "Higher fees but quick and instant",
          "2_method": "Credit & debit cards",
          description: "Description",
          fee: "Fee",
          method: "Method"
        },
        title: "Payment methods and fees"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. MoonPay needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
        descriptionGeneric: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. However partner exchanges need to collect some information to operate. Please refer to their respective privacy policies to see in more detail how the data is handled.",
        title: "Data protection"
      },
      security: {
        description: "When you buy {{name}} via MoonPay, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        descriptionGeneric: "When you buy {{name}} via a partner exchange, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        link: "Security threat model",
        title: "Security model"
      },
      title: "Welcome to your one stop shop for buying {{name}}"
    },
    next: "Next",
    selectLabel: "Choose your account",
    selectPlaceholder: "Select a coin",
    skip: "Do not show again",
    title: "Buy {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket privacy policy",
      p1: "The BitBoxApp does not collect any data when buying bitcoin, the incoming funds are treated like a regular transaction. Pocket needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
      title: "Data protection"
    },
    kyc: {
      link: "Read Pocket FAQs",
      p1: "Pocket tries to keep KYC to a minimum. For purchases under 950 EUR (1000 CHF) a day, no additional documents are required. For purchases over this amount, you will need to schedule a call with Pocket to complete the necessary KYC/AML process.",
      title: "KYC/AML"
    },
    payment: {
      p1: "You can buy bitcoin instantly with Pocket via SEPA bank transfer. The fee is 1.5% and the bitcoin is deposited to your BitBox as soon as possible after Pocket receives the bank transfer (usually within the same day).",
      p2: "Please note that Pockets exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
      title: "Payment methods and fees"
    },
    previousTransactions: "The transaction history of this account is not empty. Sharing this account will make all its past and future transactions visible for Pocket. Proceed anyway?",
    security: {
      link: "BitBox02 security threat model",
      p1: "When you buy bitcoin via Pocket, you are using an external service. This service is out of scope of the BitBox02 Security Threat model and relies on the safety and security of the environment which the BitBoxApp software is running in. However we work together to improve security by using a two factor authentication mechanism to verify the address you are receiving to.",
      title: "Security model"
    },
    usedAddress: "The address {{address}} has been already used, please start again with a new address.",
    verifyBitBox02: "Please verify that the address you received via email matches the one displayed on your Bitbox. If possible, you should open the email on a second device for better security.",
    welcome: {
      p1: "We partner with Pocket to offer you a seamless way to buy bitcoin directly within the BitBoxApp. It's just a few clicks.",
      p2: "Pocket is a Swiss platform that makes it quick and easy to buy bitcoin in most of Europe (anywhere where SEPA bank transfers are supported).",
      p3: "With Pocket, you can also do regular buys through standing bank orders, so you can DCA (dollar-cost averaging) with ease.",
      title: "Welcome to your one stop shop for buying bitcoin"
    }
  },
  title: "Buy {{name}}"
};
const changePin$f = {
  newTitle: "New device password",
  oldLabel: "Current device password"
};
const chart$b = {
  dataMissing: "Gathering historical data... stay tuned.",
  dataOldTimestamp: "Historical exchange rates updating. The chart is not displaying data after {{time}}.",
  dataUpdating: "updating data",
  filter: {
    all: "All",
    month: "Month",
    week: "Week",
    year: "Year"
  }
};
const checkSDcard$f = "checking microSD card";
const clickHere$f = "Click here.";
const confirm$h = {
  abortInfo: "Tap to ",
  abortInfoRedText: "abort",
  approveInfo: "Hold 4+ secs to ",
  approveInfoGreenText: "confirm",
  info: "Continue on your BitBox. ",
  infoWhenPaired: "First on the paired mobile and then your BitBox"
};
const confirmOnDevice$f = "Please confirm on your device.";
const connectKeystore$9 = {
  promptNoName: "Please connect your BitBox02 to continue",
  promptWithName: 'Please connect your BitBox02 named "{{name}}" to continue'
};
const darkmode$9 = {
  toggle: "Dark mode"
};
const device$f = {
  appUpradeRequired: "Your BitBox is not compatible with this desktop application. Please download and install the latest version.",
  keystoreConnected: "Connected wallet"
};
const deviceLock$f = {
  button: "Enable two factor authorization (2FA)",
  condition1: "Do you have a backup?",
  condition2: "Is mobile app verification working?",
  condition3: "2FA DISABLES backups and mobile app pairing. The device must be RESET to exit 2FA!",
  confirm: "Enable two factor authorization (2FA)",
  title: "Enable two factor authorization (2FA)"
};
const deviceSettings$f = {
  backups: {
    manageBackups: {
      description: "Create or verify your microSD card backup."
    },
    showRecoveryWords: {
      description: "Show and verify recovery words."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "The BitBoxApp checks if your device is authentic."
    },
    deviceName: {
      description: "Change the name of your device."
    },
    rootFingerprint: {
      description: "The root fingerprint is a unique identifier for the wallet currently in use. It can help you distinguish between different wallets if you use passphrases."
    },
    securechip: {
      description: "The model of the secure chip."
    },
    title: "Device information"
  },
  expert: {
    factoryReset: {
      description: "Reset your device to factory settings. This deletes the wallet from your BitBox02!",
      title: "Factory reset"
    },
    goToStartupSettings: {
      description: "Enter the bootloader of the BitBox02. You can enable the firmware hash from here."
    },
    passphrase: {
      description: "Enable or disable the passphrase feature.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Available version"
    },
    title: "Firmware",
    upToDate: "Your device is up to date",
    upgradeAvailable: "New upgrade available",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "Authenticity check failed",
      label: "Authenticity check",
      "true": "Your BitBox02 is authentic"
    },
    sdcard: {
      "false": "Not inserted",
      label: "microSD card",
      "true": "Inserted"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Retrieving device info",
  pairing: {
    lock: {
      "false": "Disabled",
      label: "Two factor authorization (2FA)",
      "true": "Enabled"
    },
    mobile: {
      "false": "Closed",
      label: "Mobile app",
      "true": "Open"
    },
    status: {
      "false": "Not paired",
      label: "Status",
      "true": "Paired"
    },
    title: "Pairing"
  },
  secrets: {
    manageBackups: "Manage backups",
    title: "Secrets"
  }
};
const deviceTampered$f = "Has your BitBox been supplied with a recovery password? If so, stop the setup process and contact support immediately. Shift will never give you a ready made wallet or make password recommendations.";
const dialog$g = {
  cancel: "Cancel",
  confirm: "Confirm",
  confirmTitle: "Confirmation"
};
const error$b = {
  accountAlreadyExists: "The account already exists.",
  accountLimitReached: "Cannot add account. The maximum number of accounts for this coin has been reached.",
  aoppCallback: "There was an error delivering the address to {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "There are no available accounts.",
  aoppSigningAborted: "Address ownership request cancelled.",
  aoppUnknown: "An unknown error occurred.",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "There are no available accounts that support the requested address format.",
  aoppUnsupportedKeystore: "The connected device cannot sign messages for this asset.",
  aoppVersion: "Unknown version.",
  keystoreTimeout: "Wallet request expired. Please try again.",
  wrongKeystore: "Wrong wallet connected. Please make sure to insert the correct device matching this account.",
  wrongKeystore2: " If you are using the optional passphrase, make sure you have entered the correct passphrase for the account."
};
const fiat$h = {
  "default": "default",
  setDefault: "Set {{code}} as default",
  title: "Currencies"
};
const footer$h = {
  appVersion: "App version:"
};
const generic$b = {
  enabled_false: "Disabled",
  enabled_true: "Enabled"
};
const genericError$f = "An error occurred. If you notice any issues, please restart the application.";
const goal$f = {
  buttons: {
    create: "Create a new wallet",
    restore: "Restore a wallet from a backup"
  },
  paragraph: "Please select one of the following options:",
  step: {
    "1": {
      title: "Security information"
    },
    "2": {
      description: "Set a device password",
      title: "Device"
    },
    "3-create": {
      description: "Create a new wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "from a backup",
      title: "Restore"
    },
    "4-create": {
      title: "Summary"
    },
    "4-restore": {
      title: "Summary"
    }
  }
};
const guide$g = {
  accountDescription: {
    text: "Your account overview shows your available balance as well as incoming and outgoing transactions. Our guide in Settings has more information about each account type. ",
    title: "What does this page show me?"
  },
  accountFiat: {
    text: "Yes. Click on any ticker to rotate through fiat currencies. You can change the list of currencies in the settings.",
    title: "Can I display other conversion rates?"
  },
  accountIncomingBalance: {
    text: "Incoming sums up the amounts transferred to you but not yet confirmed by the network.",
    title: "What does incoming mean?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Each xpub is tied to the "Type" shown: either "Native Segwit (bech32)", "Wrapped Segwit" or Taproot (Bitcoin only). These are script types used by {{coinName}}. The BitBoxApp combines them, supporting multiple script types in the same account. Because each script type gives a different xpub, there are multiple xpubs per account.\n\nIf you consistently receive on the default address (Native Segwit), you only need the "bech32" xpub. However, if you also receive funds to "Wrapped Segwit" or Taproot, you also need to use the "Wrapped Segwit" and Taproot extended public keys respectively.',
      title: "Why are there multiple xpubs?"
    },
    privacy: {
      text: "For this specific account, the extended public key reveals the entire financial history, your account balance, and all future transactions. But the xpub does not allow anyone to spend your coins.\n\nIf you give an xpub to someone, you should be aware that this person or company can see all other transactions of the same account. Therefore, its a good idea to use that account only for this purpose and keep other funds in different accounts.",
      title: "Do I need to keep my xpub secret?"
    },
    verify: {
      text: "Yes, its always a good idea to double-check your xpub. If someone else will generate receive addresses from this xpub to send you money, this is especially important. You need to verify it on the device to ensure that this xpub belongs to you; otherwise, all funds could go to the wrong addresses.",
      title: "Do I need to verify the xpub on the device?"
    },
    xpub: {
      text: "An extended public key (xpub) is a root key from which all receiving addresses of an account are derived.\n\nIt is provided here for advanced use and interoperability with watch-only wallets, such as Electrum or Sentinel. If you received to different address types, please import all the different xpub formats into the watch-only wallet in order to see all your coins.\n\nPlease note, third party wallets may not support Taproot xpubs yet.",
      title: "What is an extended public key?"
    }
  },
  accountRates: {
    text: "We update exchange rates every minute from CoinGecko.",
    title: "Which exchange rates apply?"
  },
  accountReload: {
    text: "Theres no need. Your transaction information is updated automatically.",
    title: "Can I reload the transaction history?"
  },
  accountSendDisabled: {
    text: "The Send button is activated when your balance is more than zero.",
    title: "Why can't I send any {{unit}}?"
  },
  accountSummaryAmount: {
    text: "The total amount is the sum of all your crypto accounts. Exchange rates are obtained from coingecko.com.\n\nNote: If you use MyEtherWallet for tokens not supported in the BitBoxApp, they will not be included in the amount displayed.",
    title: "How is the total amount calculated?"
  },
  accountSummaryDescription: {
    text: "Here you can see the performance of your portfolio over time. A summary of your individual crypto accounts is displayed under the chart.",
    title: "What does this page show me?"
  },
  accountTransactionAttributesBTC: {
    text: "Virtual size: Determines the network fee. You successfully saved on fees if it is smaller than the transaction size.\nSize: Actual transaction size in bytes when serialized according to the underlying blockchain.\nWeight: A new metric introduced with Segwit to evaluate transaction and block sizes. Each segregated witness byte counts as one, everything else as four weight units. Instead of one megabyte in actual size, the block size limit is now four million weight units.",
    title: "What about the Bitcoin-specific transaction details?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmations: Your first transaction broadcast is unconfirmed until a miner includes it in a block, after which it has one confirmation. Each block broadcast on the network adds another confirmation to your transaction. Generally merchants and other network actors will only settle transactions with between three to six confirmations.\nTransaction ID: A unique identification number that allows you to look up a transaction in a block explorer.\nFee: Miners are paid a transaction fee as an incentive to include transactions in the blocks they mine. To learn more, click on the send button.",
    title: "Whats the information in the transaction details?"
  },
  accountTransactionConfirmation: {
    text: "A transaction broadcast to the network but not yet confirmed.",
    title: "What is a pending transaction?"
  },
  accountTransactionLabel: {
    text: "Its the address you received coins from or sent coins to.",
    title: "Which address is displayed for each transaction?"
  },
  accountTransactionTime: {
    text: "The blockchain transaction confirmation time.",
    title: "What time is displayed?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin and Litecoin can have an arbitrary amount of accounts. After five accounts, you can only add another account if the previous account has been used. \nOther coins can have a maximum of five accounts.",
      title: "How many accounts can I create?"
    },
    howtoAddTokens: {
      text: 'Tokens using the ERC20 standard are tied to a specific Ethereum account. To enable or disable a particular token, open the "Manage accounts" screen, expand your Ethereum account and switch the desired token on or off.',
      title: "How can I add additional tokens?"
    },
    moveFunds: {
      text: "Yes. But because accounts are independent, you need to send your funds using a regular transaction.",
      title: "Can I move funds between accounts?"
    },
    recoverAccounts: {
      text: "Yes. The BitBoxApp creates accounts using well-established standards compatible with most other crypto wallets.",
      title: "Can I recover my accounts with other wallets?"
    },
    supportedCoins: {
      link: {
        text: "View supported coins"
      },
      text: "The BitBoxApp supports Bitcoin, Litecoin, Ethereum as well as a selection of ERC20 token. For Cardano and other tokens, use your BitBox02 with alternative software such as AdaLite or Rabby. You can find an exhaustive list of all supported coins on our website:",
      title: "Which coins are supported?"
    },
    whatAreAccounts: {
      text: "Your wallet can manage multiple accounts of the same coin. Accounts are helpful when you want to keep funds separate.",
      title: "What are accounts?"
    },
    whatIsRememberWallet: {
      text: "Enabling Remember wallet lets you see the accounts for this wallet in the BitBoxApp even when the BitBox02 is not plugged in. This allows you to check your balance and portfolio whenever you want. The BitBox02 still needs to be plugged in and unlocked to send or receive coins.\n\nDisabling Remember wallet requires you to plug in the respective BitBox02 (or passphrase wallet) to see those accounts in the BitBoxApp.",
      title: "What happens when I enable/disable Remember wallet?"
    },
    whyIsThisUseful: {
      text: 'Accounts are great for managing funds for different people or purposes because they are separated. You can also share the "extended public key" of an account without revealing anything about your other accounts. This allows you to repeatedly receive funds without reusing addresses, such as receiving your wage or regularly buying crypto.',
      title: "Why is this useful?"
    }
  },
  appendix: {
    link: "Contact us!",
    text: "Another question?"
  },
  backups: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet. It can also be used to verify that you still have the correct recovery password. You can check your main recovery password or your hidden recovery password.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: "No but your recovery password is required to derive the wallet from the stored seed.",
      title: "Can I encrypt the backup?"
    },
    howOften: {
      text: "The backup is automatically generated when a new wallet is created. You only have to make a new backup if your microSD card is lost or damaged, or if you want to use multiple microSD cards as backups.\nYou do not need to create new backups after transaction activity. All your transaction data can be recreated by your single backup that was automatically generated for you.",
      title: "How often do I have to make a backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card. The seed together with your recovery password generates your wallet.",
      title: "What is a backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: 'No. Please keep the microSD card safe, as it contains the unencrypted seed to recover your wallet. If you wish to password-protect your seed, you can enable an optional passphrase in the expert settings under "Manage device".',
      title: "Can I encrypt the backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card.",
      title: "What is a backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "When 2FA is enabled, all transactions have to be approved on the paired mobile phone in order to spend coins. Under the hood, an encrypted single-use number is sent to the mobile app, decrypted there, and returned to the BitBox when pressing the Accept button. This communication with the device is done via the channel between the mobile phone and this desktop app established during pairing.\n\nBe sure to backup your wallet and pair the mobile app before enabling 2FA. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.",
      title: "How does Two factor authorization (2FA) work?"
    },
    disable2FA: {
      text: "In order to disable 2FA, you need to reset your BitBox and then restore the wallet from its backup. Make sure that you still have the microSD card with the backup and that you still remember the recovery password. Then press 'Reset device'. Set a new device password and choose 'Or restore a backup'. Select the backup you have made from the wallet, click 'Restore' and enter the recovery password you used when creating the wallet.",
      title: "How can I disable two factor authorization (2FA)?"
    },
    ejectBitbox: {
      text: "You can unplug the BitBox at any time without having to eject it first.",
      title: "How can I eject the BitBox?"
    },
    ejectSD: {
      text: "You can remove the microSD card from the BitBox at any time as long as you are not in the process of creating or restoring a backup.",
      title: "How can I eject the microSD card?"
    },
    hiddenWallet: {
      text: "It is a second wallet on the same device protected by a different device password and recovery password, which you can use for plausible deniability. The same backup seed is used for both your normal and hidden wallet, so no additional backup is required.",
      title: "What is a hidden wallet?"
    },
    legacyHiddenWallet: {
      text: "First click the button below (available if the BitBox is unlocked with the main device password and 2FA is disabled), then replug your Bitbox and unlock it with your hidden device password.",
      title: "How do I access the legacy hidden wallet?"
    },
    pairing: {
      text: "After having downloaded our mobile app for either iOS or Android, you scan the displayed QR code, which sets up a secure channel between the mobile app and this application. Once scanned, follow the instructions in the mobile app.",
      title: "How to securely pair with your phone"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Please check Bitsurances website and their FAQ for more details.",
      title: "Additional questions?"
    },
    privacy: {
      link: {
        text: "Bitsurance privacy policy"
      },
      text: "Like any regular insurance policy, it contains your full name and address, and specifies the insured object (defined by the extended public key of the insured Bitcoin account). This data is submitted to Bitsurance directly and is not shared with Shift Crypto. Please consult the Bitsurance privacy policy for more information",
      title: "What personal information is needed for the insurance?"
    },
    renew: {
      text: "The insurance will automatically renew for the next year. You can cancel the renewal any time by clicking on Manage contract in the BitBoxApp, which takes you to the Bitsurance customer portal.",
      title: "How can I renew or cancel the insurance?"
    },
    status: {
      text: "Successfully insured accounts are marked with a green insured badge in the top left corner on each Bitcoin account page. In the Insurance section, you can see the overview of all insured Bitcoin accounts and their current insurance status. It can take up to 48 hours to update the insurance status.",
      title: "Can I check the status of an insured account?"
    },
    what: {
      text: "Each Bitcoin insurance contract covers a specific wallet account. You can insure multiple accounts by taking out multiple insurance policies. Insured accounts are limited to using Native Segwit Bitcoin addresses.",
      title: "Is the whole BitBox wallet insured?"
    },
    who: {
      text: "The insurance is offered by Bitsurance, an insurance broker built by bitcoiners. They work with ELEMENT insurance to provide Bitcoin insurance. Both companies are based in Germany.",
      title: "Who is insuring my bitcoin?"
    },
    why: {
      text: "Bitsurance covers some risks of self-custody that are not in-scope of even the most secure wallet, e.g. burglary, extortion or destruction of the wallet. Its your personal decision if you need insurance coverage for these risks.",
      title: "Do I need Bitcoin insurance?"
    }
  },
  cointracking: {
    text: 'Click the "Export" button and open the downloads folder where you will find the CSV export. Then click the link below, upload your BitBox CSV file and import the data in order to use it for your CoinTracking portfolio manager and to create your tax reports.',
    title: "How to import my transactions into CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Read more about the authenticity check"
      },
      text: "The BitBoxApp performs an attestation check on the BitBox02 to verify if the device is genuine. The check is done locally and does not connect to any servers.",
      title: "How does the authenticity check work?"
    },
    name: {
      text: "This is the name of your wallet and backup. The name is used for future backups and can be used to help distinguish between different wallets. It can be changed at any time but note that backups made before the change will still use the previous name.",
      title: "What is the BitBox02 name used for?"
    },
    "secure-chip": {
      link: {
        text: "Read more about the secure chip"
      },
      text: "This information shows the model number of the secure chip, the most up to date chip is ATECC608B with improved security features compared to older models.",
      title: "Why show the secure chip model?"
    }
  },
  receive: {
    address: {
      text: "You can give the address to others to send you some coins. Just make sure they are sending to the correct address.",
      title: "What do I do with an address?"
    },
    addressChange: {
      text: "As soon as you transact, a new address is automatically added to the list so there are always 20 addresses available which have never received any coins.",
      title: "When do the addresses change?"
    },
    addressFormats: {
      text: "By default, the address type is Native Segwit. This address type is widely adopted by other wallets/exchanges and gives you the best fee rates for everyday transactions. However, you may also choose to send to Taproot (Bitcoin only), which is the newest address type, but may not be widely supported yet. Alternatively, if you are having issues sending to Native Segwit (the default type), you can try switching to the older Wrapped Segwit address type that may be compatible with more wallets/exchanges.",
      title: "When do I use Change address type?"
    },
    howVerify: {
      text: "For the BitBox01, click on the BitBox icon in the sidebar on the left and see the Pairing section. The guide will update and you can continue following the instructions from there.\nFor the BitBox02, you can verify addresses directly on the device during the send/receive process.",
      title: "How can I verify an address securely?"
    },
    plugout: {
      text: "No, once you sent coins to your BitBox address, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while receiving?"
    },
    why20: {
      text: 'During start-up the app generates addresses derived from your seed to see if they have received funds. As the app can generate an almost infinite number of addresses, it could spend years determining the balance. To limit this search it stops after it sees 20 addresses that have never received funds. This is the "gap limit" and 20 is a de-facto standard though the number is arbitrary. These are the 20 addresses you can choose from.',
      title: "Why only 20 addresses?"
    },
    whyMany: {
      text: "To maintain privacy and security, never hand out the same address twice. If you have used an address, click on on the right arrow for a new address. You can generate up to 20 addresses at a time. Think of addresses like invoice numbers. All addresses are derived from your single backup seed.",
      title: "Why so many addresses?"
    },
    whyVerify: {
      text: "You shouldnt trust your computer to generate and display authentic addresses. Its big attack surface makes it significantly more vulnerable than a hardware wallet. For the BitBox01, The button to verify the address securely sends the address to a paired mobile phone, from which you can also scan and verify the QR code. For the BitBox02, the address can be verified directly on the BitBox02 display.",
      title: "Why should I verify the address securely?"
    }
  },
  send: {
    change: {
      text: "The change will be returned to a Taproot address if you have at least one Taproot UTXO. If you use coin control, the change will be returned to a Taproot address if there is at least one Taproot UTXO among the selected UTXOs. In all other cases, the change is returned to a Native Segwit address.",
      title: "How is the change output determined?"
    },
    fee: {
      text: "The fee is based on the transaction data size and not its amount. The fee targets are calculated by Bitcoin Core's fee estimation algorithm for each network priority you chose. They are shown if they have a different value from the target below.\nEconomy: 24 blocks (around 4 hours for Bitcoin, 1 hour for Litecoin)\nLow: 12 blocks (around 2 hours for Bitcoin, 30 minutes for Litecoin)\nNormal: 6 blocks (around 1 hour for Bitcoin, 15 minutes for Litecoin)\nHigh: 2 blocks (around 20 minutes for Bitcoin, 5 minutes for Litecoin)\n(A block takes on average ten minutes for Bitcoin (2.5 minutes in Litecoin) to mine and the network load may vary considerably in the above periods.)",
      title: "How is the fee determined?"
    },
    plugout: {
      text: "No, once you have made a transaction, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while sending?"
    },
    priority: {
      text: "The higher fee you are willing to pay, the faster your transaction is typically confirmed by the network.",
      title: "What is the network priority?"
    },
    revert: {
      text: "Once a transaction is signed and sent (i.e. broadcasted to the network), it can no longer be reverted. Verify the transactions (including the fee) properly before signing!\nIf you know the recipient and he or she is willing to send the same amount (minus the transaction fees) back to you, you can send them a new receiving address.",
      title: "Can I revert a transaction?"
    },
    whyFee: {
      text: "Transactions are competing to be confirmed by a miner. Miners choose transactions to be included in the blockchain based on their fee.\nMiners vote on the history of transactions. Since there is no trusted third party to enforce one vote per person (which is the whole point of blockchains), miners vote on transactions by sacrificing a costly resource like computing power. As a reward for their work, they can claim newly created coins and the fee of all the transactions they included.",
      title: "Why is there a network fee?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "If you intend to only connect to your node when you are on the same network (e.g. your home wifi), then using regular network communication is sufficient.\nIn this case it is advisable that your Electrum server provides a TLS certificate to encrypt the communication.\nIf you intend to connect to your node from anywhere, using Tor is the better option. No TLS certificate is necessary in that case.",
      title: "Should I use clearnet TCP, TLS or Tor?"
    },
    instructions: {
      link: {
        text: "Guide to connect your node"
      },
      text: "For a full tutorial, please visit our guide:",
      title: "How do I connect my BitBoxApp to my own full node?"
    },
    options: {
      text: "There are multiple options to run your own node such as buying a finished device, building your own or running Bitcoin Core.\nIf you want to connect your BitBoxApp to your node, make sure that it runs an Electrum server. This is a dedicated program that allows a wallet app to communicate with your full node.\nSupported options include Electrs, Electrum Personal Server (EPS) or Bitcoin Wallet Tracker (BTW).",
      title: "What options are there to run a node?"
    },
    tor: {
      text: "Tor stands for 'The Onion Router', which is a free and open source software that offers a lot of privacy benefits and is especially useful when using Bitcoin.\nIf you intend to connect to your node via Tor, make sure that Tor is installed on your computer and then enable the Tor Proxy in the BitBoxApp settings.\nOn most operating systems there are two ways to run Tor:\n1. Tor Browser: download and open the Tor Browser. This will allow the BitBoxApp to connect to the Tor network by setting port 9150 in the Tor proxy settings.\n2. Tor background service: install the Tor daemon, which always runs in the background. The BitBoxApp can then connect by setting port 9050 in the Tor proxy settings.",
      title: "What is Tor, Tor proxy and which port should I use?"
    },
    what: {
      text: "It is possible to power your wallet with your own full nodes instead of using Shift servers.",
      title: "What is this?"
    },
    why: {
      text: "Running your own node is not necessary but improves privacy and reduces the need to trust others.\nFirstly, it means that you are using Bitcoin more privately as the BitBoxApp won't connect to our servers to fetch your transaction history; instead it will fetch that information from your own node.\nSecondly, running your own node means that your node verifies all transactions itself, making sure that the consensus rules are enforced.",
      title: "Why should I run my own node?"
    }
  },
  settings: {
    sats: {
      text: "A Satoshi ('sat' for short) is the smallest unit of Bitcoin. One Satoshi is a hundred millionth of a bitcoin (0.00000001 BTC). It is named after the creator of Bitcoin, Satoshi Nakamoto.",
      title: "What is a Satoshi?"
    },
    servers: {
      text: "This app communicates with the Shift Crypto servers to check for updates, load transactions, and send information to paired mobile apps.\nThe app also retrieves the latest exchange rates from CoinGecko. All conversions are calculated locally which means no data about the amount of your transaction is ever transmitted.\nNote: For Ethereum and ERC20 Tokens, we use Etherscan.io APIs.",
      title: "Which servers does this app talk to?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Close guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "On desktop, hover the cursor over the chart. On mobile, hold your finger on the chart and drag horizontally.",
    title: "How to see historical values on the chart?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "You have to reset the device and restore the wallet from a backup, using the recovery password.",
      title: "What do I do if I forgot the device password?"
    },
    reset: {
      text: "Enter a wrong device password 15 times. The last few attempts require a long touch on the device.",
      title: "How do I reset the device?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "The device should blink once when inserted. Make sure that it is inserted the right way around. If you are having trouble, please contact us through the link below.\n\nThe BitBox01 is not supported on mobile. Please use the BitBoxApp on desktop to connect your BitBox01.",
      title: "My BitBox01 is not recognized"
    },
    getDevice: {
      link: {
        text: "Order a BitBox"
      },
      text: "You can buy a BitBox in our online shop:",
      title: "How can I get a device?"
    },
    internet: {
      text: "Yes, an internet connection is required to synchronize the wallet, send transactions and retrieve the latest exchange rates.",
      title: "Does this app require an internet connection?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "You can recover your accounts on a new BitBox or with our backup center.",
      title: "I lost my device. Now what?"
    },
    useWithoutDevice: {
      text: "Unfortunately, this is not yet possible at the moment.",
      title: "Can I use the app without a device?"
    },
    welcome: {
      text: "Thanks for using this app built by Shift Crypto in Switzerland. We appreciate any input you have to share. Please give feedback using the link at the bottom.",
      title: "Welcome to the BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "If you are using a new phone/computer with the BitBoxApp, then you will need to connect to the DApps again. You will then see your coins on the dapp again like usual.",
      title: "I don't see my previous connections."
    },
    supportedNetworks: {
      text: "Currently, only Ethereum mainnet is supported using WalletConnect in the BitBoxApp. To use other EVM compatible chains please use the Rabby browser extension wallet.",
      title: "What networks are supported?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is a communication protocol for web3 applications. It allows you to conveniently connect to Ethereum based DApps and web wallets without using a third party app, which is particularly useful for Android users of the BitBoxApp.",
      title: "What is WalletConnect?"
    }
  }
};
const headerssync$f = {
  blocksSynced: "{{blocks}} blocks synced"
};
const hiddenWallet$f = {
  info1HTML: "For plausible deniability purposes, a hidden wallet can be created based on a <strong>different</strong> device password + recovery password combination.",
  info2HTML: "Define the device password and recovery password you want to associate with your hidden wallet below. The device password and recovery password must be <strong>different</strong> from the ones you defined for your primary wallet.",
  passwordLabel: "Hidden recovery password",
  passwordPlaceholder: "Please confirm hidden recovery password",
  pinLabel: "Hidden device password",
  pinRepeatLabel: "Repeat hidden device password",
  pinRepeatPlaceholder: "Please confirm hidden device password",
  success: "Hidden wallet created successfully. Replug your BitBox to unlock it."
};
const initialize$f = {
  create: "Set device password",
  creating: "Setting device password",
  error: {
    e102: "The device password must consist of at least 4 characters."
  },
  info: {
    description1: "Choose your device password. This will be used to unlock your BitBox.",
    description2: "You can use numbers, letters & symbols. Longer passwords offer higher security.",
    description3: "If you lose the device password you will have to reset your device and restore your wallet backup.",
    subtitle: "Now you will set your device password",
    title: "Initializing your device"
  },
  input: {
    label: "Device password",
    labelRepeat: "Repeat device password",
    placeholderRepeat: "Please confirm device password"
  }
};
const invalidFormat$f = "Invalid format";
const language$g = {
  title: "Select language"
};
const legacyhiddenwallet$f = {
  disable: "Disable legacy hidden wallet",
  enable: "Enable legacy hidden wallet",
  successDisable: "Successfully disabled the legacy hidden wallet.",
  successEnable: "Successfully enabled the legacy hidden wallet. Replug your BitBox and enter the hidden device password to access the legacy hidden wallet."
};
const loading$f = "loading";
const manageAccounts$9 = {
  accountHidden: "This account has been hidden from your watch-only accounts. To see it again, please plug in your BitBox02.",
  editAccount: "Edit",
  editAccountNameTitle: "Edit account name",
  noAccounts: "no accounts found",
  settings: {
    hideTokens: "Hide tokens",
    showTokens: "Show tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Add and show/hide accounts",
  title: "Manage accounts",
  watchAccount: "Watch account",
  watchAccountDescription: "This account is part of your watch-only accounts. You can hide it from your watch-only accounts using the toggle."
};
const mobile$a = {
  usingMobileDataWarning: "Mobile data usage: this app may download up to a few hundred megabytes of blockchain header data after unlocking an account. Please connect to Wi-Fi to avoid using mobile data. After dismissing it, this message won't be shown again."
};
const newSettings$8 = {
  about: {
    appVersion: {
      title: "App version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Lock access to the app with screen lock/fingerprint.",
      title: "Screen lock"
    },
    coinControl: {
      description: "Select which UTXOs are part of a transaction to help improve privacy."
    },
    customFees: {
      description: "Lets you enter your own fee when sending."
    },
    torProxy: {
      description: "Connect over Tor for better privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "These additional currencies can be toggled through on your account page.",
      title: "Active currencies"
    },
    darkmode: {
      description: "See the BitBoxApp in dark mode."
    },
    defaultCurrency: {
      description: "Select your default currency",
      title: "Default currency"
    },
    enableAccount: {
      description: "Disabling your account means it will not appear in the sidebar or the portfolio. You can always enable it again from here. Coins on this account will not be affected and will remain safe.",
      title: "Enable/disable account"
    },
    hideAmounts: {
      description: "Displays a toggle to hide your balance and amounts to improve your privacy when using the app in public.",
      hideAmounts: "Hide amounts",
      showAmounts: "Show amounts",
      title: "Allow hiding amounts"
    },
    language: {
      description: "Which language you want the BitBoxApp to use.",
      title: "Language"
    },
    remebmerWallet: {
      name: "Remember wallet",
      warning: "This will remove your remembered wallet. To see it again, you will need to plug in the BitBox02 for this wallet. Any coins on this wallet are not affected. Do you want to continue?",
      warningTitle: "Disable remember wallet"
    },
    toggleSats: {
      description: "Enable or disable Satoshis."
    }
  }
};
const note$b = {
  input: {
    description: "(optional)",
    placeholder: "Add note"
  },
  title: "Note"
};
const notification$f = {
  newTxs_one: "New transaction in: {{accountName}}",
  newTxs_other: "{{count}} new transactions in: {{accountName}}"
};
const pairing$f = {
  aborted: {
    text: "The pairing has been aborted from the mobile app.",
    title: "Aborted"
  },
  button: "Pair mobile app",
  confirm: "Are you sure you want to pair your BitBox? Note that after, the mobile phone is required to perform a transaction.",
  connectOnly: {
    button: "Connect mobile app",
    title: "Scan with our mobile app by selecting the menu item 'Connect to new desktop app'"
  },
  error: {
    text: "Something went wrong. Please start again.",
    title: "Error"
  },
  pullFailed: {
    text: "Failed to pull a message from your mobile through the relay server. The relay server might be offline, please contact support.",
    title: "Pull failed"
  },
  reconnectOnly: {
    button: "Reconnect mobile app"
  },
  scanningFailed: {
    text: "Mobile was not able to scan the message successfully. Please try again.",
    title: "Scanning Failed"
  },
  start: {
    hideAppQRCode: "Hide QR code",
    revealAppQRCode: "Show QR code",
    step1: "If you do not have the mobile app, you can scan the QR code for the Apple App Store or the Google Play Store depending on which phone you have.",
    step2: "Scan with our mobile app, which you can find under the name 'Digital Bitbox 2FA' in the app stores for iOS and Android:"
  },
  started: {
    text: "Now please follow the instructions in the mobile app.",
    title: "Great"
  },
  success: {
    text: "Congratulations, you successfully paired your BitBox with the mobile app!",
    title: "Success"
  },
  timeout: {
    text: "The pairing timed out after two minutes. Start again if you still want to pair the mobile app.",
    title: "Timeout"
  },
  title: "Mobile pairing"
};
const passphrase$9 = {
  considerations: {
    button: "Backup considerations",
    message: "The passphrase adds a layer of protection to your wallet backup (microSD card or recovery words). If someone has access to your backup they will also need the passphrase to access your wallet.\n\nHowever, this means you will need <strong>both the passphrase + wallet backup</strong> to restore your passphrase-enabled wallet, in case your BitBox02 is lost or broken. If you forget or lose your passphrase, you will lose access to all the coins on that wallet.\n\nWhen storing your passphrase, consider putting it in a separate location than your backup. That way if someone finds your backup they dont find your passphrase as well.",
    title: "Backup considerations"
  },
  disable: "Disable passphrase",
  disableInfo: {
    button: "Disable",
    message: "After disabling the passphrase, you will no longer be asked to enter a passphrase after unlocking your BitBox02. Therefore, you will enter your default wallet.\n\nAny coins on your passphrase-wallet will still be on that wallet, however you wont be able to access them because after unlocking your BitBox02, you will open your default wallet.\n\nTo access your passphrase-wallets again, simply re-enable the passphrase feature and enter the relevant passphrase after unlocking the BitBox02.\n\n<strong>Tip:</strong> You can still enter your original wallet by leaving the passphrase empty."
  },
  enable: "Enable passphrase",
  error: {
    e104: "Changing the passphrase setting was aborted."
  },
  how: {
    button: "What it looks like",
    message: "A passphrase doesnt work like a password that youre used to. If you mistype your passphrase, you will not be notified. This is because <strong>every passphrase creates a different, yet valid, wallet</strong>. This means you can use multiple passphrases for as many wallets as you want. But each wallet can only be accessed when typing in the corresponding passphrase.\n\nWhen plugging in your BitBox02, youll be prompted for the device password as usual. After that, youll be asked to enter a passphrase on the device.\n\nAfter entering the passphrase, youll be shown the passphrase you entered. This is so you can confirm you entered it correctly.",
    title: "How does it work"
  },
  intro: {
    message: "A passphrase provides an additional layer of security on top of your wallet.\nLets learn how it works.",
    title: "Setup passphrase"
  },
  progressDisable: {
    message: "Confirm on your BitBox that you want to <strong>disable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  progressEnable: {
    message: "Confirm on your BitBox that you want to <strong>enable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  successDisabled: {
    message: "Optional passphrase <strong>successfully enabled</strong>!\nYoull be asked to provide a passphrase from now on.",
    messageEnd: "Please replug the BitBox02 now.",
    title: "Passphrase enabled"
  },
  successEnabled: {
    message: "Optional passphrase <strong>successfully disabled</strong>!\n\nYou will not be asked to provide a passphrase anymore.",
    messageEnd: "Please replug your BitBox02 now.",
    tips: "Tips",
    tipsList: [
      "We suggest sending a small amount to the passphrase wallet first. Then unplug and replug the BitBox02 and enter your password and passphrase. If you entered the passphrase correctly, you should see the coins in your wallet.",
      "If you want to enter your original wallet without a passphrase, you can still do this by entering nothing when prompted to enter the passphrase. Or you can disable the passphrase feature."
    ],
    title: "Passphrase disabled"
  },
  summary: {
    button: "Enable passphrase",
    title: "Summary",
    understand: "I understand how the passphrase works and the risks associated with it.",
    understandList: [
      "The passphrase is an additional layer of security on top of your backup.",
      "Entering a different passphrase will always generate a different wallet.",
      "To restore your wallet you need <strong>both the passphrase and backup</strong>.",
      "If you forget your passphrase, you can <strong>no longer access your coins</strong>."
    ]
  },
  what: {
    button: "Learn how this works",
    message: "A wallet is created (derived) from a very big random number, also known as a seed. This seed is created when you first set up your BitBox02 and is backed up with the microSD card or recovery words. Anyone who has access to the seed has full control over the funds on that wallet.\n\nA passphrase is an <strong>optional secret</strong>, added to the seed. When using a passphrase, each passphrase creates a new wallet based on the seed + passphrase (optional secret). A passphrase can be anything: letters, words, special characters or it can even be empty. The default wallet is in fact derived from the seed + empty passphrase.\n\nThe passphrase is part of the BIP39 standard, which means it is compatible with all wallets that support the same standard.",
    title: "What is a passphrase?"
  },
  why: {
    button: "Why use a passphrase",
    message: "The BitBox02 protects the seed against extraction from the device itself, but the backup (microSD card or recovery words) gives full access to the wallet. That is why it should be stored in a secure location!\n\nSince a passphrase creates a new wallet using your existing seed, the passphrase-wallet requires both your <strong>backup AND passphrase to restore</strong>. The benefit of this is if someone finds your backup, they still need the passphrase to access the passphrase-wallet.\n\nAdditionally, the passphrase feature allows you to create multiple wallets on the same device, or hidden wallets in addition to the default one.",
    title: "Why use a passphrase?"
  }
};
const password$f = {
  show: "Show {{label}}",
  warning: {
    caps: "WARNING: caps lock () is enabled",
    paste: 'to paste text, enable "SHOW {{label}}"'
  }
};
const random$g = {
  button: "Generate random number",
  description: "Your BitBox generated the following {{bits}}-bit random number:"
};
const receive$h = {
  bitsuranceWarning: "This is an insured account, meaning it can only receive to Native Segwit. This is so you don't accidently receive to Wrapped Segwit or Taproot, which are not insured.",
  changeScriptType: "Change address type",
  label: "Your address",
  onlyThisCoin: {
    description: "To receive other tokens, enable them in the settings. If you deposit other tokens, they might not be accessible.",
    warning: "Make sure to only receive {{coinName}} on this address."
  },
  qrCodeCopiedMessage: "Copied!",
  scriptType: {
    p2tr: "Taproot (newest format)",
    p2wpkh: "Native Segwit (default)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatible format)"
  },
  selectAccount: "Select account",
  showFull: "Show and verify full address on device",
  taprootWarning: "Note: Taproot is a new Bitcoin feature and is not yet widely adopted. Funds received on Taproot addresses may not be visible in third party watch-only wallets. Many wallets and exchanges are not yet able to send to Taproot addresses.",
  title: "Receive {{accountName}}",
  verify: "Verify address securely",
  verifyBitBox01: "Verify address on mobile app",
  verifyBitBox02: "Verify address on BitBox02",
  verifyInstruction: "Please verify that the following address matches the one displayed on your device.",
  warning: {
    secureOutput: "Please pair your BitBox with your mobile device to enable secure address verification. Go to 'Manage device' in the sidebar."
  }
};
const reset$f = {
  description: "All data will be deleted from this device. That includes your Private Key!",
  notReset: "Device NOT reset.",
  title: "Factory reset device",
  understand: "I have a backup and know my recovery password",
  understandBB02: "I have a valid backup"
};
const securityInformation$f = {
  create: {
    description1: "We recommend you set up your device in a safe environment, meaning you are away from other people that could see what password you choose.",
    description2: "You will be asked to create two passwords.",
    description3: "The first is the <strong>device password</strong> which unlocks your BitBox device and can be changed later.",
    description4: "The second is the <strong>recovery password</strong> which unlocks your wallet. This password cannot be changed later.",
    description5: "The wallet you create will be backed up to a file on the microSD card provided. This can be used in an emergency to recover your funds using your <strong>recovery password</strong>.",
    title: "Security information"
  },
  restore: {
    description1: "You will be asked to insert the microSD card you used to store you backup.",
    description2: "To restore your device you will need your recovery password. ",
    description3: "Please take care when entering the recovery password. Any password you enter will create a valid wallet. If you enter the wrong password you may be shown a wallet balance that you do not expect.",
    title: "Security information"
  }
};
const seed$f = {
  agreements: {
    "funds-access": "I will NOT be able to access my funds if I forget my recovery password",
    "password-change": "I can NOT change the recovery password later",
    "password-required": "The recovery password is required to restore a wallet from a backup"
  },
  create: "Create wallet",
  creating: "Creating wallet",
  description: "I understand that:",
  error: {
    e102: "The password must consist of at least 4 characters.",
    e200: "You need to insert a microSD card into your BitBox in order to create a wallet, so a backup can be created automatically."
  },
  info: {
    button: "Set recovery password now",
    description1: "Insert the microSD card into the BitBox",
    description2: "Choose a recovery password for the wallet and select Set recovery password now",
    description3: "The back up to microSD card and your recovery password is the only method to recover your funds in case of lost or stolen BitBox device.",
    description4: "You cannot change your recovery password later on without transferring your funds.",
    title: "Create a new wallet"
  },
  password: {
    label: "Recovery password",
    repeatPlaceholder: "Repeat recovery password"
  },
  walletName: {
    label: "Wallet name"
  }
};
const seedRestore$f = {
  error: {
    e200: "Restoring a wallet from a backup requires the microSD card."
  },
  info: {
    description1: "Insert the microSD card into the BitBox and click Continue",
    description2: "Choose a backup and click Restore",
    description3: "Enter the recovery password",
    description4: "You need to confirm to understand that an incorrect password will create a different wallet.",
    title: "How to restore a wallet from a backup"
  }
};
const send$h = {
  abort: "The transaction has been aborted.",
  address: {
    label: "Receiver address",
    placeholder: "Enter address"
  },
  amount: {
    label: "Amount",
    placeholder: "Enter amount"
  },
  availableBalance: "Available balance",
  button: "Review",
  coincontrol: {
    address: "Address",
    outpoint: "Outpoint",
    title: "Send from output"
  },
  confirm: {
    "selected-coins": "Selected coins",
    title: "Confirm and send transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "It seems like you do not have enough Ether to pay for this ERC20 transaction. Please make sure you hold enough Ether in your wallet",
    feeTooLow: "fee too low",
    feesNotAvailable: "Could not estimate fees",
    insufficientFunds: "insufficient funds",
    invalidAddress: "invalid address",
    invalidAmount: "invalid amount",
    invalidData: "invalid data"
  },
  fee: {
    customPlaceholder: "Enter amount",
    label: "Network fee",
    placeholder: "Not available"
  },
  feeTarget: {
    customLabel: "Fee rate",
    customLabel_eth: "Gas price",
    description: {
      economy: "4 hours (24 blocks)",
      economy_eth: "30 minutes or less",
      economy_ltc: "1 hour (24 blocks)",
      high: "20 minutes (2 blocks)",
      high_eth: "30 seconds or less",
      high_ltc: "5 minutes (2 blocks)",
      low: "2 hours (12 blocks)",
      low_eth: "5 minutes or less",
      low_ltc: "30 minutes (12 blocks)",
      normal: "1 hour (6 blocks)",
      normal_eth: "2 minutes or less",
      normal_ltc: "15 minutes (6 blocks)"
    },
    estimate: "Estimated confirmation time:",
    label: {
      custom: "Custom",
      economy: "Economy",
      high: "High",
      low: "Low",
      normal: "Normal"
    },
    placeholder: "Calculating fee"
  },
  maximum: "Send all",
  maximumSelectedCoins: "Send selected coins",
  noFeeTargets: "Fee rate estimations are currently unavailable. Please try again later or enter a custom fee.",
  priority: "Priority",
  scanQR: "Scan QR code",
  scanQRNoCameraMessage: "Camera not found. Please ensure that your device supports a camera and permissions are correctly set.",
  signprogress: {
    description: "This is a transaction containing a lot of data. To fully sign the transaction, you will be asked to confirm {{steps}} times.",
    label: "Progress"
  },
  success: "The transaction has been signed and sent.",
  title: "Send {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Transaction details"
};
const settings$g = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Advanced settings",
  appearance: "Appearance",
  electrum: {
    add: "Add a server",
    "add-server": "Add",
    check: "Check",
    checkFailed: "Failed",
    checkSuccess: "Successfully established a connection to {{host}}",
    checking: "Checking",
    "download-cert": "Download remote certificate",
    "remove-server": "Remove",
    removeConfirm: "Remove {{server}}?",
    reset: "Reset to default",
    resetConfirm: "Do you want to remove all servers and install the default servers?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Enter the endpoint.",
    step2: "2",
    "step2-text": "Enter a certificate of the server's certificate chain. Alternatively, download the remote certificate and compare it visually.",
    "step2-text-tcp": "You can skip this step if you do not want to use TLS.",
    step3: "3",
    "step3-text": "Check the connection and add the server.",
    step4: "4",
    "step4-text": "Restart the wallet. If you do not remove the default servers, your own node will be added as a redundancy.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Enable coin control",
    electrum: {
      description: "You can connect to your own Electrum full node.",
      title: "Connect your own full node"
    },
    fee: "Enable custom fees",
    setProxyAddress: "Set proxy address",
    title: "Expert settings",
    useProxy: "Enable tor proxy",
    useSats: "Display BTC values in Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "New update available",
    title: "Info",
    "up-to-date": "Your app is up to date",
    version: "App Version"
  },
  restart: "Please re-start the BitBoxApp for the changes to take effect.",
  services: {
    title: "Services"
  },
  success: "Please unplug and replug the BitBox for the changes to take effect.",
  title: "Settings"
};
const setup$f = "Setup device";
const sidebar$g = {
  buy: "Buy crypto",
  device: "Manage device",
  insurance: "Insurance",
  leave: "Leave",
  settings: "Settings"
};
const success$m = {
  create: {
    info1: "Your wallet has been securely backed up to the microSD Card. Remove it and keep it safe.",
    info2: "You have created a secure device password that unlocks the BitBox.",
    info3: "You have created a secure recovery password for your wallet that unlocks your funds and restores your backups.",
    summary: "Here is a summary of what you have done",
    title: "Success"
  },
  getstarted: "Get started",
  restore: {
    summary: "You have successfully restored a wallet from your backup.",
    title: "Success"
  }
};
const transaction$g = {
  confirmation: "Confirmations",
  details: {
    activity: "Activity",
    address: "Address",
    amount: "Amount",
    date: "Date",
    fiat: "Fiat",
    fiatAmount: "Fiat amount",
    fiatAtTime: "Fiat at time of transaction",
    status: "Status",
    title: "Transaction Details",
    type: "Type"
  },
  explorer: "Transaction ID",
  explorerTitle: "Open in external block explorer",
  fee: "Fee",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "Edit note",
    save: "Save note"
  },
  pending: "Pending transaction",
  size: "Size",
  status: {
    complete: "Complete",
    failed: "Failed",
    pending: "Pending"
  },
  tx: {
    received: "Received to",
    sent: "Sent to"
  },
  vsize: "Virtual size",
  weight: "Weight"
};
const transactions$f = {
  errorLoadTransactions: "There was an error loading the transactions",
  placeholder: "No transactions yet."
};
const unknownError$f = "An unknown error occurred: {{errorMessage}}";
const unlock$f = {
  description: "Enter your device password to unlock your device.",
  error: {
    e109_normal: "Wrong device password. {{remainingAttempts}} attempts remain before the device is reset.",
    e109_touch: "$t(unlock.error.e109_normal) The next login requires holding the touch button.",
    e113: "Due to many login attempts, the next login requires holding the touch button for 4 seconds."
  },
  input: {
    label: "Device password",
    placeholder: "Enter your device password to unlock the device"
  },
  unlocking: "Unlocking"
};
const upgradeFirmware$g = {
  button: "Upgrade firmware",
  description: "Do you want to upgrade the firmware from version {{currentVersion}} to {{newVersion}}?",
  label: "Your BitBox requires a firmware upgrade.",
  locked: "To upgrade from {{currentVersion}} to {{newVersion}}, please do a long touch.",
  title: "Upgrade firmware",
  unlocked: "The bootloader is unlocked. To continue, please:",
  unlocked1: "Unplug and replug your Bitbox",
  unlocked2: "The LED will light up when your BitBox is plugged back in",
  unlocked3: "Tap the touch button when the LED lights up"
};
const walletConnect$a = {
  connect: {
    button: "Connect",
    dappLabel: "Enter URI address of dapp",
    invalidPairingUri: "Invalid pairing uri"
  },
  dashboard: {
    allSessions: "All sessions",
    disclaimer: "Walletconnect is a protocol to connect to Ethereum based Dapps. These dapps are run by third-party services, so only connect to dapps you trust and be sure to always know what you are signing when making a transaction.",
    newConnection: "New connection",
    noConnectedSessions: "No accounts are currently connected to any dapps."
  },
  invalidPairingChain: "Error in approving pairing. Please make sure to use one of the supported chains: {{chains}}",
  pairingRequest: {
    approve: "Approve Connection",
    reject: "Reject",
    title: "New connection request from"
  },
  pairingSuccess: "Dapp successfully connected. You can continue on the dapp website.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Failed to parse data",
    decodeError: "Failed to decode message",
    method: {
      sendTransaction: "Sign and send transaction",
      signMessage: "Sign message",
      signTransaction: "Sign transaction",
      signTypedData: "Sign typed data"
    },
    successfullySigned: "Request succesfully signed",
    walletConnectRequest: "WalletConnect request"
  },
  useNewUri: "This URI has already been used to attempt a connection. Please use a new URI.",
  walletConnect: "WalletConnect"
};
const warning$l = {
  receivePairing: "Please pair the BitBox to enable secure address verification. Go to 'Manage device' in the sidebar.",
  sdcard: "Keep the microSD card stored separate from the BitBox, unless you want to manage backups.",
  sendPairing: "Please pair the BitBox to securely verify transaction details. Go to 'Manage device' in the sidebar."
};
const welcome$f = {
  connect: "Connect BitBox02",
  getStarted: "Let's get started by installing firmware on your BitBox02.",
  insertBitBox02: "For the BitBox02, please tap the device to continue.",
  insertDevice: "Please connect your device to get started",
  title: "Welcome"
};
const appTranslationsEN = {
  account: account$f,
  accountInfo: accountInfo$f,
  accountSummary: accountSummary$f,
  addAccount: addAccount$g,
  aopp: aopp$9,
  app: app$f,
  auth: auth$9,
  backup: backup$f,
  bb02Bootloader: bb02Bootloader$f,
  bitbox: bitbox$f,
  bitbox02Interact: bitbox02Interact$f,
  bitbox02Settings: bitbox02Settings$f,
  bitbox02Wizard: bitbox02Wizard$f,
  bitsurance: bitsurance$8,
  bitsuranceAccount: bitsuranceAccount$8,
  blink: blink$f,
  bootloader: bootloader$f,
  button: button$k,
  buy: buy$b,
  changePin: changePin$f,
  chart: chart$b,
  checkSDcard: checkSDcard$f,
  clickHere: clickHere$f,
  confirm: confirm$h,
  confirmOnDevice: confirmOnDevice$f,
  connectKeystore: connectKeystore$9,
  darkmode: darkmode$9,
  device: device$f,
  deviceLock: deviceLock$f,
  deviceSettings: deviceSettings$f,
  deviceTampered: deviceTampered$f,
  dialog: dialog$g,
  error: error$b,
  fiat: fiat$h,
  footer: footer$h,
  generic: generic$b,
  genericError: genericError$f,
  goal: goal$f,
  guide: guide$g,
  headerssync: headerssync$f,
  hiddenWallet: hiddenWallet$f,
  initialize: initialize$f,
  invalidFormat: invalidFormat$f,
  language: language$g,
  legacyhiddenwallet: legacyhiddenwallet$f,
  loading: loading$f,
  manageAccounts: manageAccounts$9,
  mobile: mobile$a,
  newSettings: newSettings$8,
  note: note$b,
  notification: notification$f,
  pairing: pairing$f,
  passphrase: passphrase$9,
  password: password$f,
  random: random$g,
  receive: receive$h,
  reset: reset$f,
  securityInformation: securityInformation$f,
  seed: seed$f,
  seedRestore: seedRestore$f,
  send: send$h,
  settings: settings$g,
  setup: setup$f,
  sidebar: sidebar$g,
  success: success$m,
  transaction: transaction$g,
  transactions: transactions$f,
  unknownError: unknownError$f,
  unlock: unlock$f,
  upgradeFirmware: upgradeFirmware$g,
  walletConnect: walletConnect$a,
  warning: warning$l,
  welcome: welcome$f
};
const account$e = {
  disconnect: "Connexion perdue. Tentative de reconnexion",
  "export": "Exporter",
  exportTransactions: "Exporter les transactions vers le dossier Tlchargements sous forme de fichier CSV",
  fatalError: "Une erreur inattendue s'est produite.",
  incoming: "Entrant",
  initializing: "Rcupration d'informations de la blockchain",
  insuranceExpired: "<strong>Le compte n'est plus assur</strong>\n\nLe plan d'assurance pour ce compte a t modifi.\nVeuillez consulter la page d'assurance pour plus de dtails.",
  insured: "Compte assur",
  maybeProxyError: "Proxy Tor activ. Assurez-vous que votre proxy Tor fonctionne correctement, ou dsactivez la configuration du proxy.",
  reconnecting: "Connexion perdue, tentative de reconnexion",
  syncedAddressesCount: "{{count}} adresses scannes",
  uncoveredFundsLink: "Suivez ce guide pour savoir comment dplacer vos coins.",
  warning: "Avertissement !"
};
const accountInfo$e = {
  address: "Adresse",
  buyCTA: {
    buy: "Acheter {{unit}}",
    buyCrypto: "Acheter de la Crypto",
    information: {
      looksEmpty: "On dirait que ce portefeuille est vide",
      start: "Commencez par dposer des fonds dans le portefeuille ou bien achetez en directement dans l'application BitBoxApp."
    }
  },
  extendedPublicKey: "Cl publique tendue",
  label: "Informations du compte",
  scriptType: "Type de scrypt",
  title: "Informations sur le compte",
  verify: "Vrifier sur l'appareil",
  xpubTypeChangeBtn: {
    p2pkh: "Afficher la cl publique tendue (xpub) P2PKH legacy",
    p2tr: "Voir Taproot",
    p2wpkh: "Voir Native Segwit",
    "p2wpkh-p2sh": "Afficher l'ancienne cl publique tendue (xpub) Segwit"
  },
  xpubTypeInfo: "Affichage actuellement de la cl publique tendue {{scriptType}} ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$e = {
  availableBalance: "Solde disponible",
  balance: "Solde",
  exportSummary: "Exporter un extrait des comptes vers le dossier de Tlchargements sous forme de fichier CSV",
  fiatBalance: "Solde en devise",
  name: "Nom du compte",
  noAccount: "Il n'y a pas de compte  montrer.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Vue globale de mon portefeuille",
  total: "Total",
  transactionHistory: "Historique des transactions"
};
const addAccount$f = {
  chooseName: {
    nextButton: "Ajouter un compte",
    step: "Donner un nom au compte",
    title: "Donnez un nom  votre compte"
  },
  selectCoin: {
    nextButton: "Suivant",
    step: "Slectionner un coin (pice)",
    title: "Slectionnez une crypto-monnaie"
  },
  success: {
    addAnotherAccount: "Ajouter un autre compte",
    message: "<strong>{{accountName}}</strong> a maintenant t ajout  vos comptes.",
    nextButton: "Termin",
    step: "Fini",
    title: "Compte ajout"
  },
  title: "Ajouter un compte"
};
const aopp$8 = {
  addressRequest: "{{host}} exige une adresse de rception.",
  addressRequestWithLogo: "exige une adresse de rception.",
  banner: "Demande d'adresse en cours",
  errorTitle: "Erreur durant la demande d'adresse",
  labelAddress: "Adresse",
  labelMessage: "Message",
  reverifyInfoText: "Vrification de l'adresse",
  signing: "Afin de continuer, veuillez signer le message  l'aide de votre BitBox02",
  success: {
    message: "Continuer sur {{host}}",
    title: "Adresse envoye avec succs"
  },
  syncing: "Synchronisation du compte, veuillez patienter.",
  title: "Demande d'adresse"
};
const app$e = {
  upgrade: "Une nouvelle version de cette application est disponible ! Veuillez mettre  jour de la {{current}}  la {{version}}."
};
const auth$8 = {
  authButton: "Authentification",
  title: "Veuillez vous authentifier pour continuer"
};
const backup$e = {
  check: {
    checking: "Vrification de la sauvegarde",
    confirmTitle: "Vrifier la sauvegarde",
    notOK: "La sauvegarde ne correspond PAS  ce portefeuille.",
    ok: "La sauvegarde correspond au portefeuille.",
    password: {
      label: "Mot de passe de rcupration",
      placeholder: "Mot de passe de rcupration",
      showLabel: "mot de passe de rcupration"
    },
    success: "Sauvegarde vrifie avec succs :",
    title: "Vrifier la sauvegarde"
  },
  create: {
    alreadyExists: "Vous avez dj une sauvegarde valide. Souhaitez-vous la recrer ?",
    fail: "La cration de la sauvegarde a chou !",
    info: "Veuillez saisir le mot de passe de rcupration du portefeuille actuel pour vrification.",
    name: {
      label: "Nom de la sauvegarde",
      placeholder: "Veuillez nommer la sauvegarde"
    },
    password: {
      label: "Mot de passe de rcupration",
      placeholder: "Veuillez entrer votre mot de passe de rcupration"
    },
    title: "Crer une sauvegarde",
    verificationFailed: "Le mot de passe de rcupration NE CORRESPOND PAS  ce portefeuille. La sauvegarde a t cre. Veuillez utiliser Vrifier la sauvegarde pour vrifier  nouveau votre mot de passe de rcupration."
  },
  description: "Slectionnez le <strong>fichier de sauvegarde du portefeuille</strong>.",
  insert: "Veuillez insrer la carte microSD pour grer les sauvegardes.",
  insertButton: "J'ai insr la carte microSD",
  list: "Vos sauvegardes sur la carte microSD",
  noBackups: "Il n'existe aucune sauvegarde sur cette carte micro SD.",
  restore: {
    confirmTitle: "Restaurer la sauvegarde",
    error: {
      e200: "Carte microSD non trouve",
      general: "Erreur lors de la restauration de la sauvegarde"
    },
    password: {
      label: "Mot de passe de rcupration ou mot de passe de rcupration cach",
      placeholder: "Mot de passe de rcupration",
      repeatPlaceholder: "Rpter le mot de passe de rcupration",
      showLabel: "Mot de passe de rcupration"
    },
    restoring: "Restauration de la sauvegarde",
    selectedBackup: "<strong>{{backupName}}</strong> cr le {{createdDateTime}} sera restaur.",
    title: "Restaurer",
    understand: "Je comprends qu'un mot de passe de rcupration incorrect crera un portefeuille diffrent."
  },
  showMnemonic: {
    description: "24 mots de rcupration vont vous tre prsents; ils constituent une sauvegarde de votre portefeuille. Notez-les sur papier.\n\n<strong>Ne les stockez pas sur un support numrique et ne les prenez pas en photo.</strong>\n\n<strong>Ne prononcez pas les mots  haute voix.</strong>\n\n<strong>Cette sauvegarde n'est pas protge par un mot de passe.</strong>.\n\nIl vous sera demand ensuite de confirmer chacun de ces mots.",
    title: "Montrer les mots de rcupration",
    warning: "<strong>Ne partagez jamais vos mots de rcupration avec qui que ce soit.</strong> Vos mots de rcupration permettent un accs intgral  votre portefeuille. Si on vous demande vos mots de rcupration, il sagit dune escroquerie, ne les partagez jamais !"
  },
  title: "Grer les sauvegardes"
};
const bb02Bootloader$e = {
  abort: "Ne pas mettre  jour - Revenir en arrire",
  abort_noUpgrade: "Retour en arrire",
  advanced: {
    label: "Paramtres avancs",
    toggleShowFirmwareHash: "Afficher le hash du firmware  chaque dmarrage de l'application"
  },
  flipscreen: "Retourner l'cran",
  orientation: "Appareil dans le mauvais sens ?",
  success: "Mise  jour russie ! Continue dans {{rebootSeconds}} secondes...",
  success_install: "Installation russie ! Poursuite dans {{rebootSeconds}} secondes..."
};
const bitbox$e = {
  error: {
    e10000: "Mot de passe de l'appareil incorrect.",
    e10001: "La tentative de remplacer le mot de passe de l'appareil a chou",
    e102: "Le mot de passe doit comporter au minimum 4 caractres.",
    e112: "Le mot de passe cach ne peut pas tre identique au mot de passe principal de l'appareil."
  }
};
const bitbox02Interact$e = {
  confirmDate: "Confirmez la date du jour sur votre BitBox02",
  confirmDateText: "Cette date sera utilise pour crer votre sauvegarde.",
  confirmName: "Confirmez le nom sur le BitBox02",
  confirmWords: "Notez les {{amount}} mots de rcupration depuis votre BitBox02",
  confirmWordsText: "Ensuite, la BitBox02 vous demandera de confirmer chaque mot afin de sassurer que la sauvegarde a t correctement effectue.",
  followInstructions: "Veuillez suivre les instructions sur votre BitBox02.",
  followInstructionsMnemonic: "Suivez les instructions sur votre BitBox02 afin de saisir les mots de rcupration de votre sauvegarde et restaurer ainsi votre portefeuille.",
  followInstructionsMnemonicTitle: "Restaurer  partir des mots de rcupration"
};
const bitbox02Settings$e = {
  deviceName: {
    current: "Nom du priphrique actuel",
    error: "Le nom de l'appareil n'a pas pu tre configur",
    error_104: "La confirmation du nom de l'appareil a t interrompu sur celui-ci.",
    input: "Nom du BitBox02",
    placeholder: "Nouveau nom de priphrique",
    title: "Dfinir le nom de votre BitBox02"
  },
  gotoStartupSettings: {
    description: "Cela va rebooter votre BitBox02 et entrer les paramtres de dmarrage.",
    title: "Aller aux paramtres de dmarrage"
  }
};
const bitbox02Wizard$e = {
  advanced: {
    button: "Options avances",
    outOfDate: "Le micrologiciel n'est pas  jour et ne permet pas cette fonctionnalit",
    seed12WordInfo: "Veuillez noter que le nombre de mots ne peut pas tre modifi aprs la cration du portefeuille.",
    seed12WordLabel: "Crer une seed de 12 mots plutt que de 24 mots",
    seed12WordText: "Par dfaut, la BitBox02 utilise une seed de 24 mots. Dans la pratique, les deux longueurs de seed sont fiables contre les attaques par force brute. Toutefois, certains utilisateurs peuvent prfrer la commodit inhrente  une seed de 12 mots.",
    skipSDCardLabel: "Sauter ltape de sauvegarde sur la carte microSD et crire les mots de rcupration plutt.",
    skipSDCardText: "Vous avez toujours la possibilit de crer une sauvegarde sur la carte microSD ou d'crire vos mots de rcupration aprs la configuration. Vous pouvez le faire  partir des paramtres.",
    title: "Options de sauvegarde avances"
  },
  attestationFailed: "L'authentification a chou. Ceci est potentiellement d au redmarrage de l'application alors que l'appareil attendait une saisie de la part de l'utilisateur. Veuillez vous reconnecter et essayer  nouveau. Si cela persiste, veuillez contacter support@bitbox.swiss",
  backup: {
    point1: "Slectionner une sauvegarde sur la carte micro SD",
    point2: "Dfinissez un mot de passe pour votre appareil",
    restoreText: "Ok, restaurons une sauvegarde !",
    text1: "Parfait, le mot de passe pour votre BitBox02 est dfini et votre portefeuille est cr. Il est maintenant temps de procder  votre premire sauvegarde. Assurez-vous que la carte micro SD soit bien insre dans l'appareil et continuez.",
    text2: "Veuillez suivre les instructions sur l'cran de votre appareil pour crer une sauvegarde.",
    text3: "Une fois votre sauvegarde cre, veuillez retirer la carte micro SD et la conserver dans un endroit <strong>scuris</strong>. Le contenu de la carte micro SD n'est pas protg par mot de passe. Ne l'insrez jamais dans un appareil autre que votre BitBox02.",
    userConfirmation1: "Je devrais stocker ma sauvegarde dans un endroit sr.",
    userConfirmation2: "Ma sauvegarde n'est pas protge par mot de passe. Quiconque y a accs peut accder  mon portefeuille.",
    userConfirmation3: "Si je perds ou endommage mon BitBox02, la seule faon de rcuprer mes fonds est de restaurer  partir de ma sauvegarde.",
    userConfirmation4: "Si je perds ou endommage  la fois ma sauvegarde et ma BitBox02, mes fonds seront perdus.",
    userConfirmation5: "Je ne dois pas insrer ma carte de sauvegarde microSD dans un ordinateur, un tlphone, une imprimante ou tout appareil autre qu'un BitBox02.",
    userConfirmation5mnemonic: "Je ne dois pas saisir mes mots de rcupration dans un ordinateur, un tlphone, une imprimante ou tout autre appareil autre qu'une BitBox02."
  },
  create: {
    button: "Nommer l'appareil et continuer",
    info: "Voici les tapes de base  suivre pour configurer votre BitBox :",
    inputTitle: "Nom du portefeuille",
    point1: "Nommez votre appareil",
    point2: "Dfinir un mot de passe pour votre appareil",
    point3: "Crer une sauvegarde",
    text: "Ok, crons un nouveau portefeuille !"
  },
  createBackupAborted: "Cration de la sauvegarde interrompue.",
  createBackupFailed: "La cration de la sauvegarde a chou, veuillez ressayer.",
  initialize: {
    passwordText: "Dfinissons maintenant un mot de passe pour votre appareil. Utilisez les commandes de votre BitBox pour entrer et choisir un mot de passe.",
    passwordTitle: "Dfinissez un mot de passe pour votre BitBox",
    text: "Votre BitBox02 a t appair avec succs ! Initialisons maintenant votre appareil. Commencez par choisir de crer un nouveau portefeuille ou de restaurer un portefeuille  partir d'une sauvegarde existante. <strong>Veuillez vous assurer que vous avez une carte micro SD insre dans votre BitBox02</strong>.",
    tip: "Nous recommandons de continuer dans un environnement scuris.",
    title: "Initialiser votre BitBox"
  },
  insertSDCard: "<strong>Assurez-vous d'avoir une carte micro SD insre dans votre BitBox02.</strong>",
  noPasswordMatch: "Le mot de ",
  pairing: {
    failed: "Appariement non confirm. Veuillez rebrancher votre BitBox02.",
    paired: "Vous avez confirm le code suivant sur votre appareil. Veuillez continuer.",
    title: "Vrifier le code d'appairage",
    unpaired: "Une BitBox02 non-associe a t dtecte. Veuillez vrifier que le code dassociation correspond  celui indiqu sur votre BitBox02."
  },
  restoreFromMnemonic: {
    e104: "La restauration  partir des mots de rcupration a t annule.",
    failed: "La restauration  partir des mots de rcupration a chou, veuillez ressayer."
  },
  stepBackup: {
    beforeProceed: "Avant de continuer, veuillez lire ces importantes mesures de scurit :",
    createBackup: "Vous allez maintenant crer une sauvegarde sur votre carte microSD.",
    createBackupMnemonic: "Vous allez  prsent noter les mots de rcupration."
  },
  stepBackupSuccess: {
    fundsSafe: "Pour assurer la scurit de vos fonds, n'oubliez pas ce qui suit :",
    title: "Sauvegarde restaure !"
  },
  stepConnected: {
    unlock: "Entrez le mot de passe du BitBox02 pour le dverrouiller."
  },
  stepCreate: {
    description: "Ce nom est utilis comme celui de l'appareil et pour la sauvegarde.",
    nameLabel: "Nom du BitBox02",
    namePlaceholder: "Mon BitBox02",
    title: "Choisissez le nom du BitBox02",
    toastMicroSD: "Veuillez insrer votre carte microSD dans votre BitBox02, elle sera utilise pour stocker une sauvegarde du portefeuille."
  },
  stepCreateSuccess: {
    removeMicroSD: "Veuillez retirer la carte microSD de votre BitBox02 et la stocker dans un endroit sr.",
    storeMnemonic: "Veuillez conserver vos mots de rcupration dans un emplacement sr",
    success: "Vous avez cr votre sauvegarde avec succs."
  },
  stepInsertSD: {
    insertSDCard: "Veuillez insrer une carte microSD dans votre BitBox02 pour continuer.",
    insertSDcardTitle: "Insrer une carte microSD"
  },
  stepPassword: {
    e104: "Le paramtrage du mot de passe a t abandonn.",
    title: "Dfinissez le mot de passe du BitBox02",
    useControls: "Utilisez les touches de votre BitBox02 pour dfinir un mot de passe."
  },
  stepUninitialized: {
    create: "Je veux configurer un nouveau BitBox02.",
    restore: "Je veux restaurer mon portefeuille  partir d'une sauvegarde.",
    restoreMicroSD: "Restauration  partir d'une carte microSD",
    restoreMnemonic: "Restaurer  partir des mots de rcupration",
    title: "Configurez votre BitBox02"
  },
  success: {
    text: "Hourra ! Votre BitBox02 est maintenant prt  l'emploi. \n\nPour plus d'informations sur l'utilisation de l'application BitBox, veuillez utiliser le guide d'utilisation en cliquant sur le point d'interrogation situ dans le coin suprieur droit.",
    title: "Vous tes prt !"
  }
};
const bitsurance$7 = {
  dashboard: {
    active: "Police d'assurance active",
    button: "Assurer un nouveau compte",
    canceled: "Annul",
    coverage: "Couverture maximale",
    inactive: "Inactif",
    processing: "Traitement",
    refused: "Refus",
    supportLink: "Gestion du contrat",
    title: "Comptes assurs",
    waitpayment: "En attente de paiement"
  },
  detect: {
    button: "Vrification de l'existence d'une assurance",
    insured: "Compte assur dtect :",
    notInsured: "Aucun compte assur n'a pu tre dtect. Si vous tes certain d'avoir un compte assur, vrifiez d'avoir bien connect le wallet correspondant.",
    text: "Si vous avez dj souscrit  Bitsurance, l'application BitBoxapp peut se synchroniser automatiquement avec votre couverture d'assurance existante.",
    title: "Dj assur ?"
  },
  insure: {
    button: "Vrifier la disponibilit et les tarifs",
    faq: "Plus d'informations sur les FAQs de Bitsurance",
    listItem1: "Cambriolage",
    listItem2: "Extorsion (par exemple: attaque avec un objet contondant)",
    listItem3: "Destruction due au feu,  l'eau ou autres catastrophes naturelles",
    month: "mois",
    text: "Assurez votre BitBox02 et jusqu' une valeur de 100 000  en Bitcoin",
    text3: "Disponible actuellement en Allemagne, avec d'autres zones gographiques  suivre.",
    title: "Dmarrer"
  },
  intro: {
    link: "Site web de Bitsurance",
    text1: "BitBox travaille conjointement avec Bitsurance pour ajouter une couche de protection supplmentaire  vos bitcoins. Alors que BitBox02 assure la scurit de vos fonds, Bitsurance couvre les menaces domestiques qui ne peuvent tre prises en charge par la technologie seule, comme par exemple le cambriolage, l'extorsion ou bien la destruction du hardware wallet lui-mme."
  },
  terms: {
    link: "Politique de confidentialit de Bitsurance",
    text1: "Bitsurance est un service tiers indpendant. Pour toute question concernant leurs offres et les demandes d'assurance, veuillez contacter Bitsurance directement.",
    text2: "L'assurance est actuellement disponible en Allemagne, avec d'autres zones gographiques  suivre",
    text3: "La couverture Bitcoin maximale actuellement disponible est de 100 000 euros par personne. Des montants plus levs sont prvus  l'avenir.",
    text4: "Des informations personnelles ainsi que la cl publique tendue de votre compte assur font partie de la police d'assurance et seront partages avec Bitsurance et le courtier."
  },
  title: "Assurance"
};
const bitsuranceAccount$7 = {
  errorNoXpub: "Erreur : Il n'a pas t possible d'obtenir la xpub de ce compte.",
  noAccount: "Aucun compte ne peut tre assur.",
  select: "Slectionner un compte",
  title: "Assurance"
};
const blink$e = {
  button: "Clignoter"
};
const bootloader$e = {
  button: "Mettre  jour le micrologiciel maintenant",
  button_install: "Installer le firmware maintenant",
  progress: "Mise  jour : {{progress}}%",
  progress_install: "Installation : {{progress}}%",
  success: "Mise  jour russie ! Veuillez rebrancher l'appareil. Cette fois, ne touchez pas le bouton."
};
const button$j = {
  abort: "Abandonner",
  back: "Retour",
  buy: "Acheter",
  changepin: "Changer le mot de passe de l'appareil",
  check: "Vrifier la sauvegarde",
  "continue": "Continuer",
  copy: "Copie",
  create: "Crer",
  dismiss: "Ignorer",
  done: "Termin",
  download: "Tlcharger",
  hiddenwallet: "Crer un portefeuille cach",
  next: "Suivant",
  ok: "D'accord",
  previous: "Prcdent",
  receive: "Recevoir",
  restore: "Restaurer",
  select: "Slectionner",
  send: "Envoyer",
  unlock: "Dverrouiller",
  update: "Mise  jour",
  upgrade: "Mettre  jour"
};
const buy$a = {
  exchange: {
    bankTransfer: "Virement bancaire",
    bestDeal: "Meilleure offre",
    creditCard: "Carte de crdit",
    fast: "Rapide",
    fee: "frais",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Virement Bancaire: {{fee}}%",
          creditDebitCard: "Carte de crdit/dbit: {{fee}}%",
          learnMore: "En savoir plus sur Moonpay",
          title: "Frais"
        },
        fullCurrenciesList: "Voir la liste complte des devises ici",
        payment: {
          asteriskText: "* Non disponible pour les rsidents amricains",
          bankTransfer: "Virement bancaire*",
          bankTransferDetails: {
            pix: "PIX (transactions BR au Brsil uniquement)",
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          creditDebitCard: "Carte de crdit/dbit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "Voir plus de dtails sur les mthodes de paiement",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte toutes les principales devises fiat : USD, EUR, CHF, et autres."
      },
      pocket: {
        fees: {
          info: "Virement bancaire : {{fee}}%",
          title: "Frais"
        },
        learnMore: "En savoir plus sur Pocket",
        payment: {
          bankTransfer: "Virement bancaire",
          bankTransferDetails: {
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            sic: "SIC - Swiss Interbank Clearing (Transactions CHF en Suisse/Liechtenstein uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          bankTransferReccuring: "Comment mettre en place des achats rcurrents avec un ordre permanent?",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte les devises Europennes : EUR, GBP et CHF",
        verification: {
          info: "La vrification de l'identit n'est requise qu'au-del des limites quotidiennes et annuelles.",
          link: "Consulter les limites en vigueur, ici.",
          title: "Vrification de l'identit"
        }
      },
      region: {
        title: "Slectionnez la zone gographique de domiciliation de votre compte bancaire afin de dterminer les options  votre disposition."
      }
    },
    noExchanges: "Dsol, aucun change disponible dans cette zone gographique",
    region: "Zone Gographique",
    selectRegion: "Non spcifi",
    title: "Acheter du {{name}}"
  },
  info: {
    "continue": "Accepter et continuer",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nous avons un partenariat avec MoonPay afin de vous permettre d'acheter simplement des {{name}} directement depuis BitBoxApp. Quelques clics suffisent.",
        "MoonPay est une plateforme qui permet dacheter des {{name}} de manire simple et rapide dans plus de 160 pays."
      ],
      payment: {
        details: "Vous pouvez acheter des {{name}} instantanment via MoonPay avec les mthodes de paiement suivantes. Les achats par carte de crdit ou de dbit sont faciles et instantans, mais plus chers en raison du risque de rtro-facturation plus lev. Nous vous recommandons d'utiliser l'option du virement bancaire pour les montants plus importants. Les frais minimum sont de 4 USD/EUR ou quivalent.",
        footnote: "Veuillez noter que les taux de change de MoonPay peuvent diffrer de ceux utiliss dans BitBoxApp, ce qui peut entraner potentiellement des montants lgrement diffrents.",
        table: {
          "1_description": "Frais les plus bas, peut prendre jusqu' 3 jours ouvrables",
          "1_method": "Virements bancaires (SEPA)",
          "2_description": "Frais plus levs mais rapides et directs",
          "2_method": "Cartes de crdit et de dbit",
          description: "Description",
          fee: "Frais",
          method: "Mthode"
        },
        title: "Modes de paiement et frais"
      },
      privacyPolicy: "Politique de confidentialit de MoonPay",
      protection: {
        description: "BitBoxApp ne collecte aucune donne lors de l'achat de {{name}}, les fonds entrants sont traits comme une transaction normale. MoonPay a besoin de collecter certaines donnes personnelles afin de fonctionner. Leur politique de confidentialit dcrit en dtail la faon dont ces donnes sont traites.",
        descriptionGeneric: "BitBoxapp ne collecte aucune donne lors de l'achat de {{nom}}, les fonds entrants sont traits comme une transaction normale. Cependant, les exchanges partenaires ont besoin de recueillir certaines informations pour fonctionner. Veuillez vous rfrer  leurs politiques de confidentialit respectives pour voir plus en dtail comment sont traites ces donnes.",
        title: "Protection des donnes"
      },
      security: {
        description: "Lorsque vous achetez du {{name}} via MoonPay, vous utilisez un service externe. Ce service est hors de porte du modle scurit contre les menaces de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy.",
        descriptionGeneric: "Lorsque vous achetez du {{nom}} via un exchange partenaire, vous utilisez un service externe. Ce service est hors de porte du modle scurit contre les menaces de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy.",
        link: "Modle de menace  la scurit",
        title: "Modle de scurit"
      },
      title: "Bienvenue sur la boutique de votre site cl en main pour acheter du {{name}}"
    },
    next: "Suivant",
    selectLabel: "Slectionnez votre compte",
    selectPlaceholder: "Slectionnez un coin (monnaie)",
    skip: "Ne plus montrer",
    title: "Acheter du {{name}}"
  },
  pocket: {
    data: {
      link: "Politique de confidentialit de Pocket",
      p1: "BitBoxApp ne recueille aucune donne lors de l'achat de bitcoins, les fonds entrants sont traits comme une transaction ordinaire. Pocket a besoin de collecter certaines donnes personnelles pour son fonctionnement. La politique de confidentialit de Pocket expose en dtail la manire dont elles sont exploites.",
      title: "Protection des donnes"
    },
    kyc: {
      link: "Lire la FAQ de Pocket",
      p1: "Pocket s'efforce de rduire au minimum le processus didentification (KYC). Pour les achats infrieurs  950 EUR (1000 CHF) par jour, aucun document supplmentaire n'est requis. Pour les achats suprieurs  ce montant, vous devrez fixer un rendez-vous tlphonique avec Pocket au pralable afin de complter le processus Identification/Lutte Contre le Blanchiment (KYC/AML) ncessaire.",
      title: "Identification/Lutte Contre le Blanchiment (KYC/AML)"
    },
    payment: {
      p1: "Vous avez la possibilit dacheter des bitcoins instantanment avec Pocket via un transfert bancaire SEPA. Les frais sont de 1,5% et les bitcoins sont dposs dans votre BitBox ds que possible, une fois le virement bancaire  reu par Pocket (gnralement le jour mme).",
      p2: "Veuillez noter que les taux de change de Pocket peuvent diffrer de ceux utiliss par BitBoxApp,et avoir pour effet des montants lgrement diffrents.",
      title: "Modes de paiement et frais"
    },
    previousTransactions: "L'historique des transactions de ce compte n'est pas vierge. En partageant ce compte, toutes ses transactions passes et futures seront exposes  Pocket. Souhaitez-vous continuer malgr tout ?",
    security: {
      link: "Modle de menace de scurit de BitBox02",
      p1: "Lorsque vous achetez des bitcoins via Pocket, vous utilisez un service externe. Ce service est hors de porte du modle de menace de scurit de BitBox02 et repose sur la scurit de l'environnement dans lequel le logiciel BitBoxApp est dploy. Cependant, nous collaborons dans le but de renforcer la scurit en utilisant un mcanisme d'authentification  deux facteurs pour vrifier l'adresse sur laquelle vous les recevez.",
      title: "Modle de scurit"
    },
    usedAddress: "L'adresse {{adresse}} a dj t utilise, veuillez recommencer avec une nouvelle adresse.",
    verifyBitBox02: "Veuillez vrifier que l'adresse que vous avez reue par email correspond  celle affiche sur votre Bitbox. Si vous en avez la possibilit, vous devriez ouvrir l'email sur un deuxime appareil pour plus de scurit.",
    welcome: {
      p1: "Nous collaborons avec Pocket afin de vous offrir un processus simplifi pour vos achats de bitcoins directement dans l'application BitBox. Quelques clics suffisent.",
      p2: "Pocket est une plateforme suisse qui permet d'acheter rapidement et facilement des bitcoins depuis la plupart des pays europens (partout o les transferts bancaires SEPA sont disponibles).",
      p3: "Avec Pocket, vous pouvez galement effectuer des achats rguliers par le biais d'ordres bancaires rcurrents, vous donnant ainsi la possibilit d'effectuer facilement un lissage de votre prix d'acquisition (DCA).",
      title: "Bienvenue dans votre espace unique et complet ddi  l'achat de bitcoins."
    }
  },
  title: "Acheter du {{name}}"
};
const changePin$e = {
  newTitle: "Nouveau mot de passe de l'appareil",
  oldLabel: "Mot de passe actuel de l'appareil"
};
const chart$a = {
  dataMissing: "Rcupration de lhistorique des donnes soyez patients.",
  dataOldTimestamp: "Mise  jour de lhistorique des taux de change. Le graphique ne tient pas compte des donnes aprs {{time}}.",
  dataUpdating: "mise  jour des donnes...",
  filter: {
    all: "Tout",
    month: "Mois",
    week: "Semaine",
    year: "Anne"
  }
};
const checkSDcard$e = "vrification de la carte microSD";
const clickHere$e = "Cliquez ici.";
const confirm$g = {
  abortInfo: "Appuyez pour",
  abortInfoRedText: "abandonner",
  approveInfo: "Appuyez 4+ secondes pour",
  approveInfoGreenText: "confirmer",
  info: "Continuez sur votre BitBox",
  infoWhenPaired: "D'abord sur le mobile appair, puis sur votre BitBox"
};
const confirmOnDevice$e = "Veuillez confirmer sur l'appareil.";
const connectKeystore$8 = {
  promptNoName: "Veuillez connecter votre BitBox02 pour continuer",
  promptWithName: 'Veuillez connecter votre BitBox02 dnomme "{{name}}" pour continuer'
};
const darkmode$8 = {
  toggle: "Dark mode"
};
const device$e = {
  appUpradeRequired: "Votre BitBox n'est pas compatible avec cette version de l'application de bureau. Veuillez tlcharger et installer la dernire version.",
  keystoreConnected: "Wallet connect"
};
const deviceLock$e = {
  button: "Activer la double authentification (2FA)",
  condition1: "Avez-vous une sauvegarde ?",
  condition2: "Est-ce que la vrification avec l'application mobile fonctionne-t-elle ?",
  condition3: "Le 2FA DSACTIVE les sauvegardes et l'appariement  l'application mobile. L'appareil doit tre RINITIALIS pour enlever le 2FA !",
  confirm: "Activer la double authentification (2FA)",
  title: "Activer la double authentification (2FA)"
};
const deviceSettings$e = {
  backups: {
    manageBackups: {
      description: "Crez ou vrifiez la sauvegarde de votre carte microSD."
    },
    showRecoveryWords: {
      description: "Afficher et vrifier les mots de rcupration."
    },
    title: "Sauvegardes"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp vrifie l'authenticit de votre appareil."
    },
    deviceName: {
      description: "Modifiez le nom de votre appareil."
    },
    rootFingerprint: {
      description: "L'empreinte digitale racine est un identifiant unique du portefeuille en cours d'utilisation. Elle peut vous aider  distinguer les diffrents portefeuilles si vous utilisez des passsphrases."
    },
    securechip: {
      description: "Modle de la puce scurise."
    },
    title: "Informations sur l'appareil"
  },
  expert: {
    factoryReset: {
      description: "Rinitialisez votre appareil aux paramtres d'usine. Cela supprimera le wallet de votre BitBox02 !",
      title: "Rinitialisation aux paramtres d'usine"
    },
    goToStartupSettings: {
      description: "Entrez le bootloader de la BitBox02. Vous pouvez activer le hachage du micrologiciel  partir de l."
    },
    passphrase: {
      description: "Activer ou dsactiver la fonction de passphrase (phrase secrte)",
      title: "Passphrase (phrase secrte)"
    }
  },
  firmware: {
    firmwareVersion: "Version du Firmware",
    newVersion: {
      label: "Version disponible"
    },
    title: "Micrologiciel",
    upToDate: "Votre appareil est  jour",
    upgradeAvailable: "Nouvelle mise  jour disponible",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "chec du contrle d'authenticit",
      label: "Contrle d'authenticit",
      "true": "Votre BitBox02 est authentique"
    },
    sdcard: {
      "false": "Non insre",
      label: "carte microSD",
      "true": "Insre"
    },
    securechip: "Puce scurise",
    title: "Matriel informatique"
  },
  loading: "Rcupration des informations sur l'appareil",
  pairing: {
    lock: {
      "false": "Dsactiv",
      label: "Double authentification (2FA)",
      "true": "Activ"
    },
    mobile: {
      "false": "Ferm",
      label: "Application mobile",
      "true": "Ouvrir"
    },
    status: {
      "false": "Non appair",
      label: "Statut",
      "true": "Appair"
    },
    title: "Appariement"
  },
  secrets: {
    manageBackups: "Grer les sauvegardes",
    title: "Secrets"
  }
};
const deviceTampered$e = "Est-ce que votre BitBox a t fourni avec un mot de passe de rcupration ? Si c'est le cas, arrtez la procdure d'installation et contactez immdiatement le support. Shift ne vous donnera jamais un portefeuille prt  l'emploi ni de recommandation de mot de passe.";
const dialog$f = {
  cancel: "Annuler",
  confirm: "Confirmer",
  confirmTitle: "Confirmation"
};
const error$a = {
  accountAlreadyExists: "Ce compte existe dj.",
  accountLimitReached: "Impossible d'ajouter un compte. Le nombre maximum de comptes pour ce coin (monaie) a t atteint.",
  aoppCallback: "Une erreur s'est produite lors de la transmission de l'adresse  {{host}}.",
  aoppInvalidRequest: "Requte invalide.",
  aoppNoAccounts: "Aucun comptes disponibles.",
  aoppSigningAborted: "Demande de possession de l'adresse annule.",
  aoppUnknown: "Une erreur inconnue s'est produite.",
  aoppUnsupportedAsset: "Cet actif n'est pas pris en charge.",
  aoppUnsupportedFormat: "Aucun des comptes disponibles ne supporte le format d'adresse requis.",
  aoppUnsupportedKeystore: "Lappareil connect ne peut pas signer de messages pour cet asset.",
  aoppVersion: "Version inconnue.",
  wrongKeystore: "Portefeuille connect incorrect. Veuillez vous assurer d'insrer le bon appareil correspondant  ce compte",
  wrongKeystore2: "Si vous utilisez la passphrase facultative, assurez-vous bien que vous avez saisi la passphrase correspondant  ce compte."
};
const fiat$g = {
  "default": "dfaut",
  setDefault: "Dfinir {{code}} comme paramtre par dfaut",
  title: "Devises"
};
const footer$g = {
  appVersion: "Version de l'application :"
};
const generic$a = {
  enabled_false: "Dsactiv",
  enabled_true: "Activ"
};
const genericError$e = "Une erreur est survenue. Si vous rencontrez des problmes, veuillez redmarrez l'application.";
const goal$e = {
  buttons: {
    create: "Crer un nouveau portefeuille",
    restore: "Restaurer un portefeuille  partir d'une sauvegarde"
  },
  paragraph: "Veuillez slectionner l'une des options suivantes :",
  step: {
    "1": {
      title: "Information de scurit"
    },
    "2": {
      description: "Dfinir un mot de passe pour l'appareil",
      title: "Appareil"
    },
    "3-create": {
      description: "Crer un nouveau portefeuille",
      title: "Portefeuille"
    },
    "3-restore": {
      description: " partir d'une sauvegarde",
      title: "Restaurer"
    },
    "4-create": {
      title: "Rsum"
    },
    "4-restore": {
      title: "Rsum"
    }
  }
};
const guide$f = {
  accountDescription: {
    text: `La vue d'ensemble de votre compte affiche votre solde disponible ainsi que les transactions entrantes et sortantes. Notre guide dans "Paramtres" contient plus d'informations sur chaque type de compte. `,
    title: "Que me montre cette page ?"
  },
  accountFiat: {
    text: "Oui. Cliquez sur n'importe quel symbol pour changer la devise. Vous pouvez modifier la liste des devises dans les paramtres.",
    title: "Puis-je afficher d'autres taux de conversion ?"
  },
  accountIncomingBalance: {
    text: "Entrant est la somme des montants qui vous ont t transfrs mais qui n'ont pas encore t confirms par le rseau.",
    title: "Que veut dire entrant ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Chaque xpub est lie au "Type" indiqu : soit "Native Segwit (bech32)", "Wrapped Segwit" ou "Taproot" (Bitcoin uniquement). Ce sont les types de script utiliss par {{coinName}}. BitBoxApp les combine, prenant en charge plusieurs types de script dans le mme compte. Comme chaque type de script donne une xpub diffrente, il y a plusieurs xpubs par compte.

Si vous recevez systmatiquement sur l'adresse par dfaut (Native Segwit), vous n'avez besoin que de la xpub "bech32". Cependant, si vous recevez galement des fonds sur "Wrapped Segwit" ou "Taproot", vous devez galement utiliser respectivement les cls publiques tendues "Wrapped Segwit" et "Taproot".`,
      title: "Pourquoi y a-t-il plusieurs xpubs ?"
    },
    privacy: {
      text: "Pour ce compte spcifique, la cl publique tendue rvle l'ensemble de l'historique des oprations, le solde de votre compte et toutes les transactions futures. Mais la xpub ne permet  personne de dpenser vos coins (monnaie).\n\nSi vous communiquez une xpub  quelqu'un, vous devez tre conscient que cette personne ou entreprise peut visualiser toutes les autres transactions de ce mme compte. Par consquent, c'est une bonne ide d'utiliser ce compte uniquement  cette fin et de garder les autres fonds sur des comptes distincts.",
      title: "Est-ce que je dois garder ma xpub secrte ?"
    },
    verify: {
      text: "Oui, c'est toujours une bonne initiative de revrifier votre xpub. Si un tiers va gnrer des adresses de rception  partir de cette xpub pour vous envoyer de l'argent, c'est tout particulirement important. Vous devez la vrifier sur l'appareil afin de vous assurer que cette xpub vous appartient; sinon, l'ensemble des fonds pourraient tre envoys  des adresses non voulues.",
      title: "Est-ce que je dois vrifier la xpub sur l'appareil ?"
    },
    xpub: {
      text: `Une cl publique tendue (xpub) est une cl racine  partir de laquelle toutes les adresses de rception d'un compte sont drives.

Elle sont fournies ici  des fins d'utilisation avance et d'interoprabilit avec les portefeuilles de type "watch-only", comme Electrum ou Sentinel. Si vous recevez des fonds sur diffrents types d'adresses, veuillez importer tous les diffrents formats xpub dans le portefeuille "watch-only" afin de pouvoir visualiser tous vos fonds.

Veuillez noter que certains portefeuilles tiers ne supportent pas encore les xpubs Taproot.`,
      title: "Qu'est-ce qu'une cl publique tendue ?"
    }
  },
  accountRates: {
    text: "Les taux de change sont mis  jour toutes les minutes  partir de CoinGecko.",
    title: "Quels taux de change sont utiliss ?"
  },
  accountReload: {
    text: "Il n'y a pas besoin. Vos informations de transaction sont mises  jour automatiquement.",
    title: "Puis-je recharger l'historique des transactions ?"
  },
  accountSendDisabled: {
    text: 'Le bouton "Envoyer" est activ lorsque votre solde est suprieur  zro.',
    title: "Pourquoi ne puis-je pas envoyer de {{unit}} ?"
  },
  accountSummaryAmount: {
    text: "Le montant total est la somme de tous vos comptes crypto. Les taux de change sont obtenus auprs de coingecko.com.\n\nRemarque : si vous utilisez MyEtherWallet pour des tokens (jetons) non pris en charge par BitBoxApp, ils ne seront pas inclus dans le montant affich.",
    title: "Comment le montant total est-il calcul ?"
  },
  accountSummaryDescription: {
    text: "Vous pouvez voir ici la performance de votre portefeuille au fil du temps. Un rsum de vos comptes cryptos individuels est affich sous le graphique.",
    title: "Que me montre cette page ?"
  },
  accountTransactionAttributesBTC: {
    text: "Taille virtuelle : dtermine les frais de rseau. Vous avez russi  conomiser sur les frais si elle est infrieure  la taille de la transaction.\nTaille : Taille relle de la transaction en octets dpendamment de la blockchain concerne.\nPoids : Une nouvelle mesure, introduite avec Segwit, permettant d'valuer la transaction et la taille du bloc. Chaque octet tmoin est spar et compte pour un, le reste en tant que quatre units de poids. Au lieu d'un mgaoctet de taille relle, la limite de taille de bloc est maintenant de quatre millions d'units de poids.",
    title: "Qu'en est-il des dtails spcifiques de la transaction Bitcoin ?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmations : Lors de l'mission de votre transaction, elle ne sera pas confirme. Vous devrez attendre qu'un mineur l'inclue dans un bloc, elle aura alors une confirmation. Chaque bloc mis sur le rseau par la suite ajoutera une nouvelle confirmation  votre transaction. En gnral, les commerants et autres acteurs de l'cosystme considrent comme valides les transactions ayant entre 3 et 6 confirmations.\nTransaction ID : Numro d'identification unique pouvant tre utilis pour rechercher une transaction dans un explorateur de blocs.\nFrais : Les mineurs reoivent des frais de transaction afin de les inciter  intgrer les transactions dans les blocs qu'ils minent. Pour en savoir plus, cliquez sur le bouton d'envoi.",
    title: "Quelles sont les informations affiches dans le dtail de la transaction?"
  },
  accountTransactionConfirmation: {
    text: "Il sagit dune transaction qui a t mise sur le rseau et en attente dtre confirme.",
    title: "Qu'est-ce qu'une transaction en attente ?"
  },
  accountTransactionLabel: {
    text: "C'est l'adresse vous ayant envoy les coins ou  laquelle vous les avez envoys.",
    title: "Quelle adresse est affiche pour chaque transaction?"
  },
  accountTransactionTime: {
    text: "L'heure et la date  laquelle la transaction a t confirme sur la blockchain.",
    title: "Quel horodatage est affich ?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin et Litecoin ne peuvent avoir quun nombre arbitraire de comptes. Au del de cinq comptes, vous ne pouvez en ajouter un supplmentaire que si le compte prcdent a dj t utilis. \nUn maximum de cinq comptes est possible pour les autres coins (jetons).",
      title: "Combien de comptes puis-je crer ?"
    },
    howtoAddTokens: {
      text: `Les jetons utilisant la norme ERC20 sont rattachs  un compte Ethereum spcifique. Pour activer ou dsactiver un jeton en particulier, ouvrez l'cran "Grer les comptes", largissez votre compte Ethereum et activez ou dsactivez le jeton souhait.`,
      title: "Comment ajouter des jetons supplmentaires ?"
    },
    moveFunds: {
      text: "Oui. Mais comme les comptes sont indpendants, vous devez envoyer vos fonds en utilisant une transaction classique.",
      title: "Est-ce que je peux dplacer des fonds entre les diffrents comptes ?"
    },
    recoverAccounts: {
      text: "Oui. BitBoxApp cre des comptes en utilisant des normes bien tablies et compatibles avec la plupart des autres portefeuilles de crypto-monnaies.",
      title: "Est-ce que je peux rcuprer mes comptes avec d'autres portefeuilles ?"
    },
    whatAreAccounts: {
      text: "Votre portefeuille peut grer plusieurs comptes pour un mme coin (monnaie). Les diffrents comptes sont utiles lorsque vous souhaitez conserver des fonds sparment.",
      title: "Qu'est-ce qu'un compte ?"
    },
    whyIsThisUseful: {
      text: `Les comptes sont parfaits pour grer des fonds destins  des personnes ou des objectifs diffrents, car ils sont distincts. Vous pouvez galement partager la "cl publique tendue" (xpub) d'un compte sans rien dvoiler de vos autres comptes. Cela vous permet de recevoir des fonds de manire rpte sans rutiliser les adresses, par exemple pour recevoir votre salaire ou acheter rgulirement des crypto-monnaies.`,
      title: "Pourquoi est-ce utile ?"
    }
  },
  appendix: {
    link: "Contactez-nous !",
    text: "Vous avez une autre question ?"
  },
  backups: {
    check: {
      text: `"Vrifier la sauvegarde" vous permet de vrifier que vous disposez d'une sauvegarde fonctionnelle correspondant  votre portefeuille actuel. Elle peut galement tre utilise pour vrifier que vous disposez toujours du mot de passe de rcupration correct. Vous pouvez vrifier votre mot de passe de rcupration principal ou votre mot de passe de rcupration cach.`,
      title: 'Que signifie "Vrifier la sauvegarde" ?'
    },
    encrypt: {
      text: "Non, mais votre mot de passe de rcupration est ncessaire pour driver le portefeuille  partir de la graine stocke.",
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    howOften: {
      text: "La sauvegarde est automatiquement gnre lorsqu'un nouveau portefeuille est cr. Vous devez effectuer une nouvelle sauvegarde que si votre carte microSD est perdue ou endommage ou si vous souhaitez utiliser plusieurs cartes microSD pour vos sauvegardes.\nVous n'avez pas besoin de crer une nouvelle sauvegarde aprs avoir effectu des transactions. Toutes les donnes associes  vos transactions peuvent tre recres par votre sauvegarde unique qui a t gnre automatiquement.",
      title: " quelle frquence dois-je faire une sauvegarde ?"
    },
    whatIsABackup: {
      text: "C'est une copie de la graine sur une carte microSD. La graine combine  votre mot de passe de rcupration gnre votre portefeuille.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Vrifier la sauvegarde" vous permet de vrifier que la sauvegarde correspond bien  votre portefeuille.',
      title: 'Que signifie "Vrifier la sauvegarde" ?'
    },
    encrypt: {
      text: `Non. Veillez  conserver la carte microSD en scurit compte tenu du fait qu'elle contient votre liste de mots permettant la restauration de votre portefeuille. Si vous souhaitez protger votre graine par mot de passe, vous pouvez activer une phrase secrte dans les paramtres avancs du menu "Grer l'appareil".`,
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    whatIsABackup: {
      text: "Il s'agit d'une copie de votre liste de mots BIP39 sur une carte microSD.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Lorsque le 2FA est activ, toutes les transactions doivent tre approuves sur votre tlphone portable appair afin de pouvoir envoyer des jetons. En ralit, un numro chiffr,  usage unique, est envoy  l'application mobile, dchiffr  et renvoy au BitBox lorsque vous appuyez sur le bouton "Accepter". Cette communication avec l'appareil se fait via le canal entre le tlphone mobile et l'application de bureau tablie lors de l'appareillage.

Assurez-vous de sauvegarder votre portefeuille et d'appairer l'application mobile avant d'activer le 2FA. Une fois activ, l'appairage entre l'emplacement de la carte micro SD et l'application mobile est dsactiv. Il peut tre ractiv en rinitialisant le BitBox.`,
      title: "Comment fonctionne la double authentification (2FA) ?"
    },
    disable2FA: {
      text: `Pour dsactiver le 2FA, vous devez rinitialiser votre BitBox, puis restaurer le portefeuille  partir de sa sauvegarde. Assurez-vous que vous tes toujours en possession de la carte micro SD avec la sauvegarde et que vous vous souvenez du mot de passe de rcupration. Puis appuyez sur "Rinitialiser l'appareil". Dfinissez un nouveau mot de passe et choisissez "Ou restaurer une sauvegarde". Slectionnez la sauvegarde que vous avez effectue  partir du portefeuille, cliquez sur "Restaurer" et entrez le mot de passe de rcupration que vous avez utilis lors de la cration du portefeuille.`,
      title: "Comment puis-je dsactiver la double authentification (2FA) ?"
    },
    ejectBitbox: {
      text: "Vous pouvez dbrancher le BitBox  tout moment sans avoir  l'jecter.",
      title: "Comment puis-je jecter le BitBox ?"
    },
    ejectSD: {
      text: "Vous pouvez retirer la carte microSD du BitBox  tout moment, tant que vous n'tes pas en train de crer ou de restaurer une sauvegarde.",
      title: "Comment puis-je jecter la carte microSD ?"
    },
    hiddenWallet: {
      text: "Il sagit dun deuxime portefeuille sur le mme appareil, protg par un mot de passe d'appareil et de rcupration diffrents, qui peut tre utile pour un plausible dni. La mme graine de sauvegarde est utilise pour votre portefeuille normal et votre portefeuille cach. Aucune sauvegarde supplmentaire n'est donc ncessaire.",
      title: "Qu'est-ce qu'un portefeuille cach ?"
    },
    legacyHiddenWallet: {
      text: "Cliquez d'abord sur le bouton ci-dessous (disponible si le BitBox est dverrouill avec le mot de passe principal de l'appareil et si la double authentification est dsactive), puis rebranchez votre BitBox et dverrouillez-le avec le mot de passe du portefeuille cach.",
      title: "Comment accder au portefeuille Legacy cach ?"
    },
    pairing: {
      text: "Aprs avoir tlcharg notre application mobile pour iOS ou Android, vous devez scanner le QR code affich, ce qui tablit un canal scuris entre l'application mobile et l'application de bureau. Une fois scann, suivez les instructions sur l'application mobile.",
      title: "Comment appairer votre tlphone en toute scurit ?"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Veuillez consulter le site web de Bitsurance et sa FAQ pour plus de dtails.",
      title: "Questions supplmentaires ?"
    },
    privacy: {
      link: {
        text: "Politique de confidentialit de Bitsurance"
      },
      title: "Quelles informations personnelles sont ncessaires pour l'assurance ?"
    },
    renew: {
      title: "Comment puis-je renouveler ou rsilier l'assurance ?"
    },
    status: {
      text: `Les comptes assurs avec succs sont signals par un badge vert "assur" dans le coin suprieur droit de chaque page de vos compte Bitcoin. Dans la section "Assurance", vous pouvez avoir l'aperu de tous les comptes Bitcoin assurs et leur statut d'assurance en temps rel.`,
      title: "Puis-je consulter l'tat d'un compte assur ?"
    },
    what: {
      title: "Est-ce que l'ensemble du portefeuille BitBox est assur ?"
    },
    who: {
      text: "L'assurance est propose par Bitsurance, un courtier en assurance fond par des bitcoiners. Ils travaillent conjointement avec ELEMENT insurance afin de fournir une assurance Bitcoin. Ces deux socits sont bases en Allemagne.",
      title: "Qui assure mes bitcoins ?"
    },
    why: {
      text: "Bitsurance couvre certains risques lis  la self-custody (dtention par soi-mme) qui ne sont pas couverts mme par les wallets les plus srs, comme par exemple le cambriolage, l'extorsion ou la destruction du-dit wallet. Il vous appartient de dcider par vous mme si vous avez la ncessit d'une police d'assurance pour ces risques.",
      title: "Ai-je besoin d'une assurance Bitcoin ?"
    }
  },
  cointracking: {
    text: `Cliquez sur le bouton "Exporter" et ouvrez le dossier de tlchargement o vous trouverez l'exportation CSV. Cliquez ensuite sur le lien ci-dessous, tlchargez votre fichier CSV BitBox et importez les donnes afin de les utiliser avec votre gestionnaire de portefeuille CoinTracking et pour crer vos dclaration fiscales.`,
    title: "Comment importer mes transactions dans CoinTracking ?"
  },
  device: {
    attestation: {
      link: {
        text: "En savoir plus sur le contrle d'authenticit"
      },
      text: "BitBoxApp effectue un contrle d'attestation sur la BitBox02 afin de confirmer que le dispositif est bien authentique. La vrification est effectue localement et ne ncessite aucune connexion  un serveur.",
      title: "Comment fonctionne le contrle d'authenticit?"
    },
    name: {
      text: "Ceci est le nom de votre portefeuille et de votre sauvegarde. Ce nom est utilis pour les sauvegardes futures et permet de faire la distinction entre diffrents portefeuilles. Il peut tre modifi  tout moment mais veuillez noter que les sauvegardes effectues avant ce changement continueront d' utiliser le nom prcdent.",
      title: "A quoi sert le nom BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "En savoir plus sur la puce scurise"
      },
      text: "Cette information indique le modle de la puce scurise. La puce la plus rcente est l'ATECC608B, qui bnficie de caractristiques de scurit renforces comparativement aux prcdents modles.",
      title: "Pourquoi indiquer le modle de puce scurise?"
    }
  },
  receive: {
    address: {
      text: "Vous pouvez donner l'adresse  d'autres personnes pour qu'elles vous envoient des coins. Assurez-vous simplement qu'elles envoient  la bonne adresse.",
      title: "Que puis-je faire d'une adresse ?"
    },
    addressChange: {
      text: "Ds que vous effectuez une transaction, une nouvelle adresse est automatiquement ajoute  la liste de sorte qu'il y ait toujours 20 adresses vierges disponibles.",
      title: "Quand les adresses changent-elles ?"
    },
    addressFormats: {
      text: "Par dfaut, le type d'adresse est Native Segwit. Ce type d'adresse est largement adopt par d'autres portefeuilles/exchanges et vous offre les meilleurs niveau de frais pour les transactions quotidiennes. Cependant, vous pouvez galement choisir d'envoyer vers Taproot (Bitcoin uniquement), qui est le type d'adresse le plus rcent, mais qui n'est peut-tre pas encore largement support. Par ailleurs, si vous rencontrez des difficults pour vos envois vers Native Segwit (le type par dfaut), vous pouvez essayer de passer  l'ancien type d'adresse Wrapped Segwit, qui peut se rvler compatible avec davantage de portefeuilles/exchanges.",
      title: `Quand dois-je utiliser la fonction "Modifier le type d'adresse" ?`
    },
    howVerify: {
      text: "Pour le BitBox01, cliquez sur l'icne BitBox dans la barre latrale de gauche et consultez la section appairage. Le guide sera mis  jour et vous pourrez continuer  suivre les instructions  partir de l.\nPour le BitBox02, vous pouvez vrifier les adresses directement sur l'appareil pendant le processus d'envoi/rception.",
      title: "Comment puis-je vrifier une adresse en toute scurit ?"
    },
    plugout: {
      text: "Non, une fois que vous avez envoy des fonds sur votre adresse BitBox, vous n'avez pas besoin de laisser votre BitBox branche. Vous tes libre de pouvoir dconnecter votre BitBox.",
      title: "Est-ce que je dois laisser mon BitBox branch quand je reois des fond ?"
    },
    why20: {
      text: `Au dmarrage, l'application gnre des adresses drives de votre graine pour vrifier si elles ont reu des fonds. Comme l'application peut gnrer un nombre presque infini d'adresses, elle pourrait prendre des annes  effectuer cette vrification de solde. Pour limiter cette recherche, elle s'arrte aprs avoir gnr 20 adresses vierges. Il s'agit de la "limite d'cart" et 20 est une norme commune bien que arbitraire. Voici les 20 adresses parmi lesquelles vous pouvez choisir.`,
      title: "Pourquoi seulement 20 adresses ?"
    },
    whyMany: {
      text: "Pour prserver la confidentialit et la scurit, ne donnez jamais deux fois la mme adresse. Si vous avez utilis une adresse, cliquez sur la flche  droite pour obtenir une nouvelle adresse. Vous pouvez gnrer jusqu' 20 adresses  la fois. Voyez les adresses comme des numros de facture. Toutes les adresses sont drives de votre graine, elle mme unique.",
      title: "Pourquoi y a-t-il autant d'adresses ?"
    },
    whyVerify: {
      text: "Vous ne devriez pas faire confiance  votre ordinateur pour gnrer et afficher des adresses authentiques. Sa grande surface d'attaque le rend beaucoup plus vulnrable qu'un portefeuille physique. Pour le BitBox01, le bouton permettant de vrifier l'adresse envoie l'adresse de manire scurise  un tlphone mobile jumel,  partir duquel vous pouvez galement scanner et vrifier le code QR. Pour le BitBox02, l'adresse peut tre vrifie directement sur l'cran du BitBox02.",
      title: "Pourquoi devrais-je vrifier l'adresse en toute scurit ?"
    }
  },
  send: {
    change: {
      text: "Le change sera restitue sur une adresse Taproot si vous disposez d'au moins un UTXO Taproot. Si vous utilisez le coin control, le change sera transfr vers une adresse Taproot s'il y a au moins un UTXO Taproot parmi les UTXOs slectionns. Dans tous les autres cas, le change est envoy vers une adresse Native Segwit.",
      title: "Comment le change output (de sortie) est-il dtermin ?"
    },
    fee: {
      text: "Les frais sont bass sur la taille des donnes de la transaction et non sur son montant. L'estimation des frais  payer sont calculs par l'algorithme du logiciel Bitcoin Core en fonction de la priorit de traitement par le rseau choisie. Ils sont affichs s'ils ont une valeur diffrente des cibles ci-dessous.\n\nconomique : 24 blocs (environ 4 heures pour Bitcoin, 1 heure pour Litecoin)\nBas : 12 blocs (environ 2 heures pour Bitcoin, 30 minutes pour Litecoin)\nNormal : 6 blocs (environ 1 heure pour Bitcoin, 15 minutes pour Litecoin)\nlev : 2 blocs (environ 20 minutes pour Bitcoin, 5 minutes pour Litecoin)\n(Un bloc prend en moyenne dix minutes pour Bitcoin (2,5 minutes pour Litecoin)  miner et la charge du rseau peut varier considrablement au cours des priodes ci-dessus.)",
      title: "Comment les frais sont-ils dtermins ?"
    },
    plugout: {
      text: "Non, une fois que vous avez effectu une transaction, il n'est pas ncessaire de laisser votre BitBox branch. Vous pouvez dconnecter votre BitBox.",
      title: "Dois-je laisser ma BitBox branche pendant l'envoi ?"
    },
    priority: {
      text: "Votre transaction sera gnralement confirme plus rapidement par le rseau si les frais que vous tes prt  payer sont levs.",
      title: "Quelle est la priorit du rseau ?"
    },
    revert: {
      text: "Une fois qu'une transaction est signe et envoye (c'est--dire diffuse sur le rseau), elle ne peut plus tre annule. Vrifiez les transactions (y compris les frais) correctement avant de signer !\nSi vous connaissez le destinataire et qu'il est prt  vous renvoyer le mme montant (moins les frais de transaction), vous pouvez lui communiquer une adresse de rception  vous.",
      title: "Puis-je annuler une transaction ?"
    },
    whyFee: {
      text: "Les transactions sont en comptitions les unes avec les autres pour tre confirmes par un mineur. Les mineurs choisissent quelles transactions sont  inclure dans la blockchain en fonction des frais de rseau.\nLes mineurs votent sur l'historique des transactions. Puisqu'il n'y a pas de tiers de confiance qui impose un vote par personne (ce qui est l'intrt des blockchains), les mineurs votent sur les transactions en sacrifiant une ressource coteuse telle que la puissance de calcul. En rcompense de leur travail, ils peuvent prtendre aux jetons fraichement crs ainsi qu'aux frais de toutes les transactions qu'ils ont incluses dans leur bloc.",
      title: "Pourquoi y a-t-il des frais de rseau ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Si vous avez l'intention de connecter  votre nud exclusivement  un seul rseau (par exemple, le rseau wifi de votre domicile), l'utilisation d'une communication rseau normale est suffisante.\nDans ce cas, il est conseill que votre serveur Electrum fournisse un certificat TLS pour crypter la communication.\nSi vous avez l'intention de connecter votre nud depuis n'importe o, l'utilisation de Tor est la meilleure option. Aucun certificat TLS n'est ncessaire dans ce cas.",
      title: "Dois-je utiliser clearnet TCP, TLS ou Tor ?"
    },
    instructions: {
      link: {
        text: "Guide pour connecter votre nud"
      },
      text: "Pour un tutoriel complet, veuillez consulter notre guide :",
      title: "Comment je fais pour connecter ma BitBoxApp  mon nud personnel?"
    },
    options: {
      text: "Il existe diffrentes solutions pour faire tourner votre propre nud, comme par exemple acheter un appareil prt  l'emploi, ou bien fabriquer le vtre, ou bien encore utiliser Bitcoin Core.\nSi vous souhaitez connecter votre BitBoxApp  votre nud, assurez-vous qu'il tourne sur un serveur Electrum. Il s'agit d'un programme ddi qui permet  une application de portefeuille de communiquer avec votre nud.\nLes options supportes sont Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).",
      title: "Quelles sont les options disponibles pour faire tourner un nud?"
    },
    tor: {
      text: `Tor est l'acronyme de "The Onion Router", un logiciel libre et gratuit qui offre de nombreux avantages en matire de confidentialit et qui est particulirement intressant lorsque vous utilisez Bitcoin.
Si vous avez l'intention de vous connecter  votre nud via Tor, assurez-vous que Tor est install sur votre ordinateur, puis activez le proxy Tor dans les paramtres de BitBoxApp.
Sur la plupart des systmes d'exploitation, il existe deux faons d'excuter Tor :
1. Navigateur Tor : tlchargez et ouvrez le navigateur Tor. Cela permettra  BitBoxApp de se connecter au rseau Tor en activant le port 9150 dans les paramtres du proxy Tor.
2. Background service Tor : installez le daemon Tor, qui fonctionne toujours en fond. BitBoxApp peut alors se connecter en configurant le port 9050 dans les paramtres du proxy Tor.`,
      title: "Qu'est-ce que Tor, le proxy Tor et quel port dois-je utiliser ?"
    },
    what: {
      text: "Il est possible de synchroniser votre portefeuille depuis vos propres nuds complets au lieu d'utiliser les serveurs de Shift.",
      title: "Qu'est-ce que cela ?"
    },
    why: {
      text: "Faire tourner votre propre nud n'est pas ncessaire mais amliore la confidentialit et rduit le besoin de faire confiance aux autres.\nPremirement, cela signifie que vous utilisez Bitcoin de manire plus prive car le BitBoxApp ne se connectera pas  nos serveurs pour rcuprer l'historique de vos transactions, mais rcuprera ces informations  partir de votre propre nud.\nDeuximement, faire tourner votre propre nud signifie que celui-ci vrifie lui-mme toutes les transactions, en s'assurant que les rgles de consensus sont bien respectes.",
      title: "Pourquoi est-ce que je devrais faire tourner mon propre nud ?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" en abrg) est la plus petite unit de Bitcoin. Un Satoshi correspond  un cent millionime de bitcoin (0,00000001 BTC). Il tire son nom du crateur de Bitcoin, Satoshi Nakamoto.',
      title: "Qu'est-ce qu'un Satoshi?"
    },
    servers: {
      text: "Cette application communique avec les serveurs de Shift Crypto pour rechercher des mises  jour, charger des transactions et envoyer des informations aux applications mobiles appaires.\nDe plus, elle rcupre les derniers taux de change de CoinGecko.\nLes conversions sont calcules localement, aucun de vos montants n'est transmis.\nNote : Pour Ethereum et les jetons ERC20, nous utilisons Etherscan.io APIs.",
      title: "Avec quels serveurs cette application communique-t-elle ?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Fermer le guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Sur ordinateur, dplacez le curseur sur le graphique. Sur mobile, maintenez le doigt sur le graphique et faites-le glisser horizontalement.",
    title: "Comment voir les valeurs historiques sur le graphique?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Vous devez rinitialiser l'appareil et restaurer le portefeuille  partir d'une sauvegarde et du mot de passe de rcupration.",
      title: "Que dois-je faire si j'ai oubli le mot de passe de l'appareil ?"
    },
    reset: {
      text: "Entrez un mauvais mot de passe 15 fois. Les dernires tentatives ncessitent une longue pression du bouton tactile sur l'appareil.",
      title: "Comment rinitialiser l'appareil ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Le dispositif doit clignoter une fois qu'il est insr. Assurez-vous qu'il soit insr dans le bon sens. Si vous rencontrez des difficults, veuillez nous contacter via le lien ci-dessous.\n\nLa BitBox01 n'est pas utilisable sur mobile. Veuillez utiliser la BitBoxApp sur votre ordinateur pour connecter votre BitBox01.",
      title: "Mon BitBox01 n'est pas reconnu"
    },
    getDevice: {
      link: {
        text: "Commander un BitBox"
      },
      text: "Vous pouvez acheter un BitBox dans notre boutique en ligne :",
      title: "Comment puis-je obtenir un appareil BitBox ?"
    },
    internet: {
      text: "Oui, une connexion  Internet est ncessaire pour synchroniser le portefeuille, envoyer des transactions et rcuprer les derniers taux de change.",
      title: "Cette application ncessite-t-elle une connexion  Internet ?"
    },
    lostDevice: {
      link: {
        text: "Centre de sauvegarde"
      },
      text: "Vous pouvez accder  vos comptes via un nouveau BitBox ou depuis notre centre de sauvegarde.",
      title: "J'ai perdu mon appareil. Que faire ?"
    },
    useWithoutDevice: {
      text: "Ce n'est malheureusement pas possible pour le moment.",
      title: "Puis-je utiliser l'application sans appareil Bitbox ?"
    },
    welcome: {
      text: "Merci d'utiliser cette application dveloppe par Shift Crypto en Suisse. Nous apprcions tous les commentaires dont vous pourriez nous faire part. Vous pouvez nous les soumettre en cliquant sur le lien en bas de page.",
      title: "Bienvenue dans l'application BitBox !"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si vous utilisez un nouveau tlphone/ordinateur avec la BitBoxApp, vous devrez vous connecter  nouveau aux DApps. Vous verrez alors vos coins sur la DApps comme prcdemment.",
      title: "Je ne vois pas mes prcdentes connexions."
    },
    supportedNetworks: {
      text: "Actuellement, seul le mainnet dEthereum est support lorsque vous utilisez WalletConnect dans la BitBoxApp. Pour utiliser d'autres chanes compatibles EVM, veuillez utiliser l'extension de navigateur Rabby wallet.",
      title: "Quels sont les rseaux supports ?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect est un protocole de communication pour les applications web3. Il vous permet de vous connecter facilement aux DApps et aux portefeuilles web reposant sur Ethereum sans utiliser d'application tierce; ceci constitue une solution particulirement pratique pour les utilisateurs Android de la BitBoxApp.",
      title: "Qu'est-ce que WalletConnect ?"
    }
  }
};
const headerssync$e = {
  blocksSynced: "{{blocks}} blocs synchroniss"
};
const hiddenWallet$e = {
  info1HTML: "Pour un besoin de dni plausible, un portefeuille cach peut tre cr  partir d'une combinaison de <strong> diffrents </strong> mot de passe de rcupration et d'appareil.",
  info2HTML: "Dfinissez le mot de passe de l'appareil et de rcupration que vous souhaitez associer  votre portefeuille cach ci-dessous. Le mot de passe de l'appareil et le mot de passe de rcupration doivent tre <strong> diffrents </strong> de ceux que vous avez dfinis pour votre portefeuille principal.",
  passwordLabel: "Mot de passe de rcupration cach",
  passwordPlaceholder: "Veuillez confirmer le mot de passe de rcupration cach",
  pinLabel: "Mot de passe de l'appareil cach",
  pinRepeatLabel: "Rpter le mot de passe de l'appareil cach",
  pinRepeatPlaceholder: "Veuillez confirmer le mot de passe de l'appareil cach",
  success: "Un portefeuille cach a t cr avec succs. Rebranchez votre BitBox pour le dverrouiller."
};
const initialize$e = {
  create: "Dfinir le mot de passe de l'appareil",
  creating: "Dfinition du mot de passe de l'appareil en cours",
  error: {
    e102: "Le mot de passe de l'appareil doit comporter au moins 4 caractres."
  },
  info: {
    description1: "Choisissez le mot de passe de votre appareil. Celui-ci sera utilis pour dverrouiller votre BitBox.",
    description2: "Vous pouvez utiliser des chiffres, des lettres et des symboles. Les mots de passe longs offrent une meilleure scurit.",
    description3: "Si vous perdez le mot de passe de votre appareil, vous devrez le rinitialiser et restaurer la sauvegarde de votre portefeuille.",
    subtitle: "Vous allez maintenant dfinir le mot de passe de votre appareil",
    title: "Initialisation de votre appareil"
  },
  input: {
    label: "Mot de passe de l'appareil",
    labelRepeat: "Rpter le mot de passe de l'appareil",
    placeholderRepeat: "Veuillez confirmer le mot de passe de l'appareil"
  }
};
const invalidFormat$e = "Format invalide";
const language$f = {
  title: "Choisir la langue"
};
const legacyhiddenwallet$e = {
  disable: "Dsactiver le portefeuille Legacy cach",
  enable: "Activer le portefeuille Legacy cach",
  successDisable: "Portefeuille Legacy cach dsactiv avec succs.",
  successEnable: "Portefeuille Legacy cach activ avec succs. Reconnectez votre BitBox et entrez le mot de passe de l'appareil cach pour accder au portefeuille Legacy cach."
};
const loading$e = "chargement en cours";
const manageAccounts$8 = {
  accountHidden: "Ce compte a t retir de vos comptes watch-only. Pour le voir  nouveau, veuillez brancher votre BitBox02.",
  editAccount: "Modifier",
  editAccountNameTitle: "Modifier le nom du compte",
  noAccounts: "aucun compte trouv",
  settings: {
    hideTokens: "Cacher les jetons",
    showTokens: "Afficher les jetons ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Ajouter et afficher/masquer les comptes",
  title: "Gestion des comptes",
  watchAccount: "Compte de suivi",
  watchAccountDescription: "Ce compte fait partie de vos comptes watch-only. Vous pouvez le faire disparatre de vos comptes watch-only  l'aide du bouton."
};
const mobile$9 = {
  usingMobileDataWarning: "Utilisation des donnes mobiles : cette application peut tlcharger jusqu' quelques centaines de mgaoctets de donnes d'en-tte de blockchain aprs avoir dverrouill un compte. Veuillez vous connecter au Wi-Fi afin d'viter d'utiliser les donnes mobiles. Aprs l'avoir quitt, ce message ne s'affichera plus."
};
const newSettings$7 = {
  about: {
    appVersion: {
      title: "Version de l'application"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Verrouiller l'accs  l'application via le verrouillage de l'cran/empreinte digitale.",
      title: "Verrouillage de l'cran"
    },
    coinControl: {
      description: "Slectionnez quelles UTXO font partie d'une transaction afin d'amliorer la confidentialit"
    },
    customFees: {
      description: "Vous permet de saisir vos propres frais lors de l'envoi."
    },
    torProxy: {
      description: "Se connecter via Tor pour une meilleure confidentialit."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Ces devises supplmentaires peuvent tre slectionnes sur la page de votre compte.",
      title: "Devises actives"
    },
    darkmode: {
      description: "Voir la BitBoxApp en dark mode (mode sombre)."
    },
    defaultCurrency: {
      description: "Slectionnez votre devise par dfaut",
      title: "Devise par dfaut"
    },
    enableAccount: {
      description: "La dsactivation de votre compte signifie qu'il n'apparatra plus dans la barre latrale ou dans le portfolio. Vous avez toujours la possibilit de le ractiver  partir d'ici. Les coins de ce compte ne seront pas affectes et resteront en scurit.",
      title: "Activer/dsactiver le compte"
    },
    hideAmounts: {
      description: "Affiche un bouton permettant de masquer votre solde et vos montants afin d'amliorer votre confidentialit lorsque vous utilisez l'application en public.",
      hideAmounts: "Cacher les montants",
      showAmounts: "Afficher les montants",
      title: "Autoriser la dissimulation des montants"
    },
    language: {
      description: "Quelle langue souhaitez vous que BitBoxApp utilise?",
      title: "Langue"
    },
    remebmerWallet: {
      name: "Se souvenir du wallet"
    },
    toggleSats: {
      description: "Activer ou dsactiver l'unit des Satoshis"
    }
  }
};
const note$a = {
  input: {
    description: "(facultatif)",
    placeholder: "Ajouter une note..."
  },
  title: "Note"
};
const notification$e = {
  newTxs_one: "Nouvelle transaction dans : {{accountName}}",
  newTxs_other: "{{count}} nouvelles transactions dans : {{accountName}}"
};
const pairing$e = {
  aborted: {
    text: "L'appairage a t annul depuis l'application mobile.",
    title: "Abandonn"
  },
  button: "Appairer l'application mobile",
  confirm: "tes-vous sr de vouloir appairer votre BitBox ? Notez qu'ensuite le tlphone mobile est ncessaire pour effectuer une transaction.",
  connectOnly: {
    button: "Connecter l'application mobile",
    title: 'Scannez depuis notre application mobile en cliquant sur "Connecter  une nouvelle application de bureau"'
  },
  error: {
    text: "Quelque chose s'est mal pass. Veuillez recommencer.",
    title: "Erreur"
  },
  pullFailed: {
    text: "Impossible de faire passer un message de votre mobile par le serveur relais. Le serveur relais est peut-tre hors ligne, veuillez contacter l'assistance.",
    title: "chec de transfert"
  },
  reconnectOnly: {
    button: "Reconnecter l'application mobile"
  },
  scanningFailed: {
    text: "Le mobile n'a pas pu scanner le message correctement. Veuillez ressayer.",
    title: "chec de la numrisation"
  },
  start: {
    hideAppQRCode: "Masquer le QR Code",
    revealAppQRCode: "Afficher le QR Code",
    step1: "Si vous ne possdez pas encore l'application mobile, vous pouvez scanner le QR code correspondant  l'App Store ou au Play Store en fonction de votre tlphone.",
    step2: `Scannez depuis notre application mobile, que vous pouvez trouver sous le nom "Digital Bitbox 2FA" dans les magasins d'applications pour iOS et Android :`
  },
  started: {
    text: "Veuillez maintenant suivre les instructions sur l'application mobile.",
    title: "Gnial"
  },
  success: {
    text: "Flicitations, vous avez appair votre BitBox  lapplication mobile !",
    title: "Succs"
  },
  timeout: {
    text: "Le temps d'appairage expire aprs deux minutes. Recommencez si vous souhaitez toujours appairer l'application mobile.",
    title: "Expiration de session"
  },
  title: "Appairage mobile"
};
const passphrase$8 = {
  considerations: {
    button: "Considrations relatives  la sauvegarde",
    message: "La passphrase ajoute une couche de protection supplmentaire   la sauvegarde de votre portefeuille (carte microSD ou mots de rcupration). Si quelqu'un a accs  votre sauvegarde, il aura galement besoin de la passphrase pour accder  votre portefeuille.\n\nCependant, cela signifie que vous aurez besoin <strong> la fois de la passphrase ET de la sauvegarde du portefeuille</strong>  pour restaurer votre portefeuille pour lequel la passphrase est active, au cas o votre BitBox02 serait perdu ou cass. Si vous oubliez ou perdez votre passphrase, vous perdrez l'accs  toutes les fonds se trouvant dans ce portefeuille.\n\nLorsque vous stockez votre passphrase, pensez bien  la conserver dans un endroit diffrent de celui de votre sauvegarde. De cette faon, si venait  trouver votre sauvegarde, il n'aurait pas accs  votre passphrase galement.",
    title: "Considrations relatives  la sauvegarde"
  },
  disable: "Dsactiver la passphrase",
  disableInfo: {
    button: "Dsactiver",
    message: "Une fois la passphrase dsactive, il ne vous sera plus demand de saisir une passphrase aprs avoir dverrouill votre BitBox02. Par consquent, vous entrerez dans votre portefeuille par dfaut.\n\nTous les coins (monnaies) se trouvant sur votre portefeuille avec passphrase seront toujours sur ce portefeuille, mais vous ne pourrez plus y accder car aprs avoir dverrouill votre BitBox02, vous ouvrirez votre portefeuille par dfaut.\n\nPour accder de nouveau  vos portefeuilles avec passphrase, il suffit de ractiver la fonction passphrase et de saisir la passphrase correspondante aprs dverrouillage de la BitBox02.\n\n<strong>Astuce:</strong> Vous pouvez toujours accder  votre portefeuille d'origine en laissant la phrase de passe vide."
  },
  enable: "Activer la passphrase",
  error: {
    e104: "La modification des paramtres de la passphrase a t interrompue."
  },
  how: {
    button: "A quoi a ressemble",
    message: "Une passphrase ne fonctionne pas comme les mots de passe auxquels vous tes habitu. Si vous vous trompez dans la saisie de votre passphrase, vous ne serez pas averti. En effet, <strong>chaque passphrase cre un portefeuille distinct, mais valide</strong>. Cela signifie que vous pouvez utiliser autant de passphrases que vous le souhaitez afin de crer autant de portefeuilles correspondants. Mais on ne peut accder  chaque portefeuille qu'en saisissant la passphrase associe.\n\nAu moment o vous branchez votre BitBox02, le mot de passe de l'appareil vous sera demand de manire habituelle. Ensuite, il vous sera demand d'entrer une passphrase sur l'appareil.\n\nAprs avoir saisi la passphrase, vous verrez s'afficher cette mme passphrase que vous avez entre. Cela vous permet de confirmer que vous l'avez saisie correctement.",
    title: "Comment a marche"
  },
  intro: {
    message: "Une passphrase fournit une couche supplmentaire de scurit en plus pour votre portefeuille.\nVoyons comment cela fonctionne.",
    title: "Configurer la passphrase"
  },
  progressDisable: {
    message: "Confirmez sur votre BitBox que vous souhaitez <strong>dsactiver</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  progressEnable: {
    message: "Confirmez sur votre BitBox que vous voulez <strong>activer</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  successDisabled: {
    message: "Passphrase optionnelle <strong>active avec succs</strong> !\nIl vous sera demand de fournir une passphrase  partir de maintenant.",
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02",
    title: "Passphrase active"
  },
  successEnabled: {
    message: "Passphrase optionnelle <strong>dsactive avec succs</strong> !\nIl ne vous sera plus demand de fournir une passphrase  partir de maintenant.",
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02.",
    tips: "Astuces",
    tipsList: [
      "Nous vous suggrons d'envoyer d'abord un petit montant dans le portefeuille avec passphrase. Ensuite, dbranchez puis rebranchez la BitBox02 avant de saisir votre mot de passe et votre passphrase. Si vous avez entr votre passphrase correctement, vous devriez voir les fonds dans votre portefeuille.",
      "Si vous souhaitez accder  votre portefeuille d'origine sans passphrase, vous pouvez toujours le faire en ne saisissant tout simplement rien lorsque vous tes invit  fournir la passphrase. Vous pouvez galement choisir de dsactiver la fonction passphrase."
    ],
    title: "Passphrase dsactive"
  },
  summary: {
    button: "Activer la passphrase",
    title: "Rsum",
    understand: "Je comprends le fonctionnement de la passphrase et les risques qui lui sont associs.",
    understandList: [
      "La passphrase est une couche de scurit supplmentaire en plus de votre sauvegarde.",
      "La saisie d'une passphrase diffrente gnrera  chaque fois un porte-monnaie diffrent.",
      "Pour restaurer votre portefeuille, vous avez besoin <strong> la fois de la passphrase et de la sauvegarde</strong>.",
      "Si vous oubliez votre passphrase, vous ne pourrez plus accder  vos fonds."
    ]
  },
  what: {
    button: "Dcouvrez comment cela fonctionne",
    message: `Un portefeuille est cr (driv)  partir d'un  nombre alatoire trs grand, galement appel "seed" (graine). Cette seed est cre lors de la premire configuration de votre BitBox02 et est sauvegarde via la carte microSD ou les mots de rcupration. Toute personne ayant accs  la seed dispose d'un contrle total sur les fonds de ce portefeuille.

Une passphrase est un <strong>secret optionnel</strong>, ajout  la seed. Lorsque vous utilisez une passphrase, chaque passphrase cre un nouveau portefeuille bas sur la seed + la passphrase (secret optionnel). Une passphrase peut tre n'importe quoi : des lettres, des mots, des caractres spciaux ou mme tre vide. Le portefeuille par dfaut est en fait driv de la seed + passphrase vide.

La passphrase fait partie de la norme BIP39, ce qui signifie qu'elle est compatible avec tous les portefeuilles qui supportent cette dernire.`,
    title: "Qu'est-ce qu'une passphrase?"
  },
  why: {
    button: "Pourquoi utiliser une passphrase",
    message: `La BitBox02 protge la seed contre l'extraction depuis l'appareil lui-mme, mais la sauvegarde (carte microSD ou mots de rcupration) donne un accs complet au portefeuille. C'est pourquoi elle doit tre stocke dans un endroit sr !

Puisqu'une passphrase cre un nouveau portefeuille en utilisant votre seed existante, le portefeuille avec passphrase ncessite  la fois <strong> votre sauvegarde ET votre passphrase pour tre restaur</strong>. L'avantage de ceci est que si quelqu'un trouve votre sauvegarde, il a toujours besoin de la passphrase pour accder au poretefeuille avec passphrase.

En outre, la fonction passphrase vous permet de crer plusieurs portefeuilles sur le mme appareil, ou "portefeuilles cachs", en plus du portefeuille par dfaut.`,
    title: "Pourquoi utiliser une passphrase"
  }
};
const password$e = {
  show: "Montrer {{label}}",
  warning: {
    caps: "ATTENTION : le verrouillage des majuscules () est activ",
    paste: 'Pour coller du texte, activez "Montrer {{label}}"'
  }
};
const random$f = {
  button: "Gnrer un numro alatoire",
  description: "Votre BitBox a gnr le numro alatoire  {{bits}}-bit suivant :"
};
const receive$g = {
  bitsuranceWarning: "Ceci est un compte assur, ce qui signifie qu'il ne peut recevoir des fonds que sur des adresses Native Segwit. Ceci afin d'viter que vous ne receviez accidentellement des fonds vers des adresses Wrapped Segwit ou Taproot, qui ne sont elles pas assures.",
  changeScriptType: "Changer de type d'adresse",
  label: "Votre adresse",
  onlyThisCoin: {
    description: "Pour recevoir d'autres coins, activez-les dans les paramtres. Si vous dposez d'autres coins, il se peut qu'ils ne soient pas accessibles.",
    warning: "Assurez-vous de ne recevoir que {{coinName}} sur cette adresse."
  },
  scriptType: {
    p2tr: "Taproot (nouveau format d'adresse)",
    p2wpkh: "Native Segwit (par dfaut)",
    "p2wpkh-p2sh": "Wrapped Segwit (format compatible)"
  },
  selectAccount: "Slectionner un compte",
  showFull: "Afficher et vrifier l'adresse complte sur l'appareil",
  taprootWarning: `Remarque : Taproot est une nouvelle fonctionnalit sur Bitcoin et n'est pas encore largement adopte. Les fonds reus sur les adresses Taproot peuvent potentiellement ne pas tre visibles depuis les portefeuilles "watch-only" tiers. De nombreux portefeuilles et exchanges ne sont pas encore en mesure d'envoyer des fonds aux adresses Taproot.`,
  title: "Recevoir {{accountName}}",
  verify: "Vrifier l'adresse de faon scurise",
  verifyBitBox01: "Vrifier l'adresse sur l'application mobile",
  verifyBitBox02: "Vrifier l'adresse sur le BitBox02",
  verifyInstruction: "Veuillez vrifier que l'adresse suivante correspond  celle affiche sur votre appareil.",
  warning: {
    secureOutput: "Veuillez appairer votre BitBox avec votre tlphone mobile pour activer la vrification scurise des adresses. Cliquez sur Grer l'appareil dans la barre latrale."
  }
};
const reset$e = {
  description: "Toutes les donnes vont tre supprimes de l'appareil. Ceci inclut votre Cl Prive !",
  notReset: "Appareil NON rinitialis.",
  title: "Rinitialiser l'appareil aux paramtres usine",
  understand: "J'ai une sauvegarde et je connais mon mot de passe de rcupration",
  understandBB02: "J'ai une sauvegarde valide"
};
const securityInformation$e = {
  create: {
    description1: "Il est recommand de configurer votre appareil dans un environnement scuris; c'est--dire loin d'autres personnes qui seraient susceptibles de voir le mot de passe que vous choisissez.",
    description2: "Il vous sera demand de crer deux mots de passe.",
    description3: "Le premier est le <strong>mot de passe de l'appareil</strong> qui dverrouille votre BitBox et peut tre modifi ultrieurement.",
    description4: "Le second est le <strong>mot de passe de rcupration</strong> qui dverrouille votre portefeuille. Ce mot de passe ne peut PAS tre chang ultrieurement.",
    description5: "Le portefeuille que vous crez sera sauvegard dans un fichier sur la carte microSD fournie. Elle peut tre utilis en cas d'urgence pour rcuprer vos fonds avec l'aide de votre <strong>mot de passe de rcupration</strong>.",
    title: "Information de scurit"
  },
  restore: {
    description1: "Il vous sera demand d'insrer la carte microSD utilise pour votre sauvegarde.",
    description2: "Pour restaurer votre appareil, vous aurez besoin de votre mot de passe de rcupration.",
    description3: "Veuillez faire attention lorsque vous entrez le mot de passe de rcupration. Tout mot de passe que vous entrez crera un portefeuille valide. Si vous entrez un mot de passe diffrent, le solde du portefeuille ne sera pas celui attendu.",
    title: "Information de scurit"
  }
};
const seed$e = {
  agreements: {
    "funds-access": "Je ne pourrai PAS accder  mes fonds si j'oublie mon mot de passe de rcupration",
    "password-change": "Je ne peux PAS changer le mot de passe de rcupration ultrieurement",
    "password-required": "Le mot de passe de rcupration est ncessaire pour restaurer un portefeuille  partir d'une sauvegarde."
  },
  create: "Crer un portefeuille",
  creating: "Crer un portefeuille",
  description: "Je comprends que :",
  error: {
    e102: "Le mot de passe doit contenir au minimum 4 caractres.",
    e200: "Vous devez insrer une carte microSD dans votre BitBox afin de crer un portefeuille, une sauvegarde se cre ainsi automatiquement."
  },
  info: {
    button: "Dfinir le mot de passe maintenant",
    description1: "Insrez la carte microSD dans le BitBox",
    description2: 'Choisissez un mot de passe de rcupration pour le portefeuille et slectionnez "Dfinir le mot de passe de rcupration maintenant".',
    description3: "La sauvegarde sur une carte microSD et votre mot de passe de rcupration constituent le seul moyen de rcuprer vos fonds en cas de perte ou de vol de votre BitBox.",
    description4: "Vous ne pouvez pas modifier votre mot de passe de rcupration sans avoir transfr vos fonds au pralable.",
    title: "Crer un nouveau portefeuille"
  },
  password: {
    label: "Mot de passe de rcupration",
    repeatPlaceholder: "Rpter le mot de passe de rcupration"
  },
  walletName: {
    label: "Nom du portefeuille"
  }
};
const seedRestore$e = {
  error: {
    e200: "La restauration d'un portefeuille  partir d'une sauvegarde ncessite la carte microSD."
  },
  info: {
    description1: "Insrez la carte microSD dans le BitBox et cliquez sur Continuer",
    description2: 'Choisissez une sauvegarde et cliquez sur "Restaurer"',
    description3: "Entrez le mot de passe de rcupration",
    description4: "Vous devez confirmer avoir compris qu'un mot de passe incorrect crera un portefeuille diffrent.",
    title: "Comment restaurer un portefeuille  partir d'une sauvegarde"
  }
};
const send$g = {
  abort: "La transaction a t annule.",
  address: {
    label: "Adresse du destinataire",
    placeholder: "Entrer l'adresse"
  },
  amount: {
    label: "Montant",
    placeholder: "Entrer le montant"
  },
  availableBalance: "Solde disponible",
  button: "Revoir",
  coincontrol: {
    address: "Adresse",
    outpoint: "Point de sortie",
    title: "Envoi  partir de"
  },
  confirm: {
    "selected-coins": "Coins slectionns",
    title: "Confirmer et envoyer la transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Il semblerait que vous n'ayez pas assez d'Ether pour rgler cette transaction ERC20. Veuillez vous assurer que vous avez suffisamment d'Ether dans votre portefeuille.",
    feeTooLow: "Frais pas assez levs",
    feesNotAvailable: "Estimation des frais impossible",
    insufficientFunds: "fonds insuffisants",
    invalidAddress: "adresse invalide",
    invalidAmount: "montant invalide",
    invalidData: "donnes invalides"
  },
  fee: {
    customPlaceholder: "Entrer le montant",
    label: "Frais de rseau",
    placeholder: "Indisponible"
  },
  feeTarget: {
    customLabel: "Taux des frais",
    customLabel_eth: "Prix du Gas",
    description: {
      economy: "4 heures (24 blocs)",
      economy_eth: "30 minutes maximum",
      economy_ltc: "1 heure (24 blocs)",
      high: "20 minutes (2 blocs)",
      high_eth: "30 secondes maximum",
      high_ltc: "5 minutes (2 blocs)",
      low: "2 heures (12 blocs)",
      low_eth: "5 minutes maximum",
      low_ltc: "30 minutes (12 blocs)",
      normal: "1 heure (6 blocs)",
      normal_eth: "2 minutes maximum",
      normal_ltc: "15 minutes (6 blocs)"
    },
    estimate: "Temps d'attente estim avant confirmation:",
    label: {
      custom: "Personnalis",
      economy: "conomique",
      high: "lev",
      low: "Faible",
      normal: "Normal"
    },
    placeholder: "Calcul des frais"
  },
  maximum: "Envoyer tout",
  maximumSelectedCoins: "",
  noFeeTargets: "L'estimation des frais n'est pas disponible actuellement. Veuillez ressayer plus tard ou saisir des frais personnaliss.",
  priority: "Priorit",
  scanQR: "Scanner un QR Code",
  signprogress: {
    description: "Cette transaction contient beaucoup de donnes. Pour la signer entirement, il vous sera demand de confirmer {{steps}} fois.",
    label: "Avancement"
  },
  success: "La transaction a t signe et envoye.",
  title: "Envoyer {{accountName}}",
  toggleCoinControl: "Slecteur de coins",
  transactionDetails: "Dtails de la transaction"
};
const settings$f = {
  about: " propos",
  accounts: "Comptes",
  advancedSettings: "Paramtres avancs",
  appearance: "Apparence",
  electrum: {
    add: "Ajouter un serveur",
    "add-server": "Ajouter",
    check: "Vrifier",
    checkFailed: "chou",
    checkSuccess: "Connexion  {{hte}} russie",
    checking: "Vrification",
    "download-cert": "Tlcharger le certificat distant",
    "remove-server": "Retirer",
    removeConfirm: "Supprimer {{serveur}} ?",
    reset: "Rinitialisation aux valeurs par dfaut",
    resetConfirm: 'Voulez-vous retirer tous les serveurs et installer ceux "par dfaut" ?',
    servers: "Serveurs",
    step1: "1",
    "step1-text": "Entrez le endpoint.",
    step2: "2",
    "step2-text": "Entrez un certificat de la chane de certificats du serveur. Vous pouvez galement tlcharger le certificat isol et le comparer visuellement.",
    "step2-text-tcp": "Vous pouvez sauter cette tape si vous ne souhaitez pas utiliser TLS.",
    step3: "3",
    "step3-text": "Vrifiez la connexion et ajoutez le serveur.",
    step4: "4",
    "step4-text": "Redmarrez l'appareil. Si vous ne supprimez pas les serveurs par dfaut votre nud sera ajout comme une redondance.",
    "title-btc": "Serveurs Bitcoin Electrum",
    "title-ltc": "Serveurs Litecoin Electrum",
    "title-tbtc": "Serveurs Bitcoin Testnet Electrum",
    "title-tltc": "Serveurs Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activer le contrle des monnaies",
    electrum: {
      description: "Vous pouvez vous connecter  votre propre nud Electrum.",
      title: "Connectez votre nud complet"
    },
    fee: "Activer la personnalisation des frais",
    setProxyAddress: "Dfinir une adresse proxy",
    title: "Paramtres avancs",
    useProxy: "Activer tor proxy",
    useSats: "Afficher les valeurs des BTC en Satoshis"
  },
  header: {
    home: "Accueil"
  },
  info: {
    "out-of-date": "Nouvelle mise  jour disponible",
    title: "Info",
    "up-to-date": "Votre application est  jour",
    version: "Version de l'application"
  },
  restart: "Veuillez redmarrer la BitBoxApp pour que les changements prennent effet.",
  services: {
    title: "Services"
  },
  success: "Veuillez dbrancher et reconnecter le BitBox pour que les modifications prennent effet.",
  title: "Paramtres"
};
const setup$e = "Configuration de l'appareil";
const sidebar$f = {
  buy: "Acheter de la crypto",
  device: "Grer l'appareil",
  insurance: "Assurance",
  leave: "Quitter",
  settings: "Paramtres"
};
const success$l = {
  create: {
    info1: "Votre portefeuille a t correctement sauvegard sur la carte microSD. Retirez-la et gardez-la en scurit.",
    info2: "Vous avez cr un mot de passe scuris pour l'appareil qui permet de dverrouiller votre BitBox.",
    info3: "Vous avez cr un mot de passe de rcupration scuris pour votre portefeuille, qui dverrouille vos fonds et permet la restauration de vos sauvegardes.",
    summary: "Voici un rsum de ce que vous avez fait",
    title: "Succs"
  },
  getstarted: "Commencer",
  restore: {
    summary: "Vous avez restaur avec succs un portefeuille  partir de votre sauvegarde.",
    title: "Succs"
  }
};
const transaction$f = {
  confirmation: "Confirmations",
  details: {
    activity: "Activit",
    address: "Adresse",
    amount: "Montant",
    date: "Date",
    fiat: "Devise",
    fiatAmount: "Montant en Fiat",
    fiatAtTime: "Fiat au moment de la transaction",
    status: "Statut",
    title: "Dtails de la transaction",
    type: "Type"
  },
  explorer: "Identification de transaction",
  explorerTitle: "Ouvrir dans un Explorateur de blocs externe",
  fee: "Frais",
  fiatHistorical: "Historique",
  gas: "Gaz",
  note: {
    edit: "Modifier la note",
    save: "Sauvegarder la note"
  },
  pending: "Transaction en attente",
  size: "Taille",
  status: {
    complete: "Termin",
    failed: "chou",
    pending: "En attente"
  },
  tx: {
    received: "Reu de",
    sent: "Envoy "
  },
  vsize: "Taille virtuelle",
  weight: "Poids"
};
const transactions$e = {
  errorLoadTransactions: "Une erreur s'est produite lors du chargement des transactions",
  placeholder: "Aucune transaction pour le moment."
};
const unknownError$e = "Une erreur inconnue s'est produite : {{errorMessage}}";
const unlock$e = {
  description: "Entrez le mot de passe de votre appareil pour le dverrouiller.",
  error: {
    e109_normal: "Mauvais mot de passe. {{remainingAttempts}} essais restant avant que l'appareil se rinitialise.",
    e109_touch: "$t(unlock.error.e109_normal) La prochaine connexion ncessite de maintenir le bouton tactile enfonc.",
    e113: "En raison de nombreuses tentatives de connexion, la connexion suivante ncessite de maintenir le bouton tactile enfonc pendant 4 secondes."
  },
  input: {
    label: "Mot de passe de l'appareil",
    placeholder: "Entrez le mot de passe de votre appareil pour le dverrouiller"
  },
  unlocking: "Dverrouillage"
};
const upgradeFirmware$f = {
  button: "Mettre  jour le firmware",
  description: "Voulez-vous mettre  jour le firmware de la version {{currentVersion}}  la {{newVersion}} ?",
  label: "Une mise  jour du firmware de votre BitBox est ncessaire.",
  locked: "Pour effectuer la mise  jour de la {{currentVersion}}  la {{newVersion}}, veuillez presser longuement le bouton tactile.",
  title: "Mettre  jour le firmware",
  unlocked: "Le chargeur d'amorage est dverrouill. Pour continuer, veuillez :",
  unlocked1: "Dbrancher et rebrancher votre BitBox",
  unlocked2: "La LED s'allumera lorsque votre BitBox sera rebranch",
  unlocked3: "Appuyez sur le bouton tactile lorsque la LED s'allume"
};
const walletConnect$9 = {
  connect: {
    button: "Connecter",
    dappLabel: "Saisir l'adresse URI de la Dapp",
    invalidPairingUri: "Uri d'appariement non valide"
  },
  dashboard: {
    allSessions: "Toutes les sessions",
    disclaimer: "Walletconnect est un protocole permettant de se connecter  des Dapps bases sur Ethereum. Ces Dapps sont gres par des services tiers, ne vous connectez donc uniquement qu' des Dapps en lesquelles vous avez entirement confiance et assurez-vous de toujours savoir ce que vous signez lorsque vous effectuez une transaction.",
    newConnection: "Nouvelle connexion",
    noConnectedSessions: "Aucun compte n'est actuellement connect  une Dapp."
  },
  invalidPairingChain: "Erreur dans l'approbation de l'appariement. Veillez  utiliser l'une des chanes prises en charge : {{chains}}",
  pairingRequest: {
    approve: "Approuver la connexion",
    reject: "Rejeter",
    title: "Nouvelle demande de connexion de"
  },
  pairingSuccess: "Dapp connecte avec succs. Vous pouvez continuer sur le site de la Dapp.",
  signingRequest: {
    account: "Compte",
    chain: "Chane",
    dapp: "Dapp",
    data: "Donnes",
    dataParsingError: "chec de l'analyse des donnes",
    decodeError: "chec de dchiffrage du message",
    method: {
      sendTransaction: "Signer et envoyer la transaction",
      signMessage: "Signer un message",
      signTransaction: "Signer une transaction",
      signTypedData: "Signer les donnes saisies"
    },
    successfullySigned: "Requte signe avec succs",
    walletConnectRequest: "Demande WalletConnect"
  },
  useNewUri: "Cet URI a dj t utilis pour une tentative de connexion. Veuillez utiliser un nouvel URI.",
  walletConnect: "WalletConnect"
};
const warning$k = {
  receivePairing: "Veuillez appairer le BitBox pour activer la vrification d'adresse scurise. Cliquez sur Grer l'appareil dans la barre latrale.",
  sdcard: "Conservez la carte micro SD sparment du BitBox,  moins que vous ne  souhaitiez grer les sauvegardes.",
  sendPairing: "Veuillez appairer le BitBox pour vrifier le dtails de la transaction en toute scurit. Cliquez sur Grer l'appareil dans la barre latrale."
};
const welcome$e = {
  connect: "Connexion BitBox02",
  getStarted: "Commenons en installant le firmware sur votre BitBox02",
  insertBitBox02: "Pour le BitBox02, appuyez sur l'appareil pour continuer.",
  insertDevice: "Pour commencer, veuillez connecter votre appareil",
  title: "Bienvenue"
};
const appTranslationsFR = {
  account: account$e,
  accountInfo: accountInfo$e,
  accountSummary: accountSummary$e,
  addAccount: addAccount$f,
  aopp: aopp$8,
  app: app$e,
  auth: auth$8,
  backup: backup$e,
  bb02Bootloader: bb02Bootloader$e,
  bitbox: bitbox$e,
  bitbox02Interact: bitbox02Interact$e,
  bitbox02Settings: bitbox02Settings$e,
  bitbox02Wizard: bitbox02Wizard$e,
  bitsurance: bitsurance$7,
  bitsuranceAccount: bitsuranceAccount$7,
  blink: blink$e,
  bootloader: bootloader$e,
  button: button$j,
  buy: buy$a,
  changePin: changePin$e,
  chart: chart$a,
  checkSDcard: checkSDcard$e,
  clickHere: clickHere$e,
  confirm: confirm$g,
  confirmOnDevice: confirmOnDevice$e,
  connectKeystore: connectKeystore$8,
  darkmode: darkmode$8,
  device: device$e,
  deviceLock: deviceLock$e,
  deviceSettings: deviceSettings$e,
  deviceTampered: deviceTampered$e,
  dialog: dialog$f,
  error: error$a,
  fiat: fiat$g,
  footer: footer$g,
  generic: generic$a,
  genericError: genericError$e,
  goal: goal$e,
  guide: guide$f,
  headerssync: headerssync$e,
  hiddenWallet: hiddenWallet$e,
  initialize: initialize$e,
  invalidFormat: invalidFormat$e,
  language: language$f,
  legacyhiddenwallet: legacyhiddenwallet$e,
  loading: loading$e,
  manageAccounts: manageAccounts$8,
  mobile: mobile$9,
  newSettings: newSettings$7,
  note: note$a,
  notification: notification$e,
  pairing: pairing$e,
  passphrase: passphrase$8,
  password: password$e,
  random: random$f,
  receive: receive$g,
  reset: reset$e,
  securityInformation: securityInformation$e,
  seed: seed$e,
  seedRestore: seedRestore$e,
  send: send$g,
  settings: settings$f,
  setup: setup$e,
  sidebar: sidebar$f,
  success: success$l,
  transaction: transaction$f,
  transactions: transactions$e,
  unknownError: unknownError$e,
  unlock: unlock$e,
  upgradeFirmware: upgradeFirmware$f,
  walletConnect: walletConnect$9,
  warning: warning$k,
  welcome: welcome$e
};
const account$d = {
  disconnect: "",
  "export": "",
  exportTransactions: "CSV",
  fatalError: "",
  incoming: "",
  initializing: "",
  insuranceExpired: "<strong></strong>\n\n\n",
  insured: "",
  maybeProxyError: "TorTor",
  reconnecting: "",
  syncedAddressesCount: "{{count}}",
  uncoveredFunds: "",
  uncoveredFundsLink: "",
  warning: ""
};
const accountInfo$d = {
  address: "",
  buyCTA: {
    buy: "{{unit}}",
    buyCrypto: "",
    information: {
      looksEmpty: "",
      start: "BitBoxApp"
    }
  },
  extendedPublicKey: "",
  label: "",
  scriptType: "",
  title: "",
  verify: "",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH",
    p2tr: "Taproot",
    p2wpkh: "Segwit",
    "p2wpkh-p2sh": "Segwit"
  },
  xpubTypeInfo: "{{scriptType}}{{numberOfXPubs}}{{current}}"
};
const accountSummary$d = {
  availableBalance: "",
  balance: "",
  exportSummary: "CSV",
  fiatBalance: "",
  name: "",
  noAccount: "",
  subtotalWithCoinName: "{{coinName}}",
  title: "",
  total: "",
  transactionHistory: ""
};
const addAccount$e = {
  chooseName: {
    nextButton: "",
    step: "",
    title: ""
  },
  selectCoin: {
    nextButton: "",
    step: "",
    title: ""
  },
  success: {
    addAnotherAccount: "",
    message: "<strong>{{accountName}}</strong>",
    nextButton: "",
    step: "",
    title: ""
  },
  title: ""
};
const aopp$7 = {
  addressRequest: "{{host}}",
  addressRequestWithLogo: "",
  banner: "",
  errorTitle: "",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: "",
  signing: "BitBox02",
  success: {
    message: "{{host}}",
    title: ""
  },
  syncing: "",
  title: ""
};
const app$d = {
  upgrade: "{{current}}{{version}}"
};
const auth$7 = {
  authButton: "",
  title: ""
};
const backup$d = {
  check: {
    checking: "",
    confirmTitle: "",
    notOK: "",
    ok: "",
    password: {
      label: "",
      placeholder: "",
      showLabel: ""
    },
    success: "",
    title: ""
  },
  create: {
    alreadyExists: "",
    fail: "",
    info: "",
    name: {
      label: "",
      placeholder: ""
    },
    password: {
      label: "",
      placeholder: ""
    },
    title: "",
    verificationFailed: ""
  },
  description: "<strong></strong>",
  insert: "SD",
  insertButton: "SD",
  list: "microSD",
  noBackups: "microSD",
  restore: {
    confirmTitle: "",
    error: {
      e200: "microSD",
      general: ""
    },
    password: {
      label: "",
      placeholder: "",
      repeatPlaceholder: "",
      showLabel: ""
    },
    restoring: "",
    selectedBackup: "<strong>{{backupName}}</strong>{{createdDateTime}}",
    title: "",
    understand: ""
  },
  showMnemonic: {
    description: "BitBox02\n\n<strong></strong>\n\n<strong></strong>\n\n<strong></strong>\n\n",
    title: "",
    warning: "<strong></strong>"
  },
  title: ""
};
const bb02Bootloader$d = {
  abort: "  ",
  abort_noUpgrade: "",
  advanced: {
    label: "",
    toggleShowFirmwareHash: ""
  },
  flipscreen: "",
  orientation: "",
  success: "{{rebootSeconds}}",
  success_install: "{{rebootSeconds}} "
};
const bitbox$d = {
  error: {
    e10000: "",
    e10001: "",
    e102: "4",
    e112: ""
  }
};
const bitbox02Interact$d = {
  confirmDate: "BitBox02",
  confirmDateText: "",
  confirmName: "BitBox02",
  confirmWords: "BitBox02{{amount}}",
  confirmWordsText: "BitBox02",
  followInstructions: "BitBox02",
  followInstructionsMnemonic: "BitBox02",
  followInstructionsMnemonicTitle: ""
};
const bitbox02Settings$d = {
  deviceName: {
    current: "",
    error: "",
    error_104: "",
    input: "BitBox02",
    placeholder: "",
    title: "BitBox02"
  },
  gotoStartupSettings: {
    description: "BitBox02",
    title: ""
  }
};
const bitbox02Wizard$d = {
  advanced: {
    button: "",
    outOfDate: "",
    seed12WordInfo: "",
    seed12WordLabel: "2412",
    seed12WordText: "BitBox022412",
    skipSDCardLabel: "SD",
    skipSDCardText: "microSD",
    title: ""
  },
  attestationFailed: "support@bitbox.swiss",
  backup: {
    point1: "microSD",
    point2: "",
    restoreText: "",
    text1: "BitBox02microSD",
    text2: "",
    text3: "microSD<strong></strong>microSDBitBox02",
    userConfirmation1: "",
    userConfirmation2: "",
    userConfirmation3: "BitBox02",
    userConfirmation4: "BitBox02",
    userConfirmation5: "SDBitBox02",
    userConfirmation5mnemonic: "BitBox02"
  },
  create: {
    button: "",
    info: "BitBox",
    inputTitle: "",
    point1: "",
    point2: "",
    point3: "",
    text: ""
  },
  createBackupAborted: "",
  createBackupFailed: "",
  initialize: {
    passwordText: "BitBox",
    passwordTitle: "BitBox",
    text: "BitBox02<strong>microSD</strong>",
    tip: "",
    title: "BitBox"
  },
  insertSDCard: "<strong>BitBox02microSD</strong?",
  noPasswordMatch: "",
  pairing: {
    failed: "BitBox02",
    paired: "",
    title: "",
    unpaired: "BitBox02BitBox02"
  },
  restoreFromMnemonic: {
    e104: "",
    failed: ""
  },
  stepBackup: {
    beforeProceed: "",
    createBackup: "microSD",
    createBackupMnemonic: ""
  },
  stepBackupSuccess: {
    fundsSafe: "",
    title: ""
  },
  stepConnected: {
    unlock: "BitBox02"
  },
  stepCreate: {
    description: "",
    nameLabel: "BitBox02",
    namePlaceholder: "BitBox02",
    title: "BitBox02",
    toastMicroSD: "BitBox02microSD"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02microSD",
    storeMnemonic: "",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "BitBox02microSD",
    insertSDcardTitle: "microSD"
  },
  stepPassword: {
    e104: "",
    title: "BitBox02",
    useControls: "BitBox02"
  },
  stepUninitialized: {
    create: "BitBox02",
    restore: "",
    restoreMicroSD: "microSD",
    restoreMnemonic: "",
    title: "BitBox02"
  },
  success: {
    text: "BitBox02\n\nBitBox App",
    title: ""
  }
};
const bitsurance$6 = {
  dashboard: {
    active: "",
    button: "",
    canceled: "",
    coverage: "",
    inactive: "",
    processing: "",
    refused: "",
    supportLink: "",
    title: "\n",
    waitpayment: ""
  },
  detect: {
    button: "",
    insured: "",
    notInsured: "",
    text: "BitsuranceBitBoxApp",
    title: ""
  },
  insure: {
    button: "",
    faq: "BitsuranceFAQ",
    listItem1: "",
    listItem2: "5",
    listItem3: "",
    month: "",
    text: "BitBox02100,000",
    text2: "302.50Bitsurance",
    text3: "",
    title: ""
  },
  intro: {
    link: "Bitsurance ",
    text1: "BitBoxBitsuranceBitBox02Bitsurance"
  },
  terms: {
    link: "Bitsurance",
    text1: "BitsuranceBitsurance",
    text2: "",
    text3: "110",
    text4: "Bitsurance",
    text5: ""
  },
  title: ""
};
const bitsuranceAccount$6 = {
  errorNoXpub: " xpub",
  noAccount: "\n",
  select: "",
  title: ""
};
const blink$d = {
  button: ""
};
const bootloader$d = {
  button: "",
  button_install: "",
  progress: "{{progress}}\r%",
  progress_install: "{{progress}}\n%",
  success: ""
};
const button$i = {
  abort: "",
  back: "",
  buy: "",
  changepin: "",
  check: "",
  "continue": "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "",
  next: "",
  ok: "OK",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
};
const buy$9 = {
  exchange: {
    bankTransfer: "",
    bestDeal: "",
    creditCard: "",
    fast: "",
    fee: "",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: ": {{fee}}%",
          creditDebitCard: "/: {{fee}}%",
          learnMore: "Moonpay",
          title: ""
        },
        fullCurrenciesList: "",
        payment: {
          asteriskText: "",
          bankTransfer: "",
          bankTransferDetails: {
            pix: "PIX",
            sepa: "SEPASEPASEPA",
            uk: "UKGBP"
          },
          creditDebitCard: "/",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "",
          title: ""
        },
        supportedCurrencies: "USDEURCHF"
      },
      pocket: {
        fees: {
          info: ": {{fee}}%",
          title: ""
        },
        learnMore: "Pocket",
        payment: {
          bankTransfer: "",
          bankTransferDetails: {
            sepa: "SEPASEPASEPA",
            sic: "CH/LICHF",
            uk: "UKGBP"
          },
          bankTransferReccuring: "",
          title: ""
        },
        supportedCurrencies: "EUR, GBP, and CHF.",
        verification: {
          info: "",
          link: "",
          title: ""
        }
      },
      region: {
        title: ""
      }
    },
    noExchanges: "",
    region: "",
    selectRegion: "",
    title: "{{name}}"
  },
  info: {
    "continue": "",
    crypto: "",
    disclaimer: {
      intro: [
        "MoonPayBitBoxApp{{name}}",
        "MoonPay160{{name}}"
      ],
      payment: {
        details: "MoonPay{{name}}4 USD/EUR",
        footnote: "MoonPayBitBoxApp",
        table: {
          "1_description": "3",
          "1_method": "(SEPA)",
          "2_description": "",
          "2_method": "",
          description: "",
          fee: "",
          method: ""
        },
        title: ""
      },
      privacyPolicy: "MoonPay",
      protection: {
        description: "BitBoxApp{{name}}MoonPay",
        descriptionGeneric: "BitBoxApp{{name}}",
        title: ""
      },
      security: {
        description: "MoonPay{{name}}BitBox02BitBoxApp",
        descriptionGeneric: "{{name}}BitBox02BitBoxApp",
        link: "",
        title: ""
      },
      title: "{{name}}"
    },
    next: "",
    selectLabel: "",
    selectPlaceholder: "",
    skip: "",
    title: " {{name}} "
  },
  pocket: {
    data: {
      link: "Pocket ",
      p1: "BitBoxAppPocket",
      title: ""
    },
    kyc: {
      link: "Pocket ",
      p1: "PocketKYC19501000KYC/AMLPocket",
      title: "KYC/AML"
    },
    payment: {
      p1: "SEPAPocket1.5%PocketBitBox",
      p2: "PocketBitBoxApp",
      title: ""
    },
    previousTransactions: "Pocket",
    security: {
      link: "BitBox02",
      p1: "PocketBitBox02BitBoxApp",
      title: ""
    },
    usedAddress: "{{address}}",
    verifyBitBox02: "Bitbox",
    welcome: {
      p1: "PocketBitBoxApp",
      p2: "PocketSEPA",
      p3: "PocketDCA",
      title: ""
    }
  },
  title: "{{name}}"
};
const changePin$d = {
  newTitle: "",
  oldLabel: ""
};
const chart$9 = {
  dataMissing: "...",
  dataOldTimestamp: "{{time}}",
  dataUpdating: "...",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
};
const checkSDcard$d = "microSD";
const clickHere$d = "";
const confirm$f = {
  abortInfo: "",
  abortInfoRedText: "",
  approveInfo: "4",
  approveInfoGreenText: "",
  info: "BitBox",
  infoWhenPaired: "BitBox"
};
const confirmOnDevice$d = "";
const connectKeystore$7 = {
  promptNoName: "BitBox02",
  promptWithName: '"{{name}}" BitBox02'
};
const darkmode$7 = {
  toggle: ""
};
const device$d = {
  appUpradeRequired: "BitBox",
  keystoreConnected: ""
};
const deviceLock$d = {
  button: "2(2FA)",
  condition1: "",
  condition2: "",
  condition3: "2(2FA)2",
  confirm: "2(2FA)",
  title: "2(2FA)"
};
const deviceSettings$d = {
  backups: {
    manageBackups: {
      description: "SD"
    },
    showRecoveryWords: {
      description: ""
    },
    title: ""
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp"
    },
    deviceName: {
      description: ""
    },
    rootFingerprint: {
      description: ""
    },
    securechip: {
      description: ""
    },
    title: ""
  },
  expert: {
    factoryReset: {
      description: "BitBox02",
      title: ""
    },
    goToStartupSettings: {
      description: "BitBox02"
    },
    passphrase: {
      description: "",
      title: ""
    }
  },
  firmware: {
    firmwareVersion: "",
    newVersion: {
      label: ""
    },
    title: "",
    upToDate: "",
    upgradeAvailable: "",
    version: {
      label: ""
    }
  },
  hardware: {
    attestation: {
      "false": "",
      label: "",
      "true": "BitBox02"
    },
    sdcard: {
      "false": "",
      label: "microSD",
      "true": ""
    },
    securechip: "",
    title: ""
  },
  loading: "",
  pairing: {
    lock: {
      "false": "",
      label: "2(2FA)",
      "true": ""
    },
    mobile: {
      "false": "",
      label: "",
      "true": ""
    },
    status: {
      "false": "",
      label: "",
      "true": ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "",
    title: ""
  }
};
const deviceTampered$d = "BitBoxShift";
const dialog$e = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
};
const error$9 = {
  accountAlreadyExists: "",
  accountLimitReached: "",
  aoppCallback: "{{host}}",
  aoppInvalidRequest: "",
  aoppNoAccounts: "",
  aoppSigningAborted: "",
  aoppUnknown: "",
  aoppUnsupportedAsset: "",
  aoppUnsupportedFormat: "",
  aoppUnsupportedKeystore: "",
  aoppVersion: "",
  wrongKeystore: "",
  wrongKeystore2: ""
};
const fiat$f = {
  "default": "",
  setDefault: "{{code}}",
  title: ""
};
const footer$f = {
  appVersion: ""
};
const generic$9 = {
  enabled_false: "",
  enabled_true: ""
};
const genericError$d = "";
const goal$d = {
  buttons: {
    create: "",
    restore: ""
  },
  paragraph: "",
  step: {
    "1": {
      title: ""
    },
    "2": {
      description: "",
      title: ""
    },
    "3-create": {
      description: "",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$e = {
  accountDescription: {
    text: "",
    title: ""
  },
  accountFiat: {
    text: "",
    title: ""
  },
  accountIncomingBalance: {
    text: "",
    title: ""
  },
  accountInfo: {
    multipleXPubs: {
      text: 'xpub"Type""Native Segwit (bech32)""Wrapped Segwit"Taproot{{coinName}}BitBoxAppxpubxpub\n\nNative Segwit"bech32" xpub"Wrapped Segwit"Taproot"Wrapped Segwit"Taproot',
      title: "xpub"
    },
    privacy: {
      text: "xpubxpub\n\nxpub",
      title: "xpub"
    },
    verify: {
      text: "xpubxpubxpub",
      title: "xpub"
    },
    xpub: {
      text: "xpub\n\nElectrumSentinelxpub\n\nTaproot xpub",
      title: ""
    }
  },
  accountRates: {
    text: "CoinGecko",
    title: ""
  },
  accountReload: {
    text: "",
    title: ""
  },
  accountSendDisabled: {
    text: "0",
    title: "{{unit}}"
  },
  accountSummaryAmount: {
    text: "coingecko.com\n\n: BitBoxAppMyEtherWallet\n\n\n\n",
    title: ""
  },
  accountSummaryDescription: {
    text: "",
    title: ""
  },
  accountTransactionAttributesBTC: {
    text: "Virtual size\nSize\nWeightSegwitSegregated Witness141400",
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: "\n36\nIDblock explorer\n",
    title: ""
  },
  accountTransactionConfirmation: {
    text: "",
    title: ""
  },
  accountTransactionLabel: {
    text: "\n",
    title: ""
  },
  accountTransactionTime: {
    text: "\n",
    title: ""
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin Litecoin5\n5",
      title: ""
    },
    howtoAddTokens: {
      text: "ERC20",
      title: ""
    },
    moveFunds: {
      text: "",
      title: ""
    },
    recoverAccounts: {
      text: "BitBoxApp",
      title: ""
    },
    whatAreAccounts: {
      text: "",
      title: ""
    },
    whatIsRememberWallet: {
      text: "BitBox02BitBoxAppBitBox02\n\nBitBox02BitBoxApp\n",
      title: ""
    },
    whyIsThisUseful: {
      text: "",
      title: ""
    }
  },
  appendix: {
    link: "",
    text: ""
  },
  backups: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "",
      title: ""
    },
    howOften: {
      text: "microSDmicroSD\n",
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  backupsBB02: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "microSD",
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  bitbox: {
    "2FA": {
      text: "2(2FA)BitBox\n2(2FA)2(2FA)microSDBitBox",
      title: "2(2FA)"
    },
    disable2FA: {
      text: "2(2FA)BitBoxmicroSD",
      title: "2(2FA)"
    },
    ejectBitbox: {
      text: "BitBox",
      title: "BitBox"
    },
    ejectSD: {
      text: "microSDBitBox",
      title: "microSD"
    },
    hiddenWallet: {
      text: "(plausible deniability)",
      title: ""
    },
    legacyHiddenWallet: {
      text: "BitBox2BitBox",
      title: " legacy"
    },
    pairing: {
      text: "iOSAndroidQR",
      title: ""
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "BitsuranceFAQ",
      title: ""
    },
    privacy: {
      link: {
        text: "Bitsurance"
      },
      text: "BitsuranceShift CryptoBitsurance\n\n\n\n\n\n",
      title: ""
    },
    renew: {
      text: "BitBoxAppBitsurance",
      title: ""
    },
    status: {
      text: "",
      title: ""
    },
    what: {
      text: "Native Segwit",
      title: "BitBox"
    },
    who: {
      text: "BitsuranceELEMENT Insurance\n",
      title: ""
    },
    why: {
      text: "Bitsurance",
      title: ""
    }
  },
  cointracking: {
    text: '""CSVBitBoxCSVCoinTracking',
    title: "CoinTracking"
  },
  device: {
    attestation: {
      link: {
        text: ""
      },
      text: "BitBoxAppBitBox02",
      title: ""
    },
    name: {
      text: "",
      title: "BitBox02"
    },
    "secure-chip": {
      link: {
        text: ""
      },
      text: "ATECC608B",
      title: ""
    }
  },
  receive: {
    address: {
      text: "",
      title: ""
    },
    addressChange: {
      text: "20",
      title: ""
    },
    addressFormats: {
      text: "Native Segwit/TaprootNative Segwit/Wrapped Segwit",
      title: '""'
    },
    howVerify: {
      text: "BitBox01BitBox\nBitBox02",
      title: ""
    },
    plugout: {
      text: "BitBoxBitBoxBitBox",
      title: "BitBox"
    },
    why20: {
      text: "202020",
      title: "20"
    },
    whyMany: {
      text: "2201",
      title: ""
    },
    whyVerify: {
      text: "BitBox01QRBitBox02BitBox02",
      title: ""
    }
  },
  send: {
    change: {
      text: "Taproot UTXO1TaprootUTXO1Taproot UTXOTaprootNative Segwit",
      title: ""
    },
    fee: {
      text: "Bitcoin Core\n24(Bitcoin4Litecoin1)\n12(Bitcoin2Litecoin30)\n6(Bitcoin1Litecoin15)\n2(Bitcoin20Litecoin5)\n(1Bitcoin10Litecoin2.5)",
      title: ""
    },
    plugout: {
      text: "BitBoxBitBox",
      title: "BitBox"
    },
    priority: {
      text: "",
      title: ""
    },
    revert: {
      text: "()()\n()",
      title: ""
    },
    whyFee: {
      text: "11()",
      title: ""
    }
  },
  "settings-electrum": {
    connection: {
      text: "wifi\nElectrumTLS\nTorTLS",
      title: "clearnet TCPTLSTor"
    },
    instructions: {
      link: {
        text: ""
      },
      text: "",
      title: "BitBoxApp"
    },
    options: {
      text: "Bitcoin Core\nBitBoxAppElectrum\nElectrsElectrum Personal Server (EPS)Bitcoin Wallet Tracker (BTW)",
      title: ""
    },
    tor: {
      text: "TorThe Onion Router\nTorTorBitBoxAppTor Proxy\nOSTor2\n1. Tor Browser: Tor Browser Tor9150BitBoxAppTor\n2. Tor background serviceTorBitBoxAppTor9050",
      title: "TorTor\n"
    },
    what: {
      text: "Shift",
      title: ""
    },
    why: {
      text: "\nBitBoxApp\n",
      title: ""
    }
  },
  settings: {
    sats: {
      text: "Satoshisat1 Satoshibitcoin110.00000001BTCbitcoin",
      title: "Satoshi"
    },
    servers: {
      text: "Shift CryptoCoinGecko()",
      title: ""
    }
  },
  title: "",
  toggle: {
    close: "",
    open: ""
  },
  trackingModePortfolioChart: {
    text: "",
    title: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "",
      title: ""
    },
    reset: {
      text: "15",
      title: ""
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "\n\nBitBox01BitBox01BitBoxApp",
      title: "BitBox01"
    },
    getDevice: {
      link: {
        text: "BitBox"
      },
      text: "BitBox",
      title: ""
    },
    internet: {
      text: "",
      title: ""
    },
    lostDevice: {
      link: {
        text: ""
      },
      text: "BitBox",
      title: ""
    },
    useWithoutDevice: {
      text: "",
      title: ""
    },
    welcome: {
      text: "Shift Crypto",
      title: "BitBoxApp"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "BitBoxApp/DAppsDApp",
      title: ""
    },
    supportedNetworks: {
      text: "BitBoxAppWalletConnectEthereumEVMRabby",
      title: ""
    },
    whatIsWalletConnect: {
      text: "WalletConnectweb3EthereumDAppsBitBoxAppAndroid",
      title: "WalletConnect"
    }
  }
};
const headerssync$d = {
  blocksSynced: "{{blocks}}"
};
const hiddenWallet$d = {
  info1HTML: "(plausible deniability)<strong></strong>",
  info2HTML: "2<strong></strong>",
  passwordLabel: "",
  passwordPlaceholder: "",
  pinLabel: "",
  pinRepeatLabel: "",
  pinRepeatPlaceholder: "",
  success: ""
};
const initialize$d = {
  create: "",
  creating: "",
  error: {
    e102: "4()"
  },
  info: {
    description1: "BitBox",
    description2: "",
    description3: "",
    subtitle: "",
    title: ""
  },
  input: {
    label: "",
    labelRepeat: "",
    placeholderRepeat: ""
  }
};
const invalidFormat$d = "";
const language$e = {
  title: ""
};
const legacyhiddenwallet$d = {
  disable: " legacy",
  enable: " legacy",
  successDisable: " legacy",
  successEnable: " legacyBitBox"
};
const loading$d = "";
const manageAccounts$7 = {
  accountHidden: "BitBox02",
  editAccount: "",
  editAccountNameTitle: "",
  noAccounts: "",
  settings: {
    hideTokens: "",
    showTokens: " ({{activeTokenCount}})"
  },
  settingsButtonDescription: "/",
  title: "",
  watchAccount: "",
  watchAccountDescription: ""
};
const mobile$8 = {
  usingMobileDataWarning: "Wi-Fi"
};
const newSettings$6 = {
  about: {
    appVersion: {
      title: ""
    }
  },
  advancedSettings: {
    authentication: {
      description: "",
      title: ""
    },
    coinControl: {
      description: "UTXO"
    },
    customFees: {
      description: ""
    },
    torProxy: {
      description: "Tor"
    }
  },
  appearance: {
    activeCurrencies: {
      description: "",
      title: ""
    },
    darkmode: {
      description: "BitBoxApp"
    },
    defaultCurrency: {
      description: "",
      title: ""
    },
    enableAccount: {
      description: "",
      title: "/"
    },
    hideAmounts: {
      description: "",
      hideAmounts: "",
      showAmounts: "",
      title: ""
    },
    language: {
      description: "BitBoxApp",
      title: ""
    },
    remebmerWallet: {
      name: "",
      warning: " BitBox02 \n",
      warningTitle: ""
    },
    toggleSats: {
      description: " Satoshi"
    }
  }
};
const note$9 = {
  input: {
    description: "()",
    placeholder: "..."
  },
  title: ""
};
const notification$d = {
  newTxs_one: "{{accountName}}{{count}}",
  newTxs_other: "{{accountName}}{{count}}"
};
const pairing$d = {
  aborted: {
    text: "",
    title: ""
  },
  button: "",
  confirm: "BitBox",
  connectOnly: {
    button: "",
    title: "Connect to new desktop app"
  },
  error: {
    text: "",
    title: ""
  },
  pullFailed: {
    text: "",
    title: ""
  },
  reconnectOnly: {
    button: ""
  },
  scanningFailed: {
    text: "",
    title: ""
  },
  start: {
    hideAppQRCode: "QR",
    revealAppQRCode: "QR",
    step1: "Apple App StoreGoogle Play StoreQR",
    step2: "Digital Bitbox 2FAiOSAndroidQR"
  },
  started: {
    text: "",
    title: ""
  },
  success: {
    text: "BitBox",
    title: ""
  },
  timeout: {
    text: "2",
    title: ""
  },
  title: ""
};
const passphrase$7 = {
  considerations: {
    button: "",
    message: "SD\n\nBitBox02<strong> + </strong>\n\n",
    title: ""
  },
  disable: "",
  disableInfo: {
    button: "",
    message: "BitBox02\n\nBitBox02\n\nBitBox02\n\n<strong>:</strong>"
  },
  enable: "",
  error: {
    e104: ""
  },
  how: {
    button: "",
    message: "<strong></strong>\n\nBitBox02\n\n",
    title: ""
  },
  intro: {
    message: "\n\n\n",
    title: ""
  },
  progressDisable: {
    message: "<strong>disable</strong>BitBox",
    title: ""
  },
  progressEnable: {
    message: "<strong>enable</strong>BitBox",
    title: ""
  },
  successDisabled: {
    message: " <strong>successfully enabled</strong>\n",
    messageEnd: "BitBox02",
    title: ""
  },
  successEnabled: {
    message: "<strong></strong>\n\n",
    messageEnd: "BitBox02",
    tips: "",
    tipsList: [
      "BitBox02",
      ""
    ],
    title: ""
  },
  summary: {
    button: "",
    title: "",
    understand: "",
    understandList: [
      "",
      "",
      "<strong></strong>",
      "<strong></strong>"
    ]
  },
  what: {
    button: "",
    message: "BitBox02SD\n\n<strong></strong> +  + \n\nBIP39",
    title: ""
  },
  why: {
    button: "",
    message: "BitBox02SD\n\n<strong></strong>\n\n",
    title: ""
  }
};
const password$d = {
  show: "{{label}}",
  warning: {
    caps: "caps lock()",
    paste: "{{label}}"
  }
};
const random$e = {
  button: "",
  description: "BitBox{{bits}}bit"
};
const receive$f = {
  bitsuranceWarning: "Native SegwitWrapped SegwitTaproot",
  changeScriptType: "",
  label: "",
  onlyThisCoin: {
    description: "",
    warning: "{{coinName}}"
  },
  scriptType: {
    p2tr: "Taproot ()",
    p2wpkh: "Native Segwit ()",
    "p2wpkh-p2sh": "Wrapped Segwit"
  },
  selectAccount: "",
  showFull: "",
  taprootWarning: "TaprootTaprootwatch-only Taproot",
  title: "{{accountName}}",
  verify: "",
  verifyBitBox01: "",
  verifyBitBox02: "BitBox02",
  verifyInstruction: "",
  warning: {
    secureOutput: "BitBox\n\n\n\n"
  }
};
const reset$d = {
  description: "",
  notReset: "",
  title: "",
  understand: "",
  understandBB02: ""
};
const securityInformation$d = {
  create: {
    description1: "",
    description2: "2",
    description3: "1<strong></strong>BitBox",
    description4: "2<strong></strong>",
    description5: "SD<strong></strong>",
    title: ""
  },
  restore: {
    description1: "microSD",
    description2: "",
    description3: "",
    title: ""
  }
};
const seed$d = {
  agreements: {
    "funds-access": "",
    "password-change": "",
    "password-required": ""
  },
  create: "",
  creating: "",
  description: "",
  error: {
    e102: "4()",
    e200: "BitBoxmicroSD"
  },
  info: {
    button: "",
    description1: "BitBoxmicroSD",
    description2: "",
    description3: "SDBitBox",
    description4: "",
    title: ""
  },
  password: {
    label: "",
    repeatPlaceholder: ""
  },
  walletName: {
    label: ""
  }
};
const seedRestore$d = {
  error: {
    e200: "SD"
  },
  info: {
    description1: "BitBoxmicroSD",
    description2: "",
    description3: "",
    description4: "",
    title: ""
  }
};
const send$f = {
  abort: "",
  address: {
    label: "",
    placeholder: ""
  },
  amount: {
    label: "",
    placeholder: ""
  },
  availableBalance: "",
  button: "",
  coincontrol: {
    address: "",
    outpoint: "",
    title: ""
  },
  confirm: {
    "selected-coins": "",
    title: "",
    total: ""
  },
  error: {
    erc20InsufficientGasFunds: "ERC20",
    feeTooLow: "",
    feesNotAvailable: "",
    insufficientFunds: "",
    invalidAddress: "",
    invalidAmount: "",
    invalidData: ""
  },
  fee: {
    customPlaceholder: "",
    label: "",
    placeholder: ""
  },
  feeTarget: {
    customLabel: "",
    customLabel_eth: "",
    description: {
      economy: "424",
      economy_eth: "30",
      economy_ltc: "124",
      high: "202",
      high_eth: "30",
      high_ltc: "52",
      low: "212",
      low_eth: "5",
      low_ltc: "3012",
      normal: "16",
      normal_eth: "2",
      normal_ltc: "156"
    },
    estimate: "",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "..."
  },
  maximum: "",
  maximumSelectedCoins: "",
  noFeeTargets: "",
  priority: "",
  scanQR: "QR",
  signprogress: {
    description: "{{steps}}",
    label: ""
  },
  success: "",
  title: "{{accountName}}",
  toggleCoinControl: "",
  transactionDetails: ""
};
const settings$e = {
  about: "",
  accounts: "",
  advancedSettings: "",
  appearance: "",
  electrum: {
    add: "",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "{{host}}",
    checking: "",
    "download-cert": "",
    "remove-server": "",
    removeConfirm: "{{server}} ",
    reset: "",
    resetConfirm: "",
    servers: "",
    step1: "1",
    "step1-text": "",
    step2: "2",
    "step2-text": "",
    "step2-text-tcp": "TLS",
    step3: "3",
    "step3-text": "",
    step4: "4",
    "step4-text": "",
    "title-btc": "Bitcoin Electrum",
    "title-ltc": "Litecoin Electrum",
    "title-tbtc": "Bitcoin Testnet Electrum",
    "title-tltc": "Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "",
    electrum: {
      description: "Electrum",
      title: ""
    },
    fee: "",
    setProxyAddress: "",
    title: "",
    useProxy: "Tor",
    useSats: "\nBTCSatoshi"
  },
  header: {
    home: ""
  },
  info: {
    "out-of-date": "",
    title: "",
    "up-to-date": "",
    version: ""
  },
  restart: "BitBoxApp",
  services: {
    title: ""
  },
  success: "BitBox",
  title: ""
};
const setup$d = "";
const sidebar$e = {
  buy: "",
  device: "",
  insurance: "",
  leave: "",
  settings: ""
};
const success$k = {
  create: {
    info1: "microSD",
    info2: "Bitbox",
    info3: "",
    summary: "",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "",
    title: ""
  }
};
const transaction$e = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: "",
    fiatAtTime: "",
    status: "",
    title: "",
    type: ""
  },
  explorer: "ID",
  explorerTitle: "",
  fee: "",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "",
    save: ""
  },
  pending: "",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: ""
  },
  tx: {
    received: "",
    sent: "\n"
  },
  vsize: "",
  weight: ""
};
const transactions$d = {
  errorLoadTransactions: "",
  placeholder: ""
};
const unknownError$d = "{{errorMessage}}";
const unlock$d = {
  description: "",
  error: {
    e109_normal: "{{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) ",
    e113: "4"
  },
  input: {
    label: "",
    placeholder: ""
  },
  unlocking: ""
};
const upgradeFirmware$e = {
  button: "",
  description: "{{currentVersion}}{{newVersion}}",
  label: "BitBox",
  locked: "{{currentVersion}}{{newVersion}}",
  title: "",
  unlocked: "",
  unlocked1: "BitBox",
  unlocked2: "BitBoxLED",
  unlocked3: "LED"
};
const walletConnect$8 = {
  connect: {
    button: "",
    dappLabel: "dappURI",
    invalidPairingUri: "URI"
  },
  dashboard: {
    allSessions: "",
    disclaimer: "WalletconnectEthereumDappsdappsdapps",
    newConnection: "",
    noConnectedSessions: "dapps"
  },
  invalidPairingChain: "{{chains}}",
  pairingRequest: {
    approve: "",
    reject: "",
    title: ""
  },
  pairingSuccess: "Dappdapp",
  signingRequest: {
    account: "",
    chain: "",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "",
    decodeError: "",
    method: {
      sendTransaction: "",
      signMessage: "",
      signTransaction: "",
      signTypedData: ""
    },
    successfullySigned: "",
    walletConnectRequest: "WalletConnect"
  },
  useNewUri: "URIURI",
  walletConnect: "WalletConnect"
};
const warning$j = {
  receivePairing: "BitBox",
  sdcard: "BitBoxSD",
  sendPairing: "BitBox"
};
const welcome$d = {
  connect: "BitBox02",
  getStarted: "BitBox02",
  insertBitBox02: "BitBox02",
  insertDevice: "",
  title: ""
};
const appTranslationsJA = {
  account: account$d,
  accountInfo: accountInfo$d,
  accountSummary: accountSummary$d,
  addAccount: addAccount$e,
  aopp: aopp$7,
  app: app$d,
  auth: auth$7,
  backup: backup$d,
  bb02Bootloader: bb02Bootloader$d,
  bitbox: bitbox$d,
  bitbox02Interact: bitbox02Interact$d,
  bitbox02Settings: bitbox02Settings$d,
  bitbox02Wizard: bitbox02Wizard$d,
  bitsurance: bitsurance$6,
  bitsuranceAccount: bitsuranceAccount$6,
  blink: blink$d,
  bootloader: bootloader$d,
  button: button$i,
  buy: buy$9,
  changePin: changePin$d,
  chart: chart$9,
  checkSDcard: checkSDcard$d,
  clickHere: clickHere$d,
  confirm: confirm$f,
  confirmOnDevice: confirmOnDevice$d,
  connectKeystore: connectKeystore$7,
  darkmode: darkmode$7,
  device: device$d,
  deviceLock: deviceLock$d,
  deviceSettings: deviceSettings$d,
  deviceTampered: deviceTampered$d,
  dialog: dialog$e,
  error: error$9,
  fiat: fiat$f,
  footer: footer$f,
  generic: generic$9,
  genericError: genericError$d,
  goal: goal$d,
  guide: guide$e,
  headerssync: headerssync$d,
  hiddenWallet: hiddenWallet$d,
  initialize: initialize$d,
  invalidFormat: invalidFormat$d,
  language: language$e,
  legacyhiddenwallet: legacyhiddenwallet$d,
  loading: loading$d,
  manageAccounts: manageAccounts$7,
  mobile: mobile$8,
  newSettings: newSettings$6,
  note: note$9,
  notification: notification$d,
  pairing: pairing$d,
  passphrase: passphrase$7,
  password: password$d,
  random: random$e,
  receive: receive$f,
  reset: reset$d,
  securityInformation: securityInformation$d,
  seed: seed$d,
  seedRestore: seedRestore$d,
  send: send$f,
  settings: settings$e,
  setup: setup$d,
  sidebar: sidebar$e,
  success: success$k,
  transaction: transaction$e,
  transactions: transactions$d,
  unknownError: unknownError$d,
  unlock: unlock$d,
  upgradeFirmware: upgradeFirmware$e,
  walletConnect: walletConnect$8,
  warning: warning$j,
  welcome: welcome$d
};
const account$c = {
  disconnect: " .   ... ",
  "export": "",
  exportTransactions: "        CSV",
  fatalError: " .",
  incoming: "",
  initializing: "    ...",
  maybeProxyError: "- . ,   - ,    -  .",
  reconnecting: " ,    ...",
  syncedAddressesCount: " {{count}} "
};
const accountInfo$c = {
  address: "",
  buyCTA: {
    buy: " {{unit}}",
    buyCrypto: " ",
    information: {
      looksEmpty: ",   ",
      start: "         BitBoxApp."
    }
  },
  extendedPublicKey: " Public Key",
  label: "   ",
  scriptType: " ",
  title: "   ",
  verify: "  ",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH   ",
    p2tr: "  Taproot",
    p2wpkh: "  Native Segwit",
    "p2wpkh-p2sh": " Segwit   "
  },
  xpubTypeInfo: " {{scriptType}}    ({{current}}  {{numberOfXPubs}})"
};
const accountSummary$c = {
  availableBalance: " ",
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: " ",
  name: "  ",
  noAccount: "   .",
  subtotalWithCoinName: " ({{coinName}})",
  title: "  \n",
  total: "",
  transactionHistory: " "
};
const addAccount$d = {
  chooseName: {
    nextButton: " ",
    step: " ",
    title: "  "
  },
  selectCoin: {
    nextButton: "",
    step: " ",
    title: " "
  },
  success: {
    message: "<strong>{{accountName}}</strong>   ",
    nextButton: "",
    step: "",
    title: " "
  },
  title: "  "
};
const aopp$6 = {
  addressRequest: "{{host}}   ",
  addressRequestWithLogo: "  ",
  banner: "  ",
  errorTitle: "   ",
  labelAddress: "",
  labelMessage: "",
  reverifyInfoText: " ",
  signing: " ,    BitBox02",
  success: {
    message: "  {{host}}",
    title: "  "
  },
  syncing: " , , .",
  title: " "
};
const app$c = {
  upgrade: "    !   {{current}}  {{version}}."
};
const backup$c = {
  check: {
    checking: "   ...",
    confirmTitle: "  ",
    notOK: "     . ",
    ok: "    .",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "   :",
    title: "  "
  },
  create: {
    alreadyExists: "     .    ?",
    fail: "    !",
    info: "      .",
    name: {
      label: "  ",
      placeholder: "   "
    },
    password: {
      label: " ",
      placeholder: "   "
    },
    title: "  ",
    verificationFailed: "     .    .    ,    ."
  },
  description: " <strong>  </strong>",
  insert: "   microSD    .",
  insertButton: "    microSD",
  list: "      microSD",
  noBackups: "   microSD   .",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "  microSD  ",
      general: "   "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "    ...",
    selectedBackup: "<strong>{{backupName}}</strong>   {{createdDateTime}} ",
    title: "",
    understand: " ,       "
  },
  showMnemonic: {
    description: "   24  ,      .    .\n\n<strong>        .</strong>\n\n<strong>   .</strong>\n\n<strong>     .</strong>\n\n       .",
    title: "   "
  },
  title: "  "
};
const bb02Bootloader$c = {
  abort: "  -  ",
  abort_noUpgrade: " ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "      "
  },
  flipscreen: " ",
  orientation: "    ?",
  success: "  !   {{rebootSeconds}}  ...",
  success_install: "  !   {{rebootSeconds}} ..."
};
const bitbox$c = {
  error: {
    e10000: "  .",
    e10001: "    ",
    e102: "     4 .",
    e112: "         ."
  }
};
const bitbox02Interact$c = {
  confirmDate: "      BitBox02",
  confirmDateText: "        .",
  confirmName: "     BitBox02",
  followInstructions: ",      BitBox02.",
  followInstructionsMnemonic: ",      BitBox02,       ",
  followInstructionsMnemonicTitle: "    ( )"
};
const bitbox02Settings$c = {
  deviceName: {
    current: "  ",
    input: "  BitBox02",
    placeholder: "  ",
    title: "  BitBox02"
  },
  gotoStartupSettings: {
    description: "   BitBox02     ",
    title: "   "
  }
};
const bitbox02Wizard$c = {
  attestationFailed: "    .       ,     . ,      . ,   support@bitbox.swiss     ",
  backup: {
    point1: "     microSD",
    point2: "    ",
    restoreText: ",    !",
    text1: ",   BitBox02     .        . ,    microSD   BitBox02,  .",
    text2: ",      ,    .",
    text3: "      microSD     <strong> </strong>.   microSD   .        ,   BitBox02.",
    userConfirmation1: "       .",
    userConfirmation2: "     . ,    ,    .",
    userConfirmation3: "      BitBox02,      -   .",
    userConfirmation4: "         BitBox02,    .",
    userConfirmation5: "       microSD       , ,     ,  BitBox02."
  },
  create: {
    button: "   ",
    info: "  ,        BitBox: ",
    inputTitle: " ",
    point1: "  ",
    point2: "    ",
    point3: "  ",
    text: ",    !"
  },
  createBackupFailed: "    .   .",
  initialize: {
    passwordText: "      .      BitBox     .",
    passwordTitle: "    BitBox",
    text: " BitBox02   !     .             . <strong>,    BitBox02    microSD</strong>",
    tip: "  ,       .",
    title: "  BitBox"
  },
  insertSDCard: "<strong>,   BitBox02   microSD.</strong>",
  noPasswordMatch: "  ,   .",
  pairing: {
    failed: " . ,   BitBox02 .",
    paired: "    ,   .   ,   ,   .",
    title: "  ",
    unpaired: " BitBox02  . ,     ,     .   ,      BitBox02     ,  ."
  },
  restoreFromMnemonic: {
    failed: "   .   ."
  },
  stepBackup: {
    beforeProceed: "  ,      :",
    createBackup: "       microSD."
  },
  stepBackupSuccess: {
    fundsSafe: "    ,  :",
    title: "  !"
  },
  stepConnected: {
    unlock: "  BitBox02  ."
  },
  stepCreate: {
    description: "          ",
    nameLabel: " BitBox02",
    namePlaceholder: " BitBox02",
    title: "  BitBox02",
    toastMicroSD: ",   microSD   BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "  microSD  BitBox02      .",
    success: "    "
  },
  stepInsertSD: {
    insertSDCard: " ,   microSD  BitBox02.",
    insertSDcardTitle: "  microSD"
  },
  stepPassword: {
    title: "  BitBox02",
    useControls: "     BitBox02,   ."
  },
  stepUninitialized: {
    create: "    BitBox02.",
    restore: "       .",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "    ",
    title: "  BitBox02"
  },
  success: {
    text: "!  BitBox02    .\n\n     ,    BitBoxApp, ,    ,        .",
    title: "   !"
  }
};
const blink$c = {
  button: ""
};
const bootloader$c = {
  button: " ",
  button_install: " ",
  progress: ": {{progress}}%",
  progress_install: ": {{progress}}%",
  success: " !     .       ."
};
const button$h = {
  abort: "",
  back: "",
  buy: "",
  changepin: "  ",
  check: "  ",
  "continue": "",
  copy: "",
  create: "",
  dismiss: "",
  done: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
};
const buy$8 = {
  info: {
    "continue": "  ",
    crypto: "",
    disclaimer: {
      intro: [
        "   MoonPay,      {{name}}   BitBoxApp.    ",
        "MoonPay -  ,       {{name}}    160+ "
      ],
      payment: {
        details: "    {{name}}  MoonPay   .           ,    -    .    ,      .    4 USD/EUR  ",
        footnote: " ,    MoonPay    ,   BitBoxApp,      .",
        table: {
          "1_description": "  ,    3-  ",
          "1_method": "  (SEPA)",
          "2_description": "  ,    ",
          "2_method": "   ",
          description: "",
          fee: "",
          method: ""
        },
        title: "   "
      },
      privacyPolicy: "  MoonPay",
      protection: {
        description: " BitBoxApp       {{name}},      . MoonPay       .     ,    ",
        title: " "
      },
      security: {
        description: " {{name}}  MoonPay,    .         BitBox02     ,      BitBoxApp",
        link: "  ",
        title: " "
      },
      title: "        {{name}}"
    },
    next: "",
    selectLabel: " ",
    selectPlaceholder: " ",
    skip: "  ",
    title: " {{name}}"
  },
  title: " {{name}}"
};
const changePin$c = {
  newTitle: "  ",
  oldLabel: "  "
};
const chart$8 = {
  dataMissing: "    . , .",
  dataUpdating: " ",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
};
const checkSDcard$c = "   microSD";
const clickHere$c = " .";
const confirm$e = {
  abortInfo: ", ",
  abortInfoRedText: " ",
  approveInfo: " 4 , ",
  approveInfoGreenText: " ",
  info: "    BitBox. ",
  infoWhenPaired: "    ,    BitBox"
};
const confirmOnDevice$c = ",    .";
const device$c = {
  appUpradeRequired: " BitBox     .     ."
};
const deviceLock$c = {
  button: "   (2FA)",
  condition1: "    ?",
  condition2: "    ?",
  condition3: "        .           (2FA)!",
  confirm: " 2FA",
  title: "   (2FA)"
};
const deviceSettings$c = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "     ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": " ",
      label: " Micro SD",
      "true": ""
    },
    securechip: " ",
    title: " "
  },
  loading: "    ...",
  pairing: {
    lock: {
      "false": "",
      label: "  (2FA)",
      "true": ""
    },
    mobile: {
      "false": "",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: " "
  }
};
const deviceTampered$c = "  BitBox    ?   ,         . Shift             .";
const dialog$d = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
};
const error$8 = {
  accountAlreadyExists: "  ",
  accountLimitReached: "  .       ",
  aoppCallback: "      {{host}}",
  aoppInvalidRequest: " ",
  aoppNoAccounts: "  ",
  aoppSigningAborted: "    ",
  aoppUnknown: "  ",
  aoppUnsupportedAsset: "  ",
  aoppUnsupportedFormat: "  ,    .",
  aoppUnsupportedKeystore: "        ",
  aoppVersion: " "
};
const fiat$e = {
  "default": "",
  setDefault: " {{code}} ",
  title: ""
};
const footer$e = {
  appVersion: " :"
};
const generic$8 = {
  enabled_false: "",
  enabled_true: ""
};
const genericError$c = " .    - ,  .";
const goal$c = {
  buttons: {
    create: "  ",
    restore: "  "
  },
  paragraph: "    :",
  step: {
    "1": {
      title: "  "
    },
    "2": {
      description: "  ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$d = {
  accountDescription: {
    text: "    .      .       .  ,        .",
    title: "  ?"
  },
  accountFiat: {
    text: ",      ,   .        .",
    title: "      ?"
  },
  accountIncomingBalance: {
    text: ",    ,    ,     .",
    title: "  ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: ' xpub     "": "Native Segwit (bech32)", "Wrapped Segwit" or Taproot (  Bitcoin).   ,  {{coinName}}.  BitBoxApp  ,       .       xpub ,      xpub .\n\n     ,    (Native Segwit),     xpub  "bech32". ,      "Wrapped Segwit"  Taproot ,        "Wrapped Segwit"  Taproot ',
      title: "   xpub ?"
    },
    privacy: {
      text: "      (xpub)    ,       .  xpub       .\n\n   - xpub ,    ,           .      xpub          .",
      title: "    xpub   ?"
    },
    verify: {
      text: ",     xpub .  -       xpub ,    ,    .       ,  ,   xpub   .           !",
      title: "    xpub   ?"
    },
    xpub: {
      text: "   (xpub) -   ,        .\n\n         ,    ,   Electrum  Sentinel.        , ,     xpub  ,    ,     .\n\n ,        Taproot xpubs ",
      title: "    ?"
    }
  },
  accountRates: {
    text: "       CoinGecko.",
    title: "  ?"
  },
  accountReload: {
    text: "     .",
    title: "     ?"
  },
  accountSendDisabled: {
    text: "  ,     .",
    title: "     {{unit}}?"
  },
  accountSummaryAmount: {
    text: "     .       coingecko.com.\n\n.     MyEtherWallet     BitBoxApp    .",
    title: "   ?"
  },
  accountSummaryDescription: {
    text: "      .          .",
    title: "    ?"
  },
  accountTransactionAttributesBTC: {
    text: " :      .   ,      .\n:            .\n:   Segwit,         .    Segwit   ,    -   .   ,        .",
    title: "  ,   "
  },
  accountTransactionAttributesGeneric: {
    text: ": ,    ,   .    ,       - ,       .   ,   ,       .       3-6 .\n :   ,      .\n :             ,   .   ,   .",
    title: " ,    ?"
  },
  accountTransactionConfirmation: {
    text: "          .",
    title: "   ?"
  },
  accountTransactionLabel: {
    text: " ,       .",
    title: "     ?"
  },
  accountTransactionTime: {
    text: ",      .",
    title: "  ?"
  },
  accounts: {
    howManyAccounts: {
      text: "      ",
      title: "    ?"
    },
    howtoAddTokens: {
      text: ',   ERC20,    Ethereum.      ,   " ",     Ethereum      .',
      title: "    ?"
    },
    moveFunds: {
      text: ".     ,         .",
      title: "      ?"
    },
    recoverAccounts: {
      text: ". BitBoxApp  ,   ,     -.",
      title: "         ?"
    },
    whatAreAccounts: {
      text: "      .   ,      ",
      title: "  ?"
    },
    whyIsThisUseful: {
      text: '             ,    .     "   (xpub)"   ,       .         . ,          ',
      title: "  ?"
    }
  },
  appendix: {
    link: "  !",
    text: " ?"
  },
  backups: {
    check: {
      text: "    ,       ,    .        .",
      title: "    ?"
    },
    encrypt: {
      text: ",        .",
      title: "     ?"
    },
    howOften: {
      text: "       .           micro SD   ,        SD-    .\n        .            ,    .",
      title: "      ?"
    },
    whatIsABackup: {
      text: "     micro SD.         .",
      title: "   ?"
    }
  },
  backupsBB02: {
    check: {
      text: "    ,       ,    .",
      title: "    ?"
    },
    encrypt: {
      text: ".   microSD   ,          .       ,            .",
      title: "     ?"
    },
    whatIsABackup: {
      text: "     micro SD.",
      title: "   ?"
    }
  },
  bitbox: {
    "2FA": {
      text: "  2FA ,         ,  ,   .       ,      BitBox    .             ,    .\n\n         ,     2FA.  ,  micro SD     .    ,  BitBox,   .",
      title: "    (2FA)?"
    },
    disable2FA: {
      text: "  2FA,    BitBox,        . ,        microSD          .    .          .   ,     ,      ,      .",
      title: "    (2FA)?"
    },
    ejectBitbox: {
      text: "   BitBox   .",
      title: "    BitBox?"
    },
    ejectSD: {
      text: "    microSD  BitBox   ,           .",
      title: "     microSD?"
    },
    hiddenWallet: {
      text: "      ,        ,      .         ,    ,      .",
      title: "   ?"
    },
    legacyHiddenWallet: {
      text: "    (,  BitBox      ,    2FA ),    Bitbox        .",
      title: "      ?"
    },
    pairing: {
      text: "      iOS  Android   QR-,          .       .",
      title: "    "
    }
  },
  cointracking: {
    text: '  ""    ,       CSV.     ,   CSV- BitBox   ,       ( )     ',
    title: "        ?"
  },
  receive: {
    address: {
      text: "    ,     .  ,      .",
      title: "    ?"
    },
    addressChange: {
      text: "     ,        .     20  .",
      title: "  ?"
    },
    addressFormats: {
      text: "    - Native Segwit.        /         .        Taproot (   (Btc)),      , , ,        .         Native Segwit (  ),          Wrapped Segwit,        / ",
      title: "      ?"
    },
    howVerify: {
      text: "   BitBox01,   BitBox         .  ,      .\n   BitBox02,            .",
      title: "     ?"
    },
    plugout: {
      text: ",  ,        BitBox,      BitBox .     BitBox",
      title: "    BitBox     ?"
    },
    why20: {
      text: "     ,    ,  ,      .        ,      .    ,    20        .     20    -,     .",
      title: "  20 ?"
    },
    whyMany: {
      text: "             .    ,        .     20  .       .       .",
      title: "   ?"
    },
    whyVerify: {
      text: "            .       .    BitBox01,          ,         QR-.    BitBox02,       BitBox02.",
      title: "    ?"
    }
  },
  send: {
    change: {
      text: "      Taproot,        UTXO (  )  Taproot.  ,    ,      Taproot,    UTXOs     Taproot UTXO.          Native Segwit",
      title: "   ?"
    },
    fee: {
      text: "     ,     .       Bitcoin Core    .\n: 24  ( 4   , 1   Litecoin)\n: 12  ( 2   , 30   Litecoin)\n: 6  ( 1   , 15   Litecoin)\n: 2  ( 20   , 5   Litecoin)\n(        (2,5   Litecoin)           .)",
      title: "   ?"
    },
    plugout: {
      text: ",  ,    ,      BitBox .     BitBox",
      title: "     BitBox     ?"
    },
    priority: {
      text: "  ,    ,       .",
      title: "   ?"
    },
    revert: {
      text: "       (    ),      .      ( )!\n  ,          ,       .",
      title: "   ?"
    },
    whyFee: {
      text: " ,    .   ,      blockchain,    .\n     .             (     ),    ,   ,    .                 ,   .",
      title: "   ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "        ,       (,   Wi-Fi),     .\n   ,    Electrum   TLS   .\n         ,   Tor.     TLS  .",
      title: "   , TCP, TLS  Tor?"
    },
    instructions: {
      link: {
        text: "    "
      },
      text: "   ",
      title: "  BitBoxApp     ()?"
    },
    options: {
      text: "     ,     ,    Bitcoin Core.\n    BitBoxApp   , ,     Electrum.   ,       .\n   Electrs,   Electrum (EPS)  Bitcoin Wallet Tracker (BTW).",
      title: "     ?"
    },
    tor: {
      text: "Tor   .        ,             .\n        Tor, ,  Tor    ,    Tor Proxy   BitBoxApp.\n        Tor:\n1. Tor Browser:    Tor Browser.   BitBoxApp    Tor,   9150   - Tor.\n2.   Tor:   Tor,      .  BitBoxApp  ,   9050   - Tor.",
      title: "  Tor, - Tor      ?"
    },
    what: {
      text: "            Shift.",
      title: " ?"
    },
    why: {
      text: "     ,        .\n-,  ,      ,  BitBoxApp           ;          .\n-,    ,       ,     .",
      title: "    ?"
    }
  },
  settings: {
    servers: {
      text: "     Shift Crypto   ,         .\n ,       CoinGecko. (  ,    .)",
      title: "     ?"
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "         ,   .",
      title: " ,     ?"
    },
    reset: {
      text: "    15 .       .",
      title: "  ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "      . ,    .     , ,      .\n\nBitBox01     . ,   BitBoxApp       BitBox01",
      title: "  BitBox01  "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox   -:",
      title: "    ?"
    },
    internet: {
      text: ",   ,      ,  -.",
      title: "       ?"
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "        BitBox      .",
      title: "   .  ?"
    },
    useWithoutDevice: {
      text: " ,   .",
      title: "      ?"
    },
    welcome: {
      text: "    ,  Shift Crypto  .  -    -,     ,    . ,  ,   .",
      title: "    BitBoxApp!"
    }
  }
};
const headerssync$c = {
  blocksSynced: "{{blocks}}  "
};
const hiddenWallet$c = {
  info1HTML: "            <strong>  </strong>     .",
  info2HTML: "     ,        .       <strong>  </strong>  ,       .",
  passwordLabel: "  ",
  passwordPlaceholder: "   ",
  pinLabel: "  ",
  pinRepeatLabel: "   ",
  pinRepeatPlaceholder: "   ",
  success: "   .  BitBox,   ."
};
const initialize$c = {
  create: "  ",
  creating: "   ...",
  error: {
    e102: "      4 ."
  },
  info: {
    description1: "  .       BitBox.",
    description2: "     .     .",
    description3: "    ,            .",
    subtitle: "     ",
    title: " "
  },
  input: {
    label: " ",
    labelRepeat: "  ",
    placeholderRepeat: "  "
  }
};
const invalidFormat$c = " ";
const language$d = {
  title: " "
};
const legacyhiddenwallet$c = {
  disable: "    ",
  enable: "    ",
  successDisable: "   .",
  successEnable: "   .   BitBox     ,      ."
};
const loading$c = " ...";
const manageAccounts$6 = {
  editAccount: "",
  editAccountNameTitle: "  ",
  noAccounts: "   ",
  settings: {
    hideTokens: " ",
    showTokens: "  ({{activeTokenCount}})"
  },
  settingsButtonDescription: "  / ",
  title: " "
};
const mobile$7 = {
  usingMobileDataWarning: "  :               . ,   Wi-Fi,     .    ,     ."
};
const note$8 = {
  input: {
    description: "()",
    placeholder: "  ..."
  },
  title: ""
};
const notification$c = {
  newTxs_one: "  : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
};
const pairing$c = {
  aborted: {
    text: "     .",
    title: ""
  },
  button: "   ",
  confirm: " ,     BitBox?  ,         .",
  connectOnly: {
    button: "  ",
    title: "     ,        ,"
  },
  error: {
    text: " . ,  .",
    title: ""
  },
  pullFailed: {
    text: "         . ,   ,     ",
    title: " "
  },
  reconnectOnly: {
    button: "   "
  },
  scanningFailed: {
    text: "      . ,   ",
    title: " "
  },
  start: {
    hideAppQRCode: " QR ",
    revealAppQRCode: " QR ",
    step1: "     ,    QR-  Apple App Store  Google Play Store    ,    .",
    step2: "     ,       Digital Bitbox 2FA     iOS  Android:"
  },
  started: {
    text: "     .",
    title: ""
  },
  success: {
    text: ",     BitBox   !",
    title: ""
  },
  timeout: {
    text: "     .  ,        .",
    title: "-"
  },
  title: " "
};
const passphrase$6 = {
  considerations: {
    button: "   ",
    message: "           ( microSD  seed   24 ).   -      ,          .\n\n  ,    <strong>  ,     </strong>       ,  ,   BitBox02   .        ,          ().\n\n      ,      ,    .  ,  -    ,      !",
    title: "   "
  },
  disable: "  ",
  disableInfo: {
    button: "",
    message: "              BitBox02.      .\n\n        -     ,        ,      BitBox02    .\n\n         ,              BitBox02.\n\n<strong>:</strong>        ,   "
  },
  enable: "  ",
  error: {
    e104: "     "
  },
  how: {
    button: "  ",
    message: "    ,  ,    .       ,    .   ,  <strong>    ,   </strong>.          ,  .           .\n\n  BitBox02 ,  ,     .         .\n\n          .    ,    ,    ",
    title: "  "
  },
  intro: {
    message: "       .\n ,   ",
    title: "  "
  },
  progressDisable: {
    message: "   BitBox,    <strong></strong>   ",
    title: "  "
  },
  progressEnable: {
    message: "   BitBox,    <strong></strong>   ",
    title: "  "
  },
  successDisabled: {
    message: "   <strong> </strong>!\n      ",
    messageEnd: ",  BitBox02 ",
    title: "  "
  },
  successEnabled: {
    message: "   <strong> </strong>!\n       ",
    messageEnd: ",   BitBox02 ",
    tips: "",
    tipsList: [
      "          .      BitBox02       .      ,       ",
      "         ,    ,      ,   .       "
    ],
    title: "  "
  },
  summary: {
    button: "  ",
    title: "",
    understand: " ,         ",
    understandList: [
      "  -    ,    ",
      "         ",
      "   ,   <strong>  ,    </strong>",
      "     ,         "
    ]
  },
  what: {
    button: ",   ",
    message: "  ()     ,    seed  ( ).        BitBox02      microSD  24 . ,      seed ,        .\n\n  -  <strong> </strong>,   seed .          seed  +   ( ).      ,  .     : , ,      .             , .. seed  +   .\n\n     BIP39 -  ,      ,      ",
    title: "   ?"
  },
  why: {
    button: "   ",
    message: "BitBox02   seed      ,    ( microSD  24 )     .      !\n\n      ,    seed ,    , <strong>    </strong>.     ,   -     ( seed ),            .\n\n ,          ,         ",
    title: "   ?"
  }
};
const password$c = {
  show: " {{label}}",
  warning: {
    caps: ": Caps Lock () ",
    paste: "    ,   {{label}}"
  }
};
const random$d = {
  button: "  ",
  description: " BitBox   {{bits}}-  :"
};
const receive$e = {
  changeScriptType: "  ",
  label: " ",
  onlyThisCoin: {
    description: "   ,    .     ,    .",
    warning: ",    {{coinName}}   ."
  },
  scriptType: {
    p2tr: "Taproot ( )",
    p2wpkh: "Native Segwit ( )",
    "p2wpkh-p2sh": "Wrapped Segwit ( )"
  },
  showFull: "      ",
  taprootWarning: ": Taproot -    ,      . ,     Taproot,        ,    .           Taproot",
  title: " {{accountName}}",
  verify: "  ",
  verifyBitBox01: "    ",
  verifyBitBox02: "   BitBox02",
  verifyInstruction: ",           .",
  warning: {
    secureOutput: ',   BitBox   ,     .    " "   '
  }
};
const reset$c = {
  description: "     .       !",
  notReset: "   .",
  title: "    ",
  understand: "         ",
  understandBB02: "     "
};
const securityInformation$c = {
  create: {
    description1: "       ,         .",
    description2: "     .",
    description3: " <strong>device password</strong>,  ,    BitBox     .",
    description4: "  <strong>recovery password</strong>   .       .",
    description5: "         micro SD.      ,    ,  <strong> </strong>.",
    title: "  "
  },
  restore: {
    description1: "     micro SD,       ",
    description2: "       .",
    description3: "     .       .     ,      ,    .",
    title: "  "
  }
};
const seed$c = {
  agreements: {
    "funds-access": "       ,     ",
    "password-change": "      .",
    "password-required": "        "
  },
  create: " ",
  creating: " ",
  description: " :",
  error: {
    e102: "       4 .",
    e200: "    micro SD   BitBox,        "
  },
  info: {
    button: "  ",
    description1: "  micro SD  BitBox",
    description2: "         ",
    description3: "    micro SD      (seed ) -           BitBox.",
    description4: "       ,    .",
    title: "  "
  },
  password: {
    label: " ",
    repeatPlaceholder: "  "
  },
  walletName: {
    label: " "
  }
};
const seedRestore$c = {
  error: {
    e200: "        micro SD."
  },
  info: {
    description1: "  micro SD  BitBox   ,",
    description2: "     ,",
    description3: "  ",
    description4: "  ,      .",
    title: "     "
  }
};
const send$e = {
  abort: "  .",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: "",
  coincontrol: {
    address: "",
    outpoint: "Outpoint",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    feeTooLow: "  ",
    feesNotAvailable: "   ",
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: ""
  },
  feeTarget: {
    customLabel: " ",
    customLabel_eth: " gas ( eth)",
    description: {
      economy: "4  (24 )",
      economy_eth: "30   ",
      economy_ltc: "1  (24 )",
      high: "20  (2 )",
      high_eth: "30   ",
      high_ltc: "5  (2 )",
      low: "2  (12 )",
      low_eth: "5   ",
      low_ltc: "30  (12 )",
      normal: "1  (6 )",
      normal_eth: "2   ",
      normal_ltc: "15  (6 )"
    },
    estimate: "   :",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "    ..."
  },
  maximum: " ",
  maximumSelectedCoins: "  ",
  priority: "",
  scanQR: " QR ",
  signprogress: {
    description: "    .    ,    {{steps}} a.",
    label: ""
  },
  success: "    .",
  title: " {{accountName}}",
  toggleCoinControl: "  ",
  transactionDetails: " "
};
const settings$d = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: "    {{host}}",
    checking: "",
    "download-cert": " ",
    "remove-server": "",
    removeConfirm: " {{server}}?",
    reset: "   ",
    resetConfirm: "       ?",
    servers: "",
    step1: "1",
    "step1-text": " .",
    step2: "2",
    "step2-text": "    . ,      .",
    "step2-text-tcp": "    ,     TLS.",
    step3: "3",
    "step3-text": "    .",
    step4: "4",
    "step4-text": " .      ,       .",
    "title-btc": " Bitcoin Electrum",
    "title-ltc": " Litecoin Electrum",
    "title-tbtc": " Bitcoin Testnet Electrum ",
    "title-tltc": " Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "  ",
    electrum: {
      title: "   "
    },
    fee: "   ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: " - "
  },
  header: {
    home: ""
  },
  restart: " BitBoxApp,     .",
  services: {
    title: ""
  },
  success: ",    BitBox ,     .",
  title: ""
};
const setup$c = " ";
const sidebar$d = {
  buy: " ",
  device: " ",
  leave: "",
  settings: ""
};
const success$j = {
  create: {
    info1: "         microSD.       .",
    info2: "    ,     BitBox.",
    info3: "       ,         .",
    summary: "   ,   ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "      .",
    title: ""
  }
};
const transaction$d = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: " ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  note: {
    edit: " ",
    save: " "
  },
  pending: " ",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: " "
  },
  tx: {
    received: "",
    sent: ""
  },
  vsize: " ",
  weight: ""
};
const transactions$c = {
  placeholder: "   ."
};
const unknownError$c = "  : {{errorMessage}}";
const unlock$c = {
  description: "   ,   .",
  error: {
    e109_normal: "  . {{remainingAttempts}}      .",
    e109_touch: "$t(unlock.error.e109_normal)        .",
    e113: "-     ,            4 ."
  },
  input: {
    label: " ",
    placeholder: "   ."
  },
  unlocking: " ..."
};
const upgradeFirmware$d = {
  button: " ",
  description: "     {{currentVersion}}  {{newVersion}}?",
  label: "  BitBox   .",
  locked: "   {{currentVersion}}  {{newVersion}},   .",
  title: " ",
  unlocked: " .  , :",
  unlocked1: "    Bitbox ",
  unlocked2: " ,   BitBox   ",
  unlocked3: "  ,   "
};
const warning$i = {
  receivePairing: ",  BitBox,    .       ",
  sdcard: "  micro SD   BitBox,        ",
  sendPairing: " BitBox,   e  .       "
};
const welcome$c = {
  getStarted: "       BitBox02",
  insertBitBox02: "  BitBox02, ,  .",
  insertDevice: "     ",
  title: " "
};
const appTranslationsRU = {
  account: account$c,
  accountInfo: accountInfo$c,
  accountSummary: accountSummary$c,
  addAccount: addAccount$d,
  aopp: aopp$6,
  app: app$c,
  backup: backup$c,
  bb02Bootloader: bb02Bootloader$c,
  bitbox: bitbox$c,
  bitbox02Interact: bitbox02Interact$c,
  bitbox02Settings: bitbox02Settings$c,
  bitbox02Wizard: bitbox02Wizard$c,
  blink: blink$c,
  bootloader: bootloader$c,
  button: button$h,
  buy: buy$8,
  changePin: changePin$c,
  chart: chart$8,
  checkSDcard: checkSDcard$c,
  clickHere: clickHere$c,
  confirm: confirm$e,
  confirmOnDevice: confirmOnDevice$c,
  device: device$c,
  deviceLock: deviceLock$c,
  deviceSettings: deviceSettings$c,
  deviceTampered: deviceTampered$c,
  dialog: dialog$d,
  error: error$8,
  fiat: fiat$e,
  footer: footer$e,
  generic: generic$8,
  genericError: genericError$c,
  goal: goal$c,
  guide: guide$d,
  headerssync: headerssync$c,
  hiddenWallet: hiddenWallet$c,
  initialize: initialize$c,
  invalidFormat: invalidFormat$c,
  language: language$d,
  legacyhiddenwallet: legacyhiddenwallet$c,
  loading: loading$c,
  manageAccounts: manageAccounts$6,
  mobile: mobile$7,
  note: note$8,
  notification: notification$c,
  pairing: pairing$c,
  passphrase: passphrase$6,
  password: password$c,
  random: random$d,
  receive: receive$e,
  reset: reset$c,
  securityInformation: securityInformation$c,
  seed: seed$c,
  seedRestore: seedRestore$c,
  send: send$e,
  settings: settings$d,
  setup: setup$c,
  sidebar: sidebar$d,
  success: success$j,
  transaction: transaction$d,
  transactions: transactions$c,
  unknownError: unknownError$c,
  unlock: unlock$c,
  upgradeFirmware: upgradeFirmware$d,
  warning: warning$i,
  welcome: welcome$c
};
const account$b = {
  disconnect: "Sambungan hilang. Mencuba lagi...",
  "export": "Eksport",
  exportTransactions: "Eksport transaksi ke folder muat turun sebagai fail CSV",
  fatalError: "Terdapat kesilapan yang tidak dijangka.",
  incoming: "Masuk",
  initializing: "Mendapatkan maklumat dari blockchain ...",
  insuranceExpired: "<strong>Akaun tidak lagi diinsuranskan</strong>\n\nPelan insurans untuk akaun ini telah diubah suai.\nSila semak halaman insurans untuk butiran.",
  insured: "Akaun yang diinsuranskan",
  maybeProxyError: "Proksi Tor diaktifkan. Pastikan proksi Tor anda berfungsi dengan baik atau matikan tetapan proksi.",
  reconnecting: "Sambungan hilang, mencuba menyambung kembali...",
  syncedAddressesCount: "{{count}} alamat telah diimbas",
  uncoveredFunds: "Anda mempunyai syiling pada alamat yang tidak diinsuranskan. Nama alamat: <strong>{{name}}</strong>, akaun yang tidak diinsuranskan: {{uncovered}}.\nKarena akaun itu diinsuranskan, hanya syiling diterima melalui <strong>Segwit asli (Native Segwit)</strong> adalah jenis alamat yang diinsuranskan. Syiling pada jenis alamat yang berbeza, walaupun ia berada pada akaun yang sama, tidak diinsuranskan.\nSila alihkan semua syiling anda daripada jenis alamat yang tidak disokong kepada jenis alamat <strong>Segwit asl (Native Segwit)i</strong>, jadi semua syiling anda pada akaun ini diinsuranskan.",
  uncoveredFundsLink: "Ikuti panduan ini tentang cara mengalihkan syiling anda.",
  warning: "Amaran!\n"
};
const accountInfo$b = {
  address: "Alamat",
  buyCTA: {
    buy: "Beli {{unit}}",
    buyCrypto: "Beli Kripto",
    information: {
      looksEmpty: "Nampaknya dompet ini kosong.",
      start: "Memulakan dengan mendepositkan beberapa syiling ke dalam dompet atau membeli terus di dalam aplikasi BitBoxApp."
    }
  },
  extendedPublicKey: "Public key lanjutan",
  label: "Maklumat akaun",
  scriptType: "Jenis skrip",
  title: "Maklumat Akaun",
  verify: "Sahkan pada peranti",
  xpubTypeChangeBtn: {
    p2pkh: "Lihat legacy P2PKH extended public key",
    p2tr: "Lihat Taproot",
    p2wpkh: "Lihat Segwit Asli",
    "p2wpkh-p2sh": "Lihat Segwit public key lanjutan yang lebih lama"
  },
  xpubTypeInfo: "Sedang memaparkan {{scriptType}} public key lanjutan ({{current}} daripada {{numberOfXPubs}})"
};
const accountSummary$b = {
  availableBalance: "Baki yang ada",
  balance: "Baki",
  exportSummary: "Eksport Ringkasan Akaun ke Folder Muat Turun sebagai Fail CSV",
  fiatBalance: "Baki Fiat",
  name: "Nama Akaun",
  noAccount: "Tiada akaun untuk dipaparkan.",
  subtotalWithCoinName: "Jumlah ({{coinName}})",
  title: "Ringkasan Akaun",
  total: "Jumlah",
  transactionHistory: "Sejarah transaksi"
};
const addAccount$c = {
  chooseName: {
    nextButton: "Tambah Akaun",
    step: "Nama akaun",
    title: "Namakan akaun anda"
  },
  selectCoin: {
    nextButton: "Seterusnya",
    step: "Pilih syiling",
    title: "Pilih mata wang kripto"
  },
  success: {
    addAnotherAccount: "Tambah akaun lain",
    message: "<strong>{{accountName}}</strong> telah ditambahkan ke akaun anda",
    nextButton: "Selesai",
    step: "Selesai",
    title: "Akaun ditambahkan"
  },
  title: "Tambah akaun"
};
const aopp$5 = {
  addressRequest: "{{host}} sedang meminta alamat penerimaan.",
  addressRequestWithLogo: "sedang meminta alamat penerima",
  banner: "Permintaan alamat sedang dijalankan. Sila sambungkan peranti anda untuk meneruskan.",
  errorTitle: "Ralat semasa permintaan alamat",
  labelAddress: "Alamat",
  labelMessage: "Mesej",
  reverifyInfoText: "Sahkan alamat",
  signing: "Untuk meneruskan, tandatangani mesej pada BitBox02 anda.",
  success: {
    message: "Teruskan {{host}}",
    title: "Alamat berjaya dihantar"
  },
  syncing: "Menyelaraskan akaun, sila tunggu.",
  title: "Permintaan alamat"
};
const app$b = {
  upgrade: "Versi baru aplikasi ini telah didapati! Sila kemaskini dari {{current}} ke {{version}}."
};
const auth$6 = {
  authButton: "Sahkan",
  title: "Sila sahkan untuk meneruskan"
};
const backup$b = {
  check: {
    checking: "Memeriksa backup...",
    confirmTitle: "Semak Backup",
    notOK: "Backup TIDAK sepadan dengan wallet.",
    ok: "Backup sepadan dengan wallet.",
    password: {
      label: "Kata laluan pemulihan",
      placeholder: "Kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    success: "Backup berjaya disahkan",
    title: "Semak Backup"
  },
  create: {
    alreadyExists: "Anda sudah mempunyai backup yang sah. Adakah anda ingin menciptanya kembali?",
    fail: "TIDAK BERJAYA membuat backup!",
    info: "Sila masukkan kata laluan pemulihan dari wallet terkini untuk pengesahan",
    name: {
      label: "Nama backup",
      placeholder: "Sila memberi nama backup"
    },
    password: {
      label: "Kata Laluan Pemulihan",
      placeholder: "Sila masukkan kata laluan pemulihan anda"
    },
    title: "Buat Backup",
    verificationFailed: "Kata laluan pemulihan TIDAK sesuai dompet terkini. Backup telah dibuat. Sila gunakan 'Semak Backup' untuk mengesahkan kembali password pemulihan anda."
  },
  description: "Pilih <strong>fail backup wallet</strong>",
  insert: "Sila masukkan kad micro SD untuk mengurus backup.",
  insertButton: "Saya telah memasukkan kad micro SD",
  list: "Telah jumpa <strong>backup berikut</strong> pada kad SD ini:",
  noBackups: "Tiada backup pada kad microSD ini.",
  restore: {
    confirmTitle: "Memulihkan Backup",
    error: {
      e200: "SD card tidak dijumpai",
      general: "Ralat memulihkan sandaran"
    },
    password: {
      label: "Kata laluan pemulihan atau kata laluan pemulihan tersembunyi",
      placeholder: "Kata laluan pemulihan",
      repeatPlaceholder: "Ulangi kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    restoring: "Memulihkan backup...",
    selectedBackup: "<strong>{{backupName}}</strong> dicipta pada {{createdDateTime}} akan dipulihkan.",
    title: "Memulihkan",
    understand: "Saya faham bahawa kata laluan pemulihan yang salah akan membuat dompet yang berbeza"
  },
  showMnemonic: {
    description: "Anda akan diberikan 24 perkataan pemulihan, yang membentuk sandaran dompet anda. Tulis mereka di atas kertas.\n\n<strong>Jangan menyimpannya secara digital atau mengambil gambar.</strong>\n\n<strong>Jangan mengucapkannya dengan lantang.</strong>\n\n<strong>Sandaran ini tidak dilindungi kata laluan.</strong>\n\nSelepas itu, anda akan diminta mengesahkan setiap perkataan.",
    title: "Tunjukkan perkataan pemulihan",
    warning: "<strong>Jangan sekali-kali berkongsi kata-kata pemulihan anda dengan sesiapa pun.</strong> Perkataan pemulihan anda memberikan akses penuh kepada dompet anda. Jika seseorang meminta anda untuk kata-kata pemulihan anda, ia adalah penipu, jangan kongsikannya!"
  },
  title: "Urus Backup"
};
const bb02Bootloader$b = {
  abort: "Jangan naik taraf - Kembali",
  abort_noUpgrade: "Bawa saya balik",
  advanced: {
    label: "Tetapan lanjutan",
    toggleShowFirmwareHash: "Tunjukkan hash firmware setiap kali pada permulaan"
  },
  flipscreen: "Putar skrin",
  orientation: "Orientasi peranti salah?",
  success: "Naik taraf berjaya! Meneruskan dalam {{rebootSeconds}} detik...",
  success_install: "Pemasangan berjaya! Meneruskan dalam {{rebootSeconds}} detik..."
};
const bitbox$b = {
  error: {
    e10000: "Kata laluan peranti terkini salah",
    e10001: "Gagal mengganti kata laluan peranti",
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e112: "Kata laluan peranti tersembunyi tidak boleh sama dengan kata laluan peranti utama."
  }
};
const bitbox02Interact$b = {
  confirmDate: "Sahkan tarikh hari ini pada BitBox02 anda.",
  confirmDateText: "Tarikh ini akan digunakan untuk membuat sandaran anda.",
  confirmName: "Sahkan nama pada BitBox02",
  confirmWords: "Tuliskan {{amount}} perkataan pemulihan daripada BitBox02 anda",
  confirmWordsText: "Selepas itu BitBox02 meminta anda mengesahkan setiap perkataan untuk mengesahkan bahawa sandaran adalah betul.",
  followInstructions: "Sila ikuti arahan pada BitBox02 anda.",
  followInstructionsMnemonic: "Ikuti arahan pada BitBox02 anda untuk memasukkan perkataan pemulihan dari sandaran dan pulihkan dompet anda.",
  followInstructionsMnemonicTitle: "Pulihkan dari perkataan pemulihan"
};
const bitbox02Settings$b = {
  deviceName: {
    current: "Nama peranti semasa",
    error: "Nama peranti tidak dapat ditetapkan",
    error_104: "Mengesahkan nama peranti telah digugurkan pada peranti.",
    input: "Nama BitBox02",
    placeholder: "Nama peranti baharu",
    title: "Tetapkan Nama BitBox02"
  },
  gotoStartupSettings: {
    description: "Ini akan but semula BitBox02 anda dan masukkan tetapan permulaan.",
    title: "Ini akan me-reboot BitBox02 anda dan masuk ke dalam tetapan permulaan semula."
  }
};
const bitbox02Wizard$b = {
  advanced: {
    button: "Pilihan lanjutan",
    outOfDate: "Perisian tegar sudah lapuk untuk ciri ini",
    seed12WordInfo: "Sila ambil perhatian bahawa bilangan perkataan tidak boleh diubah selepas mencipta dompet.",
    seed12WordLabel: "Buat 12 perkataan dan bukannya benih 24 perkataan",
    seed12WordText: "Secara lalai, BitBox02 menggunakan benih 24 perkataan. Kedua-dua panjang benih adalah selamat daripada paksaan kasar dalam amalan. Sesetengah pengguna mungkin lebih suka kemudahan benih 12 perkataan sebaliknya.",
    skipSDCardLabel: "Langkau sandaran kad microSD dan tulis perkataan pemulihan sebaliknya",
    skipSDCardText: "Anda sentiasa mempunyai pilihan untuk membuat sandaran kad microSD atau menulis perkataan pemulihan anda selepas persediaan. Ini boleh dilakukan dari tetapan.",
    title: "Pilihan sandaran lanjutan"
  },
  attestationFailed: "Pengesahan peranti gagal. BitBox anda mungkin palsu atau terkompromi. Syiling di BitBox02 mungkin berisiko hilang. Sila hubungi support@bitbox.swiss dengan segera.",
  backup: {
    point1: "Pilih backup pada kad microSD",
    point2: "Tetapkan kata laluan untuk peranti anda",
    restoreText: "Ok, mari kita pulihkan backup!",
    text1: "Hebat, kata laluan BitBox02 anda sudah ditetapkan dan wallet dibuat. Kini tiba masanya untuk membuat backup pertama anda. Sila pastikan kad microSD anda dimasukkan ke dalam BitBox02 anda dan teruskan.",
    text2: "Sila ikuti arahan pada skrin pada peranti anda untuk membuat backup.",
    text3: "Selepas backup anda dicipta, sila tarik keluar kad microSD dan simpan itu di <strong>lokasi selamat</strong>. Kandungan kad microSD tidak dilindungi kata laluan. Jangan sekali-kali memasukkannya ke peranti lain selain BitBox02 anda.",
    userConfirmation1: "Saya harus menyimpan sandaran saya di lokasi yang selamat.",
    userConfirmation2: "Sandaran saya tidak dilindungi dengan kata laluan. Siapa saja yang mempunyai akses kepadanya dapat mengakses dompet saya.",
    userConfirmation3: "Jika saya kehilangan atau merosakkan BitBox02 saya, satu-satunya cara untuk memulihkan dana saya adalah dengan memulihkan daripada sandaran saya.",
    userConfirmation4: "Jika saya kehilangan atau merusakkan kedua-dua sandaran dan BitBox02 saya, maka dana saya akan hilang.",
    userConfirmation5: "Saya sepatutnya tidak memasukkan sandaran kad microSD saya ke dalam komputer, telefon, pencetak atau sebarang peranti selain daripada BitBox02.",
    userConfirmation5mnemonic: "Saya tidak sepatutnya meletakkan perkataan pemulihan saya dalam komputer, telefon, pencetak atau mana-mana peranti selain daripada BitBox02."
  },
  create: {
    button: "Beri Nama dan Teruskan",
    info: "Inilah langkah-langkah asas yang akan anda ambil untuk menyediakan BitBox anda: ",
    inputTitle: "Nama Wallet",
    point1: "Tetapkan nama untuk peranti anda",
    point2: "Tetapkan kata laluan untuk peranti anda",
    point3: "Buat backup",
    text: "Ok, mari buat dompet baru!"
  },
  createBackupAborted: "Membuat sandaran dihentikan.",
  createBackupFailed: "Gagal membuat sandaran, cuba lagi.",
  initialize: {
    passwordText: "Sekarang mari kita tetapkan kata laluan untuk peranti anda. Gunakan kawalan pada BitBox anda untuk memasukkan dan memilih kata laluan.",
    passwordTitle: "Tetapkan kata laluan untuk BitBox anda",
    text: "Berjaya berpasangan dengan BitBox02 anda! Sekarang mari kita inisialisasi peranti anda. Mulailah dengan memilih untuk membuat wallet baru, atau untuk memulihkan wallet dari backup yang sudah ada. <strong>Sila pastikan anda mempunyai kad microSD yang sudah dimasukkan dalam BitBox02 anda</strong>",
    tip: "Sebelum meneruskan, sangat disyorkan supaya anda meneruskan di persekitaran yang selamat.",
    title: "Inisialisasi BitBox anda"
  },
  insertSDCard: "<strong>Sila pastikan anda mempunyai kad microSD yang dimasukkan ke dalam BitBox02 anda.</strong>",
  noPasswordMatch: "Kata laluan tidak sepadan, sila cuba lagi.",
  pairing: {
    failed: "Pasangan tidak berjaya disahkan. Sila tancap ulang BitBox02 anda.",
    paired: "Anda telah mengesahkan pada peranti anda bahawa kod sepadan. Jika ini betul, anda boleh meneruskan dengan mengklik butang di bawah.",
    title: "Sahkan Kod Pasangan",
    unpaired: "BitBox02 baru telah dikesan. Sila sahkan bahawa kod berikut sepadan dengan apa yang ditunjukkan pada peranti anda. Jika kod itu sepadan, sentuh di bawah tanda semak pada BitBox02 anda dan kemudian klik butang di bawah untuk meneruskan."
  },
  restoreFromMnemonic: {
    e104: "Pemulihan daripada perkataan pemulihan telah dibatalkan.",
    failed: "Pemulihan daripada perkataan pemulihan gagal, sila cuba lagi."
  },
  stepBackup: {
    beforeProceed: "Sebelum meneruskan, sila baca pertimbangan keselamatan berikut:",
    createBackup: "Anda kini akan membuat sandaran pada kad microSD anda.",
    createBackupMnemonic: "Kini, anda akan dapat menulis perkataan pemulihan."
  },
  stepBackupSuccess: {
    fundsSafe: "Untuk memastikan dana anda selamat, sila ingat perkara berikut:",
    title: "Sandaran Dipulihkan!"
  },
  stepConnected: {
    unlock: "Masukkan kata laluan BitBox02 untuk membuka kunci."
  },
  stepCreate: {
    description: "Nama ini digunakan sebagai nama peranti dan untuk sandaran.",
    nameLabel: "Nama BitBox02",
    namePlaceholder: "BitBox02 Saya",
    title: "Pilih nama BitBox02",
    toastMicroSD: "Sila masukkan kad microSD anda ke dalam BitBox02 anda yang akan digunakan untuk menyimpan sandaran dompet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Sila keluarkan kad microSD dari BitBox02 anda dan simpan di tempat yang selamat.",
    storeMnemonic: "Sila simpan perkataan pemulihan anda di lokasi yang selamat",
    success: "Anda telah berjaya membuat sandaran anda."
  },
  stepInsertSD: {
    insertSDCard: "Sila masukkan kad mikroSD ke dalam BitBox02 anda untuk meneruskan.",
    insertSDcardTitle: "Masukkan kad mikroSD"
  },
  stepPassword: {
    e104: "Menetapkan kata laluan telah dibatalkan.",
    title: "Tetapkan kata laluan BitBox02",
    useControls: "Gunakan kawalan pada BitBox02 anda untuk menetapkan kata laluan."
  },
  stepUninitialized: {
    create: "Saya mahu menyiapkan BitBox02 baru",
    restore: "Saya mahu memulihkan dompet saya daripada sandaran.",
    restoreMicroSD: "Pulihkan daripada kad microSD",
    restoreMnemonic: "Pulihkan daripada perkataan pemulihan",
    title: "Sediakan BitBox02 anda"
  },
  success: {
    text: "Hooray! BitBox02 anda kini siap untuk digunakan.\n\nUntuk maklumat lanjut mengenai cara menggunakan aplikasi BitBox, sila gunakan panduan dalam aplikasi dengan mengklik tanda tanya di sudut kanan atas.",
    title: "Anda sudah bersedia untuk pergi!"
  }
};
const bitsurance$5 = {
  dashboard: {
    active: "Polisi insurans aktif",
    button: "Insuranskan akaun baharu",
    canceled: "Dibatalkan",
    coverage: "Liputan maksimum",
    inactive: "Tidak aktif",
    processing: "Memproses",
    refused: "enggan",
    supportLink: "Urus kontrak",
    title: "Akaun yang diinsuranskan",
    waitpayment: "Menunggu pembayaran"
  },
  detect: {
    button: "Semak insurans sedia ada",
    insured: "Akaun yang diinsuranskan dikesan:",
    notInsured: "Tiada akaun yang diinsuranskan dikesan. Jika anda pasti anda mempunyai akaun yang diinsuranskan, sila pastikan anda mempunyai dompet yang betul disambungkan.",
    text: "Jika anda sudah mendaftar dengan Bitsurance, BitBoxApp boleh menyegerakkan perlindungan insurans sedia ada anda secara automatik.",
    title: "Sudah diinsuranskan?"
  },
  insure: {
    button: "Semak ketersediaan dan harga",
    faq: "Baca lebih lanjut mengenai Soalan Lazim Bitsurance",
    listItem1: "rompakan",
    listItem2: "Peras ugut (cth., serangan sepana $5)",
    listItem3: "Kemusnahan akibat kebakaran, air atau bencana alam",
    month: "bulan",
    text: "Insuranskan BitBox02 anda dan bitcoin bernilai sehingga 100,000 terhadap",
    text2: "Pelan insurans bermula pada 30/tahun (2.50/bulan). Anda boleh mengetahui lebih lanjut tentang Bitsurance dan tawaran insurans tepat mereka di",
    text3: "Kini tersedia di Jerman, dengan lebih banyak wilayah untuk diikuti.",
    title: "Bermula"
  },
  intro: {
    link: "Laman web Bitsurance",
    text1: "BitBox berfungsi dengan Bitsurance untuk menambah lapisan perlindungan tambahan untuk bitcoin anda. Walaupun BitBox02 memastikan dana anda selamat, Bitsurance melindungi ancaman di rumah yang tidak boleh dikurangkan dengan teknologi sahaja, seperti pecah rumah, peras ugut atau pemusnahan dompet perkakasan itu sendiri."
  },
  terms: {
    link: "Dasar Privasi Bitsurance",
    text1: "Bitsurance ialah perkhidmatan pihak ketiga yang bebas. Untuk pertanyaan mengenai tawaran dan tuntutan insurans mereka, sila hubungi Bitsurance secara terus.",
    text2: "Insurans kini tersedia di Jerman, dengan lebih banyak wilayah untuk diikuti.",
    text3: "Perlindungan Bitcoin maksimum yang tersedia pada masa ini ialah 100,000 setiap orang. Jumlah yang lebih tinggi dirancang untuk masa hadapan.",
    text4: "Maklumat peribadi dan kunci awam lanjutan (extended public key) akaun anda yang diinsuranskan adalah sebahagian daripada polisi insurans dan akan dikongsi dengan Bitsurance dan pembekal insurans.",
    text5: "Untuk maklumat lanjut tentang privasi, sila rujuk"
  },
  title: "Insurans"
};
const bitsuranceAccount$5 = {
  errorNoXpub: "Ralat: Tidak dapat mendapatkan xpub daripada akaun.",
  noAccount: "Tiada akaun yang boleh diinsuranskan.",
  select: "Pilih akaun",
  title: "Insurans"
};
const blink$b = {
  button: "Berkedip"
};
const bootloader$b = {
  button: "Naik taraf Firmware sekarang",
  button_install: "Pasang firmware sekarang",
  progress: "Menaiktaraf: {{progress}}%",
  progress_install: "Memasang: {{progress}}%",
  success: "Naik taraf berjaya! Sila pasang ulang peranti. Kali ini, jangan sentuh butang."
};
const button$g = {
  abort: "Tinggalkan",
  back: "Kembali",
  buy: "Beli",
  changepin: "Ubah kata laluan peranti",
  check: "Semak Backup",
  "continue": "Teruskan",
  copy: "Menyalin",
  create: "Buat",
  dismiss: "Batalkan",
  done: "Selesai",
  download: "Muat turun",
  hiddenwallet: "Buat wallet tersembunyi",
  next: "Berikut",
  ok: "OK",
  previous: "Sebelumnya",
  receive: "Terima",
  restore: "Memulihkan",
  select: "Pilih",
  send: "Hantar",
  unlock: "Buka",
  update: "Kemas kini",
  upgrade: "Naik taraf"
};
const buy$7 = {
  exchange: {
    bankTransfer: "Transfer bank",
    bestDeal: "Tawaran terbaik",
    creditCard: "Kad kredit",
    fast: "Cepat",
    fee: "bayaran",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Pemindahan bank: {{fee}}%",
          creditDebitCard: "Kad kredit/debit: {{fee}}%",
          learnMore: "Ketahui lebih lanjut tentang Moonpay",
          title: "Bayaran"
        },
        fullCurrenciesList: "Lihat senarai penuh mata wang di sini",
        payment: {
          asteriskText: "* Tidak tersedia untuk penduduk AS",
          bankTransfer: "Transfer bank*",
          bankTransferDetails: {
            pix: "PIX (transaksi BR di Brasil sahaja)",
            sepa: "SEPA dan SEPA Instant (transaksi EUR di negara-negara SEPA sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          creditDebitCard: "Kad kredit/debit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa dan Maestro"
          },
          learnMore: "Lihat butiran lanjut tentang kaedah pembayaran",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong semua mata wang fiat utama: USD, EUR, CHF dan lain-lain."
      },
      pocket: {
        fees: {
          info: "Transfer bank: {{fee}}%",
          title: "Bayaran"
        },
        learnMore: "Ketahui lebih lanjut tentang Pocket",
        payment: {
          bankTransfer: "Transfer bank",
          bankTransferDetails: {
            sepa: "SEPA dan SEPA Segera (urus niaga EUR di negara SEPA sahaja)",
            sic: "Swiss Interbank Clearing (transaksi CHF di CH/LI sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          bankTransferReccuring: "Bagaimana cara menyiapkan pembelian berkala dengan standing order?",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong mata wang Eropah: EUR, GBP dan CHF.",
        verification: {
          info: "Hanya memerlukan pengesahan identiti melebihi ambang harian dan tahunan.",
          link: "Cari ambang semasa di sini",
          title: "Pengesahan identiti"
        }
      },
      region: {
        title: "Pilih wilayah akaun bank anda didaftarkan untuk melihat pilihan yang tersedia untuk anda."
      }
    },
    noExchanges: "Maaf, tiada pertukaran tersedia di rantau ini.",
    region: "Wilayah",
    selectRegion: "Tidak dinyatakan",
    title: "Beli {{name}}"
  },
  info: {
    "continue": "Setuju dan teruskan",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "Kami bekerjasama dengan MoonPay untuk menawarkan anda cara yang lancar untuk membeli {{name}} terus dalam BitBoxApp. Ia hanya beberapa klik.",
        "MoonPay ialah platform yang memudahkan dan cepat untuk membeli {{name}} di lebih 160+ negara."
      ],
      payment: {
        details: "Anda boleh beli {{name}} serta-merta melalui MoonPay dengan kaedah pembayaran berikut. Pesanan kad kredit atau debit adalah segera dan mudah, tetapi lebih mahal disebabkan peningkatan risiko caj balik. Kami mengesyorkan menggunakan pilihan pindahan bank untuk jumlah yang lebih besar. Yuran minimum ialah 4 USD/EUR atau setara.",
        footnote: "Sila ambil perhatian bahawa kadar pertukaran MoonPay boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
        table: {
          "1_description": "Yuran terendah, boleh mengambil masa sehingga 3 hari bekerja",
          "1_method": "Pindahan bank (SEPA)",
          "2_description": "Yuran yang lebih tinggi tetapi cepat dan segera",
          "2_method": "Kad kredit & debit",
          description: "Penerangan",
          fee: "Yuran",
          method: "Kaedah"
        },
        title: "Kaedah pembayaran dan yuran"
      },
      privacyPolicy: "Dasar privasi MoonPay",
      protection: {
        description: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana masuk dianggap seperti transaksi biasa. MoonPay perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
        descriptionGeneric: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana yang masuk dianggap seperti transaksi biasa. Bagaimanapun pertukaran rakan kongsi perlu mengumpul beberapa maklumat untuk beroperasi. Sila rujuk dasar privasi masing-masing untuk melihat dengan lebih terperinci cara data dikendalikan.",
        title: "Perlindungan Data"
      },
      security: {
        description: "Apabila anda membeli {{name}} melalui MoonPay, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        descriptionGeneric: "Apabila anda membeli {{name}} melalui pertukaran rakan kongsi, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        link: 'Model "security threat"',
        title: "Model security"
      },
      title: ""
    },
    next: "Seterusnya",
    selectLabel: "Pilih akaun anda",
    selectPlaceholder: "Pilih syiling",
    skip: "Jangan tunjukkan lagi",
    title: "Beli {{name}}"
  },
  pocket: {
    data: {
      link: "Dasar privasi poket",
      p1: "BitBoxApp tidak mengumpul sebarang data semasa membeli bitcoin, dana masuk dianggap seperti transaksi biasa. Pocket perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
      title: "Perlindungan Data"
    },
    kyc: {
      link: "Baca Soalan Lazim Poket",
      p1: "Pocket cuba mengekalkan KYC pada tahap minimum. Untuk pembelian di bawah 950 EUR (1000 CHF) sehari, tiada dokumen tambahan diperlukan. Untuk pembelian melebihi jumlah ini, anda perlu menjadualkan panggilan dengan Pocket untuk melengkapkan proses KYC/AML yang diperlukan.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Anda boleh membeli bitcoin serta-merta dengan Pocket melalui pindahan bank SEPA. Yuran adalah 1.5% dan bitcoin didepositkan ke BitBox anda secepat mungkin selepas Pocket menerima pindahan bank (biasanya dalam hari yang sama).",
      p2: "Sila ambil perhatian bahawa kadar pertukaran Pocket boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
      title: "Kaedah pembayaran dan yuran"
    },
    previousTransactions: "Sejarah transaksi akaun ini tidak kosong. Berkongsi akaun ini akan menjadikan semua urus niaga masa lalu dan masa depannya kelihatan untuk Pocket. Teruskan juga?",
    security: {
      link: "Model ancaman keselamatan BitBox02",
      p1: "Apabila anda membeli bitcoin melalui Pocket, anda menggunakan perkhidmatan luaran. Perkhidmatan ini di luar skop model Ancaman Keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran yang dijalankan oleh perisian BitBoxApp. Walau bagaimanapun, kami bekerjasama untuk meningkatkan keselamatan dengan menggunakan mekanisme pengesahan dua faktor untuk mengesahkan alamat anda menerima ke.",
      title: "Model keselamatan"
    },
    usedAddress: "Alamat {{address}} telah digunakan, sila mulakan semula dengan alamat baharu.",
    verifyBitBox02: "Sila sahkan bahawa alamat yang anda terima melalui e-mel sepadan dengan alamat yang dipaparkan pada Bitbox anda. Jika boleh, anda harus membuka e-mel pada peranti kedua untuk keselamatan yang lebih baik.",
    welcome: {
      p1: "Kami bekerjasama dengan Pocket untuk menawarkan anda cara yang lancar untuk membeli bitcoin terus dalam BitBoxApp. Ia hanya beberapa klik.",
      p2: "Pocket ialah platform Switzerland yang menjadikannya cepat dan mudah untuk membeli bitcoin di kebanyakan Eropah (di mana-mana sahaja di mana pemindahan bank SEPA disokong).",
      p3: "Dengan Pocket, anda juga boleh melakukan pembelian biasa melalui pesanan bank tetap, jadi anda boleh DCA (purata kos dolar) dengan mudah.",
      title: "Selamat datang ke kedai sehenti anda untuk membeli bitcoin"
    }
  },
  title: "Beli {{name}}"
};
const changePin$b = {
  newTitle: "Kata laluan peranti baru",
  oldLabel: "Kata laluan peranti terkini"
};
const chart$7 = {
  dataMissing: "Mengumpul data sejarah... nantikan.",
  dataOldTimestamp: "Pengemaskinian kadar pertukaran sejarah. Carta tidak memaparkan data selepas {{time}}.",
  dataUpdating: "mengemas kini data",
  filter: {
    all: "Semua",
    month: "Bulan",
    week: "Minggu",
    year: "Tahun"
  }
};
const checkSDcard$b = "memeriksa kad micro SD";
const clickHere$b = "Tekan di sini.";
const confirm$d = {
  abortInfo: "Sentuh untuk ",
  abortInfoRedText: "tinggalkan",
  approveInfo: "Tahan 4 detik untuk ",
  approveInfoGreenText: "sahkan",
  info: "Pada BitBox anda",
  infoWhenPaired: "Mula-mula pada telefon mudah alih yang dipasangkan dan kemudian BitBox anda"
};
const confirmOnDevice$b = "Sila sahkan pada peranti anda.";
const connectKeystore$6 = {
  promptNoName: "Sila sambungkan BitBox02 anda untuk meneruskan",
  promptWithName: 'Sila sambungkan BitBox02 anda bernama "{{name}}" bersambung'
};
const darkmode$6 = {
  toggle: "Mod gelap"
};
const device$b = {
  appUpradeRequired: "BitBox anda tidak sesuai dengan aplikasi desktop ini. Sila muat turun dan pasang versi terkini.",
  keystoreConnected: "Wallet bersambung"
};
const deviceLock$b = {
  button: "Membolehkan Pengesahan Dua Langkah (2FA)",
  condition1: "Adakah anda mempunyai backup?",
  condition2: "Apakah pengesahan aplikasi mudah alih berfungsi?",
  condition3: "2FA MENYAHAKTIFKAN backup dan pemasangan aplikasi. Peranti mesti DITETAPKAN SEMULA untuk keluar dari 2FA!",
  confirm: "Membolehkan Pengesahan Dua Langkah (2FA)",
  title: "Membolehkan Pengesahan Dua Langkah (2FA)"
};
const deviceSettings$b = {
  backups: {
    manageBackups: {
      description: "Cipta atau sahkan sandaran kad microSD anda."
    },
    showRecoveryWords: {
      description: "Tunjukkan dan sahkan perkataan pemulihan."
    },
    title: "Sandaran"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp menyemak sama ada peranti anda adalah tulen."
    },
    deviceName: {
      description: "Tukar nama peranti anda."
    },
    rootFingerprint: {
      description: "Root fingerprint ialah pengecam unik untuk dompet yang sedang digunakan. Root fingerpri boleh membantu anda membezakan antara dompet yang berbeza jika anda menggunakan frasa laluan."
    },
    securechip: {
      description: "Model cip selamat."
    },
    title: "Maklumat peranti"
  },
  expert: {
    factoryReset: {
      description: "Tetapkan semula peranti anda kepada tetapan kilang. Ini memadamkan dompet daripada BitBox02 anda!",
      title: "Tetapan semula kilang"
    },
    goToStartupSettings: {
      description: "Masukkan pemuat but BitBox02. Anda boleh mendayakan cincang perisian tegar dari sini."
    },
    passphrase: {
      description: "Dayakan atau lumpuhkan ciri frasa laluan.",
      title: "Ungkapan laluan"
    }
  },
  firmware: {
    firmwareVersion: "Versi Perisian Tegar",
    newVersion: {
      label: "Versi yang tersedia"
    },
    title: "Firmware",
    upToDate: "Peranti anda adalah yang terkini",
    upgradeAvailable: "Peningkatan baharu tersedia",
    version: {
      label: "Versi"
    }
  },
  hardware: {
    attestation: {
      "false": "Semakan ketulenan gagal",
      label: "Semakan ketulenan",
      "true": "BitBox02 anda adalah sahih"
    },
    sdcard: {
      "false": "Belum dimasukkan",
      label: "Kad micro SD",
      "true": "Telah dimasukkan"
    },
    securechip: "Cip selamat",
    title: "Hardware"
  },
  loading: "Mengambil maklumat peranti ...",
  pairing: {
    lock: {
      "false": "dinyahaktifkan",
      label: "Pengesahan Dua Langkah (2FA)",
      "true": "Diaktifkan"
    },
    mobile: {
      "false": "Ditutup",
      label: "Aplikasi Mudah Alih",
      "true": "Buka"
    },
    status: {
      "false": "Belum dipasangkan",
      label: "Status",
      "true": "Dipasangkan"
    },
    title: "Memasang"
  },
  secrets: {
    manageBackups: "Urus Backup",
    title: "Rahsia"
  }
};
const deviceTampered$b = "Apakah BitBox anda dibekalkan dengan kata laluan pemulihan? Jika ya, hentikan proses persediaan dan hubungi sokongan segera. Shift tidak akan memberikan anda dompet siap pakai atau membuat cadangan kata laluan.";
const dialog$c = {
  cancel: "Batal",
  confirm: "Sahkan",
  confirmTitle: "Pengesahan"
};
const error$7 = {
  accountAlreadyExists: "Akaun sudah wujud.",
  accountLimitReached: "Tidak boleh menambah akaun. Bilangan maksimum akaun untuk syiling ini telah dicapai.",
  aoppCallback: "Terdapat ralat menghantar alamat kepada {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "Tiada akaun tersedia.",
  aoppSigningAborted: "Permintaan pemilikan alamat dibatalkan.",
  aoppUnknown: "Ralat tidak diketahui berlaku.",
  aoppUnsupportedAsset: "Aset tidak disokong.",
  aoppUnsupportedFormat: "Tiada akaun tersedia yang menyokong format alamat yang diminta.",
  aoppUnsupportedKeystore: "Peranti yang disambungkan tidak boleh menandatangani mesej untuk aset ini.",
  aoppVersion: "Versi tidak diketahui.",
  wrongKeystore: "Dompet salah disambungkan. Sila pastikan anda memasukkan peranti yang betul yang sepadan dengan akaun ini.",
  wrongKeystore2: " Jika anda menggunakan frasa laluan pilihan, pastikan anda telah memasukkan frasa laluan yang betul untuk akaun tersebut."
};
const fiat$d = {
  "default": "tetapan standard",
  setDefault: "Tetapkan {{code}} sebagai tetapan standard",
  title: "Mata wang"
};
const footer$d = {
  appVersion: "Versi App:"
};
const generic$7 = {
  enabled_false: "Dinyahaktifkan",
  enabled_true: "Diaktifkan"
};
const genericError$b = "Kesalahan muncul. Sekiranya anda melihat sebarang masalah, sila mulakan semula aplikasi.";
const goal$b = {
  buttons: {
    create: "Buat wallet baru",
    restore: "Pulihkan wallet dari backup"
  },
  paragraph: "Sila pilih salah satu pilihan berikut:",
  step: {
    "1": {
      title: "Maklumat Keselamatan"
    },
    "2": {
      description: "Tetapkan kata laluan peranti",
      title: "Peranti"
    },
    "3-create": {
      description: "Buat wallet baru",
      title: "Wallet"
    },
    "3-restore": {
      description: "dari backup",
      title: "Memulihkan"
    },
    "4-create": {
      title: "Ringkasan"
    },
    "4-restore": {
      title: "Ringkasan"
    }
  }
};
const guide$c = {
  accountDescription: {
    text: "Ini adalah gambaran keseluruhan akaun anda. Ia menunjukkan transaksi masuk dan keluar. Baki dipaparkan untuk setiap akaun secara berasingan. Rujuk panduan dalam tetapan untuk mengetahui lebih lanjut mengenai jenis akaun yang berlainan.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountFiat: {
    text: "Ya, anda boleh mengklik ticker mana sahaja untuk berputar melalui beberapa mata wang fiat. Anda juga boleh menukar senarai mata wang dalam tetapan.",
    title: "Bolehkah saya memaparkan kadar penukaran lain?"
  },
  accountIncomingBalance: {
    text: "Jumlah yang akan masuk dan akan dipindahkan kepada anda tetapi belum disahkan oleh rangkaian.",
    title: "Apakah maksud akan masuk?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Setiap xpub terikat dengan "Jenis" yang ditunjukkan: sama ada "Segwit Asli (bech32)", "Segwit Terbungkus" atau "Taproot" (Bitcoin sahaja). Ini adalah jenis skrip yang digunakan oleh {{coinName}}. BitBoxApp menggabungkannya, menyokong berbilang jenis skrip dalam akaun yang sama. Kerana setiap jenis skrip memberikan xpub yang berbeza, terdapat berbilang xpub bagi setiap akaun.\n\nJika anda menerima secara konsisten pada alamat lalai (Native Segwit), anda hanya memerlukan xpub "bech32". Walau bagaimanapun, jika anda turut menerima dana untuk "Wrapped Segwit" atau "Taproot", anda juga perlu menggunakan kunci awam lanjutan "Wrapped Segwit" dan "Taproot".',
      title: "Mengapa terdapat banyak xpub?"
    },
    privacy: {
      text: "Untuk akaun khusus ini, kunci awam lanjutan mendedahkan keseluruhan sejarah kewangan, baki akaun anda dan semua urus niaga masa hadapan. Tetapi xpub tidak membenarkan sesiapa membelanjakan syiling anda.\n\nJika anda memberikan xpub kepada seseorang, anda harus sedar bahawa orang atau syarikat ini boleh melihat semua transaksi lain akaun yang sama. Oleh itu, adalah idea yang baik untuk menggunakan akaun itu hanya untuk tujuan ini dan menyimpan dana lain dalam akaun yang berbeza.",
      title: "Adakah saya perlu merahsiakan xpub saya?"
    },
    verify: {
      text: "Ya, adalah idea yang baik untuk menyemak semula xpub anda. Jika orang lain akan menjana alamat terima daripada xpub ini untuk menghantar wang kepada anda, ini amat penting. Anda perlu mengesahkannya pada peranti untuk memastikan bahawa xpub ini kepunyaan anda; jika tidak, semua dana boleh pergi ke alamat yang salah.",
      title: "Adakah saya perlu mengesahkan xpub pada peranti?"
    },
    xpub: {
      text: "Public Key Lanjutan adalah kunci akar yang mana semua alamat penerima sebuah akaun diperoleh.\nIa disediakan di sini untuk kegunaan lanjutan dan saling kendalian dengan wallet yang hanya boleh dilihat sahaja, seperti Electrum atau Sentinel.",
      title: "Apa itu Public Key Lanjutan?"
    }
  },
  accountRates: {
    text: "Kadar pertukaran dikemas kini setiap minit oleh CoinGecko.",
    title: "Kadar mana yang digunakan?"
  },
  accountReload: {
    text: "Semua maklumat transaksi dikemas kini secara automatik.",
    title: "Bagaimanakah saya dapat memuatkan semula sejarah transaksi?"
  },
  accountSendDisabled: {
    text: "Butang 'Hantar' diaktifkan apabila baki anda tidak kosong.",
    title: "Mengapa saya tidak dapat menghantar sebarang {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Jumlah keseluruhan ialah jumlah semua akaun crypto anda. Kadar pertukaran diperoleh daripada coingecko.com.\n\nNota: Jika anda menggunakan MyEtherWallet untuk token yang tidak disokong dalam BitBoxApp, ia tidak akan dimasukkan dalam jumlah yang dipaparkan.",
    title: "Bagaimanakah jumlah keseluruhan dikira?"
  },
  accountSummaryDescription: {
    text: "Di sini anda boleh melihat prestasi portfolio anda dari semasa ke semasa. Ringkasan akaun crypto individu anda dipaparkan di bawah carta.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountTransactionAttributesBTC: {
    text: "Saiz maya: Digunakan untuk menentukan yuran rangkaian. Anda telah berjaya menyimpan yuran jika ia lebih kecil daripada saiz transaksi.\nSaiz: Saiz transaksi yang sebenarnya dalam bait apabila disirikan mengikuti blockchan yang mendasarinya.\nBerat: Diperkenalkan dengan Segwit, itu adalah metrik baru untuk menilai saiz transaksi dan blok. Setiap bait saksi yang dipisahkan dianggap sebagai satu, semua yang lain sebagai empat unit berat. Dibandingkan satu megabyte dalam saiz sebenarnya, had saiz blok kini adalah empat juta unit berat.",
    title: "Butiran transaksi yang berkaitan dengan Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: "Pengesahan: Apabila transaksi anda disiarkan buat kali pertama, ia tidak akan disahkan terlebih dahulu. Anda perlu menunggu untuk dimasukkan ke dalam blok oleh pelombong, selepas itu ia akan mempunyai 1 pengesahan. Setiap blok yang disiarkan di rangkaian selepas itu akan menambah pengesahan lain ke transaksi anda. Secara umum pedagang dan pelaku rangkaian lain hanya akan menerima transaksi dengan pengesahan 3-6 sebelum mempertimbangkan transaksi sebagai selesai.\nID Transaksi: Nombor pengenalan unik yang boleh digunakan untuk mencari transaksi dalam blok explorer.\nYuran: Pelombong dibayar yuran transaksi sebagai insentif untuk memasukkan transaksi di blok-blok yang mereka laksanakan. Untuk mengetahui lebih lanjut, klik pada butang hantar.",
    title: "Apa makna daripada maklumat yang ditunjukkan dalam butiran transaksi?"
  },
  accountTransactionConfirmation: {
    text: "Ini adalah transaksi yang telah disiarkan ke rangkaian dan sedang menunggu untuk disahkan.",
    title: "Apa itu transaksi yang tertunda?"
  },
  accountTransactionLabel: {
    text: "Ia adalah alamat di mana anda menerima syiling atau menghantar syiling itu. Satu alamat menyandi bagaimana (dan dengan demikian oleh siapa) syiling dapat dibelanjakan.",
    title: "Alamat mana yang dipaparkan untuk setiap transaksi?"
  },
  accountTransactionTime: {
    text: "Masa daripada transaksi yang telah disahkan di blokchain.",
    title: "Masa mana yang dipaparkan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Setiap syiling boleh mempunyai maksimum lima akaun.",
      title: "Berapa banyak akaun yang boleh saya buat?"
    },
    howtoAddTokens: {
      text: 'Token yang menggunakan standard ERC20 terikat pada akaun Ethereum tertentu. Untuk mendayakan atau melumpuhkan token tertentu, buka skrin "Urus akaun", kembangkan akaun Ethereum anda dan hidupkan atau matikan token yang dikehendaki.',
      title: "Bagaimanakah saya boleh menambah token tambahan?"
    },
    moveFunds: {
      text: "ya. Tetapi kerana akaun adalah bebas, anda perlu menghantar dana anda menggunakan transaksi biasa.",
      title: "Bolehkah saya memindahkan dana antara akaun?"
    },
    recoverAccounts: {
      text: "ya. BitBoxApp mencipta akaun menggunakan piawaian yang mantap yang serasi dengan kebanyakan dompet crypto lain.",
      title: "Bolehkah saya memulihkan akaun saya dengan dompet lain?"
    },
    whatAreAccounts: {
      text: "Dompet anda boleh mengurus berbilang akaun syiling yang sama. Akaun berguna apabila anda ingin mengasingkan dana.",
      title: "Apakah akaun?"
    },
    whatIsRememberWallet: {
      text: 'Mendayakan "Ingat dompet" membolehkan anda melihat akaun untuk dompet ini dalam BitBoxApp walaupun apabila BitBox02 tidak dipalamkan. Ini membolehkan anda menyemak baki dan portfolio anda pada bila-bila masa anda mahu. BitBox02 masih perlu dipalamkan dan dibuka kuncinya untuk menghantar atau menerima syiling.\n\nMelumpuhkan "Ingat dompet" memerlukan anda memasukkan BitBox02 (atau dompet frasa laluan) masing-masing untuk melihat akaun tersebut dalam BitBoxApp.',
      title: 'Apa yang berlaku apabila saya mendayakan/lumpuhkan "Ingat dompet"?'
    },
    whyIsThisUseful: {
      text: 'Akaun bagus untuk mengurus dana untuk orang atau tujuan yang berbeza kerana ia dipisahkan. Anda juga boleh berkongsi "kunci awam lanjutan" akaun tanpa mendedahkan apa-apa tentang akaun anda yang lain. Ini membolehkan anda berulang kali menerima dana tanpa menggunakan semula alamat, seperti menerima gaji anda atau kerap membeli kripto.',
      title: "Mengapa ini berguna?"
    }
  },
  appendix: {
    link: "Hubungi kami!",
    text: "Soalan lain?"
  },
  backups: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda. Ia juga boleh digunakan untuk mengesahkan bahawa anda masih mempunyai kata laluan pemulihan yang betul. Anda dapat menyemak kata laluan pemulihan utama atau tersembunyi anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak, tetapi kata laluan pemulihan diperlukan untuk memperoleh wallet dari benih yang disimpan.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    howOften: {
      text: "Cadangan dibuat secara automatik apabila dompet baru dibuat. Anda hanya perlu membuat backup baru jika kad micro SD anda hilang atau rosak, atau jika anda mahu menggunakan lebih daripada satu kad micro SD sebagai backup.\nAnda tidak perlu membuat backup baru selepas aktiviti transaksi. Semua data transaksi anda dapat diciptakan oleh backup tunggal anda yang dijana secara automatik untuk anda.",
      title: "Berapa kerap saya perlu membuat backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad micro SD. Benih bersama-sama dengan kata laluan pemulihan menjana dompet anda.",
      title: "Apa itu backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak. Sila simpan kad SD mikro dengan selamat, kerana ia mengandung benih yang tidak disenarai untuk memulihkan dompet anda.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad microSD.",
      title: "Apakah backup itu?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Apabila 2FA dihidupkan, semua transaksi perlu diluluskan pada telefon mudah alih yang dipasangkan untuk membelanjakan duit syiling. Di bawah tudung, nombor guna tunggal yang disulitkan dihantar ke aplikasi mudah alih, disahsulitkan di sana, dan kembali ke BitBox dengan menekan butang Terima. Komunikasi dengan peranti ini dilakukan melalui saluran antara telefon mudah alih dan aplikasi desktop ini yang ditubuhkan semasa berpasangan.\n\nPastikan anda telah membackup wallet anda dan pasangkan aplikasi mudah alih sebelum menghidupkan 2FA. Setelah dihidupkan, slot micro SD dan pasangan aplikasi mudah alih akan dimatikan. Mereka boleh diaktifkan semula dengan menetapkan semula BitBox, yang mana akan menghapuskan peranti tersebut.",
      title: "Bagaimanakah Pengesahan Dua Langkah (2FA) berfungsi?"
    },
    disable2FA: {
      text: "Untuk mematikan 2FA, anda perlu menetapkan semula BitBox anda dan kemudian memulihkan wallet dari backupnya. Pastikan anda masih mempunyai kad micro SD dengan backup dan bahawa anda masih ingat kata laluan pemulihan anda. Kemudian tekan 'Tetapkan semula Peranti'. Lalu tetapkan kata laluan peranti baru dan pilih 'Atau Pulihkan Backup'. Pilih backup yang telah anda buat dari wallet, klik 'Pulihkan' dan masukkan kata laluan pemulihan yang anda gunakan semasa membuat dompet.",
      title: "Bagaimanakah saya dapat mematikan Pengesahan Dua Langkah (2FA)?"
    },
    ejectBitbox: {
      text: "Anda boleh mencabut BitBox bila-bila masa tanpa perlu mengklik ikon 'Selamat Lepaskan Perkakasan' terlebih dahulu.",
      title: "Bagaimana saya dapat menarik keluar BitBox?"
    },
    ejectSD: {
      text: "Anda dapat menyingkirkan micro SD kad dari BitBox kapanpun selama anda tidak menciptakan atau memulihkan sebuah backup",
      title: "Bagaimana saya dapat mengeluarkan kad micro SD?"
    },
    hiddenWallet: {
      text: "Ia adalah wallet kedua pada peranti yang sama yang dilindungi oleh kata laluan peranti dan kata laluan pemulihan yang berlainan, yang boleh anda gunakan untuk tujuan penafian yang munasabah. Dikeranakan penggunaan benih backup yang sama untuk wallet biasa dan tersembunyi anda, tiada tambahan backup diperlukan.",
      title: "Apa itu wallet tersembunyi?"
    },
    legacyHiddenWallet: {
      text: "Mula-mula klik butang di bawah (tersedia jika BitBox dikunci dengan kata laluan peranti utama dan 2FA dinyahdayakan), kemudian pasang kembali Bitbox dan buka dengan kata laluan peranti tersembunyi anda.",
      title: "Bagaimanakah saya dapat mengakses legacy wallet tersembunyi?"
    },
    pairing: {
      text: "Selepas memuat turun aplikasi mudah alih kami untuk iOS atau Android, anda dapat menubuhkan saluran selamat antara aplikasi mudah alih dan aplikasi ini dengan mengimbas kod QR yang dipaparkan. Setelah diimbas, ikut arahan dalam aplikasi mudah alih.",
      title: "Bagaimana memasangkan dengan selamat telefon anda"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Sila semak tapak web Bitsurance dan Soalan Lazim mereka untuk butiran lanjut.",
      title: "Soalan tambahan?"
    },
    privacy: {
      link: {
        text: "Dasar privasi Bitsurance"
      },
      text: "Seperti mana-mana polisi insurans biasa, ia mengandungi nama penuh dan alamat anda, dan menyatakan objek yang diinsuranskan (ditakrifkan oleh kunci awam lanjutan akaun Bitcoin yang diinsuranskan). Data ini diserahkan kepada Bitsurance secara langsung dan tidak dikongsi dengan Shift Crypto. Sila rujuk dasar privasi Bitsurance untuk mendapatkan maklumat lanjut",
      title: "Apakah maklumat peribadi yang diperlukan untuk insurans?"
    },
    renew: {
      text: 'Insurans akan diperbaharui secara automatik untuk tahun hadapan. Anda boleh membatalkan pembaharuan pada bila-bila masa dengan mengklik pada "Urus kontrak" dalam BitBoxApp, yang membawa anda ke portal pelanggan Bitsurance.',
      title: "Bagaimanakah saya boleh memperbaharui atau membatalkan insurans?"
    },
    status: {
      text: 'Akaun yang berjaya diinsuranskan ditandakan dengan lencana hijau "diinsuranskan" di penjuru kiri sebelah atas pada setiap halaman akaun Bitcoin. Dalam bahagian "Insurans", anda boleh melihat gambaran keseluruhan semua akaun Bitcoin yang diinsuranskan dan status insurans semasa mereka.',
      title: "Bolehkah saya menyemak status akaun yang diinsuranskan?"
    },
    what: {
      text: 'Setiap kontrak insurans Bitcoin meliputi akaun dompet tertentu. Anda boleh menginsuranskan berbilang akaun dengan mengambil beberapa polisi insurans. Akaun yang diinsuranskan terhad kepada menggunakan alamat Bitcoin "Segwit Asli".',
      title: "Adakah keseluruhan dompet BitBox diinsuranskan?"
    },
    who: {
      text: "Insurans ditawarkan oleh Bitsurance, broker insurans yang dibina oleh bitcoiners. Mereka bekerja dengan insurans ELEMENT untuk menyediakan insurans Bitcoin. Kedua-dua syarikat berpangkalan di Jerman.",
      title: "Siapa yang menginsuranskan bitcoin saya?"
    },
    why: {
      text: "Bitsurance melindungi beberapa risiko penjagaan diri yang tidak dalam skop walaupun dompet paling selamat, mis. pecah rumah, peras ugut atau pemusnahan dompet. Ia adalah keputusan peribadi anda jika anda memerlukan perlindungan insurans untuk risiko ini.",
      title: "Adakah saya memerlukan insurans Bitcoin?"
    }
  },
  cointracking: {
    text: 'Klik butang "Eksport" dan buka folder muat turun di mana anda akan menemui eksport CSV. Kemudian klik pautan di bawah, muat naik fail CSV BitBox anda dan import data untuk menggunakannya untuk pengurus portfolio CoinTracking anda dan untuk membuat laporan cukai anda.',
    title: "Bagaimana untuk mengimport urus niaga saya ke dalam CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Baca lebih lanjut mengenai semakan ketulenan"
      },
      text: "BitBoxApp menjalankan semakan pengesahan pada BitBox02 untuk mengesahkan sama ada peranti itu tulen. Semakan dilakukan secara tempatan dan tidak bersambung ke mana-mana pelayan.",
      title: "Bagaimanakah semakan ketulenan berfungsi?"
    },
    name: {
      text: "Ini adalah nama dompet dan sandaran anda. Nama itu digunakan untuk sandaran masa hadapan dan boleh digunakan untuk membantu membezakan antara dompet yang berbeza. Ia boleh ditukar pada bila-bila masa tetapi ambil perhatian bahawa sandaran yang dibuat sebelum perubahan masih akan menggunakan nama sebelumnya.",
      title: "Apakah nama BitBox02 digunakan?"
    },
    "secure-chip": {
      link: {
        text: "Baca lebih lanjut mengenai cip selamat"
      },
      text: "Maklumat ini menunjukkan nombor model cip selamat, cip paling terkini ialah ATECC608B dengan ciri keselamatan yang dipertingkatkan berbanding model lama.",
      title: "Mengapa tunjukkan model cip selamat?"
    }
  },
  receive: {
    address: {
      text: "Berikan kepada orang lain untuk menghantarkan anda beberapa syiling.\n(Sentiasa sahkan alamat secara mandiri, contohnya dengan panggilan telefon.)",
      title: "Apa yang boleh saya lakukan dengan alamat?"
    },
    addressChange: {
      text: "Selepas alamat digunakan dalam sebuah transaksi, alamat baru akan ditambah ke senarai untuk menggantikannya. Setiap masa terdapat 20 alamat yang belum digunakan dalam senarai.",
      title: "Bila alamat berubah?"
    },
    addressFormats: {
      text: "Secara lalai, jenis alamat ialah Segwit Asli. Jenis alamat ini digunakan secara meluas oleh dompet/pertukaran lain dan memberikan anda kadar yuran terbaik untuk transaksi harian. Walau bagaimanapun, anda juga boleh memilih untuk menghantar kepada Taproot (Bitcoin sahaja), yang merupakan jenis alamat terbaharu, tetapi mungkin belum disokong secara meluas lagi. Sebagai alternatif, jika anda menghadapi masalah menghantar kepada Native Segwit (jenis lalai), anda boleh cuba bertukar kepada jenis alamat Wrapped Segwit yang lebih lama yang mungkin serasi dengan lebih banyak dompet/pertukaran.",
      title: 'Bilakah saya menggunakan "Tukar jenis alamat"?'
    },
    howVerify: {
      text: "Klik ikon BitBox pada bar sisi di sebelah kiri dan lihat bahagian Pemasangan. Panduan akan dikemas kini dan anda boleh terus mengikuti arahan dari sana.",
      title: "Bagaimana saya dapat mengesahkan alamat dengan selamat?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda menghantar syiling ke alamat BitBox anda, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menerima?"
    },
    why20: {
      text: 'Semasa permulaan apl menjana alamat yang diperoleh daripada benih anda untuk melihat sama ada mereka telah menerima dana. Memandangkan apl boleh menjana bilangan alamat yang hampir tidak terhingga, ia boleh menghabiskan masa bertahun-tahun untuk menentukan baki. Untuk mengehadkan carian ini ia berhenti selepas ia melihat 20 alamat yang tidak pernah menerima dana. Ini ialah "had jurang" dan 20 ialah piawaian de-facto walaupun bilangannya adalah sewenang-wenangnya. Ini ialah 20 alamat yang boleh anda pilih.',
      title: "Mengapa hanya 20 alamat?"
    },
    whyMany: {
      text: "Untuk sebab-sebab privasi dan keselamatan, anda tidak perlu menyerahkan alamat yang sama dua kali. Klik 'Berikut' untuk mendapatkan alamat baru untuk tujuan yang berbeza. Anda boleh menjana hingga 20 alamat dalam satu masa. Semua alamat diperoleh dari biji backup tunggal anda. (Bayangkan alamat seperti nombor invois.)",
      title: "Mengapa terdapat banyak alamat?"
    },
    whyVerify: {
      text: "Salah satu sebab untuk membeli wallet hardware seperti BitBox ialah anda tidak boleh mempercayai komputer anda kerana permukaan serangan yang besar. Oleh itu, anda tidak boleh mempercayai komputer anda untuk menjana dan memaparkan alamat yang sahih. Butang untuk mengesahkan alamat dengan selamat membuat BitBox menghantar alamat ke telefon mudah alih yang dipasangkan, dari mana anda juga boleh mengimbas dan mengesahkan kod QR.",
      title: "Mengapa saya perlu mengesahkan alamat dengan selamat?"
    }
  },
  send: {
    change: {
      text: "Perubahan akan dikembalikan ke alamat Taproot jika anda mempunyai sekurang-kurangnya satu Taproot UTXO. Jika anda menggunakan kawalan syiling, perubahan akan dikembalikan ke alamat Taproot jika terdapat sekurang-kurangnya satu Taproot UTXO antara UTXO yang dipilih. Dalam semua kes lain, perubahan dikembalikan ke alamat Segwit Asli.",
      title: "Bagaimanakah output perubahan ditentukan?"
    },
    fee: {
      text: "Yuran ini didasarkan pada saiz data transaksi dan bukan jumlahnya. Sasaran yuran dikira oleh algoritma pengiraan yuran Bitcoin Core untuk setiap keutamaan rangkaian yang anda pilih. Mereka ditunjukkan jika mereka mempunyai nilai yang berbeza dari sasaran di bawah.\nEkonomi: 24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)\nRendah: 12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)\nNormal: 6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)\nTinggi: 2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)\n(Blok mengambil purata sepuluh minit untuk Bitcoin (2.5 minit di Litecoin) untuk melombong dan beban rangkaian mungkin berbeza-beza untuk tempoh di atas.)",
      title: "Bagaimanakah bayaran ditentukan?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda membuat transaksi, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menghantar?"
    },
    priority: {
      text: "Semakin tinggi yuran yang anda bayar, semakin cepat transaksi anda disahkan oleh rangkaian.",
      title: "Apa itu keutamaan rangkaian?"
    },
    revert: {
      text: "Selepas sebuah transaksi ditandatangani dan dihantar (disiarkan ke rangkaian), ia tidak dapat lagi dipulangkan. Periksa ulang transaksi (termasuk yurannya) dengan teliti sebelum menandatangani!\nSekiranya anda tahu sang penerima dan dia akan menghantar jumlah yang sama (dikurang yuran transaksi) kepada anda, anda boleh menghantar kepadanya alamat penerima yang baru.",
      title: "Dapatkah saya memulangkan transaksi?"
    },
    whyFee: {
      text: "Transaksi bersaing untuk disahkan oleh penambang. Pelombong memilih transaksi untuk dimasukkan ke dalam blok yang berdasarkan yuran mereka.\nMiners mengundi untuk sejarah transaksi. Dikeranakan tidak ada pihak ketiga yang dipercayai untuk menguatkuasakan satu undi bagi setiap orang (yang merupakan titik keseluruhan blok), penambang mengundi transaksi dengan mengorbankan sumber yang mahal seperti daya pengkomputeran. Sebagai hadiah untuk kerja mereka, mereka boleh menuntut duit syiling yang baru dibuat dan yuran dari semua transaksi yang mereka sertakan.",
      title: "Mengapa ada yuran rangkaian?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Jika anda berhasrat untuk menyambung ke nod anda sahaja apabila anda berada di rangkaian yang sama (cth. wifi rumah anda), maka menggunakan komunikasi rangkaian biasa sudah memadai.\nDalam kes ini, adalah dinasihatkan bahawa pelayan Electrum anda menyediakan sijil TLS untuk menyulitkan komunikasi.\nJika anda berhasrat untuk menyambung ke nod anda dari mana-mana sahaja, menggunakan Tor ialah pilihan yang lebih baik. Tiada sijil TLS diperlukan dalam kes itu.",
      title: "Sekiranya saya menggunakan clearnet TCP, TLS atau Tor?"
    },
    instructions: {
      link: {
        text: "Panduan untuk menyambungkan nod anda"
      },
      text: "Untuk tutorial penuh, sila lawati panduan kami:",
      title: "Bagaimanakah cara saya menyambungkan BitBoxApp saya ke nod penuh saya sendiri?"
    },
    options: {
      text: "Terdapat pelbagai pilihan untuk menjalankan nod anda sendiri seperti membeli peranti siap, membina sendiri atau menjalankan Bitcoin Core.\nJika anda ingin menyambungkan BitBoxApp anda ke nod anda, pastikan ia menjalankan pelayan Electrum. Ini ialah program khusus yang membolehkan apl dompet berkomunikasi dengan nod penuh anda.\nPilihan yang disokong termasuk Electrs, Electrum Personal Server (EPS) atau Bitcoin Wallet Tracker (BTW).",
      title: "Apakah pilihan yang ada untuk menjalankan nod?"
    },
    tor: {
      text: "Tor adalah singkatan kepada 'The Onion Router', iaitu perisian percuma dan sumber terbuka yang menawarkan banyak faedah privasi dan amat berguna apabila menggunakan Bitcoin.\nJika anda berhasrat untuk menyambung ke nod anda melalui Tor, pastikan Tor dipasang pada komputer anda dan kemudian dayakan Proksi Tor dalam tetapan BitBoxApp.\nPada kebanyakan sistem pengendalian terdapat dua cara untuk menjalankan Tor:\n1. Pelayar Tor: muat turun dan buka Pelayar Tor. Ini akan membolehkan BitBoxApp menyambung ke rangkaian Tor dengan menetapkan port 9150 dalam tetapan proksi Tor.\n2. Perkhidmatan latar belakang Tor: pasang daemon Tor, yang sentiasa berjalan di latar belakang. BitBoxApp kemudiannya boleh menyambung dengan menetapkan port 9050 dalam tetapan proksi Tor.",
      title: "Apakah Tor, proksi Tor dan port mana yang harus saya gunakan?"
    },
    what: {
      text: "Adalah mungkin untuk menggerakkan dompet anda dengan nod penuh anda sendiri sebagai ganti menggunakan server Shift.",
      title: "Apakah ini?"
    },
    why: {
      text: "Menjalankan nod anda sendiri tidak perlu tetapi meningkatkan privasi dan mengurangkan keperluan untuk mempercayai orang lain.\nPertama, ini bermakna anda menggunakan Bitcoin secara lebih peribadi kerana BitBoxApp tidak akan menyambung ke pelayan kami untuk mengambil sejarah transaksi anda; sebaliknya ia akan mengambil maklumat tersebut daripada nod anda sendiri.\nKedua, menjalankan nod anda sendiri bermakna nod anda mengesahkan semua transaksi itu sendiri, memastikan peraturan konsensus dikuatkuasakan.",
      title: "Mengapa saya perlu menjalankan nod saya sendiri?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (pendek kata 'sat') ialah unit terkecil Bitcoin. Satu Satoshi ialah seratus juta bitcoin (0.00000001 BTC). Ia dinamakan sempena pencipta Bitcoin, Satoshi Nakamoto.",
      title: "Apa itu Satoshi?"
    },
    servers: {
      text: "Aplikasi ini berkomunikasi dengan server Shift Crypto untuk memeriksa kemas kini, memuat transaksi, dan menghantar maklumat ke aplikasi mudah alih yang telah dipasangkan.\nDi samping itu, ia mengambil kadar pertukaran terkini dari CoinGecko. (Penukaran dikira secara tempatan, tiada wang anda yang dihantar)",
      title: "Server mana yang digunakan aplikasi ini?"
    }
  },
  title: "Panduan",
  toggle: {
    close: "Tutup panduan",
    open: "Panduan"
  },
  trackingModePortfolioChart: {
    text: "Pada desktop, tuding kursor pada carta. Pada mudah alih, pegang jari anda pada carta dan seret secara mendatar.",
    title: "Bagaimana untuk melihat nilai sejarah pada carta?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Anda perlu menetapkan semula peranti dan memulihkan wallet dari backup dengan menggunakan kata laluan pemulihan.",
      title: "Apa yang perlu saya lakukan jika saya lupa kata laluan peranti?"
    },
    reset: {
      text: "Anda telah memasukkan kata laluan peranti yang salah sebanyak 15 kali. Beberapa percubaan terakhir memerlukan sentuhan panjang pada peranti.",
      title: "Bagaimana menetapkan semula peranti?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Peranti mesti berkelip sekali apabila dimasukkan. Pastikan ia dimasukkan ke arah yang betul. Jika anda menghadapi masalah, sila hubungi kami melalui pautan di bawah.",
      title: "Peranti saya tidak diketahui"
    },
    getDevice: {
      link: {
        text: "Pesan sebuah BitBox"
      },
      text: "Anda boleh membeli BitBox di kedai online kami:",
      title: "Bagaimana saya boleh mendapatkan peranti?"
    },
    internet: {
      text: "Ya, sambungan internet diperlukan untuk menyegerakkan wallet, menghantar transaksi dan mendapatkan kadar pertukaran terkini.",
      title: "Apakah aplikasi ini memerlukan sambungan internet?"
    },
    lostDevice: {
      link: {
        text: "Pusat Backup"
      },
      text: "Anda boleh memulihkan akaun anda pada BitBox baru atau dengan pusat backup kami.",
      title: "Saya kehilangan peranti saya. Bagaimana sekarang?"
    },
    useWithoutDevice: {
      text: "Maaf, ini belum mungkin pada masa ini.",
      title: "Bolehkah saya menggunakan aplikasi tanpa peranti?"
    },
    welcome: {
      text: "Terima kasih kerana menggunakan aplikasi ini yang dibina oleh Shift Crypto dari Switzerland. Ia masih dalam versi beta dan kami menghargai apa-apa input yang anda perlu bagikan. Sila berikan maklum balas menggunakan pautan di bahagian bawah.",
      title: "Selamat datang ke aplikasi BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Jika anda menggunakan telefon/komputer baharu dengan BitBoxApp, maka anda perlu menyambung semula ke DApps. Anda kemudian akan melihat syiling anda pada dapp semula seperti biasa.",
      title: "Saya tidak melihat sambungan saya sebelum ini."
    },
    supportedNetworks: {
      text: "Pada masa ini, hanya mainnet Ethereum disokong menggunakan WalletConnect dalam BitBoxApp. Untuk menggunakan rantaian serasi EVM lain, sila gunakan dompet sambungan penyemak imbas Rabby.",
      title: "Apakah rangkaian yang disokong?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ialah protokol komunikasi untuk aplikasi web3. Ia membolehkan anda menyambung dengan mudah ke DApps berasaskan Ethereum dan dompet web tanpa menggunakan aplikasi pihak ketiga, yang amat berguna untuk pengguna Android BitBoxApp.",
      title: "Apakah itu WalletConnect?"
    }
  }
};
const headerssync$b = {
  blocksSynced: "{{blocks}} blok telah disegerakkan"
};
const hiddenWallet$b = {
  info1HTML: "Untuk tujuan penafian yang munasabah, wallet tersembunyi boleh dibuat dengan kombinasi kata laluan pemulihan dan kata laluan peranti yang <strong> berbeza </strong>.",
  info2HTML: "Tentukan kata laluan peranti dan kata laluan pemulihan yang anda mahu kaitkan dengan wallet tersembunyi anda di bawah ini. Kata laluan peranti dan kata laluan pemulihan mestilah <strong> berbeza </strong> daripada yang anda tentukan untuk wallet utama anda.",
  passwordLabel: "Kata laluan pemulihan tersembunyi",
  passwordPlaceholder: "Sila ulangi kata laluan pemulihan tersembunyi",
  pinLabel: "Kata laluan peranti tersembunyi",
  pinRepeatLabel: "Ulangi kata laluan peranti tersembunyi",
  pinRepeatPlaceholder: "Sila ulangi kata laluan peranti tersembunyi",
  success: "Dompet tersembunyi berjaya dibuat. Pasang ulang BitBox anda untuk membuka kuncinya."
};
const initialize$b = {
  create: "Tetapkan kata laluan peranti",
  creating: "Menetapkan kata laluan peranti...",
  error: {
    e102: "Kata laluan peranti mestilah mengandung sekurang-kurangnya 4 aksara."
  },
  info: {
    description1: "Pilih kata laluan peranti anda. Ini akan digunakan untuk membuka kunci BitBox anda.",
    description2: "Anda boleh menggunakan nombor, huruf dan simbol. Kata laluan yang lebih panjang memberikan keselamatan yang lebih tinggi",
    description3: "Jika anda kehilangan kata laluan peranti, anda perlu menetapkan semula peranti anda dan memulihkan backup wallet anda.",
    subtitle: "Sekarang anda boleh menetapkan kata laluan peranti anda",
    title: "Memulakan peranti anda"
  },
  input: {
    label: "Kata laluan peranti",
    labelRepeat: "Ulangi kata laluan peranti",
    placeholderRepeat: "Sila ulangi kata laluan peranti"
  }
};
const invalidFormat$b = "Format tidak sah";
const language$c = {
  title: "Pilih Bahasa"
};
const legacyhiddenwallet$b = {
  disable: "Matikan Legacy Hidden Wallet",
  enable: "Aktifkan Legacy Hidden Wallet",
  successDisable: "Berjaya melumpuhkan legacy hidden wallet",
  successEnable: "Berjaya menyahaktifkan wallet legacy tersembunyi. Pasang semula BitBox anda dan masukkan kata laluan peranti tersembunyi untuk mengakses wallet legacy tersembunyi warisan."
};
const loading$b = "memuatkan ...";
const manageAccounts$5 = {
  accountHidden: "Akaun ini telah disembunyikan daripada akaun watch-only anda sahaja. Untuk melihatnya semula, sila pasangkan BitBox02 anda.",
  editAccount: "Sunting",
  editAccountNameTitle: "Sunting nama akaun",
  noAccounts: "tiada akaun ditemui",
  settings: {
    hideTokens: "Sembunyikan token",
    showTokens: "Tunjukkan token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Tambah dan tunjukkan/sembunyikan akaun",
  title: "Urus akaun",
  watchAccount: "Tonton akaun",
  watchAccountDescription: "Akaun ini adalah sebahagian daripada akaun watch-only anda sahaja. Anda boleh menyembunyikannya daripada akaun jam tangan anda menggunakan togol."
};
const mobile$6 = {
  usingMobileDataWarning: "Penggunaan data mudah alih: apl ini boleh memuat turun sehingga beberapa ratus megabait data pengepala blockchain selepas membuka kunci akaun. Sila sambung ke Wi-Fi untuk mengelak daripada menggunakan data mudah alih. Selepas menolaknya, mesej ini tidak akan ditunjukkan lagi."
};
const newSettings$5 = {
  about: {
    appVersion: {
      title: "Versi aplikasi"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Kunci akses kepada aplikasi dengan kunci skrin/cap jari.",
      title: "Kunci skrin"
    },
    coinControl: {
      description: "Pilih UTXO yang merupakan sebahagian daripada transaksi untuk membantu meningkatkan privasi."
    },
    customFees: {
      description: "Membolehkan anda memasukkan yuran anda sendiri semasa menghantar."
    },
    torProxy: {
      description: "Sambungkan melalui Tor untuk privasi yang lebih baik."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Mata wang tambahan ini boleh ditogol pada halaman akaun anda.",
      title: "Mata wang aktif"
    },
    darkmode: {
      description: "Lihat BitBoxApp dalam mod gelap."
    },
    defaultCurrency: {
      description: "Pilih mata wang lalai anda",
      title: "Mata wang lalai"
    },
    enableAccount: {
      description: "Melumpuhkan akaun anda bermakna ia tidak akan muncul dalam bar sisi atau portfolio. Anda sentiasa boleh mendayakannya semula dari sini. Syiling pada akaun ini tidak akan terjejas dan akan kekal selamat.",
      title: "Dayakan/lumpuhkan akaun"
    },
    hideAmounts: {
      description: "Memaparkan togol untuk menyembunyikan baki anda dan amaun untuk meningkatkan privasi anda apabila menggunakan apl di khalayak ramai.",
      hideAmounts: "Sembunyikan jumlah",
      showAmounts: "Tunjukkan jumlah",
      title: "Benarkan menyembunyikan jumlah"
    },
    language: {
      description: "Bahasa yang anda mahu BitBoxApp gunakan.",
      title: "Bahasa"
    },
    remebmerWallet: {
      name: "Ingat dompet",
      warning: "Ini akan mengeluarkan dompet anda yang diingati. Untuk melihatnya semula, anda perlu memasukkan BitBox02 untuk dompet ini. Sebarang syiling pada dompet ini tidak terjejas. Adakah anda mahu meneruskan?",
      warningTitle: "Lumpuhkan ingat dompet"
    },
    toggleSats: {
      description: "Dayakan atau lumpuhkan Satoshis."
    }
  }
};
const note$7 = {
  input: {
    description: "(pilihan)",
    placeholder: "Tambah Nota"
  },
  title: "Catatan"
};
const notification$b = {
  newTxs_one: "{{count}} transaksi baru di: {{accountName}}",
  newTxs_other: "{{count}} transaksi baharu dalam: {{accountName}}"
};
const pairing$b = {
  aborted: {
    text: "Pemasangan telah ditinggalkan oleh aplikasi mudah alih.",
    title: "Ditinggalkan"
  },
  button: "Pasangkan Aplikasi Mudah Alih",
  confirm: "Adakah anda pasti mahu memasangkan BitBox anda? Ambil perhatian bahawa selepas itu, telefon bimbit diperlukan untuk melakukan transaksi.",
  connectOnly: {
    button: "Sambungkan aplikasi mudah alih",
    title: "Imbas dengan aplikasi mudah alih kami dengan memilih item menu 'Sambung ke aplikasi desktop baharu'"
  },
  error: {
    text: "Ada yang salah. Sila mulakan lagi.",
    title: "Ada yang salah"
  },
  pullFailed: {
    text: "Gagal menarik mesej daripada telefon bimbit anda melalui pelayan geganti. Pelayan geganti mungkin berada di luar talian, sila hubungi sokongan.",
    title: "Pull gagal"
  },
  reconnectOnly: {
    button: "Sambung semula aplikasi mudah alih"
  },
  scanningFailed: {
    text: "Mudah alih tidak berjaya mengimbas mesej. Sila cuba lagi.",
    title: "Pengimbasan Gagal"
  },
  start: {
    hideAppQRCode: "Sembunyikan QR Code",
    revealAppQRCode: "Tunjukkan QR Code",
    step1: "Jika anda tidak mempunyai aplikasi mudah alih, anda boleh mengimbas kod QR untuk Apple App Store atau Google Play Store.",
    step2: "Imbas dengan aplikasi mudah alih kami, yang anda dapati di bawah nama 'Digital Bitbox 2FA' di kedai aplikasi untuk iOS dan Android:"
  },
  started: {
    text: "Kini sila ikuti arahan dalam aplikasi mudah alih.",
    title: "Hebat"
  },
  success: {
    text: "Selamat, anda berjaya memasangkan BitBox anda dengan aplikasi mudah alih!",
    title: "Berjaya"
  },
  timeout: {
    text: "Pemasanganan ini berakhir selepas dua minit. Mula semula jika anda masih mahu memasangkan aplikasi mudah alih.",
    title: "Berakhir"
  },
  title: "Memasang telefon bimbit"
};
const passphrase$5 = {
  considerations: {
    button: "Pertimbangan sandaran",
    message: "Frasa laluan menambah lapisan perlindungan pada sandaran dompet anda (kad mikroSD atau perkataan pemulihan). Jika seseorang mempunyai akses kepada sandaran anda, mereka juga memerlukan frasa laluan untuk mengakses dompet anda.\n\nWalau bagaimanapun, ini bermakna anda perlu <strong>kedua-dua frasa laluan + sandaran dompet</strong> untuk memulihkan dompet didayakan frasa laluan anda, sekiranya BitBox02 anda hilang atau rosak. Jika anda terlupa atau kehilangan frasa laluan anda, anda akan kehilangan akses kepada semua syiling pada dompet itu.\n\nApabila menyimpan frasa laluan anda, pertimbangkan untuk meletakkannya di lokasi yang berasingan daripada sandaran anda. Dengan cara itu jika seseorang menjumpai sandaran anda, mereka juga tidak menemui frasa laluan anda.",
    title: "Pertimbangan sandaran"
  },
  disable: "Lumpuhkan frasa laluan",
  disableInfo: {
    button: "Lumpuhkan",
    message: "Selepas melumpuhkan frasa laluan, anda tidak lagi akan diminta untuk memasukkan frasa laluan selepas membuka kunci BitBox02 anda. Oleh itu, anda akan memasukkan dompet lalai anda.\n\nMana-mana syiling pada dompet frasa laluan anda masih ada pada dompet itu, namun anda tidak akan dapat mengaksesnya kerana selepas membuka kunci BitBox02 anda, anda akan membuka dompet lalai anda.\n\nUntuk mengakses dompet frasa laluan anda sekali lagi, cukup dayakan semula ciri frasa laluan dan masukkan frasa laluan yang berkaitan selepas membuka kunci BitBox02.\n\n<strong>Petua:</strong> Anda masih boleh memasukkan dompet asal anda dengan membiarkan frasa laluan kosong."
  },
  enable: "Dayakan frasa laluan",
  error: {
    e104: "Menukar tetapan frasa laluan telah digugurkan."
  },
  how: {
    button: "Macam mana rupanya",
    message: "Frasa laluan tidak berfungsi seperti kata laluan yang anda gunakan. Jika anda tersalah taip frasa laluan anda, anda tidak akan dimaklumkan. Ini adalah kerana <strong>setiap frasa laluan mencipta dompet yang berbeza, namun sah</strong>. Ini bermakna anda boleh menggunakan berbilang frasa laluan untuk seberapa banyak dompet yang anda mahukan. Tetapi setiap dompet hanya boleh diakses apabila menaip frasa laluan yang sepadan.\n\nApabila memasang BitBox02 anda, anda akan digesa untuk kata laluan peranti seperti biasa. Selepas itu, anda akan diminta untuk memasukkan frasa laluan pada peranti.\n\nSelepas memasukkan frasa laluan, anda akan ditunjukkan frasa laluan yang anda masukkan. Ini supaya anda boleh mengesahkan anda memasukkannya dengan betul.",
    title: "Bagaimanakah ia berfungsi"
  },
  intro: {
    message: "Frasa laluan menyediakan lapisan keselamatan tambahan di atas dompet anda.\nMari belajar bagaimana ia berfungsi.",
    title: "Sediakan frasa laluan"
  },
  progressDisable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>melumpuhkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  progressEnable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>membolehkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  successDisabled: {
    message: "Ungkapan laluan pilihan <strong>berjaya didayakan</strong>!\nAnda akan diminta untuk memberikan frasa laluan mulai sekarang.",
    messageEnd: "Sila pasang semula BitBox02 sekarang.",
    title: "Ungkapan laluan didayakan"
  },
  successEnabled: {
    message: "Ungkapan laluan pilihan <strong>berjaya dilumpuhkan</strong>!\n\nAnda tidak akan diminta untuk memberikan frasa laluan lagi.",
    messageEnd: "Sila pasang semula BitBox02 anda sekarang.",
    tips: "Petua",
    tipsList: [
      "Kami cadangkan menghantar sejumlah kecil ke dompet frasa laluan terlebih dahulu. Kemudian cabut dan pasang semula BitBox02 dan masukkan kata laluan dan frasa laluan anda. Jika anda memasukkan frasa laluan dengan betul, anda sepatutnya melihat syiling dalam dompet anda.",
      "Jika anda ingin memasukkan dompet asal anda tanpa frasa laluan, anda masih boleh melakukan ini dengan memasukkan apa-apa apabila digesa untuk memasukkan frasa laluan. Atau anda boleh melumpuhkan ciri frasa laluan."
    ],
    title: "Ungkapan laluan dilumpuhkan"
  },
  summary: {
    button: "Dayakan frasa laluan",
    title: "Ringkasan",
    understand: "Saya faham cara frasa laluan berfungsi dan risiko yang berkaitan dengannya.",
    understandList: [
      "Frasa laluan ialah lapisan keselamatan tambahan di atas sandaran anda.",
      "Memasukkan frasa laluan yang berbeza akan sentiasa menghasilkan dompet yang berbeza.",
      "Untuk memulihkan dompet anda yang anda perlukan <strong>kedua-dua frasa laluan dan sandaran</strong>.",
      "Jika anda terlupa frasa laluan anda, anda tidak lagi boleh mengakses syiling anda."
    ]
  },
  what: {
    button: "Ketahui cara ini berfungsi",
    message: "Dompet dicipta (berasal) daripada nombor rawak yang sangat besar, juga dikenali sebagai benih. Benih ini dicipta apabila anda mula-mula menyediakan BitBox02 anda dan disandarkan dengan kad microSD atau perkataan pemulihan. Sesiapa sahaja yang mempunyai akses kepada benih mempunyai kawalan penuh ke atas dana pada dompet itu.\n\nFrasa laluan ialah <strong>rahsia pilihan</strong>, ditambah kepada benih. Apabila menggunakan frasa laluan, setiap frasa laluan mencipta dompet baharu berdasarkan benih + frasa laluan (rahsia pilihan). Frasa laluan boleh jadi apa-apa sahaja: huruf, perkataan, aksara khas atau malah boleh kosong. Dompet lalai sebenarnya berasal daripada benih + frasa laluan kosong.\n\nFrasa laluan adalah sebahagian daripada standard BIP39, yang bermaksud ia serasi dengan semua dompet yang menyokong standard yang sama.",
    title: "Apakah frasa laluan?"
  },
  why: {
    button: "Mengapa menggunakan frasa laluan",
    message: 'BitBox02 melindungi benih daripada pengekstrakan daripada peranti itu sendiri, tetapi sandaran (kad mikroSD atau perkataan pemulihan) memberikan akses penuh kepada dompet. Itulah sebabnya ia harus disimpan di lokasi yang selamat!\n\nMemandangkan frasa laluan mencipta dompet baharu menggunakan benih sedia ada anda, frasa laluan-dompet memerlukan kedua-dua anda <strong>sandaran DAN frasa laluan untuk memulihkan</strong>. Faedah ini ialah jika seseorang menemui sandaran anda, mereka masih memerlukan frasa laluan untuk mengakses dompet frasa laluan.\n\nSelain itu, ciri frasa laluan membolehkan anda membuat berbilang dompet pada peranti yang sama, atau "dompet tersembunyi" sebagai tambahan kepada dompet lalai.',
    title: "Mengapa menggunakan frasa laluan?"
  }
};
const password$b = {
  show: "Tunjukkan {{label}}",
  warning: {
    caps: "AMARAN: kunci caps () diaktifkan",
    paste: 'untuk menampal teks, aktifkan "SHOW {{label}}"'
  }
};
const random$c = {
  button: "Menjana Nombor Rawak",
  description: "BitBox anda telah menjana nombor rawak {{bits}}-bit berikut:"
};
const receive$d = {
  bitsuranceWarning: "Ini ialah akaun yang diinsuranskan, bermakna ia hanya boleh menerima kepada Native Segwit. Ini supaya anda tidak menerima secara tidak sengaja kepada Wrapped Segwit atau Taproot, yang tidak diinsuranskan.",
  changeScriptType: "Tukar jenis alamat",
  label: "Alamat anda",
  onlyThisCoin: {
    description: "Untuk menerima token lain, dayakannya dalam tetapan. Jika anda mendepositkan token lain, ia mungkin tidak boleh diakses.",
    warning: "Pastikan hanya menerima {{coinName}} pada alamat ini."
  },
  scriptType: {
    p2tr: "Akar Tunjang (format terbaharu)",
    p2wpkh: "Segwit asli (lalai)",
    "p2wpkh-p2sh": "Wrapped Segwit (format yang serasi)"
  },
  selectAccount: "Pilih akaun",
  showFull: "Tunjukkan dan sahkan alamat lengkap",
  taprootWarning: "Nota: Taproot ialah ciri Bitcoin baharu dan belum diterima pakai secara meluas. Dana yang diterima pada alamat Taproot mungkin tidak kelihatan dalam dompet jam tangan pihak ketiga sahaja. Banyak dompet dan pertukaran belum dapat dihantar ke alamat Taproot.",
  title: "Dapatkan syiling",
  verify: "Sahkan alamat dengan selamat",
  verifyBitBox01: "Sahkan alamat pada apl mudah alih",
  verifyBitBox02: "Sahkan alamat pada BitBox02",
  verifyInstruction: "Sila sahkan bahawa alamat berikut sepadan dengan yang dipaparkan pada peranti anda.",
  warning: {
    secureOutput: "Sila pasangkan BitBox anda dengan peranti mobile anda untuk menghidupkan pengesahan alamat selamat. Pergi ke 'Urus Peranti' pada bar sisi."
  }
};
const reset$b = {
  description: "Semua data pada peranti akan dihapus. Itu termasuk Private Key anda!",
  notReset: "Peranti BELUM ditetapkan semula.",
  title: "Tetapkan semula peranti",
  understand: "Saya mempunyai backup dan mengetahui kata laluan pemulihan saya",
  understandBB02: "Saya mempunyai sandaran yang sah"
};
const securityInformation$b = {
  create: {
    description1: "Sebelum menetapkan peranti anda, disarankan agar anda dalam persekitaran yang selamat.",
    description2: "Anda akan diminta untuk membuat dua kata laluan.",
    description3: "Yang pertama adalah <strong> kata laluan peranti </strong> yang digunakan untuk membuka peranti BitBox anda dan boleh diubah kemudian.",
    description4: "Yang kedua ialah <strong>kata laluan pemulihan</strong> yang digunakan untuk membuka wallet anda. Kata laluan ini tidak boleh diubah kemudian.",
    description5: "Wallet yang anda buat akan dibackupkan kepada fail pada kad micro SD yang disediakan. Ini boleh digunakan dalam kecemasan untuk memulihkan wang anda menggunakan <strong> kata laluan pemulihan </strong> anda.",
    title: "Maklumat Keselamatan"
  },
  restore: {
    description1: "Anda akan diminta untuk memasukkan kad micro SD yang digunakan untuk menyimpan backup.",
    description2: "Untuk memulihkan peranti, anda memerlukan kata laluan pemulihan anda.",
    description3: "Sila berhati-hati semasa memasukkan kata laluan pemulihan. Sebarang kata laluan yang anda masukkan akan membuat wallet yang sah. Jika anda memasukkan kata laluan yang salah, anda mungkin akan mendapatkan baki wallet yang tidak anda harapkan.",
    title: "Maklumat Keselamatan"
  }
};
const seed$b = {
  agreements: {
    "funds-access": "Saya TIDAK akan dapat mengakses dana saya jika saya lupa kata laluan pemulihan saya",
    "password-change": "Saya TIDAK dapat menukar kata laluan pemulihan di kemudian hari",
    "password-required": "Kata laluan pemulihan diperlukan untuk memulihkan dompet dari backup"
  },
  create: "Buat Wallet",
  creating: "Membuat dompet",
  description: "Saya faham bahawa:",
  error: {
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e200: "Anda perlu memasukkan kad micro SD ke dalam BitBox anda untuk membuat wallet, agar backup boleh dibuat secara automatik."
  },
  info: {
    button: "Tetapkan kata laluan pemulihan sekarang",
    description1: "Masukkan kad micro SD ke dalam BitBox",
    description2: 'Pilih kata laluan pemulihan untuk wallet dan pilih "Tetapkan kata laluan pemulihan sekarang"',
    description3: "Backup ke kad micro SD dan kata laluan pemulihan anda adalah satu-satunya cara untuk mendapatkan semula wang anda, sekiranya peranti BitBox hilang atau dicuri.",
    description4: "Anda tidak dapat mengganti kata laluan pemulihan anda di kemudian hari tanpa memindahkan wang anda.",
    title: "Buat wallet baru"
  },
  password: {
    label: "Kata laluan pemulihan",
    repeatPlaceholder: "Ulangi kata laluan pemulihan"
  },
  walletName: {
    label: "Nama Wallet"
  }
};
const seedRestore$b = {
  error: {
    e200: "Untuk memulihkan wallet dari backup memerlukan kad micro SD."
  },
  info: {
    description1: 'Masukkan kad micro SD ke BitBox dan klik "Teruskan"',
    description2: 'Pilih backup pada dan klik "Simpan semula"',
    description3: "Masukkan kata laluan pemulihan",
    description4: "Anda perlu mengesahkan untuk memahami bahawa kata laluan salah akan membuat dompet yang berbeza.",
    title: "Bagaimana cara memulihkan wallet dari backup"
  }
};
const send$d = {
  abort: "Transaksi telah ditinggalkan.",
  address: {
    label: "Alamat Penerima",
    placeholder: "Masukkan alamat"
  },
  amount: {
    label: "Jumlah",
    placeholder: "Masukkan jumlah"
  },
  availableBalance: "Baki yang ada",
  button: "Tandatangan dan Hantar",
  coincontrol: {
    address: "Alamat",
    outpoint: "Outpoint",
    title: "Hantar dari Output"
  },
  confirm: {
    "selected-coins": "Syiling yang dipilih",
    title: "Sahkan Transaksi",
    total: "Jumlah"
  },
  error: {
    erc20InsufficientGasFunds: "Nampaknya anda tidak mempunyai Eter yang mencukupi untuk membayar transaksi ERC20 ini. Sila pastikan anda memegang cukup Eter dalam dompet anda",
    feeTooLow: "bayaran terlalu rendah",
    feesNotAvailable: "Tidak dapat menganggarkan bayaran",
    insufficientFunds: "Dana tidak mencukupi",
    invalidAddress: "alamat tidak sah",
    invalidAmount: "jumlah tidak sah",
    invalidData: "data tidak sah"
  },
  fee: {
    customPlaceholder: "Masukkan jumlah",
    label: "Yuran Rangkaian",
    placeholder: "Tidak tersedia"
  },
  feeTarget: {
    customLabel: "Kadar bayaran",
    customLabel_eth: "Harga gas",
    description: {
      economy: "24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)",
      economy_eth: "30 minit atau kurang",
      economy_ltc: "1 jam (24 blok)",
      high: "2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)",
      high_eth: "30 saat atau kurang",
      high_ltc: "5 minit (2 blok)",
      low: "12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)",
      low_eth: "5 minit atau kurang",
      low_ltc: "30 minit (12 blok)",
      normal: "6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)",
      normal_eth: "2 minit atau kurang",
      normal_ltc: "15 minit (6 blok)"
    },
    estimate: "Anggaran masa pengesahan:",
    label: {
      custom: "Adat",
      economy: "ekonomi",
      high: "tinggi",
      low: "rendah",
      normal: "normal"
    },
    placeholder: "Mengira bayaran anggaran ..."
  },
  maximum: "Hantar semua",
  maximumSelectedCoins: "Hantar syiling terpilih",
  noFeeTargets: "Anggaran kadar yuran tidak tersedia pada masa ini. Sila cuba sebentar lagi atau masukkan yuran tersuai.",
  priority: "Keutamaan",
  scanQR: "Imbas Kod QR",
  signprogress: {
    description: "Ini adalah transaksi yang mengandung banyak data. Untuk menandatangani transaksi dengan sepenuhnya, anda akan diminta untuk mengesahkan sebanyak {{steps}} kali.",
    label: "Kemajuan"
  },
  success: "Transaksi telah ditandatangani dan dihantar.",
  title: "Hantar syiling",
  toggleCoinControl: "Toggle Kawalan Syiling",
  transactionDetails: "Butiran transaksi"
};
const settings$c = {
  about: "Tentang aplikasi",
  accounts: "Akaun",
  advancedSettings: "Tetapan lanjutan",
  appearance: "Penampilan",
  electrum: {
    add: "Tambah server",
    "add-server": "Tambah",
    check: "Periksa",
    checkFailed: "Gagal",
    checkSuccess: "Berhasil menubuhkan sambungan ke {{host}}",
    checking: "Memeriksa",
    "download-cert": "Muat turun sijil jauh",
    "remove-server": "Hapus",
    removeConfirm: "Hapus {{server}}?",
    reset: "Tetapkan semula kepada tetapan standard",
    resetConfirm: "Apakah anda mahu menyingkirkan semua server dan memasang server standard?",
    servers: "Server",
    step1: "1",
    "step1-text": "Masukkan titik akhir.",
    step2: "2",
    "step2-text": "Masukkan sijil dari rantai sijil server. Secara alternatif, muat turun sijil jauh dan bandingkan secara visual.",
    "step2-text-tcp": "Anda boleh melangkau langkah ini jika anda tidak mahu menggunakan TLS.",
    step3: "3",
    "step3-text": "Semak sambungan dan tambahkan server.",
    step4: "4",
    "step4-text": "Mulakan semula wallet anda. Jika anda tidak menyingkirkan server standard, nod anda akan ditambah sebagai redundansi.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Hidupkan kawalan syiling",
    electrum: {
      description: "Anda boleh menyambung ke nod penuh Electrum anda sendiri.",
      title: "Sambung nod penuh anda sendiri"
    },
    fee: "Dayakan yuran tersuai",
    setProxyAddress: "Tetapkan alamat proksi",
    title: "Tetapan Pakar",
    useProxy: "Dayakan proksi tor",
    useSats: "Paparkan nilai BTC dalam Satoshis"
  },
  header: {
    home: "Rumah"
  },
  info: {
    "out-of-date": "Kemas kini baharu tersedia",
    title: "info",
    "up-to-date": "Apl anda adalah terkini",
    version: "Versi Apl"
  },
  restart: "Sila mulakan semula BitBoxApp untuk perubahan berkuat kuasa.",
  services: {
    title: "Perkhidmatan"
  },
  success: "Sila cabut dan pasang kembali BitBox agar perubahan dapat berlaku.",
  title: "Tetapan"
};
const setup$b = "Menetapkan peranti";
const sidebar$c = {
  buy: "Beli kripto",
  device: "Urus Peranti",
  insurance: "Insurans",
  leave: "Tinggalkan",
  settings: "Tetapan"
};
const success$i = {
  create: {
    info1: "Dompet anda telah dibackupkan dengan selamat ke kad micro SD. Tarik keluar kad micro SD dan simpan dengan selamat.",
    info2: "Anda telah membuat kata laluan peranti yang selamat yang dapat membuka BitBox.",
    info3: "Anda telah membuat kata laluan pemulihan yang selamat untuk wallet anda yang dapat membuka wang anda dan mengembalikan backup anda.",
    summary: "Berikut adalah ringkasan dari apa yang telah anda lakukan",
    title: "Berjaya"
  },
  getstarted: "Bermula",
  restore: {
    summary: "Anda telah berjaya memulihkan wallet dari backup anda.",
    title: "Berjaya"
  }
};
const transaction$c = {
  confirmation: "Pengesahan",
  details: {
    activity: "Aktiviti",
    address: "Alamat",
    amount: "Jumlah",
    date: "Tarikh",
    fiat: "Fiat",
    fiatAmount: "Jumlah Fiat",
    fiatAtTime: "Fiat pada masa transaksi",
    status: "Status",
    title: "butiran transaksi",
    type: "taip"
  },
  explorer: "ID Transaksi",
  explorerTitle: "Buka dalam blok Explorer luaran",
  fee: "Yuran",
  fiatHistorical: "Sejarah",
  gas: "Gas",
  note: {
    edit: "Edit nota",
    save: "Simpan nota"
  },
  pending: "Transaksi Menunggu",
  size: "Saiz",
  status: {
    complete: "lengkap",
    failed: "Gagal",
    pending: "Yang belum selesai"
  },
  tx: {
    received: "Diterima kepada",
    sent: "Dihantar kepada"
  },
  vsize: "Saiz maya",
  weight: "Berat"
};
const transactions$b = {
  errorLoadTransactions: "Terdapat ralat semasa memuatkan urus niaga",
  placeholder: "Belum ada transaksi."
};
const unknownError$b = "Kesalahan yang tidak diketahui muncul: {{errorMessage}}";
const unlock$b = {
  description: "Masukkan kata laluan peranti anda untuk membuka peranti.",
  error: {
    e109_normal: "Kata laluan peranti salah. Masih ada {{remainingAttempts}} percubaan sebelum peranti diset semula.",
    e109_touch: "$t(unlock.error.e109_normal) Menahan butang sentuhan diperlukan pada log masuk berikutnya",
    e113: "Oleh kerana banyaknya percubaan masuk, menahan butang sentuhan selama 4 saat diperlukan pada log masuk berikutnya ."
  },
  input: {
    label: "Kata laluan peranti",
    placeholder: "Masukkan kata laluan peranti anda"
  },
  unlocking: "Membuka ..."
};
const upgradeFirmware$c = {
  button: "Tingkatkan firmware",
  description: "Apakah anda mahu menaik taraf Firmware dari versi {{currentVersion}} ke {{newVersion}}?",
  label: "Peningkatan firmware diperlukan untuk BitBox anda.",
  locked: "Untuk menaik taraf dari {{currentVersion}} ke {{newVersion}}, sila buat sentuhan panjang.",
  title: "Tingkatkan Firmware",
  unlocked: "Bootloader terbuka. Untuk meneruskan, sila:",
  unlocked1: "Tarik keluar dan pasang ulang BitBox anda",
  unlocked2: "LED akan menyala apabila BitBox anda terpasang kembali",
  unlocked3: "Tekan butang sentuh apabila LED menyala"
};
const walletConnect$7 = {
  connect: {
    button: "Sambung",
    dappLabel: "Masukkan alamat URI dapp",
    invalidPairingUri: "Uri gandingan tidak sah"
  },
  dashboard: {
    allSessions: "Semua sesi",
    disclaimer: "Walletconnect ialah protokol untuk menyambung ke Dapps berasaskan Ethereum. Dapps ini dijalankan oleh perkhidmatan pihak ketiga, jadi hanya sambungkan kepada dapps yang anda percayai dan pastikan anda sentiasa mengetahui perkara yang anda tandatangani semasa membuat transaksi.",
    newConnection: "Sambungan baharu",
    noConnectedSessions: "Tiada akaun disambungkan ke mana-mana dapp pada masa ini."
  },
  invalidPairingChain: "Ralat dalam meluluskan gandingan. Sila pastikan anda menggunakan salah satu rangkaian yang disokong: {{chains}}",
  pairingRequest: {
    approve: "Luluskan Sambungan",
    reject: "Tolak",
    title: "Permintaan sambungan baharu daripada"
  },
  pairingSuccess: "Dapp berjaya disambungkan. Anda boleh teruskan di laman web dapp.",
  signingRequest: {
    account: "Akaun",
    chain: "Rantai",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Gagal menghuraikan data",
    decodeError: "Gagal menyahkod mesej",
    method: {
      sendTransaction: "Tandatangan dan hantar transaksi",
      signMessage: "Tandatangan mesej",
      signTransaction: "Tandatangani transaksi",
      signTypedData: "Tandatangani data yang ditaip"
    },
    successfullySigned: "Permintaan berjaya ditandatangani",
    walletConnectRequest: "Permintaan WalletConnect"
  },
  useNewUri: "URI ini telah digunakan untuk mencuba sambungan. Sila gunakan URI baharu.",
  walletConnect: "WalletConnect"
};
const warning$h = {
  receivePairing: "Sila pasangkan BitBox untuk membolehkan pengesahan alamat dengan selamat. Pergi ke 'Uruskan Peranti' pada bar sisi.",
  sdcard: "Pastikan kad micro SD disimpan berasingan dari BitBox, kecuali jika anda mahu mengurus backup.",
  sendPairing: "Sila pasang BitBox untuk mengesahkan butiran transaksi dengan selamat. Pergi ke 'Urus Peranti' di bar sisi."
};
const welcome$b = {
  connect: "Sambungkan BitBox02",
  getStarted: "Mari mulakan dengan memasang perisian tegar pada BitBox02 anda.",
  insertBitBox02: "Untuk BitBox02, sila ketik peranti untuk meneruskan.",
  insertDevice: "Sila sambungkan peranti anda untuk memulakan",
  title: "Selamat datang"
};
const appTranslationsMS = {
  account: account$b,
  accountInfo: accountInfo$b,
  accountSummary: accountSummary$b,
  addAccount: addAccount$c,
  aopp: aopp$5,
  app: app$b,
  auth: auth$6,
  backup: backup$b,
  bb02Bootloader: bb02Bootloader$b,
  bitbox: bitbox$b,
  bitbox02Interact: bitbox02Interact$b,
  bitbox02Settings: bitbox02Settings$b,
  bitbox02Wizard: bitbox02Wizard$b,
  bitsurance: bitsurance$5,
  bitsuranceAccount: bitsuranceAccount$5,
  blink: blink$b,
  bootloader: bootloader$b,
  button: button$g,
  buy: buy$7,
  changePin: changePin$b,
  chart: chart$7,
  checkSDcard: checkSDcard$b,
  clickHere: clickHere$b,
  confirm: confirm$d,
  confirmOnDevice: confirmOnDevice$b,
  connectKeystore: connectKeystore$6,
  darkmode: darkmode$6,
  device: device$b,
  deviceLock: deviceLock$b,
  deviceSettings: deviceSettings$b,
  deviceTampered: deviceTampered$b,
  dialog: dialog$c,
  error: error$7,
  fiat: fiat$d,
  footer: footer$d,
  generic: generic$7,
  genericError: genericError$b,
  goal: goal$b,
  guide: guide$c,
  headerssync: headerssync$b,
  hiddenWallet: hiddenWallet$b,
  initialize: initialize$b,
  invalidFormat: invalidFormat$b,
  language: language$c,
  legacyhiddenwallet: legacyhiddenwallet$b,
  loading: loading$b,
  manageAccounts: manageAccounts$5,
  mobile: mobile$6,
  newSettings: newSettings$5,
  note: note$7,
  notification: notification$b,
  pairing: pairing$b,
  passphrase: passphrase$5,
  password: password$b,
  random: random$c,
  receive: receive$d,
  reset: reset$b,
  securityInformation: securityInformation$b,
  seed: seed$b,
  seedRestore: seedRestore$b,
  send: send$d,
  settings: settings$c,
  setup: setup$b,
  sidebar: sidebar$c,
  success: success$i,
  transaction: transaction$c,
  transactions: transactions$b,
  unknownError: unknownError$b,
  unlock: unlock$b,
  upgradeFirmware: upgradeFirmware$c,
  walletConnect: walletConnect$7,
  warning: warning$h,
  welcome: welcome$b
};
const account$a = {
  disconnect: "Verbinding verbroken. Opnieuw aan het verbinden...",
  "export": "Exporteren",
  exportTransactions: "Transacties als CSV bestand naar de downloads map exporteren",
  fatalError: "Er is een onverwachte fout opgetreden",
  incoming: "Inkomende",
  initializing: "Blockchain wordt gesynchroniseerd",
  insuranceExpired: "<strong>Account niet meer verzekerd</strong>\nDe verzekering voor dit account is gewijzigd. Kijk op de verzekeringspagina voor meer informatie.",
  insured: "Verzekerde account",
  maybeProxyError: "De Tor Proxy staat ingeschakeld. Zorg ervoor dat deze correct werkt, of schakel de proxy-instelling uit.",
  reconnecting: "Verbinding verbroken, opnieuw aan het verbinden...",
  syncedAddressesCount: "{{count}} adressen gescand",
  uncoveredFunds: "Je heb coins op de volgende niet-verzekerde addressen van je <strong>{{name}}</strong> account: {{uncovered}}.\nJe account is verzekerd, maar alleen coins die via het <strong>Native Segwit</strong> adrestype ontvangen worden, zijn gedekt. Coins op een ander adrestype zijn niet gedekt, ook al zijn de adressen onderdeel van hetzelfde account.\nStuur alsjeblieft al je coins van de niet-ondersteunde adrestypes naar het <strong>Native Segwit</strong> adrestype, zodat alle coins op dit account verzekerd zijn.",
  uncoveredFundsLink: "Volg deze handleiding over hoe je je coins kunt verplaatsen.",
  warning: "Waarschuwing!"
};
const accountInfo$a = {
  address: "Adres",
  buyCTA: {
    buy: "Koop {{unit}}",
    buyCrypto: "Koop Crypto",
    information: {
      looksEmpty: "Het lijkt erop dat deze wallet leeg is.",
      start: "Begin door coins naar deze wallet te sturen, of direct vanuit de BitBoxApp te kopen."
    }
  },
  extendedPublicKey: "Uitgebreide publieke sleutel",
  label: "Accountinformatie",
  scriptType: "Script-type",
  title: "Accountinformatie",
  verify: "Verifieer op je adres",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy P2PKH uitgebreide publieke sleutel weergeven",
    p2tr: "Taproot weergeven",
    p2wpkh: "Native SegWit weergeven",
    "p2wpkh-p2sh": "Oude SegWit uitgebreide publieke sleutel weergeven"
  },
  xpubTypeInfo: "Op dit moment wordt nummer {{current}} van de {{numberOfXPubs}} {{scriptType}} uitgebreide publieke sleutels weergegeven"
};
const accountSummary$a = {
  availableBalance: "Beschikbare balans",
  balance: "Balans",
  exportSummary: "Accounts als CSV bestand naar de downloads map exporteren",
  fiatBalance: "Fiat balans",
  name: "Accountnaam",
  noAccount: "Er zijn geen accounts om weer te geven",
  subtotalWithCoinName: "Totaal ({{coinName}})",
  title: "Mijn portfolio",
  total: "Totaal",
  transactionHistory: "Transactiegeschiedenis"
};
const addAccount$b = {
  chooseName: {
    nextButton: "Account toevoegen",
    step: "Account benoemen",
    title: "Geef je account een naam"
  },
  selectCoin: {
    nextButton: "Volgende",
    step: "Coin selecteren",
    title: "Cryptovaluta selecteren"
  },
  success: {
    addAnotherAccount: "Voeg een account toe",
    message: "<strong>{{accountName}}</strong> is aan je accounts toegevoegd",
    nextButton: "Klaar",
    step: "Afgerond",
    title: "Account toegevoegd"
  },
  title: "Account toevoegen"
};
const aopp$4 = {
  addressRequest: "Er wordt een ontvangstadres aangevraagd door {{host}}",
  addressRequestWithLogo: "vraagt een ontvangstadres aan",
  banner: "Adresaanvraag in behandeling",
  errorTitle: "Foutmelding tijdens adresaanvraag",
  labelAddress: "Adres",
  labelMessage: "Bericht",
  reverifyInfoText: "Adres verifiren",
  signing: "Onderteken het bericht op je BitBox02 om door te gaan",
  success: {
    message: "Ga door op {{host}}",
    title: "Adres verzonden"
  },
  syncing: "Account aan het synchroniseren, even geduld",
  title: "Adresaanvraag"
};
const app$a = {
  upgrade: "Er is een nieuwe versie van de app beschikbaar! Upgrade nu van versie {{current}} naar {{version}}>"
};
const auth$5 = {
  authButton: "Inloggen\n",
  title: "Log in om door te gaan"
};
const backup$a = {
  check: {
    checking: "Backup aan het controleren...",
    confirmTitle: "Controleer backup",
    notOK: "De backup komt NIET overeen met de wallet",
    ok: "Backup komt overeen met de wallet",
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      showLabel: "herstelwachtwoord"
    },
    success: "Backup geverifieerd:",
    title: "Controleer backup"
  },
  create: {
    alreadyExists: "Je hebt al een valide backup. Wil je deze opnieuw maken?",
    fail: "Backup is NIET gemaakt!",
    info: "Voer het herstelwachtwoord van de huidige wallet in.",
    name: {
      label: "Backup naam",
      placeholder: "Geef de backup een naam"
    },
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Voer alsjeblieft je herstelwachtwoord in"
    },
    title: "Creer backup",
    verificationFailed: "Het herstelwachtworod komt NIET overeen met de huidige wallet. De backup is aangemaakt. Gebruik 'Check backup' om je herstelwachtwoord nogmaals te verifiren."
  },
  description: "Selecteer <strong>wallet backup bestand</strong>",
  insert: "Voer de microSD kaart in om je backups te beheren",
  insertButton: "Ik heb de microSD kaart ingevoerd",
  list: "Jouw microSD kaart backups",
  noBackups: "Er zijn geen backups op deze microSD kaart aanwezig.",
  restore: {
    confirmTitle: "Backup herstellen",
    error: {
      e200: "microSD kaart niet gevonden",
      general: "Fout tijdens het herstellen van de backup"
    },
    password: {
      label: "Herstelwachtwoord of verborgen herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      repeatPlaceholder: "Herstelwachtwoord herhalen",
      showLabel: "Herstelwachtwoord"
    },
    restoring: "Backup aan het herstellen",
    selectedBackup: "De backup <strong>{{backupName}}</strong>, aangemaakt op {{createdDateTime}}, wordt hersteld",
    title: "Herstellen",
    understand: ""
  },
  showMnemonic: {
    description: "Je ziet zometeen de 24 herstelwoorden die de backup van je wallet vormen. Schrijf ze op papier op.\n<strong>Sla ze niet digitaal op en neem er geen foto's van</strong>\n<strong>Zeg de woorden niet hardop</strong>\n<strong>Deze backup is niet beschermd met een wachtwoord</strong>\nAchteraf word je gevraagd ieder woord te bevestigen",
    title: "Herstelwoorden tonen",
    warning: "<strong>Deel je herstelwoorden nooit, met wie dan ook!</strong> Met je herstelwoorden kan iemand volledige toegang tot je wallet krijgen. Als iemand je om je herstelwoorden vraagt, is dit vrijwel altijd een oplichter."
  },
  title: "Backups beheren"
};
const bb02Bootloader$a = {
  abort: "Terug - doe de update niet",
  abort_noUpgrade: "Breng me terug",
  advanced: {
    label: "Geavanceerde instellingen",
    toggleShowFirmwareHash: "Toon de firmware hash iedere keer tijdens het opstarten"
  },
  flipscreen: "Scherm omkeren",
  orientation: "Tekst op je BitBox ondersteboven?",
  success: "Upgrade voltooid! Verder in {{rebootSeconds}} seconden...",
  success_install: "Installatie voltooid! Verder in {{rebootSeconds}} seconden..."
};
const bitbox$a = {
  error: {
    e10000: "Huidig apparaatwachtwoord incorrect",
    e10001: "Het veranderen van het wachtwoord is niet gelukt",
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e112: "Het verborgen apparaatwachtwoord kan niet hetzelfde zijn als het hoofdwachtwoord."
  }
};
const bitbox02Interact$a = {
  confirmDate: "Bevestig de huidige datum op je BitBox02",
  confirmDateText: "Deze datum wordt gebruikt om je backup te maken.",
  confirmName: "Bevestig naam op je BitBox02",
  confirmWords: "Schrijf de {{amount}}",
  confirmWordsText: "Hierna vraagt de BitBox je om ieder woord te bevestigen zodat je zeker weet dat de backup correct is.",
  followInstructions: "Volg de instructies op je BitBox02",
  followInstructionsMnemonic: "Volg de instructies op je BitBox02 om te herstellen met je herstelwoorden.",
  followInstructionsMnemonicTitle: "Met herstelwoorden herstellen"
};
const bitbox02Settings$a = {
  deviceName: {
    current: "Huidige naam",
    error: "Het is niet gelukt de naam in te stellen.",
    error_104: "Het instellen van de naam is afgebroken door de BitBox.",
    input: "BitBox02 naam",
    placeholder: "Nieuwe naam",
    title: "BitBox02 naam instellen"
  },
  gotoStartupSettings: {
    description: "",
    title: "Ga naar opstartinstellingen"
  }
};
const bitbox02Wizard$a = {
  advanced: {
    button: "Geavanceerde opties",
    outOfDate: "Deze optie is niet beschikbaar voor deze firmware-versie",
    seed12WordInfo: "De hoeveelheid woorden kan niet veranderd worden nadat je de wallet hebt aangemaakt.",
    seed12WordLabel: "Seed met 12 ipv 24 herstelwoorden aanmaken",
    seed12WordText: 'De BitBox maakt standaard een backup met 24 herstelwoorden aan. Backups met zowel 12 als 24 woorden zijn in de praktijk veilig tegen "brute force" aanvallen. ',
    skipSDCardLabel: "MicroSD backup overslaan en herstelwoorden opschrijven",
    skipSDCardText: "Je hebt altijd de mogelijkheid om via de instellingen alsnog een microSD- of herstelwoord-backup te maken.",
    title: "Geavanceerde backup-opties"
  },
  attestationFailed: "Validiteitscheck niet gehaald. Dit kan gebeuren als de app opnieuw wordt opgestart terwijl de BitBox wachtte op input. Probeer de BitBox opnieuw te verbinden. Neem contact op met support@bitbox.swiss als dit probleem blijft voortbestaan.",
  backup: {
    point1: "Selecteer een backup op de microSD kaart",
    point2: "Stel een wachtwoord in voor je apparaat",
    restoreText: "Ok, laten we een backup herstellen!",
    text1: "Je BitBox02 wachtwoord is ingesteld en je wallet is aangemaakt. Nu gaan we je eerste backup instellen. Zorg dat je microSD kaart is ingevoerd in de BitBox02 en ga verder.",
    text2: "Volg de instructies op je BitBox om een backup te maken.",
    text3: "Verwijder de microSD kaart en sla hem op in een <strong>veilige locatie</strong> nadat je backup is aangemaakt. De inhoud van de microSD kaart is niet beveiligd met een wachtwoord. Voer je microSD kaart nooit in een ander apparaat dan je BitBox02 in.",
    userConfirmation1: "Ik zal mijn backup in een veilige locatie opslaan.",
    userConfirmation2: "Mijn backup is niet beveiligd met een wachtwoord. Iedereen die er toegang tot heeft, heeft toegang tot mijn wallet.",
    userConfirmation3: "Als ik mijn BitBox02 verlies of beschadig, is de backup mijn enige manier om weer toegang tot mijn wallet te krijgen.",
    userConfirmation4: "Als ik mijn BitBox02 n mijn backup verlies of beschadig, is mijn wallet permanent verloren.",
    userConfirmation5: "Ik moet mijn microSD kaart niet in een computer, telefoon, printer of ieder ander apparaat dan een BitBox02 invoeren.",
    userConfirmation5mnemonic: "Ik snap dat ik mijn herstelwoorden NOOIT in een computer, telefoon, printer of ieder ander apparaat dat geen BitBox is moet invoeren"
  },
  create: {
    button: "",
    info: "Dit zijn de stappen die je gaat nemen om je BitBox in te stellen:",
    inputTitle: "Walletnaam",
    point1: "Geef je BitBox een naam",
    point2: "Stel een wachtwoord voor je BitBox in",
    point3: "Maak een backup",
    text: "Ok, we gaan nu een nieuwe wallet aanmaken!"
  },
  createBackupAborted: "Backup afgebroken",
  createBackupFailed: "Het maken van een backup is niet gelukt, probeer het opnieuw.",
  initialize: {
    passwordText: "Gebruik de touch-sensors op je BitBox om een wachtwoord in te stellen.",
    passwordTitle: "Stel een wachtwoord in voor je BitBox.",
    text: "Je BitBox02 is gekoppeld. Stel hem in door te kiezen voor het maken van een nieuwe wallet, of het herstellen van een backup. <strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
    tip: "We raden je aan in een veilige omgeving door te gaan.",
    title: "Initializeer je BitBox"
  },
  insertSDCard: "<strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
  noPasswordMatch: "De wachtwoorden kwamen niet overeen, probeer het op nieuw.",
  pairing: {
    failed: "Koppeling niet bevestigd. Plug je BitBox opnieuw in.",
    paired: "Je hebt de volgende code op je BitBox bevestigd. Klik om door te gaan.",
    title: "Verifieer koppelcode",
    unpaired: "Er is een nieuwe BitBox02 gedetecteerd. Controleer dat onderstaande code overeenkomt met wat er op je BitBox staat"
  },
  restoreFromMnemonic: {
    e104: "Het herstellen is afgebroken",
    failed: "Herstel is niet gelukt, probeer het nog eens."
  },
  stepBackup: {
    beforeProceed: "Lees deze belangrijke veiligheidsoverwegingen voordat je verder gaat:",
    createBackup: "Je gaat nu een backup op je microSD kaart maken.",
    createBackupMnemonic: "Je gaat nu de herstelwoorden opschrijven"
  },
  stepBackupSuccess: {
    fundsSafe: "Houd rekening met het volgende om je crypto veilig te houden:",
    title: "Backup hersteld!"
  },
  stepConnected: {
    unlock: "Voer je BitBox02 wachtwoord in om te ontgrendelen."
  },
  stepCreate: {
    description: "Deze naam wordt gebruikt als apparaatnaam en voor de backup",
    error: {
      genericMessage: "Gebruik letters, cijfers, symbolen en spaties. Maximaal 30 karakters.",
      invalidChars: "De naam bevat ongeldige karakters: {{invalidChars}}.",
      tooLong: "Naam is te lang"
    },
    nameLabel: "BitBox02 naam",
    namePlaceholder: "Mijn BitBox02",
    title: "Kies een naam voor je BitBox02",
    toastMicroSD: "Zorg dat je microSD kaart is ingevoerd in je BitBox02; deze wordt gebruikt om een backup van je wallet op te slaan."
  },
  stepCreateSuccess: {
    removeMicroSD: "Haal de microSD kaart uit je BitBox02 en bewaar deze in een veilige locatie.",
    storeMnemonic: "Bewaar je herstelwoorden op een veilige locatie",
    success: "Je backup is aangemaakt."
  },
  stepInsertSD: {
    insertSDCard: "Stop een microSD kaart in je BitBox02 om door te gaan.",
    insertSDcardTitle: "Voer microSD kaart in"
  },
  stepPassword: {
    e104: "Het instellen van een wachtwoord is afgebroken",
    title: "BitBox02 wachtwoord instellen",
    useControls: "Gebruik de touch-sensors op je BitBox02 om een wachtwoord in te voeren."
  },
  stepUninitialized: {
    create: "Ik wil een nieuwe BitBox02 instellen.",
    restore: "Ik wil de backup van een bestaande wallet herstellen.",
    restoreMicroSD: "Herstel met microSD kaart",
    restoreMnemonic: "Herstel met herstelwoorden",
    title: "Stel je BitBox02 in"
  },
  success: {
    text: "Gefeliciteerd! Je BitBox02 is nu klaar om te gebruiken.\nVoor meer informatie over het gebruik van de BitBoxApp check je de applicatiehulp door op het icoon rechtsbovenin te klikken.",
    title: "Je bent helemaal klaar!"
  }
};
const bitsurance$4 = {
  dashboard: {
    active: "Verzekering actief",
    button: "Verzeker een nieuw account",
    canceled: "Geannuleerd",
    coverage: "Maximale dekking",
    inactive: "Inactief",
    processing: "In behandeling",
    refused: "Geweigerd",
    supportLink: "Contract beheren",
    title: "Verzekerde accounts",
    waitpayment: "In afwachting van betaling"
  },
  detect: {
    button: "Bestaande verzekering checken",
    insured: "Verzekerde account gevonden:",
    notInsured: "Geen verzekerde accounts gevonden. Als je zeker weet dat je een verzekerde account hebt, kijk dan of je de juiste wallet hebt verbonden.",
    text: "Als je al lid bent van Bitsurance, kan de BitBoxApp automatisch met je bestaande verzekering synchroniseren.",
    title: "Al verzekerd?"
  },
  insure: {
    button: "Bekijk beschikbaarheid en prijzen",
    faq: "Lees meer in de Bitsurance FAQs",
    listItem1: "Diefstal",
    listItem2: "Afpersing of bedreiging",
    listItem3: "Vernietiging door brand, waterschade of natuurrampen",
    month: "maand",
    text: "Verzeker je BitBox02 en tot 100 000 aan bitcoin tegen",
    text2: "Verzekeringen zijn verkrijgbaar vanaf 30 per jaar (2,50 per maand). Je kunt meer te weten komen over Bitsurance en hun verzekeringsaanbod op de",
    text3: "Op dit moment alleen beschikbaar in Duitsland, andere landen volgen later",
    title: "Aan de slag"
  },
  intro: {
    link: "Bitsurance website",
    text1: "BitBox werkt met Bitsurance om een extra laag van bescherming voor je bitcoin te bieden. Waar de BitBox02 je coins beveiligt, dekt Bitsurance ook de dingen die niet op te lossen zijn met technologie, zoals diefstal, afpersing en bedreiging of vernietiging van de hardware wallet zelf."
  },
  terms: {
    link: "Bitsurance privacy policy",
    text1: "Bitsurance is een onafhankelijke dienst van een derde partij. Voor vragen over hun aanbod en voor het doen van verzekeringsclaims kun je direct met Bitsurance contact opnemen.",
    text2: "Verzekeringen zijn op dit moment alleen in Duitsland beschikbaar, andere landen volgen later.",
    text3: "De maximale bitcoin-dekking is op dit moment 100 000 per persoon. Het plan is om in de toekomst ook hogere dekkingen aan te bieden.",
    text4: "Je persoonlijke informatie en de publieke sleutel van je verzekerde account is onderdeel van de verzekering en zal gedeeld worden met Bitsurance en de verzekeringsprovider.",
    text5: "Voor meer over je privacy, raadpleeg je de"
  },
  title: "Verzekering"
};
const bitsuranceAccount$4 = {
  errorNoXpub: "Foutmelding: De xpub voor dit account kon niet gevonden worden.",
  noAccount: "Er zijn geen accounts die verzekerd kunnen worden.",
  select: "Selecteer account",
  title: "Verzekering"
};
const blink$a = {
  button: "Knipperen"
};
const bootloader$a = {
  button: "Firmwareupgrade uitvoeren",
  button_install: "Firmware installeren",
  progress: "Firmwareupgrade wordt uitgevoerd: {{progress}}%",
  progress_install: "Firmware wordt genstalleerd: {{progress}}%",
  success: "Upgrade voltooid! Plug je BitBox opnieuw in. Druk deze keer niet op de knop."
};
const button$f = {
  abort: "Annuleren",
  back: "Terug",
  buy: "Koop",
  changepin: "BitBox-wachtwoord veranderen",
  check: "Backup controleren",
  "continue": "Verder",
  copy: "Kopiren",
  create: "Aanmaken",
  dismiss: "Sluiten",
  done: "Klaar",
  download: "Download",
  hiddenwallet: "Verborgen wallet aanmaken",
  next: "Volgende",
  ok: "OK",
  previous: "Vorige",
  receive: "Ontvangen",
  restore: "Herstellen",
  select: "Selecteren",
  send: "Verzenden",
  unlock: "Ontgrendelen",
  update: "Updaten",
  upgrade: "Upgraden"
};
const buy$6 = {
  exchange: {
    bankTransfer: "Bankoverschrijving",
    bestDeal: "Beste deal",
    creditCard: "Creditcard",
    fast: "Snel",
    fee: "transactiekosten",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankoverschrijving: {{fee}}%",
          creditDebitCard: "Creditcard:  {{fee}}%",
          learnMore: "Lees meer over Moonpay",
          title: "Transactiekosten"
        },
        fullCurrenciesList: "Bekijk hier de hele Valutalijst",
        payment: {
          asteriskText: "* Niet beschikbaar voor inwoners van de VS",
          bankTransfer: "Bankoverschrijving*",
          bankTransferDetails: {
            pix: "PIX (Alleen in Brazili)",
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          creditDebitCard: "Credit/debitkaart",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa en Maestro"
          },
          learnMore: "Zie meer details over betaalmethodes",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "Ondersteunt alle grote fiat-valuta: USD, EUR, CHF en meer"
      },
      pocket: {
        fees: {
          info: "Bankoverschrijving: {{fee}}%",
          title: "Transactiekosten"
        },
        learnMore: "Lees meer over Pocket",
        payment: {
          bankTransfer: "Bankoverschrijving",
          bankTransferDetails: {
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            sic: "Swiss Interbank Clearing (CHF-transacties alleen in CH/LI)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          bankTransferReccuring: "Hoe stel ik regelmatige aankopen in?",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "EUR, GBP en CHF worden ondersteund",
        verification: {
          info: "Vereist alleen identiteitsverificatie boven een dagelijks/jaarlijks limiet",
          link: "Vind de huidige limieten hier",
          title: "Identiteitsverificatie"
        }
      },
      region: {
        title: "Selecteer het land waarin je bankrekening is geregistreerd om de beschikbare opties te zien"
      }
    },
    noExchanges: "Sorry, er zijn geen exchanges beschikbaar in jouw regio",
    region: "Regio",
    selectRegion: "Niet aangegeven",
    title: "Koop {{name}}"
  },
  info: {
    "continue": "Akkoord, verder",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Samen met MoonPay bieden we je een naadloze manier om {{name}} direct in de BitBoxApp te kopen. Het is met een paar kliks gedaan.",
        "MoonPay is een platform dat het snel en makkelijk maakt om {{name}} in meer dan 160 landen te kopen."
      ],
      payment: {
        details: "Je kunt via MoonPay direct {{name}} kopen met de volgende betaalmethodes. Credit- of debitcard aankopen zijn makkelijk en snel, maar zijn duurder omdat de transactie teruggedraaid kan worden. We raden aan om een bankoverschrijving te doen voor grotere hoeveelheden. De minimale kosten zijn 4 euro.",
        footnote: "Houd er rekening mee dat de wisselkoers die MoonPay aanhoudt anders kan zijn dan die in de BitBoxApp, waardoor de hoeveelheden kunnen verschillen.",
        table: {
          "1_description": "Laagste kosten, kan tot 3 werkdagen duren.",
          "1_method": "Bankoverschrijving (SEPA)",
          "2_description": "Hogere kosten, onmiddelijke aankoop",
          "2_method": "Credit- en debitcards",
          description: "Omschrijving",
          fee: "Kosten",
          method: "Methode"
        },
        title: "Betaalmethode en kosten"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "De BitBoxApp verzamelt geen data als je {{name}} koopt, de inkomende transactie wordt als gewone transactie behandeld. MoonPay moet wat persoonlijke data verzamelen om je hun diensten aan te bieden. Hun privacy policy legt in detail uit hoe die data behandeld wordt.",
        descriptionGeneric: "De BitBoxApp verzamelt geen informatie van je als je {{name}} koopt. De inkomende transactie wordt als een normale transactie behandeld. Onze partner-exchanges moeten echter wat informatie verzamelen om hun diensten te kunnen verlenen. Zie hun respectievelijke privacybeleid voor meer informatie over hoe ze met je data omgaan.",
        title: "Databescherming."
      },
      security: {
        description: "Als je {{name}} koopt via MoonPay, gebruik je een externe dienst. Deze dienst valt buiten het BitBox02 Beveiligings- en bedreigingsmodel en vertrouwt op de beveiliging van de omgeving waarin je de BitBoxApp draait.",
        descriptionGeneric: "Als je {{name}} koopt via een van onze partner-exchanges, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait.",
        link: "Beveiliging- en bedreigingsmodel",
        title: "Bedreigingsmodel"
      },
      title: "Welkom bij jouw one-stop-shop om {{name}} te kopen"
    },
    next: "Volgende",
    selectLabel: "Kies je account",
    selectPlaceholder: "Selecteer een coin",
    skip: "Niet nog eens weergeven",
    title: "Koop {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket's privacybeleid",
      p1: "De BitBoxApp verzamelt geen informatie van je als je bitcoin koopt. De inkomende transactie wordt als een normale transactie behandeld. Moet echter wat informatie verzamelen om hun diensten te kunnen verlenen. Pocket's privacybeleid legt in detail uit hoe ze met je data omgaan.",
      title: "Databescherming"
    },
    kyc: {
      link: "Lees de Pocket-FAQs",
      p1: "Pocket probeert KYC tot een minimum te beperken. Voor aankopen van minder dan 950EUR (1000 CHF) per dag, is het uploaden van identificatie-documenten niet nodig. Als je meer dan dit wilt kopen, zul je een gesprek met Pocket in moeten plannen om de benodigde KYC/AML-procedure te doorlopen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Je kunt bij Pocket direct bitcoin kopen met een simpele SEPA bankoverschrijving. De transactiekosten hiervoor zijn 1.5%, en de bitcoin wordt direct naar je BitBox gestuurd (zodra Pocket de bankoverschrijving heeft ontvangen - meestal dezelfde dag nog).",
      p2: "Let er op dat de wisselkoers die Pocket hanteert verschillend kan zijn dan die in de BitBoxApp wordt aangegeven, wat een klein verschil in de hoeveelheden kan opleveren.",
      title: "Betaalmethodes en transactiekosten"
    },
    previousTransactions: "Je deelt een bestaande en gebruikte account met Pocket. Als je dit doet kunnen ze je volledige transactiegeschiedenis en alle toekomstige transacties inzien. Wil je toch doorgaan?",
    security: {
      link: "BitBox02 beveiligings- en bedreigingsmodel",
      p1: "Als je bitcoin koopt via Pocket, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait. We werken echter samen met Pocket om de beveiliging te verbeteren door het adres waar je op ontvangt te controleren met een tweefactor-authenticatiemechanisme.",
      title: "Beveiligingsmodel"
    },
    usedAddress: "Het adres {{address}} is al gebruikt, probeer het opnieuw met een nieuw adres.",
    verifyBitBox02: "Verifieer alsjeblieft of het adres wat je via de mail is toegestuurd hetzelfde is als het adres dat op je BitBox wordt weergegeven. Als het kan, is het het beste om de email op een tweede apparaat te openen.",
    welcome: {
      p1: "Met Pocket kun je binnen een paar kliks direct in de BitBoxApp bitcoin kopen.",
      p2: "Pocket is een Zwitsers platform wat het makkelijk en snel maakt om bitcoin te kopen in bijna heel Europa (overal waar SEPA bankoverschrijvingen beschikbaar zijn).",
      p3: "Met Pocket kun je ook regelmatige aankopen doen door een herhaalopdracht in te stellen bij je bank, zodat je makkelijk een DCA (dollar-cost-averaging) spaarplan in kunt stellen.",
      title: "Welkom bij je one-stop-shop voor bitcoin-aankopen"
    }
  },
  title: "Koop {{name}}"
};
const changePin$a = {
  newTitle: "Nieuw BitBox02 wachtwoord",
  oldLabel: "Huidig BitBox02 wachtwoord"
};
const chart$6 = {
  dataMissing: "Datahistorie aan het verzamelen... even geduld.",
  dataOldTimestamp: "Historische wisselkoersen aan het updaten. De grafiek toont geen data van na {{time}}.",
  dataUpdating: "Data aan het updaten...",
  filter: {
    all: "Alle",
    month: "Maand",
    week: "Week",
    year: "Jaar"
  }
};
const checkSDcard$a = "microSD kaart aan het controleren";
const clickHere$a = "Klik hier";
const confirm$c = {
  abortInfo: "Klik om",
  abortInfoRedText: "annuleren",
  approveInfo: "Houd 4 seconden ingedrukt om te",
  approveInfoGreenText: "bevestigen",
  info: "Ga verder op je BitBox",
  infoWhenPaired: "Eerst op de gekoppelde telefoon en dan op je BitBox"
};
const confirmOnDevice$a = "Bevestig op je BitBox";
const connectKeystore$5 = {
  promptNoName: "Verbind je BitBox02 om verder te gaan",
  promptWithName: 'Verbind de BitBox02 die je "{{name}}" hebt genoemd om verder te gaan'
};
const darkmode$5 = {
  toggle: "Donkere kleurstelling"
};
const device$a = {
  appUpradeRequired: "Je BitBox wordt niet ondersteund door deze desktop applicatie. Download en installeer de laatste versie.",
  keystoreConnected: "Verbonden wallet"
};
const deviceLock$a = {
  button: "Stel tweefactor authenticatie (2FA) in",
  condition1: "Heb je een backup?",
  condition2: "Werkt de mobiele app verificatie?",
  condition3: "2FA stelt backups en app-koppelingen buiten werking. De BitBox moet worden gereset om 2FA uit te zetten!",
  confirm: "Stel tweefactor authenticatie (2FA) in",
  title: "Stel tweefactor authenticatie (2FA) in"
};
const deviceSettings$a = {
  backups: {
    manageBackups: {
      description: "MicroSD kaart backup aanmaken of controleren."
    },
    showRecoveryWords: {
      description: "Herstelwoorden tonen en verifiren."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "De BitBoxApp controleert of je apparaat echt is."
    },
    deviceName: {
      description: "Verander de naam van je apparaat."
    },
    rootFingerprint: {
      description: "Deze vingerafdruk is een unieke identificatie voor de wallet die je op dit moment gebruikt. Het kan je helpen om verschillende wallets uit elkaar te houden, bijvoorbeeld als je een passphrase gebruikt."
    },
    securechip: {
      description: "Secure-chip modelnummer"
    },
    title: "Apparaatinformatie"
  },
  expert: {
    factoryReset: {
      description: "Zet je BitBox terug naar de fabrieksinstellingen - dit verwijdert de wallet uit je BitBox02!",
      title: "Terugzetten naar fabrieksinstellingen"
    },
    goToStartupSettings: {
      description: 'Ga naar de bootloader van de BitBox02. Je kunt hier het laten zien van de "firmware hash" inschakelen.'
    },
    passphrase: {
      description: "Zet de optionele passphrase aan of uit",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware-versie",
    newVersion: {
      label: "Beschikbare versie"
    },
    title: "Firmware",
    upToDate: "Je BitBox is up-to-date",
    upgradeAvailable: "Een nieuwe upgrade is beschikbaar",
    version: {
      label: "Versie"
    }
  },
  hardware: {
    attestation: {
      "false": "Autentiteitscontrole mislukt",
      label: "Autentiteitscontrole",
      "true": "Je hebt een autentieke BitBox02"
    },
    sdcard: {
      "false": "Niet ingevoerd",
      label: "microSD kaart",
      "true": "Ingevoerd"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Apparaatinformatie aan het verzamelen...",
  pairing: {
    lock: {
      "false": "Uitgeschakeld",
      label: "Tweefactor authenticatie (2FA)",
      "true": "Ingeschakeld"
    },
    mobile: {
      "false": "Gesloten",
      label: "Mobiele app",
      "true": "Open"
    },
    status: {
      "false": "Niet gekoppeld",
      label: "Status",
      "true": "Gekoppeld"
    },
    title: "Aan het koppelen"
  },
  secrets: {
    manageBackups: "Backups beheren",
    title: "Geheimen"
  }
};
const deviceTampered$a = "Heb je een herstelwachtwoord gekregen bij de aankoop van je BitBox? Zo ja, moet je onmiddelijk stoppen en ons onmiddelijk contacteren. Shift zal je nooit een kant-en-klare wallet aanbieden of aanbevelingen doen voor je wachtwoorden.";
const dialog$b = {
  cancel: "Annuleren",
  confirm: "Bevestigen",
  confirmTitle: "Bevestiging"
};
const error$6 = {
  accountAlreadyExists: "Deze account bestaat al",
  accountLimitReached: "Kan account niet toevoegen. Je hebt de maximale hoeveelheid accounts voor deze coin.",
  aoppCallback: "Er is een fout opgetreden tijdens het versturen van het adres naar {{host}}",
  aoppInvalidRequest: "Ongeldig verzoek.",
  aoppNoAccounts: "Er zijn geen accounts beschikbaar.",
  aoppSigningAborted: "Verzoek om adreseigenaarschap geannuleerd.",
  aoppUnknown: "Er is een onbekende fout opgetreden.",
  aoppUnsupportedAsset: "Dit token wordt niet ondersteund.",
  aoppUnsupportedFormat: "Er zijn geen accounts beschikbaar die de het verzochte adresformaat ondersteunen.",
  aoppUnsupportedKeystore: "Het verbonden apparaat kan voor deze crypto geen berichten ondertekenen.",
  aoppVersion: "Onbekende versie.",
  keystoreTimeout: "Walletaanvraag verlopen. Probeer het opnieuw.",
  wrongKeystore: "Verkeerde wallet verbonden. Zorg ervoor dat je de juiste BitBox02 voor dit account verbindt.",
  wrongKeystore2: "Als je de optionele passphrase hebt ingeschakeld, zorg er dan voor dat je de juiste passphrase voor dit account hebt ingevoerd."
};
const fiat$c = {
  "default": "Standaard",
  setDefault: "Stel {{code}} in als standaard",
  title: "Valuta's"
};
const footer$c = {
  appVersion: "App versie:"
};
const generic$6 = {
  enabled_false: "Uitgeschakeld",
  enabled_true: "Ingeschakeld"
};
const genericError$a = "Er is een fout opgetreden. Start de applicatie opnieuw op als je problemen tegenkomt.";
const goal$a = {
  buttons: {
    create: "Maak een nieuwe wallet aan.",
    restore: "Herstel een wallet met een backup"
  },
  paragraph: "Selecteer n van de volgende opties:",
  step: {
    "1": {
      title: "Beveiligingsinformatie"
    },
    "2": {
      description: "Stel een apparaatwachtwoord in",
      title: "Apparaat"
    },
    "3-create": {
      description: "Maak een nieuwe wallet aan",
      title: "Wallet"
    },
    "3-restore": {
      description: "met een backup",
      title: "Herstel"
    },
    "4-create": {
      title: "Samenvatting"
    },
    "4-restore": {
      title: "Samenvatting"
    }
  }
};
const guide$b = {
  accountDescription: {
    text: "Je accountpagina laat je beschikbare balansen, en binnenkomende en uitgaande transacties zien. In de instellingen kun je meer informatie vinden over iedere accountsoort.",
    title: "Wat staat er op deze pagina?"
  },
  accountFiat: {
    text: "Ja. Je kunt op iedere 'ticker' klikken om door fiatvaluta te roteren. Je kunt de lijst van valuta's in de instellingen veranderen.",
    title: "Kan ik ook andere wisselkoersen weergeven?"
  },
  accountIncomingBalance: {
    text: "Binnenkomende transacties zijn een som van de hoeveelheden die naar je toe gestuurd zijn, maar nog geen bevestiging hebben van het netwerk.",
    title: "Wat zijn binnenkomende transacties?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Iedere xpub is gekoppeld aan het getoonde 'type': dit is "Native segwit (bech32)", "Wrapped segwit" of "Taproot" (alleen bij Bitcoin). Dit zijn scrypttypes die gebruikt worden door {{coinName}}. De BitBoxApp combineert ze door meerdere scripttypes in dezelfde account te ondersteunen. Omdat ieder scripttype een andere xpub heeft, heb je meerdere xpubs per account.

Als je altijd op het standaardadres ontvangt, heb je alleen de 'bech32' xpub nodig. Als je echter ook (handmatig) ontvangt op je compatibiliteitsadres, staan deze onder de "oudere Segwit" of "Taproot" uitgebreide publieke sleutel (xpub).`,
      title: "Waarom heb ik meerdere xpubs?"
    },
    privacy: {
      text: "Met de uitgebreide publieke sleutel vallen de volledige financile geschiedenis, de balans van je account en alle eventuele toekomstige transacties te achterhalen. Met alleen de xpub heb je echter geen verzendcontrole over de coins.\n\nAls je een xpub aan iemand geeft, moet je je ervan bewust zijn dat deze persoon of dit bedrijf alle transacties van dit account kan zien. Daarom is het handig om accounts waarvan je de xpub weggeeft maar voor n doel te gebruiken, en je andere financin op een ander account te beheren. ",
      title: "Moet ik mijn xpub geheim houden?"
    },
    verify: {
      text: "Ja, het is altijd een goed idee om je xpub te dubbel-checken. Zeker als iemand anders met deze xpub adressen gaat genereren om je geld te sturen is het extra belangrijk. Je verifieert de xpub op je BitBox om er zeker van te zijn dat de xpub van jou is. Anders zullen alle transacties naar een verkeerd adres gaan. ",
      title: "Moet ik de xpub verifiren op mijn BitBox?"
    },
    xpub: {
      text: "Een uitgebreide publieke sleutel (xpub) is de bron waaruit alle ontvangstadressen van een account gemaakt worden. \n\nHet wordt hier weergegeven voor geavanceerde gebruikers en voor ondersteuning van watch-only wallets zoals Electrum of Sentinel. Als je verschillende adrestypes gebruikt, noteer dan alle verschillende xpub-formaten in de watch-only wallet om al je coins te kunnen zien.\n\nLet op dat nog niet alle externe wallets Taproot ondersteunen. ",
      title: "Wat is een uitgebreide publieke sleutel?"
    }
  },
  accountRates: {
    text: "We vernieuwen de wisselkoers iedere minuut gebaseerd op de wisselkoersen van CoinGecko.",
    title: "Welke wisselkoersen gelden er?"
  },
  accountReload: {
    text: "Dat is niet nodig. Je transactiegeschiedenis wordt automatisch gepdatet.",
    title: "Kan ik de transactiegeschiedenis herladen?"
  },
  accountSendDisabled: {
    text: "De verzendknop wordt geactiveerd als de balans van dat account meer dan nul is.",
    title: "Waarom kan ik geen {{unit}} verzenden?"
  },
  accountSummaryAmount: {
    text: "De totale balans is de som van al je crypto-accounts, berekend met de wisselkoers van coingecko.com.\nLet op: Gebruik je MyEtherWallet voor toekens die niet ondersteund worden door de BitBoxApp? Dan worden deze niet meegerekend in dit totaal.",
    title: "Hoe wordt de totale balans berekend?"
  },
  accountSummaryDescription: {
    text: "Hier kun je de prestaties van je gehele portfolio gedurende verschillende tijdsbestekken bekijken. Een overzicht van je individuele crypto-accounts wordt onder de grafiek weergegeven.",
    title: "Wat zie ik op deze pagina?"
  },
  accountTransactionAttributesBTC: {
    text: "Grootte: De daadwerkelijke grootte van de transactie in bytes zoals berekend volgens de onderliggende blockchain.\nVirtuele grootte: Dit bepaalt de netwerkkosten. Je bespaart op kosten als de virtuele grootte kleiner is dan de transactiegrootte.\nGewicht: Een nieuwe meeteenheid die gentroduceerd is met Segwit om de grootte van transacties en blokken te evalueren. Iedere 'segregated witness' byte telt als n gewichtseenheid (weight unit), alle andere data telt als vier. In plaats van n megabyte is de grootte van een block nu vier miljoen weight units.",
    title: "Hoe zit het met de Bitcoin-specifieke transactiedetails?"
  },
  accountTransactionAttributesGeneric: {
    text: "Bevestigingen: Je transactie is onbevestigd totdat een miner het toevoegt aan een block. Op dat moment heeft het n bevestiging. Ieder block wat daarna komt geeft jouw transactie een extra bevestiging. Over het algemeen vereisen winkels en andere mensen op het netwerk drie tot zes bevestigingen.\nTransactie-ID: Een uniek identificatienummer waarmee je je transactie in een block explorer kunt opzoeken.\nTransactiekosten: Miners worden betaald met transactiekosten, die ervoor moet zorgen dat ze jouw transactie in een block opnemen. Klik op 'verzenden' om hier meer over te leren.",
    title: "Welke informatie vind ik in de transactiedetails?"
  },
  accountTransactionConfirmation: {
    text: "Een transactie die is uitgezondern naar het netwerk, maar nog geen bevestigingen heeft. ",
    title: "Wat is een transactie in afwachting?"
  },
  accountTransactionLabel: {
    text: "Dit is het adres waarop je coins hebt ontvangen of naartoe hebt verzonden. ",
    title: "Wat is het adres wat bij iedere transactie wordt weergegeven?"
  },
  accountTransactionTime: {
    text: "De transactiebevestigingstijd op de blockchain",
    title: "Wat is de tijd die wordt weergegeven?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin en Litecoin kunnen zoveel accounts hebben als je wilt. Na vijf accounts kun je pas een nieuwe toevoegen als de vorige account daadwerkelijk gebruikt is voor een transactie. Andere coins hebben een maximum van vijf accounts.",
      title: "Hoeveel accounts kan ik aanmaken?"
    },
    howtoAddTokens: {
      text: 'Tokens die gebruik maken van de ERC20 standaard worden aan een specifieke Ethereum-account gekoppeld. Om een token aan- of uit te zetten, open je het "Accounts beheren" scherm, klik je op je Ethereum account en schakel je de gewenste token in of uit.',
      title: "Hoe kan ik meer tokens toevoegen?"
    },
    moveFunds: {
      text: "Ja, maar omdat accounts onafhankelijk van elkaar zijn, moet je een reguliere transactie maken.",
      title: "Kan ik mijn coins tussen accounts verplaatsen?"
    },
    recoverAccounts: {
      text: "Ja, de BitBoxApp maakt accounts die voldoen aan breed gebruikte standaarden, zodat je accounts compatibel zijn met de meeste andere crypto-wallets.",
      title: "Kan ik mijn accounts in een andere wallet herstellen?"
    },
    whatAreAccounts: {
      text: "Je wallet kan meerdere accounts van dezelfde coin aanmaken. Accounts zijn handig als je verschillende 'rekeningen' wilt hebben om je financin gescheiden te houden..",
      title: "Wat zijn accounts?"
    },
    whatIsRememberWallet: {
      text: 'Als je "wallet onthouden" hebt ingeschakeld, kun je de accounts voor deze wallet bekijken, zelfs zonder dat je BitBox02 is verbonden. Zo kun je je portfolio inzien wanneer je wilt. Om te verzenden en te ontvangen, moet je nog steeds je BitBox02 verbinden.\n\nAls je deze optie uitzet, moet je je BitBox02 ingeplugd hebben om de bijbehorende accounts in te zien.',
      title: 'Wat gebeurt er als ik "wallet onthouden" in- of uitschakel?'
    },
    whyIsThisUseful: {
      text: "Accounts zijn een goede manier om bijvoorbeeld de financin van verschillende mensen of voor verschillende doeleinden te beheren omdat deze gescheiden gehouden worden in verschillende accounts. Je kunt ook de uitgebreide publieke sleutel (xpub) van n account met iemand anders delen zonder ook maar iets over je andere accounts aan diegene bloot te stellen. Dit zorgt ervoor dat je herhaaldelijk kunt ontvangen zonder een adres te hergebruiken, bijvoorbeeld om een salaris te ontvangen of regelmatig crypto te kopen.",
      title: "Waar is dit goed voor?"
    }
  },
  appendix: {
    link: "Neem contact met ons op!",
    text: "Nog een vraag?"
  },
  backups: {
    check: {
      text: "Het checken van je backup zorgt ervoor dat je kunt controleren of je een geldige backup hebt voor je huidige wallet. Het kan ook gebruikt worden om te controleren of je herstelwachtwoord nog klopt. Je kunt je hoofdherstelwachtwoord checken, of je verborgen herstelwachtwoord.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, maar je herstelwachtwoord is nodig om de wallet vanuit de seed phrase te herstellen.",
      title: "Kan ik de backup versleutelen?"
    },
    howOften: {
      text: "De backup wordt automatisch gegenereerd wanneer je een nieuwe wallet aanmaakt. Je hoeft alleen een nieuwe backup te maken als je microSD kaart kapot of kwijt is, of als je meerdere microSD kaarten als backup wilt gebruiken. Je hoeft geen nieuwe backup te maken nadat je een transactie hebt gedaan; alle transactiedata kan worden hersteld met de backup die aan het begin gemaakt is.",
      title: "Hoe vaak moet ik een nieuwe backup maken?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwoorden ('seed phrase') op een microSD kaart. De herstelwoorden samen met je herstelwachtwoord genereren je wallet.",
      title: "Wat is een backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "Met 'check backup' kun je verifiren dat je een werkende backup hebt die overeenkomt met je huidige wallet.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, dit is niet mogelijk. Bewaar de microSD kaart op een veilige plek, omdat de onversleutelde herstelwoorden die je wallet kunnen herstellen hierop staan. Als je een wachtwoordbeveiliging wilt gebruiken, kun je de optionele wachtwoordfunctie inschakelen onder de geavanceerde instellingen. ",
      title: "Kan ik de backup versleutelen?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwachtwoorden op een microSD kaart.",
      title: "Wat is een backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Wanneer 2FA is ingeschakeld moeten alle (verzend-) transacties goedgekeurd worden met de gekoppelde mobiele telefoon. Dit is wat er onder de motorkap gebeurt: Een versleuteld bericht wordt naar de mobiele app gestuurd en ontgrendeld, waarna het teruggestuurd wordt naar de BitBoxApp als je op 'accepteren' klikt. Deze communicatie wordt gedaan via het kanaal dat opgezet wordt tussen de mobiele telefoon en de BitBoxApp tijdens het koppelen. \n\nZorg dat je wallet gebackupt is en gekoppeld met de mobiele app voordat je 2FA inschakeld. Zodra dit gebeurd is worden de microSD poort en het koppelen met de mobiele app uitgeschakeld. Ze kunnen opnieuw ingeschakeld worden door de BitBox te resetten, wat ook je wallets verwijdert. ",
      title: "Hoe werkt tweefactor authenticatie (2FA)?"
    },
    disable2FA: {
      text: "Om 2FA uit te zetten moet je de BitBox resetten en herstellen middels je backup. Zorg ervoor dat je de microSD kaart met de backup nog hebt en dat je het herstelwachtwoord nog weet. Kies dan voor 'Reset BitBox' in de instellingen. Kies een nieuw apparaatwachtwoord en kies 'herstel een backup'. Selecteer de backup die je voor je wallet hebt gemaakt, klik op herstellen en voer het herstelwachtwoord in wat je hebt gekozen toen je de wallet aanmaakte.",
      title: "Hoe kan ik tweefactor authenticatie (2FA) uitschakelen?"
    },
    ejectBitbox: {
      text: "Je kunt de BitBox op ieder moment uit je apparaat halen, zonder dat je het eerst hoeft uit te werpen.",
      title: "Hoe kan ik de BitBox uitwerpen?"
    },
    ejectSD: {
      text: "Je kunt de microSD kaart op ieder moment handmatig uit je BitBox halen, zo lang je niet op dat moment een backup aan het maken of herstellen bent.",
      title: "Hoe kan ik de microSD kaart uitwerpen?"
    },
    hiddenWallet: {
      text: "Het is een tweede wallet op dezelfde BitBox, die beschermd wordt door aparte apparaat- en herstelwachtwoorden, die je kunt gebruiken om een gedeelte van je balans te verbergen. Dezelfde herstelwoorden / SD kaart backup wordt gebruikt voor je normale en verborgen wallet, dus je hebt geen extra backup nodig.",
      title: "Wat is een verborgen wallet?"
    },
    legacyHiddenWallet: {
      text: "Klik eerst op onderstaande button (die beschikbaar is als de BitBox ontgrendeld is en 2FA niet ingeschakeld staat), plug daarna je BitBox opnieuw in en ontgrendel hem met je verborgen apparaatwachtwoord.",
      title: "Hoe krijg ik toegang tot mijn verborgen legacy wallet?"
    },
    pairing: {
      text: "Nadat je de mobiele BitBoxApp hebt gedownload voor iOS of Android, kun je de weergegeven QR-code scannen. Dit zet een beveiligd kanaal op tussen de mobiele telefoon en deze applicatie. Zodra je de QR-code gescand hebt, kun je de instructies op je telefoon volgen.",
      title: "Hoe koppel ik mijn mobiele telefoon?"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Raadpleeg alsjeblieft Bitsurance's website en hun FAQ voor meer informatie.",
      title: "Verder nog vragen?"
    },
    privacy: {
      link: {
        text: "Bitsurance privacy policy"
      },
      text: "De verzekering bevat, zoals alle verzekeringen, je naam en adres, en specificeert het het te verzekeren object (in dit geval wordt dit door je publieke sleuten gedefinieerd). Deze gegevens worden direct naar Bitsurance gestuurd en worden niet met Shift Crypto gedeeld. Voor meer informatie kun je de Bitsurance privacy policy raadplegen.",
      title: "Welke persoonlijke informatie is nodig voor de verzekering?"
    },
    renew: {
      text: 'De verzekering verlengt na een jaar automatisch. Je kunt dit op ieder moment stopzetten via "Contract beheren" in de BitBoxApp, wat je naar het klantenportaal van Bitsurance brengt.',
      title: "Hoe kan ik de verzekering verlengen of annuleren?"
    },
    status: {
      text: 'Verzekerde accounts worden met een groene "verzekerd" badge gemarkeerd in de linkerbovenhoek van de Bitcoin account-pagina. In de "verzekering" sectie kun je een overzicht vinden van alle verzekerde Bitcoin accounts en hun huidige verzekeringsstatus.',
      title: "Kan ik de status van een verzekerd account inzien?"
    },
    what: {
      text: 'Iedere Bitcoin-verzekeringscontract dekt een specifieke account in je wallet. Je kunt verschillende accounts verzekeren door meerdere polissen af te sluiten. De verzekering dekt alleen adressen van het "Native Segwit" type.',
      title: "Is de hele BitBox wallet verzekerd?"
    },
    who: {
      text: "De verzekering wordt aangeboden door Bitsurance, een verzekeraar opgericht door bitcoiners. Ze werken samen met ELEMENT verzekeringen om de Bitcoin-verzekering aan te bieden. Beide bedrijven zijn in Duitsland gevestigd.",
      title: "Wie verzekert mijn bitcoin?"
    },
    why: {
      text: "Bitsurance dekt een aantal risico's van het in eigen beheer houden van je coins die niet door een wallet afgevangen kunnen worden, zoals diefstal, afpersing of vernietiging van de wallet. Het is een persoonlijke beslissing of je voor deze risico's een verzekering nodig hebt.",
      title: "Heb ik een Bitcoin-verzekering nodig?"
    }
  },
  cointracking: {
    text: "Klik op de 'exporteren' knop en open de downloads map. Hier vind je een .csv export bestand. Klik op onderstaande link, upload je BitBox .csv bestand en importeer de data om het in je CoinTracking porfoliomanager te gebruiken en je belastingaangifte te genereren.",
    title: "Hoe importeer ik mijn transacties in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lees meer over de authenticiteits-check"
      },
      text: "De BitBoxApp doet een authenticiteitscheck om er zeker van te zijn dat je BitBox echt is. Deze check wordt lokaal uitgevoerd en benodigt geen verbinding naar externe servers.",
      title: "Hoe werkt de authenticiteitscheck?"
    },
    name: {
      text: "Dit is de naam van je wallet en van je backup. De naam wordt gebruikt voor toekomstige backups en kan ook gebruikt worden om verschillende wallets te onderscheiden. Deze kun je op ieder moment veranderen, maar backups die je hiervoor gemaakt hebt zullen nog steeds de oude naam gebruiken.",
      title: "Waar wordt de BitBox02-naam voor gebruikt?"
    },
    "secure-chip": {
      link: {
        text: "Lees meer over de secure chip"
      },
      text: "Deze informatie toont het modelnummer van de secure chip. De het nieuwste model is de ATECC608B, die verbeterde beveiligings-eigenschappen heeft vergleken met oudere modellen.",
      title: "Waarom wordt het secure chip modelnummer getoond?"
    }
  },
  receive: {
    address: {
      text: "Je kunt dit adres aan anderen geven, zodat ze transacties naar je kunnen doen. Controleer altijd met de verzender of zij wel het juiste adres hebben ingevuld!",
      title: "Wat moet ik met een adres?"
    },
    addressChange: {
      text: "Zodra je een transactie doet, wordt er automatisch een nieuw adres gegenereerd en toegevoegd aan de lijst. Zo heb je altijd 20 adressen beschikbaar die nog nooit coins hebben ontvangen.",
      title: "Wanneer veranderen mijn adressen?"
    },
    addressFormats: {
      text: "Het standaardadrestype is Native Segwit. Dit adrestype is het meest gebruikt door andere wallets en exchanges en zorgt ervoor dat je de laagste transactiekosten betaalt. Je kunt er echter voor kiezen om bitcointransacties naar Taproot-adressen te doen, wat het nieuwste adresformaat is, maar nog niet overal ondersteund wordt. Als je problemen ondervind met het versturen naar een Native Segwit adres, kun je ervoor kiezen om een Wrapped Segwit adres te gebruiken, wat met vrijwel alle andere wallets en exchanges compatibel is. ",
      title: 'Wanneer moet ik "Adrestype wijzigen" gebruiken?'
    },
    howVerify: {
      text: "Voor de BitBox01 klik je op het BitBox icoon in het zijmenu aan de linkerkant en ga je naar de 'koppelen'-sectie. Als je daar bent, updatet de hulp en kun je de instructies daar verder volgen.\nOp de BitBox02 kun je adressen direct op het apparaat verifiren tijdens het proces van verzenden of ontvangen.",
      title: "Hoe kan ik veilig mijn adressen verifiren?"
    },
    plugout: {
      text: "Nee, zodra je je coins naar het adres hebt verstuurd, kun je je BitBox gewoon weer opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het ontvangen?"
    },
    why20: {
      text: "Tijdens het opstarten genereert de app verschillende adressen op basis van je seed om te kijken of ze iets hebben ontvangen. Omdat de app een praktisch oneindige hoeveelheid adressen kan genereren, kan de app ook oneindig doorgaan met adressen controleren tijdens het opstarten. Om dit te voorkomen, stopt de app met controleren als het 20 adressen achter elkaar heeft gezien die niets ontvangen hebben. Dit is het tussenruimte-limiet en 20 is hiervoor de arbitraire standaard. Dit zijn de 20 adressen waar je uit kunt kiezen.",
      title: "Waarom slechts 20 adressen?"
    },
    whyMany: {
      text: "Om je privacy en veiligheid te bewaken, moet je nooit twee keer hetzelfde adres gebruiken; bekijk een adres als een factuurnummer. Als je een adres hebt gebruikt, kun je op de rechterpijl klikken voor een nieuw adres. Je kunt tot 20 adressen tegelijkertijd aanmaken. Alle adressen zijn gegenereerd op basis van je backup herstelwoorden.",
      title: "Waarom zo veel adressen?"
    },
    whyVerify: {
      text: "Je zou je computer niet moeten vertrouwen om adressen te genereren en weer te geven. Je computer heeft een veel hoger aanvalsrisico dan een hardware wallet, waardoor de kans op virussen en malware vele malen hoger is. \nVoor de BitBox01 klik je op de knop om een veilig adres naar de gekoppelde telefoon te sturen, die je ook kun gebruiken om de QR-code te scannen en verifiren. Voor de BitBox02 kun je het adres direct op het display verifiren. ",
      title: "Waarom moet ik mijn adressen verifiren. "
    }
  },
  send: {
    change: {
      text: "Het wisselgeld wordt naar een Taproot-adres gestort als je ten minste n andere Taproot-UTXO hebt. Als je coin control gebruikt, wordt het wisselgeld naar een Taproot adres gestort als er zich ten minste n Taproot-UTXO tussen de geselecteerde UTXOs bevindt. In alle andere gevallen wordt het wisselgeld naar een Native Segwit adres gestort. ",
      title: "Hoe wordt het wisselgeldadres bepaald?"
    },
    fee: {
      text: "De netwerkkosten worden geschat op basis van de grootte van de transactie en niet de hoeveelheid. De netwerkkosten worden berekend door het algoritme van Bitcoin Core op basis van de prioriteit die je zelf kiest. Deze worden weergegeven als ze een andere waarde hebben dan de waardes hieronder:\nBudget: 24 blokken (ongeveer 4 uur voor Bitcoin, 1 uur voor Litecoin)\nLaag: 12 blokken (ongeveer 2 uur voor Bitcoin, 30 minuten voor Litecoin)\nNormaal: 6 blokken (ongeveer 1 uur voor Bitcoin, 15 minuten voor Litecoin)\nHoog: 2 blokken (ongeveer 20 uur voor Bitcoin, 5 minuten voor Litecoin)\n(Een Bitcoin-blok kost gemiddeld 10 minuten en een Litecoin-blok 2,5 minuut om te minen. De belasting op het netwerk en dus je bevestigingstijd kan drastisch variren.)",
      title: "Hoe worden de netwerkkosten bepaald?"
    },
    plugout: {
      text: "Nee, zodra je een transactie hebt gemaakt, hoef je je BitBox niet ingeplugd te laten. Je kunt je BitBox direct na verzenden veilig opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het verzenden?"
    },
    priority: {
      text: "Hoe hoger de netwerkkosten die je bereid bent te betalen, hoe sneller je transactie bevestigd zal worden door het netwerk.",
      title: "Wat is de netwerkprioriteit?"
    },
    revert: {
      text: "Zodra een transactie is ondertekend en verzonden (uitgezonden naar het netwerk), kan het niet teruggedraaid worden. Verifieer daarom altijd alle onderdelen van de transactie (inclusief de netwerkkosten) voordat je hem ondertekent! Als je de ontvanger kent, kun je ze middels een ontvangstadres vragen om de transactie handmatig terug te sturen.",
      title: "Kan ik een transactie terugdraaien?"
    },
    whyFee: {
      text: "Transacties concurreren met elkaar om bevestigd te worden door een miner. Miners kiezen de transacties die ze in hun blokken stoppen op basis van welke transacties het meeste betalen. Miners bepalen welke transacties er opgenomen worden in de blockchain. Omdat er geen vertrouwde derde partijen zijn om te bepalen welke transacties valide zijn, doen miners dit door middel van computerkracht op te offeren. Als beloning voor hun werk, kunnen ze nieuwe Bitcoin en de netwerkkosten van alle transacties die ze hebben uitgekozen opeisen.",
      title: "Waarom zijn er netwerkkosten?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Als je je eigen node wilt verbinden die zich op hetzelfde netwerk bevindt (bv. je wifinetwerk thuis), kun je zonder problemen normale netwerkcommunicatie gebruiken. Het is aan te raden dat je Electrum-server een TLS-certificaat heeft om de communicatie te versleutelen.\nAls je op andere locaties dan alleen thuis met je node wilt verbinden, is Tor de betere optie. In dit geval is een TLS-certificaat niet nodig.",
      title: "Moet ik clearnet TCP, TLS of Tor gebruiken?"
    },
    instructions: {
      link: {
        text: "Instructies om je eigen node te koppelen."
      },
      text: "Voor een volledige tutorial kun je onze instructies op deze webpagina volgen:",
      title: "Hoe verbind ik mijn BitBoxApp met mijn eigen full node?"
    },
    options: {
      text: "Er zijn meerdere opties om je eigen node te draaien, zoals een kant-en-klaar apparaat te kopen, er zelf een te bouwen of Bitcoin Core te draaien op je PC. Als je de BitBoxApp wilt verbinden met je eigen node, moet je ervoor zorgen dat het beschikt over een Electrum server. Dit is een programma dat toegeweid is aan het verbinden van wallets met je full node.\nOndersteunde opties zijn Electrs, Electrum Personal Server of Bitcoin Wallet Tracker.",
      title: "Welke opties heb ik om zelf een full node te draaien?"
    },
    tor: {
      text: "Tor staat voor 'The Onion Router'. Het is een gratis, open source programma dat je extra privacy biedt en heel nuttig is in combinatie met Bitcoin. \nAls je met je node wilt verbinden via Tor, moet je ervoor zorgen dat Tor is genstalleerd op je computer en dat de Tor Proxy is ingeschakeld in de instellingen van de BitBoxApp.\nOp de meeste besturingssystemen zijn er twee manieren om Tor te gebruiken:\n1. Tor Browser: download en open de Tor Browser. Dit zorgt ervoor dat de BitBoxApp kan verbinden met het Tor netwerk als je poort 9150 hebt ingesteld in de Tor Proxy instellingen.\n2. Tor achtergronddienst: installeer de Tor daemon, die altijd in de achtergrond draait. De BitBoxApp kan dan verbinden door poort 9050 in te stellen in de Tor Proxy instellingen.",
      title: "Wat zijn Tor en de Tor Proxy, en welke poort moet ik gebruiken?"
    },
    what: {
      text: "Het is mogelijk om je wallet te verbinden met je eigen full node, in plaats van het gebruiken van de Shift servers.",
      title: "Wat is dit?"
    },
    why: {
      text: "Het draaien van je eigen node is niet noodzakelijk, maar het verhoogt wel je privacy en verlaagt de noodzaak om anderen te vertrouwen.\nHet betekent dat je Bitcointransacties meer priv zijn, omdat de BitBoxApp niet meer verbindt met onze servers om je transactiegeschiedenis op te halen. In plaats daarvan wordt die informatie van je eigen node gehaald.\nTen tweede zorgt het draaien van je eigen node ervoor dat je alle transacties zelf verifieerd en controleert of de consensusregels gevolgd worden ",
      title: "Waarom zou ik mijn eigen node moeten draaien?"
    }
  },
  settings: {
    sats: {
      text: 'Een Satoshi (of "sat" in het kort) is de kleinst mogelijke eenheid op het bitcoinnetwerk. Een satoshi is n honderdmiljoenste bitcoin (0.00 000 001 BTC). Het is vernoemd naar de maker van Bitcoin, Satoshi Nakamoto.',
      title: "Wat is een Satoshi?"
    },
    servers: {
      text: "De app communiceert met de Shift Crypto servers om op updates te controleren, je transacties te laden en informatie te versturen naar je gekoppelde mobiele apps. \nDe app haalt ook de huidige wisselkoersen van CoinGecko. Alle conversies worden lokaal gedaan, zodat je balansen nooit naar derde partijen verstuurd worden.\nVoor Ethereum en ERC20 tokens worden de Etherscan.io APIs gebruikt.",
      title: "Met welke servers verbindt deze app?"
    }
  },
  title: "Gids",
  toggle: {
    close: "Gids sluiten",
    open: "Gids"
  },
  trackingModePortfolioChart: {
    text: "Op de desktop kun je je muiscursor over de grafiek heen bewegen. Op je telefoon gebruik je je vinger om horizontaal over de grafiek te slepen.",
    title: "Hoe kan ik de historische waardes op de grafiek inzien?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Je moet het apparaat resetten en de wallet herstellen middels een backup en het herstelwachtwoord.",
      title: "Wat moet ik doen als ik het wachtwoord van mijn BitBox vergeten ben?"
    },
    reset: {
      text: "Door 15 keer een verkeerd apparaatwachtwoord in te voeren. Tijdens de laatste paar keer moet je de knoppen langer ingedrukt houden.",
      title: "Hoe reset ik mijn BitBox?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Het apparaat zou n keer moeten knipperen als het ingevoerd wordt. Zorg dat het met de juiste kant boven ingevoerd is. Als je het probleem niet opgelost krijgt, kun je contact met ons opnemen via onderstaande link.\nDe BitBox01 is niet te koppelen met mobiele telefoons. Gebruik alsjeblieft de BitBoxApp op een PC om je BitBox01 te verbinden.",
      title: "Mijn BitBox01 wordt niet herkend."
    },
    getDevice: {
      link: {
        text: "Bestel een BitBox"
      },
      text: "Je kunt een BitBox op onze webwinkel bestellen:",
      title: "Hoe kan ik aan een BitBox komen?"
    },
    internet: {
      text: "Ja, een internetverbinding is nodig om de wallet te synchroniseren, transacties te versturen en de laatste wisselkoersen op te halen.",
      title: "Heeft deze app een internetverbinding nodig?"
    },
    lostDevice: {
      link: {
        text: "Backup-center"
      },
      text: "Je kunt je accounts herstellen met een nieuwe BitBox of via ons backup-center",
      title: "Ik ben mijn BitBox kwijt, wat nu?"
    },
    useWithoutDevice: {
      text: "Dat is op dit moment niet mogelijk.",
      title: "Kan ik de app ook zonder BitBox gebruiken?"
    },
    welcome: {
      text: "Bedankt voor het gebruiken van deze app, gemaakt door Shift Crypto in Zwitserland. We waarderen alle feedback die je voor ons hebt! Die kun je delen door op de link onderaan het scherm te klikken.",
      title: "Welkom in de BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Als je een nieuwe telefoon of computer met de BitBoxApp verbindt, moet je opnieuw met je DApps verbinden. Als je dit gedaan hebt, zie je de coins weer in de DApp zoals je gewend bent.",
      title: "Ik zie mijn eerdere verbindingen niet."
    },
    supportedNetworks: {
      text: "Op dit moment wordt alleen Ethereum via WalletConnect in de BitBoxApp ondersteund. Gebruik de Rabby-browserextensie om van andere EVM-compatibele chains gebruik te maken.",
      title: "Welke netwerken worden ondersteund?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is een communicatie-protocol voor web3 applicaties. Hiermee kun je op een gemakkelijke manier met op Ethereum gebaseerde DApps en web-wallets verbinden zonder een applicatie van een derde partij te hoeven gebruiken. Dit is extra handig voor gebruikers van de Android-BitBoxApp.",
      title: "Wat is WalletConnect?"
    }
  }
};
const headerssync$a = {
  blocksSynced: "{{blocks}} blokken gesynchroniseerd"
};
const hiddenWallet$a = {
  info1HTML: "Je kunt een verborgen wallet aanmaken met een <strong>andere</strong> combinatie van apparaatwachtwoord & herstelwachwoord, om plausibele ontkenning mogelijk te maken.",
  info2HTML: "Voer het apparaatwachwoord en het herstelwachtwoord dat je met je verborgen wallet wilt associren hieronder in. Het apparaatwachtworod en het herstelwachtwoord <strong>moeten</strong> van je hoofdwallet verschillen.",
  passwordLabel: "Verborgen herstelwachtwoord",
  passwordPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  pinLabel: "Verborgen apparaatwachtwoord",
  pinRepeatLabel: "Herhaal je verborgen herstelwachtwoord",
  pinRepeatPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  success: "Verborgen wallet aangemaakt. Voer je BitBox opnieuw in om het te ontgrendelen."
};
const initialize$a = {
  create: "Stel apparaatwachtwoord in",
  creating: "Apparaatwachtwoord instellen...",
  error: {
    e102: "Het apparaatwachtwoord moet ten minste vier karakters bevatten."
  },
  info: {
    description1: "Kies je apparaatwachtwoord. Dit wordt gebruikt om je BitBox te ontgrendelen.",
    description2: "Je kunt nummers, letters en symbolen gebruiken. Langere wachtwoorden bieden je meer veiligheid.",
    description3: "Als je je apparaatwachtwoord kwijtraakt moet je je BitBox resetten met je backup.",
    subtitle: "Nu ga je je apparaatwachtwoord instellen.",
    title: "Apparaat initialiseren..."
  },
  input: {
    label: "Apparaatwachtwoord",
    labelRepeat: "Herhaal apparaatwachtwoord",
    placeholderRepeat: "Bevestig apparaatwachtwoord"
  }
};
const invalidFormat$a = "Ongeldig format";
const language$b = {
  title: "Selecteer je taal"
};
const legacyhiddenwallet$a = {
  disable: "Verborgen legacy wallet uitschakelen",
  enable: "Verborgen legacy wallet inschakelen",
  successDisable: "Verborgen legacy wallet uitgeschakeld",
  successEnable: "Verborgen legacy wallet ingeschakeld. Plug je BitBox opnieuw in en voer het verborgen apparaatwachtwoord in om toegang te krijgen tot je verborgen legacy wallet."
};
const loading$a = "laden...";
const manageAccounts$4 = {
  accountHidden: "Deze account is verborgen in je alleen-kijken accounts. Om hem weer te zien moet je je BitBox02 verbinden.",
  editAccount: "Bewerken",
  editAccountNameTitle: "Accountnaam bewerken",
  noAccounts: "Geen accounts gevonden",
  settings: {
    hideTokens: "Tokens verbergen",
    showTokens: "Tokens tonen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Accounts toevoegen en tonen/verbergen",
  title: "Accounts beheren",
  watchAccount: "Alleen-kijken account",
  watchAccountDescription: "Deze account is onderdeel van je alleen-kijken accounts. Je kunt het in deze lijst verbergen met de toggle."
};
const mobile$5 = {
  usingMobileDataWarning: "Mobiel datagebruik: deze app kan een paar honderd megabyte aan blockchaindata downloaden als je een account opent. Verbind met een wifinetwerk om je mobiele datagebruik te beperken.\n\nDit bericht wordt niet nogmaals getoond."
};
const newSettings$4 = {
  about: {
    appVersion: {
      title: "App versie"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Vergrendel toegang tot de app met je schermvergrendeling of vingerafdruk.",
      title: "Schermvergrendeling"
    },
    coinControl: {
      description: "Selecteer welke UTXOs onderdeel van een transactie zijn om privacy te verbeteren."
    },
    customFees: {
      description: "Dit laat je de transactiekosten van een overboeking precies bepalen."
    },
    torProxy: {
      description: "Verbind via Tor voor betere privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Je kunt door alle valuta heen wisselen op de acccountpagina.",
      title: "Actieve valuta"
    },
    darkmode: {
      description: "Verander het uiterlijk van de BitBoxApp naar een donkere kleurstelling."
    },
    defaultCurrency: {
      description: "Selecteer je standaardvaluta",
      title: "Standaardvaluta"
    },
    enableAccount: {
      description: "Als je je account de-activeert betekent dit alleen dat deze niet direct zichtbaar is in de BitBoxApp. Je kunt hem via dit menu altijd weer heractiveren. Coins op gedeactiveerde accounts blijven daar gewoon staan en blijven veilig.",
      title: "Account activeren/uitzetten"
    },
    hideAmounts: {
      description: "Laat een toggle zien om je balansen en hoeveelheden te verbergen om je privacy te beschermen als je de app in het openbaar gebruikt.",
      hideAmounts: "Hoeveelheden verbergen",
      showAmounts: "Hoeveelheden laten zien",
      title: '"Hoeveelheden verbergen" inschakelen'
    },
    language: {
      description: "De taal waarin je de BitBoxApp wilt gebruiken.",
      title: "Taal"
    },
    remebmerWallet: {
      name: "Wallet onthouden",
      warning: "Je onthouden wallet wordt hiermee vergeten. Om hem weer te zien, moet je je BitBox02 opnieuw verbinden. Dit heeft geen enkele invloed op de coins die op je wallet staan. \n\nWil je doorgaan?",
      warningTitle: "Wallet niet meer onthouden"
    },
    toggleSats: {
      description: "Satoshis in- of uitschakelen."
    }
  }
};
const note$6 = {
  input: {
    description: "(optioneel)",
    placeholder: "Notitie toevoegen"
  },
  title: "Notitie"
};
const notification$a = {
  newTxs_one: "Nieuwe transactie in: {{accountName}}",
  newTxs_other: "{{count}} nieuwe transacties in: {{accountName}}"
};
const pairing$a = {
  aborted: {
    text: "Het koppelen van de mobiele app is afgebroken.",
    title: "Afgebroken"
  },
  button: "Mobiele app koppelen",
  confirm: "Weet je zeker dat je je BitBox wilt koppelen? Hierna heb je je mobiele telefoon nodig om een transactie uit te voeren.",
  connectOnly: {
    button: "Mobiele app verbinden",
    title: "Scan met de mobiele app door in het menu 'Nieuwe desktop-app verbinden' te kiezen."
  },
  error: {
    text: "Er is iets misgegaan. Probeer het opnieuw.",
    title: "Fout"
  },
  pullFailed: {
    text: "We konden het bericht niet van je telefoon ophalen door de relay server. De server kan offline zijn, neem contact op met de klantenservice.",
    title: "Pull niet gelukt"
  },
  reconnectOnly: {
    button: "Mobiele app opnieuw verbinden"
  },
  scanningFailed: {
    text: "Telefoon kon het bericht niet scannen. Probeer het opnieuw.",
    title: "Scan niet gelukt"
  },
  start: {
    hideAppQRCode: "QR-code verbergen",
    revealAppQRCode: "QR-code tonen",
    step1: "Als je de mobiele app niet hebt, kun je de QR-code voor de App Store of Play store scannen, afhankelijk van welke telefoon je hebt. ",
    step2: "Scan met onze mobiele app, die je kunt vinden als 'Digital BitBox 2FA' in de iOS en Android app stores."
  },
  started: {
    text: "Volg de instructies op de mobiele app",
    title: "Fantastisch"
  },
  success: {
    text: "Gefeliciteerd, je hebt je BitBox met de mobiele app gekoppeld!",
    title: "Gelukt"
  },
  timeout: {
    text: "Het koppelen is na twee minuten automatisch gestopt. Begin opnieuw als je de mobiele app nog steeds wilt koppelen. ",
    title: "Time-out"
  },
  title: "Mobiele koppeling"
};
const passphrase$4 = {
  considerations: {
    button: "Backup overwegingen",
    message: "De passphrase biedt je extra bescherming voor je (microSD of herstelwoord-) backup. Als iemand toegang heeft gekregen tot je backup, hebben ze nu ook de passphrase nodig om toegang te krijgen tot je wallet.\n\nDit betekent echter dat je <strong>zowel de passphrase als de backup</strong> nodig hebt om je wallet te herstellen wanneer je BitBox02 kapot gaat of verloren raakt. Als je je passphrase verliest of vergeet, raak je de toegang tot alle coins op die wallet kwijt.\n\nAls je je passphrase ergens opslaat, zou je dit op een andere plek dan je backup moeten doen. Op die manier heeft iemand die je backup vindt niet ook toegang tot je passphrase.",
    title: "Backup overwegingen"
  },
  disable: "Passphrase uitzetten",
  disableInfo: {
    button: "Uitzetten",
    message: "Nadat je de passphrase hebt uitgezet, word je niet langer gevraagd om een passphrase in te voeren nadat je je BitBox02 hebt ontgrendeld. Je voert dus je standaard wallet in.\n\nEventuele coins die nog op je passphrase wallet staan, zullen daarop blijven staan, en je kunt hier niet meer bij; je BitBox vraagt immers niet meer om de passphrase en opent direct je standaard wallet. Om weer toegang te krijgen, kun je simpelweg de passphrase opnieuw inschakelen en de passphrase weer invoeren bij het opstarten.\n\n<strong>Tip:</strong> Je kunt ook met een passphrase toegang tot je standaardwallet krijgen door niks in te voeren als er om je passphrase gevraagd wordt."
  },
  enable: "Passphrase inschakelen",
  error: {
    e104: "Het veranderen van de passphrase-instelling is geannuleerd."
  },
  how: {
    button: "Hoe het er uit ziet",
    message: "Een passphrase werkt niet zoals andere wachtwoorden waar je aan gewend bent. Als je je passphrase verkeerd invoerd, krijg je hier geen melding van. Dit komt omdat <strong>iedere passphrase een nieuwe, valide wallet maakt</strong>. Dit betekent dat je zo veel verschillende wallets kunt aanmaken als je wilt door een andere passphrase in te voeren. Je kunt weer toegang krijgen tot iedere wallet door de bijbehorende passphrase in te voeren.\n\nAls je je BitBox02 invoert, zul je zoals je gewend bent om het gewone wachtwoord gevraagd worden. Daarna kun je een passphrase invoeren.\n\nNadat je de passphrase hebt ingevoerd, kun je nog een keer checken wat je precies hebt ingevoerd, zodat je zeker weet dat het was wat je verwachtte.",
    title: "Hoe werkt het"
  },
  intro: {
    message: "Een passphrase zorgt voor extra beveiliging voor je wallet.\nDit is hoe het werkt.",
    title: "Passphrase instellen"
  },
  progressDisable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>uitschakelen</strong>",
    title: "Bevestig op je BitBox"
  },
  progressEnable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>aanzetten</strong>.",
    title: "Bevestig op je BitBox"
  },
  successDisabled: {
    message: "De passphrase <strong>staat nu aan</strong>!\nVanaf nu zul je tijdens het opstarten om een passphrase worden gevraagd.",
    messageEnd: "Plug alsjeblieft de BitBox opnieuw in.",
    title: "Passphrase aangezet"
  },
  successEnabled: {
    message: "De passphrase <strong>staat nu uit</strong>!\nVanaf nu zul je niet langer tijdens het opstarten om een passphrase worden gevraagd.",
    messageEnd: "Plug je BitBox02 opnieuw in.",
    tips: "Tips",
    tipsList: [
      "We raden je aan om een kleine hoeveelheid coins naar de passphrase wallet te sturen. Plug daarna je BitBox opnieuw in en voer je wachtwoord en passphrase in. Als je passphrase correct is, zou je de coins in je wallet moeten zien.",
      "Als je toegang wilt krijgen tot de originele wallet, kun je dit nog steeds doen door niets in te voeren als je om een passphrase wordt gevraagd. Of je kunt de passphrase helemaal uitzetten."
    ],
    title: "Passphrase uitgeschakeld"
  },
  summary: {
    button: "Passphrase aanzetten",
    title: "Samenvatting",
    understand: "Ik snap hoe de passphrase werkt, en begrijp de risico's die het met zich meebrengt.",
    understandList: [
      "De passphrase is een extra beveiliging bovenop je backup",
      "Het invoeren van een andere passphrase genereert een andere wallet.",
      "Om je wallet te herstellen heb je <strong>zowel de passphrase als de backup</strong> nodig.",
      "Als je je passphrase vergeet, kun je geen toegang meer krijgen tot je coins."
    ]
  },
  what: {
    button: "Leer hoe dit werkt",
    message: "Een wallet komt voort uit een heel groot willekeurig getal, ook wel bekend als je 'seed'. Deze seed is gemaakt toen je je BitBox02 voor het eerst instelde en is gebackupt met de microSD kaart of je lijst van herstelwoorden. Iedereen die toegang heeft tot de seed, heeft volledige controle over de coins in die wallet. \n\nEen passphrase is een <strong>optioneel geheim</strong> dat toegevoegd wordt aan de seed. Wanneer je de passphrase aanzet, maakt iedere verschillende passphrase een nieuwe wallet op basis van de seed <strong>en</strong> de passphrase. Een passphrase kan alles zijn; letters, woorden, speciale karakters, of helemaal niets. In feite is je standaardwallet een seed met een lege passphrase.\n\nDeze passphrase is onderdeel van de BIP39 standaard, wat betekent dat hij compatibel is met alle wallets die diezelfde standaard ondersteunen. ",
    title: "Wat is een passphrase?"
  },
  why: {
    button: "Waarom zou ik een passphrase gebruiken?",
    message: "De BitBox02 beschermt je seed op het apparaat zelf, maar de backup (op de microSD kaart of je herstelwoorden) geeft nog steeds volledige controle over de wallet. Dat is waarom deze backup veilig opgeslagen moet worden!\n\nOmdat een passphrase een nieuwe wallet genereert met de bestaande seed, heeft een passphrase wallet <strong>zowel de backup als de passphrase</strong> nodig om hem te herstellen. Het voordeel hiervan is dat als iemand je backup vindt, ze nog steeds je passphrase nodig hebben om toegang te krijgen tot je wallet.\n\nDaarnaast kun je met de passphrase meerdere wallets op hetzelfde device aanmaken, ook bekend als 'verborgen wallets', naast de bestaande wallet.",
    title: "Waarom zou je een passphrase gebruiken?"
  }
};
const password$a = {
  show: "Toon {{label}}",
  warning: {
    caps: "WAARSCHUWING: Caps lock () is ingeschakeld",
    paste: 'om tekst te plakken, schakel je "SHOW {{label}}" in'
  }
};
const random$b = {
  button: "Genereer willekeurig getal",
  description: "Je BitBox heeft het volgende willekeurige getal van {{bits}} bits gegenereerd:"
};
const receive$c = {
  bitsuranceWarning: "Dit is een verzekerde account, wat betekent dat het alleen kan ontvangen naar Native Segwit adressen. Dit is om te voorkomen dat je geen bitcoin naar adressen stuurt die niet gedekt zijn.",
  changeScriptType: "Adrestype wijzigen",
  label: "Jouw adres",
  onlyThisCoin: {
    description: "Om andere tokens te ontvangen, moet je deze inschakelen in de instellingen. Als je hier andere tokens stort, zijn ze mogelijk niet toegankelijk.",
    warning: "Zorg dat je alleen {{coinName}} op dit adres ontvangt."
  },
  scriptType: {
    p2tr: "Taproot (nieuwste adresformaat)",
    p2wpkh: "Native Segwit (standaard)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatibiliteitsformaat)"
  },
  selectAccount: "Selecteer een account",
  showFull: "Toon het volledige adres op je BitBox om te verifiren",
  taprootWarning: "Let op: Taproot is een nieuwe adressoort in Bitcoin en wordt nog niet op grote schaal gebruikt. Het kan bijvoorbeeld zijn dat bitcoin die op een Taproot-adres ontvangen wordt, niet weergegeven wordt in andere watch-only wallets. Veel andere wallets en exchanges kunnen ook nog niet naar Taproot-adressen zenden.",
  title: "{{accountName}} ontvangen",
  verify: "Verifieer veilig je adres ",
  verifyBitBox01: "Verifieer het adres op de mobiele app",
  verifyBitBox02: "Verifieer het adres op je BitBox02",
  verifyInstruction: "Verifieer of het volgende adres hetzelfde is als het adres wat op je BitBox wordt getoond.",
  warning: {
    secureOutput: "Koppel je BitBox met je mobiele telefoon om beveiligde adresverificatie in te schakelen. Ga hiervoor naar 'Apparaten beheren' in de zijbalk."
  }
};
const reset$a = {
  description: "Alle data zal van dit apparaat worden verwijderd, inclusief je privsleutel!",
  notReset: "Apparaat NIET gereset",
  title: "Fabrieksinstellingen terugzetten",
  understand: "Ik heb een backup en weet mijn herstelwachtwoord",
  understandBB02: "Ik heb een geldige backup"
};
const securityInformation$a = {
  create: {
    description1: "We raden je aan om je apparaat in te stellen in een veilige omgeving. Het belangrijkste is dat andere mensen niet kunnen zien welk wachtwoord je keist.",
    description2: "Je wordt gevraagd om twee wachtwoorden aan te maken.",
    description3: "Het eerste is het <strong>apparaatwachtwoord</strong>, wat je BitBox ontgrendeld. Dit kan later veranderd worden.",
    description4: "Het tweede is je <strong>herstelwachtwoord</strong>, wat je wallet ontgrendeld. Dit wachtwoord kan niet gewijzigd worden.",
    description5: "De wallet die je aanmaakt wordt gebackupt als bestand op de meegeleverde microSD kaart. Dit kan <strong>samen met je herstelwachtwoord</strong> gebruikt worden om je wallets te herstellen.",
    title: "Beveiligingsinformatie"
  },
  restore: {
    description1: "Je wordt gevraagd om de microSD kaart die je gebruikt hebt om je backup te maken in te voeren.",
    description2: "Om je apparaat te herstellen, heb je je herstelwachtwoord nodig.",
    description3: "Zorg ervoor dat je het juiste herstelwachtwoord invoert. Ongeacht wat je hier invoert, maak je een valide wallet aan. Als je een verkeerd wachtwoord invoert, krijg je waarschijnlijk een nieuwe, lege wallet te zien.",
    title: "Beveiligingsinformatie"
  }
};
const seed$a = {
  agreements: {
    "funds-access": "Ik kan NIET bij mijn wallets als ik mijn herstelwachtwoord vergeet",
    "password-change": "Ik kan het herstelwachtwoord NIET meer veranderen",
    "password-required": "Het hetstelwachtwoord is nodig om een wallet van een backup te herstellen"
  },
  create: "Wallet aanmaken",
  creating: "Wallet aanmaken...",
  description: "Ik heb het volgende gelezen en begrepen:",
  error: {
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e200: "Je moet een microSD kaart in je BitBox invoeren om een wallet aan te maken, zodat er automatisch een backup gegenereerd kan worden."
  },
  info: {
    button: "Stel nu je herstelwachtwoord in",
    description1: "Voer de microSD kaart in de BitBox in",
    description2: 'Kies een herstelwachtwoord voor de wallet en selecteer "Herstelwachtwoord nu instellen"',
    description3: "De backup op je microSD kaart en je herstelwachtwoord zijn de enige manier om weer toegang te krijgen tot je wallet als je BitBox verloren raakt, gestolen wordt, of kapot gaat.",
    description4: "Je kunt je herstelwachtwoord niet veranderen zonder je balans over te zetten op een nieuwe wallet.",
    title: "Nieuwe wallet aanmaken"
  },
  password: {
    label: "Herstelwachtwoord",
    repeatPlaceholder: "Herstelwachtwoord herhalen"
  },
  walletName: {
    label: "Walletnaam"
  }
};
const seedRestore$a = {
  error: {
    e200: "Voor het herstellen van een backup is de microSD kaart nodig"
  },
  info: {
    description1: 'Voer de microSD kaart in de BitBox in en klik op "verder"',
    description2: 'Kies een backup en klik op "herstellen"',
    description3: "Voer het herstelwachtwoord in",
    description4: "Je moet bevestigen dat je begrijpt dat een verkeerd wachtwoord een nieuwe, andere wallet aanmaakt.",
    title: "Hoe herstel je een wallet vanuit een backup"
  }
};
const send$c = {
  abort: "De transactie is afgebroken",
  address: {
    label: "Adres van de ontvanger",
    placeholder: "Adres invoeren"
  },
  amount: {
    label: "Hoeveelheid",
    placeholder: "Hoeveelheid invoeren"
  },
  availableBalance: "Beschikbare balans",
  button: "Controle",
  coincontrol: {
    address: "Adres",
    outpoint: "Output",
    title: "Verstuur uit output"
  },
  confirm: {
    "selected-coins": "Geselecteerde coins",
    title: "Bevestigen & transactie versturen",
    total: "Totaal"
  },
  error: {
    erc20InsufficientGasFunds: "Je hebt niet genoeg Ether in je wallet voor deze transactie. Stort meer Ether in je wallet om de transactie uit te voeren.",
    feeTooLow: "netwerkkosten te laag",
    feesNotAvailable: "Schatting van netwerkkosten niet beschikbaar",
    insufficientFunds: "ontoereikende balans",
    invalidAddress: "ongeldig adres",
    invalidAmount: "ongeldige hoeveelheid",
    invalidData: "ongeldige data"
  },
  fee: {
    customPlaceholder: "Hoeveelheid invoeren",
    label: "Netwerkkosten",
    placeholder: "Niet beschikbaar"
  },
  feeTarget: {
    customLabel: "Netwerktarief",
    customLabel_eth: "Gas-prijs",
    description: {
      economy: "4 uur (24 blokken)",
      economy_eth: "30 minuten of minder",
      economy_ltc: "1 uur (24 blokken)",
      high: "20 minuten (2 blokken)",
      high_eth: "30 seconden of minder",
      high_ltc: "5 minuten (2 blokken)",
      low: "2 uur (12 blokken)",
      low_eth: "5 minuten of minder",
      low_ltc: "30 minuten (12 blokken)",
      normal: "1 uur (6 blokken)",
      normal_eth: "2 minuten of minder",
      normal_ltc: "15 minuten (6 blokken)"
    },
    estimate: "Geschatte bevestigingstijd:",
    label: {
      custom: "Eigen selectie",
      economy: "Budget",
      high: "Hoog",
      low: "Laag",
      normal: "Normaal"
    },
    placeholder: "Netwerkkosten berekenen..."
  },
  maximum: "Alles verzenden",
  maximumSelectedCoins: "Geselecteerde coins verzenden",
  noFeeTargets: "Schattingen van de transactiekosten zijn op dit moment niet beschikbaar. Probeer het later opnieuw of stel zelf de hoogte in.",
  priority: "Prioriteit",
  scanQR: "QR-code scannen",
  signprogress: {
    description: "Dit is een transactie die veel data in zich heeft. Om de transactie te verzenden, word je gevraagd om {{steps}} keer te ondertekenen.",
    label: "Voortgang"
  },
  success: "De transactie is ondertekend en verzonden.",
  title: "Verstuur {{accountName}}",
  toggleCoinControl: "Coin control aan/uitzetten",
  transactionDetails: "Transactiedetails"
};
const settings$b = {
  about: "Over",
  accounts: "Accounts",
  advancedSettings: "Geavanceerde instellingen",
  appearance: "Uiterlijk",
  electrum: {
    add: "Server toevoegen",
    "add-server": "Toevoegen",
    check: "Controleer",
    checkFailed: "Niet geslaagd",
    checkSuccess: "Verbinding met {{host}} tot stand gebracht",
    checking: "Aan het controleren",
    "download-cert": "Remote certificate downloaden",
    "remove-server": "Verwijderen",
    removeConfirm: "Wil je {{server}} verwijderen?",
    reset: "Terugzetten naar standaardinstelling",
    resetConfirm: "Wil je alle servers verwijderen en de standaard-servers instellen?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Voer het eindpunt in.",
    step2: "2",
    "step2-text": "Voer een certificaat van de server in. Je kunt ook het remote certificate downloaden en het op het oog inspecteren.",
    "step2-text-tcp": "Je kunt deze stap overslaan als je geen TLS wilt gebruiken.",
    step3: "3",
    "step3-text": "Controleer de verbinding en voeg de server toe.",
    step4: "4",
    "step4-text": "Start de wallet opnieuw op. Als je de standaard servers niet verwijderd, wordt je eigen node als backup-server toegevoegd.",
    "title-btc": "",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Coin control aanzetten",
    electrum: {
      description: "Je kunt hier met je eigen Electrum-fullnode verbinden.",
      title: "Verbind met je eigen full node"
    },
    fee: "Custom fees aanzetten",
    setProxyAddress: "Proxy adres instellen",
    title: "Geavanceerde instellingen",
    useProxy: "Tor proxy aanzetten",
    useSats: "BTC-waarde in Satoshis weergeven"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nieuwe update beschikbaar ",
    title: "Info",
    "up-to-date": "Je app is bijgewerkt",
    version: "App versie"
  },
  restart: "Start de BitBoxApp opnieuw op om de veranderde instellingen in te schakelen.",
  services: {
    title: "Diensten"
  },
  success: "Voer de BitBox opnieuw in om de veranderde instellingen in te schakelen.",
  title: "Instellingen"
};
const setup$a = "Apparaat instellen";
const sidebar$b = {
  buy: "Crypto kopen",
  device: "Apparaat beheren",
  insurance: "Verzekering",
  leave: "Verlaten",
  settings: "Instellingen"
};
const success$h = {
  create: {
    info1: "Je wallet is veilig gebackupt op de microSD kaart. Verwijder deze en bewaar hem op een veilige plek.",
    info2: "Je hebt een veilig apparaatwachtwoord aangemaakt dat de BitBox ontgrendelt.",
    info3: "Je hebt een veilig herstelwachtwoord voor je wallet aangemaakt die je wallet ontgrendeld en nodig is om je backups te herstellen.",
    summary: "Hier is een samenvatting van wat je gedaan hebt",
    title: "Gelukt"
  },
  getstarted: "Get started",
  restore: {
    summary: "Je hebt je wallet vanuit je backup hersteld",
    title: "Gelukt"
  }
};
const transaction$b = {
  confirmation: "Bevestigingen",
  details: {
    activity: "Activiteit",
    address: "Adres",
    amount: "Hoeveelheid",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Hoeveelheid in fiat",
    fiatAtTime: "Fiat-waarde ten tijde van de transactie",
    status: "Status",
    title: "Transactiedetails",
    type: "Type"
  },
  explorer: "Transactie-ID",
  explorerTitle: "In externe block explorer openen",
  fee: "Netwerkkosten",
  fiatHistorical: "Historie",
  gas: "Gas",
  note: {
    edit: "Notitie aanpassen",
    save: "Notitie opslaan"
  },
  pending: "Transactie in afwachting",
  size: "Grootte",
  status: {
    complete: "Afgerond",
    failed: "Niet gelukt",
    pending: "In afwachting"
  },
  tx: {
    received: "Ontvangen naar",
    sent: "Verzonden naar"
  },
  vsize: "Virtuele grootte",
  weight: "Gewicht"
};
const transactions$a = {
  errorLoadTransactions: "Er is een fout opgetreden bij het laden van de transacties",
  placeholder: "Nog geen transacties"
};
const unknownError$a = "Er is een onbekende fout opgetreden: {{errorMessage}}";
const unlock$a = {
  description: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen",
  error: {
    e109_normal: "Apparaatwachtwoord onjuist. Je hebt nog {{remainingAttempts}} over voordat je BitBox wordt gereset.",
    e109_touch: "$t(unlock.error.e109_normal) Met de volgende login moet je de touchknop ingedrukt houden.",
    e113: "Omdat je tevaak geprobeerd hebt in te loggen, moet je de touchknop 4 seconden ingedrukt houden bij de volgende login."
  },
  input: {
    label: "Apparaatwachtwoord",
    placeholder: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen"
  },
  unlocking: "Ontgrendelen..."
};
const upgradeFirmware$b = {
  button: "Firmware updaten",
  description: "Wil je de firmware updaten van versie {{currentVersion}} naar versie {{newVersion}}?",
  label: "Je BitBox heeft een firmwareupdate nodig.",
  locked: "Hou de touchknop lang ingedrukt om van {{currentVersion}} naar {{newVersion}} te updaten.",
  title: "Firmware updaten",
  unlocked: "De bootloader is ontgrendeld. Om door te gaan:",
  unlocked1: "Voer je BitBox opnieuw in",
  unlocked2: "Het LED lichtje gaat branden als je BitBox opnieuw is ingevoerd",
  unlocked3: "Klik op de touchknop wanneer het LED lichtje gaat branden"
};
const walletConnect$6 = {
  connect: {
    button: "Verbinden",
    dappLabel: "Voer het URI-address van de DApp in",
    invalidPairingUri: "Ongeldige koppel-URI"
  },
  dashboard: {
    allSessions: "Alle sessies",
    disclaimer: "WalletConnect is een protocol om met op Ethereum gebaseerde DApps te verbinden. Deze DApps worden aangeboden door derder partijen, dus zorg ervoor dat je alleen met DApps verbindt die je vertrouwt. Zorg er ook altijd voor dat je weet wat je ondertekent als je een transactie aanmaakt.",
    newConnection: "Nieuwe verbinding",
    noConnectedSessions: "Geen van je accounts zijn op dit moment met een DApp verbonden."
  },
  invalidPairingChain: "Error met het toestaan van de koppeling. Zorg ervoor dat je een van deze ondersteunde chains gebruikt: {{chains}}",
  pairingRequest: {
    approve: "Koppeling goedkeuren",
    reject: "Afwijzen",
    title: "Nieuw koppelverzoek van"
  },
  pairingSuccess: "DApp met success verbonden. Je kunt verdergaan op de website van de DApp",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Data",
    dataParsingError: "Data kon niet verwerkt worden",
    decodeError: "Bericht kon niet gedecodeerd worden",
    method: {
      sendTransaction: "Transactie ondertekenen en verzenden",
      signMessage: "Bericht ondertekenen",
      signTransaction: "Transactie ondertekenen",
      signTypedData: "Ingevoerde data ondertekenen"
    },
    successfullySigned: "Verzoek ondertekend",
    walletConnectRequest: "WalletConnect verzoek"
  },
  useNewUri: "Deze URI is al gebruikt om een verbinding te maken. Gebruik alsjeblieft een nieuwe URI.",
  walletConnect: "WalletConnect"
};
const warning$g = {
  receivePairing: "Koppel de BitBox om beveiligde adresverificatie in te schakelen. Ga naar 'Apparaat beheren' in de sidebar.",
  sdcard: "Bewaar de microSD kaart apart van de BitBox, tenzij je je backups aan het beheren bent.",
  sendPairing: "Koppel de BitBox om je transactiedetails beveiligd te kunnen verifiren. Ga naar 'Manage device' in de sidebar."
};
const welcome$a = {
  connect: "Verbind je BitBox02",
  getStarted: "Laten we beginnen door de firmware op je BitBox02 te installeren.",
  insertBitBox02: "Tap de touch-sensoren op je BitBox02 om door te gaan.",
  insertDevice: "Verbind je BitBox om te starten",
  title: "Welkom"
};
const appTranslationsNL = {
  account: account$a,
  accountInfo: accountInfo$a,
  accountSummary: accountSummary$a,
  addAccount: addAccount$b,
  aopp: aopp$4,
  app: app$a,
  auth: auth$5,
  backup: backup$a,
  bb02Bootloader: bb02Bootloader$a,
  bitbox: bitbox$a,
  bitbox02Interact: bitbox02Interact$a,
  bitbox02Settings: bitbox02Settings$a,
  bitbox02Wizard: bitbox02Wizard$a,
  bitsurance: bitsurance$4,
  bitsuranceAccount: bitsuranceAccount$4,
  blink: blink$a,
  bootloader: bootloader$a,
  button: button$f,
  buy: buy$6,
  changePin: changePin$a,
  chart: chart$6,
  checkSDcard: checkSDcard$a,
  clickHere: clickHere$a,
  confirm: confirm$c,
  confirmOnDevice: confirmOnDevice$a,
  connectKeystore: connectKeystore$5,
  darkmode: darkmode$5,
  device: device$a,
  deviceLock: deviceLock$a,
  deviceSettings: deviceSettings$a,
  deviceTampered: deviceTampered$a,
  dialog: dialog$b,
  error: error$6,
  fiat: fiat$c,
  footer: footer$c,
  generic: generic$6,
  genericError: genericError$a,
  goal: goal$a,
  guide: guide$b,
  headerssync: headerssync$a,
  hiddenWallet: hiddenWallet$a,
  initialize: initialize$a,
  invalidFormat: invalidFormat$a,
  language: language$b,
  legacyhiddenwallet: legacyhiddenwallet$a,
  loading: loading$a,
  manageAccounts: manageAccounts$4,
  mobile: mobile$5,
  newSettings: newSettings$4,
  note: note$6,
  notification: notification$a,
  pairing: pairing$a,
  passphrase: passphrase$4,
  password: password$a,
  random: random$b,
  receive: receive$c,
  reset: reset$a,
  securityInformation: securityInformation$a,
  seed: seed$a,
  seedRestore: seedRestore$a,
  send: send$c,
  settings: settings$b,
  setup: setup$a,
  sidebar: sidebar$b,
  success: success$h,
  transaction: transaction$b,
  transactions: transactions$a,
  unknownError: unknownError$a,
  unlock: unlock$a,
  upgradeFirmware: upgradeFirmware$b,
  walletConnect: walletConnect$6,
  warning: warning$g,
  welcome: welcome$a
};
const account$9 = {
  disconnect: "Conexo perdida. Tentando novamente...",
  "export": "Exportar",
  exportTransactions: "Exportar transaes para a pasta Downloads como um arquivo CSV.",
  fatalError: "Ocorreu um erro inesperado.",
  incoming: "Lanamentos",
  initializing: "Obtendo informaes da blockchain...",
  insuranceExpired: "<strong>A conta no est mais segurada</strong>\n\nO plano de seguro para esta conta foi modificado.\nPor favor, verifique a pgina do seguro para obter detalhes.",
  insured: "Conta segurada",
  maybeProxyError: "Tor proxy ativado. Certifique-se que seu Tor esteja rodando corretamente ou desative as opes de proxy.",
  reconnecting: "Conexo perdida, tentando reconectar...",
  syncedAddressesCount: "Encontrado {{count}} endereos",
  uncoveredFunds: "Voc tem moedas nos seguintes tipos de endereos descobertos da sua conta <strong>{{name}}</strong>: {{uncovered}}.\nUma vez que a conta est segurada, apenas as moedas recebidas atravs do tipo de endereo <strong>Segwit nativo</strong> so cobertas. Moedas em outros tipos de endereos, mesmo que estejam na mesma conta, no esto seguradas.\nMova todas as suas moedas dos tipos de endereo no suportados para o tipo de endereo <strong>Segwit nativo</strong> para que todas as suas moedas nesta conta fiquem seguradas.",
  uncoveredFundsLink: "Siga este guia sobre como mover suas moedas.",
  warning: "Aviso!"
};
const accountInfo$9 = {
  address: "Endereo",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Cripto",
    information: {
      looksEmpty: "Parece que esta carteira est vazia.",
      start: "Comece depositando algumas moedas na carteira ou comprando diretamente no BitBoxApp."
    }
  },
  extendedPublicKey: "Chave pblica estendida",
  label: "Informaes da conta",
  scriptType: "Tipo de script",
  title: "Informaes da conta",
  verify: "Verificar no dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizar chave P2PKH pblica estendida j existente.",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Segwit Nativo",
    "p2wpkh-p2sh": "Veja a chave pblica estendida do Segwit mais antiga"
  },
  xpubTypeInfo: "Atualmente mostrando {{scriptType}} chave pblica estendida ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$9 = {
  availableBalance: "Saldo disponvel",
  balance: "Saldo",
  exportSummary: "Exportar resumo de contas para a pasta de Downloads como um arquivo CSV",
  fiatBalance: "Saldo em moeda corrente",
  name: "Nome da conta",
  noAccount: "No h contas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Meu portflio",
  total: "Total",
  transactionHistory: "Histrico de transaes"
};
const addAccount$a = {
  chooseName: {
    nextButton: "Adicionar conta",
    step: "Nome conta",
    title: "Um nome para sua conta"
  },
  selectCoin: {
    nextButton: "Prximo",
    step: "Selecione a moeda",
    title: "Selecione a crypto."
  },
  success: {
    addAnotherAccount: "Adicionar outra conta",
    message: "<strong>{{accountName}}</strong> foi addicionado agora as suas contas.",
    nextButton: "Pronto",
    step: "Terminado",
    title: "Conta adicionada"
  },
  title: "Adicionar conta"
};
const aopp$3 = {
  addressRequest: "{{host}} est solicitando um endereo de recebimento.",
  addressRequestWithLogo: "est solicitando um endereo de recebimento",
  banner: "Solicitao de endereo em andamento. Conecte seu dispositivo para continuar.",
  errorTitle: "Erro durante a solicitao de endereo",
  labelAddress: "Endereo",
  labelMessage: "Mensagem",
  reverifyInfoText: "Verificar endereo",
  signing: "Para prosseguir, assine a mensagem na sua BitBox02",
  success: {
    message: "Prossiga em {{host}}",
    title: "Endereo enviado com sucesso"
  },
  syncing: "Sincronizando a conta, aguarde.",
  title: "Solicitao de endereo"
};
const app$9 = {
  upgrade: "Uma nova verso desse app est disponvel! Por favor, atualize de {{current}} para {{version}}."
};
const auth$4 = {
  authButton: "Autenticar",
  title: "Autentique-se para continuar"
};
const backup$9 = {
  check: {
    checking: "Checando backup...",
    confirmTitle: "Checar backup",
    notOK: "O Backup NO corresponde  carteira.",
    ok: "Backup corresponde  carteira.",
    password: {
      label: "Senha de recuperao",
      placeholder: "Senha de recuperao",
      showLabel: "senha de recuperao"
    },
    success: "Backup verificado com sucesso:",
    title: "Checar backup"
  },
  create: {
    alreadyExists: "Voc j tem um backup vlido. Voc deseja recri-lo?",
    fail: "A criao do backup FALHOU!",
    info: "Por favor, digite a senha de recuperao da carteira atual para verificao.",
    name: {
      label: "Nome do backup",
      placeholder: "Por favor, nomeie o backup"
    },
    password: {
      label: "Senha de recuperao",
      placeholder: "Por favor, digite sua senha de recuperao"
    },
    title: "Criar backup",
    verificationFailed: "A senha de recuperao NO CORRESPONDE  carteira atual. O backup foi criado. Por favor, use 'Checar backup' para verificar sua senha de recuperao novamente."
  },
  description: "Selecione um <strong>arquivo de backup da carteira</strong>",
  insert: "Por favor, insira o carto microSD para gerenciar backups.",
  insertButton: "Eu inseri o carto microSD",
  list: "Os backups do seu carto microSD",
  noBackups: "No h backups neste carto microSD.",
  restore: {
    confirmTitle: "Restaurar backup",
    error: {
      e200: "Carto microSD no encontrado",
      general: "Erro ao restaurar o backup"
    },
    password: {
      label: "Senha de recuperao ou senha de recuperao oculta",
      placeholder: "Senha de recuperao",
      repeatPlaceholder: "Repita a senha de recuperao",
      showLabel: "Senha de recuperao"
    },
    restoring: "Restaurando o backup...",
    selectedBackup: "<strong>{{backupName}}</strong> criado em {{createdDateTime}} ser restaurado.",
    title: "Restaurar",
    understand: "Eu entendo que uma senha de recuperao incorreta criar uma carteira diferente"
  },
  showMnemonic: {
    description: "Sero mostradas suas palavras de recuperao na sua BitBox02, que formam um backup de sua carteira. Anote-as em um papel.\n\n<strong>No as armazene digitalmente nem tire fotos delas.</strong>\n\n<strong>No diga as palavras em voz alta.</strong>\n\n<strong>Este backup no  protegido por senha.</strong>\n\nDepois disso, voc ser solicitado a confirmar cada palavra.",
    title: "Mostrar frase de recuperao",
    warning: "<strong>Nunca compartilhe suas palavras de recuperao com ningum.</strong> Suas palavras de recuperao do acesso total  sua carteira. Se algum est pedindo suas palavras de recuperao,  um golpista, no as compartilhe!"
  },
  title: "Gerenciar backups"
};
const bb02Bootloader$9 = {
  abort: "No atualizar - Leve-me de volta",
  abort_noUpgrade: "Me leve de volta",
  advanced: {
    label: "Configuraes avanadas",
    toggleShowFirmwareHash: "Mostrar o hash de firmware toda vez na inicializao"
  },
  flipscreen: "Girar tela",
  orientation: "Dispositivo orientado de maneira errada?",
  success: "Atualizao bem sucedida! Continuando em {{rebootSeconds}} segundos...",
  success_install: "Instalao com sucesso! Continuando em {{rebootSeconds}} segundos..."
};
const bitbox$9 = {
  error: {
    e10000: "Senha atual do dispositivo incorreta.",
    e10001: "Falha ao substituir a senha do dispositivo",
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e112: "A senha do dispositivo oculto no pode ser igual  senha do dispositivo principal."
  }
};
const bitbox02Interact$9 = {
  confirmDate: "Confirme a data de hoje em sua BitBox02",
  confirmDateText: "Esta data ser usada para criar seu backup.",
  confirmName: "Confirme o nome na BitBox02",
  confirmWords: "Escreva as {{amount}} palavras de recuperao da sua BitBox02",
  confirmWordsText: "Depois disso a BitBox02 pede para voc confirmar cada palavra para verificar se o backup est correto.",
  followInstructions: "Por favor, siga as instrues na sua BitBox02.",
  followInstructionsMnemonic: "Siga as instrues em sua BitBox02 para inserir as palavras de recuperao de seu backup e restaurar sua carteira.",
  followInstructionsMnemonicTitle: "Restaurar a partir da frase de recuperao"
};
const bitbox02Settings$9 = {
  deviceName: {
    current: "Nome atual do dispositivo",
    error: "No foi possvel definir o nome do dispositivo",
    error_104: "A confirmao do nome do dispositivo foi interrompida no dispositivo.",
    input: "Nome da BitBox02",
    placeholder: "Novo nome de dispositivo",
    title: "Definir nome da BitBox02"
  },
  gotoStartupSettings: {
    description: "Isso reiniciar sua BitBox02 e entrar nas configuraes de inicializao.",
    title: "V para as configuraes de inicializao"
  }
};
const bitbox02Wizard$9 = {
  advanced: {
    button: "Opes avanadas",
    outOfDate: "Firmware desatualizado para este recurso",
    seed12WordInfo: "Observe que o nmero de palavras no pode ser alterado aps a criao da carteira.",
    seed12WordLabel: "Criar uma semente de 12 palavras em vez de 24 palavras",
    seed12WordText: "Por padro, a BitBox02 usa uma semente de 24 palavras. Ambos os tamanhos de sementes so seguros contra fora bruta na prtica. Alguns usurios podem preferir a convenincia da semente de 12 palavras.",
    skipSDCardLabel: "Pule o backup do carto microSD e anote as palavras de recuperao",
    skipSDCardText: "Voc sempre tem a opo de criar um backup em um carto microSD ou escrever suas palavras de recuperao aps a configurao. Isso pode ser feito nas configuraes.",
    title: "Opes avanadas de backup"
  },
  attestationFailed: "Falha na verificao do dispositivo, o que pode ter ocorrido ao reniciar o app enquanto o dispositivo estava esperando uma entrada do usurio. Por favor, reconecte e tente novamente. Entre em contato com support@bitbox.swiss se a falha persistir.",
  backup: {
    point1: "Selecione um backup no carto microSD",
    point2: "Defina uma senha para o seu dispositivo",
    restoreText: "Ok, vamos restaurar um backup!",
    text1: "timo, sua senha da BitBox02 foi definida e a carteira foi criada. Agora  hora de criar seu primeiro backup. Por favor, verifique se o seu carto microSD est inserido na sua BitBox02 e continue.",
    text2: "Por favor, siga as instrues na tela do seu dispositivo para criar um backup.",
    text3: "Aps o backup ser criado, remova o carto microSD e armazene-o em um <strong>local seguro</strong>. O contedo do carto microSD no  protegido por senha. Nunca insira em qualquer outro dispositivo alm de sua BitBox02.",
    userConfirmation1: "Eu devo armazenar meu backup em um local seguro.",
    userConfirmation2: "Meu backup no  protegido por senha. Qualquer pessoa com acesso a ele pode acessar minha carteira.",
    userConfirmation3: "Se eu perder ou danificar minha BitBox02, a nica maneira de recuperar meus fundos  restaurando do meu backup.",
    userConfirmation4: "Se eu perder ou danificar meu backup e minha BitBox02, meus fundos sero perdidos.",
    userConfirmation5: "Eu no devo colocar meu carto de backup microSD em um computador, telefone, impressora ou qualquer dispositivo a no ser o BitBox02. ",
    userConfirmation5mnemonic: "No devo colocar minhas palavras de recuperao em um computador, telefone, impressora ou qualquer outro dispositivo que no seja uma BitBox02."
  },
  create: {
    button: "Nomear dispositivo e continuar",
    info: "Aqui esto os passos bsicos que voc vai seguir para configurar a sua BitBox: ",
    inputTitle: "Nome da carteira",
    point1: "Nomear seu dispositivo",
    point2: "Definir uma senha para o seu dispositivo",
    point3: "Criar um backup",
    text: "Ok, vamos criar uma nova carteira!"
  },
  createBackupAborted: "Criao de backup abortada.",
  createBackupFailed: "Falha na criao do backup, tente novamente.",
  initialize: {
    passwordText: "Agora vamos definir uma senha para o seu dispositivo. Use os controles da sua BitBox para entrar e escolher uma senha.",
    passwordTitle: "Definir uma senha para a sua BitBox",
    text: "Sucesso ao emparelhar sua BitBox02! Agora vamos inicializar seu dispositivo. Comece escolhendo criar uma nova carteira ou restaurar uma carteira a partir de um backup existente. <strong>Por favor, verifique se voc tem um carto microSD inserido na sua BitBox02</strong>",
    tip: "Recomendamos que voc proceda em um ambiente seguro.",
    title: "Inicialize sua BitBox"
  },
  insertSDCard: "<strong>Por favor, verifique se voc tem um carto microSD inserido em sua BitBox02.</strong>",
  noPasswordMatch: "Senhas no conferem, tente novamente.",
  pairing: {
    failed: "Pareamento no confirmado. Por favor, reconecte sua BitBox02.",
    paired: "Voc confirmou o seguinte cdigo em seu dispositivo. Por favor continue.",
    title: "Verificar o cdigo de pareamento",
    unpaired: "Uma BitBox02 no pareada foi detectada. Verifique se o cdigo de pareamento corresponde ao que  mostrado em sua BitBox02."
  },
  restoreFromMnemonic: {
    e104: "A restaurao a partir das palavras de recuperao foi cancelada.",
    failed: "A restaurao a partir da frase de recuperao falhou, por favor, tente novamente."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, leia estas importantes consideraes de segurana:",
    createBackup: "Agora voc criar um backup no seu carto microSD.",
    createBackupMnemonic: "Agora voc anotar as palavras de recuperao."
  },
  stepBackupSuccess: {
    fundsSafe: "Para manter seus fundos seguros, lembre-se do seguinte:",
    title: "Backup restaurado!"
  },
  stepConnected: {
    unlock: "Digite a senha da BitBox02 para desbloquear."
  },
  stepCreate: {
    description: "Este nome  usado como o nome do dispositivo e para o backup.",
    nameLabel: "Nome da BitBox02",
    namePlaceholder: "Minha BitBox02",
    title: "Escolha o nome da BitBox02",
    toastMicroSD: "Por favor, insira seu carto microSD em sua BitBox02, que ser usado para armazenar um backup da carteira."
  },
  stepCreateSuccess: {
    removeMicroSD: "Remova o carto microSD de sua BitBox02 e guarde-o em um local seguro.",
    storeMnemonic: "Guarde suas palavras de recuperao em um local seguro",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "Por favor insira um carto microSD na sua BitBox02 para continuar.",
    insertSDcardTitle: "Insira carto microSD."
  },
  stepPassword: {
    e104: "A definio da senha foi cancelada.",
    title: "Definir senha da BitBox02",
    useControls: "Use os controles em sua BitBox02 para definir uma senha."
  },
  stepUninitialized: {
    create: "Quero configurar uma nova BitBox02.",
    restore: "Quero restaurar minha carteira a partir de um backup.",
    restoreMicroSD: "Restaurar a partir do carto microSD",
    restoreMnemonic: "Restaurar a partir da frase de recuperao",
    title: "Configure sua BitBox02"
  },
  success: {
    text: "Oba! Sua BitBox02 agora est pronta para uso.\n\nPara obter mais informaes sobre como usar o BitBoxApp, use o guia no aplicativo clicando no ponto de interrogao no canto superior direito.",
    title: "Voc est pronto para comear!"
  }
};
const bitsurance$3 = {
  dashboard: {
    active: "Aplice de seguro ativa",
    button: "Faa seguro de uma nova conta",
    canceled: "Cancelado",
    coverage: "Cobertura mxima",
    inactive: "Inativo",
    processing: "Em processamento",
    refused: "Recusado",
    supportLink: "Gerenciar contrato",
    title: "Contas seguradas",
    waitpayment: "Aguardando pagamento"
  },
  detect: {
    button: "Verificar se h seguro existente",
    insured: "Conta segurada detectada:",
    notInsured: "Nenhuma conta segurada detectada. Se voc tiver certeza de que possui uma conta segurada, certifique-se de ter a carteira correta conectada.",
    text: "Se voc j se cadastrou no Bitsurance, o BitBoxApp pode sincronizar automaticamente sua cobertura de seguro existente.",
    title: "J est segurado?"
  },
  insure: {
    button: "Verificar disponibilidade e preos",
    faq: "Leia mais sobre perguntas frequentes sobre Bitsurance",
    listItem1: "Roubo",
    listItem2: "Extorso (por exemplo, $5 wrench attack)",
    listItem3: "Destruio devido a incndio, gua ou desastres naturais",
    month: "ms",
    text: "Faa seguro do sua BitBox02 e de at 100.000 em bitcoin contra",
    text2: "Os planos de seguro comeam em 30/ano (2,50/ms). Voc pode aprender mais sobre o Bitsurance e suas ofertas exatas de seguros no",
    text3: "Atualmente disponvel na Alemanha, com mais regies a seguir.",
    title: "Comear"
  },
  intro: {
    link: "Site do Bitsurance",
    text1: "A BitBox trabalha com Bitsurance para adicionar uma camada adicional de proteo ao seu bitcoin. Enquanto a BitBox02 mantm seus fundos seguros, o Bitsurance cobre ameaas domsticas que no podem ser mitigadas apenas com tecnologia, como roubo, extorso ou destruio da prpria carteira de hardware."
  },
  terms: {
    link: "Poltica de Privacidade do Bitsurance",
    text1: "Bitsurance  um servio terceirizado independente. Para perguntas sobre suas ofertas e reivindicaes de seguro, entre em contato diretamente com o Bitsurance.",
    text2: "O seguro est atualmente disponvel na Alemanha, com mais regies a seguir.",
    text3: "A cobertura mxima de Bitcoin atualmente disponvel  de 100.000 euros por pessoa. Montantes mais elevados esto previstos para o futuro.",
    text4: "As informaes pessoais e a chave pblica estendida da sua conta segurada fazem parte da aplice de seguro e sero compartilhadas com o Bitsurance e a seguradora.",
    text5: "Para mais informaes sobre privacidade, consulte a"
  },
  title: "Seguro"
};
const bitsuranceAccount$3 = {
  errorNoXpub: "Erro: no foi possvel obter o xpub da conta.",
  noAccount: "No h contas que possam ser seguradas.",
  select: "Selecione a conta",
  title: "Seguro"
};
const blink$9 = {
  button: "Piscar"
};
const bootloader$9 = {
  button: "Atualizar firmware agora",
  button_install: "Instale o firmware agora",
  progress: "Atualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Atualizao bem sucedida! Por favor, insira novamente o dispositivo. Desta vez, no toque no boto."
};
const button$e = {
  abort: "Abortar",
  back: "Voltar",
  buy: "Comprar",
  changepin: "Mudar senha do dispositivo",
  check: "Checar backup",
  "continue": "Continuar",
  copy: "Copiar",
  create: "Criar",
  dismiss: "Dispensar",
  done: "Pronto",
  download: "Baixar",
  hiddenwallet: "Criar carteira oculta",
  next: "Prximo",
  ok: "OK",
  previous: "Anterior",
  receive: "Receber",
  restore: "Restaurar",
  select: "Selecionar",
  send: "Enviar",
  unlock: "Desbloquear",
  update: "Atualizar",
  upgrade: "Atualizar"
};
const buy$5 = {
  exchange: {
    bankTransfer: "Transferncia bancria",
    bestDeal: "Melhor oferta",
    creditCard: "Carto de crdito",
    fast: "Rpido",
    fee: "taxa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferncia bancria: {{fee}}%",
          creditDebitCard: "Carto de crdito/dbito: {{fee}}%",
          learnMore: "Saiba mais sobre a Moonpay",
          title: "Taxas"
        },
        fullCurrenciesList: "Veja a lista completa de moedas aqui",
        payment: {
          asteriskText: "* No disponvel para residentes nos EUA",
          bankTransfer: "Transferncia bancria*",
          bankTransferDetails: {
            pix: "PIX (transaes BR somente no Brasil)",
            sepa: "SEPA e SEPA Instant (transaes em EUR somente em pases SEPA)",
            uk: "UK Faster Payments (transaes em GBP somente no Reino Unido)"
          },
          creditDebitCard: "Carto de crdito/dbito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Veja mais detalhes sobre os mtodos de pagamento",
          title: "Mtodos de Pagamento"
        },
        supportedCurrencies: "Suporta todas as principais moedas fiducirias: USD, EUR, CHF e outras."
      },
      pocket: {
        fees: {
          info: "Transferncia bancria: {{fee}}%",
          title: "Taxas"
        },
        learnMore: "Saiba mais sobre a Pocket",
        payment: {
          bankTransfer: "Transferncia bancria",
          bankTransferDetails: {
            sepa: "SEPA e SEPA Instant (transaes em EUR somente em pases SEPA)",
            sic: "Swiss Interbank Clearing (transaes em CHF apenas em CH/LI)",
            uk: "UK Faster Payments (transaes em GBP somente no Reino Unido)"
          },
          bankTransferReccuring: "Como configurar compras recorrentes com uma ordem permanente?",
          title: "Mtodos de Pagamento"
        },
        supportedCurrencies: "Suporta moedas europeias: EUR, GBP e CHF.",
        verification: {
          info: "Requer apenas verificao de identidade acima dos limites dirios e anuais.",
          link: "Encontre os limites atuais aqui",
          title: "Verificao de Identidade"
        }
      },
      region: {
        title: "Selecione a regio em que sua conta bancria est registrada para ver quais opes esto disponveis para voc."
      }
    },
    noExchanges: "Desculpe, no h exchanges disponveis nesta regio.",
    region: "Regio",
    selectRegion: "No especificada",
    title: "Comprar {{name}}"
  },
  info: {
    "continue": "Concordo e continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Somos parceiros da MoonPay para oferecer a voc um modo perfeito de comprar {{name}} diretamente para o BitBoxApp. Em apenas alguns cliques.",
        "MoonPay  uma plataforma simples e rpida para comprar {{name}} em mais de 160 pases."
      ],
      payment: {
        details: "Voc pode comprar {{name}} instantneamente atravs da MoonPay com os seguintes mtodos de pagamento. Compras com carto de crdito ou dbito so convenientes e instantneas, mas so mais caras devido ao risco de estorno. Ns recomendamos que use a opo de transferncia bancria para quantidades maiores. A taxa mnima  de 4 USD/EUR ou equivalente.",
        footnote: "Por favor perceba que as taxas da corretora MoonPay pode ser diferente das utilizadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
        table: {
          "1_description": "Taxas baixas podem levar at 3 dias teis.",
          "1_method": "Transferncia bancria (SEPA)",
          "2_description": "Taxas altas mas rpidas e instantneas",
          "2_method": "Cartes de crdito & dbito",
          description: "Descrio",
          fee: "Taxa",
          method: "Mtodo"
        },
        title: "Mtodos de pagamento e taxas"
      },
      privacyPolicy: "Poltica de privacidade da MoonPay",
      protection: {
        description: "O BitBoxApp no coleta nenhum dado quando voc compra {{name}}, o saldo recebido  tratado como uma transao regular. A MoonPay precisa coletar alguns dados pessoais para a operao. A Poltica de Privacidade da MoonPay explica detalhadamente como esses dados so tratados.",
        descriptionGeneric: "O BitBoxApp no coleta nenhum dado quando voc compra {{name}}, os fundos recebidos so tratados como uma transao normal. No entanto, as exchanges parceiras precisam coletar algumas informaes para operar. Consulte suas respectivas polticas de privacidade para ver com mais detalhes como os dados so tratados.",
        title: "Proteo dos dados"
      },
      security: {
        description: "Quando voc compra {{name}} atravs da MoonPay, voc est usando um servio externo. Esse servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e fora do ambiente de segurana onde o aplicativo BitBoxApp est rodando.",
        descriptionGeneric: "Quando voc compra {{name}} atravs de uma exchange parceira, voc est usando um servio externo. Este servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e depende da proteo e segurana do ambiente em que o software BitBoxApp est sendo executado.",
        link: "Modelo de ameaas de segurana",
        title: "Modelo de segurana"
      },
      title: "Bem-vindo a sua loja virtual pessoal para comprar {{name}}"
    },
    next: "Prximo",
    selectLabel: "Seleciona sua conta",
    selectPlaceholder: "Selecione uma moeda",
    skip: "No mostre novamente",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Poltica de privacidade da Pocket",
      p1: "O BitBoxApp no coleta nenhum dado ao comprar bitcoin, os fundos recebidos so tratados como uma transao regular. A Pocket precisa coletar alguns dados pessoais para operar. Sua Poltica de Privacidade explica em detalhes como esses dados so tratados.",
      title: "Proteo de dados"
    },
    kyc: {
      link: "Leia as perguntas frequentes da Pocket",
      p1: "A Pocket tenta manter o KYC no mnimo. Para compras abaixo de 950 EUR (1000 CHF) por dia, no so necessrios documentos adicionais. Para compras acima desse valor, ser necessrio agendar uma ligao com a Pocket para concluir o processo KYC/AML necessrio.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Voc pode comprar bitcoin instantaneamente com a Pocket via transferncia bancria SEPA. A taxa  de 1,5% e o bitcoin  depositado em sua BitBox o mais rpido possvel aps a Pocket receber a transferncia bancria (geralmente no mesmo dia).",
      p2: "Observe que as taxas de cmbio da Pocket podem diferir daquelas usadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
      title: "Mtodos de pagamento e taxas"
    },
    previousTransactions: "O histrico de transaes desta conta no est vazio. Compartilhar esta conta tornar todas as transaes passadas e futuras visveis para a Pocket. Continuar mesmo assim?",
    security: {
      link: "Modelo de ameaas de segurana da BitBox02",
      p1: "Ao comprar bitcoin via Pocket, voc est usando um servio externo. Este servio est fora do escopo do modelo de ameaas de segurana da BitBox02 e depende da proteo e segurana do ambiente em que o software BitBoxApp est sendo executado. No entanto, trabalhamos juntos para melhorar a segurana usando um mecanismo de autenticao de dois fatores para verificar o endereo em que voc est recebendo.",
      title: "Modelo de segurana"
    },
    usedAddress: "O endereo {{address}} j foi usado, comece novamente com um novo endereo.",
    verifyBitBox02: "Verifique se o endereo que voc recebeu por e-mail corresponde ao exibido em sua Bitbox. Se possvel, voc deve abrir o e-mail em um segundo dispositivo para maior segurana.",
    welcome: {
      p1: "Fizemos parceria com a Pocket para oferecer a voc uma maneira perfeita de comprar bitcoin diretamente no BitBoxApp. So apenas alguns cliques.",
      p2: "Pocket  uma plataforma sua que facilita e agiliza a compra de bitcoin na maior parte da Europa (em qualquer lugar onde as transferncias bancrias SEPA sejam suportadas).",
      p3: "Com a Pocket, voc tambm pode fazer compras regulares por meio de ordens bancrias recorrentes, para poder fazer DCA (dollar-cost averaging) com facilidade.",
      title: "Bem-vindo ao seu balco nico para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
};
const changePin$9 = {
  newTitle: "Nova senha do dispositivo",
  oldLabel: "Senha atual do dispositivo"
};
const chart$5 = {
  dataMissing: "Buscando dados histricos... fique ligado.",
  dataOldTimestamp: "Atualizao das taxas de cmbio histricas. O grfico no est exibindo dados aps {{time}}.",
  dataUpdating: "atualizando dados...",
  filter: {
    all: "Todos",
    month: "Ms",
    week: "Semana",
    year: "Ano"
  }
};
const checkSDcard$9 = "checando carto microSD";
const clickHere$9 = "Clique aqui.";
const confirm$b = {
  abortInfo: "Toque para ",
  abortInfoRedText: "abortar",
  approveInfo: "Segure 4 segundos ou mais para ",
  approveInfoGreenText: "confirmar",
  info: "Prossiga na sua BitBox.",
  infoWhenPaired: "Primeiro no celular emparelhado e depois na sua BitBox"
};
const confirmOnDevice$9 = "Por favor, confirme no seu dispositivo.";
const connectKeystore$4 = {
  promptNoName: "Por favor conecte sua BitBox02 para continuar",
  promptWithName: 'Por favor conecte sua BitBox02 chamada "{{name}}" para continuar'
};
const darkmode$4 = {
  toggle: "Modo escuro"
};
const device$9 = {
  appUpradeRequired: "Sua BitBox no  compatvel com este aplicativo. Por favor, baixe e instale a verso mais recente.",
  keystoreConnected: "Carteira conectada"
};
const deviceLock$9 = {
  button: "Ativar autorizao de dois fatores (2FA)",
  condition1: "Voc tem um backup?",
  condition2: "A verificao pelo aplicativo de celular est funcionando?",
  condition3: "2FA DESATIVA backups e emparelhamento de aplicativos mveis. O dispositivo precisa ser RESETADO para sair do 2FA!",
  confirm: "Ativar autorizao de dois fatores (2FA)",
  title: "Ativar autorizao de dois fatores (2FA)"
};
const deviceSettings$9 = {
  backups: {
    manageBackups: {
      description: "Criar ou verificar o backup do carto microSD."
    },
    showRecoveryWords: {
      description: "Mostrar e verificar palavras de recuperao."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "O BitBoxApp verifica se o seu dispositivo  autntico."
    },
    deviceName: {
      description: "Altere o nome do seu dispositivo."
    },
    rootFingerprint: {
      description: "A impresso digital raiz  um identificador exclusivo da carteira atualmente em uso. Pode ajud-lo a distinguir entre diferentes carteiras se voc usar frases secretas."
    },
    securechip: {
      description: "O modelo do chip seguro."
    },
    title: "Informaes do dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Redefina seu dispositivo para as configuraes de fbrica. Isso exclui a carteira de sua BitBox02!",
      title: "Restaurao de fbrica"
    },
    goToStartupSettings: {
      description: "Acesse o bootloader da BitBox02. Voc pode habilitar o hash do firmware aqui."
    },
    passphrase: {
      description: "Ative ou desative o recurso de frase secreta.",
      title: "Frase secreta"
    }
  },
  firmware: {
    firmwareVersion: "Verso do firmware",
    newVersion: {
      label: "Verso disponvel"
    },
    title: "Firmware",
    upToDate: "Seu dispositivo est atualizado",
    upgradeAvailable: "Nova atualizao disponvel",
    version: {
      label: "Verso"
    }
  },
  hardware: {
    attestation: {
      "false": "Falha na verificao de autenticidade",
      label: "Verificao de autenticidade",
      "true": "Sua BitBox02  autntica"
    },
    sdcard: {
      "false": "No inserido",
      label: "Carto microSD",
      "true": "Inserido"
    },
    securechip: "Chip seguro",
    title: "Hardware"
  },
  loading: "Recuperando informaes do dispositivo...",
  pairing: {
    lock: {
      "false": "Desativado",
      label: "Autorizao de dois fatores (2FA)",
      "true": "Ativado"
    },
    mobile: {
      "false": "Fechado",
      label: "Aplicativo mvel",
      "true": "Abrir"
    },
    status: {
      "false": "No emparelhado",
      label: "Status",
      "true": "Emparelhado"
    },
    title: "Emparelhamento"
  },
  secrets: {
    manageBackups: "Gerenciar backups",
    title: "Privacidade"
  }
};
const deviceTampered$9 = "Sua BitBox foi fornecida com uma senha de recuperao? Se sim, pare o processo de configurao e contate o suporte imediatamente. A Shift nunca lhe dar uma carteira pronta ou far recomendaes de senha.";
const dialog$a = {
  cancel: "Cancelar",
  confirm: "Confirmar",
  confirmTitle: "Confirmao"
};
const error$5 = {
  accountAlreadyExists: "A conta j existe.",
  accountLimitReached: "No foi possvel adicionar a conta. O nmero mximo de contas para essa moeda foi atingido.",
  aoppCallback: "Ocorreu um erro ao entregar o endereo para {{host}}.",
  aoppInvalidRequest: "Pedido invlido.",
  aoppNoAccounts: "No h contas disponveis.",
  aoppSigningAborted: "Solicitao de propriedade de endereo cancelada.",
  aoppUnknown: "Ocorreu um erro desconhecido.",
  aoppUnsupportedAsset: "O ativo no  compatvel.",
  aoppUnsupportedFormat: "No h contas disponveis que suportem o formato de endereo solicitado.",
  aoppUnsupportedKeystore: "O dispositivo conectado no pode assinar mensagens para este ativo.",
  aoppVersion: "Verso desconhecida.",
  wrongKeystore: "Carteira errada conectada. Certifique-se de inserir o dispositivo correto que corresponde a esta conta.",
  wrongKeystore2: " Se voc estiver usando a frase secreta opcional, certifique-se de ter digitado a frase secreta correta para a conta."
};
const fiat$b = {
  "default": "padro",
  setDefault: "Definir {{code}} como padro",
  title: "Moedas"
};
const footer$b = {
  appVersion: "Verso do aplicativo:"
};
const generic$5 = {
  enabled_false: "Desabilitado",
  enabled_true: "Habilitado"
};
const genericError$9 = "Um erro ocorreu. Se voc notar algum problema, por favor, reinicie o aplicativo.";
const goal$9 = {
  buttons: {
    create: "Criar uma nova carteira",
    restore: "Restaurar uma carteira de um backup"
  },
  paragraph: "Por favor, selecione uma das seguintes opes:",
  step: {
    "1": {
      title: "Informao de segurana"
    },
    "2": {
      description: "Definir uma senha do dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Criar uma nova carteira",
      title: "Carteira"
    },
    "3-restore": {
      description: "de um backup",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumo"
    },
    "4-restore": {
      title: "Resumo"
    }
  }
};
const guide$a = {
  accountDescription: {
    text: 'A viso geral da sua conta mostra seu saldo disponvel, alm de transaes de entrada e sada. Nosso guia em "Configuraes" contm mais informaes sobre cada tipo de conta. ',
    title: "O que esta pgina me mostra?"
  },
  accountFiat: {
    text: "Sim. Clique em qualquer cdigo para alternar entre moedas fiducirias. Voc pode alterar a lista de moedas nas configuraes.",
    title: "Posso exibir outras taxas de converso?"
  },
  accountIncomingBalance: {
    text: "Lanamentos soma os valores transferidos para voc ainda no confirmados pela rede.",
    title: "O que significa lanamentos?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Cada xpub  atrelado ao "Tipo" mostrado: tanto o "Segwit Nativo (bech32)" como ao "Wrapped Segwit" ou "Taproot" (somente Bitcoin). Esses so tipos de scripts usados pela {{coinName}}. O BitBoxApp combina eles, suportando mltiplos tipos de scripts na mesma conta. Por isso cada tipo de script te fornece um xpub diferente, existem vrios xpubs por conta.\n\nSe voc recebe constantemente em um tipo de endereo padro (Segwit Nativo), voc s precisa do xpub "bech32". Entretando, se voc tambm recebe valores nos tipos "Wrapped Segwit" ou "Taproot", voc precisa usar as chaves pblicas estendidas do "Wrapped Segwit" e "Taproot" respectivamente.',
      title: "Por que tem vrios xpubs?"
    },
    privacy: {
      text: "Para esse tipo especfio de conta, a chave pblica estendida revela seu histrico financeiro completo, seu saldo em conta e todas suas transaes futuras. Mas a xpub no permite que ningum gaste suas moedas.\n\nSe voc fornecer sua xpub  algum, voc dever ter em mente que essa pessoa ou empresa poder ver todas as transaes antigas da sua conta. Assim achamos uma boa idia que voc use essa conta somente para esse propsito e mantenha seus fundos salvos em contas diferentes dessa.",
      title: "Por que preciso manter minha xpub secreta?"
    },
    verify: {
      text: "Sim,  sempre uma boa idia revisar sua xpub. Se alguma outra pessoa gerar um endereo de recebimento atravs da sua xpub para mandar seu dinheiro, isso  muito importante. Voc precisa verificar no dispositivo para garantir que essa xpub pertence a voc para que seus fundos no acabem indo para endereos errados e sejam perdidos.",
      title: "Preciso verificar minha xpub nesse dispositivo?"
    },
    xpub: {
      text: "Uma chave pblica estendida (xpub)  uma chave-raiz da qual todos os endereos de recebimento de uma conta so derivados.\n\nEla  fornecida aqui para uso avanado e interoperabilidade com carteiras watch-only, como Electrum ou Sentinel. Se voc recebeu de diferentes tipos de endereo, importe todos os formatos diferentes de xpub em sua carteira watch-only para ver todas as suas moedas.\n\nPor favor, note que que carteiras de terceiros podem no suportar xpubs do tipo Taproot ainda.",
      title: "O que  uma chave pblica estendida?"
    }
  },
  accountRates: {
    text: "Ns atualizamos as taxas de cmbio a cada minuto no CoinGecko.",
    title: "Quais taxas de cmbio so aplicadas?"
  },
  accountReload: {
    text: "No h necessidade. Suas informaes de transao so atualizadas automaticamente.",
    title: "Posso recarregar o histrico de transaes?"
  },
  accountSendDisabled: {
    text: 'O boto "Enviar"  ativado quando seu saldo for maior que zero.',
    title: "Por que no consigo enviar {{unit}}?"
  },
  accountSummaryAmount: {
    text: "O montante total  a soma de de saldo de todas sua contas crypto. Taxas de troca so obtidas atravs da coingecko.com.\n\nObs: Se voc usa a MyEtherWallet para tokens ela no  suportada no BitBoxApp, por isso no ser incluso no montante total mostrado.",
    title: "Como o valor total  calculado?"
  },
  accountSummaryDescription: {
    text: "Aqui voc pode ver o desempenho do seu portflio ao longo do tempo. Um resumo de suas contas crypto individuais  exibido abaixo do grfico.",
    title: "O que essa pgina me mostra?"
  },
  accountTransactionAttributesBTC: {
    text: "Tamanho virtual: determina a taxa de rede. Voc economizou com sucesso em taxas se for menor que o tamanho da transao.\nTamanho: tamanho real da transao em bytes quando serializado de acordo com a blockchain subjacente.\nPeso: uma nova mtrica introduzida no Segwit para avaliar os tamanhos de transao e bloco. Cada segregated witness (segwit) byte conta como um, todo o resto como quatro unidades de peso. Em vez de um megabyte em tamanho real, o limite de tamanho do bloco agora  de quatro milhes de unidades de peso.",
    title: "E os detalhes da transao especfica do Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmaes: sua primeira transmisso de transao no  confirmada at que um minerador a inclua em um bloco, isso s acontece aps uma confirmao. Cada bloco transmitido na rede adiciona outra confirmao  sua transao. Geralmente, os comerciantes e outros agentes da rede somente liquidam transaes com trs a seis confirmaes.\nID da transao: um nmero de identificao exclusivo que permite procurar uma transao em um explorador de blocos.\nTaxa: Os mineradores recebem uma taxa de minerao como incentivo para incluir transaes nos blocos que mineram. Para saber mais, clique no boto enviar.",
    title: "Quais so as informaes nos detalhes da transao?"
  },
  accountTransactionConfirmation: {
    text: "Uma transao transmitida para a rede, mas ainda no confirmada.",
    title: "O que  uma transao pendente?"
  },
  accountTransactionLabel: {
    text: " o endereo para o qual voc recebeu ou enviou moedas.",
    title: "Qual endereo  exibido para cada transao?"
  },
  accountTransactionTime: {
    text: "O horrio de confirmao da transao blockchain.",
    title: "Qual horrio  exibido?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin e Litecoin podem ter uma quantidade arbitrria de contas. Aps cinco contas, voc s pode adicionar outra conta se a conta anterior tiver sido usada. Outras moedas podem ter um mximo de cinco contas.",
      title: "Quantas contas posso criar?"
    },
    howtoAddTokens: {
      text: 'Tokens usando o padro ERC20 so atrelados a uma conta Ethereum especfica. Para habilitar ou desabilitar um token em particular, abra a tela "Gerenciar contas", e expanda at a sua conta Ethereum e mude o token desejado para ligado ou desligado.',
      title: "Como posso adicionar mais tokens?"
    },
    moveFunds: {
      text: "Sim. Porque as contas so independentes, voc deve mandar saldo usando uma transao regular.",
      title: "Posso mover saldo entre contas?"
    },
    recoverAccounts: {
      text: "Sim, O BitBoxApp cria suas contas usando o melhor padro estabelecido compatvel com a maioria das outras carteiras de crypto.",
      title: "Posso recuperar minhas contas com outras carteiras?"
    },
    whatAreAccounts: {
      text: "Sua carteira pode gerenciar contas mltiplas da mesma moeda. Vrias contas so de extrema ajuda para manter seus fundos separadamente.",
      title: "O que so contas?"
    },
    whatIsRememberWallet: {
      text: "Ativar Lembrar carteira permite que voc veja as contas desta carteira no BitBoxApp mesmo quando a BitBox02 no est conectada. Isso permite checar seu saldo e portflio quando quiser. A BitBox02 ainda precisa ser conectada e desbloqueada para enviar ou receber moedas.\n\nDesativar Lembrar carteira exige que voc conecte a respectiva BitBox02 (ou a carteira com frase secreta) para ver essas contas no BitBoxApp.",
      title: "O que acontece quando eu habilito/desabilito Lembrar carteira?"
    },
    whyIsThisUseful: {
      text: 'Contas so timas para gerenciar seus fundos para pessoas ou propsitos diferentes porque so separadas. Voc pode tambm compartilhar sua "chave pblica estendida" de uma conta sem revelar nada sobre suas outras contas.Isso permite voc repetidamente receber saldo sem reutilizar os seus endereos, bem como receber seu salrio ou seu saldo de crypto que for comprado.',
      title: "Por que isso  til?"
    }
  },
  appendix: {
    link: "Contate-nos!",
    text: "Outra pergunta?"
  },
  backups: {
    check: {
      text: "'Checar backup' permite verificar se voc tem um backup funcionando correspondente  sua carteira atual. Tambm pode ser usado para verificar se voc ainda tem a senha de recuperao correta. Voc pode verificar sua senha de recuperao principal ou sua senha de recuperao oculta.",
      title: "O que  'Checar backup'?"
    },
    encrypt: {
      text: "No, mas sua senha de recuperao  necessria para derivar a carteira a partir da semente armazenada.",
      title: "Posso criptografar o backup?"
    },
    howOften: {
      text: "O backup  gerado automaticamente quando uma nova carteira  criada. Voc s precisa fazer um novo backup se o seu carto microSD for perdido ou danificado ou se desejar usar vrios cartes microSD como backups.\nVoc no precisa criar novos backups depois das atividades de transao. Todos os seus dados de transao podem ser recriados pelo backup nico que foi gerado automaticamente para voc.",
      title: "Com que frequncia tenho que fazer um backup?"
    },
    whatIsABackup: {
      text: " uma cpia da semente em um carto microSD. A semente junto com sua senha de recuperao gera sua carteira.",
      title: "O que  um backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Checar backup' permite verificar se voc tem um backup funcionando correspondente  sua carteira atual.",
      title: "O que  'Checar backup'?"
    },
    encrypt: {
      text: 'No. Por favor, mantenha o carto microSD seguro, pois ele contm a semente no criptografada para recuperar sua carteira. Se voc deseja proteger sua semente com senha,  possvel ativar uma frase secreta opcional nas configuraes de especialistas em "Gerenciar dispositivo".',
      title: "Posso criptografar o backup?"
    },
    whatIsABackup: {
      text: " uma cpia da semente em um carto microSD.",
      title: "O que  um backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Quando o 2FA  ativado, todas as transaes de moedas precisam ser aprovadas no celular emparelhado. Internamente, um nmero de uso nico criptografado  enviado para o aplicativo mvel,  descriptografado e retornado  BitBox ao pressionar o boto Aceitar. Esta comunicao com o dispositivo  feita atravs do canal entre o telefone celular e este aplicativo de desktop estabelecido durante o emparelhamento.\n\nCertifique-se de fazer um backup de sua carteira e emparelhar o aplicativo mvel antes de ativar o 2FA. Uma vez ativado, o slot de carto microSD e o emparelhamento via aplicativo mvel so desativados. Eles podem ser reativados resetando a BitBox, o que formata o dispositivo.",
      title: "Como funciona a autenticao de dois fatores (2FA)?"
    },
    disable2FA: {
      text: `Para desabilitar o 2FA, voc precisa resetar a sua BitBox e restaurar a carteira atravs do seu backup. Certifique-se de que voc ainda tem o carto microSD com o backup e que voc ainda se lembra da senha de recuperao. Em seguida, pressione 'Resetar dispositivo'. Defina uma nova senha para o dispositivo e escolha "Ou restaurar a partir de um backup". Selecione o backup que voc fez da carteira, clique em 'Restaurar' e insira a senha de recuperao que voc usou ao criar a carteira.`,
      title: "Como posso desativar a autorizao de dois fatores (2FA)?"
    },
    ejectBitbox: {
      text: "Voc pode desconectar a BitBox a qualquer momento sem precisar ejet-la primeiro.",
      title: "Como posso ejetar a BitBox?"
    },
    ejectSD: {
      text: "Voc pode remover o carto microSD da BitBox a qualquer momento, desde que no esteja criando ou restaurando um backup.",
      title: "Como posso ejetar o carto microSD?"
    },
    hiddenWallet: {
      text: " uma segunda carteira no mesmo dispositivo protegida por uma senha de dispositivo e senha de recuperao diferentes, que voc pode usar para negao plausvel (plausible deniability). A mesma semente do backup  usada para sua carteira normal e oculta, portanto, nenhum backup adicional  necessrio.",
      title: "O que  uma carteira oculta?"
    },
    legacyHiddenWallet: {
      text: "Primeiro, clique no boto abaixo (disponvel se a BitBox estiver desbloqueada com a senha principal do dispositivo e o 2FA estiver desabilitado), em seguida, reconecte sua BitBox e desbloqueie-a com a senha oculta do dispositivo.",
      title: "Como fao para acessar a carteira legacy oculta?"
    },
    pairing: {
      text: "Depois de fazer o download do nosso aplicativo para dispositivos mveis para iOS ou Android, escaneie o QR code exibido, que cria um canal seguro entre o aplicativo mvel e este aplicativo. Depois de escanear, siga as instrues no aplicativo para dispositivos mveis.",
      title: "Como emparelhar de forma segura com o seu telefone"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Verifique o site do Bitsurance e suas perguntas frequentes para obter mais detalhes.",
      title: "Mais perguntas?"
    },
    privacy: {
      link: {
        text: "Poltica de privacidade do Bitsurance"
      },
      text: "Como qualquer aplice de seguro regular, ela contm seu nome e endereo completos e especifica o objeto segurado (definido pela chave pblica estendida da conta Bitcoin segurada). Esses dados so enviados diretamente ao Bitsurance e no so compartilhados com a Shift Crypto. Por favor consulte a poltica de privacidade do Bitsurance para mais informaes",
      title: "Quais informaes pessoais so necessrias para o seguro?"
    },
    renew: {
      text: "O seguro ser renovado automaticamente para o prximo ano. Voc pode cancelar a renovao a qualquer momento clicando em Gerenciar contrato no BitBoxApp, que o leva ao portal do cliente Bitsurance.",
      title: "Como posso renovar ou cancelar o seguro?"
    },
    status: {
      text: "As contas seguradas com sucesso so marcadas com um emblema verde segurado no canto superior esquerdo de cada pgina da conta Bitcoin. Na seo Seguro, voc pode ver a viso geral de todas as contas Bitcoin seguradas e seu status atual de seguro.",
      title: "Posso verificar o status de uma conta segurada?"
    },
    what: {
      text: "Cada contrato de seguro Bitcoin cobre uma conta de carteira especfica. Voc pode segurar vrias contas contratando vrias aplices de seguro. As contas seguradas esto limitadas ao uso de endereos Bitcoin Segwit Nativo.",
      title: "Toda a carteira BitBox est segurada?"
    },
    who: {
      text: "O seguro  oferecido pelo Bitsurance, uma corretora de seguros criada por bitcoiners. Eles trabalham com o seguro ELEMENT para fornecer seguro de Bitcoin. Ambas as empresas esto sediadas na Alemanha.",
      title: "Quem est assegurando meu bitcoin?"
    },
    why: {
      text: "O Bitsurance cobre alguns riscos de autocustdia que no esto no escopo nem mesmo da carteira mais segura, por exemplo. roubo, extorso ou destruio da carteira. A deciso  sua se voc precisa de cobertura de seguro para esses riscos.",
      title: "Preciso de seguro de Bitcoin?"
    }
  },
  cointracking: {
    text: 'Clique no boto "Exportar" e abra a pasta de downloads onde voc ira encontrar seu arquivo CSV exportado. Depois clique no link abaixo, faa upload do arquivo CSV BitBox e importe ele a fim de usar os dados no seu Gerenciador de rastreamento de moeda e poder criar seus relatrios de taxa.',
    title: "Como importar minhas transaes para a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leia mais sobre a verificao de autenticidade"
      },
      text: "O BitBoxApp executa uma verificao de atestado na BitBox02 para verificar se o dispositivo  genuno. A verificao  feita localmente e no se conecta a nenhum servidor.",
      title: "Como funciona a verificao de autenticidade?"
    },
    name: {
      text: "Este  o nome da sua carteira e backup. O nome  usado para backups futuros e pode ser usado para ajudar a distinguir entre diferentes carteiras. Ele pode ser alterado a qualquer momento, mas observe que os backups feitos antes da alterao ainda usaro o nome anterior.",
      title: "Para que serve o nome da BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leia mais sobre o chip seguro"
      },
      text: "Esta informao mostra o nmero do modelo do chip seguro, o chip mais atualizado  o ATECC608B com recursos de segurana aprimorados em comparao com modelos mais antigos.",
      title: "Por que mostrar o modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Voc pode dar o endereo para que outras pessoas lhe enviem algumas moedas. Apenas certifique-se de que esto enviando para o endereo correto.",
      title: "O que eu fao com um endereo?"
    },
    addressChange: {
      text: "Assim que voc realiza a transao, um novo endereo  automaticamente adicionado  lista, para que haja sempre 20 endereos disponveis que nunca receberam moedas.",
      title: "Quando os endereos mudam?"
    },
    addressFormats: {
      text: "Por padro, o tipo de endereo  Segwit Nativo. Esse tipo de endereo  amplamente adotado por outras carteiras/corretoras e oferece as melhores taxas para transaes habituais. No entanto, voc tambm pode optar por enviar para Taproot (somente Bitcoin), que  o tipo de endereo mais recente, mas pode no ser amplamente suportado ainda. Alternativamente, se voc estiver tendo problemas para enviar para o Segwit Nativo (o tipo padro), tente alternar para o tipo de endereo mais antigo Wrapped Segwit que pode ser compatvel com mais carteiras/corretoras.",
      title: 'Quando usar "Alterar tipo de endereo"?'
    },
    howVerify: {
      text: "Para a BitBox01, clique no cone BitBox na barra lateral  esquerda e veja a seo Emparelhamento. O guia ser atualizado e voc poder continuar seguindo as instrues.\nPara a BitBox02, voc pode verificar os endereos diretamente no dispositivo durante o processo de envio/recebimento.",
      title: "Como posso verificar um endereo com segurana?"
    },
    plugout: {
      text: "No, uma vez que voc enviou moedas para o seu endereo BitBox, voc no precisa deixar sua BitBox conectada. Voc pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o recebimento?"
    },
    why20: {
      text: 'Durante a inicializao, o aplicativo gera endereos derivados de sua semente para ver se eles receberam fundos. Como o aplicativo pode gerar um nmero quase infinito de endereos, poderia levar anos determinando o saldo. Para limitar essa pesquisa, ele para depois de ver 20 endereos que nunca receberam fundos. Esse  o "gap limit" e 20  um padro de fato, embora o nmero seja arbitrrio. Estes so os 20 endereos que voc pode escolher.',
      title: "Por que apenas 20 endereos?"
    },
    whyMany: {
      text: "Para manter a privacidade e a segurana, nunca distribua o mesmo endereo duas vezes. Se voc usou um endereo, clique na seta para a direita para obter um novo endereo. Voc pode gerar at 20 endereos por vez. Pense em endereos como nmeros de fatura. Todos os endereos so derivados de sua nica semente de backup.",
      title: "Por que tantos endereos?"
    },
    whyVerify: {
      text: "Voc no deve confiar no seu computador para gerar e exibir endereos autnticos. As diferentes formas que um computador convencional pode ser atacado o torna significativamente mais vulnervel do que uma carteira de hardware. Para a BitBox01, o boto para verificar o endereo envia o endereo com segurana para um telefone celular emparelhado, a partir do qual voc tambm pode digitalizar e verificar o QR code. Para a BitBox02, o endereo pode ser verificado diretamente no visor da BitBox02.",
      title: "Por que devo verificar o endereo com segurana?"
    }
  },
  send: {
    change: {
      text: "O troco ser devolvido a um endereo Taproot se voc tiver pelo menos um Taproot UTXO. Se voc usar o controle de moedas, o troco ser devolvido a um endereo Taproot se houver pelo menos um Taproot UTXO entre os UTXOs selecionados. Em todos os outros casos, o troco  devolvido a um endereo Segwit Nativo.",
      title: "Como o output do troco  determinado?"
    },
    fee: {
      text: "A taxa  baseada no tamanho dos dados da transao e no no valor. As metas de taxas so calculadas pelo algoritmo de estimativa de taxas do Bitcoin Core para cada prioridade de rede que voc escolher. Elas so mostradas se tiverem um valor diferente do objetivo abaixo.\nEconmica: 24 blocos (cerca de 4 horas para Bitcoin, 1 hora para Litecoin)\nBaixa: 12 blocos (cerca de 2 horas para o Bitcoin, 30 minutos para o Litecoin)\nNormal: 6 blocos (cerca de 1 hora para o Bitcoin, 15 minutos para o Litecoin)\nAlta: 2 blocos (cerca de 20 minutos para Bitcoin, 5 minutos para Litecoin)\n(Um bloco demora, em mdia, dez minutos para Bitcoin (2,5 minutos para Litecoin) para ser minerado e o carregamento da rede pode variar consideravelmente nos perodos acima.)",
      title: "Como a taxa  determinada?"
    },
    plugout: {
      text: "No, uma vez que voc tenha feito uma transao, voc no precisa deixar sua BitBox conectada. Voc pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o envio?"
    },
    priority: {
      text: "Tipicamente, quanto maior a taxa que voc est disposto a pagar, mais rapidamente sua transao  confirmada pela rede.",
      title: "Qual  a prioridade da rede?"
    },
    revert: {
      text: "Depois que uma transao  assinada e enviada (ou seja, transmitida para a rede), ela no pode mais ser revertida. Verifique as transaes (incluindo a taxa) corretamente antes de assinar!\nSe voc conhece o destinatrio e ele ou ela est disposto a enviar o mesmo valor (menos as taxas de transao) de volta para voc, voc pode enviar um novo endereo de recebimento.",
      title: "Posso reverter uma transao?"
    },
    whyFee: {
      text: "As transaes esto competindo para serem confirmadas por um minerador. Mineradores escolhem transaes para serem includas na blockchain com base em sua taxa.\nOs mineradores votam no histrico das transaes. Como no h nenhum terceiro confivel para fazer valer um voto por pessoa (que  a ideia das blockchains), os mineradores votam em transaes sacrificando um recurso caro como o poder de computao. Como recompensa por seu trabalho, eles podem reivindicar moedas recm-criadas e a taxa de todas as transaes includas.",
      title: "Por que h uma taxa de rede?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Se voc pretente apenas conectar seu n quando voc tiver em uma rede especfica (ex: seu wifi de casa), ento uma comunicao padro apenas  suficiente.\nNesse caso  aconselhado que seu servidor Electrum fornea um certificado TLS para encriptar a comunicao.\nSe voc prente conectar seu n de qualquer lugar usando o protocolo Tor a melhor opo e necessria  no usar um certificado TLS para esse caso.",
      title: "Devo usar clearnet TCP, TLS ou Tor?"
    },
    instructions: {
      link: {
        text: "Guia para conectar seu n"
      },
      text: "Para um tutorial completo, por favor visite nosso guia:",
      title: "Como conecto meu BitBoxApp no meu prrprio n?"
    },
    options: {
      text: "Existem vrias opes para voc rodar seu prprio n, como comprar um dispositivo prprio, construir um ou usar a rede Bitcoin Core.\nSe voc deseja conectar seu BitBoxApp no seu n, certifique-se de quele roda um servidor Electrum compatvel. Trata-se de um programa dedicado que permite que seu aplicativo de carteira se comunique com seu prprio n.\nOperaes suportadas incluem Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).",
      title: "Quais opes tenho para rodar um n?"
    },
    tor: {
      text: "Tor significa 'The Onion Router', que  um software de cdigo aberto e gratuito que oferece muitos benefcios de privacidade e  especialmente til ao usar Bitcoin.\nSe voc pretende se conectar ao seu node atravs do Tor, certifique-se de que o Tor est instalado no seu computador e ative o Proxy Tor nas configuraes do BitBoxApp.\nNa maioria dos sistemas operacionais, existem duas maneiras de executar o Tor:\n1. Navegador Tor: baixe e abra o navegador Tor. Isso permitir que o BitBoxApp se conecte  rede Tor configurando a porta 9150 nas configuraes de proxy do Tor.\n2. Servio Tor em segundo plano: instale o daemon Tor, que sempre  executado em segundo plano. O BitBoxApp pode ento se conectar definindo a porta 9050 nas configuraes de proxy do Tor.",
      title: "O que  Tor, proxy Tor e qual porta devo usar?"
    },
    what: {
      text: " possvel alimentar sua carteira com seus prprios full nodes em vez de usar os servidores Shift.",
      title: "O que  isso?"
    },
    why: {
      text: "Executar seu prprio node no  necessrio, mas melhora a privacidade e reduz a necessidade de confiar nos outros.\nEm primeiro lugar, significa que voc est usando o Bitcoin de forma mais privada, pois o BitBoxApp no se conecta aos nossos servidores para buscar seu histrico de transaes; em vez disso, ele buscar essas informaes em seu prprio node.\nEm segundo lugar, executar seu prprio node significa que ele verifica todas as transaes por si mesmo, garantindo que as regras de consenso sejam aplicadas.",
      title: "Por que devo executar meu prprio node?"
    }
  },
  settings: {
    sats: {
      text: "Um Satoshi ('sat' para abreviar)  a menor unidade de Bitcoin. Um Satoshi  um centsimo milionsimo de um bitcoin (0,00000001 BTC).  o nome do criador do Bitcoin, Satoshi Nakamoto.",
      title: "O que  um Satoshi?"
    },
    servers: {
      text: "Este aplicativo se comunica com os servidores Shift Crypto para verificar atualizaes, carregar transaes e enviar informaes para aplicativos mveis emparelhados.\nO aplicativo tambm busca as taxas de cmbio mais recentes do CoinGecko. Todas as converses so calculadas localmente, o que significa que nenhum dado sobre o valor da sua transao  transmitido.\nNota: Para Ethereum e ERC20 Tokens, ns usamos APIs do Etherscan.io.",
      title: "Com quais servidores este aplicativo se comunica?"
    }
  },
  title: "Guia",
  toggle: {
    close: "Fechar guia",
    open: "Guia"
  },
  trackingModePortfolioChart: {
    text: "No desktop passe o cursor sobre o grfico. No celular, segure o dedo no grfico e arraste horizontalmente.",
    title: "Como ver os valores histricos no grfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Voc precisa resetar o dispositivo e restaurar a carteira a partir de um backup, usando a senha de recuperao.",
      title: "O que fao se eu esquecer a senha do dispositivo?"
    },
    reset: {
      text: "Digite uma senha do dispositivo errada 15 vezes. As ltimas tentativas exigem um toque longo no dispositivo.",
      title: "Como fao para resetar o dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "O dispositivo deve piscar uma vez quando inserido. Certifique-se de que est inserido de maneira correta. Se voc est tendo problemas, por favor, entre em contato conosco atravs do link abaixo.\n\nA BitBox01 no  suportada em dispositivos mveis. Por favor, use o BitBoxApp no Desktop para conectar sua BitBox01.",
      title: "Minha BitBox01 no  reconhecida"
    },
    getDevice: {
      link: {
        text: "Encomendar uma BitBox"
      },
      text: "Voc pode comprar uma BitBox em nossa loja online:",
      title: "Como posso obter um dispositivo?"
    },
    internet: {
      text: "Sim, uma conexo com a internet  necessria para sincronizar a carteira, enviar transaes e buscar as taxas de cmbio mais recentes.",
      title: "Este aplicativo requer uma conexo com a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de backup"
      },
      text: "Voc pode recuperar suas contas em uma nova BitBox ou com o nosso centro de backup.",
      title: "Eu perdi meu dispositivo. E agora?"
    },
    useWithoutDevice: {
      text: "Infelizmente, isso ainda no  possvel no momento.",
      title: "Posso usar o aplicativo sem um dispositivo?"
    },
    welcome: {
      text: "Obrigado por usar este aplicativo criado pela Shift Crypto na Sua. Agradecemos qualquer contribuio que voc tenha para compartilhar. Por favor, d feedback usando o link na parte inferior.",
      title: "Bem-vindo ao BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se voc estiver usando um novo telefone/computador com o BitBoxApp, precisar se conectar aos DApps novamente. Voc ver suas moedas no dapp novamente, como de costume.",
      title: "No vejo minhas conexes anteriores."
    },
    supportedNetworks: {
      text: "Atualmente, apenas a rede principal Ethereum  suportada usando WalletConnect no BitBoxApp. Para usar outras cadeias compatveis com a EVM, use a carteira de extenso do navegador Rabby.",
      title: "Quais redes so suportadas?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect  um protocolo de comunicao para aplicativos web3. Ele permite que voc se conecte convenientemente a DApps baseados em Ethereum e carteiras web sem usar um aplicativo de terceiros, o que  particularmente til para usurios Android do BitBoxApp.",
      title: "O que  WalletConnect?"
    }
  }
};
const headerssync$9 = {
  blocksSynced: "{{blocks}} blocos sincronizados"
};
const hiddenWallet$9 = {
  info1HTML: "Para fins de negao plausvel (plausible deniability), uma carteira oculta pode ser criada com base em uma combinao de senha de recuperao e uma senha de dispositivo <strong>diferente</strong>.",
  info2HTML: "Defina a senha do dispositivo e a senha de recuperao que voc deseja associar  sua carteira oculta abaixo. A senha do dispositivo e a senha de recuperao devem ser <strong>diferentes</strong> das que voc definiu para sua carteira principal.",
  passwordLabel: "Senha de recuperao oculta",
  passwordPlaceholder: "Por favor, confirme a senha de recuperao oculta",
  pinLabel: "Senha oculta do dispositivo",
  pinRepeatLabel: "Repita a senha oculta do dispositivo",
  pinRepeatPlaceholder: "Por favor, confirme a senha oculta do dispositivo",
  success: "Carteira oculta criada com sucesso. Reconecte a sua BitBox para desbloque-la."
};
const initialize$9 = {
  create: "Definir senha do dispositivo",
  creating: "Configurando senha do dispositivo...",
  error: {
    e102: "A senha do dispositivo precisa conter pelo menos 4 caracteres."
  },
  info: {
    description1: "Escolha a senha do seu dispositivo. Ela ser usada para desbloquear a sua BitBox.",
    description2: "Voc pode usar nmeros, letras & smbolos. Senhas maiores oferecem mais segurana.",
    description3: "Se voc perder a senha do dispositivo, precisar reset-lo e restaurar o backup da carteira.",
    subtitle: "Agora voc vai definir a senha do seu dispositivo",
    title: "Inicializando seu dispositivo"
  },
  input: {
    label: "Senha do dispositivo",
    labelRepeat: "Repita a senha do dispositivo",
    placeholderRepeat: "Por favor, confirme a senha do dispositivo"
  }
};
const invalidFormat$9 = "Formato Invlido";
const language$a = {
  title: "Selecione o idioma"
};
const legacyhiddenwallet$9 = {
  disable: "Desativar carteira legacy oculta",
  enable: "Ativar carteira legacy oculta",
  successDisable: "Carteira legacy oculta desativada com sucesso.",
  successEnable: "Carteira legacy oculta ativada com sucesso. Reconecte sua BitBox e digite a senha oculta do dispositivo para acessar a carteira legacy oculta."
};
const loading$9 = "carregando";
const manageAccounts$3 = {
  accountHidden: "Esta conta foi ocultada das suas contas watch-only. Para v-la novamente, conecte sua BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nome da conta",
  noAccounts: "nenhuma conta encontrada",
  settings: {
    hideTokens: "Esconder tokens",
    showTokens: "Exibir tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Adicionar e exibir/mostrar contas",
  title: "Gerenciar contas",
  watchAccount: "Observar conta",
  watchAccountDescription: "Esta conta faz parte das suas contas watch-only. Voc pode ocult-la de suas contas watch-only usando o boto de alternncia."
};
const mobile$4 = {
  usingMobileDataWarning: "Uso de dados mveis: esse aplicativo baixa centenas de megabytes de dados de cabealho de blockhain depois de desbloquear sua conta. Por favor conecte no Wi-Fi para evitar de usar dados mveis desnecessrios. Depois de descartar isso, essa mensagem no aparecer novamente."
};
const newSettings$3 = {
  about: {
    appVersion: {
      title: "Verso do aplicativo"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloqueie o acesso ao aplicativo com bloqueio de tela/impresso digital.",
      title: "Bloqueio de tela"
    },
    coinControl: {
      description: "Selecione quais UTXOs fazem parte de uma transao para ajudar a melhorar a privacidade."
    },
    customFees: {
      description: "Permite inserir sua prpria taxa ao enviar."
    },
    torProxy: {
      description: "Conecte-se via Tor para melhor privacidade."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Essas moedas adicionais podem ser alternadas na pgina da sua conta.",
      title: "Moedas ativas"
    },
    darkmode: {
      description: "Veja o BitBoxApp no modo escuro."
    },
    defaultCurrency: {
      description: "Selecione sua moeda padro",
      title: "Moeda padro"
    },
    enableAccount: {
      description: "Desativar sua conta significa que ela no aparecer na barra lateral ou no portflio. Voc sempre pode ativ-la novamente aqui. As moedas nesta conta no sero afetadas e permanecero seguras.",
      title: "Ativar/desativar conta"
    },
    hideAmounts: {
      description: "Exibe um boto para ocultar seu saldo e valores para melhorar sua privacidade ao usar o aplicativo em pblico.",
      hideAmounts: "Ocultar valores",
      showAmounts: "Mostrar valores",
      title: "Permitir ocultar valores"
    },
    language: {
      description: "Qual idioma voc deseja que o BitBoxApp use.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Lembrar carteira",
      warning: "Isso remover sua carteira lembrada. Para v-la novamente, voc precisar conectar a BitBox02 para esta carteira. Quaisquer moedas nesta carteira no sero afetadas. Voc quer continuar?",
      warningTitle: "Desativar lembrar carteira"
    },
    toggleSats: {
      description: "Ativar ou desativar Satoshis."
    }
  }
};
const note$5 = {
  input: {
    description: "(opcional)",
    placeholder: "Adicionar nota..."
  },
  title: "Nota"
};
const notification$9 = {
  newTxs_one: "Nova transao em: {{accountName}}",
  newTxs_other: "{{count}} novas transaes em: {{accountName}}"
};
const pairing$9 = {
  aborted: {
    text: "O emparelhamento foi cancelado no aplicativo para dispositivos mveis.",
    title: "Abortado"
  },
  button: "Emparelhar aplicativo mvel",
  confirm: "Tem certeza de que deseja emparelhar sua BitBox? Observe que, depois disso, o celular ser necessrio para realizar uma transao.",
  connectOnly: {
    button: "Conectar aplicativo mvel",
    title: "Escaneie com nosso aplicativo mvel selecionando o item 'Conectar ao novo aplicativo de desktop' do menu"
  },
  error: {
    text: "Algo deu errado. Por favor comece de novo.",
    title: "Erro"
  },
  pullFailed: {
    text: "Falha ao obter mensagem de seu dispositivo mvel atravs do servidor. O servidor pode estar offline, por favor entre em contato com o suporte.",
    title: "Falha ao obter"
  },
  reconnectOnly: {
    button: "Reconectar aplicativo mvel"
  },
  scanningFailed: {
    text: "Telefone no foi capaz de scanear a mensagem com sucesso. Por favor tente novamente.",
    title: "Falha ao scanear."
  },
  start: {
    hideAppQRCode: "Ocultar QR code",
    revealAppQRCode: "Mostrar QR code",
    step1: "Se voc no tiver o aplicativo para dispositivos mveis, voc pode escanear o QR code da Apple App Store ou da Google Play Store, dependendo de qual celular voc possui.",
    step2: 'Escaneie com nosso aplicativo para celular, que voc pode encontrar sob o nome "Digital Bitbox 2FA" nas lojas de aplicativos para iOS e Android:'
  },
  started: {
    text: "Agora, por favor, siga as instrues no aplicativo mvel.",
    title: "timo"
  },
  success: {
    text: "Parabns, voc pareou com sucesso sua BitBox com o aplicativo mvel!",
    title: "Sucesso"
  },
  timeout: {
    text: "O emparelhamento expirou aps dois minutos. Comece novamente se voc ainda deseja emparelhar o aplicativo para dispositivos mveis.",
    title: "Tempo esgotado"
  },
  title: "Emparelhamento por celular"
};
const passphrase$3 = {
  considerations: {
    button: "Consideraes sobre backup",
    message: "A frase secreta adiciona uma camada de proteo ao backup da sua carteira (carto microSD ou palavras de recuperao). Se algum tiver acesso ao seu backup, tambm precisar da frase secreta para acessar sua carteira.\n\nNo entanto, isso significa que voc precisar <strong>tanto da frase secreta + backup da carteira</strong> para restaurar sua carteira habilitada para frase secreta, caso sua BitBox02 seja perdida ou danificada. Se voc esquecer ou perder sua frase secreta, perder o acesso a todas as moedas dessa carteira.\n\nAo armazenar sua frase secreta, considere coloc-la em um local separado do backup. Dessa forma, se algum encontrar seu backup, eles tambm no encontraro sua frase secreta.",
    title: "Consideraes sobre backup"
  },
  disable: "Desabilitar frase secreta",
  disableInfo: {
    button: "Desabilitar",
    message: "Depois de desabilitar a frase secreta, voc no ser mais solicitado a inserir uma frase secreta aps desbloquear sua BitBox02. Portanto, voc entrar em sua carteira padro.\n\nQuaisquer moedas em sua carteira gerada com a frase secreta ainda estaro nessa carteira, mas voc no poder acess-las porque depois de desbloquear sua BitBox02, voc abrir sua carteira padro.\n\nPara acessar suas carteiras geradas com frases secretas novamente, basta reativar o recurso de frase secreta e inserir a frase secreta relevante aps desbloquear a BitBox02.\n\n<strong>Dica:</strong> voc ainda pode acessar sua carteira original deixando a frase secreta vazia."
  },
  enable: "Habilitar frase secreta",
  error: {
    e104: "A alterao da configurao da frase secreta foi abortada."
  },
  how: {
    button: "Como funciona",
    message: "Uma frase secreta no funciona como uma senha com a qual voc est acostumado. Se voc digitar incorretamente sua frase secreta, voc no ser notificado. Isso ocorre porque <strong>cada frase secreta cria uma carteira diferente, porm vlida</strong>. Isso significa que voc pode usar vrias frases secretas para quantas carteiras quiser. Mas cada carteira s pode ser acessada ao digitar a frase secreta correspondente.\n\nAo conectar sua BitBox02, voc ser solicitado a inserir a senha do dispositivo como de costume. Depois disso, voc ser solicitado a inserir uma frase secreta no dispositivo.\n\nDepois de inserir a frase secreta, voc ver a frase secreta digitada. Isso  para que voc possa confirmar que digitou corretamente.",
    title: "Como funciona"
  },
  intro: {
    message: "Uma frase secreta fornece uma camada adicional de segurana em sua carteira.\nVamos aprender como funciona.",
    title: "Configurar frase secreta"
  },
  progressDisable: {
    message: "Confirme em sua BitBox que voc deseja <strong>desabilitar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  progressEnable: {
    message: "Confirme em sua BitBox que voc deseja <strong>ativar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  successDisabled: {
    message: "Frase secreta opcional <strong>ativada com sucesso</strong>!\nVoc ser solicitado a fornecer uma frase secreta a partir de agora.",
    messageEnd: "Por favor, reconecte a BitBox02 agora.",
    title: "Frase secreta ativada"
  },
  successEnabled: {
    message: "Frase secreta opcional <strong>desativada com sucesso</strong>!\n\nVoc no ser mais solicitado a fornecer uma frase secreta.",
    messageEnd: "Por favor, reconecte sua BitBox02 agora.",
    tips: "Dicas",
    tipsList: [
      "Sugerimos enviar primeiro uma pequena quantia para a carteira gerada pela frase secreta. Em seguida, desconecte e reconecte a BitBox02 e digite sua senha e frase secreta. Se voc digitou a frase secreta corretamente, dever ver as moedas em sua carteira.",
      "Se voc deseja acessar sua carteira original sem uma frase secreta, voc ainda pode fazer isso no digitando nada quando solicitado a inserir a frase secreta. Ou voc pode desativar o recurso de frase secreta."
    ],
    title: "Frase secreta desativada"
  },
  summary: {
    button: "Ativar frase secreta",
    title: "Resumo",
    understand: "Eu entendo como a frase secreta funciona e os riscos associados a ela.",
    understandList: [
      "A frase secreta  uma camada adicional de segurana em seu backup.",
      "A insero de uma frase secreta diferente sempre gerar uma carteira diferente.",
      "Para restaurar sua carteira, voc precisa <strong>da frase secreta e do backup</strong>.",
      "Se voc esquecer sua frase secreta, voc <strong>no poder mais acessar suas moedas</strong>."
    ]
  },
  what: {
    button: "Saiba como isso funciona",
    message: "Uma carteira  criada (derivada) a partir de um nmero aleatrio muito grande, tambm conhecido como semente. Essa semente  criada quando voc configura sua BitBox02 pela primeira vez e  feito backup com o carto microSD ou palavras de recuperao. Qualquer pessoa que tenha acesso  semente tem controle total sobre os fundos dessa carteira.\n\nUma frase secreta  um <strong>segredo opcional</strong>, adicionado  semente. Ao usar uma frase secreta, cada frase secreta cria uma nova carteira com base na semente + frase secreta (segredo opcional). Uma frase secreta pode ser qualquer coisa: letras, palavras, caracteres especiais ou pode at ser vazia. A carteira padro  de fato derivada da semente + frase secreta vazia.\n\nA frase secreta  parte do padro BIP39, o que significa que  compatvel com todas as carteiras que suportam o mesmo padro.",
    title: "O que  uma frase secreta?"
  },
  why: {
    button: "Por que usar uma frase secreta",
    message: "A BitBox02 protege a semente contra extrao do prprio dispositivo, mas o backup (carto microSD ou palavras de recuperao) d acesso total  carteira.  por isso que deve ser armazenado em um local seguro!\n\nComo uma frase secreta cria uma nova carteira usando sua semente existente, a carteira da frase secreta requer tanto seu <strong>backup quanto sua frase secreta para restaurar</strong>. O benefcio disso  que, se algum encontrar seu backup, ainda precisar da frase secreta para acessar a carteira.\n\nAlm disso, o recurso de frase secreta permite que voc crie vrias carteiras no mesmo dispositivo ou carteiras ocultas alm da padro.",
    title: "Por que usar uma frase secreta?"
  }
};
const password$9 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "ATENO: o caps lock () est ativado",
    paste: 'para colar o texto, ative "MOSTRAR {{label}}"'
  }
};
const random$a = {
  button: "Gerar nmero aleatrio",
  description: "Sua BitBox gerou o seguinte nmero aleatrio de {{bits}} bits:"
};
const receive$b = {
  bitsuranceWarning: "Esta  uma conta segurada, o que significa que s pode receber em Segwit Nativo. Isso  para que voc no receba acidentalmente Wrapped Segwit ou Taproot, que no so segurados.",
  changeScriptType: "Alterar tipo de endereo",
  label: "Seu endereo",
  onlyThisCoin: {
    description: "Para receber outros tokens, ative-os nas configuraes. Se voc depositar outros tokens, eles podem no ser acessveis.",
    warning: "Certifique-se de receber apenas {{coinName}} neste endereo."
  },
  scriptType: {
    p2tr: "Taproot (formato mais recente)",
    p2wpkh: "Segwit Nativo (padro)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatvel)"
  },
  selectAccount: "Selecione a conta",
  showFull: "Mostrar e verificar endereo completo no dispositivo",
  taprootWarning: "Nota: Taproot  um novo recurso do Bitcoin e ainda no  amplamente adotado. Os valores recebidos em endereos Taproot podem no ser visveis em carteiras watch-only de terceiros. Muitas carteiras e corretoras ainda no podem enviar para endereos Taproot.",
  title: "Receber {{accountName}}",
  verify: "Verificar endereo com segurana",
  verifyBitBox01: "Verifique o endereo no aplicativo mvel",
  verifyBitBox02: "Verifique o endereo na BitBox02",
  verifyInstruction: "Por favor, verifique se o endereo a seguir corresponde ao exibido no seu dispositivo.",
  warning: {
    secureOutput: "Por favor, emparelhe sua BitBox com seu dispositivo mvel para ativar a verificao segura de endereo. V para 'Gerenciar dispositivo' na barra lateral."
  }
};
const reset$9 = {
  description: "Todos os dados sero excludos deste dispositivo. Isso inclui sua chave privada!",
  notReset: "Dispositivo NO redefinido.",
  title: "Restaurar configuraes de fbrica",
  understand: "Eu tenho um backup e sei minha senha de recuperao",
  understandBB02: "Eu tenho um backup vlido"
};
const securityInformation$9 = {
  create: {
    description1: "Recomendamos que voc configure seu dispositivo em um ambiente seguro, ou seja, voc estar longe de outras pessoas que possam ver a senha que voc escolher.",
    description2: "Voc ser solicitado a criar duas senhas.",
    description3: "A primeira  a <strong>senha do dispositivo</strong> que desbloqueia o seu dispositivo BitBox e pode ser alterada mais tarde.",
    description4: "A segunda  a <strong>senha de recuperao</strong> que desbloqueia sua carteira. Esta senha no pode ser alterada mais tarde.",
    description5: "A carteira que voc criar ser copiada para um arquivo no carto microSD fornecido. Ele pode ser usado em caso de emergncia para recuperar seus fundos usando a sua <strong>senha de recuperao</strong>.",
    title: "Informao de segurana"
  },
  restore: {
    description1: "Voc ser solicitado a inserir o carto microSD usado para armazenar seu backup.",
    description2: "Para restaurar o seu dispositivo, voc precisar da sua senha de recuperao.",
    description3: "Por favor, tenha cuidado ao digitar a senha de recuperao. Qualquer senha que voc inserir criar uma carteira vlida. Se voc digitar a senha errada, poder ser mostrado um saldo da carteira que voc no espera.",
    title: "Informao de segurana"
  }
};
const seed$9 = {
  agreements: {
    "funds-access": "Eu NO poderei acessar meus fundos se esquecer minha senha de recuperao",
    "password-change": "Eu NO posso mudar a senha de recuperao mais tarde",
    "password-required": "A senha de recuperao  necessria para restaurar uma carteira de um backup"
  },
  create: "Criar carteira",
  creating: "Criando carteira",
  description: "Eu entendo que:",
  error: {
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e200: "Voc precisa inserir um carto microSD na sua BitBox para criar uma carteira, para que um backup possa ser criado automaticamente."
  },
  info: {
    button: "Definir senha de recuperao agora",
    description1: "Insira o carto microSD na BitBox",
    description2: 'Escolha uma senha de recuperao para a carteira e selecione "Definir senha de recuperao agora"',
    description3: "O backup para o carto microSD e sua senha de recuperao  o nico mtodo para recuperar seus fundos em caso de perda ou roubo de um dispositivo BitBox.",
    description4: "Voc no pode alterar sua senha de recuperao posteriormente sem transferir seus fundos.",
    title: "Criar uma nova carteira"
  },
  password: {
    label: "Senha de recuperao",
    repeatPlaceholder: "Repita a senha de recuperao"
  },
  walletName: {
    label: "Nome da carteira"
  }
};
const seedRestore$9 = {
  error: {
    e200: "Restaurar uma carteira a partir de um backup requer o carto microSD."
  },
  info: {
    description1: 'Insira o carto microSD na BitBox e clique em "Continuar"',
    description2: 'Escolha um backup e clique em "Restaurar"',
    description3: "Digite a senha de recuperao",
    description4: "Voc precisa confirmar que entende que uma senha incorreta criar uma carteira diferente.",
    title: "Como restaurar uma carteira a partir de um backup"
  }
};
const send$b = {
  abort: "A transao foi abortada.",
  address: {
    label: "Endereo do destinatrio",
    placeholder: "Insira o endereo"
  },
  amount: {
    label: "Montante",
    placeholder: "Insira o valor"
  },
  availableBalance: "Saldo disponvel",
  button: "Revisar",
  coincontrol: {
    address: "Endereo",
    outpoint: "Outpoint",
    title: "Enviar da sada"
  },
  confirm: {
    "selected-coins": "Moedas selecionadas",
    title: "Confirmar e enviar transao",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que voc no tem Ether suficiente para pagar por esta transao ERC20. Certifique-se de ter Ether suficiente em sua carteira",
    feeTooLow: "taxa muito baixa",
    feesNotAvailable: "No foi possvel estimar as taxas",
    insufficientFunds: "saldo insuficiente",
    invalidAddress: "endereo invlido",
    invalidAmount: "montante invlido",
    invalidData: "dados invlidos"
  },
  fee: {
    customPlaceholder: "Insira o valor",
    label: "Taxa de rede",
    placeholder: "No disponvel"
  },
  feeTarget: {
    customLabel: "Taxa",
    customLabel_eth: "Preo do gs",
    description: {
      economy: "4 horas (24 blocos)",
      economy_eth: "30 minutos ou menos",
      economy_ltc: "1 hora (24 blocos)",
      high: "20 minutos (2 blocos)",
      high_eth: "30 segundos ou menos",
      high_ltc: "5 minutos (2 blocos)",
      low: "2 horas (12 blocos)",
      low_eth: "5 minutos ou menos",
      low_ltc: "30 minutos (12 blocos)",
      normal: "1 hora (6 blocos)",
      normal_eth: "2 minutos ou menos",
      normal_ltc: "15 minutos (6 blocos)"
    },
    estimate: "Tempo estimado de confirmao:",
    label: {
      custom: "Customizar",
      economy: "Econmica",
      high: "Alta",
      low: "Baixa",
      normal: "Normal"
    },
    placeholder: "Calculando a taxa ..."
  },
  maximum: "Enviar tudo",
  maximumSelectedCoins: "Enviar moedas selecionadas",
  noFeeTargets: "As estimativas de taxa de transao esto indisponveis no momento. Por favor, tente novamente mais tarde ou insira uma taxa personalizada.",
  priority: "Prioridade",
  scanQR: "Escanear QR code",
  signprogress: {
    description: "Esta  uma transao que contm muitos dados. Para assinar completamente a transao, voc ser solicitado a confirmar {{steps}} vezes.",
    label: "Progresso"
  },
  success: "A transao foi assinada e enviada.",
  title: "Enviar {{accountName}}",
  toggleCoinControl: "Alternar controle de moedas",
  transactionDetails: "Detalhes da transao"
};
const settings$a = {
  about: "Sobre",
  accounts: "Contas",
  advancedSettings: "Configuraes avanadas",
  appearance: "Aparncia",
  electrum: {
    add: "Adicionar um servidor",
    "add-server": "Adicionar",
    check: "Checar",
    checkFailed: "Falhou",
    checkSuccess: "Conexo com {{host}} estabelecida com sucesso.",
    checking: "Checando",
    "download-cert": "Baixar certificado remoto",
    "remove-server": "Remover",
    removeConfirm: "Remover {{server}}?",
    reset: "Redefinir para o padro",
    resetConfirm: "Voc deseja remover todos os servidores e instalar os servidores padro?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Digite o endpoint.",
    step2: "2",
    "step2-text": "Digite um certificado da cadeia de certificados do servidor. Alternativamente, baixe o certificado remoto e compare-o visualmente.",
    "step2-text-tcp": "Voc pode pular essa estapa se no quiser usar TLS.",
    step3: "3",
    "step3-text": "Checar a conexo e adicionar o servidor.",
    step4: "4",
    "step4-text": "Reinicie a carteira. Se voc no remover os servidores padro, seu prprio node ser adicionado como uma redundncia.",
    "title-btc": "Servidores Bitcoin Electrum",
    "title-ltc": "Servidores Litecoin Electrum",
    "title-tbtc": "Servidores Bitcoin Testnet Electrum",
    "title-tltc": "Servidores Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Ativar controle de moedas",
    electrum: {
      description: "Voc pode se conectar ao seu prprio n completo Electrum.",
      title: "Conectar seu prprio full node"
    },
    fee: "Habilitar taxas personalizadas",
    setProxyAddress: "Configurar endereo de proxy",
    title: "Configuraes para especialistas",
    useProxy: "Ativar proxy Tor",
    useSats: "Exibir valores BTC em Satoshis"
  },
  header: {
    home: "Incio"
  },
  info: {
    "out-of-date": "Nova atualizao disponvel",
    title: "Informaes",
    "up-to-date": "Seu aplicativo est atualizado",
    version: "Verso do aplicativo"
  },
  restart: "Por favor, reinicie o BitBoxApp para que as alteraes faam efeito.",
  services: {
    title: "Servios"
  },
  success: "Por favor, retire e reconecte a BitBox para que as mudanas faam efeito.",
  title: "Configuraes"
};
const setup$9 = "Configurar dispositivo";
const sidebar$a = {
  buy: "Comprar crypto",
  device: "Gerenciar dispositivo",
  insurance: "Seguro",
  leave: "Sair",
  settings: "Configuraes"
};
const success$g = {
  create: {
    info1: "Sua carteira foi armazenada com segurana no carto microSD. Remova-o e mantenha-o seguro.",
    info2: "Voc criou uma senha de dispositivo segura que desbloqueia a BitBox.",
    info3: "Voc criou uma senha de recuperao segura para sua carteira que desbloqueia seu saldo e restaura seus backups.",
    summary: "Aqui est um resumo do que voc fez",
    title: "Sucesso"
  },
  getstarted: "Comear",
  restore: {
    summary: "Voc restaurou uma carteira a partir do seu backup com sucesso.",
    title: "Sucesso"
  }
};
const transaction$a = {
  confirmation: "Confirmaes",
  details: {
    activity: "Movimentao",
    address: "Endereo",
    amount: "Valor",
    date: "Data",
    fiat: "Fiduciria",
    fiatAmount: "Valor fiducirio",
    fiatAtTime: "Fiat no momento da transao",
    status: "Status",
    title: "Detalhes da transao",
    type: "Tipo"
  },
  explorer: "ID da transao",
  explorerTitle: "Abrir no explorador de blocos externo",
  fee: "Taxa",
  fiatHistorical: "Histrico",
  gas: "Gas",
  note: {
    edit: "Editar n",
    save: "Salvar n"
  },
  pending: "Transao pendente",
  size: "Tamanho",
  status: {
    complete: "Completa",
    failed: "Falhou",
    pending: "Pendente"
  },
  tx: {
    received: "Recebido para",
    sent: "Enviado para"
  },
  vsize: "Tamanho virtual",
  weight: "Peso"
};
const transactions$9 = {
  errorLoadTransactions: "Ocorreu um erro ao carregar as transaes",
  placeholder: "Nenhuma transao ainda."
};
const unknownError$9 = "Ocorreu um erro desconhecido: {{errorMessage}}";
const unlock$9 = {
  description: "Digite a senha do dispositivo para desbloque-lo.",
  error: {
    e109_normal: "Senha do dispositivo errada. {{remainingAttempts}} tentativas restantes antes que o dispositivo seja resetado.",
    e109_touch: "$t(unlock.error.e109_normal) O prximo login requer que segure o boto touch.",
    e113: "Devido a muitas tentativas de login, o prximo login requer que o boto touch seja pressionado por 4 segundos."
  },
  input: {
    label: "Senha do dispositivo",
    placeholder: "Digite a senha do dispositivo para desbloque-lo"
  },
  unlocking: "Desbloqueando..."
};
const upgradeFirmware$a = {
  button: "Atualizar firmware",
  description: "Deseja atualizar o firmware da verso {{currentVersion}} para {{newVersion}}?",
  label: "Sua BitBox requer uma atualizao de firmware.",
  locked: "Para atualizar da verso {{currentVersion}} para a {{newVersion}}, por favor, realize um longo toque.",
  title: "Atualizar firmware",
  unlocked: "O bootloader est desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecte e reconecte sua Bitbox",
  unlocked2: "O LED acender quando a sua BitBox for conectada novamente",
  unlocked3: "Toque no boto touch quando o LED acender"
};
const walletConnect$5 = {
  connect: {
    button: "Conectar",
    dappLabel: "Insira o endereo URI do dapp",
    invalidPairingUri: "Uri de emparelhamento invlido"
  },
  dashboard: {
    allSessions: "Todas as sesses",
    disclaimer: "Walletconnect  um protocolo para conectar-se a Dapps baseados em Ethereum. Esses dapps so executados por servios de terceiros, portanto, conecte-se apenas a dapps em que voc confia e sempre saiba o que est assinando ao fazer uma transao.",
    newConnection: "Nova conexo",
    noConnectedSessions: "Nenhuma conta est atualmente conectada a nenhum dapps."
  },
  invalidPairingChain: "Erro ao aprovar o emparelhamento. Certifique-se de usar uma das cadeias suportadas: {{chains}}",
  pairingRequest: {
    approve: "Aprovar conexo",
    reject: "Rejeitar",
    title: "Nova solicitao de conexo de"
  },
  pairingSuccess: "Dapp conectado com sucesso. Voc pode continuar no site dapp.",
  signingRequest: {
    account: "Conta",
    chain: "Cadeia",
    dapp: "Dapp",
    data: "Dados",
    dataParsingError: "Falha ao analisar os dados",
    decodeError: "Falha ao decodificar a mensagem",
    method: {
      sendTransaction: "Assinar e enviar transao",
      signMessage: "Assinar mensagem",
      signTransaction: "Assinar transao",
      signTypedData: "Assinar dados digitados"
    },
    successfullySigned: "Solicitao assinada com sucesso",
    walletConnectRequest: "Solicitao WalletConnect"
  },
  useNewUri: "Este URI j foi usado para tentar uma conexo. Use um novo URI.",
  walletConnect: "WalletConnect"
};
const warning$f = {
  receivePairing: "Por favor, emparelhe a BitBox para ativar a verificao segura de endereo. V para 'Gerenciar dispositivo' na barra lateral.",
  sdcard: "Mantenha o carto microSD guardado separado da BitBox, a menos que voc queira gerenciar os backups.",
  sendPairing: 'Por favor, emparelhe a BitBox para verificar com segurana os detalhes da transao. V para "Gerenciar dispositivo" na barra lateral.'
};
const welcome$9 = {
  connect: "Conecte a BitBox02",
  getStarted: "Vamos comear instalando o firmware na sua BitBox02.",
  insertBitBox02: "Para a BitBox02, por favor, toque no dispositivo para continuar.",
  insertDevice: "Por favor, conecte seu dispositivo para iniciar",
  title: "Bem-vindo"
};
const appTranslationsPT = {
  account: account$9,
  accountInfo: accountInfo$9,
  accountSummary: accountSummary$9,
  addAccount: addAccount$a,
  aopp: aopp$3,
  app: app$9,
  auth: auth$4,
  backup: backup$9,
  bb02Bootloader: bb02Bootloader$9,
  bitbox: bitbox$9,
  bitbox02Interact: bitbox02Interact$9,
  bitbox02Settings: bitbox02Settings$9,
  bitbox02Wizard: bitbox02Wizard$9,
  bitsurance: bitsurance$3,
  bitsuranceAccount: bitsuranceAccount$3,
  blink: blink$9,
  bootloader: bootloader$9,
  button: button$e,
  buy: buy$5,
  changePin: changePin$9,
  chart: chart$5,
  checkSDcard: checkSDcard$9,
  clickHere: clickHere$9,
  confirm: confirm$b,
  confirmOnDevice: confirmOnDevice$9,
  connectKeystore: connectKeystore$4,
  darkmode: darkmode$4,
  device: device$9,
  deviceLock: deviceLock$9,
  deviceSettings: deviceSettings$9,
  deviceTampered: deviceTampered$9,
  dialog: dialog$a,
  error: error$5,
  fiat: fiat$b,
  footer: footer$b,
  generic: generic$5,
  genericError: genericError$9,
  goal: goal$9,
  guide: guide$a,
  headerssync: headerssync$9,
  hiddenWallet: hiddenWallet$9,
  initialize: initialize$9,
  invalidFormat: invalidFormat$9,
  language: language$a,
  legacyhiddenwallet: legacyhiddenwallet$9,
  loading: loading$9,
  manageAccounts: manageAccounts$3,
  mobile: mobile$4,
  newSettings: newSettings$3,
  note: note$5,
  notification: notification$9,
  pairing: pairing$9,
  passphrase: passphrase$3,
  password: password$9,
  random: random$a,
  receive: receive$b,
  reset: reset$9,
  securityInformation: securityInformation$9,
  seed: seed$9,
  seedRestore: seedRestore$9,
  send: send$b,
  settings: settings$a,
  setup: setup$9,
  sidebar: sidebar$a,
  success: success$g,
  transaction: transaction$a,
  transactions: transactions$9,
  unknownError: unknownError$9,
  unlock: unlock$9,
  upgradeFirmware: upgradeFirmware$a,
  walletConnect: walletConnect$5,
  warning: warning$f,
  welcome: welcome$9
};
const account$8 = {
  disconnect: "       ...",
  exportTransactions: "     CSV      ",
  fatalError: "   ",
  incoming: "  ",
  initializing: "       ...",
  reconnecting: "  ,          ..."
};
const accountInfo$8 = {
  address: "",
  extendedPublicKey: "  ",
  label: " ",
  title: "  ",
  verify: "   "
};
const accountSummary$8 = {
  balance: "",
  exportSummary: "      CSV      ",
  fiatBalance: " ",
  name: "  ",
  noAccount: "      ",
  title: " ",
  total: ""
};
const addAccount$9 = {
  title: " "
};
const app$8 = {
  upgrade: "       !  {{current}}  {{version}}   "
};
const backup$8 = {
  check: {
    checking: "    ...",
    confirmTitle: "   ",
    notOK: "      ",
    ok: "     ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "  :",
    title: "   "
  },
  create: {
    alreadyExists: "                ?",
    fail: "   ",
    info: "          ",
    name: {
      label: "  ",
      placeholder: "    "
    },
    password: {
      label: " ",
      placeholder: "     "
    },
    title: " ",
    verificationFailed: "                       ' '   "
  },
  description: "<strong>  </strong>  ",
  insert: "         ",
  insertButton: "     ",
  list: "   ",
  noBackups: "        ",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "     ...",
    title: " ",
    understand: "           "
  },
  showMnemonic: {
    description: " 24   ,            \n\n<strong>           </strong>\n\n<strong>     </strong>\n\n<strong>      </strong>\n\n ,          ",
    title: "  "
  },
  title: "  "
};
const bb02Bootloader$8 = {
  abort: "   -    ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "     hash "
  },
  flipscreen: " ",
  orientation: "     ?",
  success: "  !  {{rebootSeconds}}     ..."
};
const bitbox$8 = {
  error: {
    e10000: "    ",
    e10001: "    ",
    e102: "     4   ",
    e112: "           "
  }
};
const bitbox02Interact$8 = {
  followInstructions: "  BitBox02       "
};
const bitbox02Settings$8 = {
  deviceName: {
    current: "   ",
    input: "BitBox02  ",
    title: "BitBox02    "
  }
};
const bitbox02Wizard$8 = {
  attestationFailed: "    ,                     :      ",
  backup: {
    point1: "      ",
    point2: "       ",
    restoreText: " ,    !",
    text1: ",   BitBox02                          BitBox02       ",
    text2: "        -    ",
    text3: "     ,       <strong> </strong>                BitBox02        ",
    userConfirmation1: "        ",
    userConfirmation2: "               ",
    userConfirmation3: "   BitBox02       ,               ",
    userConfirmation4: "      BitBox02                "
  },
  create: {
    button: "      ",
    info: " BitBox             ",
    inputTitle: "  ",
    point1: "    ",
    point2: "       ",
    point3: "  ",
    text: " ,     !"
  },
  initialize: {
    passwordText: "                  BitBox     ",
    passwordTitle: " BitBox      ",
    text: "  BitBox02  !            ,               <strong>     BitBox02       </strong>",
    tip: "         ",
    title: " BitBox   "
  },
  insertSDCard: "<strong>       BitBox02       </strong>",
  pairing: {
    failed: "    BitBox02   ",
    paired: "               ,             ",
    title: "pairing   ",
    unpaired: "  BitBox02                    ,   BitBox02                    "
  },
  restoreFromMnemonic: {
    failed: "      ,    "
  },
  stepBackup: {
    beforeProceed: "   ,       :",
    createBackup: "        "
  },
  stepBackupSuccess: {
    fundsSafe: "      ,     :",
    title: "   !"
  },
  stepConnected: {
    unlock: "    BitBox02  "
  },
  stepCreate: {
    nameLabel: "BitBox02 ",
    namePlaceholder: " BitBox02",
    title: "BitBox02   ",
    toastMicroSD: "        BitBox02    "
  },
  stepCreateSuccess: {
    removeMicroSD: "  BitBox02           ",
    success: "      "
  },
  stepPassword: {
    title: "BitBox02    ",
    useControls: "      BitBox02     "
  },
  stepUninitialized: {
    create: "   BitBox02    ",
    restore: "          ",
    restoreMicroSD: "    ",
    restoreMnemonic: "mnemonic   ",
    title: " BitBox02  "
  },
  success: {
    text: "!  BitBox02       \n\nBitBoxApp           ,          -    ",
    title: "      !"
  }
};
const blink$8 = {
  button: ""
};
const bootloader$8 = {
  button: "   ",
  progress: "   : {{progress}}%",
  success: "  !        ,     "
};
const button$d = {
  abort: "      ",
  back: " ",
  changepin: "  ",
  check: "   ",
  "continue": "Continue",
  copy: " ",
  create: " ",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: " ",
  restore: " ",
  select: "Select",
  send: "",
  unlock: "",
  update: "Update",
  upgrade: ""
};
const changePin$8 = {
  newTitle: "  ",
  oldLabel: "  "
};
const checkSDcard$8 = "       ";
const clickHere$8 = "  ";
const confirm$a = {
  abortInfo: "  ",
  abortInfoRedText: "    ",
  approveInfo: "4+     ",
  approveInfoGreenText: "    ",
  info: " BitBox ",
  infoWhenPaired: "         BitBox"
};
const confirmOnDevice$8 = "     ";
const device$8 = {
  appUpradeRequired: " BitBox              "
};
const deviceLock$8 = {
  button: "Two Factor Authorization (2FA)  ",
  condition1: "    ?",
  condition2: "       ?",
  condition3: "2FA            2FA      RESET  !",
  confirm: "Two Factor Authorization (2FA)  ",
  title: "Two Factor Authorization (2FA)  "
};
const deviceSettings$8 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "     ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": "  ",
      label: "  ",
      "true": " "
    },
    title: ""
  },
  loading: "     ",
  pairing: {
    lock: {
      "false": " ",
      label: "Two Factor Authorization (2FA)",
      "true": " "
    },
    mobile: {
      "false": " ",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": " "
    },
    title: " "
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
};
const deviceTampered$8 = "  BitBox        ?  ,        support    Shift             ";
const dialog$9 = {
  cancel: " ",
  confirm: " "
};
const fiat$a = {
  "default": "",
  setDefault: "set {{code}} as default",
  title: ""
};
const footer$a = {
  appVersion: " :"
};
const genericError$8 = "          ,       ";
const goal$8 = {
  buttons: {
    create: "   ",
    restore: "     "
  },
  paragraph: "        :",
  step: {
    "1": {
      title: " "
    },
    "2": {
      description: "   ",
      title: ""
    },
    "3-create": {
      description: "   ",
      title: ""
    },
    "3-restore": {
      description: " ",
      title: " "
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$9 = {
  accountDescription: {
    text: "       -           '              ",
    title: "     ?"
  },
  accountFiat: {
    text: "                        ",
    title: "        ?"
  },
  accountIncomingBalance: {
    text: "                     ",
    title: "incoming    ?"
  },
  accountInfo: {
    xpub: {
      text: "                  \n  -                 ",
      title: "     ?"
    }
  },
  accountRates: {
    text: " CoinGecko         \n",
    title: "      ?"
  },
  accountReload: {
    text: "     -        ",
    title: "        ?"
  },
  accountSendDisabled: {
    text: "        'Send'     ",
    title: "  {{unit}}     ?"
  },
  accountTransactionAttributesBTC: {
    text: " :                         \n:            \n: Segwit     ,                segregated witness         ,               ,          ",
    title: "-       ?"
  },
  accountTransactionAttributesGeneric: {
    text: "(Confirmations):   -        miner        ,                                   \n (Transaction ID):               \n(Fee):                          ,     ",
    title: "        ?"
  },
  accountTransactionConfirmation: {
    text: "                  ",
    title: "   ?"
  },
  accountTransactionLabel: {
    text: "              ",
    title: "         ?"
  },
  accountTransactionTime: {
    text: "   ",
    title: "     ?"
  },
  appendix: {
    link: "  !",
    text: "  ?"
  },
  backups: {
    check: {
      text: "' '                                                         ",
      title: "'   ?"
    },
    encrypt: {
      text: ",                           ",
      title: "      ?"
    },
    howOften: {
      text: "                       ,              ,        \n-                                  ",
      title: "     ?"
    },
    whatIsABackup: {
      text: "                    ",
      title: "  ?"
    }
  },
  backupsBB02: {
    check: {
      text: "' '                     ",
      title: "'   ?"
    },
    encrypt: {
      text: ',      ,                        ,   " "            ',
      title: "      ?"
    },
    whatIsABackup: {
      text: "         ",
      title: "  ?"
    }
  },
  bitbox: {
    "2FA": {
      text: " 2FA   ,                      ,   -       ,     ,      BitBox                            \n2FA                     ,             BitBox         ,      ",
      title: "Two Factor Authorization (2FA)    ?"
    },
    disable2FA: {
      text: "2FA     ,   BitBox                                     ' '         '  '         , ''                 ",
      title: " Two Factor Authorization (2FA)      ?"
    },
    ejectBitbox: {
      text: " BitBox       BitBox     ",
      title: " BitBox    ?"
    },
    ejectSD: {
      text: "            ,             ",
      title: "       ?"
    },
    hiddenWallet: {
      text: "                 ,      (plausible deniability)                      ,       ",
      title: "   ?"
    },
    legacyHiddenWallet: {
      text: "        (  BitBox           2FA  ),   BitBox               ",
      title: "       ?"
    },
    pairing: {
      text: "iOS  Android          ,   QR     ,                    ,         ",
      title: "        "
    }
  },
  receive: {
    address: {
      text: "                     ",
      title: "     ?"
    },
    addressChange: {
      text: "   -  ,             20          ",
      title: "   ?"
    },
    howVerify: {
      text: "BitBox01  ,     BitBox                       \nBitBox02  ,   /              ",
      title: "           ?"
    },
    why20: {
      text: '-                                 ,                      20                " "   20    ,       20       ',
      title: " 20   ?"
    },
    whyMany: {
      text: "      ,                 ,                20               ",
      title: "   ?"
    },
    whyVerify: {
      text: "\n                                BitBox01  ,                  ,   QR          BitBox02  ,    BitBox02       ",
      title: "        ?"
    }
  },
  send: {
    fee: {
      text: "       ,                   Bitcoin Core                 ,     \n: 24  (Bitcoin    4 , Litecoin   1 )\n: 12  (Bitcoin    2 , Litecoin   30 )\n: 6  (Bitcoin    1 , Litecoin   15 )\n: 2  (Bitcoin    20 , Litecoin   5 )\n(Bitcoin      (  2.5 )                  )",
      title: "     ?"
    },
    priority: {
      text: "         ,              ",
      title: "   ?"
    },
    revert: {
      text: "      (   )  ,             ( )     !\n             (  )    ,            ",
      title: "      ?"
    },
    whyFee: {
      text: "                           \n             (      )           ,                       ,                  ",
      title: "   ?"
    }
  },
  "settings-electrum": {
    what: {
      text: "                   ",
      title: "  ?"
    }
  },
  settings: {
    servers: {
      text: "  ,  -          ,        \n                           -            \n:    20   ,       ",
      title: "       ?"
    }
  },
  title: "",
  toggle: {
    close: "  ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "                  ",
      title: "          ?"
    },
    reset: {
      text: "15                    ",
      title: "     ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "                        ,            ",
      title: " BitBox01    "
    },
    getDevice: {
      link: {
        text: "BitBox  "
      },
      text: "     BitBox   :",
      title: " BitBox      ?"
    },
    internet: {
      text: ",    ,                  ",
      title: "         ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "   BitBox              ",
      title: "      ?"
    },
    useWithoutDevice: {
      text: " ,     ",
      title: "          ?"
    },
    welcome: {
      text: "  Shift Crypto                                 ",
      title: "BitBox     !"
    }
  }
};
const headerssync$8 = {
  blocksSynced: "{{blocks}}    "
};
const hiddenWallet$8 = {
  info1HTML: "  (plausible deniability)  , <strong></strong>   +              ",
  info2HTML: "                                   <strong></strong>     ",
  passwordLabel: "  ",
  passwordPlaceholder: "      ",
  pinLabel: "  ",
  pinRepeatLabel: "    ",
  pinRepeatPlaceholder: "      ",
  success: "           BitBox    "
};
const initialize$8 = {
  create: "   ",
  creating: "      ...",
  error: {
    e102: "      4   "
  },
  info: {
    description1: "       BitBox       ",
    description2: " ,             ",
    description3: "      ,               ",
    subtitle: "      ",
    title: "    "
  },
  input: {
    label: " ",
    labelRepeat: "  ",
    placeholderRepeat: "     "
  }
};
const invalidFormat$8 = " ";
const language$9 = {
  title: " "
};
const legacyhiddenwallet$8 = {
  disable: "     ",
  enable: "    ",
  successDisable: "       ",
  successEnable: "        BitBox                  "
};
const loading$8 = "   ";
const notification$8 = {
  newTxs_one: "{{accountName}}    ",
  newTxs_other: "{{accountName}}  {{count}}  "
};
const pairing$8 = {
  aborted: {
    text: "         ",
    title: "  "
  },
  button: "  ",
  confirm: "    BitBox    ?             ",
  connectOnly: {
    button: "   ",
    title: "  '     '         "
  },
  error: {
    text: "        ",
    title: ""
  },
  reconnectOnly: {
    button: "      "
  },
  start: {
    hideAppQRCode: "QR  ",
    revealAppQRCode: "QR  ",
    step1: "      ,           Apple App Store  Google Play Store   QR      ",
    step2: "     ,   iOS  Android      'Digital BitBox 2FA'     :"
  },
  started: {
    text: "          ",
    title: "Great"
  },
  success: {
    text: " ,   BitBox        !",
    title: ""
  },
  timeout: {
    text: "                        ",
    title: " "
  },
  title: "Mobile Pairing"
};
const password$8 = {
  show: "{{label}} ",
  warning: {
    caps: ":   ()  ",
    paste: 'text   , "{{label}} "    '
  }
};
const random$9 = {
  button: "   ",
  description: " BitBox   {{bits}}-bit     :"
};
const receive$a = {
  label: " ",
  onlyThisCoin: {
    description: "     ,            ,          ",
    warning: "    {{coinName}}    "
  },
  showFull: "     ",
  title: "{{accountName}} ",
  verify: "      ",
  verifyBitBox01: "     ",
  verifyBitBox02: "BitBox02    ",
  verifyInstruction: "              ",
  warning: {
    secureOutput: "               BitBox     ' '  "
  }
};
const reset$8 = {
  description: "            !",
  notReset: "   ",
  title: "  ",
  understand: "          ",
  understandBB02: "     "
};
const securityInformation$8 = {
  create: {
    description1: "                  ",
    description2: "       ",
    description3: "  <strong> </strong>   BitBox              ",
    description4: "  <strong> </strong>                 ",
    description5: "    ,  SD            <strong> </strong>               ",
    title: " "
  },
  restore: {
    description1: "                   ",
    description2: "              ",
    description3: "                                        ",
    title: " "
  }
};
const seed$8 = {
  agreements: {
    "funds-access": "               ",
    "password-change": "       ",
    "password-required": "            "
  },
  create: " ",
  creating: "   ",
  description: "   :",
  error: {
    e102: "     4   ",
    e200: "      BitBox          ,          "
  },
  info: {
    button: "    ",
    description1: "BitBox     ",
    description2: '        "    " ',
    description3: "BitBox                            ",
    description4: "              ",
    title: "   "
  },
  password: {
    label: " ",
    repeatPlaceholder: "  "
  },
  walletName: {
    label: "  "
  }
};
const seedRestore$8 = {
  error: {
    e200: "              "
  },
  info: {
    description1: 'BitBox       " "   ',
    description2: '    " "   ',
    description3: "  ",
    description4: "                   ",
    title: "      "
  }
};
const send$a = {
  abort: "     ",
  address: {
    label: "  ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  button: "   ",
  coincontrol: {
    address: "",
    outpoint: "outpoint",
    title: "  "
  },
  confirm: {
    "selected-coins": " ",
    title: "   ",
    total: ""
  },
  error: {
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "24  (Bitcoin    4 , Litecoin   1 )",
      high: "2  (Bitcoin    20 , Litecoin   5 )",
      low: "12  (Bitcoin    2 , Litecoin   30 )",
      normal: "6  (Bitcoin    1 , Litecoin   15 )"
    },
    estimate: "  :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "       ..."
  },
  maximum: " ",
  scanQR: "QR   ",
  signprogress: {
    description: "                    {{steps}}       ",
    label: ""
  },
  success: "         ",
  title: "{{accountName}} ",
  toggleCoinControl: "Coin Control  "
};
const settings$9 = {
  electrum: {
    add: "  ",
    "add-server": "",
    check: "",
    checkFailed: " ",
    checkSuccess: " {{host}}      ",
    checking: "   ",
    "download-cert": "   ",
    "remove-server": "",
    removeConfirm: "{{server}} ?",
    reset: "   ",
    resetConfirm: "               ?",
    servers: "",
    step1: "1",
    "step1-text": "endpoint  ",
    step2: "2",
    "step2-text": "          ,          ",
    step3: "3",
    "step3-text": "      ",
    step4: "4",
    "step4-text": "           ,          ",
    "title-btc": "Bitcoin Electrum ",
    "title-ltc": "Litecoin Electrum ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "   ",
    electrum: {
      title: "    "
    },
    setProxyAddress: "   ",
    title: " ",
    useProxy: "   "
  },
  header: {
    home: "Home"
  },
  restart: "       BitBoxApp     ",
  success: "          BitBox    ",
  title: ""
};
const setup$8 = " ";
const sidebar$9 = {
  device: "  ",
  leave: "",
  settings: ""
};
const success$f = {
  create: {
    info1: "                   ",
    info2: "        BitBox    ",
    info3: "                        ",
    summary: "         ",
    title: ""
  },
  getstarted: " ",
  restore: {
    summary: "          ",
    title: ""
  }
};
const transaction$9 = {
  confirmation: "Confirmations",
  explorer: " ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: "",
  gas: "Gas",
  pending: " ",
  size: "",
  vsize: " ",
  weight: ""
};
const transactions$8 = {
  placeholder: "     "
};
const unknownError$8 = "   : {{errorMessage}}";
const unlock$8 = {
  description: "          ",
  error: {
    e109_normal: "          {{remainingAttempts}}   ",
    e109_touch: "$t(unlock.error.e109_normal)          ",
    e113: "    ,     4         "
  },
  input: {
    label: " ",
    placeholder: "         "
  },
  unlocking: "    ..."
};
const upgradeFirmware$9 = {
  button: "  ",
  description: "    {{currentVersion}}  {{newVersion}}       ?",
  label: " BitBox      ",
  locked: "{{currentVersion}}  {{newVersion}}    ,     ",
  title: "  ",
  unlocked: "        , :",
  unlocked1: " Bitbox         ",
  unlocked2: "  BitBox          ",
  unlocked3: "          "
};
const warning$e = {
  receivePairing: "        BitBox     ' '  ",
  sdcard: "       ,          ",
  sendPairing: "            BitBox     ' '  "
};
const welcome$8 = {
  insertBitBox02: "BitBox02  ,         ",
  insertDevice: "        ",
  title: "  "
};
const appTranslationsHI = {
  account: account$8,
  accountInfo: accountInfo$8,
  accountSummary: accountSummary$8,
  addAccount: addAccount$9,
  app: app$8,
  backup: backup$8,
  bb02Bootloader: bb02Bootloader$8,
  bitbox: bitbox$8,
  bitbox02Interact: bitbox02Interact$8,
  bitbox02Settings: bitbox02Settings$8,
  bitbox02Wizard: bitbox02Wizard$8,
  blink: blink$8,
  bootloader: bootloader$8,
  button: button$d,
  changePin: changePin$8,
  checkSDcard: checkSDcard$8,
  clickHere: clickHere$8,
  confirm: confirm$a,
  confirmOnDevice: confirmOnDevice$8,
  device: device$8,
  deviceLock: deviceLock$8,
  deviceSettings: deviceSettings$8,
  deviceTampered: deviceTampered$8,
  dialog: dialog$9,
  fiat: fiat$a,
  footer: footer$a,
  genericError: genericError$8,
  goal: goal$8,
  guide: guide$9,
  headerssync: headerssync$8,
  hiddenWallet: hiddenWallet$8,
  initialize: initialize$8,
  invalidFormat: invalidFormat$8,
  language: language$9,
  legacyhiddenwallet: legacyhiddenwallet$8,
  loading: loading$8,
  notification: notification$8,
  pairing: pairing$8,
  password: password$8,
  random: random$9,
  receive: receive$a,
  reset: reset$8,
  securityInformation: securityInformation$8,
  seed: seed$8,
  seedRestore: seedRestore$8,
  send: send$a,
  settings: settings$9,
  setup: setup$8,
  sidebar: sidebar$9,
  success: success$f,
  transaction: transaction$9,
  transactions: transactions$8,
  unknownError: unknownError$8,
  unlock: unlock$8,
  upgradeFirmware: upgradeFirmware$9,
  warning: warning$e,
  welcome: welcome$8
};
const account$7 = {
  disconnect: "  .   ...",
  exportTransactions: "     Downloads  CSV ",
  fatalError: "  .",
  incoming: "",
  initializing: "    ...",
  reconnecting: "  ,     ..."
};
const accountInfo$7 = {
  address: "",
  extendedPublicKey: "  ",
  label: "  ",
  title: "  ",
  verify: "  "
};
const accountSummary$7 = {
  balance: "",
  exportSummary: "       CSV    Downloads",
  fiatBalance: "   ",
  name: "  ",
  noAccount: "  ",
  title: "   ",
  total: ""
};
const addAccount$8 = {
  title: "  "
};
const app$7 = {
  upgrade: "  -    !    {{current}}  {{version}}."
};
const backup$7 = {
  check: {
    checking: " ...",
    confirmTitle: "  ",
    notOK: "     .",
    ok: "    .",
    password: {
      label: "  ",
      placeholder: "  ",
      showLabel: "  "
    },
    success: "  :",
    title: "  "
  },
  create: {
    alreadyExists: "    .      ?",
    fail: "    !",
    info: "         .",
    name: {
      label: "  ",
      placeholder: "    "
    },
    password: {
      label: "  ",
      placeholder: "    "
    },
    title: "  ",
    verificationFailed: '         .   .    "  ",      .'
  },
  description: "  <strong>   </strong>",
  insert: "  microSD ,    .",
  insertButton: "microSD   ",
  list: "   micro SD :",
  noBackups: "  microSD   .",
  restore: {
    confirmTitle: "  ",
    error: {
      e200: "   microSD "
    },
    password: {
      label: "       ",
      placeholder: "  ",
      repeatPlaceholder: "     ",
      showLabel: "  "
    },
    restoring: "  ...",
    title: "",
    understand: ",           "
  },
  showMnemonic: {
    description: "       24 ,       .    .\n\n<strong>         .</strong>\n\n<strong>    .</strong>\n\n<strong>     .</strong>\n\n        .",
    title: "   "
  },
  title: "  "
};
const bb02Bootloader$7 = {
  abort: "     ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "          "
  },
  flipscreen: "  ",
  orientation: "     ?",
  success: "  !   {{rebootSeconds}} ..."
};
const bitbox$7 = {
  error: {
    e10000: "      .",
    e10001: "      ",
    e102: "     4 ",
    e112: "             ."
  }
};
const bitbox02Interact$7 = {
  followInstructions: "  ,    BitBox02."
};
const bitbox02Settings$7 = {
  deviceName: {
    current: "   ",
    input: "  BitBox02",
    title: "   BitBox02"
  }
};
const bitbox02Wizard$7 = {
  attestationFailed: "    .     ,   ,        .      .",
  backup: {
    point1: "   microSD ",
    point2: "    ",
    restoreText: ",    !",
    text1: ",    BitBox02      .        .  ,  microSD     BitBox02  .",
    text2: "     ,    .",
    text3: "    ,  micro SD     <strong>  </strong>.   micro SD      .          ,   BitBox02.",
    userConfirmation1: "      .",
    userConfirmation2: "     . ,     ,      .",
    userConfirmation3: "     BitBox02,               .",
    userConfirmation4: "     ,  BitBox02 ,     ."
  },
  create: {
    button: "      ",
    info: "   ,    ,     BitBox:",
    inputTitle: "  ",
    point1: "    ",
    point2: "    ",
    point3: " ",
    text: ",    !"
  },
  initialize: {
    passwordText: "     .      BitBox,       .",
    passwordTitle: "    BitBox",
    text: "   BitBox02  !    . -         ,       . <strong> ,    BitBox02   microSD </strong>",
    tip: "  ,      .",
    title: "   BitBox"
  },
  insertSDCard: "<strong> ,    BitBox02   microSD </strong>",
  pairing: {
    failed: "   .     BitBox02.",
    paired: "   ,   .    ,   ,    .",
    title: "    .",
    unpaired: "   BitBox02.  ,           .   ,            BitBox02    ,   ."
  },
  restoreFromMnemonic: {
    failed: "    ,  ."
  },
  stepBackup: {
    beforeProceed: "  ,       :",
    createBackup: "       microSD ."
  },
  stepBackupSuccess: {
    fundsSafe: "       ,   :",
    title: "  !"
  },
  stepConnected: {
    unlock: "   BitBox02,    ."
  },
  stepCreate: {
    nameLabel: "  BitBox02",
    namePlaceholder: " BitBox02 ",
    title: "    BitBox02",
    toastMicroSD: " ,  microSD      BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: " microSD    BitBox02      .",
    success: "   ."
  },
  stepPassword: {
    title: "    BitBox02",
    useControls: "    BitBox02,    ."
  },
  stepUninitialized: {
    create: "    BitBox02 .",
    restore: "      .",
    restoreMicroSD: "  microSD ",
    restoreMnemonic: "   ",
    title: "   BitBox02 "
  },
  success: {
    text: "!  BitBox02    .\n\n       BitBox,     ,          .",
    title: "  !"
  }
};
const blink$7 = {
  button: ""
};
const bootloader$7 = {
  button: "  firmware",
  progress: ": {{progress}}%",
  success: "  !       ,    ."
};
const button$c = {
  abort: "",
  back: "",
  changepin: "    ",
  check: "  ",
  "continue": "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "   ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "",
  update: "",
  upgrade: ""
};
const changePin$7 = {
  newTitle: "   ",
  oldLabel: "   "
};
const checkSDcard$7 = "  microSD ";
const clickHere$7 = " ";
const confirm$9 = {
  abortInfo: ",  ",
  abortInfoRedText: "",
  approveInfo: "  4 ,  ",
  approveInfoGreenText: "",
  info: "  BitBox",
  infoWhenPaired: "          BitBox"
};
const confirmOnDevice$7 = "    .";
const device$7 = {
  appUpradeRequired: " BitBox       .      - ."
};
const deviceLock$7 = {
  button: "    (2FA)",
  condition1: "   ?",
  condition2: "     ?",
  condition3: "2FA           .     ,     2FA!",
  confirm: "    (2FA)",
  title: "    (2FA)"
};
const deviceSettings$7 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "Firmware",
    upToDate: "   - ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": "  ",
      label: "microSD ",
      "true": ""
    },
    title: ""
  },
  loading: "    ...",
  pairing: {
    lock: {
      "false": "",
      label: "  (2FA)",
      "true": ""
    },
    mobile: {
      "false": "",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": " "
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
};
const deviceTampered$7 = "         BitBox,            . Shift            !";
const dialog$8 = {
  cancel: "",
  confirm: ""
};
const fiat$9 = {
  "default": " ",
  setDefault: " {{code}}  ",
  title: ""
};
const footer$9 = {
  appVersion: "  :"
};
const genericError$7 = " .   ,  .";
const goal$7 = {
  buttons: {
    create: "   ",
    restore: "    "
  },
  paragraph: "    :",
  step: {
    "1": {
      title: "  "
    },
    "2": {
      description: "    ",
      title: ""
    },
    "3-create": {
      description: "   ",
      title: ""
    },
    "3-restore": {
      description: " ",
      title: ""
    },
    "4-create": {
      title: " "
    },
    "4-restore": {
      title: " "
    }
  }
};
const guide$8 = {
  accountDescription: {
    text: '         ,    .     ""       .',
    title: "     ?"
  },
  accountFiat: {
    text: ".   ,     .           .",
    title: "      ?"
  },
  accountIncomingBalance: {
    text: ' ""     ,        .',
    title: '  ""?'
  },
  accountInfo: {
    xpub: {
      text: "   (Extended Public Key)   ,         .                Electrum  Sentinel.",
      title: "    ?"
    }
  },
  accountRates: {
    text: "        CoinGecko.",
    title: "   ?"
  },
  accountReload: {
    text: "  .       .",
    title: "      ?"
  },
  accountSendDisabled: {
    text: ' ""  ,    -  .',
    title: "     {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    text: " :   .   -     ,   .\n :      ,      .\n:  ,    SegWit         .  SegWit       ,          .     ,           .",
    title: "   Bitcoin   ?"
  },
  accountTransactionAttributesGeneric: {
    text: ':     "",       ,       "1 ".  ,     ,       .                 3  6 .\nID  :  ,         block explorer.\n:           ,  .    ,   "".',
    title: "     ? "
  },
  accountTransactionConfirmation: {
    text: ",     ,     .",
    title: "   (pending) ?"
  },
  accountTransactionLabel: {
    text: "  ,         .",
    title: "      ?"
  },
  accountTransactionTime: {
    text: "      .",
    title: "   ?"
  },
  appendix: {
    link: "   !",
    text: "  ?"
  },
  backups: {
    check: {
      text: '"  "    ,     ,       .          ,       .     ,     .',
      title: '  "  "?'
    },
    encrypt: {
      text: ",     ,          (seed).",
      title: "    ?"
    },
    howOften: {
      text: "        .             microSD          microSD .\n             .           ,    .",
      title: "     ?"
    },
    whatIsABackup: {
      text: "      (seed),   microSD .         .",
      title: "  ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"  "     ,     ,   ,    .',
      title: '  "  "?'
    },
    encrypt: {
      text: '.  microSD    ,          (seed),     .        ,                "  ".',
      title: "    ?"
    },
    whatIsABackup: {
      text: "      (seed),   microSD .",
      title: "  ?"
    }
  },
  bitbox: {
    "2FA": {
      text: '     (2FA),           . - ,          ;            "" (Accept)     BitBox.        ,     .\n\n ,          ,     .     , microSD          .     ,    BitBox  ,    .',
      title: "    (2FA)?"
    },
    disable2FA: {
      text: '    ,     BitBox         . -  ,    microSD           .     "  ".        "   ".     ,   ""     ,       .',
      title: "      (2FA)?"
    },
    ejectBitbox: {
      text: '   BitBox   ;     " " (Eject Media).',
      title: "   BitBox  ?"
    },
    ejectSD: {
      text: "   microSD   BitBox   ,              .",
      title: "    microSD ?"
    },
    hiddenWallet: {
      text: "      ,           .           (.. 'plausible deniability').  ,         ,          .",
      title: '  " "?'
    },
    legacyHiddenWallet: {
      text: "-     (     BitBox            ),      BitBox          .",
      title: "      (legacy)   ?"
    },
    pairing: {
      text: "      iOS  Android,     QR .             .    ,     .",
      title: "       "
    }
  },
  receive: {
    address: {
      text: "      ,       .          .",
      title: "     ?"
    },
    addressChange: {
      text: "   ,      ,      20 ,     .",
      title: "   ?"
    },
    howVerify: {
      text: ' BitBox01:     BitBox       "".          - .\n BitBox02:           /  .',
      title: "       ?"
    },
    why20: {
      text: "   ,   ,      (seed)        .          ,       .       ,      20  ,     .   ..  (gap limit),       ,       .   20- ,     .",
      title: "  20 ?"
    },
    whyMany: {
      text: "      ,         .      ,   ,     .     20  .                   (seed).",
      title: "   ?"
    },
    whyVerify: {
      text: "             .    -     .  BitBox01          ,           QR .  BitBox02           .",
      title: "    ?"
    }
  },
  send: {
    fee: {
      text: "       ,    .       Bitcoin Core       ,       -  .\n: 24  (. 4   Bitcoin, 1   Litecoin)\n: 12  (. 2   Bitcoin, 30   Litecoin)\n: 6  (. 1   Bitcoin, 15   Litecoin)\n: 2  (. 20   Bitcoin, 5   Litecoin)\n\n:       10   Bitcoin (2.5   Litecoin)        .",
      title: "    ?"
    },
    priority: {
      text: " -  ,  -       .",
      title: "   ?"
    },
    revert: {
      text: "         (..   ),      .      (   ) ,   !\n            (     ),       .",
      title: "      ?"
    },
    whyFee: {
      text: '        .            .  ""    .       ,    ,    ,      .              ,    .',
      title: "    ?"
    }
  },
  "settings-electrum": {
    what: {
      text: "        ,      Shift.",
      title: "  ?"
    }
  },
  settings: {
    servers: {
      text: "     Shift Crypto,      ,           .  ,       CoinGecko.                .\n:  Ethereum  ERC20   API-  Etherscan.io",
      title: "    ?"
    }
  },
  title: "",
  toggle: {
    close: "  ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "               .",
      title: "   ,      ?"
    },
    reset: {
      text: "       15  .          .",
      title: "   ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "      .  ,    .   ,       .",
      title: " BitBox 01    "
    },
    getDevice: {
      link: {
        text: " BitBox "
      },
      text: "   BitBox    :",
      title: "   ?"
    },
    internet: {
      text: "     ,             .",
      title: "     ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "       BitBox        ",
      title: " .  ?"
    },
    useWithoutDevice: {
      text: "         .",
      title: "      ?"
    },
    welcome: {
      text: " ,    ,   Shift Crypto  .    ,    .     ,    .",
      title: "   BitBoxApp!"
    }
  }
};
const headerssync$7 = {
  blocksSynced: " {{blocks}} "
};
const hiddenWallet$7 = {
  info1HTML: "       ,   <strong></strong>        .      .",
  info2HTML: "            ,       .    ,        <strong></strong>     .",
  passwordLabel: "   ",
  passwordPlaceholder: "     ",
  pinLabel: "    ",
  pinRepeatLabel: "     ()",
  pinRepeatPlaceholder: "      ",
  success: "    .    BitBox,    ."
};
const initialize$7 = {
  create: "     ",
  creating: "   ...",
  error: {
    e102: "      4 ."
  },
  info: {
    description1: "    .        BitBox.",
    description2: "   ,   . -   - .",
    description3: "     ,            .",
    subtitle: "       ",
    title: "  "
  },
  input: {
    label: "   ",
    labelRepeat: "    ()",
    placeholderRepeat: "     "
  }
};
const invalidFormat$7 = " ";
const language$8 = {
  title: "  "
};
const legacyhiddenwallet$7 = {
  disable: "     Legacy",
  enable: "     Legacy",
  successDisable: " Legacy    .",
  successEnable: "      Legacy.    BitBox      ,        ."
};
const loading$7 = "...";
const notification$7 = {
  newTxs_one: "   {{accountName}}",
  newTxs_other: "{{count}}    {{accountName}}"
};
const pairing$7 = {
  aborted: {
    text: "     .",
    title: ""
  },
  button: "   ",
  confirm: "  ,      BitBox   ?   ,       ,    .",
  connectOnly: {
    button: "   ",
    title: '   ,    "    "  .'
  },
  error: {
    text: "   .    .",
    title: ""
  },
  reconnectOnly: {
    button: "    "
  },
  start: {
    hideAppQRCode: "  QR ",
    revealAppQRCode: "  QR ",
    step1: "     ,    QR   Apple App Store  Google Play Store       .",
    step2: "   ,         iOS  Android   'Digital Bitbox 2FA':"
  },
  started: {
    text: "      .",
    title: ""
  },
  success: {
    text: ",    BitBox     !",
    title: ""
  },
  timeout: {
    text: "      2 .  ,        .",
    title: ""
  },
  title: " "
};
const password$7 = {
  show: "  {{label}}",
  warning: {
    caps: ": Caps lock ()  ",
    paste: '   ,  "  {{label}}"'
  }
};
const random$8 = {
  button: "   ",
  description: " BitBox   {{bits}}-  :"
};
const receive$9 = {
  label: " ",
  onlyThisCoin: {
    description: "    ,    .     ,           .",
    warning: " ,     {{coinName}}   ."
  },
  showFull: "       ",
  title: "  {{accountName}}",
  verify: "   ",
  verifyBitBox01: "     ",
  verifyBitBox02: "    BitBox02",
  verifyInstruction: " ,          .",
  warning: {
    secureOutput: '  BitBox   ,         .   "  "   .'
  }
};
const reset$7 = {
  description: "      .    !",
  notReset: "   .",
  title: "  ",
  understand: "       ",
  understandBB02: "   "
};
const securityInformation$7 = {
  create: {
    description1: "    ,   ,      .",
    description2: "       .",
    description3: "  <strong> </strong>,    BitBox      .",
    description4: "  <strong>    </strong>,    .         - .",
    description5: "       microSD .                    <strong>  </strong>.",
    title: "  "
  },
  restore: {
    description1: "      microSD ,    .",
    description2: "     ,      .",
    description3: "  ,     .      .    ,     .",
    title: "  "
  }
};
const seed$7 = {
  agreements: {
    "funds-access": "        ,     .",
    "password-change": "         - .",
    "password-required": "           "
  },
  create: "  ",
  creating: "  ...",
  description: ", :",
  error: {
    e102: "     4 .",
    e200: "       microSD    BitBox ,        ."
  },
  info: {
    button: "    ",
    description1: " microSD   BitBox",
    description2: '        "    "',
    description3: "  microSD                      ,  BitBox     .",
    description4: "        - ,       .",
    title: "   "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "   ()"
  },
  walletName: {
    label: "  "
  }
};
const seedRestore$7 = {
  error: {
    e200: "         microSD ."
  },
  info: {
    description1: ' microSD   BitBox    ""',
    description2: '    ""',
    description3: "   ",
    description4: "  ,  ,        .",
    title: "     "
  }
};
const send$9 = {
  abort: "  .",
  address: {
    label: "  ",
    placeholder: "  "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  button: "  ",
  coincontrol: {
    address: "",
    outpoint: "  output",
    title: "  output  "
  },
  confirm: {
    "selected-coins": " ",
    title: "  ",
    total: ""
  },
  error: {
    insufficientFunds: " ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "24  ( 4   Bitcoin, 1   Litecoin)",
      high: "2  ( 20   Bitcoin, 5   Litecoin)",
      low: "12  ( 2   Bitcoin, 30   Litecoin)",
      normal: "6  ( 1   Bitcoin, 15   Litecoin)"
    },
    estimate: "   :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "  ..."
  },
  maximum: "  ",
  scanQR: "  QR ",
  signprogress: {
    description: "    .        {{steps}} .",
    label: ""
  },
  success: "    .",
  title: "  {{accountName}}",
  toggleCoinControl: "   (Coin Control)"
};
const settings$8 = {
  electrum: {
    add: "  ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "    {{host}}",
    checking: "...",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: "   {{server}}?",
    reset: "    ",
    resetConfirm: "            ?",
    servers: "",
    step1: "1",
    "step1-text": "  .",
    step2: "2",
    "step2-text": "      ,         .",
    step3: "3",
    "step3-text": "    ",
    step4: "4",
    "step4-text": " .      ,        .",
    "title-btc": "Bitcoin Electrum ",
    "title-ltc": "Litecoin Electrum ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "     (Coin Control)",
    electrum: {
      title: "    "
    },
    setProxyAddress: "   ",
    title: " ",
    useProxy: "  Tor "
  },
  header: {
    home: ""
  },
  restart: " BitBoxApp,        .",
  success: " BitBox     ,        .",
  title: ""
};
const setup$7 = "  ";
const sidebar$8 = {
  device: "  ",
  leave: "",
  settings: ""
};
const success$e = {
  create: {
    info1: "      microSD .          .",
    info2: "   ,      BitBox.",
    info3: "      ,           .",
    summary: "   ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "     .",
    title: ""
  }
};
const transaction$8 = {
  confirmation: "",
  explorer: "ID  ",
  explorerTitle: "    ",
  fee: "",
  fiatHistorical: " ",
  gas: "Gas",
  pending: ",  ",
  size: "",
  vsize: " ",
  weight: ""
};
const transactions$7 = {
  placeholder: "  ."
};
const unknownError$7 = "  : {{errorMessage}}";
const unlock$7 = {
  description: "  ,     .",
  error: {
    e109_normal: "  .  {{remainingAttempts}},     .",
    e109_touch: "$t(unlock.error.e109_normal)           .",
    e113: "      ,            4 ."
  },
  input: {
    label: " ",
    placeholder: "  ,    "
  },
  unlocking: "..."
};
const upgradeFirmware$8 = {
  button: "  firmware",
  description: "     firmware   {{currentVersion}}  {{newVersion}}?",
  label: " BitBox    firmware.",
  locked: "    {{currentVersion}}  {{newVersion}},     .",
  title: "  firmware",
  unlocked: "Bootloader-  .   , :",
  unlocked1: "     BitBox",
  unlocked2: " BitBox    ,    ",
  unlocked3: "   ,   "
};
const warning$d = {
  receivePairing: '  BitBox,         .   "  "   .',
  sdcard: " microSD    BitBox ,     .",
  sendPairing: ' BitBox ,           .   "  "   .'
};
const welcome$7 = {
  insertBitBox02: " BitBox02,     ,   .",
  insertDevice: " ,    ",
  title: " !"
};
const appTranslationsBG = {
  account: account$7,
  accountInfo: accountInfo$7,
  accountSummary: accountSummary$7,
  addAccount: addAccount$8,
  app: app$7,
  backup: backup$7,
  bb02Bootloader: bb02Bootloader$7,
  bitbox: bitbox$7,
  bitbox02Interact: bitbox02Interact$7,
  bitbox02Settings: bitbox02Settings$7,
  bitbox02Wizard: bitbox02Wizard$7,
  blink: blink$7,
  bootloader: bootloader$7,
  button: button$c,
  changePin: changePin$7,
  checkSDcard: checkSDcard$7,
  clickHere: clickHere$7,
  confirm: confirm$9,
  confirmOnDevice: confirmOnDevice$7,
  device: device$7,
  deviceLock: deviceLock$7,
  deviceSettings: deviceSettings$7,
  deviceTampered: deviceTampered$7,
  dialog: dialog$8,
  fiat: fiat$9,
  footer: footer$9,
  genericError: genericError$7,
  goal: goal$7,
  guide: guide$8,
  headerssync: headerssync$7,
  hiddenWallet: hiddenWallet$7,
  initialize: initialize$7,
  invalidFormat: invalidFormat$7,
  language: language$8,
  legacyhiddenwallet: legacyhiddenwallet$7,
  loading: loading$7,
  notification: notification$7,
  pairing: pairing$7,
  password: password$7,
  random: random$8,
  receive: receive$9,
  reset: reset$7,
  securityInformation: securityInformation$7,
  seed: seed$7,
  seedRestore: seedRestore$7,
  send: send$9,
  settings: settings$8,
  setup: setup$7,
  sidebar: sidebar$8,
  success: success$e,
  transaction: transaction$8,
  transactions: transactions$7,
  unknownError: unknownError$7,
  unlock: unlock$7,
  upgradeFirmware: upgradeFirmware$8,
  warning: warning$d,
  welcome: welcome$7
};
const account$6 = {
  disconnect: "Balant koptu. Tekrar deneniyor...",
  exportTransactions: "lemleri ndirilenler Klasrne CSV Dosyas Olarak Da Aktar",
  fatalError: "Beklenmeyen bir hata olutu.",
  incoming: "Gelen",
  initializing: "Blockchain'den bilgi alnyor",
  reconnecting: "Balant koptu, yeniden balant kuruluyor..."
};
const accountInfo$6 = {
  address: "Adres",
  extendedPublicKey: "Geniletilmi Genel Anahtar",
  label: "Hesap bilgileri",
  title: "Hesap Bilgileri",
  verify: "Bu cihazda dorula"
};
const accountSummary$6 = {
  balance: "Bakiye",
  exportSummary: "Hesap zetini ndirilenler Klasrne CSV Dosyas Olarak Da Aktar",
  fiatBalance: "Fiat Bakiyesi",
  name: "Hesap ad",
  noAccount: "Gsterilecek hesap yok.",
  title: "Hesap zeti",
  total: "Toplam"
};
const addAccount$7 = {
  title: "Hesap Ekle"
};
const app$6 = {
  upgrade: "Bu uygulamann yeni bir srm mevcut! Ltfen  {{current}} 'dan  {{version}}'a ykseltin."
};
const backup$6 = {
  check: {
    checking: "Yedekleme kontrol ediliyor...",
    confirmTitle: "Yedeklemeyi Kontrol Et",
    notOK: "Yedekleme czdanla elemiyor.",
    ok: "Yedekleme czdanla eleti.",
    password: {
      label: "ifre yenileme",
      placeholder: "Kurtarma ifresi",
      showLabel: "kurtarma ifresi"
    },
    success: "Baaryla dorulanm yedeklemeler:",
    title: "Yedeklemeyi Kontrol Et"
  },
  create: {
    alreadyExists: "Zaten geerli bir yedeiniz var. Yeniden yedeklemek ister misiniz?",
    fail: "Yedekleme oluturma BAARISIZ!",
    info: "Ltfen dorulama iin mevcut czdannzn kurtarma ifresini girin.",
    name: {
      label: "Yedek Ad",
      placeholder: "Ltfen yedei adlandrn"
    },
    password: {
      label: "Kurtarma ifresi",
      placeholder: "Ltfen kurtarma ifrenizi girin"
    },
    title: "Yedek Olutur",
    verificationFailed: "Kurtarma ifresi mevcut czdanla elemiyor. Yedekleme oluturuldu. Ltfen kurtarma ifrenizi tekrar dorulamak iin 'Yedeklemeyi Kontrol Et'i kullann."
  },
  description: "<strong>czdan yedekleme dosyasn</strong> sein",
  insert: "Yedeklemeleri ynetmek iin ltfen micro SD kart takn.",
  insertButton: "Mikro SD kartm taktm",
  list: "MicroSD kart yedekleriniz",
  noBackups: "Bu microSD kartta yedekleme yok.",
  restore: {
    confirmTitle: "Yedeklemeyi Geri Ykle",
    error: {
      e200: "SD kart bulunamad"
    },
    password: {
      label: "Kurtarma ifresi veya gizli kurtarma ifresi",
      placeholder: "Kurtarma ifresi",
      repeatPlaceholder: "Kurtarma ifresini tekrar girin",
      showLabel: "Kurtarma ifresi"
    },
    restoring: "Yedekleme geri ykleniyor...",
    title: "Geri Ykle",
    understand: "Yanl kurtarma ifresinin farkl bir czdan yaratacan onaylyorum"
  },
  showMnemonic: {
    description: "Czdannzn yedeini oluturan 24 kelimeyi size sunacaz. Onlar kada yazn.\n\n<strong>Bunlar dijital olarak saklamayn veya fotoraflarn ekmeyin.</strong>\n\n<strong>Kelimeleri yksek sesle syleme.</strong>\n\n<strong>Bu yedekleme ifre korumal deildir.</strong>\n\nSonrasnda, her bir kelimeyi tek tek onaylamanz istenecektir.",
    title: "BIP39 Anmsatcsn Gster"
  },
  title: "Yedeklemeleri Ynet"
};
const bb02Bootloader$6 = {
  abort: "Ykseltmeyi durdur  Beni geri gtr",
  advanced: {
    label: "Gelimi Ayarlar",
    toggleShowFirmwareHash: "Her alta bellenim hash'ini gster"
  },
  flipscreen: "Ekran evir",
  orientation: "Cihaz yanl yne mi yneldi?",
  success: "Ykseltme baarl!  {{rebootSeconds}} saniye ierisinde devam edecek..."
};
const bitbox$6 = {
  error: {
    e10000: "Geerli cihaz ifresi yanl.",
    e10001: "Cihazn ifresini deitirme baarsz",
    e102: "ifre en az 4 karakterden olumaldr.",
    e112: "Gizli cihaz ifresi, ana cihaz ifresi ile ayn olamaz."
  }
};
const bitbox02Interact$6 = {
  followInstructions: "Ltfen BitBox02 zerindeki talimatlar takip edin."
};
const bitbox02Settings$6 = {
  deviceName: {
    current: "Geerli cihaz ad",
    input: "BitBox02 Ad",
    title: "BitBox02 cihaznz isimlendirin"
  }
};
const bitbox02Wizard$6 = {
  attestationFailed: "Cihaz onay baarsz oldu. BitBox'nz sahte veya tehlikede olabilir. BitBox02 zerindeki paralar kaybolma riski altnda olabilir. Ltfen acilen support@bitbox.swiss ile iletiime gein.",
  backup: {
    point1: "MicroSD karttan bir yedek sein",
    point2: "Cihaznz iin bir ifre belirleyin",
    restoreText: "Tamam, hadi bir yedei geri ykleyelim!",
    text1: "Harika, BitBox02 ifreniz ayarland ve czdan oluturuldu. imdi ilk yedeinizi oluturma zaman. Ltfen microSD kartnzn BitBox02 cihaznza takl olduundan emin olun ve devam edin.",
    text2: "Bir yedekleme oluturmak iin ltfen cihaznzdaki ekrandaki talimatlar izleyin.",
    text3: "Yedeklemeniz oluturulduktan sonra, ltfen microSD kart karn ve <strong>gvenli bir yerde</strong> saklayn. MicroSD kartn ierii ifre korumal deildir. Bu nedenle asla baka bir cihaza yerletirmeyin.",
    userConfirmation1: "Yedeklememi gvenli bir yerde saklamalym.",
    userConfirmation2: "Yedeklerim ifre korumal deil. Buna eriimi olan herkes czdanma eriebilir.",
    userConfirmation3: "BitBox02 yazlmm kaybedersem veya zarar verirsem, param kurtarmann tek yolu yedeklememden geri yklemektir.",
    userConfirmation4: "Hem yedeimi hem de BitBox02mi kaybedersem veya zarar verirsem fonlarm kaybolacak."
  },
  create: {
    button: "Cihaz adlandr ve devam et",
    info: "te BitBox'nz ayarlamak iin atmanz gereken temel admlar: ",
    inputTitle: "Czdan ad",
    point1: "Cihaznz adlandrn",
    point2: "Cihaznz iin bir ifre belirleyin",
    point3: "Yedekleme olutur",
    text: "Tamam, hadi yeni bir czdan yaratalm!"
  },
  initialize: {
    passwordText: "imdi cihaznz iin bir ifre ayarlayalm. Bir ifre girmek ve bir ifre semek iin BitBox'nzdaki kontrolleri kullann.",
    passwordTitle: "BitBox'nz iin bir ifre belirleyin",
    text: "BitBox02 cihaznz baaryla eletirildi! imdi cihaznz balatalm. Yeni bir czdan oluturmay veya czdan mevcut bir yedekten geri yklemeyi seerek balayn. <strong>Ltfen BitBox02 cihaznza takl bir microSD kartn olduundan emin olun.</strong>",
    tip: "Balamadan nce, ilemlere gvenli bir ortamda devam etmeniz iddetle tavsiye edilir.",
    title: "BitBox'nz balatn"
  },
  insertSDCard: "<strong>Ltfen BitBox02 cihaznza takl bir microSD kartn olduundan emin olun.</strong>",
  pairing: {
    failed: "Onaylanmam eletirme. Ltfen BitBox02'nizi deitirin.",
    paired: "Cihaznzda kodun eletiini onayladnz. Bu doruysa, aadaki dmeye tklayarak devam edebilirsiniz.",
    title: "Eletirme Kodunu Dorulayn",
    unpaired: "Yeni bir BitBox02 tespit edildi. Ltfen aadaki kodun cihaznzda gsterilenlerle eletiini dorulayn. Kod eleirse, BitBox02 zerindeki onay iaretinin altndaki simgeye dokunun ve devam etmek iin aadaki dmeye tklayn."
  },
  restoreFromMnemonic: {
    failed: "BIP39 anmsatcsndan geri ykleme baarsz oldu, ltfen tekrar deneyin."
  },
  stepBackup: {
    beforeProceed: "Devam etmeden nce, ltfen u nemli gvenlik hususlarn okuyun:",
    createBackup: "imdi microSD kartnzda bir yedekleme oluturacaksnz."
  },
  stepBackupSuccess: {
    fundsSafe: "Fonlarnz gvende tutmak iin ltfen aadakileri unutmayn:",
    title: "Yedekleme Geri Yklendi!"
  },
  stepConnected: {
    unlock: "Kilidi amak iin BitBox02 ifresini girin."
  },
  stepCreate: {
    nameLabel: "BitBox02 ad",
    namePlaceholder: "Benim BitBox02 czdanm",
    title: "BitBox02 adn sein",
    toastMicroSD: "Ltfen microSD kartnzn BitBox02 cihaznza takl olduundan emin olun."
  },
  stepCreateSuccess: {
    removeMicroSD: "Ltfen microSD kart BitBox02 cihaznzdan karn ve gvenli bir yerde saklayn.",
    success: "Yedeklemenizi baaryla oluturdunuz."
  },
  stepPassword: {
    title: "BitBox02 ifresini ayarla",
    useControls: "Bir ifre belirlemek iin BitBox02 zerindeki kontrolleri kullann."
  },
  stepUninitialized: {
    create: "BitBox02 cihazm yeniden kurmak istiyorum.",
    restore: "Czdanm bir yedekten geri yklemek istiyorum.",
    restoreMicroSD: "MicroSD karttan geri ykle",
    restoreMnemonic: "Anmsatcdan geri ykle",
    title: "BitBox02 cihaznz kurun"
  },
  success: {
    text: "Yaasn! BitBox02'niz artk kullanma hazr.\n\nBitBox Uygulamas'nn nasl kullanlaca hakknda daha fazla bilgi iin, ltfen sa st kedeki soru iaretini tklayarak uygulama ii klavuzunu kullann.",
    title: "Balamaya hazrsn!"
  }
};
const blink$6 = {
  button: "Gz ard et"
};
const bootloader$6 = {
  button: "Donanm yazlmn imdi ykselt",
  progress: "Ykseltme: {{progress}}%",
  success: "Ykseltme baarl! Ltfen cihaz tekrar takn. Bu kez, dmeye dokunmayn."
};
const button$b = {
  abort: "ptal Et",
  back: "Geri",
  changepin: "Cihaz ifresini Deitir",
  check: "Yedeklemeyi Kontrol Et",
  "continue": "Devam et",
  copy: "Kopyala",
  create: "Olutur",
  download: "ndir",
  hiddenwallet: "Gizli Czdan Olutur",
  next: "Sonraki",
  ok: "Tamam",
  previous: "nceki",
  receive: "Alnan",
  restore: "Geri Ykle",
  select: "Se",
  send: "Gnder",
  unlock: "Kilidini a",
  update: "Gncelletirme",
  upgrade: "Ykselt"
};
const changePin$6 = {
  newTitle: "Yeni cihazn ifresi",
  oldLabel: "Mevcut cihazn ifresi"
};
const checkSDcard$6 = "Mikro SD kart kontrol ediliyor";
const clickHere$6 = "Buraya tklayn.";
const confirm$8 = {
  abortInfo: "Dokunun",
  abortInfoRedText: "ptal et",
  approveInfo: "u tua 4 saniye basl tut ",
  approveInfoGreenText: "dorula",
  info: "BitBox'nzda",
  infoWhenPaired: "nce telefonla sonrasnda Bitbox'la eletirin"
};
const confirmOnDevice$6 = "Ltfen cihaznzda onaylayn.";
const device$6 = {
  appUpradeRequired: "BitBox'nz bu masast uygulamas ile uyumlu deil. Ltfen en son srm indirin ve ykleyin."
};
const deviceLock$6 = {
  button: "Two Factor Authorization (2FA) Etkinletirme",
  condition1: "Bir yedein var m?",
  condition2: "Mobil uygulama dorulama alyor mu?",
  condition3: "2FA yedekleri ve mobil uygulama eletirmesini DEVRE DII brakr. 2FA'dan kmak iin cihazn SIFIRLANMASI olmas gerekir!",
  confirm: "Two Factor Authorization (2FA) Etkinletirme",
  title: "Two Factor Authorization (2FA) Etkinletirme"
};
const deviceSettings$6 = {
  firmware: {
    newVersion: {
      label: "Mevcut srm"
    },
    title: "Donanm yazlm",
    upToDate: "Cihaznz gncel",
    version: {
      label: "Versiyon"
    }
  },
  hardware: {
    sdcard: {
      "false": "Takl deil",
      label: "Mikro SD kart",
      "true": "Takl"
    },
    title: "Donanm"
  },
  loading: "Cihaz bilgisi alnyor",
  pairing: {
    lock: {
      "false": "Devre d",
      label: "Two Factor Authorization (2FA)",
      "true": "Etkinletir"
    },
    mobile: {
      "false": "Kapal",
      label: "Mobil Uygulama",
      "true": "A"
    },
    status: {
      "false": "Eletirilmemi",
      label: "Durum",
      "true": "Eletirilmi"
    },
    title: "Eletirme"
  },
  secrets: {
    manageBackups: "Yedekleri Ynet",
    title: "Secrets"
  }
};
const deviceTampered$6 = "BitBox'nza kurtarma ifresi mi saland? yleyse, kurulum ilemini durdurun ve hemen destee bavurun. Ekibimiz asla size hazr bir czdan vermez veya ifre nerileri yapmaz.";
const dialog$7 = {
  cancel: "ptal Et",
  confirm: "Dorula"
};
const fiat$8 = {
  "default": "Varsaylan",
  setDefault: "{{code}} varsaylan olarak ayarla",
  title: "Para birimleri"
};
const footer$8 = {
  appVersion: "Uygulama Srm:"
};
const genericError$6 = "Bir hata olutu. Herhangi bir sorunla karlarsanz, ltfen uygulamay yeniden balatn.";
const goal$6 = {
  buttons: {
    create: "Yeni bir czdan olutur",
    restore: "Czdan yedekten geri ykle"
  },
  paragraph: "Ltfen aadaki seeneklerden birini sein:",
  step: {
    "1": {
      title: "Gvenlik bilgileri"
    },
    "2": {
      description: "Bir cihaz ifresi belirleyin",
      title: "cihaz"
    },
    "3-create": {
      description: "Yeni bir czdan olutur",
      title: "Czdan"
    },
    "3-restore": {
      description: "bir yedekten",
      title: "Geri Ykle"
    },
    "4-create": {
      title: "zet"
    },
    "4-restore": {
      title: "zet"
    }
  }
};
const guide$7 = {
  accountDescription: {
    text: 'Hesabnza genel bak, mevcut bakiyenizi, gelen ve giden ilemlerinizi gsterir. " Ayarlar" sekmesindeki klavuzumuz her hesap tr hakknda daha fazla bilgi ierir. ',
    title: "Bu sayfa bana ne gsteriyor?"
  },
  accountFiat: {
    text: "Evet. Fiat para birimlerine dntrmek iin herhangi bir ticker'a tklayn. Ayarlardan Fiat para birimlerini deitirebilirsiniz.",
    title: "Dier dnm oranlarn grntleyebilir miyim?"
  },
  accountIncomingBalance: {
    text: "Yatrlanlar; size aktarlan ancak henz a tarafndan onaylanmayan tutarlar gsterir.",
    title: "Yatrlanlar ne demek?"
  },
  accountInfo: {
    xpub: {
      text: "Geniletilmi bir genel anahtar, bir hesabn tm alc adreslerinin tretildii bir kk anahtardr.\nBurada Electrum veya Sentinel gibi yalnzca izlemek iin olan czdanlarla ileri dzeyde kullanm ve birlikte alabilirlik iin salanmtr.",
      title: "Geniletilmi genel anahtar nedir?"
    }
  },
  accountRates: {
    text: "Kripto para kurlarn her dakika CoinGecko'dan gncelliyoruz.",
    title: "Hangi dviz kurlar uygulanyor?"
  },
  accountReload: {
    text: "Buna ihtiyacnz yok. lem bilgileriniz otomatik olarak gncellenir.",
    title: "lem gemiini yeniden ykleyebilir miyim?"
  },
  accountSendDisabled: {
    text: 'Bakiyeniz sfrdan fazla olduunda "Gnder" butonu etkinleir.',
    title: "Neden hibir ey gnderemiyorum {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: "Onaylar: lk ilem yaynnz, bir madenci bir bloa dahil edinceye kadar onaylanmaz, ardndan bir onay verilir. Ada yaynlanan her blok, ileminize baka bir onay ekler. Genel olarak, tccarlar ve dier a aktrler  ila alt onay aldnda ilemleri gerekletirir.\nlem Kimlii: Bir blok gezgininde bir ilem aramanza izin veren benzersiz bir kimlik numaras.\ncret: Madencilere, ilemleri onaylamalarn tevik etmek iin ilem creti denir. Daha fazla bilgi iin, gnder dmesine tklayn.",
    title: "lem detaylarndaki bilgiler neler?"
  },
  accountTransactionConfirmation: {
    text: "Ada yaynlanan ancak henz onaylanmayan bir ilem.",
    title: "Beklemedeki ilem nedir?"
  },
  accountTransactionLabel: {
    text: "Kripto paralarnz aldnz veya gnderdiiniz adres.",
    title: "Her ilemde grntlenen adres hangisi?"
  },
  accountTransactionTime: {
    text: "Blockchain ilem onay sresi.",
    title: "Ne zaman grntlenir?"
  },
  appendix: {
    link: "Bizimle iletiime gein!",
    text: "Baka bir soru?"
  },
  backups: {
    check: {
      text: "'Yedeklemeyi kontrol et', geerli czdannza karlk gelen alan bir yedeklemeniz olduunu dorulamanza olanak tanr. Ayrca hala doru kurtarma ifresine sahip olduunuzu dorulamak iin kullanlabilir. Ana kurtarma ifrenizi veya gizli kurtarma ifrenizi kontrol edebilirsiniz.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: "Hayr, ancak kurtarma ifrenizin czdanda depolanan sedden retilmesi gerekir.",
      title: "Yedeklemeyi ifreleyebilir miyim?"
    },
    howOften: {
      text: "Yeni bir czdan oluturulduunda, yedekleme otomatik olarak oluturulur. Yalnzca microSD kartnz kaybolursa veya hasar grrse veya yedek olarak birden fazla microSD kart kullanmak istiyorsanz, yeni bir yedekleme yapmanz gerekir.\nlem faaliyetinden sonra yeni yedeklemeler oluturmanza gerek yoktur. Tm ilem verileriniz, sizin iin otomatik olarak oluturulan tek bir yedeklemeyle yeniden oluturulabilir.",
      title: "Ne sklkla yedekleme yapmam gerekir?"
    },
    whatIsABackup: {
      text: "Mikro SD kartnzdaki seedin bir kopyas. Seed, kurtarma ifrenizle birlikte czdannz oluturur.",
      title: "Yedek nedir?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Yedeklemeyi kontrol et' geerli czdannza karlk gelen alan bir yedeklemeniz olduunu dorulamanz salar.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: `Hayr. Seedler ifrelenmemi bir ekilde tutulduundan MicroSD kartnz gvende tutun. Seed'i ifreyle korumak istiyorsanz, "Cihaz ynet" altndaki gelimi ayarlardan istee bal bir ifre etkinletirebilirsiniz.`,
      title: "Yedeklemeyi ifreleyebilir miyim?"
    },
    whatIsABackup: {
      text: "Bir microSD karttaki seed'in bir kopyas.",
      title: "Yedek nedir?"
    }
  },
  bitbox: {
    "2FA": {
      text: "2FA etkinletirildiinde, para harcamak iin tm ilemlerin eletirilmi cep telefonunda onaylanmas gerekir. Bylece iifreli bir tek kullanmlk numara mobil uygulamaya gnderilir, orada ifresi zlr ve Kabul Et dmesine basldnda BitBox'a geri dndrlr. Cihazla bu iletiim, cep telefonu ile eletirme srasnda kurulan bu masast uygulamas arasndaki kanal zerinden yaplr.\n\n2FA'y etkinletirmeden nce czdannz yedeklediinizden ve mobil uygulamay eletirdiinizden emin olun. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.",
      title: "ki faktrl dorulama (2FA) nasl alr?"
    },
    disable2FA: {
      text: "2FA'y devre d brakmak iin, BitBox'nz sfrlamanz ve ardndan czdan yedekten geri yklemeniz gerekir. Yedeklemeye sahip microSD kartn hala olduundan ve kurtarma ifresini hala hatrladnzdan emin olun. Ardndan 'Cihaz sfrla' tuuna basn. Yeni bir cihaz ifresi belirleyin ve 'Veya yedei geri ykle'yi sein. Czdanda oluturduunuz yedeklemeyi sein, 'Geri Ykle'yi tklayn ve czdan olutururken kullandnz kurtarma ifresini girin.",
      title: "ki faktrl dorulamay (2FA) nasl devre d brakabilirim?"
    },
    ejectBitbox: {
      text: "",
      title: "BitBox' nasl karabilirim?"
    },
    ejectSD: {
      text: "MicroSD kart BitBox'tan istediiniz zaman yedekleme oluturma veya geri ykleme ilemi yapmadnz srece kaldrabilirsiniz.",
      title: "MicroSD kart nasl karabilirim?"
    },
    hiddenWallet: {
      text: "Ayn cihazda, makul bir reddedilebilirlik iin kullanabileceiniz farkl bir cihaz ifresi ve kurtarma ifresiyle korunan ikinci bir czdandr. Ayn yedek send hem normal, hem de gizli czdannz iin kullanlr, bu nedenle ek bir yedekleme gerekmez.",
      title: "Gizli czdan nedir?"
    },
    legacyHiddenWallet: {
      text: "nce aadaki dmeyi tklayn (BitBox ana cihaz ifresiyle almsa ve 2FA devre d braklmsa kullanlabilir), ardndan Bitbox'nz yeniden takp kilidini gizli cihaz ifrenizle an.",
      title: "Eski gizli czdanma nasl eriirim?"
    },
    pairing: {
      text: "Mobil uygulamamz iOS veya Android iin indirdikten sonra, mobil uygulama ile bu uygulama arasnda gvenli bir kanal kuran grntlenen QR kodunu tararsnz. Tarandktan sonra mobil uygulamadaki talimatlar izleyin.",
      title: "Telefonumla gvenli bir ekilde nasl eletirilir"
    }
  },
  receive: {
    address: {
      text: "Size bakalarnn kripto para gndermeleri iin adresinizi verebilirsiniz. Sadece doru adresi gnderdiinizden emin olun.",
      title: "Bir adres ile ne yapabilirim?"
    },
    addressChange: {
      text: "lem yaptnz anda, otomatik olarak listeye yeni bir adres eklenir, bylece her zaman kripto para almayan 20 adres bulunur.",
      title: "Adresler ne zaman deiir?"
    },
    howVerify: {
      text: "BitBox01 iin soldaki kenar ubuundaki BitBox simgesine tklayn ve Eletirme blmne bakn. Klavuz gncellenir ve oradaki talimatlar izlemeye devam edebilirsiniz.\nBitBox02 iin, gnderme/alma ilemi srasnda adresleri dorudan cihaz zerinde dorulayabilirsiniz.",
      title: "Bir adresi gvenli bir ekilde nasl dorulayabilirim?"
    },
    why20: {
      text: "",
      title: "Neden sadece 20 adres?"
    },
    whyMany: {
      text: "Gizlilii ve gvenlii salamak iin, ayn adresi asla iki kez vermeyin. Bir adres kullandysanz, yeni bir adres iin sa oka tklayn. Bir seferde 20 adede kadar adres oluturabilirsiniz. Fatura numaralar gibi adresleri dnn. Tm adresler, tek yedekleme senedinden tretilir.",
      title: "Neden bu kadar ok adres var?"
    },
    whyVerify: {
      text: "Orijinal adresleri oluturmak ve grntlemek iin bilgisayarnza gvenmemelisiniz. Byk bir saldr, donanm czdannzn daha savunmasz kalmasn salar. BitBox01'in gvenli bir ekilde dorulama dmesi, adresi QR kodunu da tarayabileceiniz ve dorulayabileceiniz eletirilmi bir cep telefonuna gnderir. BitBox02 iin, adres dorudan BitBox02 ekrannda dorulanabilir.",
      title: "Neden adresi gvenli bir ekilde dorulamalym?"
    }
  },
  send: {
    fee: {
      text: "cret, ilem miktarna deil ilem miktarna gre belirlenir. cret hedefleri, setiiniz her a ncelii iin Bitcoin Core'un cret tahmin algoritmas ile hesaplanr. Aadaki hedeften farkl bir deere sahiplerse gsterilirler.\nEkonomi: 24 blok (Bitcoin iin yaklak 4 saat, Litecoin iin 1 saat)\nDk: 12 blok (Bitcoin iin yaklak 2 saat, Litecoin iin 30 dakika)\nNormal: 6 blok (Bitcoin iin yaklak 1 saat, Litecoin iin 15 dakika)\nYksek: 2 blok (Bitcoin iin yaklak 20 dakika, Litecoin iin 5 dakika)\n(Bir blok Bitcoin iin ortalama on dakika srer (Litecoin'de 2.5 dakika) ve a yk yukardaki periyotlarda nemli lde deiebilir.)",
      title: "cret nasl belirlenir?"
    },
    priority: {
      text: "demek istediiniz cret ne kadar yksekse, ileminiz genellikle a tarafndan daha erken onaylanr.",
      title: "A ncelii nedir?"
    },
    revert: {
      text: "Bir ilem imzalanp gnderildikten sonra (yani aa yaynlanr), artk geri alnamaz. mzalamadan nce ilemleri (cret dahil) doru bir ekilde dorulayn!\nAlcy tanyorsanz ve ayn tutar (eksi ilem cretlerini) size geri gndermeye istekliyse, onlara yeni bir alc adresi gnderebilirsiniz.",
      title: "Bir ilemi geri alabilir miyim?"
    },
    whyFee: {
      text: "lemler madenci tarafndan onaylanmak iin yaryor. Madenciler cretlerine gre Blockchain'e dahil edilecek ilemleri seiyorlar.\nMadenciler ilem tarihine oy veriyor. lemleri onaylayacak gvenli bir nc taraf olmad iin (Blockchain'lerin hepsinde), madenciler bilgisayar gc gibi pahal bir kaynaktan fedakarlk yaparak ilemleri oyluyorlar. lerinin bir dl olarak, yeni oluturulan paralar ve ierdikleri tm ilemlerin cretini talep edebilirler.",
      title: "Neden a creti var?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift sunucularn kullanmak yerine czdannza kendi tam node'larnzla g vermek mmkndr.",
      title: "Bu nedir?"
    }
  },
  settings: {
    servers: {
      text: "Bu uygulama, gncellemeleri kontrol etmek, ilemleri yklemek ve eletirilmi mobil uygulamalara bilgi gndermek iin Shift Crypto sunucular ile iletiim kurar.\nBu uygulama ayn zamanda CoinGecko'den en son dviz kurlarn alyor. Tm dnmler yerel olarak hesaplanr, bu ileminizin miktar ile ilgili hibir veri iletilmedii anlamna gelir.\nNot: Ethereum ve ERC20 Tokens iin Etherscan.io API'lerini kullanyoruz.",
      title: "Bu uygulama hangi sunucularla konuuyor?"
    }
  },
  title: "Klavuz",
  toggle: {
    close: "Klavuzu kapat",
    open: "Klavuz"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Kurtarma parolasn kullanarak cihaz sfrlamanz ve czdan bir yedekten geri yklemeniz gerekir.",
      title: "Cihaz ifresini unuttuumda ne yapmalym?"
    },
    reset: {
      text: "15 kez yanl cihaz ifresi girin. Son birka deneme, cihaza uzun sre dokunmay gerektirir.",
      title: "Cihaz nasl sfrlarm?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Cihaz yerletirildiinde bir kez yanp snmelidir. Etrafna doru yerletirildiinden emin olun. Eer sorun yayorsanz, ltfen aadaki balantdan bize ulan.",
      title: "BitBox01 tannmyor"
    },
    getDevice: {
      link: {
        text: "Bir BitBox siparii verin"
      },
      text: "Online maazamzda bir BitBox satn alabilirsiniz:",
      title: "Nasl bir cihaz nasl alabilirim?"
    },
    internet: {
      text: "Evet, czdan senkronize etmek, ilemleri gndermek ve en son kurlar almak iin bir internet balants gerekir.",
      title: "Bu uygulama internet balants gerektiriyor mu?"
    },
    lostDevice: {
      link: {
        text: "Yedekleme merkezi"
      },
      text: "Hesaplarnz yeni bir BitBox'la veya yedekleme merkezimizde kurtarabilirsiniz.",
      title: "Cihazm kaybettim. imdi ne olacak?"
    },
    useWithoutDevice: {
      text: "Ne yazk ki, u anda bu henz mmkn deil.",
      title: "Bir cihaz olmadan uygulamay kullanabilir miyim?"
    },
    welcome: {
      text: "Shift Crypto tarafndan svire'de retilen bu uygulamay kullandnz iin teekkr ederiz. Paylamanz gereken herhangi bir geri bildirimi takdir ediyoruz. Ltfen alttaki balanty kullanarak geri bildirimde bulunun.",
      title: "BitBoxApp'a Hogeldiniz!"
    }
  }
};
const headerssync$6 = {
  blocksSynced: "{{blocks}} blok senkronize edildi"
};
const hiddenWallet$6 = {
  info1HTML: "",
  info2HTML: "Aadaki gizli czdannzla ilikilendirmek istediiniz cihaz ifresini ve kurtarma ifresini tanmlayn. Cihaz ifresi ve kurtarma ifresi <strong>farkl</strong> birincil czdannz iin tanmladnzdan emin olun",
  passwordLabel: "Gizli kurtarma ifresi",
  passwordPlaceholder: "Ltfen gizli kurtarma ifresini onaylayn",
  pinLabel: "Gizli cihaz ifresi",
  pinRepeatLabel: "Gizli cihaz ifresini tekrarla",
  pinRepeatPlaceholder: "Ltfen gizli cihaz ifresini onayla",
  success: "Gizli czdan baaryla oluturuldu. Kilidini amak iin BitBox'nz deitirin."
};
const initialize$6 = {
  create: "Cihaz ifresini ayarla",
  creating: "Cihaz ifresini ayarla",
  error: {
    e102: "Cihaz ifresi en az 4 karakterden olumaldr."
  },
  info: {
    description1: "Cihaz ifrenizi sein. Bu, BitBox'nzn kilidini amak iin kullanlacaktr.",
    description2: "Saylar, harfleri ve sembolleri kullanabilirsiniz. Daha uzun ifreler daha yksek gvenlik sunar.",
    description3: "Cihaz ifresini kaybederseniz, cihaznz sfrlamanz ve czdan yedeklemenizi geri yklemeniz gerekir.",
    subtitle: "imdi cihaz ifrenizi ayarlayacaksnz",
    title: "Cihaznz balatlyor"
  },
  input: {
    label: "Cihaz parolas",
    labelRepeat: "Cihaz ifresini tekrarla",
    placeholderRepeat: "Ltfen cihaz ifresini dorulayn"
  }
};
const invalidFormat$6 = "Geersiz format";
const language$7 = {
  title: "Dil Sein"
};
const legacyhiddenwallet$6 = {
  disable: "Eski gizli czdan devre d brak",
  enable: "Eski gizli czdan etkinletir",
  successDisable: "Eski gizli czdan baaryla devre d braktnz.",
  successEnable: "Eski gizli czdan baaryla etkinletirdi. Eski gizli czdannza erimek iin BitBox'nz deitirin ve gizli cihaz ifresini girin."
};
const loading$6 = "Ykleniyor";
const notification$6 = {
  newTxs_one: "{{accountName}}'da yeni ilem",
  newTxs_other: "{{count}} Yeni ilem: {{accountName}}"
};
const pairing$6 = {
  aborted: {
    text: "Eletirme ilemi mobil uygulamadan kaldrld.",
    title: "Kaldrld"
  },
  button: "Mobil Uygulamayla Eletir",
  confirm: "BitBox'nz eletirmek istediinizden emin misiniz? Sonradan, cep telefonunun bir ilem gerekletirmesi gerektiini unutmayn.",
  connectOnly: {
    button: "Mobil Uygulamay Bala",
    title: "'Yeni masast uygulamasna balan' esini seerek mobil uygulamamz ile tarayn"
  },
  error: {
    text: "Bir eyler yanl gitti. Ltfen tekrar bala.",
    title: "Hata"
  },
  reconnectOnly: {
    button: "Mobil Uygulamay Yeniden Bala"
  },
  start: {
    hideAppQRCode: "QR Kodunu Gizle",
    revealAppQRCode: "QR Kodunu Gster",
    step1: "Mobil uygulamanz yoksa, sahip olduunuz telefona bal olarak Apple App Store veya Google Play Store iin QR kodunu tarayabilirsiniz.",
    step2: "OS ve Android uygulama maazalarnda 'Digital Bitbox 2FA' ad altnda bulabileceiniz mobil uygulamamz ile tarayn:"
  },
  started: {
    text: "imdi mobil uygulamadaki talimatlar izleyin.",
    title: "Harika"
  },
  success: {
    text: "Tebrikler, BitBox'nz mobil uygulamayla baaryla eletirdiniz!",
    title: "Baarl"
  },
  timeout: {
    text: "Eletirme iki dakikann ardndan zaman amna urad. Mobil uygulamay hala eletirmek istiyorsanz tekrar balayn.",
    title: "Zaman am"
  },
  title: "Mobil Eletirme"
};
const password$6 = {
  show: "Gster {{label}}",
  warning: {
    caps: "UYARI: Byk harf kilidi () aktif",
    paste: 'Metni yaptrmak iin "GSTER" butonunu etkinletirin {{label}}"'
  }
};
const random$7 = {
  button: "Rastgele Say ret",
  description: "BitBox'nz aadaki {{bits}}-bit random saylar retti:"
};
const receive$8 = {
  label: "Sizin adresiniz",
  onlyThisCoin: {
    description: "Baka token'lar almak iin, onlar ayarlardan etkinletirin. Dier token'lar yatrrsanz, eriilebilir olmayabilir.",
    warning: "Sadece bu adresle  {{coinName}} almak istediinize emin olun"
  },
  showFull: "Cihazdaki tam adresi gster ve dorula",
  title: "{{accountName}} Al",
  verify: "Adresi gvenli bir ekilde dorulayn",
  verifyBitBox01: "Mobil uygulamadaki adresi dorula",
  verifyBitBox02: "BitBox02'deki adresi dorulayn",
  verifyInstruction: "Ltfen aadaki adresin cihaznzda grntlenen adresiyle eletiini dorulayn.",
  warning: {
    secureOutput: "Gvenli adres dorulamasn etkinletirmek iin ltfen BitBox'nz mobil cihaznzla eletirin ve kenar ubuundaki 'Cihaz Ynet' seeneine tklayn."
  }
};
const reset$6 = {
  description: "Cihazdaki tm veriler silinecek. Buna zel Anahtarnz da dahil!",
  notReset: "Cihaz SIFIRLAMA.",
  title: "Cihaz sfrla",
  understand: "Bir yedeim var ve kurtarma ifremi biliyorum",
  understandBB02: "Geerli bir yedeim var"
};
const securityInformation$6 = {
  create: {
    description1: "Cihaznz kurmadan nce bunu gvenli bir ortamda yapmanz nerilir.",
    description2: "Sizden iki ifre oluturmanz istenecektir.",
    description3: "lki <strong>cihaz parolas</strong>. Bu ifre BitBox cihaznzn kilidini aar ve daha sonra deitirilebilir.",
    description4: "kincisi czdannzn kilidini aan <strong>kurtarma ifresi</strong>. Bu ifre daha sonra deitirilemez.",
    description5: "Oluturduunuz czdan, salanan mikro SD karttaki bir dosyaya yedeklenir. Bu, acil durumda <strong>kurtarma ifrenizi</strong> kullanarak fonlarnza ulamanz salar.",
    title: "Gvenlik Uyars"
  },
  restore: {
    description1: "Yedeklemenizi saklamak iin kullandnz mikro SD kart takmanz istenecektir.",
    description2: "Cihaznz geri yklemek iin kurtarma ifrenizin olmas gerekir. ",
    description3: "Ltfen kurtarma ifresini girerken dikkatli olun. Girdiiniz herhangi bir ifre geerli bir czdan yaratacaktr. Yanl ifre girerseniz, beklemediiniz bir czdan bakiyesi gsterilebilir.",
    title: "Gvenlik Uyars"
  }
};
const seed$6 = {
  agreements: {
    "funds-access": "Kurtarma ifremi unutursam parama ulaamayacam",
    "password-change": "Kurtarma ifresini daha sonra deitiremem",
    "password-required": "Bir czdan bir yedekten geri yklemek kurtarma ifresi gerektirir."
  },
  create: "Czdan Olutur",
  creating: "Czdan oluturma",
  description: "Bunu kabul ediyorum:",
  error: {
    e102: "ifre en az 4 karakterden olumaldr.",
    e200: "Czdan oluturmak iin BitBox'nza bir mikro SD kart takmanz gerekir, bylece yedekleme otomatik olarak oluturulabilir."
  },
  info: {
    button: "Kurtarma ifresini imdi ayarla",
    description1: "Mikro SD kart BitBox'a takn",
    description2: "Czdan iin bir kurtarma ifresi ayarlayn ve imdi kurtarma ifresini ayarla seeneini tklayn.",
    description3: "Micro SD karta yedekleme ve kurtarma ifreniz, BitBox cihazn kaybolmas veya alnmas durumunda paranz kurtarmak iin tek yntemdir.",
    description4: "Paranz aktarmadan kurtarma ifrenizi  deitiremezsiniz.",
    title: "Yeni bir czdan olutur"
  },
  password: {
    label: "Kurtarma ifresi",
    repeatPlaceholder: "Kurtarma ifresini tekrarla"
  },
  walletName: {
    label: "Czdan ad"
  }
};
const seedRestore$6 = {
  error: {
    e200: "Bir czdan yedekten geri yklemek iin mikro SD kart gerekir."
  },
  info: {
    description1: `Mikro SD kart BitBox'a takn ve "Devam Et" esine tklayn`,
    description2: 'Bir yedekleme sein ve "Geri Ykle" esini sein',
    description3: "Kurtarma ifresini girin",
    description4: "Yanl bir ifrenin farkl bir czdan yaratacan kabul ettiinizi onaylamanz gerekir.",
    title: "Bir czdan bir yedekten geri ykleme"
  }
};
const send$8 = {
  abort: "lem iptal edildi.",
  address: {
    label: "Alc adresi",
    placeholder: "Adresi girin"
  },
  amount: {
    label: "Miktar",
    placeholder: "Miktar girin"
  },
  button: "mzala ve Gnder",
  coincontrol: {
    address: "Adres",
    outpoint: "kt",
    title: "ktdan Gnder"
  },
  confirm: {
    "selected-coins": "Seilmi Kripto Paralar",
    title: "lemi Onayla",
    total: "Toplam"
  },
  error: {
    insufficientFunds: "yetersiz bakiye",
    invalidAddress: "geersiz adres",
    invalidAmount: "geersiz miktar",
    invalidData: "geersiz veri"
  },
  fee: {
    customPlaceholder: "Miktar girin",
    label: "A creti",
    placeholder: "Kullanlabilir deil"
  },
  feeTarget: {
    description: {
      economy: "24 blok (Bitcoin iin yaklak 4 saat, Litecoin iin 1 saat)",
      high: "2 blok (Bitcoin iin yaklak 20 dakika, Litecoin iin 5 dakika)",
      low: "12 blok (Bitcoin iin yaklak 2 saat, Litecoin iin 30 dakika)",
      normal: "6 blok (Bitcoin iin yaklak 1 saat, Litecoin iin 15 dakika)"
    },
    estimate: "Tahmini bekleme sresi:",
    label: {
      economy: "ekonomi",
      high: "yksek",
      low: "dk",
      normal: "normal"
    },
    placeholder: "Hesaplanan tahmini cret"
  },
  maximum: "Hepsini gnder",
  scanQR: "QR Kodunu Tara",
  signprogress: {
    description: "Bu, ok fazla veri ieren bir ilemdir. lemi tamamen imzalamak iin  {{steps}} defa onaylamanz istenir.",
    label: "lerleme"
  },
  success: "lem imzaland ve gnderildi.",
  title: "Gnder {{accountName}}",
  toggleCoinControl: "Kripto para kontroln a"
};
const settings$7 = {
  electrum: {
    add: "Bir sunucu ekle",
    "add-server": "Ekle",
    check: "Kontrol et",
    checkFailed: "Baarsz oldu",
    checkSuccess: "Baaryla balant kuruldu {{host}}",
    checking: "Kontrol ediliyor",
    "download-cert": "Uzak sertifikay indir",
    "remove-server": "Kaldr",
    removeConfirm: "Kaldr {{server}}?",
    reset: "Varsaylana sfrla",
    resetConfirm: "Tm sunucular kaldrmak ve varsaylan sunucular kurmak istiyor musunuz?",
    servers: "Sunucular",
    step1: "1",
    "step1-text": "Biti noktasn girin.",
    step2: "2",
    "step2-text": "Sunucunun sertifika zincirinden bir sertifikasn girin. Alternatif olarak, uzak sertifikay indirin ve grsel olarak karlatrn.",
    step3: "3",
    "step3-text": "Balantnz kontrol edin ve sunucuyu ekleyin.",
    step4: "4",
    "step4-text": "Czdannz yeniden balatn. Varsaylan sunucular kaldrmazsanz, kendi dmnz fazlalk olarak eklenir.",
    "title-btc": "Bitcoin Electrum Sunucular",
    "title-ltc": "Litecoin Electrum Sunucular",
    "title-tbtc": "Bitcoin Testnet Electrum Sunucular",
    "title-tltc": "Litecoin Testnet Electrum Sunucular"
  },
  expert: {
    coinControl: "Coin kontroln etkinletir",
    electrum: {
      title: "Kendi tam node'unuza balayn"
    },
    setProxyAddress: "Proxy adresini ayarla",
    title: "Uzman Ayarlar",
    useProxy: "Tor proxy'yi etkinletir"
  },
  header: {
    home: "Ev"
  },
  restart: "Ltfen deiikliklerin geerli olmas iin BitBoxAppi yeniden balatn.",
  success: "Deiikliklerin etkili olmas iin ltfen BitBoxun fiini ekin ve yeniden takn.",
  title: "Ayarlar"
};
const setup$6 = "Cihaza Kurulum Yap";
const sidebar$7 = {
  device: "Cihaz Ynet",
  leave: "Ayrl",
  settings: "Ayarlar"
};
const success$d = {
  create: {
    info1: "Czdannz micro SD Karta gvenli bir ekilde yedeklendi. karn ve gvenli bir yerde saklayn.",
    info2: "BitBox'un kilidini aan gvenli bir cihaz ifresi oluturdunuz.",
    info3: "Czdannz iin paranzn kilidini aan ve yedeklerinizi geri ykleyen gvenli bir kurtarma ifresi oluturdunuz.",
    summary: "te ilem zetiniz",
    title: "Baarl"
  },
  getstarted: "Balarken",
  restore: {
    summary: "Yedeklemenizden bir czdan baaryla geri yklediniz.",
    title: "Baarl"
  }
};
const transaction$7 = {
  confirmation: "Onaylar",
  explorer: "lem Kimlii",
  explorerTitle: "Harici explorer'da a",
  fee: "cret",
  fiatHistorical: "Tarih",
  gas: "Gas",
  pending: "Bekleyen ilem",
  size: "Boyut",
  vsize: "Sanal boyut",
  weight: "Arlk"
};
const transactions$6 = {
  placeholder: "Henz ilem yok."
};
const unknownError$6 = "Bilinmeyen bir hata olutu: {{errorMessage}}";
const unlock$6 = {
  description: "Cihaznzn kilidini amak iin cihaz ifrenizi girin.",
  error: {
    e109_normal: "Cihaz ifresi yanl. Cihaz sfrlanmadan nce {{remainingAttempts}} yapabilirsiniz.",
    e109_touch: "$t(unlock.error.e109_normal) Bir sonraki giri iin dokunmatik dmeye basl tutmanz gerektirir.",
    e113: "Birok giri denemesi nedeniyle, bir sonraki giri iin dokunmatik dmeye 4 saniye basl tutmanz gerekiyor."
  },
  input: {
    label: "Cihaz ifresi",
    placeholder: "Cihazn kilidini amak iin cihaz ifrenizi girin."
  },
  unlocking: "Kilit alyor"
};
const upgradeFirmware$7 = {
  button: "Donanm yazlmn ykselt",
  description: "Donanm yazlmn  {{currentVersion}}'dan {{newVersion}}'a ykseltmek istiyor musunuz??",
  label: "BitBox'nzn rn yazlmnn ykseltilmesi gerekiyor.",
  locked: " {{currentVersion}} den ykseltmek iin iin {{newVersion}}, ltfen uzun sre basl tutun.",
  title: "Donanm yazlmn ykselt",
  unlocked: "Bootloader kilidi ald. Devam etmek iin ltfen:",
  unlocked1: "Bitbox'nz karn ve yeniden takn",
  unlocked2: "BitBox'unuz tekrar takldnda LED yanacaktr",
  unlocked3: "LED yandnda dmeye dokunun"
};
const warning$c = {
  receivePairing: "Gvenli adres dorulamasn etkinletirmek iin ltfen BitBox' eletirin. Kenar ubuunda 'Cihaz Ynet' seeneine gidin.",
  sdcard: "Yedeklemeleri ynetmek istemediiniz srece, mikro SD kart BitBox'tan ayr saklayn.",
  sendPairing: "lem ayrntlarn gvenli bir ekilde dorulamak iin ltfen BitBox' eletirin. Kenar ubuundan 'Cihaz Ynet' seeneine gidin."
};
const welcome$6 = {
  insertBitBox02: "Devam etmek iin ltfen cihaza dokunun.",
  insertDevice: "Balamak iin ltfen cihaznz balayn",
  title: "Hogeldiniz"
};
const appTranslationsTR = {
  account: account$6,
  accountInfo: accountInfo$6,
  accountSummary: accountSummary$6,
  addAccount: addAccount$7,
  app: app$6,
  backup: backup$6,
  bb02Bootloader: bb02Bootloader$6,
  bitbox: bitbox$6,
  bitbox02Interact: bitbox02Interact$6,
  bitbox02Settings: bitbox02Settings$6,
  bitbox02Wizard: bitbox02Wizard$6,
  blink: blink$6,
  bootloader: bootloader$6,
  button: button$b,
  changePin: changePin$6,
  checkSDcard: checkSDcard$6,
  clickHere: clickHere$6,
  confirm: confirm$8,
  confirmOnDevice: confirmOnDevice$6,
  device: device$6,
  deviceLock: deviceLock$6,
  deviceSettings: deviceSettings$6,
  deviceTampered: deviceTampered$6,
  dialog: dialog$7,
  fiat: fiat$8,
  footer: footer$8,
  genericError: genericError$6,
  goal: goal$6,
  guide: guide$7,
  headerssync: headerssync$6,
  hiddenWallet: hiddenWallet$6,
  initialize: initialize$6,
  invalidFormat: invalidFormat$6,
  language: language$7,
  legacyhiddenwallet: legacyhiddenwallet$6,
  loading: loading$6,
  notification: notification$6,
  pairing: pairing$6,
  password: password$6,
  random: random$7,
  receive: receive$8,
  reset: reset$6,
  securityInformation: securityInformation$6,
  seed: seed$6,
  seedRestore: seedRestore$6,
  send: send$8,
  settings: settings$7,
  setup: setup$6,
  sidebar: sidebar$7,
  success: success$d,
  transaction: transaction$7,
  transactions: transactions$6,
  unknownError: unknownError$6,
  unlock: unlock$6,
  upgradeFirmware: upgradeFirmware$7,
  warning: warning$c,
  welcome: welcome$6
};
const account$5 = {
  disconnect: "....",
  exportTransactions: "CSV",
  fatalError: "",
  incoming: "",
  initializing: "",
  reconnecting: ""
};
const accountInfo$5 = {
  address: "",
  extendedPublicKey: "",
  label: "",
  title: "",
  verify: ""
};
const accountSummary$5 = {
  balance: "",
  exportSummary: "CSV",
  fiatBalance: "",
  name: "",
  noAccount: "",
  title: "",
  total: ""
};
const addAccount$6 = {
  title: ""
};
const app$5 = {
  upgrade: " {{current}}  {{version}}"
};
const backup$5 = {
  check: {
    checking: "",
    confirmTitle: "",
    notOK: "",
    ok: "",
    password: {
      label: "",
      placeholder: "",
      showLabel: ""
    },
    success: "",
    title: ""
  },
  create: {
    alreadyExists: "",
    fail: "",
    info: "",
    name: {
      label: "",
      placeholder: ""
    },
    password: {
      label: "",
      placeholder: ""
    },
    title: "",
    verificationFailed: ""
  },
  description: " <strong></strong>",
  insert: "Micro SD",
  insertButton: "Micro SD",
  list: "microSD",
  noBackups: "microSD",
  restore: {
    confirmTitle: "",
    error: {
      e200: "()microSD"
    },
    password: {
      label: "",
      placeholder: "",
      repeatPlaceholder: "",
      showLabel: ""
    },
    restoring: "",
    title: "",
    understand: ""
  },
  showMnemonic: {
    description: "24()\n\n<strong></strong>\n\n<strong></strong>\n\n<strong></strong>\n\n",
    title: ""
  },
  title: ""
};
const bb02Bootloader$5 = {
  abort: "-",
  advanced: {
    label: "",
    toggleShowFirmwareHash: ""
  },
  flipscreen: "",
  orientation: "",
  success: "() {{rebootSeconds}} ..."
};
const bitbox$5 = {
  error: {
    e10000: "",
    e10001: "",
    e102: "4",
    e112: ""
  }
};
const bitbox02Interact$5 = {
  followInstructions: "BitBox02"
};
const bitbox02Settings$5 = {
  deviceName: {
    current: "",
    input: "BitBox02 ",
    title: "BitBox02"
  }
};
const bitbox02Wizard$5 = {
  attestationFailed: "",
  backup: {
    point1: "microSD",
    point2: "",
    restoreText: "",
    text1: "BitBox02microSDBitBox02",
    text2: "",
    text3: "microSD<strong></strong> microSDBitBox02",
    userConfirmation1: "",
    userConfirmation2: "",
    userConfirmation3: "BitBox02()",
    userConfirmation4: "BitBox02"
  },
  create: {
    button: " & ",
    info: "BitBox ",
    inputTitle: "",
    point1: "",
    point2: "BitBox",
    point3: "",
    text: ""
  },
  initialize: {
    passwordText: "BitBox",
    passwordTitle: "BitBox",
    text: "BitBox02() <strong>BitBox02microSD</strong>",
    tip: "",
    title: "BitBox"
  },
  insertSDCard: "<strong>BitBox02microSD</strong>",
  pairing: {
    failed: "BitBox02",
    paired: "",
    title: "",
    unpaired: "BitBox02()BitBox02"
  },
  restoreFromMnemonic: {
    failed: ""
  },
  stepBackup: {
    beforeProceed: "",
    createBackup: "microSD"
  },
  stepBackupSuccess: {
    fundsSafe: "",
    title: ""
  },
  stepConnected: {
    unlock: "BitBox02"
  },
  stepCreate: {
    nameLabel: "BitBox02",
    namePlaceholder: "BitBox02",
    title: "BitBox02",
    toastMicroSD: "microSDBitBox02"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02microSD",
    success: ""
  },
  stepPassword: {
    title: "BitBox02",
    useControls: "BitBox02"
  },
  stepUninitialized: {
    create: "BitBox02",
    restore: "",
    restoreMicroSD: "microSD",
    restoreMnemonic: "",
    title: "BitBox02"
  },
  success: {
    text: "BitBox02\n\nBitBoxApp",
    title: ""
  }
};
const blink$5 = {
  button: ""
};
const bootloader$5 = {
  button: "",
  progress: " {{progress}}",
  success: ""
};
const button$a = {
  abort: "",
  back: "",
  changepin: "",
  check: "",
  "continue": "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: "()",
  update: "",
  upgrade: ""
};
const changePin$5 = {
  newTitle: "",
  oldLabel: ""
};
const checkSDcard$5 = "microSD";
const clickHere$5 = "";
const confirm$7 = {
  abortInfo: " ",
  abortInfoRedText: "",
  approveInfo: "4 ",
  approveInfoGreenText: "",
  info: "BitBox",
  infoWhenPaired: "BitBox"
};
const confirmOnDevice$5 = "";
const device$5 = {
  appUpradeRequired: "BitBox"
};
const deviceLock$5 = {
  button: "2FA",
  condition1: "",
  condition2: "app",
  condition3: "2FA2FA",
  confirm: "(2FA)",
  title: "2FA"
};
const deviceSettings$5 = {
  firmware: {
    newVersion: {
      label: ""
    },
    title: "",
    upToDate: "",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": "",
      label: "microSD",
      "true": ""
    },
    title: ""
  },
  loading: "",
  pairing: {
    lock: {
      "false": "",
      label: "2FA",
      "true": ""
    },
    mobile: {
      "false": "",
      label: "app",
      "true": ""
    },
    status: {
      "false": "",
      label: "",
      "true": ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "",
    title: ""
  }
};
const deviceTampered$5 = "BitBox Shift";
const dialog$6 = {
  cancel: "",
  confirm: ""
};
const fiat$7 = {
  "default": "",
  setDefault: " {{code}} ",
  title: "()"
};
const footer$7 = {
  appVersion: "App"
};
const genericError$5 = "";
const goal$5 = {
  buttons: {
    create: "",
    restore: ""
  },
  paragraph: "",
  step: {
    "1": {
      title: ""
    },
    "2": {
      description: "",
      title: ""
    },
    "3-create": {
      description: "",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$6 = {
  accountDescription: {
    text: " ",
    title: ""
  },
  accountFiat: {
    text: "",
    title: ""
  },
  accountIncomingBalance: {
    text: "()",
    title: "()"
  },
  accountInfo: {
    xpub: {
      text: "\nwatch-only(),ElectrumSentinel",
      title: ""
    }
  },
  accountRates: {
    text: "CoinGecko",
    title: ""
  },
  accountReload: {
    text: "",
    title: ""
  },
  accountSendDisabled: {
    text: "",
    title: " {{unit}}"
  },
  accountTransactionAttributesBTC: {
    text: "\n\nSegwit1()4()()(1MB)()",
    title: "Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: "\nID\n",
    title: ""
  },
  accountTransactionConfirmation: {
    text: "",
    title: ""
  },
  accountTransactionLabel: {
    text: "",
    title: ""
  },
  accountTransactionTime: {
    text: "",
    title: ""
  },
  appendix: {
    link: "",
    text: ""
  },
  backups: {
    check: {
      text: "()",
      title: ""
    },
    encrypt: {
      text: "",
      title: ""
    },
    howOften: {
      text: "microSDmicroSD\n",
      title: ""
    },
    whatIsABackup: {
      text: "micro SD",
      title: ""
    }
  },
  backupsBB02: {
    check: {
      text: "",
      title: ""
    },
    encrypt: {
      text: "Micro SD",
      title: ""
    },
    whatIsABackup: {
      text: "microSD",
      title: ""
    }
  },
  bitbox: {
    "2FA": {
      text: "2FAappBitBox\n\n2FAappmicro SDappBitBox",
      title: "2FA"
    },
    disable2FA: {
      text: "2FABitBoxmicroSD",
      title: "2FA"
    },
    ejectBitbox: {
      text: "BitBox",
      title: "BitBox"
    },
    ejectSD: {
      text: "BitBoxmicroSD",
      title: "microSD"
    },
    hiddenWallet: {
      text: '"plausible deniability"',
      title: ""
    },
    legacyHiddenWallet: {
      text: "BitBox2FABitbox",
      title: "legacy"
    },
    pairing: {
      text: "iOSAndroidappappapp",
      title: ""
    }
  },
  receive: {
    address: {
      text: "",
      title: ""
    },
    addressChange: {
      text: "()20",
      title: ""
    },
    howVerify: {
      text: "BitBox01BitBox\nBitBox02/",
      title: ""
    },
    why20: {
      text: "appapp()()20gap limit2020",
      title: "20"
    },
    whyMany: {
      text: "()20",
      title: ""
    },
    whyVerify: {
      text: "BitBox01QRBitBox02BitBox02",
      title: ""
    }
  },
  send: {
    fee: {
      text: "()Bitcoin Core\n2441\n12230\n/6115\n2205\n2.5",
      title: ""
    },
    priority: {
      text: "",
      title: ""
    },
    revert: {
      text: "()\n",
      title: ""
    },
    whyFee: {
      text: "()\n",
      title: ""
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift",
      title: ""
    }
  },
  settings: {
    servers: {
      text: "appShift Cryptoapps\nappCoinGecko\nERC20Etherscan.io API",
      title: "app"
    }
  },
  title: "",
  toggle: {
    close: "",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "",
      title: ""
    },
    reset: {
      text: "15",
      title: ""
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "",
      title: "BitBox01"
    },
    getDevice: {
      link: {
        text: "BitBox"
      },
      text: "BitBox",
      title: ""
    },
    internet: {
      text: "",
      title: "app"
    },
    lostDevice: {
      link: {
        text: ""
      },
      text: "BitBox",
      title: ""
    },
    useWithoutDevice: {
      text: "",
      title: "app"
    },
    welcome: {
      text: "Shift Crypto",
      title: "BitBoxApp"
    }
  }
};
const headerssync$5 = {
  blocksSynced: "{{blocks}} "
};
const hiddenWallet$5 = {
  info1HTML: '"plausible deniability" <strong></strong> +',
  info2HTML: " <strong></strong> ",
  passwordLabel: "",
  passwordPlaceholder: "",
  pinLabel: "",
  pinRepeatLabel: "",
  pinRepeatPlaceholder: "",
  success: "BitBox"
};
const initialize$5 = {
  create: "",
  creating: "...",
  error: {
    e102: "4"
  },
  info: {
    description1: "BitBox",
    description2: " & ",
    description3: "",
    subtitle: "",
    title: ""
  },
  input: {
    label: "",
    labelRepeat: "",
    placeholderRepeat: ""
  }
};
const invalidFormat$5 = "";
const language$6 = {
  title: ""
};
const legacyhiddenwallet$5 = {
  disable: "legacy",
  enable: "Legacy",
  successDisable: "legacy",
  successEnable: "legacyBitBoxlegacy"
};
const loading$5 = "...";
const notification$5 = {
  newTxs_one: "{{count}}  {{accountName}}",
  newTxs_other: "{{count}}  {{accountName}}"
};
const pairing$5 = {
  aborted: {
    text: "app",
    title: ""
  },
  button: "app",
  confirm: "BitBox",
  connectOnly: {
    button: "app",
    title: "app"
  },
  error: {
    text: "",
    title: ""
  },
  reconnectOnly: {
    button: "app"
  },
  start: {
    hideAppQRCode: "",
    revealAppQRCode: "",
    step1: "appApple App StoreGoogle Play",
    step2: "appiOSAndroid Digital Bitbox 2FAapp"
  },
  started: {
    text: "app",
    title: ""
  },
  success: {
    text: "BitBoxapp",
    title: ""
  },
  timeout: {
    text: "app",
    title: ""
  },
  title: ""
};
const password$5 = {
  show: " {{label}}",
  warning: {
    caps: "",
    paste: " {{label}}"
  }
};
const random$6 = {
  button: "",
  description: "BitBox {{bits}}"
};
const receive$7 = {
  label: "",
  onlyThisCoin: {
    description: "",
    warning: " {{coinName}} "
  },
  showFull: "",
  title: " {{accountName}}",
  verify: "",
  verifyBitBox01: "app",
  verifyBitBox02: "BitBox02",
  verifyInstruction: "",
  warning: {
    secureOutput: "BitBox"
  }
};
const reset$5 = {
  description: "",
  notReset: "",
  title: "",
  understand: "",
  understandBB02: ""
};
const securityInformation$5 = {
  create: {
    description1: "",
    description2: "",
    description3: " <strong></strong> BitBox",
    description4: " <strong></strong> ",
    description5: "microSD <strong></strong>",
    title: ""
  },
  restore: {
    description1: "microSD",
    description2: " ",
    description3: "",
    title: ""
  }
};
const seed$5 = {
  agreements: {
    "funds-access": "/",
    "password-change": "",
    "password-required": ""
  },
  create: "",
  creating: "",
  description: "",
  error: {
    e102: "4",
    e200: "BitBoxmicroSD"
  },
  info: {
    button: "",
    description1: "microSDBitBox",
    description2: "",
    description3: "BitBoxmicroSD",
    description4: "",
    title: ""
  },
  password: {
    label: "",
    repeatPlaceholder: ""
  },
  walletName: {
    label: ""
  }
};
const seedRestore$5 = {
  error: {
    e200: "microSD"
  },
  info: {
    description1: "microSDBitBox",
    description2: "",
    description3: "",
    description4: "",
    title: ""
  }
};
const send$7 = {
  abort: "",
  address: {
    label: "",
    placeholder: ""
  },
  amount: {
    label: "",
    placeholder: ""
  },
  button: "",
  coincontrol: {
    address: "",
    outpoint: "",
    title: ""
  },
  confirm: {
    "selected-coins": "",
    title: "",
    total: ""
  },
  error: {
    insufficientFunds: "",
    invalidAddress: "",
    invalidAmount: "",
    invalidData: ""
  },
  fee: {
    customPlaceholder: "",
    label: "",
    placeholder: ""
  },
  feeTarget: {
    description: {
      economy: "24Bitcoin4Litecoin1",
      high: "2Bitcoin20Litecoin5",
      low: "12Bitcoin2Litecoin30",
      normal: "6Bitcoin1Litecoin15"
    },
    estimate: "",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: "/"
    },
    placeholder: ""
  },
  maximum: "",
  scanQR: "",
  signprogress: {
    description: " {{steps}} ",
    label: ""
  },
  success: "",
  title: " {{accountName}}",
  toggleCoinControl: "coin"
};
const settings$6 = {
  electrum: {
    add: "",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: " {{host}}",
    checking: "",
    "download-cert": "",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "",
    resetConfirm: "",
    servers: "",
    step1: "1",
    "step1-text": "endpoint",
    step2: "2",
    "step2-text": "",
    step3: "3",
    "step3-text": "",
    step4: "4",
    "step4-text": "",
    "title-btc": "Bitcoin Electrum",
    "title-ltc": "LitecoinElectrum",
    "title-tbtc": "BitcoinElectrum",
    "title-tltc": "LitecoinElectrum"
  },
  expert: {
    coinControl: "coin",
    electrum: {
      title: ""
    },
    setProxyAddress: "",
    title: "/",
    useProxy: "tor"
  },
  header: {
    home: ""
  },
  restart: "BitBoxApp",
  success: "BitBox",
  title: ""
};
const setup$5 = "";
const sidebar$6 = {
  device: "",
  leave: "",
  settings: ""
};
const success$c = {
  create: {
    info1: "microSDmicroSD",
    info2: "BitBox",
    info3: "",
    summary: "",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: "",
    title: ""
  }
};
const transaction$6 = {
  confirmation: "",
  explorer: "ID",
  explorerTitle: "",
  fee: "()",
  fiatHistorical: "",
  gas: "Gas",
  pending: "",
  size: "()",
  vsize: "()",
  weight: "()"
};
const transactions$5 = {
  placeholder: ""
};
const unknownError$5 = " {{errorMessage}}";
const unlock$5 = {
  description: "",
  error: {
    e109_normal: " {{remainingAttempts}} ",
    e109_touch: "$t(unlock.error.e109_normal",
    e113: "4"
  },
  input: {
    label: "",
    placeholder: ""
  },
  unlocking: "..."
};
const upgradeFirmware$6 = {
  button: "",
  description: " {{currentVersion}} {{newVersion}}",
  label: "BitBox",
  locked: " {{currentVersion}}  {{newVersion}}()",
  title: "",
  unlocked: "",
  unlocked1: "Bitbox",
  unlocked2: "BitBoxLED",
  unlocked3: "LED"
};
const warning$b = {
  receivePairing: "BitBox",
  sdcard: "microSDBitBox",
  sendPairing: "BitBox"
};
const welcome$5 = {
  insertBitBox02: "BitBox02",
  insertDevice: "",
  title: ""
};
const appTranslationsZH = {
  account: account$5,
  accountInfo: accountInfo$5,
  accountSummary: accountSummary$5,
  addAccount: addAccount$6,
  app: app$5,
  backup: backup$5,
  bb02Bootloader: bb02Bootloader$5,
  bitbox: bitbox$5,
  bitbox02Interact: bitbox02Interact$5,
  bitbox02Settings: bitbox02Settings$5,
  bitbox02Wizard: bitbox02Wizard$5,
  blink: blink$5,
  bootloader: bootloader$5,
  button: button$a,
  changePin: changePin$5,
  checkSDcard: checkSDcard$5,
  clickHere: clickHere$5,
  confirm: confirm$7,
  confirmOnDevice: confirmOnDevice$5,
  device: device$5,
  deviceLock: deviceLock$5,
  deviceSettings: deviceSettings$5,
  deviceTampered: deviceTampered$5,
  dialog: dialog$6,
  fiat: fiat$7,
  footer: footer$7,
  genericError: genericError$5,
  goal: goal$5,
  guide: guide$6,
  headerssync: headerssync$5,
  hiddenWallet: hiddenWallet$5,
  initialize: initialize$5,
  invalidFormat: invalidFormat$5,
  language: language$6,
  legacyhiddenwallet: legacyhiddenwallet$5,
  loading: loading$5,
  notification: notification$5,
  pairing: pairing$5,
  password: password$5,
  random: random$6,
  receive: receive$7,
  reset: reset$5,
  securityInformation: securityInformation$5,
  seed: seed$5,
  seedRestore: seedRestore$5,
  send: send$7,
  settings: settings$6,
  setup: setup$5,
  sidebar: sidebar$6,
  success: success$c,
  transaction: transaction$6,
  transactions: transactions$5,
  unknownError: unknownError$5,
  unlock: unlock$5,
  upgradeFirmware: upgradeFirmware$6,
  warning: warning$b,
  welcome: welcome$5
};
const account$4 = {
  disconnect: "      ...",
  "export": "",
  exportTransactions: "       CSV      ",
  fatalError: "  .",
  incoming: "",
  initializing: "    ...",
  reconnecting: "        ..."
};
const accountInfo$4 = {
  address: "",
  extendedPublicKey: "   ",
  label: " ",
  title: " ",
  verify: "  "
};
const accountSummary$4 = {
  balance: "",
  exportSummary: "          CSV",
  fiatBalance: "   ",
  name: " ",
  noAccount: "    .",
  title: "  ",
  total: ""
};
const addAccount$5 = {
  title: " "
};
const app$4 = {
  upgrade: "    .      {{current}}   {{version}}  ."
};
const backup$4 = {
  check: {
    checking: "  ...",
    confirmTitle: " ",
    notOK: "      .",
    ok: "      ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: "     :",
    title: " "
  },
  create: {
    alreadyExists: "    .      ",
    fail: "      !",
    info: "         ",
    name: {
      label: " ",
      placeholder: "     "
    },
    password: {
      label: " ",
      placeholder: "     "
    },
    title: " ",
    verificationFailed: "       .    .    ' '      ."
  },
  description: "<strong>   </strong>  .",
  insert: "     microSD   ",
  insertButton: " microSD   ",
  list: "      microSD",
  noBackups: "      SD  .",
  restore: {
    confirmTitle: " ",
    error: {
      e200: " microSD  ."
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "  ",
      showLabel: " "
    },
    restoring: "  ...",
    title: "",
    understand: "            "
  },
  showMnemonic: {
    description: "   24           .      .\n<strong>      .     </strong>\n<strong>   .</strong>\n<strong>     .</strong>\n            .\n",
    title: "  "
  },
  title: "  "
};
const bb02Bootloader$4 = {
  abort: "     ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "        "
  },
  flipscreen: " ",
  orientation: "   ",
  success: "    !   {{rebootSeconds}} ..."
};
const bitbox$4 = {
  error: {
    e10000: "  .",
    e10001: "  ",
    e102: "     ",
    e112: "         "
  }
};
const bitbox02Interact$4 = {
  followInstructions: "        BitBox02  ."
};
const bitbox02Settings$4 = {
  deviceName: {
    current: "  ",
    input: " BitBox02",
    title: "  BitBo02"
  }
};
const bitbox02Wizard$4 = {
  attestationFailed: "                        .        .",
  backup: {
    point1: "      microSD  ",
    point2: "      ",
    restoreText: "     !",
    text1: "  BitBox02         .         .     microSD   BitBo02      .",
    text2: "                .",
    text3: "      microSD      <strong> </strong>  .  microSD   .          BitBox02  ",
    userConfirmation1: "          .",
    userConfirmation2: "    .                .",
    userConfirmation3: "  Bitbox02                .",
    userConfirmation4: "      BitBox02               "
  },
  create: {
    button: "    ",
    info: "         BitBox        : ",
    inputTitle: "  ",
    point1: "  ",
    point2: "    ",
    point3: " ",
    text: "        !"
  },
  initialize: {
    passwordText: "       .            BitBox   .",
    passwordTitle: "   BitBox ",
    text: "  BitBox02   !        .                 .         microSD  BitBox02    ",
    tip: "        .",
    title: "  BitBox "
  },
  insertSDCard: "<strong>       microSD  BitBox02   .</strong>",
  pairing: {
    failed: "  .  BitBox02     .",
    paired: "           .              .",
    title: "    ",
    unpaired: "BitBox02    .                  .          BitBox02              ."
  },
  restoreFromMnemonic: {
    failed: "         ."
  },
  stepBackup: {
    beforeProceed: "          :",
    createBackup: "     microSD    ."
  },
  stepBackupSuccess: {
    fundsSafe: "          :",
    title: "   "
  },
  stepConnected: {
    unlock: " BitBox02       ."
  },
  stepCreate: {
    nameLabel: " BitBox02",
    namePlaceholder: "BitBox02 ",
    title: " BitBox02   ",
    toastMicroSD: "      microSD   BitBox02  ."
  },
  stepCreateSuccess: {
    removeMicroSD: "  microSD   BitBox02            .",
    success: "        ."
  },
  stepPassword: {
    title: " BitBox02   ",
    useControls: "        BitBox02  ."
  },
  stepUninitialized: {
    create: "   BitBox02    .",
    restore: "           .",
    restoreMicroSD: "   microSD",
    restoreMnemonic: "   ",
    title: "BitBox02    "
  },
  success: {
    text: "!  BitBox02    .\n\n         BitBoxApp                  .",
    title: "   !"
  }
};
const blink$4 = {
  button: " "
};
const bootloader$4 = {
  button: "  ",
  progress: ": {{progress}}%",
  success: "   !      .      ."
};
const button$9 = {
  abort: "",
  back: "",
  changepin: "  ",
  check: " ",
  "continue": "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "   ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: " ",
  upgrade: ""
};
const changePin$4 = {
  newTitle: "  ",
  oldLabel: "   "
};
const checkSDcard$4 = "  microSD";
const clickHere$4 = "  .";
const confirm$6 = {
  abortInfo: "  ",
  abortInfoRedText: "",
  approveInfo: "4    ",
  approveInfoGreenText: " ",
  info: " BitBox",
  infoWhenPaired: "      BitBox"
};
const confirmOnDevice$4 = "      .";
const device$4 = {
  appUpradeRequired: "BitBox      .        ."
};
const deviceLock$4 = {
  button: "      (2FA)",
  condition1: "  ",
  condition2: "      ",
  condition3: "           .      2     .",
  confirm: "      (2FA)",
  title: "      (2FA)"
};
const deviceSettings$4 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: " ",
    upToDate: "   ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": " ",
      label: " microSD",
      "true": " "
    },
    title: " "
  },
  loading: "  ...",
  pairing: {
    lock: {
      "false": "",
      label: "    (2FA)",
      "true": ""
    },
    mobile: {
      "false": " ",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": ""
    },
    title: ""
  },
  secrets: {
    manageBackups: "  ",
    title: ""
  }
};
const deviceTampered$4 = " BitBox                   . Shift              ";
const dialog$5 = {
  cancel: "",
  confirm: ""
};
const fiat$6 = {
  "default": " ",
  setDefault: "{{code}}      ",
  title: ""
};
const footer$6 = {
  appVersion: " :"
};
const genericError$4 = "              .";
const goal$4 = {
  buttons: {
    create: "     ",
    restore: "    "
  },
  paragraph: "        :",
  step: {
    "1": {
      title: " "
    },
    "2": {
      description: "     ",
      title: ""
    },
    "3-create": {
      description: "     ",
      title: " "
    },
    "3-restore": {
      description: "  ",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$5 = {
  accountDescription: {
    text: '               .    ""       . ',
    title: "          "
  },
  accountFiat: {
    text: "                             .",
    title: "        "
  },
  accountIncomingBalance: {
    text: "                  .",
    title: "  "
  },
  accountInfo: {
    xpub: {
      text: "                      .\n              Electrum  Sentinel   .",
      title: "    "
    }
  },
  accountRates: {
    text: "",
    title: "    "
  },
  accountReload: {
    text: "        .",
    title: "       "
  },
  accountSendDisabled: {
    text: "            .",
    title: "     {{unit}}  "
  },
  accountTransactionAttributesBTC: {
    text: " :       .              .\n:                .\n:  Segwit              .                .                  .",
    title: "     "
  },
  accountTransactionAttributesGeneric: {
    text: ":             .                    .                .                       -   .\n :                  .\n:                     .         .",
    title: "         "
  },
  accountTransactionConfirmation: {
    text: "            .",
    title: "   "
  },
  accountTransactionLabel: {
    text: "                  .",
    title: "        "
  },
  accountTransactionTime: {
    text: "      .",
    title: "     "
  },
  appendix: {
    link: "  ",
    text: " "
  },
  backups: {
    check: {
      text: "                     .         .              .",
      title: '" " '
    },
    encrypt: {
      text: "             .",
      title: "      "
    },
    howOften: {
      text: "              .           microSD                 microSD    .\n         .                   .",
      title: "       "
    },
    whatIsABackup: {
      text: "         SD .            .",
      title: " "
    }
  },
  backupsBB02: {
    check: {
      text: '"  "                    .',
      title: "'  ' "
    },
    encrypt: {
      text: '.     microSD                 .                       " "  .',
      title: "       "
    },
    whatIsABackup: {
      text: "        microSD .",
      title: "  "
    }
  },
  bitbox: {
    "2FA": {
      text: "                     .                               BitBox   .                    .\n\n       2               .       SD         .    BitBox           .",
      title: "    (2FA)    "
    },
    disable2FA: {
      text: '            BitBox        .        SD            .  " "   .           "  "   .       ""                 .',
      title: "         "
    },
    ejectBitbox: {
      text: "   BitBox          .",
      title: "   BitBox   "
    },
    ejectSD: {
      text: "    microSD   BitBox              .",
      title: "    microSD   "
    },
    hiddenWallet: {
      text: "                              .                     .",
      title: "   "
    },
    legacyHiddenWallet: {
      text: "       (      BitBox                )  BitBox           .",
      title: "      legacy    "
    },
    pairing: {
      text: "       IOS  Android   QR       .            .          .",
      title: "       "
    }
  },
  receive: {
    address: {
      text: "          .          .",
      title: "     "
    },
    addressChange: {
      text: "                      .          .",
      title: "     "
    },
    howVerify: {
      text: " BitBox01   BitBox             .                 .\n BitBox02                 .",
      title: "          "
    },
    why20: {
      text: '                            .                       .          20           .  " "   20         .  20       .',
      title: "  20 "
    },
    whyMany: {
      text: "              .              .         .         .     seed     .",
      title: "     "
    },
    whyVerify: {
      text: "         BitBox                .                  .       BitBox                    QR     .  BitBox02          BitBox02",
      title: "      "
    }
  },
  send: {
    fee: {
      text: "          .        Bitcoin            .             .\n:   (    Bitcoin    Litecoin)\n:   (    Bitcoin    Litecoin)\n:   (    Bitcoin    Litecoin)\n:   (    Bitcoin    Litecoin)\n(   Bitcoin         (.   Litecoin)                 .)",
      title: "     "
    },
    priority: {
      text: "              .",
      title: "  "
    },
    revert: {
      text: "        (     )    .        ( )   .\n         (  )          .",
      title: "     "
    },
    whyFee: {
      text: "          .              .\n      .               (       )                 .                     .",
      title: "     "
    }
  },
  "settings-electrum": {
    what: {
      text: "     Shift             .",
      title: " "
    }
  },
  settings: {
    servers: {
      text: "    Shift Crypto                .           CoinGecko   . (             .)\n:    Ethereum  ERC20    API  Etherscan.io   .",
      title: "       "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: "               .",
      title: "           "
    },
    reset: {
      text: "                  .",
      title: "    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "         .           .                .",
      title: "BitBox01    "
    },
    getDevice: {
      link: {
        text: " BitBox"
      },
      text: "   BitBox       :",
      title: "     "
    },
    internet: {
      text: "                .",
      title: "      "
    },
    lostDevice: {
      link: {
        text: "  "
      },
      text: "        BitBox        .",
      title: "       "
    },
    useWithoutDevice: {
      text: "        .",
      title: "          "
    },
    welcome: {
      text: "          Shift Crypto      .                  .             .",
      title: "  BitBox  !"
    }
  }
};
const headerssync$4 = {
  blocksSynced: "{{blocks}}     "
};
const hiddenWallet$4 = {
  info1HTML: "                     +     .",
  info2HTML: "                 .       <strong></strong>          .",
  passwordLabel: "   ",
  passwordPlaceholder: "       ",
  pinLabel: "   ",
  pinRepeatLabel: "      ",
  pinRepeatPlaceholder: "       ",
  success: "       BitBox          ."
};
const initialize$4 = {
  create: "     ",
  creating: "   ...",
  error: {
    e102: "       ."
  },
  info: {
    description1: "         BitBox      .",
    description2: "       .     .",
    description3: "                   .",
    subtitle: "        ",
    title: "  "
  },
  input: {
    label: " ",
    labelRepeat: "     ",
    placeholderRepeat: "     "
  }
};
const invalidFormat$4 = " ";
const language$5 = {
  title: "     "
};
const legacyhiddenwallet$4 = {
  disable: "     legacy ",
  enable: "    legacy ",
  successDisable: "    legacy    ",
  successEnable: "    legacy   . BitBox                legacy   ."
};
const loading$4 = "  ";
const notification$4 = {
  newTxs_one: "{{count}}   : {{accountName}}"
};
const pairing$4 = {
  aborted: {
    text: "      .",
    title: " "
  },
  button: "   ",
  confirm: "    BitBox                      ",
  connectOnly: {
    button: "   ",
    title: "              ."
  },
  error: {
    text: "      ",
    title: ""
  },
  reconnectOnly: {
    button: "    "
  },
  start: {
    hideAppQRCode: "   QR",
    revealAppQRCode: "  QR",
    step1: "          QR   App Store   Google Play         .",
    step2: '            "Digital Bitbox 2FA"     iOS  Android  :'
  },
  started: {
    text: "        .",
    title: ""
  },
  success: {
    text: "      BitBox       !",
    title: ""
  },
  timeout: {
    text: "        .            .",
    title: ""
  },
  title: "  "
};
const password$4 = {
  show: " {{label}}",
  warning: {
    caps: ":  Caps lock ()  ",
    paste: '  " {{label}}"   .'
  }
};
const random$5 = {
  button: "  ",
  description: "BitBox    {{bits}}-    :"
};
const receive$6 = {
  label: " ",
  onlyThisCoin: {
    description: "           .                .",
    warning: "     {{coinName}}      ."
  },
  showFull: "      ",
  title: " {{accountName}}",
  verify: "  ",
  verifyBitBox01: "       ",
  verifyBitBox02: "   BitBox02  ",
  verifyInstruction: "              .",
  warning: {
    secureOutput: " BitBox             .       ' ' ."
  }
};
const reset$4 = {
  description: "       .       !",
  notReset: "     .",
  title: "  ",
  understand: "             ",
  understandBB02: "    "
};
const securityInformation$4 = {
  create: {
    description1: "                .",
    description2: "          .",
    description3: "         BitBox            .",
    description4: "             .      ",
    description5: "            microSD   .                     .",
    title: " "
  },
  restore: {
    description1: "       microSD          .",
    description2: "          .",
    description3: "       .            .                .",
    title: " "
  }
};
const seed$4 = {
  agreements: {
    "funds-access": "              ",
    "password-change": "     ",
    "password-required": "           "
  },
  create: "  ",
  creating: "   ",
  description: "  :",
  error: {
    e102: "      .",
    e200: "     microSD  BitBox              ."
  },
  info: {
    button: "  ",
    description1: " microSD   BitBox  ",
    description2: '        "  "   .',
    description3: "    microSD                  BitBox .",
    description4: "           .",
    title: "   "
  },
  password: {
    label: "  ",
    repeatPlaceholder: "     "
  },
  walletName: {
    label: "  "
  }
};
const seedRestore$4 = {
  error: {
    e200: "         microSD ."
  },
  info: {
    description1: " microSD   BitBox       .",
    description2: '        ""  ',
    description3: "     ",
    description4: "               .",
    title: "          "
  }
};
const send$6 = {
  abort: "  .",
  address: {
    label: " ",
    placeholder: "   "
  },
  amount: {
    label: "",
    placeholder: "   "
  },
  button: "  ",
  coincontrol: {
    address: "",
    outpoint: "",
    title: "  "
  },
  confirm: {
    "selected-coins": "   ",
    title: " ",
    total: ""
  },
  error: {
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: "  "
  },
  fee: {
    customPlaceholder: "   ",
    label: " ",
    placeholder: "  "
  },
  feeTarget: {
    description: {
      economy: "  (    Bitcoin    Litecoin)",
      high: "  (    Bitcoin    Litecoin)",
      low: "  (    Bitcoin    Litecoin)",
      normal: "  (    Bitcoin    Litecoin)"
    },
    estimate: "  :",
    label: {
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "   ..."
  },
  maximum: " ",
  scanQR: "  QR",
  signprogress: {
    description: "        .             {{steps}}   .",
    label: ""
  },
  success: "     .",
  title: " {{accountName}}",
  toggleCoinControl: "    "
};
const settings$5 = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "  {{host}}    .",
    checking: "",
    "download-cert": "    ",
    "remove-server": "",
    removeConfirm: " {{server}}",
    reset: "     ",
    resetConfirm: "              ",
    servers: " ",
    step1: "",
    "step1-text": "    ",
    step2: "",
    "step2-text": "        .               .",
    step3: "",
    "step3-text": "        .",
    step4: "",
    "step4-text": "                     .",
    "title-btc": " Bitcoin Electrum",
    "title-ltc": " Litecoin Electrum",
    "title-tbtc": "  Bitcoin Electrum ",
    "title-tltc": "  Litecoin Electrum "
  },
  expert: {
    coinControl: "    ",
    electrum: {
      title: "     "
    },
    setProxyAddress: "    ",
    title: " ",
    useProxy: "   Tor"
  },
  header: {
    home: ""
  },
  restart: "  BitBox        .",
  success: " BitBox          .",
  title: ""
};
const setup$4 = "  ";
const sidebar$5 = {
  device: " ",
  leave: "",
  settings: ""
};
const success$b = {
  create: {
    info1: "     microSD     .          .",
    info2: "         BitBox    .",
    info3: "                         .",
    summary: "         ",
    title: ""
  },
  getstarted: " ",
  restore: {
    summary: "        .",
    title: ""
  }
};
const transaction$5 = {
  confirmation: " ",
  explorer: " ",
  explorerTitle: "     ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  pending: "  ",
  size: "",
  vsize: " ",
  weight: ""
};
const transactions$4 = {
  placeholder: "   ."
};
const unknownError$4 = "     : {{errorMessage}}";
const unlock$4 = {
  description: "        .",
  error: {
    e109_normal: "   . {{remainingAttempts}}        .",
    e109_touch: "$t(unlock.error.e109_normal)          ",
    e113: "              4   ."
  },
  input: {
    label: " ",
    placeholder: "          "
  },
  unlocking: "     "
};
const upgradeFirmware$5 = {
  button: "  ",
  description: "       {{currentVersion}}   {{newVersion}}  ",
  label: "BitBox      .",
  locked: "    {{currentVersion}}   {{newVersion}}      .",
  title: "  ",
  unlocked: " bootloader  .    :",
  unlocked1: "Bitbox       ",
  unlocked2: "  BitBox      LED   ",
  unlocked3: "           "
};
const warning$a = {
  receivePairing: " BitBox            .          .",
  sdcard: " microSD    BitBox          .",
  sendPairing: " BitBox        .       "
};
const welcome$4 = {
  insertBitBox02: "  BitBox02      .",
  insertDevice: "       ",
  title: " "
};
const appTranslationsFA = {
  account: account$4,
  accountInfo: accountInfo$4,
  accountSummary: accountSummary$4,
  addAccount: addAccount$5,
  app: app$4,
  backup: backup$4,
  bb02Bootloader: bb02Bootloader$4,
  bitbox: bitbox$4,
  bitbox02Interact: bitbox02Interact$4,
  bitbox02Settings: bitbox02Settings$4,
  bitbox02Wizard: bitbox02Wizard$4,
  blink: blink$4,
  bootloader: bootloader$4,
  button: button$9,
  changePin: changePin$4,
  checkSDcard: checkSDcard$4,
  clickHere: clickHere$4,
  confirm: confirm$6,
  confirmOnDevice: confirmOnDevice$4,
  device: device$4,
  deviceLock: deviceLock$4,
  deviceSettings: deviceSettings$4,
  deviceTampered: deviceTampered$4,
  dialog: dialog$5,
  fiat: fiat$6,
  footer: footer$6,
  genericError: genericError$4,
  goal: goal$4,
  guide: guide$5,
  headerssync: headerssync$4,
  hiddenWallet: hiddenWallet$4,
  initialize: initialize$4,
  invalidFormat: invalidFormat$4,
  language: language$5,
  legacyhiddenwallet: legacyhiddenwallet$4,
  loading: loading$4,
  notification: notification$4,
  pairing: pairing$4,
  password: password$4,
  random: random$5,
  receive: receive$6,
  reset: reset$4,
  securityInformation: securityInformation$4,
  seed: seed$4,
  seedRestore: seedRestore$4,
  send: send$6,
  settings: settings$5,
  setup: setup$4,
  sidebar: sidebar$5,
  success: success$b,
  transaction: transaction$5,
  transactions: transactions$4,
  unknownError: unknownError$4,
  unlock: unlock$4,
  upgradeFirmware: upgradeFirmware$5,
  warning: warning$a,
  welcome: welcome$4
};
const account$3 = {
  disconnect: "Conexin perdida. Reintentando... ",
  "export": "Exportar ",
  exportTransactions: "Exportar transacciones a la carpeta de descargas como archivo CSV",
  fatalError: "Ha habido un error inesperado.",
  incoming: "Entrante",
  initializing: "Obteniendo informacin de la blockchain ...",
  insuranceExpired: "<strong>Cuenta que ya no est asegurada</strong>\n\nEl plan de seguro de esta cuenta ha sido modificado.\nConsulta la pgina de seguros para obtener ms informacin.",
  insured: "Cuenta asegurada",
  maybeProxyError: "Tor Proxy activado. Asegrese de que su Tor proxy est funcionando correctamente, o desactive la configuracin del proxy.",
  reconnecting: "Conexin perdida, reconectando...",
  syncedAddressesCount: "Escaneado {{count}} direcciones",
  uncoveredFunds: "Tiene monedas en los siguientes tipos de direccin no cubiertos de su  <strong>{{name}}</strong> cuenta: {{uncovered}}. Dado que la cuenta est asegurada, slo las monedas recibidas a travs del <strong> Segwit nativo </strong> estn cubiertas. Las monedas con direcciones diferentes, aunque pertenezcan a la misma cuenta, no estn aseguradas.\nPor favor, mueve todas tus monedas de los tipos de direccin no soportados al tipo de direccin <strong> Segwit nativo</strong>, para que todas tus monedas en esta cuenta estn aseguradas.",
  uncoveredFundsLink: "Sigue esta gua sobre cmo mover tus monedas.",
  warning: "Atencin!"
};
const accountInfo$3 = {
  address: "Direccin",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Crypto",
    information: {
      looksEmpty: "Parece que esta cartera est vaca.",
      start: "Comience depositando algunas monedas en la cartera o comprando directamente a travs de la BitBoxApp."
    }
  },
  extendedPublicKey: "Clave pblica extendida",
  label: "Informacin de la cuenta",
  scriptType: "Tipo de script",
  title: "Informacin de la cuenta",
  verify: "Verificar en el dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Ver clave pblica extendida legacy P2PKH",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Native Segwit",
    "p2wpkh-p2sh": "Ver clave pblica extendida antiguo Segwit"
  },
  xpubTypeInfo: "Actualmente mostrando {{scriptType}} clave pblica extendida ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$3 = {
  availableBalance: "Saldo disponible",
  balance: "Saldo",
  exportSummary: "Resumen de cuentas de exportacin a la carpeta de descargas como archivo CSV",
  fiatBalance: "Saldo de Fiat",
  name: "Nombre de cuenta",
  noAccount: "No hay cuentas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Mi portfolio",
  total: "Total",
  transactionHistory: "Historial de operaciones"
};
const addAccount$4 = {
  chooseName: {
    nextButton: "Aadir cuenta",
    step: "Nombre de la cuenta",
    title: "Nombre de su cuenta"
  },
  selectCoin: {
    nextButton: "Siguiente",
    step: "Elija moneda",
    title: "Elija cryptomoneda"
  },
  success: {
    addAnotherAccount: "Aadir otra cuenta",
    message: "<strong>{{accountName}}</strong> ha sido ahora aadida a sus cuentas.",
    nextButton: "Hecho",
    step: "Finalizado",
    title: "Cuenta aadida"
  },
  title: "Aadir cuenta"
};
const aopp$2 = {
  addressRequest: "{{host}} est solicitando una direccin de recepcin.",
  addressRequestWithLogo: "est solicitando una direccin de recepcin",
  banner: "Solicitud de direccin en curso. Conecte su dispositivo para continuar.",
  errorTitle: "Error durante la solicitud de direccin",
  labelAddress: "Direccin",
  labelMessage: "Mensaje",
  reverifyInfoText: "Verifique la direccin",
  signing: "Para proceder, firme el mensaje en su BitBox02",
  success: {
    message: "Proceder con {{host}}",
    title: "Direccin enviada con xito"
  },
  syncing: "Sincronizando la cuenta, por favor espere.",
  title: "Solicitud de direccin"
};
const app$3 = {
  upgrade: "Una nueva versin de esta aplicacin est disponible! Por favor actualiza desde {{current}} a {{version}}."
};
const auth$3 = {
  authButton: "Autentificar",
  title: "Por favor, autentifquese para continuar"
};
const backup$3 = {
  check: {
    checking: "Comprobando copia de seguridad ...",
    confirmTitle: "Comprobar la copia de seguridad",
    notOK: "Copia de seguridad NO coincide con el monedero.",
    ok: "Copia de seguridad coincide con el monedero.",
    password: {
      label: "Contrasea de recuperacin",
      placeholder: "Contrasea de recuperacin",
      showLabel: "contrasea de recuperacin"
    },
    success: "Copia de seguridad verificada con xito:",
    title: "Comprobar la copia de seguridad"
  },
  create: {
    alreadyExists: "Ya tienes una copia de seguridad vlida. Quieres volverla a crear?",
    fail: "La creacin de la copia de seguridad ha FALLADO!",
    info: "Por favor ingresa la contrasea de recuperacin del monedero actual para su verificacin.",
    name: {
      label: "Nombre de la copia de seguridad",
      placeholder: "Por favor pon el nombre de la copia de seguridad"
    },
    password: {
      label: "Contrasea de recuperacin",
      placeholder: "Por favor ingresa tu contrasea de recuperacin"
    },
    title: "Crea copia de seguridad",
    verificationFailed: "La contrasea de recuperacin NO COINCIDE con el monedero actual. La copia de seguridad ha sido creada. Por favor utiliza 'Comprueba copia de seguridad' para verificar tu contrasea de recuperacin nuevamente."
  },
  description: "Selecciona <strong>archivo de copia de seguridad del monedero</strong>",
  insert: "Por favor, inserta la tarjeta micro SD para administrar las copias de seguridad.",
  insertButton: "He insertado la tarjeta micro SD",
  list: "Tus copias de seguridad en la microSD",
  noBackups: "No hay copias de seguridad en esta tarjeta microSD.",
  restore: {
    confirmTitle: "Recupera copia de seguridad",
    error: {
      e200: "Tarjeta SD no encontrada",
      general: "Error restaurando copia de seguridad"
    },
    password: {
      label: "Contrasea de recuperacin o contrasea de recuperacin oculta",
      placeholder: "Contrasea de recuperacin",
      repeatPlaceholder: "Repita la contrasea de recuperacin",
      showLabel: "Contrasea de recuperacin"
    },
    restoring: "Restaurando copia de seguridad ...",
    selectedBackup: "<strong>{{backupName}}</strong> creada en {{createdDateTime}} ser restaurada.",
    title: "Restaurar",
    understand: "Entiendo que una contrasea de recuperacin incorrecta crear un monedero diferente"
  },
  showMnemonic: {
    description: "Se le presentarn sus palabras de recuperacin, que constituyen una copia de seguridad de su cartera. Escrbalas en un papel..\n\n<strong>No las almacenes digitalmente ni le tomes fotos.</strong>\n\n<strong>No las diga en voz alta.</strong>\n\n<strong>Esta copia de seguridad no est protegida por una contrasea.</strong>\n\nA continuacin, se le pedir que confirme cada palabra. ",
    title: "Muestra las claves de recuperacin",
    warning: "<strong>Nunca compartas tus palabras de recuperacin con nadie.</strong> Tus palabras de recuperacin dan acceso completo a tu billetera. Si alguien te pide tus palabras de recuperacin, es un estafador, no las compartas! "
  },
  title: "Administrar copias de seguridad"
};
const bb02Bootloader$3 = {
  abort: "No actualices - vuelve atrs",
  abort_noUpgrade: "Llvame atrs",
  advanced: {
    label: "Configuracin avanzada",
    toggleShowFirmwareHash: "Mostrar el hash del firmware en cada inicio"
  },
  flipscreen: "Gira la foto en la pantalla",
  orientation: "Est el dispositivo orientado de manera incorrecta?",
  success: "Actualizado con xito! Continuando en {{rebootSeconds}} segundos...",
  success_install: "Instalacin satisfactoria! Contina en {{rebootSeconds}} segundos..."
};
const bitbox$3 = {
  error: {
    e10000: "Contrasea del dispositivo actual incorrecta.",
    e10001: "Error al reemplazar la contrasea del dispositivo",
    e102: "La contrasea debe contener al menos 4 caracteres.",
    e112: "La contrasea oculta del dispositivo no puede ser la misma que la contrasea principal del dispositivo."
  }
};
const bitbox02Interact$3 = {
  confirmDate: "Confirma la fecha de hoy en tu BitBox02",
  confirmDateText: "Esta fecha se utilizar para crear tu copia de seguridad.",
  confirmName: "Confirma el nombre en tu BitBox02",
  confirmWords: "Escriba la {{amount}} de palabras recuperacin de su BitBox02",
  confirmWordsText: "Despus el BitBox02 te pedir que confirmes cada palabra para verificar que la copia de seguridad es correcta.",
  followInstructions: "Por favor, sigue las instrucciones en tu BitBox02",
  followInstructionsMnemonic: "Sigue las instrucciones de tu BitBox02 para introducir las palabras de recuperacin de tu copia de seguridad y restaurar tu billetera.",
  followInstructionsMnemonicTitle: "Restaurar desde las palabras de recuperacin"
};
const bitbox02Settings$3 = {
  deviceName: {
    current: "Nombre del dispositivo actual",
    error: "No se ha podido establecer el nombre del dispositivo",
    error_104: "La confirmacin del nombre del dispositivo fue abortada en el dispositivo.",
    input: "Nombre de la BitBox02",
    placeholder: "Nuevo nombre del dispositivo",
    title: "Establece el nombre de la BitBox02"
  },
  gotoStartupSettings: {
    description: "Esto reiniciar tu BitBox02 y entrar en la configuracin de inicio.",
    title: "Ir a configuracin de inicio"
  }
};
const bitbox02Wizard$3 = {
  advanced: {
    button: "Opciones avanzadas",
    outOfDate: "Firmware obsoleto para esta funcin",
    seed12WordInfo: "Tenga en cuenta que el nmero de palabras no se puede cambiar despus de crear la billetera.",
    seed12WordLabel: "Crear semilla de 12 palabras en lugar de 24 palabras",
    seed12WordText: "Predeterminadamente, la BitBox02 utiliza una semilla de 24 palabras. Ambas longitudes de semilla son seguras contra la fuerza bruta en la prctica. Algunos usuarios pueden preferir la conveniencia de la semilla de 12 palabras.",
    skipSDCardLabel: "Omitir la copia de seguridad de la tarjeta microSD y escribir las palabras de recuperacin en su lugar",
    skipSDCardText: "Siempre tienes la opcin de crear una copia de seguridad de la tarjeta microSD o escribir tus palabras de recuperacin despus de la configuracin. Esto se puede hacer desde los ajustes.",
    title: "Opciones avanzadas de copia de seguridad"
  },
  attestationFailed: "La comprobacin genuina del dispositivo ha fallado, que puede ser debido al reinicio de la aplicacin mientras el dispositivo estaba esperando la interaccin por parte del usuario. Por favor conecte de nuevo y intntelo otra vez. Por favor contacte con support@bitbox.swiss si el error persiste.",
  backup: {
    point1: "Selecciona una copia de seguridad de la tarjeta microSD",
    point2: "Establece una contrasea para su dispositivo",
    restoreText: "Ok, restablezcamos una copia de seguridad!",
    text1: "Genial, has establecido la contrasea de tu BitBox02 y tu billetera se ha creado. Ahora es momento de crear tu primera copia de seguridad (backup). Por favor asegrate de que tu tarjeta microSD se haya introducido en tu BitBox02 y continua.",
    text2: "Por favor sigue las instrucciones que aparecen en la pantalla de tu dispositivo para crear la copia de seguridad. ",
    text3: "Despus de que tu copia de seguridad se haya creado, por favor extrae la tarjeta microSD y gurdala en un <strong>lugar seguro</strong>. El contenido de la tarjeta microSD no est protegido con contrasea. Nunca la insertes en ningn otro dispositivo que no sea tu BitBox02. ",
    userConfirmation1: "Debo guardar mi copia de seguridad en un lugar seguro.",
    userConfirmation2: "Mi copia de seguridad no est protegida por contrasea. Cualquiera con acceso a ella tiene acceso a mi billetera.",
    userConfirmation3: "Si pierdo o dao mi BitBox02, la nica forma de recuperar mis fondos es recuperar mi billetera desde mi copia de seguridad.",
    userConfirmation4: "En caso de perder o daar tanto mi copia de seguridad como mi BitBox02, mis fondos se habrn perdido.",
    userConfirmation5: "No debera insertar mi copia de seguridad de la tarjeta microSD en el ordenador, telfono, impresora o en ningn otro dispositivo que no sea BitBox02.",
    userConfirmation5mnemonic: "No debo poner mis palabras de recuperacin en un computador, telfono, impresora o cualquier otro dispositivo que no sea un BitBox02."
  },
  create: {
    button: "Dale un nombre al dispositivo y continua",
    info: "Aqu estn los pasos bsicos que seguirs para instalar tu BitBox:",
    inputTitle: "Nombre del monedero",
    point1: "Dale un nombre a tu dispositivo",
    point2: "Establece una contrasea para su dispositivo",
    point3: "Crea una copia de seguridad",
    text: "Ok, creemos un nueva billetera!"
  },
  createBackupAborted: "Creacin de copia de seguridad abortada.",
  createBackupFailed: "Creacin de copia de seguridad fallida, vuelve a intentarlo.",
  initialize: {
    passwordText: "Ahora establezcamos una contrasea para tu dispositivo. Utiliza los controles en tu BitBox para introducir y escoger una contrasea.",
    passwordTitle: "Establece una contrasea para tu BitBox",
    text: "Tu BitBox02 se ha conectado con xito! Ahora vamos a iniciar tu dispositivo. Empecemos seleccionando crear una billetera nueva o restablecer una billetera desde una copia de seguridad existente.<strong>Por favor asegrate de tener una tarjeta microSD introducida en tu BitBox02</strong>",
    tip: "Te recomendamos que continuas en un entorno seguro.",
    title: "Inicia tu BitBox"
  },
  insertSDCard: "<strong>Por favor asegrate de haber introducido una tarjeta microSD en tu BitBox02.</strong>",
  noPasswordMatch: "Las contraseas no coinciden, por favor, vuelve a intentarlo.",
  pairing: {
    failed: "Conexin no confirmada. Por favor vuelve a conectar tu BitBox02.",
    paired: "Has confirmado el siguiente cdigo en tu dispositivo.  Por favor continua.",
    title: "Comprueba el cdigo de conexin.",
    unpaired: "Se ha detectado un BitBox02 no emparejado. Verifique que el cdigo de emparejamiento coincida con lo que se muestra en su BitBox02. "
  },
  restoreFromMnemonic: {
    e104: "Se cancel la restauracin desde las palabras de recuperacin.",
    failed: "El restablecimiento desde tu clave de recuperacin ha fallado, por favor vuelve a intentarlo."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, por favor lee estas importantes consideraciones de seguridad:",
    createBackup: "Ahora crears una copia de seguridad en tu tarjeta microSD.",
    createBackupMnemonic: "Ahora escribirs las palabras de recuperacin."
  },
  stepBackupSuccess: {
    fundsSafe: "Para mantener seguros tus fondos, por favor recuerda lo siguiente:",
    title: "Copia de seguridad restablecida!"
  },
  stepConnected: {
    unlock: "Introduce la contrasea de tu BitBox02 para desbloquearla."
  },
  stepCreate: {
    description: "Este nombre es utilizado como el nombre del dispositivo y el de la copia de seguridad.",
    error: {
      genericMessage: "Utilice letras, nmeros, smbolos bsicos y espacios. Mximo 30 caracteres.",
      invalidChars: "El nombre contiene caracteres no vlidos: {{invalidChars}}.",
      tooLong: "El nombre es demasiado largo."
    },
    nameLabel: "Nombre de la BitBox02",
    namePlaceholder: "Mi BitBox02",
    title: "Selecciona el nombre de la BitBox02",
    toastMicroSD: "Por favor, inserte su tarjeta microSD en su BitBox02 que se utilizar para almacenar una copia de seguridad de la billetera."
  },
  stepCreateSuccess: {
    removeMicroSD: "Por favor, extrae la tarjeta microSD de tu BitBox02 y gurdala en un lugar seguro. ",
    storeMnemonic: "Guarde sus palabras de recuperacin en un lugar seguro",
    success: "Ha creado su copia de seguridad con xito."
  },
  stepInsertSD: {
    insertSDCard: "Por favor, introduce una microSD en tu BitBox02 para continuar.",
    insertSDcardTitle: "Introduce la tarjeta microSD"
  },
  stepPassword: {
    e104: "Se cancel la configuracin de la contrasea.",
    title: "Establece la contrasea de tu BitBox02",
    useControls: "Utiliza los controles de tu BitBox02 para establecer la contrasea."
  },
  stepUninitialized: {
    create: "Quiero configurar una nueva BitBox02.",
    restore: "Quiero recuperar mi billetera desde una copia de seguridad.",
    restoreMicroSD: "Recupera desde una tarjeta microSD",
    restoreMnemonic: "Restaurar desde las palabras de recuperacin",
    title: "Instala tu BitBox02"
  },
  success: {
    text: "Perfecto! Tu BitBox02 est lista para ser usada. \n\nPara ms informacin sobre cmo usar la BitBoxApp, por favor utiliza la gua in-app haciendo clic en el signo de interrogacin de la esquina superior derecha. ",
    title: "Estas preparado para usar la billetera BitBox."
  }
};
const bitsurance$2 = {
  dashboard: {
    active: "Pliza de seguro activa",
    button: "Asegura una nueva cuenta",
    canceled: "Cancelado",
    coverage: "Cobertura mxima",
    inactive: "Inactivo",
    processing: "Procesando ",
    refused: "Rechazado",
    supportLink: "Gestionar el contrato",
    title: "Cuentas aseguradas",
    waitpayment: "A la espera del pago"
  },
  detect: {
    button: "Comprobar el seguro existente",
    insured: "Cuenta asegurada detectada:",
    notInsured: "No se han detectado cuentas aseguradas. Si est seguro de que tiene una cuenta asegurada, asegrese de que tiene conectada la billetera correcta.",
    text: "Si ya ests suscrito a Bitsurance, la BitBoxApp puede sincronizar automticamente tu cobertura de seguro existente.",
    title: "Ya est asegurado?"
  },
  insure: {
    button: "Consultar disponibilidad y precios",
    faq: "Ms informacin en Preguntas frecuentes sobre Bitsurance",
    listItem1: "Robo",
    listItem2: "Extorsin (por ejemplo, ataque con una llave inglesa de 5 dlares)",
    listItem3: "Destruction due to fire, water or natural disasters",
    month: "mes",
    text: "Asegura tu BitBox02 y hasta 100.000 euros en bitcoins contra",
    text2: "Los planes de seguro cuestan a partir de 30 euros al ao (2,50 euros al mes). Puede obtener ms informacin sobre Bitsurance y sus ofertas de seguros exactas en la pgina web",
    text3: "Actualmente disponible en Alemania y en otras regiones.",
    title: "Comienza"
  },
  intro: {
    link: "Sitio web de Bitsurance",
    text1: "BitBox trabaja con Bitsurance para aadir una capa adicional de proteccin para tu bitcoin. Mientras que la BitBox02 mantiene tus fondos seguros, Bitsurance cubre las amenazas en casa que no se pueden mitigar solo con tecnologa, como robos, extorsiones o la destruccin de la propia billetera fsica."
  },
  terms: {
    link: "Poltica de privacidad de Bitsurance",
    text1: "Bitsurance es un servicio externo independiente. Para preguntas sobre sus ofertas y reclamaciones de seguros, ponte en contacto directamente con Bitsurance.",
    text2: "Actualmente, el seguro est disponible en Alemania y en otras regiones.",
    text3: "La cobertura mxima de Bitcoin disponible actualmente es de 100.000 euros por persona. Se prevn importes ms elevados en el futuro.",
    text4: "La informacin personal y la clave pblica ampliada de su cuenta asegurada forman parte de la pliza de seguro y se compartirn con Bitsurance y el proveedor de seguros.",
    text5: "Para ms informacin sobre privacidad, consulte la"
  },
  title: "Seguro"
};
const bitsuranceAccount$2 = {
  errorNoXpub: "Error: No se ha podido obtener el xpub de la cuenta.",
  noAccount: "No hay cuentas que puedan asegurarse.",
  select: "Seleccionar cuenta",
  title: "Seguro"
};
const blink$3 = {
  button: "Parpadeo"
};
const bootloader$3 = {
  button: "Actualiza ahora el firmware",
  button_install: "Instalar el nuevo firmware ahora",
  progress: "Actualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Actualizacin completada! Por favor, vuelva a conectar el dispositivo. Esta vez, no toque el botn."
};
const button$8 = {
  abort: "Cancel",
  back: "Atrs",
  buy: "Compra",
  changepin: "Cambia contrasea del dispositivo",
  check: "Comprobar la copia de seguridad",
  "continue": "Continua",
  copy: "Copia",
  create: "Crea",
  dismiss: "Descartar",
  done: "Hecho",
  download: "Descarga",
  hiddenwallet: "Crea el monedero oculto",
  next: "Siguiente",
  ok: "OK",
  previous: "Anterior",
  receive: "Recibe",
  restore: "Restaurar",
  select: "Selecciona",
  send: "Enva",
  unlock: "Desbloquea",
  update: "Actualiza",
  upgrade: "Actualizar"
};
const buy$4 = {
  exchange: {
    bankTransfer: "Transferencia bancaria",
    bestDeal: "La mejor oferta",
    creditCard: "Tarjeta de crdito",
    fast: "Rpido",
    fee: "tarifa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferencia bancaria: {{fee}}%%.",
          creditDebitCard: "Tarjeta de crdito/dbito: {{fee}}%%.",
          learnMore: "Ms informacin sobre Moonpay",
          title: "Tasas"
        },
        fullCurrenciesList: "Consulte aqu la lista completa de monedas",
        payment: {
          asteriskText: "* No disponible para residentes en EE.UU.",
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            pix: "PIX (transacciones BR slo en Brasil)",
            sepa: "SEPA y SEPA Instant (slo transacciones en euros en pases SEPA)",
            uk: "Pagos rpidos en el Reino Unido (transacciones en GBP slo en el Reino Unido)"
          },
          creditDebitCard: "Tarjeta de crdito/dbito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa y Maestro"
          },
          learnMore: "Ver ms detalles sobre los mtodos de pago",
          title: "Formas de pago"
        },
        supportedCurrencies: "Compatible con las principales monedas fiduciarias: USD, EUR, CHF y ms."
      },
      pocket: {
        fees: {
          info: "Transferencia bancaria: {{fee}}% ",
          title: "Tasas"
        },
        learnMore: "Ms informacin sobre Pocket",
        payment: {
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            sepa: "SEPA y SEPA Instant (slo transacciones en euros en pases SEPA)",
            sic: "Swiss Interbank Clearing (transacciones en CHF solo en CH/LI)",
            uk: "UK Faster Payments (transacciones en GBP slo en el Reino Unido)"
          },
          bankTransferReccuring: "Cmo configurar compras recurrentes con una orden permanente? ",
          title: "Formas de pago"
        },
        supportedCurrencies: "Admite monedas europeas: EUR, GBP y CHF. ",
        verification: {
          info: "Solo requiere verificacin de identidad por encima de los puntos de inicio diarios y anuales. ",
          link: "Encuentre los puntos de inicio actuales aqu ",
          title: "Verificacin de identidad "
        }
      },
      region: {
        title: "Seleccione la regin en la que est registrada su cuenta bancaria para ver las opciones disponibles."
      }
    },
    noExchanges: "Lo sentimos, no hay intercambios disponibles en esta regin.",
    region: "Regin",
    selectRegion: "No especificado",
    title: "Comprar {{nombre}}"
  },
  info: {
    "continue": "Acepta y continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nos asociamos con MoonPay para ofrecerte una forma sencilla de comprar {{name}} directamente con BitBoxApp. Con unos pocos clics.  ",
        "MoonPay es una plataforma que hace fcil y rpida la compra de {{name}} en ms de 160 pases."
      ],
      payment: {
        details: "Puedes comprar {{name}} inmediatamente a travs de MoonPay con los siguientes mtodos de pago. Los pedidos con tarjeta de crdito o dbito son inmediatos y prcticos, pero ms caros debido al mayor riesgo de retrocesos de cargos a tarjetas. Recomendamos utilizar la opcin de transferencia bancaria para grandes cantidades. La tarifa mnima es de 4 EUR.",
        footnote: "Tenga en cuenta que los tipos de cambio de MoonPay pueden diferenciarse de los utilizados en BitBoxApp, lo que se nota en cantidades ligeramente diferentes.",
        table: {
          "1_description": "Tarifa baja, puede tardar 3 das laborales",
          "1_method": "Transferencias bancarias (SEPA)",
          "2_description": "Tarifas altas pero inmediato y rpido",
          "2_method": "Tarjetas de crdito & dbito",
          description: "Descripcin",
          fee: "Comisin",
          method: "Metodo"
        },
        title: "Mtodos de pago y tarifas"
      },
      privacyPolicy: "MoonPay poltica de privacidad",
      protection: {
        description: "BitBoxApp no recopila ningn dato al comprar {{name}}, los fondos entrantes se tratan como una transaccin normal. MoonPay necesita recoger algunos datos personales para operar. Su Poltica de privacidad explica en detalle cmo se manejan esos datos.",
        descriptionGeneric: "BitBoxApp no recopila ningn dato cuando se compra {{name}}, los fondos entrantes se tratan como una transaccin normal. Sin embargo, las bolsas asociadas necesitan recopilar cierta informacin para operar. Consulta sus respectivas polticas de privacidad para ver con ms detalle cmo se gestionan los datos.",
        title: "Proteccin de Datos"
      },
      security: {
        description: "Cuando compras {{name}} por MoonPay, utilizas un servicio externo. Este servicio est fuera del alcance de la modelacin de riesgos de seguridad BitBox02 y depende de la seguridad y proteccin del entorno en el que se ejecuta el software BitBoxApp.\n\n",
        descriptionGeneric: "Cuando compras {{name}} a travs de una casa de cambio asociada, ests utilizando un servicio externo. Este servicio est fuera del alcance del modelo de amenazas de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp.",
        link: "Modelacin de riesgos",
        title: "Modelo de seguridad"
      },
      title: "Bienvenido. Estas en el sitio correcto para comprar {{name}}"
    },
    next: "Siguiente",
    selectLabel: "Elige tu cuenta",
    selectPlaceholder: "Seleccione una moneda",
    skip: "No mostrar de nuevo",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Poltica de privacidad de Pocket",
      p1: "La BitBoxApp no recoge ningn dato al comprar bitcoin, los fondos entrantes se tratan como una transaccin normal. Pocket necesita recoger algunos datos personales para funcionar. Su Poltica de Privacidad explica en detalle cmo se manejan esos datos.",
      title: "Proteccin de datos"
    },
    kyc: {
      link: "Preguntas ms frecuentes de Pocket",
      p1: "Pocket intenta reducir al mnimo los requisitos de identificacin. Para compras inferiores a 950 EUR (1000 CHF) al da, no se requieren documentos adicionales. Para compras superiores a esta cantidad, tendrs que programar una llamada con Pocket para completar el proceso KYC/AML necesario.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puedes comprar bitcoin instantneamente con Pocket a travs de una transferencia bancaria SEPA. La comisin es del 1,5% y el bitcoin se deposita en su BitBox lo antes posible despus de que Pocket reciba la transferencia bancaria (normalmente en el mismo da).",
      p2: "Tenga en cuenta que los tipos de cambio de Pocket pueden diferir de los utilizados en la BitBoxApp, dando lugar a importes ligeramente diferentes.",
      title: "Formas de pago y tasas"
    },
    previousTransactions: "El historial de transacciones de esta cuenta no est vaco. Compartir esta cuenta har que todas sus transacciones pasadas y futuras sean visibles para Pocket. Proceder de todos modos?",
    security: {
      link: "Modelo de amenazas a la seguridad BitBox02",
      p1: "Cuando compras bitcoin a travs de Pocket, ests utilizando un servicio externo. Este servicio est fuera del alcance del modelo de amenaza de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp. Sin embargo, trabajamos juntos para mejorar la seguridad utilizando un mecanismo de autenticacin de dos factores para verificar la direccin a la que ests recibiendo.",
      title: "Modelo de seguridad"
    },
    usedAddress: "La direccin {{address}} ya ha sido utilizada, por favor comience de nuevo con una nueva direccin.",
    verifyBitBox02: "Compruebe que la direccin que ha recibido por correo electrnico coincide con la que aparece en su Bitbox. Si es posible, debera abrir el correo electrnico en un segundo dispositivo para mayor seguridad. ",
    welcome: {
      p1: "Nos asociamos con Pocket para ofrecerte una forma sencilla de comprar bitcoin directamente dentro de la BitBoxApp. Es slo un par de clics.",
      p2: "Pocket es una plataforma suiza que facilita y agiliza la compra de bitcoins en la mayor parte de Europa (en cualquier lugar donde se admitan transferencias bancarias SEPA).",
      p3: "Con Pocket, tambin puede hacer compras peridicas a travs de rdenes bancarias permanentes, por lo que puede hacer DCA (dollar-cost averaging) con facilidad.",
      title: "Bienvenido a su ventanilla nica para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
};
const changePin$3 = {
  newTitle: "Nueva contrasea del dispositivo",
  oldLabel: "Contrasea actual del dispositivo"
};
const chart$4 = {
  dataMissing: "Recopilando tus datos histricos. Permanece atento.",
  dataOldTimestamp: "Actualizacin de los tipos de cambio histricos. El grfico no muestra datos despus de {{time}}.",
  dataUpdating: "actualizando datos",
  filter: {
    all: "Todo",
    month: "Mes",
    week: "Semana",
    year: "Ao"
  }
};
const checkSDcard$3 = "comprobando tarjeta micro SD";
const clickHere$3 = "Haz clic aqu.";
const confirm$5 = {
  abortInfo: "Toque para ",
  abortInfoRedText: "Cancel",
  approveInfo: "Mantenga 4+ segundos para ",
  approveInfoGreenText: "confirma",
  info: "Continua en tu Bitbox",
  infoWhenPaired: "Primero en el mvil sincronizado y luego tu BitBox"
};
const confirmOnDevice$3 = "Por favor confirma en tu dispositivo.";
const connectKeystore$3 = {
  promptNoName: "Por favor conecta tu BitBox02 para continuar",
  promptWithName: 'Por favor, conecta tu BitBox02 llamada "{{nombre}}" para continuar '
};
const darkmode$3 = {
  toggle: "Modo oscuro"
};
const device$3 = {
  appUpradeRequired: "Tu BitBox no es compatible con esta aplicacin de escritorio. Por favor descarga e instale la ltima versin.",
  keystoreConnected: "Billetera conectada"
};
const deviceLock$3 = {
  button: "Activa autorizacin de dos factores (2FA)",
  condition1: "Tienes una copia de seguridad?",
  condition2: "Funciona la verificacin de la aplicacin mvil?",
  condition3: "2FA DESACTIVA las copias de seguridad y la sincronizacin con las aplicaciones mviles. El dispositivo debe ser REINICIADO para salir de 2FA!",
  confirm: "Activa autorizacin de dos factores (2FA)",
  title: "Activa autorizacin de dos factores (2FA)"
};
const deviceSettings$3 = {
  backups: {
    manageBackups: {
      description: "Crea o verifica la copia de seguridad de tu tarjeta microSD."
    },
    showRecoveryWords: {
      description: "Mostrar y verificar palabras de recuperacin."
    },
    title: "Copias de seguridad"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp comprueba si tu dispositivo es autntico."
    },
    deviceName: {
      description: "Cambia el nombre de tu dispositivo."
    },
    rootFingerprint: {
      description: "La huella raz es un identificador nico para la billetera actualmente en uso. Puede ayudarte a distinguir entre diferentes billeteras si utilizas frases de contrasea."
    },
    securechip: {
      description: "El modelo del chip seguro."
    },
    title: "Informacin del dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Restablece tu dispositivo a los valores de fbrica. Esto borra la billetera de tu BitBox02!",
      title: "Restablecimiento de fbrica"
    },
    goToStartupSettings: {
      description: "Entra en el bootloader de la BitBox02. Puedes activar el hash del firmware desde aqu."
    },
    passphrase: {
      description: "",
      title: "Contrasea"
    }
  },
  firmware: {
    firmwareVersion: "Versin del firmware",
    newVersion: {
      label: "Versin disponible"
    },
    title: "Firmware",
    upToDate: "Tu dispositivo est actualizado.",
    upgradeAvailable: "Nueva actualizacin disponible",
    version: {
      label: "Versin"
    }
  },
  hardware: {
    attestation: {
      "false": "Error en la comprobacin de autenticidad",
      label: "Comprobacin de autenticidad",
      "true": "Su BitBox02 es autntico"
    },
    sdcard: {
      "false": "No insertado",
      label: "Tarjeta micro SD",
      "true": "Insertado"
    },
    securechip: "Chip de seguridad",
    title: "Hardware"
  },
  loading: "Recuperando informacin del dispositivo ...",
  pairing: {
    lock: {
      "false": "Desactivado",
      label: "Autorizacin de dos factores (2FA)",
      "true": "Activado"
    },
    mobile: {
      "false": "Cerrado",
      label: "Aplicacin mvil",
      "true": "Abre"
    },
    status: {
      "false": "No sincronizado",
      label: "Estado",
      "true": "Sincronizado"
    },
    title: "Sincronizacin"
  },
  secrets: {
    manageBackups: "Administrar copias de seguridad",
    title: "Seguridad"
  }
};
const deviceTampered$3 = "Tu BitBox ha sido suministrado con una contrasea de recuperacin? Si es as, detenga el proceso de configuracin y ponte en contacto con el servicio de asistencia inmediatamente. Shift nunca te dar una billetera confeccionado ni har recomendaciones de contrasea.";
const dialog$4 = {
  cancel: "Cancela",
  confirm: "Confirma",
  confirmTitle: "Confirmacin"
};
const error$4 = {
  accountAlreadyExists: "La cuenta ya existe.",
  accountLimitReached: "No se puede aadir la cuenta. El nmero mximo de cuentas para esta moneda ha sido alcanzado.",
  aoppCallback: "Ha habido un error entregando la direccin a{{host}}.",
  aoppInvalidRequest: "Solicitud invlida.",
  aoppNoAccounts: "No hay cuentas disponibles.",
  aoppSigningAborted: "Solicitud de propiedad de la direccin cancelada.",
  aoppUnknown: "Un error desconocido ha ocurrido.",
  aoppUnsupportedAsset: "El activo no es soportado.",
  aoppUnsupportedFormat: "No hay cuentas disponibles que soporten el formato de direcciones solicitado.",
  aoppUnsupportedKeystore: "El dispositivo conectado no puede firmar mensajes para este activo.",
  aoppVersion: "Versin desconocida.",
  keystoreTimeout: "La solicitud de su billetera ha caducado. Por favor, intntelo de nuevo.",
  wrongKeystore: "Se ha conectado una billetera incorrecta. Por favor, asegrese de insertar el dispositivo correcto que coincida con esta cuenta.",
  wrongKeystore2: " Si utiliza la frase de contrasea opcional, asegrese de haber introducido la frase de contrasea correcta para la cuenta."
};
const fiat$5 = {
  "default": "predeterminado",
  setDefault: "Establecer {{code}} predeterminado",
  title: "Monedas"
};
const footer$5 = {
  appVersion: "Versin de app:"
};
const generic$4 = {
  enabled_false: "Desactivado",
  enabled_true: "Activado"
};
const genericError$3 = "Ocurri un error. Si observa algn problema, por favor reinicie la aplicacin.";
const goal$3 = {
  buttons: {
    create: "Crear una billetera nueva",
    restore: "Restaurar una billetera desde una copia de seguridad"
  },
  paragraph: "Por favor, selecciona una de las siguientes opciones:",
  step: {
    "1": {
      title: "Informacin de seguridad"
    },
    "2": {
      description: "Establece una contrasea del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crear una billetera nueva",
      title: "Billetera"
    },
    "3-restore": {
      description: "desde una copia de seguridad",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumen"
    },
    "4-restore": {
      title: "Resumen"
    }
  }
};
const guide$4 = {
  accountDescription: {
    text: "Este es el resumen de tu cuenta. Muestra las transacciones entrantes y salientes. El saldo se muestra para cada cuenta por separado. Consulta la gua de configuracin para obtener ms informacin sobre los diferentes tipos de cuentas.",
    title: "Qu me muestra esta pgina?"
  },
  accountFiat: {
    text: "S. Puedes hacer clic en cualquier ticker para rotar a travs de varias monedas fiat. Tambin puedes cambiar la lista de monedas en la configuracin.",
    title: "Puedo mostrar otros tipos de cambio?"
  },
  accountIncomingBalance: {
    text: '"Entrante" resume los importes transferidos pero que todava no han sido confirmados por la red.',
    title: 'Qu significa "Entrante"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Cada xpub est relacionada con el "Tipo" mostrado: tanto "Native Segwit (bech32)", "Wrapped Segwit" como "Taproot" (Bitcoin only). Estos son tipos de script utilizados por {{coinName}}. La BitBoxApp las combina, soportando mltiples tipos de script en la misma cuenta. Porque cada tipo de script proporciona una xpub diferente, hay mltiples xpubs por cuenta.\n\nSi constantemente recibe en la direccin por defecto (Native Segwit), solo necesita la "bech32" xpub. Sin embargo, si tambin recibe fondos en "Wrapped Segwit" o "Taproot", tambin necesitara utilizar las claves pblicas extendidas de "Wrapped Segwit" y "Taproot" respectivamente.',
      title: "Porqu hay mltiples xpubs?"
    },
    privacy: {
      text: "Para esta cuenta especfica, la clave pblica extendida revela todo el historial financiero, el balance en la cuenta, y todas las transacciones futuras. Pero el xpub no permite que nadie gaste tus monedas.\n\nSi le proporcionas una xpub a alguien, debers tener en cuenta que esa persona o empresa pueden ver otras transacciones de la misma cuenta. Por lo tanto, es una buena idea utilizar esa cuenta solamente con ese propsito y guardar otros fondos en cuentas diferentes.",
      title: "Necesito guardar mi xpub en secreto?"
    },
    verify: {
      text: "Si, siempre es una buena idea hacer una doble verificacin de tu xpub. Si alguien va a generar direcciones a partir de esta xpub para mandarte dinero, esto es especialmente importante. Tendr que verificarla en el dispositivo para asegurarse que esa xpub le pertenece; en caso contrario, todos los fondos podran ir a direcciones incorrectas.",
      title: "Necesito verificar la xpub en el dispositivo?"
    },
    xpub: {
      text: "Una clave pblica extendida (xpub) es una clave raz de la cual se obtienen todas las direcciones de recepcin de una cuenta.\nSe proporciona para uso avanzado e interoperabilidad con billeteras watch-only, como Electrum o Sentinel. Si recibe otro tipo de direcciones, por favor importe todos los formatos de xpub en la billetera watch-only para poder visualizar todas las monedas.\nTenga en cuenta que, las billeteras de terceros puede que no soporten Taproot xpubs todava.",
      title: "Qu es una clave pblica extendida?"
    }
  },
  accountRates: {
    text: "Los tipos de cambio se actualizan cada minuto desde CoinGecko.",
    title: "Qu tipo de cambio se utiliza?"
  },
  accountReload: {
    text: "No hace falta. Toda la informacin de las transacciones se actualiza automticamente.",
    title: "Puedo recargar el historial de transacciones?"
  },
  accountSendDisabled: {
    text: 'El botn "Enviar" se activa cuando tu saldo es mayor que cero.',
    title: "Por qu no puedo enviar ningn {{unit}}?"
  },
  accountSummaryAmount: {
    text: "La cantidad total es la suma de todas tus cuentas criptogrficas. Los tipos de cambio se consiguen de coingecko.com.\n\nNota: Si usas MyEtherWallet para tokens no admitidos en BitBoxApp, no se incluirn en la cantidad que se muestra.",
    title: "Cmo se calcula la suma total?"
  },
  accountSummaryDescription: {
    text: "Aqu puede ver el rendimiento de tu billetera a lo largo del tiempo. Debajo del grfico se muestra un resumen de sus cuentas criptogrficas individuales.",
    title: "Qu me muestra esta pgina?"
  },
  accountTransactionAttributesBTC: {
    text: "Tamao virtual: se utiliza para determinar la tarifa de la red. Habrs ahorrado con xito en comisiones si son ms pequeas que la transaccin.\nTamao: Tamao real de la transaccin en bytes cuando se presenta por entregas de acuerdo con la blockchain por debajo.\nPeso: Introducido con Segwit, es una nueva mtrica para evaluar los tamaos de transaccin y bloque. Cada byte testigo segregado cuenta como uno, todo lo dems como cuatro unidades de peso. En lugar de un megabyte en tamao real, el lmite de tamao de bloque ahora es de cuatro millones de unidades de peso.",
    title: "Detalles de la transaccin relacionados con Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmaciones: Cuando tu transaccin se transmita por primera vez, no se confirmar. Tienes que esperar a que un minero lo incluya en un bloque, despus de lo cual tendr 1 confirmacin. Desde ese momento, cada bloque transmitido en la red agregar otra confirmacin a tu transaccin. En general, los comerciantes y otros actores de la red solo aceptarn transacciones con confirmaciones de entre 3-6 antes de considerar la transaccin como liquidada.\nID de transaccin: un nmero de identificacin nico que se puede usar para buscar una transaccin en un explorador de bloques.\nCuota: los mineros reciben una tarifa de transaccin como incentivo para incluir las transacciones en los bloques que explotan. Para obtener ms informacin, haz clic en el botn enviar.",
    title: "Cul es la informacin que se muestra en los detalles de la transaccin?"
  },
  accountTransactionConfirmation: {
    text: "Esta es una transaccin que se ha transmitido a la red y espera ser confirmada.",
    title: "Qu es una transaccin pendiente?"
  },
  accountTransactionLabel: {
    text: "Es la direccin donde recibiste o enviaste tus monedas. \nUna direccin codifica cmo (y por lo tanto, por quin) se pueden gastar las monedas.",
    title: "Qu direccin se muestra para cada transaccin?"
  },
  accountTransactionTime: {
    text: "El tiempo que la transaccin ha sido confirmada en el blockchain.",
    title: "Qu hora se muestra?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin y Litecoin pueden tener una cantidad arbitraria de cuentas. Despus de cinco cuentas, slo se puede aadir otra cuenta si se ha utilizado la anterior. \nOtras monedas pueden tener un mximo de cinco cuentas.",
      title: "Cuntas cuentas puedo crear?"
    },
    howtoAddTokens: {
      text: 'Tokens que utilicen el estndar ERC20 estn conectados a una cuenta especfica de Ethereum. Para permitir o inutilizar un token en particular, abra la ventana de "Administrar cuentas", despliegue su cuenta Ethereum y active o desactive su token deseado.',
      title: "Cmo puedo aadir tokens adicionales?"
    },
    moveFunds: {
      text: "Si. Pero porque las cuentas son independientes, necesitar enviar los fondos utilizando una transaccin normal.",
      title: "Puedo mover fondos entre cuentas?"
    },
    recoverAccounts: {
      text: "Si. La BitBoxApp crea cuentas utilizando estndares muy establecidos compatibles con la mayora de otras carteras crypto.",
      title: "Puedo recuperar mis cuentas de otras carteras?"
    },
    whatAreAccounts: {
      text: "Su cartera puede administrar cuentas de la misma moneda. Las cuentas son tiles cuando se quiere guardar los fondos de forma separada.",
      title: "Qu son las cuentas?"
    },
    whatIsRememberWallet: {
      text: 'Activando "Recordar billetera" podrs ver las cuentas de esta billetera en la BitBoxApp incluso cuando la BitBox02 no est conectada. Esto te permite comprobar tu saldo y portafolio siempre que quieras. La BitBox02 necesita estar conectada y desbloqueada para enviar o recibir monedas.\n\nDesactivar "Recordar billetera" requiere que conectes la BitBox02 respectiva (o frase de contrasea) para ver esas cuentas en la BitBoxApp.',
      title: 'Qu ocurre cuando activo/desactivo "Recordar billetera"?'
    },
    whyIsThisUseful: {
      text: 'Las cuentas son geniales para la gestin de fondos para diferentes personas o propsitos porque estn separados. Tambin puede compartir la "clave pblica extendida" de una cuenta sin revelar nada sobre las otras cuentas. Esto permite recibir fondos repetidamente sin reutilizar direcciones, tanto para recibir su salario o comprar crypto de forma habitual.',
      title: "Porqu es esto til?"
    }
  },
  appendix: {
    link: "Contacta con nosotros!",
    text: "Otra pregunta?"
  },
  backups: {
    check: {
      text: '"Comprobar copia de seguridad" te permite verificar que tienes una copia de seguridad operativa correspondiente a tu monedero actual. Tambin se puede usar para verificar que todava tienes la contrasea de recuperacin correcta. Puedes verificar tu contrasea de recuperacin principal o tu contrasea de recuperacin oculta.',
      title: "Qu es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: "No, pero necesitas tu contrasea de recuperacin para obtener el monedero de la semilla guardada.",
      title: "Puedo encriptar la copia de seguridad?"
    },
    howOften: {
      text: "La copia de seguridad se genera automticamente cuando se crea un nuevo monedero. Slo tienes que hacer una nueva copia de seguridad si tu tarjeta micro SD est perdida o daada, o si quieres usar varias tarjetas micro SD como copias de seguridad.\nNo es necesario crear nuevas copias de seguridad despus de la actividad de transaccin. Todos tus datos de transaccin pueden ser recreados por tu nica copia de seguridad que se gener automticamente para ti.",
      title: "Con qu frecuencia tengo que hacer una copia de seguridad?"
    },
    whatIsABackup: {
      text: "Esto es una copia de la semilla en una tarjeta micro SD. La semilla junto con tu contrasea de recuperacin genera tu monedero.",
      title: "Qu es una copia de seguridad?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Comprobar copia de seguridad' te permite verificar que tienes una copia de seguridad funcional y que corresponde a tu monedero actual.",
      title: "Qu es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: 'No. Por favor mantn la microSD en un lugar seguro porque contiene la semilla para recuperar tu monedero sin encriptar. Si deseas proteger con contrasea tu semilla, puedes activar una frase de contrasea (passphrase) opcional en los ajustes, debajo de "Ajustes del dispositivo". ',
      title: "Puedo encriptar la copia de seguridad?"
    },
    whatIsABackup: {
      text: "Es una copia de la semilla en la tarjeta microSD.",
      title: "Qu es una copia de seguridad?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Cuando 2FA est habilitado, todas las transacciones deben aprobarse en el telfono mvil sincronizado para poder gastar monedas. Tcnicamente, se enva un nmero encriptado de un solo uso a la aplicacin mvil, donde se descifra y se devuelve al BitBox al presionar el botn Aceptar. Esta comunicacin con el dispositivo se realiza a travs del canal entre el telfono mvil y esta aplicacin de escritorio establecida durante la sincronizacin.\n\nAsegrate de hacer una copia de seguridad de tu monedero y sincroniza la aplicacin mvil antes de habilitar 2FA. Una vez habilitado, las sincronizaciones entre la ranura micro SD y las aplicaciones mviles se deshabilitan. Se pueden volver a habilitar reiniciando el BitBox, algo que borrar el dispositivo.",
      title: "Cmo funciona la autorizacin de dos factores (2FA)?"
    },
    disable2FA: {
      text: `Para deshabilitar 2FA, debes restablecer su BitBox y luego restaurar el monedero desde su copia de seguridad. Asegrate de que todava tienes la tarjeta micro SD con la copia de seguridad y que an recuerdas la contrasea de recuperacin. Luego pulsa 'Restablecer dispositivo'. Establece una nueva contrasea de dispositivo y elija 'O restaurar una copia de seguridad'. Selecciona la copia de seguridad que has hecho del monedero, haz clic en "Restaurar" e ingresa la contrasea de recuperacin que utilizaste al crear el monedero.`,
      title: "Cmo puedo desactivar la autorizacin de dos factores (2FA)?"
    },
    ejectBitbox: {
      text: "Puedes desconectar el BitBox en cualquier momento sin tener que expulsarlo primero.",
      title: "Cmo puedo expulsar el BitBox?"
    },
    ejectSD: {
      text: "Puedes retirar la tarjeta micro SD de BitBox en cualquier momento siempre que no est en el proceso de crear o restaurar una copia de seguridad.",
      title: "Cmo puedo expulsar la tarjeta micro SD?"
    },
    hiddenWallet: {
      text: "Es un segundo monedero en el mismo dispositivo protegido por una contrasea de dispositivo y una contrasea de recuperacin diferentes, que puedes usar para una negacin creble. La misma semilla de copia de seguridad se usa para tu monedero normal y oculto, por lo que no se requiere una copia de seguridad adicional.",
      title: "Qu es un monedero oculto?"
    },
    legacyHiddenWallet: {
      text: "Primero haz clic en el botn de abajo (disponible si el BitBox est desbloqueado con la contrasea del dispositivo principal y la 2FA est desactivada), luego vuelve a conectar su Bitbox y desbloquea con la contrasea oculta del dispositivo.",
      title: "Cmo accedo el monedero oculto heredado?"
    },
    pairing: {
      text: "Despus de haber descargado nuestra aplicacin mvil para iOS o Android, escanea el cdigo QR mostrado, que establece un canal seguro entre la aplicacin mvil y esta aplicacin. Una vez escaneado, sige las instrucciones en la aplicacin mvil.",
      title: "Cmo sincronizo de forma segura con mi telfono"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Consulte el sitio web de Bitsurance y sus preguntas frecuentes para obtener ms informacin.",
      title: "Tiene ms preguntas?"
    },
    privacy: {
      link: {
        text: "Poltica de privacidad de Bitsurance"
      },
      text: "Como cualquier pliza de seguro normal, contiene su nombre completo y direccin, y especifica el objeto asegurado (definido por la clave pblica extendida de la cuenta Bitcoin asegurada). Estos datos se envan directamente a Bitsurance y no se comparten con Shift Crypto. Por favor, consulte la poltica de privacidad de Bitsurance para ms informacin.",
      title: "Qu datos personales se necesitan para el seguro?"
    },
    renew: {
      text: 'El seguro se renovar automticamente para el ao siguiente. Puedes cancelar la renovacin en cualquier momento haciendo clic en "Gestionar contrato" en la BitBoxApp, que te lleva al portal de clientes de Bitsurance.',
      title: "Cmo puedo renovar o cancelar el seguro?"
    },
    status: {
      text: 'Las cuentas aseguradas con xito se marcan con una insignia verde de "asegurado" en la esquina superior izquierda de cada pgina de cuenta Bitcoin. En la seccin "Seguro", puede ver el resumen de todas las cuentas Bitcoin aseguradas y su estado de seguro actual.',
      title: "Puedo comprobar el estado de una cuenta asegurada?"
    },
    what: {
      text: 'Cada contrato de seguro de Bitcoin cubre una cuenta de billetera especfica. Puede asegurar varias cuentas contratando varias plizas de seguro. Las cuentas aseguradas estn limitadas al uso de direcciones Bitcoin "Segwit Nativo".',
      title: "Est asegurada toda la billatera BitBox?"
    },
    who: {
      text: "El seguro lo ofrece Bitsurance, un corredor de seguros creado por bitcoiners. Trabajan con ELEMENT insurance para ofrecer seguros de Bitcoin. Ambas empresas tienen su sede en Alemania.",
      title: "Quin asegura mi bitcoin?"
    },
    why: {
      text: "Bitsurance cubre algunos riesgos de la autocustodia que no estn cubiertos ni siquiera por la billatera ms segura, como el robo, la extorsin o la destruccin de la billetera. Es tu decisin personal si necesitas cobertura de seguro para estos riesgos.",
      title: "Necesito un seguro Bitcoin?"
    }
  },
  cointracking: {
    text: 'Haga click en el botn "Exportar" y abra la carpeta de descargas donde encontrar el CSV exportado.\nA continuacin haga click en el enlace de abajo, cargue su archivo BitBox CSV e importe los datos para ser utilizados por su gestor de CoinTracking y crear sus informes fiscales.',
    title: "Cmo importar mis transacciones a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Ms informacin sobre el control de autenticidad"
      },
      text: "La BitBoxApp realiza una comprobacin de atestacin en la BitBox02 para verificar si el dispositivo es genuino. La comprobacin se realiza localmente y no se conecta a ningn servidor.",
      title: "Cmo funciona el control de autenticidad?"
    },
    name: {
      text: "Este es el nombre de tu wallet y de la copia de seguridad. El nombre se utiliza para futuras copias de seguridad y se puede utilizar para ayudar a distinguir entre diferentes billeteras. Se puede cambiar en cualquier momento, pero ten en cuenta que las copias de seguridad realizadas antes del cambio seguirn utilizando el nombre anterior.",
      title: "Para qu se utiliza el nombre BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Ms informacin sobre el chip seguro"
      },
      text: "Esta informacin muestra el nmero de modelo del chip seguro, el chip ms actualizado es ATECC608B con caractersticas de seguridad mejoradas en comparacin con los modelos anteriores.",
      title: "Por qu mostrar el modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Puedes dar la direccin a otras personas para que te enven monedas. Solo tienes que asegurarte de que enven a la direccin correcta.",
      title: "Qu hago con una direccin?"
    },
    addressChange: {
      text: "En cuanto se utilice una direccin en una transaccin, se agrega una nueva direccin a la lista para reemplazarla. Siempre habr 20 direcciones no utilizadas disponibles en la lista.",
      title: "Cundo cambian las direcciones?"
    },
    addressFormats: {
      text: "Por defecto, el tipo de direccin es Native Segwit. Esta direccin es ampliamente adoptada por otras carteras/exchanges y proporciona las mejores comisiones para las transacciones del da a da. En cambio, se puede elegir enviar a Taproot (Bitcoin Only), que es el ltimo tipo de direcciones, pero puede que no sea ampliamente soportada todava. Como alternativa, si tiene complicaciones enviando a Native Segwit (el tipo de direccin por defecto), puede intentar cambiar al antiguo tipo de direccin Wrapped Segwit que puede ser compatible con mas carteras/exchanges.\n",
      title: 'Cundo utilizar "cambio de tipo de direccin"?'
    },
    howVerify: {
      text: "Para la BitBox01, haz clic en el icono BitBox en la barra lateral de la izquierda y revisa las opciones de emparejamiento. Esta gua se actualizar y podrs seguir las nuevas instrucciones desde all.\nPara la BitBox02, puedes verificar las direcciones directamente en tu dispositivo durante el proceso de envo y recepcin. ",
      title: "Cmo puedo verificar una direccin de forma segura?"
    },
    plugout: {
      text: "No, una vez ha enviado las monedas a su direccin de BitBox, no tendr que dejar su BitBox enchufada. Puede desconectar su BitBox cuando quiera.",
      title: "Necesito dejar conectada mi BitBox mientras recibo?"
    },
    why20: {
      text: 'Durante la inicializacin, la app genera direcciones derivadas de tu semilla para ver si han recibido fondos. Como la app puede generar un nmero casi infinito de direcciones, se podra pasar aos determinando el saldo. Para limitar esta bsqueda se para despus de encontrar 20 direcciones que nunca han recibido fondos. Esto es un "intervalo lmite" y  20 es el estndar de-facto aunque el nmero es arbitrario. Estas son las 20 direcciones que puedes escoger.',
      title: "Por qu solo 20 direcciones?"
    },
    whyMany: {
      text: "Por razones de privacidad y seguridad, nunca debes utilizar la misma direccin dos veces. Haz clic en 'Siguiente' para obtener una nueva direccin para un propsito diferente. Puedes generar hasta 20 direcciones a la vez. Todas las direcciones se derivan de tu semilla nica de la copia de seguridad.",
      title: "Por qu hay tantas direcciones?"
    },
    whyVerify: {
      text: "Una de las razones por las que comprar una cartera de hardware como la BitBox es que no debes confiar en tu ordenador debido a sus numerosos vectores de ataque. No debes confiar en que tu ordenador genere y muestre direcciones autnticas. El botn para verificar la direccin de manera segura hace que BitBox enve la direccin a un telfono mvil sincronizado, desde el cual tambin puedes escanear y verificar el cdigo QR.",
      title: "Por qu debo verificar la direccin de forma segura?"
    }
  },
  send: {
    change: {
      text: "El cambio ser devuelto a una direccin Taproot si al menos tiene un UTXO Taproot. Si utiliza coin control, el cambio ser devuelto a una direccin Taproot si al menos hay un Taproot UTXO entre los UTXOs seleccionados. En el resto de casos, el cambio ser devuelto a una direccin Native Segwit.",
      title: "Cmo se determina la direccin de cambio?"
    },
    fee: {
      text: "La tarifa se basa en el tamao de los datos de la transaccin y no en su cantidad. Los objetivos de tiempo de la tarifa se calculan mediante el algoritmo de estimacin de tarifa de Bitcoin Core para cada prioridad de red que elijas. Sern mostrados si tienen un valor diferente del siguiente objetivo.\nEconmico: 24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)\nBajo: 12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)\nNormal: 6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)\nAlto: 2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)\n(Un bloque de Bitcoin tarda un promedio diez minutos para que se mine (2.5 minutos en Litecoin), y la congestin de la red puede hacer variar considerablemente los perodos arriba mencionados).",
      title: "Cmo se determina la comisin?"
    },
    plugout: {
      text: "No, una vez ya ha realizado la transaccin, no necesita dejar su BitBox conectada. Puede desconectar su BitBox cuando quiera.",
      title: "Necesito dejar mi BitBox conectada mientras envo?"
    },
    priority: {
      text: "Cuanto mayor sea la comisin que ests dispuesto a pagar, ms rpido se confirmar tu transaccin por la red.",
      title: "Cul es la prioridad de la red?"
    },
    revert: {
      text: "Una vez que se firma y se enva una transaccin (que se transmite a la red), ya no puede revertirse. Verifica las transacciones (tambin la comisin) correctamente antes de firmar!\nSi conoces al destinatario y l o ella est dispuesto a enviarte la misma cantidad de vuelta (menos los cargos por transaccin), puedes entonces enviarle una nueva direccin de recepcin.",
      title: "Puedo revertir una transaccin?"
    },
    whyFee: {
      text: "Las transacciones compiten para ser confirmadas por un minero. Los mineros eligen las transacciones que se incluirn en la blockchain en funcin de tu tarifa.\nLos mineros votan sobre el historial de las transacciones. Dado que no hay un tercero de confianza para imponer un voto por persona (que es el eje central de las blockchains), los mineros votan sobre las transacciones sacrificando un recurso caro como la potencia de clculo. Como recompensa por su trabajo, pueden reclamar monedas recin creadas y la tarifa de todas las transacciones que incluyeron.",
      title: "Por qu hay una tarifa de red?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Si solo tiene la intencin de conectarse a tu nodo cuando est en la misma red (por ejemplo, la red wifi de tu hogar), entonces es suficiente usar la comunicacin de red regular.\nEn este caso, es recomendable que el servidor Electrum proporcione un certificado TLS para encriptar la comunicacin.\nSi tu intencin es conectarse a tu nodo desde cualquier lugar, usar Tor es la mejor opcin. En ese caso, no es necesario ningn certificado TLS.\n\n",
      title: "Debo usar Clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Gua para conectar tu nodo"
      },
      text: "Para el tutorial competo, por favor visita nuestra gua: ",
      title: "Como conecto mi BitBoxApp con mi nodo?"
    },
    options: {
      text: "Hay varias opciones para usar su propio nodo, como comprar un dispositivo terminado, construir el tuyo propio o usar Bitcoin Core.\nSi quieres conectar tu BitBoxApp a tu nodo, asegrate de que ejecutas un servidor Electrum. Este es un programa que permite que una app del monedero se comunica con su nodo completo.\nLas opciones  incluyencompatibles Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).",
      title: "Qu opciones existen para ejecutar un nodo?"
    },
    tor: {
      text: "Tor significa 'The Onion Router', es un software gratuito y de fuente abierta que ofrece muchos beneficios de privacidad. Es muy til cuando se usa Bitcoin.\nSi tienes la intencin de conectarte a su nodo a travs de Tor, asegrate de que Tor est instalado en tu ordenador y luego activa Tor Proxy en la configuracin de BitBoxApp.\nEn la mayora de los sistemas operativos, hay dos formas de ejecutar Tor:\n1. Tor Browser: descarga y abre el Tor Browser. Esto permitir que BitBoxApp se conecte a la red Tor configurando el puerto 9150 en la configuracin del proxy Tor.\n2. Servicio Tor en segundo plano: instala el Tor daemon, que siempre se usa en segundo plano. BitBoxApp puede conectarse configurando el puerto 9050 en la configuracin del proxy Tor.\n\n",
      title: "Que es un Tor, Tor proxy y en que puerto lo debera usar?"
    },
    what: {
      text: "Es posible conectar tu wallet a tu propio nodo completo Bitcoin en vez de utilizar los servidores Shift.",
      title: "Qu es esto?"
    },
    why: {
      text: "No es necesario ejecutar su propio nodo, pero mejora la privacidad y reduce la necesidad de confiar en los dems.\nEn primer lugar, significa que ests utilizando Bitcoin de forma ms privada, ya que BitBoxApp no se conectar a nuestros servidores para recuperar su historial de transacciones; en su lugar, obtendr esa informacin de su propio nodo.\nEn segundo lugar, ejecutar tu propio nodo significa que tu nodo verifica todas las transacciones por s mismo, asegurndose de que se cumplan las reglas de consenso.",
      title: "Por qu debera ejecutar mi propio nodo?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" para abreviar) es la unidad ms pequea de Bitcoin. Un Satoshi es la cienmillonsima parte de un bitcoin (0,00000001 BTC). Debe su nombre al creador de Bitcoin, Satoshi Nakamoto.',
      title: "Qu es un Satoshi?"
    },
    servers: {
      text: "Esta aplicacin se comunica con los servidores de Shift Crypto para buscar actualizaciones, cargar transacciones y enviar informacin a aplicaciones mviles sincronizadas.\nAdems, recupera los ltimos tipos de cambio de CoinGecko. Todas las conversiones se calculan de forma local lo que significa que no se envan las cantidades que uno tiene a ningn servidor. \nNota: Para Ethereum y tokens ERC20, utilizamos la API de Etherscan.io",
      title: "Con qu servidores se comunica esta aplicacin?"
    }
  },
  title: "Gua",
  toggle: {
    close: "Cerrar la gua",
    open: "Gua"
  },
  trackingModePortfolioChart: {
    text: "En el ordenador de sobremesa, site el cursor sobre el grfico. En mvil, mantn el dedo sobre el grfico y arrstralo horizontalmente.",
    title: "Cmo ver los valores histricos en el grfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Debe restablecer el dispositivo y recuperar el mondero desde una copia de seguridad, utilizando la contrasea de recuperacin.",
      title: "Qu hago si olvido la contrasea del dispositivo?"
    },
    reset: {
      text: "Introduzca una contrasea de dispositivo incorrecta 15 veces. Los ltimos intentos requieren mantener pulsado el dispositivo .",
      title: "Cmo reinicio el dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "El dispositivo debe parpadear una vez se haya insertado. Asegrese de que se inserta de la manera correcta. Si tiene problemas, por favor contctenos a travs del siguiente enlace.\nLa BitBox01 no es soportada en los mviles/celulares. Por favor utilice la BitBoxApp de escritorio para conectar su BitBox01.",
      title: "Mi dispositivo no est reconocido"
    },
    getDevice: {
      link: {
        text: "Encargue un BitBox"
      },
      text: "Puedes comprar un BitBox en nuestra tienda online:",
      title: "Cmo puedo obtener un dispositivo?"
    },
    internet: {
      text: "S, se necesita una conexin a Internet para sincronizar el monedero, enviar transacciones y recuperar los ltimos tipos de cambio.",
      title: "Esta aplicacin requiere conexin a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de respaldo (backup)"
      },
      text: "Puede recuperar sus cuentas en un nuevo BitBox o con nuestro centro de copia de seguridad.",
      title: "Perd mi dispositivo. Ahora qu?"
    },
    useWithoutDevice: {
      text: "Lamentablemente, esto todava no es posible en este momento.",
      title: "Puedo usar la aplicacin sin un dispositivo?"
    },
    welcome: {
      text: "Gracias por utilizar esta aplicacin creada por Shift Crypto en Suiza. Todava est en beta y agradecemos cualquier comentario que tenga que compartir. Por favor, de su opinin utilizando el enlace en la parte inferior.",
      title: "Bienvenido a la aplicacin de BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si ests usando un nuevo telfono/ordenador con la BitBoxApp, entonces tendrs que conectarte de nuevo a la DApps. A continuacin, ver sus monedas en la dapp de nuevo como de costumbre.",
      title: "No veo mis conexiones previas."
    },
    supportedNetworks: {
      text: "Actualmente, slo Ethereum mainnet es compatible utilizando WalletConnect en la BitBoxApp. Para utilizar otras cadenas compatibles con EVM, por favor utilice la extensin de navegador Rabby wallet.",
      title: "Qu redes son compatibles?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect es un protocolo de comunicacin para aplicaciones web3. Permite conectarse cmodamente a DApps basadas en Ethereum y billeteras web sin necesidad de utilizar una app de terceros, lo que resulta especialmente til para los usuarios de Android de la BitBoxApp.",
      title: "Qu es WalletConnect?"
    }
  }
};
const headerssync$3 = {
  blocksSynced: "{{blocks}} bloques sincronizados"
};
const hiddenWallet$3 = {
  info1HTML: "Para fines de negacin plausible, se puede crear un monedero oculto basada en una <strong>diferente</strong> combinacin de contrasea de recuperacin y contrasea del dispositivo.",
  info2HTML: "Defina la contrasea del dispositivo y la contrasea de recuperacin que quieres asociar con su monedero oculto a continuacin. La contrasea del dispositivo y la contrasea de recuperacin deben ser <strong>diferentes</strong> de los que has definido para tu monedero principal.",
  passwordLabel: "Contrasea de recuperacin oculta",
  passwordPlaceholder: "Por favor confirma la contrasea de recuperacin oculta",
  pinLabel: "Contrasea oculta del dispositivo",
  pinRepeatLabel: "Repita la contrasea del dispositivo oculto",
  pinRepeatPlaceholder: "Por favor confirma la contrasea oculta del dispositivo",
  success: "Monedero oculto creado con xito. Vuelve a enchufar tu BitBox para desbloquearlo."
};
const initialize$3 = {
  create: "Establece contrasea del dispositivo",
  creating: "Configuracin de la contrasea del dispositivo ...",
  error: {
    e102: "La contrasea del dispositivo debe constar de al menos 4 caracteres."
  },
  info: {
    description1: "Elije la contrasea de tu dispositivo. Esto se utilizar para desbloquear su BitBox.",
    description2: "Puedes usar nmeros, letras y smbolors. Las contraseas largas ofrecen mayor seguridad.",
    description3: "Si pierdes la contrasea del dispositivo, tendrs que restablecer tu dispositivo y recuperar la copia de seguridad de su monedero.",
    subtitle: "Ahora configurar la contrasea de su dispositivo.",
    title: "Iniciando su dispositivo"
  },
  input: {
    label: "Contrasea del dispositivo",
    labelRepeat: "Repita la contrasea del dispositivo",
    placeholderRepeat: "Por favor confirma la contrasea del dispositivo"
  }
};
const invalidFormat$3 = "Formato invlido";
const language$4 = {
  title: "Selecciona el idioma"
};
const legacyhiddenwallet$3 = {
  disable: "Desactiva monedero oculto heredado",
  enable: "Activa monedero oculto heredado",
  successDisable: "Se desactiv con xito el legado del monedero oculto.",
  successEnable: "El monedero oculto heredado se habilit con xito. Vuelva a enchufar su BitBox e ingresa la contrasea del dispositivo oculto para acceder al monedero oculto heredado."
};
const loading$3 = "cargando";
const manageAccounts$2 = {
  accountHidden: "Esta cuenta ha sido ocultada de tus cuentas de slo vigilancia. Para volver a verla, conecta tu BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nombre de cuenta",
  noAccounts: "No se han encontrado cuentas",
  settings: {
    hideTokens: "Ocultar tokens",
    showTokens: "Mostrar tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aadir y mostrar/ocultar cuentas",
  title: "Administrar cuentas",
  watchAccount: "Cuenta de vigilancia",
  watchAccountDescription: "Esta cuenta forma parte de tus cuentas de vigilancia. Puedes ocultarla de tus cuentas de solo vigilancia utilizando el conmutador."
};
const mobile$3 = {
  usingMobileDataWarning: "Uso de datos mviles: esta aplicacin puede descargar hasta unos cientos de megabytes de datos de blockchain despus de desbloquear una cuenta. Por favor, conctate a una red Wi-Fi para evitar el uso de datos mviles. Despus de descartarlo, este mensaje no se mostrar nuevamente.\n\n"
};
const newSettings$2 = {
  about: {
    appVersion: {
      title: "Versin de la aplicacin"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloquea el acceso a la aplicacin con bloqueo de pantalla/huella dactilar.",
      title: "Bloqueo de pantalla"
    },
    coinControl: {
      description: ""
    },
    customFees: {
      description: "Le permite introducir su propia tarifa al enviar."
    },
    torProxy: {
      description: "Conctate a travs de Tor para mejorar la privacidad."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Estas monedas adicionales se pueden cambiar a travs de la pgina de su cuenta.",
      title: "Divisas activas"
    },
    darkmode: {
      description: "Ver la BitBoxApp en modo oscuro."
    },
    defaultCurrency: {
      description: "Selecciona tu moneda predeterminada",
      title: "Moneda predeterminada"
    },
    enableAccount: {
      description: "Deshabilitar tu cuenta significa que no aparecer en la barra lateral ni en la billetera. Siempre puedes volver a activarla desde aqu. Las monedas de esta cuenta no se vern afectadas y permanecern seguras.",
      title: "Activar/desactivar cuenta"
    },
    hideAmounts: {
      description: "Muestra un conmutador para ocultar tu saldo y los importes para mejorar tu privacidad cuando utilices la aplicacin en pblico.",
      hideAmounts: "Ocultar importes",
      showAmounts: "Mostrar importes",
      title: "Permitir ocultar importes"
    },
    language: {
      description: "Qu idioma quieres que utilice la BitBoxApp.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Recuerde la billetera",
      warning: "Esto eliminar tu billetera recordada. Para verlo de nuevo, necesitar conectar la BitBox02 para esta billetera. Las monedas de esta billetera no se vern afectadas. Desea continuar?",
      warningTitle: "Desactivar recuerde la billetera"
    },
    toggleSats: {
      description: "Habilitar o deshabilitar Satoshis."
    }
  }
};
const note$4 = {
  input: {
    description: "(opcional)",
    placeholder: "aade nota"
  },
  title: "Nota"
};
const notification$3 = {
  newTxs_one: "Nueva transaccin en: {{accountName}}",
  newTxs_other: "{{count}} nuevas transacciones en: {{accountName}}"
};
const pairing$3 = {
  aborted: {
    text: "La sincronizacin ha sido cancelada desde la aplicacin mvil.",
    title: "Abortado"
  },
  button: "Sincronizar aplicacin mvil",
  confirm: "Ests seguro de que quieres sincronizar su BitBox? Ten en cuenta que despus, se necesitar el telfono mvil para realizar una transaccin.",
  connectOnly: {
    button: "Conectar aplicacin mvil",
    title: "Escanea con nuestra aplicacin mvil seleccionando el elemento de men 'Conectar a la nueva aplicacin de escritorio'"
  },
  error: {
    text: "Algo sali mal. Por favor empieza de nuevo.",
    title: "Error"
  },
  pullFailed: {
    text: "Ha habido un error recibiendo un mensaje de tu mvil a travs del relay server.  ste puede estar sin conexin, por favor contacte al soporte tcnico.",
    title: "Solicitud fallida"
  },
  reconnectOnly: {
    button: "Volver a conectar la aplicacin mvil"
  },
  scanningFailed: {
    text: "El mvil no ha podido escanear el mensaje con xito. Por favor intntalo de nuevo.",
    title: "Escaneo fallido"
  },
  start: {
    hideAppQRCode: "Ocultar cdigo QR",
    revealAppQRCode: "Mostrar cdigo QR",
    step1: "Si no tiene la aplicacin mvil, puede escanear el cdigo QR para la App Store de Apple o la Play Store de Google, segn el telfono que tengas.",
    step2: "Escanee con nuestra aplicacin mvil, que puede encontrar bajo el nombre 'Digital Bitbox 2FA' en las tiendas de aplicaciones para iOS y Android:"
  },
  started: {
    text: "Ahora sige por favor las instrucciones en la aplicacin mvil.",
    title: "Genial"
  },
  success: {
    text: "Enhorabuena, has sincronizado su BitBox con la aplicacin mvil!",
    title: "xito"
  },
  timeout: {
    text: "La sincronizacin expir despus de dos minutos. Empieza de nuevo si an quieres sincronizar la aplicacin mvil.",
    title: "Se acab el tiempo"
  },
  title: "Sincronizacin mvil"
};
const passphrase$2 = {
  considerations: {
    button: "Consideraciones de la copia de seguridad",
    message: "La frase de contrasea aade una capa de proteccin a tu billetera de copia de seguridad (de la tarjeta microSD o palabras de recuperacin). Si alguien tiene acceso a tu copia de seguridad, tambin necesitar la frase de contrasea para acceder a tu billetera. \n\n\nSin embargo, esto significa que necesitars <strong>tanto la frase de contrasea como la copia de seguridad de tu billetera</strong> para restaurar tu billetera con la frase de contrasea, en caso de que tu BitBox02 se pierda o se rompa. Si olvidas o pierdes tu contrasea, perders el acceso a todas las monedas de esa billetera.\n\nCuando almacenes tu frase de contrasea, considera ponerla en un lugar distinto a la de tu copia de seguridad. De este modo, si alguien encuentra la copia de seguridad, no encontrar tambin la frase de contrasea.",
    title: "Consideraciones de la copia de seguridad"
  },
  disable: "Desactivar passphrase",
  disableInfo: {
    button: "Desactivar",
    message: "Tras desactivar la passphrase, no se le volver a preguntar para que introduzca una passphrase tras desbloquear su BitBox02. Por lo que entrara en su cartera por defecto.\nCualquier moneda de su cartera con passphrase seguir estando en esa cartera, sin embargo no tendr acceso a ella porque tras desbloquear su BitBox02, abrir su cartera por defecto.\nPara acceder a su cartera con passphrase de nuevo, simplemente vuelva a activar la opcin de passphrase e introduzca la passphrase correcta tras desbloquear la BitBox02.\n<strong>Consejo:</strong> Puede seguir entrando en su cartera original dejando la passphrase vaca."
  },
  enable: "Activar passphrase",
  error: {
    e104: "El cambio en la caracterstica de passphrase fue abortado."
  },
  how: {
    button: "Cmo se ve",
    message: "Una passphrase no funciona como una contrasea a las que estamos habituados. Si se equivoca en un carcter de su passphrase, no ser notificado. Esto es porque <strong>cada passphrase crea una cartera diferente y vlida al mismo tiempo</strong>. Esto significa que se pueden utilizar tantas pasprases como carteras se deseen. Pero solo se puede acceder a cada cartera cuando se introduce su passphrase correspondiente.\nCuando conecte su BotBox02, ser preguntado por su contrasea como siempre. Despus, se le solicitar que introduzca la passphrase en el dispositivo.\nTras introducir la passphrase, se le mostrar la passphrase que ha introducido. Esto es para confirmar que ha sido introducida correctamente.",
    title: "Como funciona"
  },
  intro: {
    message: "Una passphrase proporciona una capa de seguridad por encima de su cartera.\nAprendamos cmo funciona.",
    title: "Configurar passphrase"
  },
  progressDisable: {
    message: "Confirme en su BitBox que quiere <strong>desactivar</strong> la opcin de passphrase.",
    title: "Confirme en el dispositivo"
  },
  progressEnable: {
    message: "Confirme en su BitBox que quiere <strong>activar</strong> la opcin de passphrase.",
    title: "Confirme en el dispositivo"
  },
  successDisabled: {
    message: "Passphrase opcional <strong>activada satisfactoriamente</strong>!\nA partir de ahora se le solicitara introducir una passphrase.",
    messageEnd: "Por favor vuelva a conectar ahora su BitBox02.",
    title: "Passphrase activado"
  },
  successEnabled: {
    message: "Passphrase opcional <strong>desactivada satisfactoriamente</strong>!\nA partir de ahora no se le solicitar introducir una passphrase.",
    messageEnd: "Por favor vuelva a conectar su BitBox02 ahora.",
    tips: "Consejos",
    tipsList: [
      "Le sugerimos enviar una pequea cantidad a su cartera con passphrase primero. Despus desconecte y vuelva a conectar la BitBox02 e introduzca su contrasea y su passphrase. Si ha introducido la passphrase correctamente, debera ver las monedas en su cartera.",
      "Si quiere entrar en su cartera original sin passphrase, puede seguir hacindolo no introduciendo nada cuando le solicite introducir la passphrase. O puede desactivar la caracterstica de passphrase."
    ],
    title: "Passphrase desactivada"
  },
  summary: {
    button: "Activar passphrase",
    title: "Resumen",
    understand: "Entiendo como funciona la passphrase y sus riesgos asociados.",
    understandList: [
      "La passphrase es una capa adicional de seguridad por encima de su copia de seguridad.",
      "Introducir un passphrase diferente siempre generar carteras diferentes.",
      "Para restaurar su cartera necesita <strong>tanto la passphrase como la copia de seguridad</strong>.",
      "Si olvidas tu frase de contrasea, ya no podrs <strong>acceder a tus monedas</strong>."
    ]
  },
  what: {
    button: "Aprenda como funciona",
    message: "Una billetera se crea (deriva) a partir de un nmero aleatorio muy grande, tambin conocido como semilla. Esta semilla se crea cuando configuras por primera vez tu BitBox02 y se respalda con la tarjeta microSD o las palabras de recuperacin. Cualquiera que tenga acceso a la semilla tiene control total sobre los fondos de esa billetera.\n\nUna frase de contrasea es un <strong>secreto opcional</strong>, aadido a la semilla. Cuando se utiliza una frase de contrasea, cada frase de contrasea crea una nueva billetera basada en la semilla + frase de contrasea (secreto opcional). Una frase de contrasea puede ser cualquier cosa: letras, palabras, caracteres especiales o incluso puede estar vaca. De hecho, la billetera predeterminadamente se deriva de la semilla + frase de contrasea vaca.\n\nLa frase de contrasea forma parte del estndar BIP39, lo que significa que es compatible con todos las billeteras que admitan el mismo estndar.",
    title: "Qu es una passphrase?"
  },
  why: {
    button: "Porqu utilizar una passphrase",
    message: 'La BitBox02 protege la semilla contra la extraccin desde el propio dispositivo, pero la copia de seguridad (tarjeta microSD o palabras de recuperacin) da acceso completo a la billetera. Por eso debe guardarse en un lugar seguro!\n\n\nDado que una frase de contrasea crea una nueva billetera utilizando tu semilla existente, la billetera con frase de contrasea requiere tanto tu <strong>reserva de seguridad</strong> COMO tu frase de contrasea para restaurarla. La ventaja de esto es que si alguien encuentra tu copia de seguridad, seguir necesitando la frase de contrasea para acceder a la billetera con la frase de contrasea.\n\n\nAdems, la funcin de la frase de contrasea permite crear varias billeteras en el mismo dispositivo, o "billeteras ocultas", adems del predeterminado.',
    title: "Porqu utilizar una passphrase?"
  }
};
const password$3 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "AVISO: el bloqueo de maysculas () est activado",
    paste: 'para pegar texto, activa "MOSTRAR {{label}}"'
  }
};
const random$4 = {
  button: "Generar nmero aleatorio",
  description: "Tu BitBox ha generado el siguiente nmero aleatorio de {{bits}} bits:"
};
const receive$5 = {
  bitsuranceWarning: "Esta es una cuenta asegurada, lo que significa que slo puede recibir a Segwit Nativo. Esto es para que no recibas accidentalmente a Wrapped Segwit o Taproot, que no estn asegurados.",
  changeScriptType: "Tipo de direccin del cambio",
  label: "Tu direccin",
  onlyThisCoin: {
    description: "Para recibir otros tokens, por favor actvalos en la configuracin. Si depositas otros tokens, podran no ser accesibles. ",
    warning: "Asegrate de recibir solo {{coinName}} en esta direccin."
  },
  scriptType: {
    p2tr: "Taproot (Nuevo formato)",
    p2wpkh: "Native Segwit (por defecto)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatible)"
  },
  selectAccount: "Seleccionar cuenta ",
  showFull: "Muestra y verifica la direccin completa en el dispositivo",
  taprootWarning: "Nota: Taproot es una nueva caracterstica de Bitcoin y todava no es ampliamente aceptada. Los fondos recibidos en direcciones Taproot pueden no ser mostradas en carteras de terceros. Muchas carteras y exchanges no pueden enviar a direcciones Taproot.",
  title: "Recibe {{accountName}}",
  verify: "Verificar la direccin de forma segura",
  verifyBitBox01: "Verifica la direccin completa en la app mvil",
  verifyBitBox02: "Verifica la direccin en la BitBox02",
  verifyInstruction: "Por favor, verifica que esta direccin encaja con la de tu dispositivo.",
  warning: {
    secureOutput: "Por favor, sincroniza su BitBox con tu dispositivo mvil para activar la verificacin segura de la direccin. Ve a 'Administrar dispositivo' en la barra lateral."
  }
};
const reset$3 = {
  description: "Todos los datos sern borrados de este dispositivo. Eso incluye tu clave privada!",
  notReset: "Dispositivo NO reseteado.",
  title: "Resetear dispositivo de fbrica",
  understand: "Tengo una copia de seguridad y conozco mi contrasea de recuperacin",
  understandBB02: "Tengo una copia de seguridad vlida"
};
const securityInformation$3 = {
  create: {
    description1: "Antes de configurar su dispositivo, se recomienda que lo hagas en un entorno seguro.",
    description2: "Se le pedir que crea dos contraseas.",
    description3: "La primera es la <strong>contrasea del dispositivo</strong> que desbloquea su dispositivo BitBox y puede cambiarse ms tarde.",
    description4: "El segundo es el <strong>contrasea de recuperacin</strong> que desbloquea tu monedero. Esta contrasea no se puede cambiar ms tarde.",
    description5: "Se realizar una copia de seguridad del monedero que creaste en un archivo de la tarjeta micro SD proporcionada. Esto se puede usar en una emergencia para recuperar tus fondos usando tu <strong>contrasea de recuperacin</strong>.",
    title: "Informacin de seguridad"
  },
  restore: {
    description1: "Se te pedir que insertes la tarjeta micro SD que utiliz para guardar su copia de seguridad.",
    description2: "Para recuperar tu dispositivo necesitars tu contrasea de recuperacin. ",
    description3: "Por favor ten cuidado al ingresar la contrasea de recuperacin. Cualquier contrasea que ingreses crear un monedero vlida. Si introduces la contrasea incorrecta, es posible que ves un saldo del monedero que no esperas.",
    title: "Informacin de seguridad"
  }
};
const seed$3 = {
  agreements: {
    "funds-access": "NO podr acceder a mis fondos si olvido mi contrasea de recuperacin",
    "password-change": "NO puedo cambiar la contrasea de recuperacin ms tarde",
    "password-required": "La contrasea de recuperacin es necesaria para restaurar un monedero desde una copia de seguridad"
  },
  create: "Crea monedero",
  creating: "Creando monedero",
  description: "Entiendo que:",
  error: {
    e102: "La contrasea debe contener al menos 4 caracteres.",
    e200: "Debe insertar una tarjeta micro SD en su BitBox para crear un mondero, de modo que se pueda crear una copia de seguridad automticamente."
  },
  info: {
    button: "Establecer contrasea de recuperacin ahora",
    description1: "Inserta la tarjeta micro SD en el BitBox",
    description2: 'Elija una contrasea de recuperacin para el monedero y seleccione "Establecer contrasea de recuperacin ahora"',
    description3: "La copia de seguridad en la tarjeta micro SD y su contrasea de recuperacin es el nico mtodo para recuperar sus fondos en caso de prdida o robo del dispositivo BitBox.",
    description4: "No puede cambiar su contrasea de recuperacin ms adelante sin transferir sus fondos.",
    title: "Crear una cartera nueva"
  },
  password: {
    label: "Contrasea de recuperacin",
    repeatPlaceholder: "Repita la contrasea de recuperacin"
  },
  walletName: {
    label: "Nombre del monedero"
  }
};
const seedRestore$3 = {
  error: {
    e200: "La recuperacin de un monedero a partir de una copia de seguridad requiere la tarjeta micro SD."
  },
  info: {
    description1: 'Inserta la tarjeta micro SD en el BitBox y haga clic en "Continuar"',
    description2: 'Elija una copia de seguridad y haga clic en "Restablecer"',
    description3: "Ingresa la contrasea de recuperacin",
    description4: "Debes confirmar para entender que una contrasea incorrecta crear una cartera diferente.",
    title: "Cmo restaurar un monedero desde una copia de seguridad"
  }
};
const send$5 = {
  abort: "La transaccin ha sido cancelada.",
  address: {
    label: "Direccin del receptor",
    placeholder: "Introduce direccin!"
  },
  amount: {
    label: "Cantidad",
    placeholder: "Introduzca la cantidad"
  },
  availableBalance: "Saldo disponible",
  button: "Revisar ",
  coincontrol: {
    address: "Direccin",
    outpoint: "Anotar",
    title: "Enviar desde salida"
  },
  confirm: {
    "selected-coins": "Monedas seleccionadas",
    title: "Confirma y enva la transaccin",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que no tiene suficiente Ether para pagar esta transaccin ERC20. Por favor, asegrese de que tiene suficiente Ether en su wallet.",
    feeTooLow: "La tarifa de red es demasiado baja",
    feesNotAvailable: "No se pueden estimar las tarifas de red",
    insufficientFunds: "fondos insuficientes",
    invalidAddress: "direccin invlida",
    invalidAmount: "Cantidad invlida",
    invalidData: "Datos invlidos"
  },
  fee: {
    customPlaceholder: "Introduzca la cantidad",
    label: "Tarifa de red",
    placeholder: "No disponible"
  },
  feeTarget: {
    customLabel: "Tarifa de red",
    customLabel_eth: "Precio del Gas",
    description: {
      economy: "24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)",
      economy_eth: "30 minutos o menos",
      economy_ltc: "1 hora (24 bloques)",
      high: "2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)",
      high_eth: "30 segundos o menos",
      high_ltc: "5 minutos (2 bloques)",
      low: "12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)",
      low_eth: "5 minutos o menos",
      low_ltc: "30 minutos (12 bloques)",
      normal: "6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)",
      normal_eth: "2 minutos o menos",
      normal_ltc: "15 minutos (6 bloques)"
    },
    estimate: "Tiempo de espera estimado:",
    label: {
      custom: "A medida",
      economy: "Econmico",
      high: "Alto",
      low: "Bajo",
      normal: "Normal"
    },
    placeholder: "Calculando la tarifa de red..."
  },
  maximum: "Enviar todo",
  maximumSelectedCoins: "Enviar monedas seleccionadas",
  noFeeTargets: "Las estimaciones de tarifas no estn disponibles actualmente. Vuelva a intentarlo ms tarde o introduzca una tarifa personalizada.",
  priority: "Prioridad",
  scanQR: "Escanear cdigo QR",
  signprogress: {
    description: "Esta es una transaccin que contiene una gran cantidad de datos. Para firmar en su totalidad la transaccin, se le pedir que confirme {{steps}} veces.",
    label: "En curso"
  },
  success: "La transaccin ha sido firmada y enviada.",
  title: "Enva {{accountName}}",
  toggleCoinControl: "Activar/Desactivar control de monedas/UTXO",
  transactionDetails: "Detalles de la transaccin"
};
const settings$4 = {
  about: "Acerca de",
  accounts: "Cuentas",
  advancedSettings: "Configuracin avanzada",
  appearance: "Apariencia",
  electrum: {
    add: "Aadir un servidor",
    "add-server": "Aadir",
    check: "Comprobar",
    checkFailed: "Fall",
    checkSuccess: "La conexin establecida con xito a {{host}}",
    checking: "Comprobacin",
    "download-cert": "Descarga certificado remoto",
    "remove-server": "Elimina",
    removeConfirm: "Eliminar {{server}}?",
    reset: "Restablecer a predeterminados",
    resetConfirm: "Desea eliminar todos los servidores e instalar los servidores predeterminados?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Introduzca el punto final.",
    step2: "2",
    "step2-text": "Introduzca un certificado de la cadena de certificados del servidor. Alternativamente, descarga el certificado remoto y comprelo visualmente.",
    "step2-text-tcp": "Puedes omitir este paso si no quieres utilizar TLS.",
    step3: "3",
    "step3-text": "Comprueba la conexin y aade el servidor.",
    step4: "4",
    "step4-text": "Reinicia el monedero. Si no eliminas los servidores predeterminados, tu propio nodo se agregar como redundancia.",
    "title-btc": "Servidores de Bitcoin Electrum",
    "title-ltc": "Servidores de Litecoin Electrum",
    "title-tbtc": "Servidores de Bitcoin Testnet Electrum",
    "title-tltc": "Servidores de Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activa control de monedas",
    electrum: {
      description: "Puedes conectarte a tu propio nodo Electrum completo.",
      title: "Conecta tu propio nodo completo"
    },
    fee: "Activar tarifas de red personalizadas",
    setProxyAddress: "Establece direccin proxy",
    title: "Configuracin avanzada",
    useProxy: "Activar tor proxy",
    useSats: "Mostrar valores BTC en Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nueva actualizacin disponible",
    title: "Informacin",
    "up-to-date": "Su aplicacin est actualizada",
    version: "Versin del App"
  },
  restart: "Por favor, reinicia la BitBoxApp para que los cambios tengan efecto.",
  services: {
    title: "Servicios"
  },
  success: "Por favor desenchufa y vuelva a enchufar el BitBox para que los cambios surjan efecto.",
  title: "Ajustes"
};
const setup$3 = "Dispositivo de configuracin";
const sidebar$4 = {
  buy: "Compra criptomoneda",
  device: "Administra dispositivo",
  insurance: "Seguro",
  leave: "Salir",
  settings: "Ajustes"
};
const success$a = {
  create: {
    info1: "Su monedero se ha respaldado de manera segura en la tarjeta micro SD. Retrelo y gurdalo en un lugar seguro. ",
    info2: "Has creado una contrasea de dispositivo seguro que desbloquea el BitBox.",
    info3: "Has creado una contrasea de recuperacin segura para su monedero que desbloquea sus fondos y recupera sus copias de seguridad.",
    summary: "Aqu hay un resumen de lo que has hecho.",
    title: "xito"
  },
  getstarted: "Empieza",
  restore: {
    summary: "Has restaurado con xito un monedero de su copia de seguridad.",
    title: "xito"
  }
};
const transaction$4 = {
  confirmation: "Confirmaciones",
  details: {
    activity: "Actividades",
    address: "Direccin",
    amount: "Cantidad",
    date: "Fecha",
    fiat: "Fiat",
    fiatAmount: "Cantidad Fiat",
    fiatAtTime: "Fiat en el momento de la transaccin",
    status: "Estado",
    title: "Detalles de la transaccin",
    type: "Tipo"
  },
  explorer: "ID de transaccin",
  explorerTitle: "Abrir en el bloque externo Explorer",
  fee: "Tarifa de red",
  fiatHistorical: "Historial",
  gas: "Gas",
  note: {
    edit: "Edita nota",
    save: "Guarda nota"
  },
  pending: "Transaccin pendiente",
  size: "Tamao",
  status: {
    complete: "Acabado",
    failed: "Fall",
    pending: "Pendiente"
  },
  tx: {
    received: "Recibido a",
    sent: "Enviado a"
  },
  vsize: "Tamao virtual",
  weight: "Peso"
};
const transactions$3 = {
  errorLoadTransactions: "Se ha producido un error al cargar las transacciones",
  placeholder: "Sin transacciones todava."
};
const unknownError$3 = "Ocurri un error desconocido: {{errorMessage}}";
const unlock$3 = {
  description: "Ingresa la contrasea de tu dispositivo para desbloquear el dispositivo.",
  error: {
    e109_normal: "Contrasea incorrecta del dispositivo. {{remainingAttempts}} intentos permanecen antes de que el dispositivo se reinicie.",
    e109_touch: "$t(unlock.error.e109_normal) El siguiente inicio de sesin requiere mantener presionado el botn tctil.",
    e113: "Debido a muchos intentos de inicio de sesin, el siguiente inicio de sesin requiere mantener presionado el botn tctil durante 4 segundos."
  },
  input: {
    label: "Contrasea del dispositivo",
    placeholder: "Ingresa la contrasea de tu dispositivo para desbloquear el dispositivo"
  },
  unlocking: "Desbloqueando..."
};
const upgradeFirmware$4 = {
  button: "Actualizacin de firmware",
  description: "Quieres actualizar el Firmware de la versin {{currentVersion}} a {{newVersion}}?",
  label: "Se requiere una actualizacin de firmware para tu BitBox.",
  locked: "Para actualizar desde {{currentVersion}} a {{newVersion}}, por favor haz un toque largo.",
  title: "Actualizacin de firmware",
  unlocked: "El gestor de arranque est desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecta y vuelva a conectar su Bitbox",
  unlocked2: "El LED se encender cuando su BitBox se vuelva a enchufar.",
  unlocked3: "Toque el botn tctil cuando el LED se encienda"
};
const walletConnect$4 = {
  connect: {
    button: "Conectar",
    dappLabel: "Introduzca la direccin URI de la aplicacin ",
    invalidPairingUri: "Uri de emparejamiento no vlido"
  },
  dashboard: {
    allSessions: "Todas las sesiones",
    disclaimer: "Walletconnect es un protocolo para conectarse a dapps basadas en Ethereum. Estas dapps estn gestionadas por servicios de terceros, as que conctate solo a dapps en las que confes y asegrate de saber siempre lo que ests firmando al realizar una transaccin.",
    newConnection: "Nueva conexin",
    noConnectedSessions: "Actualmente no hay cuentas conectadas a ninguna dapps."
  },
  invalidPairingChain: "Error al aprobar el emparejamiento. Asegrese de utilizar una de las cadenas admitidas: {{cadenas}}",
  pairingRequest: {
    approve: "Aprobar conexin",
    reject: "Rechazar",
    title: "Nueva solicitud de conexin de"
  },
  pairingSuccess: "Dapp conectada con xito. Puede continuar en el sitio web de la dapp.",
  signingRequest: {
    account: "Cuenta",
    chain: "Cadena",
    dapp: "Dapp",
    data: "Datos",
    dataParsingError: "Error al analizar los datos",
    decodeError: "No se ha podido descodificar el mensaje",
    method: {
      sendTransaction: "Firmar y enviar la transaccin",
      signMessage: "Firmar el mensaje",
      signTransaction: "Firmar la transaccin",
      signTypedData: "Firmar los datos escritos"
    },
    successfullySigned: "Solicitud firmada con xito",
    walletConnectRequest: "Solicitud de WalletConnect"
  },
  useNewUri: "Este URI ya ha sido utilizado para intentar una conexin. Por favor, utilice un nuevo URI.",
  walletConnect: "WalletConnect"
};
const warning$9 = {
  receivePairing: "Por favor, sincroniza el BitBox para activar la verificacin segura de la direccin. Ve a 'Administrar dispositivo' en la barra lateral.",
  sdcard: "Manten la tarjeta micro SD guardada aparte del BitBox, a menos que desee administrar las copias de seguridad.",
  sendPairing: "Por favor, sincroniza el BitBox para verificar con seguridad los detalles de la transaccin. Vaya a 'Administrar dispositivo' en la barra lateral."
};
const welcome$3 = {
  connect: "Conecta tu BitBox02",
  getStarted: "Vamos a comenzar instalando el firmware en su BitBox02.",
  insertBitBox02: "Si ests usando BitBox02, por favor toca el dispositivo para continuar.",
  insertDevice: "Por favor conecta tu dispositivo para comenzar",
  title: "Bienvenido"
};
const appTranslationsES = {
  account: account$3,
  accountInfo: accountInfo$3,
  accountSummary: accountSummary$3,
  addAccount: addAccount$4,
  aopp: aopp$2,
  app: app$3,
  auth: auth$3,
  backup: backup$3,
  bb02Bootloader: bb02Bootloader$3,
  bitbox: bitbox$3,
  bitbox02Interact: bitbox02Interact$3,
  bitbox02Settings: bitbox02Settings$3,
  bitbox02Wizard: bitbox02Wizard$3,
  bitsurance: bitsurance$2,
  bitsuranceAccount: bitsuranceAccount$2,
  blink: blink$3,
  bootloader: bootloader$3,
  button: button$8,
  buy: buy$4,
  changePin: changePin$3,
  chart: chart$4,
  checkSDcard: checkSDcard$3,
  clickHere: clickHere$3,
  confirm: confirm$5,
  confirmOnDevice: confirmOnDevice$3,
  connectKeystore: connectKeystore$3,
  darkmode: darkmode$3,
  device: device$3,
  deviceLock: deviceLock$3,
  deviceSettings: deviceSettings$3,
  deviceTampered: deviceTampered$3,
  dialog: dialog$4,
  error: error$4,
  fiat: fiat$5,
  footer: footer$5,
  generic: generic$4,
  genericError: genericError$3,
  goal: goal$3,
  guide: guide$4,
  headerssync: headerssync$3,
  hiddenWallet: hiddenWallet$3,
  initialize: initialize$3,
  invalidFormat: invalidFormat$3,
  language: language$4,
  legacyhiddenwallet: legacyhiddenwallet$3,
  loading: loading$3,
  manageAccounts: manageAccounts$2,
  mobile: mobile$3,
  newSettings: newSettings$2,
  note: note$4,
  notification: notification$3,
  pairing: pairing$3,
  passphrase: passphrase$2,
  password: password$3,
  random: random$4,
  receive: receive$5,
  reset: reset$3,
  securityInformation: securityInformation$3,
  seed: seed$3,
  seedRestore: seedRestore$3,
  send: send$5,
  settings: settings$4,
  setup: setup$3,
  sidebar: sidebar$4,
  success: success$a,
  transaction: transaction$4,
  transactions: transactions$3,
  unknownError: unknownError$3,
  unlock: unlock$3,
  upgradeFirmware: upgradeFirmware$4,
  walletConnect: walletConnect$4,
  warning: warning$9,
  welcome: welcome$3
};
const account$2 = {
  disconnect: "Povezava je prekinjena. Poizkuam ponovno...",
  "export": "Izvoz",
  exportTransactions: "Izvozite transakcije v CSV datoteko in odloite v lokalno mapo.",
  fatalError: "Ups, nepriakovana napaka",
  incoming: "Dohodni",
  initializing: "Pridobivam podatke iz verige blokov...",
  insuranceExpired: "<strong>Raun ni ve zavarovan</strong>\n\nZavarovanje za ta raun je bilo spremenjeno. Za ve informacij, prosimo preverite stran o zavarovanju.",
  insured: "Zavarovan raun",
  maybeProxyError: "Tor proxy omogoen. Prepriajte se, da Tor proxy deluje pravilno, ali onemogoite proxy.",
  reconnecting: "Povezava je prekinjena, poizkuam s ponovno vzpostavitvijo...",
  syncedAddressesCount: "Preteto t. naslovov: {{count}}",
  uncoveredFunds: "Kovance imate na naslednjih nezavarovanih vrstah naslovov vaega rauna <strong>{{name}}</strong>: {{uncovered}}. \nKer je raun zavarovan, so zajeti samo kovanci, prejeti preko naslova <strong>Native Segwit</strong>. Kovanci na ostalih vrstah naslovov, tudi e so na istem raunu, niso zavarovani.\nPredlagamo, da premaknete vse kovance z nepodprtih tipov naslova na <strong>Native Segwit</strong> naslov, da bodo vsi kovanci na tem raunu zavarovani. Hvala!",
  uncoveredFundsLink: "Za premik kovancev sledite temu navodilu.",
  warning: "Pozor!"
};
const accountInfo$2 = {
  address: "Naslov",
  buyCTA: {
    buy: "Kupi",
    buyCrypto: "Kupi kripto",
    information: {
      looksEmpty: "Denarnica je prazna.",
      start: "Zanite tako, da poljete nekaj kovancev v denarnico ali jih kupite neposredno v aplikaciji BitBoxApp."
    }
  },
  extendedPublicKey: "Razirjen javni klju",
  label: "Podatki o raunu",
  scriptType: "Tip skripte",
  title: "Podatki o raunu",
  verify: "Potrdi na napravi",
  xpubTypeChangeBtn: {
    p2pkh: "Ogled razirjenega javnega kljua P2PKH",
    p2tr: "Oglejte Taproot",
    p2wpkh: "Ogled Native Segwit",
    "p2wpkh-p2sh": "Ogled razirjenega javnega kljua P2SH"
  },
  xpubTypeInfo: "Prikazan je {{scriptType}} razirjen javni klju ({{current}} od {{numberOfXPubs}})"
};
const accountSummary$2 = {
  availableBalance: "Razpololjivo stanje",
  balance: "Stanje",
  exportSummary: "Izvozi povzetek rauna v mapo za prenos, kot datoteko CSV",
  fiatBalance: "Stanje v fiat valuti",
  name: "Ime rauna",
  noAccount: "Ni raunov za prikaz.",
  subtotalWithCoinName: "Skupaj ({{coinName}})",
  title: "Moj portfelj",
  total: "Skupaj",
  transactionHistory: "Zgodovina transakcij"
};
const addAccount$3 = {
  chooseName: {
    nextButton: "Dodaj raun",
    step: "Poimenuj raun",
    title: "Poimenuj raun"
  },
  selectCoin: {
    nextButton: "Naprej",
    step: "Izberi kovanec",
    title: "Izberi kriptovaluto"
  },
  success: {
    addAnotherAccount: "Dodajte nov raun",
    message: "<strong> {{accountName}} </strong> je zdaj dodan med vae raune.",
    nextButton: "OK",
    step: "Zaklljueno",
    title: "Raun dodan"
  },
  title: "Dodajte raun"
};
const aopp$1 = {
  addressRequest: "{{host}} zahteva naslov prejemnika.",
  addressRequestWithLogo: "zahteva naslov prejemnika",
  banner: "Zahteva po naslovu je v teku. Priklopite BitBox02 za nadaljevanje.",
  errorTitle: "Napaka med zahtevo za naslov",
  labelAddress: "Naslov",
  labelMessage: "Sporoilo",
  reverifyInfoText: "Potrdite naslov",
  signing: "Za nadaljevanje podpiite sporoilo na napravi",
  success: {
    message: "Nadaljujte na {{host}}",
    title: "Naslov uspeno poslan"
  },
  syncing: "Poakajte trenutek, poteka sinhronizacija rauna.",
  title: "Zahteva za naslov"
};
const app$2 = {
  upgrade: "Na voljo je nova verzija te aplikacije! Prosimo vas, da jo nadgradite iz verzije  {{current}} na {{version}}."
};
const auth$2 = {
  authButton: "Potrdi",
  title: "Za nadaljevanje potrdite"
};
const backup$2 = {
  check: {
    checking: "Preverjam varnostno kopijo...",
    confirmTitle: "Preverite varnostno kopijo",
    notOK: "Varnostna kopija se NE ujema s trenutno denarnico.",
    ok: "Varnostna kopija se ujema z denarnico.",
    password: {
      label: "Geslo za obnovo varnostne kopije",
      placeholder: "Geslo za obnovo varnostne kopije",
      showLabel: "geslo za obnovo varnostne kopije"
    },
    success: "Varnostna kopija uspeno preverjena:",
    title: "Preverite varnostno kopijo"
  },
  create: {
    alreadyExists: "Veljavno varnostno kopijo e imate. Ali jo ponovno elite ustvariti?",
    fail: "Ustvarjanje varnostne kopije NI uspelo!",
    info: "Prosimo vnesite geslo za obnovo trenutne denarnice za potrditev.",
    name: {
      label: "Ime varnostne kopije",
      placeholder: "Poimenujte varnostno kopijo"
    },
    password: {
      label: "Obnovitveno geslo",
      placeholder: "Prosimo vnesite obnovitveno geslo"
    },
    title: "Ustvarite varnostno kopijo - backup",
    verificationFailed: 'Obnovitveno geslo se NE ujema s trenutno denarnico. Varnostna kopija je bila ustvarjena. Prosimo uporabite "Preverite varnostno kopijo" da potrdite geslo za obnovo.'
  },
  description: "Izberite <strong>datoteko z varnostno kopijo denarnice</strong>",
  insert: "Prosimo vstavite microSD kartico za upravljanje z varnostnimi kopijami.",
  insertButton: "Vstavil sem microSD kartico",
  list: "Varnostne kopije na microSD kartici",
  noBackups: "Na tej microSD kartici ni varnostnih kopij.",
  restore: {
    confirmTitle: "Obnovite varnostno kopijo",
    error: {
      e200: "MicroSD kartica ni bila zaznana",
      general: "Napaka pri obnovitvi varnostne kopije"
    },
    password: {
      label: "Geslo za obnovitev ali skrito geslo za obnovitev varnostne kopije",
      placeholder: "Geslo za obnovitev",
      repeatPlaceholder: "Ponovite geslo za obnovitev",
      showLabel: "Geslo za obnovitev"
    },
    restoring: "Obnavljanje varnostne kopije ...",
    selectedBackup: "<strong>{{backupName}}</strong> ustvarjen {{createdDateTime}} bo obnovljen.",
    title: "Obnovi",
    understand: "Razumem, da bo nepravilno geslo za obnovitev ustvarilo drugo, novo denarnico"
  },
  showMnemonic: {
    description: "Na BitBox02 se bodo izpisale besede, ki tvorijo varnostno kopijo denarnice. Zapiite jih na papir.\n\n<strong>Ne hranite jih digitalno in ne fotografirajte jih!</strong>\n\n<strong>Ne izgovarjajte besed na glas.</strong>\n\n<strong>Ta varnostna kopija ni zaitena z geslom.</strong>\n\nPo konanem prikazu besed boste morali vsako e potrditi na napravi.",
    title: "Prikai seznam besed",
    warning: "<strong>Nikoli ne delite obnovitvenih besed z nikomer.</strong> Te besede omogoajo popoln dostop do vae denarnice. e vas kdo sprauje po teh besedah, gre zelo verjetno za prevaro. Ne delite jih z neznanci!"
  },
  title: "Upravljanje varnostnih kopij"
};
const bb02Bootloader$2 = {
  abort: "Ne nadgradi - vrni me nazaj",
  abort_noUpgrade: "Vrni me nazaj",
  advanced: {
    label: "Napredne nastavitve",
    toggleShowFirmwareHash: "Ob zagonu vedno prikai binarno vrednost strojne programske opreme (firmware hash)"
  },
  flipscreen: "Obrnite sliko na zaslonu",
  orientation: "Je zaslon na napravi obrnjen v napano smer?",
  success: "Nadgradnja uspena! Nadaljevanje v {{rebootSeconds}} sekundah...",
  success_install: "Namestitev uspena! Nadaljevanje v {{rebootSeconds}} sekundah..."
};
const bitbox$2 = {
  error: {
    e10000: "Trenutno geslo naprave je napano.",
    e10001: "Gesla naprave ni bilo mogoe zamenjati",
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e112: "Geslo skrite denarnice ne more biti enako kot geslo glavne denarnice."
  }
};
const bitbox02Interact$2 = {
  confirmDate: "Potrdite dananji datum na BitBox02",
  confirmDateText: "Vneen datum bo uporabljen za kreiranje varnostne kopije.",
  confirmName: "Potrdite ime na zaslonu BitBox02",
  confirmWords: "Zapiite si {{amount}} obnovitvenih besed iz vaega BitBoxa",
  confirmWordsText: "Po tem koraku BitBox02 zahteva potrditev vsake besede na zaslonu, da se prepriate, da ste varnostno kopijo zapisali pravilno.",
  followInstructions: "Prosimo upotevajte navodila na zaslonu naprave.",
  followInstructionsMnemonic: "Upotevajte navodila za obnovitev iz seznama besed na napravi in obnovite denarnico.",
  followInstructionsMnemonicTitle: "Obnovi iz seznama besed"
};
const bitbox02Settings$2 = {
  deviceName: {
    current: "Trenutno ime naprave",
    error: "Imena naprave ni bilo mogoe nastaviti",
    error_104: "Potrditev imena je bilo prekinjeno na napravi",
    input: "Novo ime",
    placeholder: "Novo ime naprave",
    title: "Nastavite ime tej napravi"
  },
  gotoStartupSettings: {
    description: "To bo znova zagnalo va BitBox02 in zaelo nastavitev zagona.",
    title: "Pojdite na zaetne nastavitve"
  }
};
const bitbox02Wizard$2 = {
  advanced: {
    button: "Napredne monosti",
    outOfDate: "Strojna programska oprema (firmware) je prestara za to funkcijo",
    seed12WordInfo: "tevilo besed kasneje ni mono spremeniti.",
    seed12WordLabel: "Ustvari 12 besedno seme namesto 24 besednega",
    seed12WordText: "BitBox privzeto uporablja 24 besedno seme. Na voljo je tudi 12 besedno seme. Obe podprti dolini semena sta dovolj varni proti strojnemu uganjevanju (brute force). ",
    skipSDCardLabel: "Ne ustvari varnostne kopije na micro SD kartico ampak prikai semenske besede",
    skipSDCardText: "Kasneje lahko vedno ustvarite varnostno kopijo na micro SD kartico ali ponovno prikaete semenske besede. To opcijo najdete v Nastavitvah.",
    title: "Napredne monosti arhivske kopije"
  },
  attestationFailed: "Preverjanje ni uspelo, kar je lahko posledica ponovnega zagona aplikacije, medtem ko je naprava akala na uporabniki vnos (dotik). Napravo znova vklopite in poskusite znova. e teava ne izgine, se obrnite na support@bitbox.swiss (v angleini).",
  backup: {
    point1: "Izberite varnostno kopijo na microSD kartici",
    point2: "Nastavite geslo za svojo napravo",
    restoreText: "Ok, obnovimo varnostno kopijo!",
    text1: "Super, vae geslo za BitBox02 je zdaj nastavljeno in denarnica je ustvarjena. Zdaj je as, da ustvarite prvo varnostno kopijo. Prepriajte se, da je microSD kartica vstavljena v BitBox02 in nato nadaljujte.",
    text2: "e elite ustvariti varnostno kopijo, sledite navodilom na zaslonu naprave.",
    text3: "Ko ustvarite varnostno kopijo, odstranite microSD kartico in jo shranite na <strong>varno lokacijo</strong>. Vsebina kartice ni zaitena z geslom. Nikoli je ne vstavite v nobeno drugo napravo, razen v va BitBox02.",
    userConfirmation1: "Varnostno kopijo je potrebno hraniti na varnem mestu",
    userConfirmation2: "Moja varnostna kopija ni zaitena z geslom. Vsak, ki ima dostop do nje, lahko dostopa do moje denarnice.",
    userConfirmation3: "e izgubim ali pokodujem svoj BitBox02, je edini nain, da povrnem svoja sredstva, obnovitev iz varnostne kopije.",
    userConfirmation4: "e izgubim ali pokodujem tako varnostno kopijo kot svoj BitBox02, so moja sredstva izgubljena.",
    userConfirmation5: "Ustvarjeno varnostno kopijo na microSD kartici ne smem vtakniti v PC, telefon, tiskalnik ali katero koli drugo napravo razen v BitBox02.",
    userConfirmation5mnemonic: "Semenskih besed NE bom vpisoval v raunalnike, telefone, tablice ali katere koli druge naprave, kot le v BitBox02."
  },
  create: {
    button: "Poimenujte napravo in nadaljujte",
    info: "To so osnovni koraki, ki jih boste izvedli za nastavitev BitBoxa: ",
    inputTitle: "Ime denarnice",
    point1: "Poimenujte napravo",
    point2: "Izberite si geslo za svojo napravo",
    point3: "Ustvarite varnostno kopijo",
    text: "Ok, pa ustvarimo novo denarnico!"
  },
  createBackupAborted: "Kreiranje varnostne kopije je prekinjeno.",
  createBackupFailed: "Ustvarjanje varnostne kopije ni uspelo, poskusite znova.",
  initialize: {
    passwordText: "Zdaj pa doloite geslo za vao napravo. Za vnos in izbiro gesla uporabite kontrolne drsnike na BitBoxu.",
    passwordTitle: "Nastavite geslo za va BitBox",
    text: "Seznanjanje je bilo uspeno! Zdaj pa pripravimo vao napravo. Zanite z ustvarjanjem nove denarnice ali obnovitvijo denarnice iz obstojee varnostne kopije. <strong>Prepriajte se, da imate v BitBox02 vstavljeno microSD kartico </strong>",
    tip: "Priporoamo vam, da te postopke opravite v varnem in zasebnem okolju.",
    title: "Zaenite in nastavite BitBox02"
  },
  insertSDCard: "<strong>Prepriajte se, da imate v BitBox02 vstavljeno microSD kartico.</strong>",
  noPasswordMatch: "Gesli se nista ujemali. Poskusite znova.",
  pairing: {
    failed: "Seznanjanje je bilo prekinjeno. Ponovno priklopite BitBox02.",
    paired: "Na napravi ste potrdili, da se koda ujema. Prosimo nadaljujte.",
    title: "Potrditev seznanitvene kode",
    unpaired: "Zaznana je bila nova BitBox02 naprava. Preverite, ali se prikazana koda ujema s tisto na zaslonu naprave."
  },
  restoreFromMnemonic: {
    e104: "Ponastavitev iz semenskih besed je bilo ustavljeno.",
    failed: "Obnova iz seznama besed ni uspela. Poskusite znova."
  },
  stepBackup: {
    beforeProceed: "Pred nadaljevanjem preberite naslednje pomembne varnostne vidike:",
    createBackup: "Zdaj boste ustvarili varnostno kopijo na microSD kartici .",
    createBackupMnemonic: "Zdaj zapiite semenske besede na papir ali jeklo"
  },
  stepBackupSuccess: {
    fundsSafe: "e elite ohraniti sredstva varna, upotevajte naslednje:",
    title: "Varnostna kopija obnovljena!"
  },
  stepConnected: {
    unlock: "Vnesite izbrano geslo, kot ponazarja video"
  },
  stepCreate: {
    description: "To bo ime naprave in varnostne kopije.",
    error: {
      genericMessage: "Uporabite rke, tevilke, osnovne simbole, presledke. Najve 30 znakov.",
      invalidChars: "Ime vsebuje nepodprte znake: {{invalidChars}}.",
      tooLong: "Ime je predolgo."
    },
    nameLabel: "Vnesite eljeno ime naprave",
    namePlaceholder: "Moj BitBox02",
    title: "Izberite ime za va BitBox02",
    toastMicroSD: "Vstavite microSD kartico v BitBox02. Na njo bo zapisana varnostna kopija denarnice."
  },
  stepCreateSuccess: {
    removeMicroSD: "Odstranite microSD kartico z naprave in jo shranite na varno mesto.",
    storeMnemonic: "Predlagamo, da shranite te obnovitvene besede na varno lokacijo",
    success: "Uspeno ste ustvarili varnostno kopijo."
  },
  stepInsertSD: {
    insertSDCard: "Vstavite microSD kartico v BitBox02.",
    insertSDcardTitle: "Vstavite microSD kartico"
  },
  stepPassword: {
    e104: "Nastavitev gesla je bila prekinjena.",
    title: "Nastavite geslo za BitBox02",
    useControls: "S pomojo drsnikov na robu naprave si nastavite geslo."
  },
  stepUninitialized: {
    create: "elim postaviti nov BitBox02.",
    restore: "elim obnoviti denarnico iz varnostne kopije.",
    restoreMicroSD: "Obnovi iz microSD kartice",
    restoreMnemonic: "Obnovi iz seznama besed",
    title: "Nastavite svoj BitBox02"
  },
  success: {
    text: "Bravo! Va BitBox02 je zdaj pripravljen za uporabo.\n\nZa dodatne informacije o uporabi aplikacije BitBoxApp uporabite vodnik. Na voljo je s klikom na vpraaj v zgornjem desnem kotu.",
    title: "Zdaj ste pripravljeni za delo z BitBox denarnico!"
  }
};
const bitsurance$1 = {
  dashboard: {
    active: "Zavarovalna polica je aktivna",
    button: "Zavarujte nov raun",
    canceled: "Preklicano",
    coverage: "Najvije kritje",
    inactive: "Neaktivno",
    processing: "Obdelujem",
    refused: "Zavrnjeno",
    supportLink: "Upravljanje pogodbe",
    title: "Zavarovani rauni",
    waitpayment: "akamo plailo"
  },
  detect: {
    button: "Preveri trenutno zavarovanje",
    insured: "Zaznan zavarovan raun:",
    notInsured: "Ni zaznanih zavarovanih raunov. V kolikor ste prepriani, da imate zavarovane raune, preverite, da imate prikljueno pravo denarnico.",
    text: "V kolikor e imate sklenjeno zavarovanje z Bitsurance lahko BitBoxApp samodejno prenese vae obstojee kritje.",
    title: "Ste e zavarovani?"
  },
  insure: {
    button: "Preverite cene in razpololjivost",
    faq: "Preberite ve na Bitsurance FAQ",
    listItem1: "Vlom",
    listItem2: "Izsiljevanje (npr. napad z nevarnim predmetom)",
    listItem3: "Unienje zaradi poara, vode ali naravnih nesre",
    month: "mesec",
    text: "Zavarujte svoj BitBox02 in bitcoin v protivrednosti do 100.000 ",
    text2: "Zavarovanja e od 30  na leto (2,50  na mesec). Ve o zavarovalnici Bitsurance in njihovi natanni ponudbi zavarovanj preverite na ",
    text3: "Trenutno na voljo v Nemiji, kmalu pa bo tudi drugje.",
    title: "Zanite"
  },
  intro: {
    link: "Spletna stran Bitsurance",
    text1: "BitBox sodeluje z drubo Bitsurance, da vam lahko ponudimo dodatno zaito za va bitcoin. Medtem ko BitBox02 varuje vaa sredstva, Bitsurance krije gronje na domu, ki jih ni mogoe ublaiti samo s tehnologijo, kot so vlom, izsiljevanje ali unienje same strojne denarnice."
  },
  terms: {
    link: "Politika zasebnosti Bitsurance",
    text1: "Bitsurance je neodvisna storitev od BitBoxa. Za vpraanja v zvezi z njihovo ponudbo in zavarovalnimi zahtevki se vedno obrnite neposredno na Bitsurance.",
    text2: "Zavarovanje je trenutno na voljo le v Nemiji, v drugih dravah pa bo na voljo kasneje.",
    text3: "Najvije trenutno razpololjivo kritje Bitcoina je 100.000  na osebo. Viji zneski bodo morda na voljo kasneje.",
    text4: "Osebni podatki in razirjeni javni klju vaega zavarovanega rauna so del zavarovalne police in bodo posredovani zavarovalnici Bitsurance in ponudniku zavarovanja.",
    text5: "Za ve informacij o zasebnosti se obrnite na"
  },
  title: "Zavarovanje"
};
const bitsuranceAccount$1 = {
  errorNoXpub: "Napaka: xpub-a ni bilo mogoe pridobiti iz rauna.",
  noAccount: "Ni raunov, ki bi jih bilo mogoe zavarovati.",
  select: "Izberite raun",
  title: "Zavarovanje"
};
const blink$2 = {
  button: "Sproi utripanje na napravi"
};
const bootloader$2 = {
  button: 'Nadgradi "firmware"',
  button_install: "Namestite firmware",
  progress: "Nadgrajujem: {{progress}}%",
  progress_install: "Nameanje: {{progress}}%",
  success: "Nadgradnja uspena! Izkljuite in ponovno prikljuite napravo v USB reo. Tokrat se ne dotikajte gumba."
};
const button$7 = {
  abort: "Prekini",
  back: "Nazaj",
  buy: "Kupi",
  changepin: "Spremenite geslo naprave",
  check: "Preverite varnostno kopijo",
  "continue": "Nadaljujte",
  copy: "Kopiraj",
  create: "Ustvari",
  dismiss: "Zavrnite",
  done: "Potrdi izbiro",
  download: "Prenesi",
  hiddenwallet: "Ustvarite skrito denarnico",
  next: "Naprej",
  ok: "OK",
  previous: "Nazaj",
  receive: "Prejmi",
  restore: "Obnovi",
  select: "Izberite",
  send: "Polji",
  unlock: "Odklenite denarnico",
  update: "Osvei",
  upgrade: "Nadgradi"
};
const buy$3 = {
  exchange: {
    bankTransfer: "Banno nakazilo",
    bestDeal: "Najbolja ponudba",
    creditCard: "Kreditna karica",
    fast: "Hitro",
    fee: "provizija",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Banno nakazilo: {{fee}}%",
          creditDebitCard: "Kreditna/debetna kartica: {{fee}}%",
          learnMore: "Ve o storitvi MoonPay",
          title: "Provizije"
        },
        fullCurrenciesList: "Tu je na voljo seznam vseh valut",
        payment: {
          asteriskText: "* Ni na voljo za rezidente ZDA",
          bankTransfer: "Banno nakazilo*",
          bankTransferDetails: {
            pix: "PIX (BR transakcije, samo v Braziliji)",
            sepa: "SEPA in SEPA Instant (samo EUR transakcije v dravah SEPA)",
            uk: "UK Faster Payments (samo GBP transakcije v Zdruenem kraljestvu)"
          },
          creditDebitCard: "Kreditna/debetna kartica",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa in Maestro"
          },
          learnMore: "Oglejte si podrobnosti o nainih plaila",
          title: "Naini plaila"
        },
        supportedCurrencies: "Podpira vse glavne fiat valute: USD, EUR, CHF in druge"
      },
      pocket: {
        fees: {
          info: "Banno nakazilo: {{fee}}%",
          title: "Provizije"
        },
        learnMore: "Ve o storitvi Pocket",
        payment: {
          bankTransfer: "Banno nakazilo",
          bankTransferDetails: {
            sepa: "SEPA in SEPA instant (transakcije v EUR znotraj SEPA podprtih drav)",
            sic: "vicarska medbanna poravnava (samo za transakcije v CHF v CH/LIE)",
            uk: "UK Faster Payments (samo transakcije v GBP v UK)"
          },
          bankTransferReccuring: "Kako nastavimo ponavljajoe nakupe z enim naroilom?",
          title: "Naini plaila"
        },
        supportedCurrencies: "Podpira evropske valute: EUR, GBP in CHF",
        verification: {
          info: "Preverjanje identitete je zahtevano le nad dnevnim in letnim limitom.",
          link: "Trenutni limiti",
          title: "Preverjanje identitete"
        }
      },
      region: {
        title: "Izberite regijo, v kateri je registriran va banni raun, da vidite monosti, ki so vam na voljo."
      }
    },
    noExchanges: "V tej regiji al ni razpololjivih menjalnic.",
    region: "Regija",
    selectRegion: "Ni navedeno",
    title: "Kupi {{name}}"
  },
  info: {
    "continue": "Potrdi in nadaljuj",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "V sodelovanju z MoonPay vam ponujamo monost nakupa {{name}} neposredno znotraj BitBoxApp. S samo nekaj kliki.",
        "MoonPay je regulirana platforma za finanne storitve, ki omogoa preprost in hiter nakup {{name}} v ve kot 160 dravah"
      ],
      payment: {
        details: "{{name}} je mono kupiti takoj prek storitve MoonPay z naslednjimi naini plaila. Plaila s kreditno ali debetno kartico so takojnja in prirona, vendar draja. Za veje zneske priporoamo uporabo bannega nakazila. Minimalna pristojbina je 4 EUR.",
        footnote: "Menjalni teaji storitve MoonPay se lahko razlikujejo od tistih, ki se uporabljajo v BitBoxApp.",
        table: {
          "1_description": "Najnija provizija, lahko traja do 3 delovne dni",
          "1_method": "Banno nakazilo (SEPA)",
          "2_description": "Vija provizija a takojnja izvritev",
          "2_method": "Kreditna ali debetna kartica",
          description: "Opis",
          fee: "Provizija",
          method: "Nain plaila"
        },
        title: "Naini plaila in provizije"
      },
      privacyPolicy: "Politika zasebnosti storitve MoonPay",
      protection: {
        description: "BitBoxApp ne zbira nobenih podatkov ob nakupu preko MoonPay. \nPrilivi se obravnavajo in so prikazani kot obiajna transakcija. MoonPay za svoje delovanje zbira nekaj osebnih podatkov. Njihova politika zasebnosti podrobno pojasnjuje, kako ravna s temi podatki.",
        descriptionGeneric: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu {{name}}, vhodna sredstva se obravnavajo kot obiajna transakcija. Priakujemo, da morajo partnerske borze zbrati nekaj vaih informacij za njihovo poslovanje. Oglejte si njihove pravilnike o zasebnosti, da vidite kako postopajo z vaimi podatki.",
        title: "Zaita podatkov"
      },
      security: {
        description: "Za nakup {{name}} preko MoonPay uporabljate zunanjo storitev. Ta storitev ne sodi v obseg zaite, ki jo nudi BitBox02 in temelji na varnosti in zaiti okolja, v katerem deluje programska oprema BitBoxApp.",
        descriptionGeneric: "Pojasnilo: Ko uporabite partnerske menjalnice za nakup {{name}}, uporabljate zunanjo storitev. Le-ta ni del nae varnostne politike in ni del zaite, ki jo ponuja BitBox02 temve je odvisna od okolja (operacijski sistem, omreje) na katerem uporabljate BitBoxApp.",
        link: "Ve o varni uporabi",
        title: "Model varnostnega sistema"
      },
      title: "Dobrodoli! Ste na pravem na mestu za nakup {{name}}"
    },
    next: "Naprej",
    selectLabel: "Izberite svoj raun",
    selectPlaceholder: "Izberi kovanec",
    skip: "Ne prikazuj ve",
    title: "Kupi  {{name}}"
  },
  pocket: {
    data: {
      link: "Varovanje zasebnosti storitve Pocket",
      p1: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu bitcoina, vhodna sredstva se obravnavajo kot obiajna transakcija. Pocket mora za svoje delovanje zbrati nekaj vaih osebnih podatkov. Njihov pravilnik o zasebnosti podrobno pojasnjuje, kako ravnajo s temi podatki.",
      title: "Varovanje podatkov"
    },
    kyc: {
      link: "Preberite FAQ (odgovore na pogosta vpraanja) storitve Pocket",
      p1: "Storitev Pocket skua tevilo postopkov za KYC (know-your-customer; prepoznavo kupca) opraviti v najmanji moni meri. Za nakupe pod 1000 CHF na dan dodatni dokumenti niso potrebni. Za nakupe nad tem zneskom se boste morali dogovoriti za klic z drubo Pocket, da opravite potreben postopek KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin lahko zelo hitro kupite s storitvijo Pocket z bannim nakazilom tipa SEPA. Provizija znaa 1,5 %, bitcoin pa se v vao denarnico nakae takoj, ko Pocket prejme vae banno nakazilo (obiajno v istem dnevu).",
      p2: "Upotevajte, da se lahko menjalni teaji v aplikaciji BitBoxApp razlikujejo od menjalnih teajev v aplikaciji Pocket, zaradi esar so zneski nekoliko drugani.",
      title: "Naini plaila in provizije"
    },
    previousTransactions: "Zgodovina transakcij tega rauna ni prazna. e boste ta raun delili, bodo vse pretekle in prihodnje transakcije na njem vidne storitvi Pocket. Ali vseeno nadaljujete?",
    security: {
      link: "Model varnosti in zaite BitBox02",
      p1: "Ob nakupu bitcoina preko storitve Pocket, uporabljate zunanjo storitev. Le-ta je izven zaite, ki jo nudi BitBox02. Varnost in zaita sta odvisna od okolja v katerem uporabljate BitBoxApp. \nSkupaj s storitvijo Pocket delujemo na nain, da z dvofaktorsko avtentikacijo preverjamo naslov na katerega prejemate bitcoin.",
      title: "Varnostni model storitve Pocket"
    },
    usedAddress: "Naslov {{address}} je bil e uporabljen. Prosimo zanite ponovno.",
    verifyBitBox02: "Preverite, ali se naslov, ki ste ga prejeli po e-poti, ujema z naslovom, prikazanim na napravi. e bolj varno je, da e-potno sporoilo odprete in preberete v drugi napravi, e je to mogoe.",
    welcome: {
      p1: "S storitvijo Pocket sodelujemo, da bi vam omogoili enostaven nain nakupa bitcoina neposredno v BitBoxApp. V le nekaj klikih.",
      p2: "Pocket je vicarska platforma ki omogoa hiter in enostaven nakup bitcoina v veini Evropskih drav.",
      p3: "S storitvijo Pocket lahko enostavno vzpostavite redni intervalni nakup bitcoina s pomojo rednih bannih nakazil. T.i. DCA (dollar-cost averaging) ",
      title: "Dobrodoli na pravem mestu za nakup bitcoinov"
    }
  },
  title: "Kupi {{name}}"
};
const changePin$2 = {
  newTitle: "Novo geslo naprave",
  oldLabel: "Trenutno geslo naprave"
};
const chart$3 = {
  dataMissing: "e vedno pridobivamo informacije. Poskusite znova ez nekaj minut. ii pa aki",
  dataOldTimestamp: "Nalagamo teaje. Graf ne prikazuje vrednosti po {{time}}.",
  dataUpdating: "posodabljam...",
  filter: {
    all: "Vse",
    month: "Mesec",
    week: "Teden",
    year: "Leto"
  }
};
const checkSDcard$2 = "preverjanje microSD kartice";
const clickHere$2 = "Kliknite tukaj.";
const confirm$4 = {
  abortInfo: "Hiter dotik za ",
  abortInfoRedText: "prekinitev",
  approveInfo: "Dotaknite se gumba za vsaj 4 sekunde ",
  approveInfoGreenText: " za potrditev",
  info: "Nadaljujte na BitBoxu.",
  infoWhenPaired: "Najprej na seznanjeni mobilni napravi in nato na BitBoxu"
};
const confirmOnDevice$2 = "Nadgradnjo potrdite na BitBox-u";
const connectKeystore$2 = {
  promptNoName: "Za nadaljevanje priklopite BitBox02",
  promptWithName: 'Za nadaljevanje priklopite va BitBox02 z imenom "{{name}}"'
};
const darkmode$2 = {
  toggle: "Temen nain"
};
const device$2 = {
  appUpradeRequired: "BitBox ni zdruljiv s to verzijo namizne aplikacije. Prenesite in namestite najnovejo razliico.",
  keystoreConnected: "Povezana denarnica"
};
const deviceLock$2 = {
  button: "Omogoite dvofaktorsko avtentikacijo (2FA)",
  condition1: "Imate varnostno kopijo?",
  condition2: "Ali deluje preverjanje v mobilni aplikaciji?",
  condition3: "2FA ONEMOGOA varnostne kopije in seznanjanje z mobilno aplikacijo. Naprava mora biti resetirana za izhod iz dvofaktorskega (2FA) naina!",
  confirm: "Omogoite dvofaktorsko avtentikacijo (2FA)",
  title: "Omogoite dvofaktorsko avtentikacijo (2FA)"
};
const deviceSettings$2 = {
  backups: {
    manageBackups: {
      description: "Prikai in preveri varnostno kopijo na Micro SD kartici."
    },
    showRecoveryWords: {
      description: "Prikai in potrdi semenske besede."
    },
    title: "Varnostne kopije"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp preverja, e je naprava avtentina."
    },
    deviceName: {
      description: "Spremenite ime naprave"
    },
    rootFingerprint: {
      description: "Korenski prstni odtis je unikaten identifikator denarnice, ki je trenutno v uporabi. e uporabljate frazemska gesla (passphrases), vam lahko pomaga pri razlikovanju med razlinimi denarnicami."
    },
    securechip: {
      description: "Model varnega ipa"
    },
    title: "Informacije o napravi"
  },
  expert: {
    factoryReset: {
      description: "Ponastavite napravo na tovarnike nastavitve. Ta postopek izbrie denarnico na BitBoxu!",
      title: "Tovarnika nastavitev"
    },
    goToStartupSettings: {
      description: 'Vstopite v nain "bootloader" na napravi. S tem lahko omogoite prikaz zgoene vrednosti strojne programske opreme (firmware hash).'
    },
    passphrase: {
      description: "Vklopi ali izklopi monost geselske fraze",
      title: "Geselska fraza"
    }
  },
  firmware: {
    firmwareVersion: "Razliica strojne programske opreme (firmware)",
    newVersion: {
      label: "Razpololjiva razliica"
    },
    title: "Verzija strojne programske opreme (firmware)",
    upToDate: "Vaa naprava je posodobljena",
    upgradeAvailable: "Na voljo je nova nadgradnja",
    version: {
      label: "Razliica"
    }
  },
  hardware: {
    attestation: {
      "false": "Preverjanje pristnosti ni uspelo",
      label: "Preverjanje pristnosti",
      "true": "BitBox02 je pristen!"
    },
    sdcard: {
      "false": "Ni vstavljena",
      label: "microSD kartica",
      "true": "Vstavljena"
    },
    securechip: "Verzija varnega ipa",
    title: "Naprava"
  },
  loading: "Pridobivam informacije o napravi ...",
  pairing: {
    lock: {
      "false": "Onemogoeno",
      label: "Dvo faktorska avtentikacija (2FA)",
      "true": "Omogoeno"
    },
    mobile: {
      "false": "Zaprto",
      label: "Mobilna aplikacija",
      "true": "Odpri"
    },
    status: {
      "false": "Ni uparjen",
      label: "Status",
      "true": "Uparjen"
    },
    title: "Seznanjanje (uparitev)"
  },
  secrets: {
    manageBackups: "Upravljanje varnostnih kopij",
    title: "Varnost"
  }
};
const deviceTampered$2 = "Ali ste prejeli BitBox skupaj z geslom za obnovitev?\ne je tako, takoj zaustavite postopek namestitve in stopite v stik z nami.\nShift nikoli ne izroa pred-pripravljene denarnice ali pred pripravljenih gesel.";
const dialog$3 = {
  cancel: "Nazaj",
  confirm: "Potrdite",
  confirmTitle: "Potrditev"
};
const error$3 = {
  accountAlreadyExists: "Ta raun e obstaja.",
  accountLimitReached: "Novega rauna ni mogoe dodati. Doseeno je najveje tevilo raunov za ta kovanec.",
  aoppCallback: "Napaka pri dostavi naslova do {{host}}.",
  aoppInvalidRequest: "Napana poizvedba",
  aoppNoAccounts: "Nobenega rauna ni na razpolago.",
  aoppSigningAborted: "Aopp postopek preklican",
  aoppUnknown: "Neznana napaka...",
  aoppUnsupportedAsset: "Izbrano sredstvo ni podprto.",
  aoppUnsupportedFormat: "Na voljo ni raunov, ki podpirajo zahtevano obliko naslova.",
  aoppUnsupportedKeystore: "Povezana naprava ne more podpisati sporoil za to sredstvo",
  aoppVersion: "Neznana razliica",
  keystoreTimeout: "as za vklop se je iztekel. Poizkusite ponovno.",
  wrongKeystore: "Prikljuena je napana denarnica. Vstavite pravo napravo BitBox02, ki ustreza temu raunu.",
  wrongKeystore2: "e uporabljate frazemsko geslo (passphrase), se prepriajte, da ste ga pravilno vnesli za ta raun."
};
const fiat$4 = {
  "default": "Privzeto",
  setDefault: "Nastavite {{code}} kot privzeto",
  title: "Valute"
};
const footer$4 = {
  appVersion: "Razliica aplikacije:"
};
const generic$3 = {
  enabled_false: "Onemogoeno",
  enabled_true: "Omogoeno"
};
const genericError$2 = "Pojavila se je napaka. e opazite kakrne koli teave, znova zaenite aplikacijo.";
const goal$2 = {
  buttons: {
    create: "Ustvarite novo denarnico",
    restore: "Obnovite denarnico iz varnostne kopije"
  },
  paragraph: "Izberite eno od naslednjih monosti:",
  step: {
    "1": {
      title: "Varnostne informacije"
    },
    "2": {
      description: "Ustvarite geslo naprave",
      title: "Naprava"
    },
    "3-create": {
      description: "Ustvarite novo denarnico",
      title: "Denarnica"
    },
    "3-restore": {
      description: "iz varnostkopije",
      title: "Obnovi"
    },
    "4-create": {
      title: "Povzetek"
    },
    "4-restore": {
      title: "Povzetek"
    }
  }
};
const guide$3 = {
  accountDescription: {
    text: "To je pregled vaega rauna. Prikazuje dohodne in odhodne transakcije. Stanje je prikazano za vsak raun posebej. Oglejte si pomo v Nastavitvah, e elite izvedeti ve o razlinih vrstah raunov.",
    title: "Kaj mi prikazuje ta stran?"
  },
  accountFiat: {
    text: "Seveda, kliknite na oznako valute in jo zamenjate. V nastavitvah lahko doloate seznam valut, ki se prikazujejo tu.",
    title: "Ali lahko preverim vrednost v drugih fiat valutah?"
  },
  accountIncomingBalance: {
    text: "Tu je zbrana vsota zneskov, ki se prenaajo na va raun, vendar jih omreje e ni potrdilo.",
    title: "Kaj pomeni dohodni?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Vsak xpub (razirjen javni klju) je vezan na prikazan tip naslova: "Native Segwit (bech32)", "Wrapped Segwit" ali "Taproot" (samo za Bitcoin). To so vrste skript, ki jih uporablja {{coinName}}. Aplikacija BitBoxApp jih zdruuje in podpira ve vrst skript na istem raunu. Ker vsaka vrsta skripta daje drugaen xpub, je na raunu ve xpubov.\n\ne sredstva stalno prejemate na privzeti naslov (Native Segwit), potrebujete samo "bech32" xpub. e pa sredstva prejemate tudi na tip naslova "Wrapped Segwit" ali "Taproot", morate uporabiti tudi razirjene javne kljue "Wrapped Segwit" oziroma "Taproot".',
      title: "Zakaj je tu ve xpub-ov?"
    },
    privacy: {
      text: "xpub ali razirjen javni klju za doloen raun, razkriva celotno finanno zgodovino tega rauna: transakcije v preteklosti, stanje rauna in prihodnje transakcije. Dostop do xpub-a pa nikomur ne omogoa premika vaih kovancev.\n\nV kolikor nekomu posredujete xpub se morate zavedati, da lahko ta oseba ali podjetje vidi vse dogajanje na temu raunu (za vsak naslov tega rauna). Premislite torej katera in koliko sredstev boste upravljali na raunu, ki ga dajete nekomu na vpogled.",
      title: "Ali moram svoje xpub-e ohraniti zasebne in na varnem?"
    },
    verify: {
      text: "Da, vedno je dobro dvakrat preveriti xpub. e bo nekdo drug iz tega xpub-a ustvaril naslove za prejemanje in vam poiljal denar, je to e posebej pomembno. Preveriti ga morate na napravi, da se prepriate, da ta xpub pripada vam. V nasprotnem primeru bi lahko vsa sredstva la na napane naslove (ki si jih morda ne lastite vi).",
      title: "Ali moram preveriti xpub na napravi?"
    },
    xpub: {
      text: 'Razirjeni javni klju (xpub) je osnovni klju, iz katerega izhajajo vsi prejemni naslovi rauna.\nTu jih prikazujemo za namene napredne uporabe, kot na primer za uporabo v opazovalnih denarnicah (watch only wallets), kot sta Electrum ali Sentinel. e imate prejeme sredstev na razline tipe naslovov, uporabite "xpub" vseh tipov naslovov, da jih boste lahko videli vse svoje kovance v teh denarnicah.\n\nPozor, nekatere denarnice e ne podpirajo vseh tipov naslovov, kot je npr Taproot.',
      title: "Kaj je razirjeni javni klju?"
    }
  },
  accountRates: {
    text: "Menjalni teaji se vsako minuto posodobijo s strani CoinGecko.",
    title: "Od kod izvirajo prikazani menjalni teaji?"
  },
  accountReload: {
    text: "Vsi podatki o transakcijah se posodabljajo samodejno.",
    title: "Kako lahko ponovno naloim zgodovino transakcij?"
  },
  accountSendDisabled: {
    text: "Gumb Polji se aktivira, ko je stanje veje od ni.",
    title: "Zakaj ne morem poslati nobenega {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Skupni znesek je vsota vseh vaih kripto raunov. Menjalni teaji so na voljo na spletnem mestu coingecko.com.\n\nOpomba: e MyEtherWallet uporabljate za etone, ki jih BitBoxApp ne podpira, ti ne bodo vkljueni v prikazani znesek.",
    title: "Kako se izraunava skupni znesek?"
  },
  accountSummaryDescription: {
    text: "Tu si lahko ogledate gibanje vaega skupnega portfelja skozi as. Povzetek posameznih raunov je prikazan pod grafom.",
    title: "Kaj prikazuje ta stran?"
  },
  accountTransactionAttributesBTC: {
    text: 'Virtualna velikost: Uporablja se za doloanje omrenine. Na omrenini ste uspeno prihranili, ko je ta manja od velikosti transakcije.\nVelikost: Dejanska velikost transakcije v bajtih, ko je serializirana glede na izbrano verigo blokov.\nTea: Uvedena s sistemom Segwit, je nova metrika za ovrednotenje velikosti transakcij in blokov. Vsak bajt "segregated witness" teje kot ena, vsi ostali kot tiri enote tee. Namesto enega megabajta dejanske velikosti je zdaj nova omejitev velikosti blokov na tiri milijone enot tee.',
    title: "Kako je s podatki o Bitcoin transakcijah?"
  },
  accountTransactionAttributesGeneric: {
    text: "Potrditve: Ko se transakcija objavi v omreju, je sprva nepotrjena. Poakati je potrebno da jo nek rudar vkljui v blok in s tem potrdi (rudari). Po tem bo imela transakcija 1 (eno) potrditev. Vsak novi blok, ki se objavi v omreju s to transakcijo, doda e eno potrditev. V splonem velja, da trgovci in drugi prejemniki, kot dokonne sprejemajo samo transakcije s 3 do 6 potrditvami.\nID transakcije: Unikatna identifikacijska tevilka transakcije, ki jo lahko uporabite za iskanje v raziskovalcih verige blokov.\nOmrenina: Rudarjem se plaa omrenina (provizija), kot spodbuda za vkljuitev transakcij v bloke, ki jih rudarijo oz izraunavajo.\ne elite izvedeti ve, kliknite gumb Polji.",
    title: "Kaj je prikazano v podatkih o transakcijah?"
  },
  accountTransactionConfirmation: {
    text: "To je transakcija, ki je e objavljena v omreju, vendar e ni potrjena.",
    title: "Kaj je nepotrjena transakcija?"
  },
  accountTransactionLabel: {
    text: "To je naslov, na katerega ste prejeli kovance ali iz njega kovance poslali.",
    title: "Kateri naslov je prikazan za vsako transakcijo?"
  },
  accountTransactionTime: {
    text: "Zabeleen as, ko je transakcija potrjena v verigi blokov (v blockchainu).",
    title: "Kateri as je prikazan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Za Bitcoin in Litecoin lahko odprete ve raunov. Po petih odprtih raunih, lahko dodate novega le e je zadnji e v uporabi. Pri vseh preostalih kovancih podpiramo najve pet raunov.",
      title: "Koliko raunov lahko ustvarim?"
    },
    howtoAddTokens: {
      text: "etoni, ki uporabljajo standard ERC20, so vezani na doloen Ethereum raun. e elite omogoiti ali onemogoiti doloen eton, odprite Upravljanje raunov, razirite raun Ethereum in vklopite ali izklopite eleni eton.",
      title: "Kako lahko dodam dodatne etone?"
    },
    moveFunds: {
      text: "Lahko a z obiajno transakcijo, iz enega naslova na drugega. Rauni so neodvisni med seboj, zato drugana pot ni mogoa.",
      title: "Ali je mono premikati sredstva med rauni?"
    },
    recoverAccounts: {
      text: "Da. BitBoxApp ustvarja raune z uveljavljenimi standardi, zdruljivimi z veino drugih kripto denarnic.",
      title: "Ali lahko obnovim raune na drugih denarnicah?"
    },
    whatAreAccounts: {
      text: "Vaa denarnica lahko upravlja ve raunov istega kovanca. Rauni so koristni, e elite sredstva hraniti loeno.",
      title: "Kaj so rauni?"
    },
    whatIsRememberWallet: {
      text: 'e si izberete "Zapomni si denarnico" potem boste lahko videli njeno vsebino v BitBoxApp tudi, ko boste izklopili napravo. S tem boste lahko preverjali stanje svojega portfelja kadarkoli, tudi brez BitBox02. Za premik sredstev boste e vedno potrebovali vklopljeno napravo.\n\ne izberete, da si BitBoxApp ne zapomni ve doloene denarnice in njenih raunov, boste za njen prikaz znova vsakokrat potrebovali prikjluen BitBox02.',
      title: 'Kaj se zgodi, ko omogoim "Zapomni si denarnico"?'
    },
    whyIsThisUseful: {
      text: 'Rauni so odlini za upravljanje sredstev za razline ljudi ali namene, ker so loeni. Svoj "razirjeni javni klju" rauna lahko delite, ne da bi razkrili esarkoli o svojih drugih raunih. To vam omogoa vekratno prejemanje sredstev brez ponovne uporabe naslovov, na primer prejemanja plae ali rednega nakupa kriptovalut.',
      title: "Zakaj je to uporabno?"
    }
  },
  appendix: {
    link: "Kontaktirajte nas!",
    text: "Imate e kakno vpraanje?"
  },
  backups: {
    check: {
      text: "Preverba varnostne kopije slui preverjanju, ali imate pravilno ustvarjeno in aktualno varnostno kopijo, ki ustreza vai trenutni denarnici. To uporabite tudi za preverjanje vaega gesla za obnovitev.",
      title: 'Kaj je "Preverba varnostne kopije"?'
    },
    encrypt: {
      text: "Ne, vendar je geslo za obnovo potrebno za pridobitev denarnice iz shranjenega semena.",
      title: "Ali lahko kriptiram varnostno kopijo?"
    },
    howOften: {
      text: "Varnostna kopija se ustvari samodejno, ko ustvarite novo denarnico. Novo varnostno kopijo morate ustvariti le v primeru, e je vaa microSD kartica z aktualno varnostno kopijo izgubljena, pokodovana ali e elite ve varnostnih kopij.\nPo posameznih transakcijah vam ni treba ustvarjati novih varnostnih kopij! \nVse transakcije, ki ste jih naredili po kreiranju varnostne kopije, lahko obnovite z eno samo varnostno kopijo.",
      title: "Kako pogosto moram narediti varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena ki jo naprava shrani na microSD kartico. Seme, skupaj z vaim geslom za obnovitev, ustvari denarnico.",
      title: "Kaj je varnostna kopija?"
    }
  },
  backupsBB02: {
    check: {
      text: "To preverjanje vam omogoa, da ugotovite, ali imate delujoo varnostno kopijo, ki ustreza trenutni denarnici.",
      title: 'Kaj je "Preveri varnostne kopije"?'
    },
    encrypt: {
      text: "Ne. Prosimo, hranite microSD kartico na varnem mestu, saj vsebuje neifrirano seme (seed) za obnovitev denarnice. e elite zaititi svoje seme z geselsko frazo, jo lahko omogoite v naprednih nastavitvah v razdelku Upravljanje naprave.",
      title: "Ali lahko ifriram varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena na microSD kartici.",
      title: "Kaj je varnostna kopija?"
    }
  },
  bitbox: {
    "2FA": {
      text: 'Ko je 2FA omogoena, je potrebno na uparjenem telefonu odobriti vse izvedene transakcije, da bi premaknili kovance. \nV ozadju se kriptirana unikatna vrednost polje v aplikacijo na telefonu, se tam deifrira in ko pritisnete gumb "Sprejmi" se vrne v BitBox. Komunikacija z napravo se izvaja preko kanala, ki je bil vzpostavljen med uparjevanjem s telefonom, in to namizno aplikacijo.\n\nPOZOR: Predno omogoite 2FA, bodite pozorni, da varnostno kopirate svojo denarnico in uparite telefon. Ko je 2FA omogoena, je namre microSD kartica onemogoena in uparjevanje s telefonom ni mono. To dvoje lahko znova omogoite le po ponastavitvi BitBox01, ki izbrie napravo (in s tem denarnico)!',
      title: "Kako deluje dvofaktorska avtentikacija (2FA)?"
    },
    disable2FA: {
      text: "e elite onemogoiti 2FA, morate ponastaviti (resetirati) in s tem izbrisati denarnico na BitBox-u in jo nato obnoviti iz varnostne kopije. Prepriajte se, da imate e vedno microSD kartico z varnostno kopijo in shranjeno veljavno in pravilno geslo za obnovo te denarnice.\nele nato pritisnite Ponastavi napravo. Nastavite novo geslo naprave in izberite Obnovite varnostno kopijo. Izberite pravo varnostno kopijo, ki ste jo naredili iz denarnice, kliknite Obnovi in vnesite geslo za obnovitev, ki ste ga kreirali pri ustvarjanju denarnice.",
      title: "Kako onemogoim dvo faktorsko avtentikacijo (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox lahko izklopite kadarkoli oz. iztaknete iz USB vhoda.",
      title: "Kako lahko odklopim BitBox?"
    },
    ejectSD: {
      text: "MicroSD lahko odstranite iz BitBoxa kadarkoli, razen, ko ste v procesu ustvarjanja ali obnavljanja varnostne kopije.",
      title: "Kdaj lahko odstranim microSD kartico?"
    },
    hiddenWallet: {
      text: "Gre za drugo denarnico na isti napravi, zaiteno z razlinim geslom naprave in obnovitvenim geslom, ki ga lahko uporabite za verodostojno zanikanje. Enako rezervno seme se uporablja za normalno in skrito denarnico, zato dodatna varnostna kopija ni potrebna.",
      title: "Kaj je skrita denarnica?"
    },
    legacyHiddenWallet: {
      text: "Najprej kliknite spodnji gumb (na voljo le, e je BitBox odklenjen z glavnim geslom naprave in je 2FA onemogoen), nato ponovno vklopite Bitbox in ga odklenite s svojim alternativnim geslom naprave.",
      title: "Kako dostopam do skrite denarnice?"
    },
    pairing: {
      text: "Ko naloite nao mobilno aplikacijo za iOS ali Android, skenirajte prikazano QR kodo, ki vzpostavi varen kanal med mobilno aplikacijo in to aplikacijo. Poskenirajte in sledite navodilom v mobilni aplikaciji.",
      title: "Kako varno uparite BitBox01 s telefonom"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Za ve podrobnosti si oglejte spletno mesto Bitsurance in odgovore na pogosto zastavljena vpraanja (FAQ).",
      title: "Imate dodatna vpraanja?"
    },
    privacy: {
      link: {
        text: "Politika zasebnosti Bitsurance"
      },
      text: "Kot vsaka obiajna zavarovalna polica, tudi ta vsebuje vae polno ime, naslov prebivalia ter opredeljuje predmet zavarovanja (ta je opredeljen z razirjenim javnim kljuem zavarovanca). Ti podatki so posredovani neposredno zavarovalnici Bitsurance in se ne delijo s podjejem Shift Crypto (in storitvijo BitBox). Za ve informacij si oglejte pravilnik o zasebnosti zavarovalnice Bitsurance.",
      title: "Kateri osebni podatki so potrebni za zavarovanje?"
    },
    renew: {
      text: 'Zavarovanje se samodejno podalja za naslednje leto. Podaljanje lahko kadar koli prekliete s klikom na "Upravljanje pogodbe" v aplikaciji BitBoxApp, ki vas pripelje na portal za stranke Bitsurance.',
      title: "Kako lahko obnovim ali prekinem zavarovanje?"
    },
    status: {
      text: 'Uspeno zavarovani rauni so oznaeni z zeleno oznako "zavarovano" v zgornjem levem kotu na strani vsakega Bitcoin rauna. V razdelku "Zavarovanje" si lahko ogledate pregled vseh Bitcoin zavarovanih raunov in njihovo trenutno stanje zavarovanja. Posodobitev stanja lahko traja do 48 ur.',
      title: "Ali lahko preverim stanje zavarovanega rauna?"
    },
    what: {
      text: 'Vsaka zavarovalna polica za Bitcoin krije doloen raun v denarnici. Ve raunov lahko zavarujete tako, da sklenete ve zavarovalnih polic. Zavarovani so le Bitcoini na tipu naslova "Native Segwit" v posameznih zavarovanih raunih.',
      title: "Ali so zaiteni vsi Bitcoini v denarnici?"
    },
    who: {
      text: "Zavarovanje ponuja Bitsurance, zavarovalni posrednik, ki so ga zgradili bitcoinerji. Sodelujejo z zavarovalno hio ELEMENT ki zagotavlja zavarovanja za Bitcoin. Obe podjetji imata sede v Nemiji.",
      title: "Kdo zavaruje moj Bitcoin?"
    },
    why: {
      text: "Zavarovanje Bitsurance krije nekatera tveganja samo-hrambe, pred katerimi ni varna nobena strojna denarnica (naprava), kot npr. vlom, izsiljevanje ali unienje denarnice. Ali potrebujete zavarovalno kritje za ta tveganja ali ne, je izkljuno vaa osebna odloitev.",
      title: "Ali potrebujem zavarovanje za Bitcoin?"
    }
  },
  cointracking: {
    text: 'Kliknite gumb "Izvozi" in odprite mapo za prenose, v kateri boste nali izvoz v .CSV datoteki. Nato kliknite spodnjo povezavo, naloite to .CSV datoteko in uvozite podatke, da jih boste lahko uporabili za storitev CoinTracking in za pripravo davnih poroil (samo za doloene drave!).',
    title: "Kako uvozim svoje transakcije v storitev CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Preberite si ve o preverjanju pristnosti"
      },
      text: "Aplikacija BitBoxApp opravi preverjanje pristnosti na napravi BitBox02, da preveri, ali je naprava originalna. Preverjanje se opravi lokalno in brez povezave z zunanjim strenikom.",
      title: "Kako poteka preverjanje pristnosti?"
    },
    name: {
      text: "To je ime vae denarnice in varnostne kopije. Ime se uporablja za prihodnje varnostne kopije in se lahko uporablja za laje razlikovanje med razlinimi denarnicami. Spremenite ga lahko kadar koli, vendar upotevajte, da bodo varnostne kopije, izdelane pred spremembo, e vedno uporabljale prejnje ime.",
      title: "Za kaj se uporablja ime denarnice BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Preberite ve o varnem ipu"
      },
      text: "Ker je verzija ipa dobra informacija o varnosti naprave. Najsodobneji ip je ATECC608B z izboljanimi varnostnimi funkcijami v primerjavi s starejimi modeli.",
      title: "Zakaj prikazujemo model varnega ipa?"
    }
  },
  receive: {
    address: {
      text: "Poljite ali predajte ga drugim, da vam lahko nanj poiljajo kovance.\nPriporoamo, da se s prejemnikom naslova prepriate, da je prejel enak naslov, kot ste mu ga poslali. Obstaja namre monost, da na poti do prejemnika naslova programska oprema zamenjala naslov s svojim.",
      title: "Kaj lahko ponem z naslovom?"
    },
    addressChange: {
      text: "Takoj, ko opravite transakcijo, se na seznam samodejno doda nov naslov. Tako je vedno na voljo 20 naslovov, ki e nikoli niso prejeli nobenega kovanca.",
      title: "Kdaj se naslovi spremenijo?"
    },
    addressFormats: {
      text: 'Privzet tip naslova je "Native Segwit" t.i. bech32 tip naslova. Podprt je e v mnogih drugih denarnicah in menjalnicah, saj ponuja najnije provizije na transakcije. Poleg tega, lahko izbirate e med drugimi tipi naslovov. Noveji je Taproot (velja samo za Bitcoin), stareji pa "Wrapped Segwit".\n',
      title: "Kdaj uporabiti Spremenite tip naslova?"
    },
    howVerify: {
      text: "e imate BitBox01 kliknite ikono BitBox na stranskem stolpcu na levi strani in glejte poglavje seznanitve. Vodnik se bo posodobil in od tam lahko nadaljujete po navodilih.\nZ BitBox02 lahko med postopkom poiljanja/prejemanja preverite naslove neposredno na napravi.",
      title: "Kako lahko varno preverim naslov?"
    },
    plugout: {
      text: "Ne, BitBox lahko odklopite. Ko poljete kovance na naslov generiran z BitBox02, vam naprave ni treba pustiti prikljuene v raunalnik ali telefon.",
      title: "Je potrebno imeti BitBox02 priklopljen vse dokler ne prejmem sredstev?"
    },
    why20: {
      text: "Med zagonom aplikacija ustvari naslove, pridobljene iz vaega semena, in preveri, ali so prejeli sredstva. Aplikacija lahko ustvari skoraj neskonno tevilo naslovov in bi lahko porabila leta, da doloi pravo stanje za vsak naslov.\nDa omejimo as iskanja, se prikaz ustavi po prvih 20 najdenih naslovov, ki nikoli niso prejeli sredstev. To je namenska omejitev in 20 je de-facto standard, eprav je tevilo poljubno. To je 20 naslovov, med katerimi lahko izbirate.",
      title: "Zakaj le 20 naslovov?"
    },
    whyMany: {
      text: "Za ohranjanje vae zasebnosti in varnosti nikoli ne uporabite istega naslova dvakrat. \ne ste e uporabili naslov, kliknite na puico v desno za nov naslov. Naenkrat lahko ustvarite do 20 naslovov. Na naslove lahko gledate, kot na tevilke izdanih raunov. Vsi naslovi so pridobljeni iz istega semena.",
      title: "Zakaj toliko naslovov?"
    },
    whyVerify: {
      text: "Vaemu raunalniku ne zaupajte, da ustvarja in prikazuje pristne naslove. Zaradi velike kompleksnosti je bistveno laja tara in bolj obutljiv kot denarnica s strojno opremo. \nZa BitBox01 - gumb za preverjanje naslova varno polje naslov na seznanjen mobilni telefon, iz katerega lahko tudi skenirate in preverite QR kodo. \nNa BitBox02 lahko naslov preverite neposredno na zaslonu.",
      title: "Zakaj moram varno preveriti naslov?"
    }
  },
  send: {
    change: {
      text: "Viek (change) bo vrnjen na naslov Taproot, e imate vsaj en Taproot UTXO (Taproot naslov z nekaj sredstvi). e uporabljate nadzor kovancev, bo sprememba vrnjena na Taproot naslov, e je med izbranimi UTXO vsaj en tipa Taproot. V vseh drugih primerih se sprememba vrne na Native Segwit (bech32) naslov.",
      title: "Kako je definirano vrailo vikov?"
    },
    fee: {
      text: "Omrenina (ali prostovoljni prispevek rudarjem, provizija) temelji na velikosti podatkov v transakciji in ne na njenem znesku. Ciljne omrenine se izraunajo po algoritmu za ocenjevanje omrenin Bitcoin Core glede na izbrano prioriteto. Prikaejo se, e imajo drugano vrednost od spodnjih.\nVarna: 24 blokov (priblino 4 ure za Bitcoin, 1 ura za Litecoin)\nNizka: 12 blokov (priblino 2 uri za Bitcoin, 30 minut za Litecoin)\nObiajna: 6 blokov (priblino 1 ura za Bitcoin, 15 minut za Litecoin)\nVisoka: 2 bloka (priblino 20 minut za Bitcoin, 5 minut za Litecoin)\n(Izraun bloka v Bitcoin omreju traja v povpreju deset minut in 2,5 minute za Litecoin. Obremenitev omreja in s tem omrenine se lahko v zgornjih obdobjih mono razlikujejo.)",
      title: "Kako se doloi vrednost omrenine?"
    },
    plugout: {
      text: "Ne, ko enkrat opravite prenos sredstev (transakcijo), vam BitBoxa ni treba imeti ve priklopljenega. Lahko jo izkljuite.",
      title: "Ali moram imeti BitBox priklopljen ves as poiljanja?"
    },
    priority: {
      text: "Vijo omrenino, ki ste jo pripravljeni plaati, hitreje bo vaa transakcija potrjena v omreju.",
      title: "Kakna je prednost omreja?"
    },
    revert: {
      text: "Ko je transakcija podpisana in poslana (tj. predvajana v omreje), je ni ve mogoe razveljaviti. Pred podpisom torej preverite transakcije (vkljuno s provizijo)!\ne prejemnika poznate in vam je pripravljen poslati isti znesek (minus transakcijske provizije), mu lahko poljete nov naslov za prejem kovancev.",
      title: "Ali lahko povrnem transakcijo?"
    },
    whyFee: {
      text: "S prispevkom oz. omrenino, ki jo prinaajo, transakcije med seboj tekmujejo, da jih potrdi rudar. Rudarji praviloma najprej izberejo tiste transakcije, ki jim prinaajo vije omrenine (provizije).\nBitcoin rudarji lahko za nagrado za opravljeno raunsko delo poberejo omrenine, plaane pri transakcijah, ki jih potrdijo, skupaj z novo nastalimi bitcoini. Rudarjenje je specializiran in konkurenen trg, kjer se nagrade delijo glede na tevilo opravljenih izraunov. ",
      title: "Zakaj obstaja omrenina?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "e se elite s svojim vozliem (full node) povezati le, ko ste v istem omreju (npr. domai wifi), zadostuje uporaba obiajne omrene komunikacije.\nV tem primeru je priporoljivo, da strenik Electrum zagotovi potrdilo TLS za ifriranje komunikacije.\ne se nameravate s svojim vozliem povezati od kjer koli drugje, je bolja monost uporaba omreja Tor. V tem primeru ni potrebno potrdilo TLS.",
      title: "Ali naj uporabim neifrirano povezavo TCP, TLS ali Tor?"
    },
    instructions: {
      link: {
        text: "Vodnik za povezavo lastnega vozlia"
      },
      text: "Za obirneja navodila obiite na vodi (v angleini):",
      title: "Kako poveem BitBoxApp s svojim polnim vozliem?"
    },
    options: {
      text: "Obstaja ve monosti za postavitev lastnega vozlia, kot na primer nakup konanega izdelka, ki je namenjen le temu, izdelava lastnega ali zagon programja Bitcoin Core na raunalniku.\ne elite BitBoxApp povezati s svojim vozliem, se prepriajte, da na njem tee tudi strenik Electrum. To je namenski program, ki aplikaciji denarnice (kot je BitBoxApp) omogoa komunikacijo s polnim vozliem.\nPodprte monosti vkljuujejo programje Electrs, Electrum Personal Server (EPS) ali Bitcoin Wallet Tracker (BTW).",
      title: "Kakne monosti obstajajo za zagon/nakup vozlia?"
    },
    tor: {
      text: "Tor pomeni 'The Onion Router', ki je brezplana in odprtokodna programska oprema, ki ponuja vijo stopnjo zasebnosti in je e posebej uporabna pri uporabi Bitcoina.\ne se nameravate povezati s vozliem prek omreja Tor, se prepriajte, da je Tor nameen na raunalniku in nato v nastavitvah BitBoxApp omogoite Tor Proxy.\nV veini operacijskih sistemov obstaja dva naina dostopa do Tor-a:\n1. Brskalnik Tor: prenesite in odprite brskalnik Tor. To bo omogoilo BitBoxApp, da se povee z omrejem Tor. V nastavitvah vpiite vrata (port) 9150 v nastavitvah za proxy strenik.\n2. To v ozadju: Namestite demon Tor, ki vedno deluje v ozadju operacijskega sistema. Nato se lahko BitBoxApp povee preko Tor-a z nastavitvijo vrat 9050 v nastavitvah za proxy strenik.",
      title: 'Kaj je Tor, Tor proxy in kater "port" naj uporabim?'
    },
    what: {
      text: "Denarnico lahko poveete s svojim polnim vozliem, namesto da uporabljate strenike podjetja Shift.",
      title: "Kaj je to?"
    },
    why: {
      text: "Vzdrevanje lastnega vozlia ni potrebno, izbolja pa zasebnost in znia potrebo po zaupanju drugim.\nPrvi, to pomeni, da bolj zasebno uporabljate Bitcoin (omreje), saj se BitBoxApp ne bo povezal z naimi streniki, da bi prejel vao zgodovino transakcij; namesto tega bo podatke prejel od vaega vozlia.\nDrugi, imeti lastno vozlie pomeni, da vozlie samo preverja vse transakcije in poskrbi, da so pravila omreja Bitcoin za vas uveljavljena.",
      title: "Zakaj naj poganjam svoje vozlie?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (satoi, kraje sat) je najmanja enota Bitcoina. En satoi je stomilijonska enota bitcoina (0,00000001 BTC). Ime je dobila po avtorju Bitcoina, Satoshiju Nakamotu.",
      title: "Kaj je Satoshi?"
    },
    servers: {
      text: "Ta aplikacija komunicira s streniki podjetja Shift Crypto AG, da preveri posodobitve, naloi transakcije in poilja informacije v uparjene mobilne aplikacije.\nAplikacija pridobiva najnoveje teaje pri CoinGecko. Vse konverzije so izraunane lokalno, kar pomeni, da se podatki o znesku vae transakcije nikoli ne poljejo ven iz aplikacije.\nOpomba: Za Ethereum in ERC20 etone uporabljamo API-je Etherscan.io.",
      title: "S katerimi streniki govori ta aplikacija?"
    }
  },
  title: "Vodi vam v pomo",
  toggle: {
    close: "Zapri",
    open: "Pomo"
  },
  trackingModePortfolioChart: {
    text: "V namizni aplikaciji pojdite z miko ez graf. V mobilni aplikaciji, pritisnite na grafi in podrsajte po njem levo ali desno.",
    title: "Kako preverim vrednosti na grafu za doloen dan?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Ponastaviti morate napravo (reset) in obnoviti denarnico iz varnostne kopije z geslom za obnovitev.",
      title: "Kaj lahko storim, e pozabim geslo naprave?"
    },
    reset: {
      text: "Vnesite napano geslo naprave 15-krat. V zadnjih nekaj poskusih je potreben dolg dotik naprave.",
      title: "Kako ponastavim napravo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Ko jo vstavite, naprava utripne enkrat. Prepriajte se, da je pravilno obrnjena v USB rei. e imate teave, nas kontaktirajte preko spodnje povezave.\n\nBitBox01 ni podprt v mobilni aplikaciji. Za povezavo z BitBox01 uporabite BitBoxApp na namizju.",
      title: "Moj BitBox01 ni prepoznan"
    },
    getDevice: {
      link: {
        text: "Naroite BitBox"
      },
      text: "BitBox lahko kupite v nai spletni trgovini (link spodaj) ali pri naih partnerjih.",
      title: "Kje lahko kupim BitBox?"
    },
    internet: {
      text: "Da, internetna povezava je potrebna za sinhronizacijo denarnice, za poiljanje transakcij in pridobivanje menjalnih teajev.",
      title: "Ali ta aplikacija zahteva internetno povezavo?"
    },
    lostDevice: {
      link: {
        text: "Varnostne kopije"
      },
      text: "Vaa sredstva lahko enostavno obnovite z novo BitBox denarnico ali z drugo BIP39 napravo. V pomo smo spisali postopek v lanku:",
      title: "Izgubil sem napravo. Kaj pa zdaj?"
    },
    useWithoutDevice: {
      text: "Na alost to trenutno e ni mogoe.",
      title: "Ali lahko aplikacijo uporabljam brez BitBoxa?"
    },
    welcome: {
      text: "Podjetje Shift Crypto iz vice se vam zahvaljuje, ker uporabljate BitBoxApp. \nVae predloge za izboljavo zelo cenimo in si jih elimo. Va odziv priakujemo na povezavi na dnu.",
      title: "Pozdravljeni v aplikaciji BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "e uporabljate nov telefon ali raunalnik z aplikacijo BitBoxApp, se boste morali ponovno povezati z DApps. Svoje kovance boste nato ponovno videli v izbranih DApp kot obiajno.",
      title: "Mojih prejnjih povezav ne vidim."
    },
    supportedNetworks: {
      text: "V BitBoxApp je trenutno z WalletConnect podprto le Ethereum omreje. Za uporabo drugih verig, zdruljivih z EVM, uporabite storitev Rabby v brskalniku (browser extension wallet).",
      title: "Katera omreja so podprta?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikacijski protokol za web3 aplikacije. Omogoa vam prirono povezavo z decentraliziranimi avtonomnimi aplikacijami (DApps) in spletnimi denarnicami, ki temeljijo na Ethereumu, brez uporabe aplikacije tretje osebe. To je e posebej uporabno za uporabnike aplikacije BitBoxApp na Androidu.",
      title: "Kaj je WalletConnect?"
    }
  }
};
const headerssync$2 = {
  blocksSynced: "{{blocks}} sinhroniziranje blokov"
};
const hiddenWallet$2 = {
  info1HTML: "Za namene verodostojnega zanikanja (obstoja prave denarnice) lahko ustvarite skrito denarnico na podlagi <strong>drugane (alternativne)</strong> kombinacije gesla in gesla za obnovitev varnostne kopije. ",
  info2HTML: "Doloite geslo naprave in geslo za obnovitev, ki ju elite povezati s spodnjo skrito denarnico. To geslo naprave in geslo za obnovitev morata biti <strong> drugana </strong> od tistih, ki ste ju doloili za primarno denarnico.",
  passwordLabel: "Skrito geslo za obnovitev",
  passwordPlaceholder: "Potrdite skrito geslo za obnovitev",
  pinLabel: "Geslo za skrito denarnico",
  pinRepeatLabel: "Ponovite geslo skrite denarnice",
  pinRepeatPlaceholder: "Prosimo potrdite geslo skrite denarnice",
  success: "Skrita denarnica je bila uspeno ustvarjena. Iztaknite in ponovno vtaknite BitBox v USB vhod, da jo odklenete."
};
const initialize$2 = {
  create: "Ustvarite geslo naprave",
  creating: "Kreiram geslo naprave ...",
  error: {
    e102: "Geslo naprave mora vsebovati najmanj 4 znake."
  },
  info: {
    description1: "Vpiite novo geslo naprave. To bo uporabljeno za odklepanje BitBox-a.",
    description2: "Uporabite lahko tevilke, rke in simbole. Dalja gesla so varneja.",
    description3: "e izgubite geslo naprave, boste morali ponastaviti napravo in obnoviti varnostno kopijo denarnice.",
    subtitle: "Zdaj boste vpisali novo geslo naprave",
    title: "Izvaja se prvi zagon vae naprave"
  },
  input: {
    label: "Geslo naprave",
    labelRepeat: "Ponovite geslo naprave",
    placeholderRepeat: "Prosimo, potrdite geslo naprave"
  }
};
const invalidFormat$2 = "Neveljavna oblika";
const language$3 = {
  title: "Izberite jezik"
};
const legacyhiddenwallet$2 = {
  disable: "Onemogoi starejo skrito denarnico (legacy wallet)",
  enable: "Omogoi skrito denarnico starejega formata (legacy)",
  successDisable: "Skita denarnica bitcoin rauna stareje generacije je onemogoena.",
  successEnable: "Skrita denarnica starejega formata je uspeno omogoena. Znova prikljuite svoj BitBox in skrbno vnesite geslo naprave za dostop do stareje skrite denarnice."
};
const loading$2 = "nalaganje";
const manageAccounts$1 = {
  accountHidden: "Ta raun je bil skrit in ga ni ve na seznamu opazovalnih raunov. e ga elite videti ponovno, priklopite va Bitbox02.",
  editAccount: "Uredi",
  editAccountNameTitle: "Uredi ime rauna",
  noAccounts: "ni raunov",
  settings: {
    hideTokens: "Skrij etone",
    showTokens: "Prikai etone ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Dodajaj in aktiviraj/deaktiviraj raune",
  title: "Upravljanje raunov",
  watchAccount: "Opazovalni raun",
  watchAccountDescription: "Ta raun je del vaih opazovalnih raunov. Z drsnikom ga lahko skrijete."
};
const mobile$2 = {
  usingMobileDataWarning: "Uporaba podatkov na mobilni napravi: ta aplikacija lahko po odklepanju rauna naloi do nekaj sto megabajtov podatkov. e elite prepreiti uporabo mobilnih podatkov, se poveite z Wi-Fi omrejem. \nTo sporoilo ne bo ve prikazano, e ga ugasnete."
};
const newSettings$1 = {
  about: {
    appVersion: {
      title: "Verzija aplikacije"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Preprei dostop do aplikacije z zaklepom zaslona.",
      title: "Zaklep zaslona"
    },
    coinControl: {
      description: "Za vejo stopnnjo zasebnosti izberite kateri UTXO naj bo del transakcije."
    },
    customFees: {
      description: "To vam omogoa vnos poljubne viine provizije za transakcijo."
    },
    torProxy: {
      description: "Poveite se preko Tor omreja za ve zasebnosti."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Te dodatne valute lahko izmenjujoe prikazujete na strani raunov.",
      title: "Aktivne valute"
    },
    darkmode: {
      description: "BitBoxApp v temnem nainu"
    },
    defaultCurrency: {
      description: "Izberite privzeto valuto",
      title: "Privzeta valuta"
    },
    enableAccount: {
      description: "e onemogoite posamezen raun, ne bo prikazan v stranski vrstici ali portfelju. Od tu ga lahko vedno znova omogoite. \nTo ne bo vplivalo na kovance v tem raunu. Ostajajo na varnem, le prikazani ne bodo.",
      title: "Omogoi/ onemogoi raun"
    },
    hideAmounts: {
      description: "Prikae preklopnik za skrivanje stanja in zneskov, za vao vejo zasebnost, ko aplikacijo uporabljate na javnem mestu.",
      hideAmounts: "Skrij zneske",
      showAmounts: "Prikai zneske",
      title: "Dovoli skrivanje zneskov"
    },
    language: {
      description: "Izberite jezik, ki ga elite uporabiti v BitBoxApp-u.",
      title: "Jezik"
    },
    remebmerWallet: {
      name: "Zapomni si denarnico",
      warning: "Odstranili boste prikaz denarnice, ko BitBox02 ni prikljuen. Vsebina denarnice in vsa sredstva s tem ostanejo varna in nedotaknjena, le BitBoxApp jo bo pozabil. Nadaljujem?",
      warningTitle: "Pozabi denarnico"
    },
    toggleSats: {
      description: "Prikaite ali skrijte Satoije (sats)."
    }
  }
};
const note$3 = {
  input: {
    description: "(opcijsko)",
    placeholder: "Dodaj opombo"
  },
  title: "Opomba"
};
const notification$2 = {
  newTxs_one: "{{count}} novih transakcij na: {{accountName}}",
  newTxs_other: "{{count}} novih transakcij na: {{accountName}}"
};
const pairing$2 = {
  aborted: {
    text: "Uparjanje je bilo prekinjeno s strani mobilne aplikacije.",
    title: "Prekinjeno"
  },
  button: "Uparite z mobilno aplikacijo",
  confirm: "Ali ste prepriani, da elite upariti svoj BitBox? Upotevajte, da je po uparitvi mobilni telefon vedno potreben za izvedbo transakcije.",
  connectOnly: {
    button: "Poveite z mobilno aplikacijo",
    title: "Skenirajte z nao mobilno aplikacijo tako, da izberete menijsko toko Connect to new desktop app"
  },
  error: {
    text: "Nekaj je lo narobe. Prosimo, zanite znova.",
    title: "Napaka"
  },
  pullFailed: {
    text: "Sporoila iz mobilnega telefona ni bilo mogoe pridobiti prek relejskega strenika. Strenik je morda brez povezave. Prosimo, obrnite se na podporo.",
    title: "Parjenje ni uspelo"
  },
  reconnectOnly: {
    button: "Ponovno vzpostavite povezavo z mobilno aplikacijo"
  },
  scanningFailed: {
    text: "Mobilnik ni uspeno skeniral sporoila. Prosimo poskusite ponovno.",
    title: "Skeniranje ni uspelo"
  },
  start: {
    hideAppQRCode: "Skrij kodo QR",
    revealAppQRCode: "Prikai QR kodo",
    step1: "e mobilne aplikacije e nimate, lahko skenirate QR kodo za Apple App Store ali Google Play Store, odvisno od tega, kateri telefon imate.",
    step2: "Skenirajte z nao mobilno aplikacijo, ki jo najdete pod imenom Digital Bitbox 2FA v trgovinah z aplikacijami za iOS in Android:"
  },
  started: {
    text: "Prosimo sledite navodilom v mobilni aplikaciji.",
    title: "Super"
  },
  success: {
    text: "estitamo, uspeno ste uparili BitBox z mobilno aplikacijo!",
    title: "Uspelo je!"
  },
  timeout: {
    text: "Seznanitev je potekla po dveh minutah. Zanite znova, e elite BitBox e vedno upariti z mobilno aplikacijo.",
    title: "Odmor"
  },
  title: "Mobilno seznanjanje"
};
const passphrase$1 = {
  considerations: {
    button: "",
    message: "Geselska fraza zagotavlja dodaten nivo zaite varnostni kopiji vae denarnice (bodisi na microSD kartici ali 24 besedam). e nekdo pridobi dostop do vae varnostne kopije (na kartici ali besede), bo za dostop do vae denarnice potreboval tudi geselsko frazo.\n\nTo pa pomeni, da boste potrebovali <strong>oboje - geselsko frazo in varnostno kopijo denarnice</strong>, da bi obnovili tako zaiteno denarnico, e se va BitBox02 pokvari ali ga izgubite. e pozabite ali izgubite to geslo, boste izgubili dostop do vseh kovancev v tej denarnici!\n\nGeselsko frazo shranjujte loeno od varnostne kopije. S tem prepreite vdor v denarnico, e nekdo najde le njeno varnostno kopijo.",
    title: "Razmislek o varnostni kopiji"
  },
  disable: "Onemogoi geselsko frazo",
  disableInfo: {
    button: "Izklopi",
    message: "Po izklopu geselske fraze, vas BitBox ob odklepu ne bo ve spraeval po njej. S tem boste vstopili v privzeto denarnico.\n\nVsi kovanci v denarnici, zaiteni z izbrano geselsko frazo, bodo e vedno v tej denarnici, vendar do njih ne boste mogli dostopati, saj boste po odklepanju naprave odprli svojo privzeto denarnico.\n\nDa bi znova odprli denarnico, ki je zaitena z geselsko frazo, enostavno ponovno omogoite to funkcijo in vnesite izbrano geselsko frazo na BitBox02.\n\n<strong>Namig:</strong> Kljub temu lahko dostopate do privzete denarnice, le geselske fraze ne vtipkavajte ob vstopu v BitBox."
  },
  enable: "Omogoi geselsko frazo",
  error: {
    e104: "Sprememba geselske fraze je bila prekinjena..."
  },
  how: {
    button: "Kako izgleda",
    message: 'Geselska fraza ne deluje tako kot "navadno" geslo, ki ste ga vajeni. e se ob vnosu geselske fraze zatipkate, na napako NE boste opozorjeni. To pa zato, ker <strong>vsaka geselska fraza ustvari razlino a veljavno denarnico</strong>. To pomeni, da lahko uporabljate ve geselskih fraz za ve denarnic na BitBox02. Vse te denarnice so na BitBox02 dostopne le po vsakokratnem vnosu ustrezne geselske fraze.\n\nOb prikljuitvi naprave BitBox02 boste, kot obiajno, pozvani k vpisu gesla naprave. Nato boste morali v napravo vnesti e geselsko frazo.\n\nPo vnosu fraze se vam bo ta prikazala na zaslonu. Tako boste lahko potrdili, da ste jo vnesli pravilno oz. da ste vnesli eljeno.\n',
    title: "Kako deluje"
  },
  intro: {
    message: "Geselska fraza zagotavlja dodatni nivo varnosti za vao denarnico.\nSpoznajmo, kako deluje.",
    title: "Vnesite eljeno geselsko frazo"
  },
  progressDisable: {
    message: "Na BitBoxu potrdite, da elite <strong>onemogoiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  progressEnable: {
    message: "Na BitBoxu potrdite, da elite <strong>omogoiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  successDisabled: {
    message: "Geselska fraza <strong>uspeno omogoena</strong>!\nOdslej jo boste vselej vnaali v napravo.",
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    title: "Geselska fraza omogoena"
  },
  successEnabled: {
    message: "Geselska fraza <strong>uspeno onemogoena</strong>!\nNaprava vas po njej ne bo ve spraevala ob odklepanju.",
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    tips: "Namigi",
    tipsList: [
      "Priporoamo, da v denarnico zaiteno s frazo najprej poljete majhen znesek. Nato BitBox ponovno priklopite in vnesite geslo ter frazo. e vse vnesete pravilno, boste lahko videli in upravljali kovance na tej denarnici.   ",
      "e elite dostopati do privzete denarnice, nezaitene z geselsko frazo, to e vedno lahko storite tako, da preskoite korak, ko vas BitBox povabi k vnosu faze."
    ],
    title: "Geselska fraza onemogoena"
  },
  summary: {
    button: "Omogoite geselsko frazo",
    title: "Povzetek",
    understand: "Razumem kako deluje geselska fraza in vsa povezana tveganja.",
    understandList: [
      "Geselska fraza je dodaten nivo zaite za varnostno kopijo.",
      "e vnesete razlino geselsko frazo, boste vedno ustvarili razlino denarnico.",
      "Za obnovitev denarnice potrebujete <strong>oboje, geselsko frazo in varnostno kopijo</strong>.",
      "e pozabite ali izgubite svojo geselsko frazo, <strong>izgubite dostop do svojih kovancev.</strong>"
    ]
  },
  what: {
    button: "Spoznajte kako to deluje",
    message: 'Denarnica je ustvarjena (pridobljena) iz zelo velikega nakljunega tevila, znanega tudi kot seme (seed). To seme je ustvarjeno ob prvi nastavitvi naprave BitBox02 in je varnostno kopirano na microSD kartici ali z 24 besedami. Vsakdo, ki ima dostop do semena, ima popoln nadzor nad sredstvi v tej denarnici.\n\nGeselska fraza ali passphrase je <strong>opcijska skrivnost</strong>, ki je dodana semenu. Pri uporabi geselske fraze vsaka ustvari novo denarnico na podlagi prerauna semena + geselske fraze. Geselska fraza je lahko karkoli: rke, besede, posebni znaki ali pa je lahko celo prazna. Privzeta denarnica dejansko izhaja iz semena + prazne fraze.\n\n"Passphrase" ali geselska fraza je del BIP39 priporoila, kar pomeni, da je kompatibilna z vsemi denarnicami, ki sledijo temu priporoilu (ali kvazi standardu)',
    title: "Kaj je geselska fraza?"
  },
  why: {
    button: "Zakaj uporabiti geselsko frazo?",
    message: "BitBox02 varuje seme (skrivnost, ki jo ustvari) pred odtujitvijo (kopiranjem) iz same naprave, vendar varnostna kopija (na microSD kartici ali izpis 24 besed) omogoa popoln dostop do denarnice. Zato jo je treba hraniti na varnem mestu!\n\nKer geselska fraza ustvari novo denarnico z uporabo vaega obstojeega semena, denarnica zaitena s frazo za obnovo zahteva oboje <strong>varnostno kopijo in geselsko frazo</strong>. Prednost tega je, da e nekdo najde vao varnostno kopijo (v obliki 24 besed ali na microSD kartici), za dostop do kovancev e vedno potrebuje geselsko frazo.\n\nPoleg tega lahko z uporabo ve geselskih fraz na enem BitBox-u upravljate mnogo med seboj loenih denarnic!",
    title: "Zakaj uporabiti geselsko frazo?"
  }
};
const password$2 = {
  show: "Prikai {{label}}",
  warning: {
    caps: "OPOZORILO: Vklopljene imate VELIKE RKE ()",
    paste: 'da prilepite besedilo, omogoite "PRIKAI {{label}}"'
  }
};
const random$3 = {
  button: "Ustvari nakljuno tevilo",
  description: "BitBox je ustvaril {{bits}}-bitno nakljuno tevilo:"
};
const receive$4 = {
  bitsuranceWarning: "To je zavarovan raun, kar pomeni, da lahko prejema le tip Bitcoin naslova Native Segwit. To je zato, da sluajno ne prejmete t.i. starejega  tipa Wrapped Segwit ali novejega Taproot, ki nista zavarovana.",
  changeScriptType: "Spremenite tip naslova",
  label: "Va naslov",
  onlyThisCoin: {
    description: "e elite prejemati druge podprte etone, jih omogoite v nastavitvah. e na naslove, ki so na voljo nakaete/poljete nepodprte etone, zelo verjetno ne bodo vidni/ dostopni.",
    warning: "Prepriajte se, da na ta naslov prejemate le {{coinName}}."
  },
  scriptType: {
    p2tr: "Taproot (najnoveja oblika)",
    p2wpkh: "Native Segwit (privzeto)",
    "p2wpkh-p2sh": "Wrapped Segwit (stareji tip)"
  },
  selectAccount: "Izberite raun",
  showFull: "Pokai in preveri polni naslov na napravi",
  taprootWarning: "Opomba: Taproot je nov tip Bitcoin naslova, ki ni e povsod podprt. Sredstva, prejeta na Taproot naslov, morda ne bodo vidna v drugih denarnicah s katerim dostopate do svoje naprave. tevilne denarnice in menjalnice e niso zmone poslati na Taproot naslove.",
  title: "Prejmi {{accountName}}",
  verify: "Skrbno preverite naslov",
  verifyBitBox01: "Preverite naslov v mobilni aplikaciji",
  verifyBitBox02: "Preverite naslov na BitBox02",
  verifyInstruction: "Preverite, da se prikazan naslov ujema s tistim, ki je prikazan na BitBoxu in to potrdite na napravi.",
  warning: {
    secureOutput: "Prosimo, uparite BitBox z mobilno aplikacijo, da omogoite varno preverjanje naslovov. Pojdite na Upravljanje naprave v stranski vrstici."
  }
};
const reset$2 = {
  description: "Vsi podatki na napravi bodo izbrisani. To vkljuuje va zasebni klju!",
  notReset: "Naprava NI ponastavljena.",
  title: "Ponastavi napravo (reset)",
  understand: "Imam varnostno kopijo in poznam geslo za njeno obnovitev",
  understandBB02: "Imam veljavno varnostno kopijo"
};
const securityInformation$2 = {
  create: {
    description1: "Priporoamo, da prvo nastavitev naprave izvedete v varnem okolju, kjer vas nihe ne opazuje in ne more beleiti vnaanja gesla.",
    description2: "Od vas se bo zahtevalo, da ustvarite dve gesli.",
    description3: "Prvo je <strong> geslo naprave</strong>, ki odklene va BitBox (napravo). Pozneje ga lahko spremenite.",
    description4: "Drugo je <strong>geslo za obnovitev</strong>, ki odklene vao denarnico. Tega gesla kasneje ni mogoe spremeniti!",
    description5: "Ko ustvarite denarnico, bo ta shranjena v datoteko na microSD kartico. To lahko uporabite v nujnih primerih za povrnitev sredstev s pomojo  <strong>gesla za obnovitev</strong>.",
    title: "Pomembne informacije"
  },
  restore: {
    description1: "Vstaviti boste morali microSD kartico, ki ste jo uporabili za shranjevanje varnostne kopije.",
    description2: "e elite obnoviti denarnico, boste potrebovali geslo za obnovitev.",
    description3: "Bodite previdni in natanni pri vnosu gesla. Vsako geslo, ki ga vnesete, bo ustvarilo novo veljavno denarnico. e vnesete napano geslo, se vam bo verjetno prikazalo stanje denarnice, ki ga ne priakujete.",
    title: "Varnostne informacije"
  }
};
const seed$2 = {
  agreements: {
    "funds-access": "da ostanem BREZ DOSTOPA do svojih sredstev, e pozabim to geslo!",
    "password-change": "pozneje NI MONO spremeniti gesla za obnovitev!",
    "password-required": "Obnovitveno geslo je potrebno za obnovitev denarnice iz varnostne kopije"
  },
  create: "Ustvari denarnico",
  creating: "Ustvarjanje denarnice",
  description: "Razumem da:",
  error: {
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e200: "Za kreiranje nove denarnice morate v BitBox vstaviti microSD kartico. S tem omogoite samodejno kreiranje varnostne kopije."
  },
  info: {
    button: "Zdaj nastavite geslo za obnovo denarnice",
    description1: "Vstavite microSD kartico v BitBox",
    description2: 'Ustvarite geslo za obnovitev denarnice in izberite "Nastavi geslo za obnovitev"',
    description3: "Varnostna kopija na microSD kartici in geslo za obnovitev je edina metoda za povrnitev sredstev v primeru izgubljenega, unienega ali ukradene denarnice BitBox01.",
    description4: "Pozneje ni mono spremeniti gesla za obnovitev brez prenosa sredstev.",
    title: "Ustvarite novo denarnico"
  },
  password: {
    label: "Geslo za obnovitev",
    repeatPlaceholder: "Ponovite geslo za obnovitev"
  },
  walletName: {
    label: "Ime denarnice"
  }
};
const seedRestore$2 = {
  error: {
    e200: "Obnova oz. priklic denarnice iz varnostne kopije zahteva microSD kartico."
  },
  info: {
    description1: 'Vstavite microSD kartico v BitBox in kliknite "Nadaljujte"',
    description2: "Izberite varnostno kopijo in kliknite Obnovi",
    description3: "Vnesite geslo za obnovo",
    description4: "Potrdite, da razumete, da bo napano geslo ustvarilo drugo, novo denarnico.",
    title: "Kako obnoviti denarnico iz varnostne kopije"
  }
};
const send$4 = {
  abort: "Transakcija je bila prekinjena.",
  address: {
    label: "Naslov prejemnika",
    placeholder: "Vnesite naslov"
  },
  amount: {
    label: "Znesek",
    placeholder: "Vnesite znesek"
  },
  availableBalance: "Razpololjivo stanje",
  button: "Podpii in polji",
  coincontrol: {
    address: "Naslov",
    outpoint: "",
    title: "Polji iz (output):"
  },
  confirm: {
    "selected-coins": "Izbrani kovanci",
    title: "Potrdite in poljite transakcijo",
    total: "Skupaj"
  },
  error: {
    erc20InsufficientGasFunds: "Kot kae na vaem raunu ni dovolj ETH za plailo transakcije za premik ERC02 etona. Poskrbite za zadostno koliino ETH na vaem Ethereum raunu.",
    feeTooLow: "Omrenina je prenizka",
    feesNotAvailable: "Provizije ni mo oceniti",
    insufficientFunds: "nezadostna sredstva",
    invalidAddress: "neveljaven naslov",
    invalidAmount: "neveljaven znesek",
    invalidData: "neveljavni podatki"
  },
  fee: {
    customPlaceholder: "Vnesite znesek",
    label: "Omrenina",
    placeholder: "Ni na voljo"
  },
  feeTarget: {
    customLabel: "Stopnja provizije",
    customLabel_eth: "Vrednost Gas-a",
    description: {
      economy: "4 ure (24 blokov)",
      economy_eth: "30 minut ali manj",
      economy_ltc: "1 ura (24 blokov)",
      high: "20 minut (2 bloka)",
      high_eth: "30 sekund ali manj",
      high_ltc: "5 minut (2 bloka)",
      low: "2 uri (12 blokov)",
      low_eth: "5 minut ali manj",
      low_ltc: "30 minut (12 blokov)",
      normal: "1 ura (6 blokov)",
      normal_eth: "2 minuti ali manj",
      normal_ltc: "15 minut (6 blokov)"
    },
    estimate: "Predviden as potrditve:",
    label: {
      custom: "Po meri",
      economy: "Ekonomina",
      high: "Visoka",
      low: "Nizka",
      normal: "Normalna"
    },
    placeholder: "Preraunavam..."
  },
  maximum: "Polji vse",
  maximumSelectedCoins: "Polji izbrane kovance",
  noFeeTargets: "Generirane provizije trenutno niso dostopne. Prosimo poizkusite ponovno ali vnesite poljubno viino provizije.",
  priority: "Omrenina",
  scanQR: "Skenirajte QR kodo",
  signprogress: {
    description: "Ta transakcija vsebuje veliko podatkov. e elite v celoti podpisati transakcijo, boste morali potrditi {{steps}} krat.",
    label: "V teku"
  },
  success: "Transakcija je bila podpisana in poslana.",
  title: "Polji {{accountName}}",
  toggleCoinControl: "Odpri nadzor nad kovanci",
  transactionDetails: "Podrobnosti transakcije"
};
const settings$3 = {
  about: "Podatki o BitBoxApp",
  accounts: "Rauni",
  advancedSettings: "Napredne nastavitve",
  appearance: "Izgled",
  electrum: {
    add: "Dodaj strenik",
    "add-server": "Dodaj",
    check: "Preveri",
    checkFailed: "Ni uspelo",
    checkSuccess: "Uspelo je vzpostaviti povezavo do {{host}}",
    checking: "Preverjam",
    "download-cert": "Prenesite oddaljeni certifikat",
    "remove-server": "Odstrani",
    removeConfirm: "Odstrani {{server}}?",
    reset: "Ponastavi na privzeto",
    resetConfirm: "Ali elite odstraniti vse strenike in namestiti privzete strenike?",
    servers: "Streniki",
    step1: "1",
    "step1-text": "Vnesite konno toko.",
    step2: "2",
    "step2-text": "Vnesite certifikat strenike verige potrdil. Lahko pa prenesete oddaljeno potrdilo in ga vizualno primerjate.",
    "step2-text-tcp": "Ta korak lahko preskoite, e ne elite uporabljati TLS.",
    step3: "3",
    "step3-text": "Preverite povezavo in dodajte strenik.",
    step4: "4",
    "step4-text": "Znova zaenite denarnico. e ne odstranite privzetih strenikov, bo vae lastno vozlie dodano kot redundanno.",
    "title-btc": "Streniki Bitcoin Electrum-a",
    "title-ltc": "Streniki Litecoin Electrum-a",
    "title-tbtc": "Streniki Bitcoin Testnet Electrum-a",
    "title-tltc": "Streniki Litecoin Testnet Electrum-a"
  },
  expert: {
    coinControl: "Omogoi nadzor nad kovanci (Coin control)",
    electrum: {
      description: "Poveete lahko svoje Electrum vozlie.",
      title: "Poveite svoje polno vozlie"
    },
    fee: "Omogoi provizije po meri",
    setProxyAddress: "Nastavite naslov proxy strenika",
    title: "Napredne nastavitve",
    useProxy: "Omogoi tor proxy",
    useSats: "Prikai vrednosti v Satoshi-jih"
  },
  header: {
    home: "Domov"
  },
  info: {
    "out-of-date": "Na voljo je nova nadgradnja",
    title: "Info",
    "up-to-date": "Aplikacija je posodobljena",
    version: "Verzija aplikacije"
  },
  restart: "Znova zaenite BitBoxApp, da spremembe zanejo veljati.",
  services: {
    title: "Storitve"
  },
  success: "Iztaknite in ponovno vtaknite BitBox v USB, da zanejo veljati ustvarjene spremembe.",
  title: "Nastavitve"
};
const setup$2 = "Nastavitev naprave";
const sidebar$3 = {
  buy: "Kupite kripto",
  device: "Upravljanje naprave",
  insurance: "Zavarovanje",
  leave: "Zapusti",
  settings: "Nastavitve"
};
const success$9 = {
  create: {
    info1: "Vaa denarnica je arhivirana na microSD kartico. \nOdstranite jo in jo varno shranite.",
    info2: "Ustvarili ste varno geslo, ki odklene BitBox.",
    info3: "Ustvarili ste varno geslo za obnovitev denarnice, ki odklene sredstva in obnovi varnostne kopije.",
    summary: "Preberite povzetek storjenega:",
    title: "Uspelo je!"
  },
  getstarted: "Zanite",
  restore: {
    summary: "Uspeno ste obnovili denarnico.",
    title: "Uspelo je!"
  }
};
const transaction$3 = {
  confirmation: "t. potrditev",
  details: {
    activity: "Dejavnost",
    address: "Naslov",
    amount: "Znesek",
    date: "Datum",
    fiat: "V fiat valuti",
    fiatAmount: "Znesek v fiat valuti",
    fiatAtTime: "Vrednost v asu transakcije",
    status: "Stanje",
    title: "Podrobnosti transakcije",
    type: "Tip"
  },
  explorer: "ID transakcije",
  explorerTitle: "Odpri v zunanjem raziskovalcu",
  fee: "Omrenina",
  fiatHistorical: "Zgodovinsko",
  gas: "Gas",
  note: {
    edit: "Uredi opombo",
    save: "Shrani opombo"
  },
  pending: "Nedokonana transakcija",
  size: "Velikost",
  status: {
    complete: "Zakljueno",
    failed: "Ni uspelo",
    pending: "V teku"
  },
  tx: {
    received: "Prejeto na",
    sent: "Poslano na"
  },
  vsize: "Virtualna velikost",
  weight: "Ute"
};
const transactions$2 = {
  errorLoadTransactions: "Napaka pri nalaganju transakcij.",
  placeholder: "Ni transakcij."
};
const unknownError$2 = "Prilo je do neznane napake: {{errorMessage}}";
const unlock$2 = {
  description: "Vnesite geslo, da odklenete napravo.",
  error: {
    e109_normal: "Napano geslo naprave. t. poskusov pred ponastavitvijo naprave: {{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) Naslednja prijava zahteva dalje dranje gumba na dotik.",
    e113: "Zaradi prevelikega tevila poskusov prijave, morate za novo prijavo pridrati tipko za dotik vsaj 4 sekunde."
  },
  input: {
    label: "Geslo naprave",
    placeholder: "...vnesite tukaj."
  },
  unlocking: "Odklepanje..."
};
const upgradeFirmware$3 = {
  button: "Nadgradite strojno programsko opremo",
  description: "Ali elite nadgraditi strojno programsko opremo iz razliice {{currentVersion}} na {{newVersion}}?",
  label: "Va BitBox zahteva nadgradnjo strojne programske opreme.",
  locked: "Za nadgradnjo z {{currentVersion}} na {{newVersion}}, izvedite dolg pritisk na LED luko.",
  title: "Nadgradite strojno programsko opremo",
  unlocked: "Zaganjalnik (bootloader) je odklenjen. e elite nadaljevati:",
  unlocked1: "Iztaknite in ponovno prikljuite svoj Bitbox",
  unlocked2: "Ko bo BitBox01 ponovno prikljuen bo zasvetila LED luka",
  unlocked3: "Ko zasveti LED luka, se jo dotaknite"
};
const walletConnect$3 = {
  connect: {
    button: "Povei",
    dappLabel: "Vnesi URI naslov za DApp",
    invalidPairingUri: "Napaen povezovalni URI"
  },
  dashboard: {
    allSessions: "Vse seje",
    disclaimer: "WalletConnect je protokol za povezavo z decentraliziranimi avtonomnimi aplikacijami (Dapps), ki temeljijo na Ethereumu. Te Dapps-e upravljajo tretje oseb (in ne Shift Crypto ali WalletConnect), zato se poveite le s tistimi, ki jim zaupate, in se prepriajte, da vedno veste, kaj podpisujete, ko opravljate transakcijo.",
    newConnection: "Nova povezava",
    noConnectedSessions: "Noben raun ni povezan s katero od DApp-ov"
  },
  invalidPairingChain: "Napaka pri potrditvi povezave. Prepriajte se, da uporabljate eno od podprtih verig: {{chains}}",
  pairingRequest: {
    approve: "Potrdi povezavo",
    reject: "Zavrni",
    title: "Zahteva za novo povezavo od"
  },
  pairingSuccess: "DApp je uspeno povezana. Nadaljujete lahko na spletni strani te DApp.",
  signingRequest: {
    account: "Raun",
    chain: "Omreje",
    dapp: "Dapp",
    data: "Podatki",
    dataParsingError: "Podatkov nismo uspeli razleniti",
    decodeError: "Sporoila nismo uspeli dekodirati",
    method: {
      sendTransaction: "Podpii in polji transakcijo",
      signMessage: "Podpii sporoilo",
      signTransaction: "Podpii transakcijo",
      signTypedData: "Podpii vnesene podatke"
    },
    successfullySigned: "Zahteva je uspeno podpisana",
    walletConnectRequest: "WalletConnect zahteva "
  },
  useNewUri: "Ta URI je bil e uporabljen za poskus vzpostavitve povezave. Uporabite nov URI.",
  walletConnect: "WalletConnect"
};
const warning$8 = {
  receivePairing: "Prosimo, da seznanite BitBox01 s pametnim telefonom, da si omogoite varno preverjanje naslovov. Pojdite na Upravljanje naprave v stranski vrstici.",
  sdcard: "MicroSD kartico hranite loeno od BitBoxa, razen ko upravljate z varnostnimi kopijami.",
  sendPairing: "Za varno preverjanje podrobnosti o transakcijah seznanite BitBox\nz mobilno napravo. Pojdite na Upravljanje naprave v stranski vrstici."
};
const welcome$2 = {
  connect: "Vklopi BitBox02",
  getStarted: "Zanimo z namestitvijo strojne programske opreme (firmware)",
  insertBitBox02: "Na BitBox02 se dotaknite eljene strani zaslona. ",
  insertDevice: "Za zaetek, prikljuite denarnico",
  title: "Dobrodoli"
};
const appTranslationsSL = {
  account: account$2,
  accountInfo: accountInfo$2,
  accountSummary: accountSummary$2,
  addAccount: addAccount$3,
  aopp: aopp$1,
  app: app$2,
  auth: auth$2,
  backup: backup$2,
  bb02Bootloader: bb02Bootloader$2,
  bitbox: bitbox$2,
  bitbox02Interact: bitbox02Interact$2,
  bitbox02Settings: bitbox02Settings$2,
  bitbox02Wizard: bitbox02Wizard$2,
  bitsurance: bitsurance$1,
  bitsuranceAccount: bitsuranceAccount$1,
  blink: blink$2,
  bootloader: bootloader$2,
  button: button$7,
  buy: buy$3,
  changePin: changePin$2,
  chart: chart$3,
  checkSDcard: checkSDcard$2,
  clickHere: clickHere$2,
  confirm: confirm$4,
  confirmOnDevice: confirmOnDevice$2,
  connectKeystore: connectKeystore$2,
  darkmode: darkmode$2,
  device: device$2,
  deviceLock: deviceLock$2,
  deviceSettings: deviceSettings$2,
  deviceTampered: deviceTampered$2,
  dialog: dialog$3,
  error: error$3,
  fiat: fiat$4,
  footer: footer$4,
  generic: generic$3,
  genericError: genericError$2,
  goal: goal$2,
  guide: guide$3,
  headerssync: headerssync$2,
  hiddenWallet: hiddenWallet$2,
  initialize: initialize$2,
  invalidFormat: invalidFormat$2,
  language: language$3,
  legacyhiddenwallet: legacyhiddenwallet$2,
  loading: loading$2,
  manageAccounts: manageAccounts$1,
  mobile: mobile$2,
  newSettings: newSettings$1,
  note: note$3,
  notification: notification$2,
  pairing: pairing$2,
  passphrase: passphrase$1,
  password: password$2,
  random: random$3,
  receive: receive$4,
  reset: reset$2,
  securityInformation: securityInformation$2,
  seed: seed$2,
  seedRestore: seedRestore$2,
  send: send$4,
  settings: settings$3,
  setup: setup$2,
  sidebar: sidebar$3,
  success: success$9,
  transaction: transaction$3,
  transactions: transactions$2,
  unknownError: unknownError$2,
  unlock: unlock$2,
  upgradeFirmware: upgradeFirmware$3,
  walletConnect: walletConnect$3,
  warning: warning$8,
  welcome: welcome$2
};
const account$1 = {
  disconnect: "... .  ",
  "export": "",
  exportTransactions: "     ",
  fatalError: ".   ",
  incoming: "",
  initializing: "  ..",
  reconnecting: "... ,   ",
  syncedAddressesCount: " {{count}} "
};
const accountInfo$1 = {
  address: "",
  extendedPublicKey: "  ",
  label: " ",
  title: " ",
  verify: "  "
};
const accountSummary$1 = {
  availableBalance: " ",
  balance: "",
  exportSummary: "      ",
  fiatBalance: "  ",
  name: " ",
  noAccount: "  ",
  title: " ",
  total: " ",
  transactionHistory: " "
};
const addAccount$2 = {
  title: " "
};
const app$1 = {
  upgrade: "     !   {{current}} {{version}}"
};
const backup$1 = {
  check: {
    checking: "... ",
    confirmTitle: " ",
    notOK: ".    ",
    ok: ".   ",
    password: {
      label: " ",
      placeholder: " ",
      showLabel: " "
    },
    success: ":  ",
    title: " "
  },
  create: {
    alreadyExists: "?  .    ",
    fail: "!   ",
    info: ".         ",
    name: {
      label: " ",
      placeholder: "   "
    },
    password: {
      label: " ",
      placeholder: "    "
    },
    title: " ",
    verificationFailed: ".      .  .      "
  },
  description: " <strong>  </strong>",
  insert: "      ",
  insertButton: "   ",
  list: "   ",
  noBackups: "    ",
  restore: {
    confirmTitle: " ",
    error: {
      e200: "   ",
      general: "  "
    },
    password: {
      label: "     ",
      placeholder: " ",
      repeatPlaceholder: "     ",
      showLabel: " "
    },
    restoring: "... ",
    title: "",
    understand: "       "
  },
  showMnemonic: {
    description: ".  24 ,   .     \n\n<strong>      </strong>\n<strong>    </strong>\n<strong>   </strong>\n\n. ,    ",
    title: "mnemonic seed -"
  },
  title: " "
};
const bb02Bootloader$1 = {
  abort: "  -   ",
  advanced: {
    label: " ",
    toggleShowFirmwareHash: "      "
  },
  flipscreen: " ",
  orientation: "?   ",
  success: "... !   {{rebootSeconds}} "
};
const bitbox$1 = {
  error: {
    e10000: ".    ",
    e10001: "   ",
    e102: ".    4  ",
    e112: ".         "
  }
};
const bitbox02Interact$1 = {
  confirmDate: "     02",
  confirmDateText: ".   ",
  confirmName: "   02",
  followInstructions: "    02",
  followInstructionsMnemonic: "mnemonic seed -     02    "
};
const bitbox02Settings$1 = {
  deviceName: {
    current: "  ",
    input: " 02",
    placeholder: "  ",
    title: "  02"
  }
};
const bitbox02Wizard$1 = {
  attestationFailed: ".  ,            .    ",
  backup: {
    point1: "   ",
    point2: "  ",
    restoreText: "!,  ",
    text1: ".,  02   .       .       02 - ",
    text2: "           ",
    text3: ".  ,         <strong> </strong>.       .       02  ",
    userConfirmation1: ".      ",
    userConfirmation2: ".    .         ",
    userConfirmation3: ".   02 ,         ",
    userConfirmation4: ".   , 02 ,   ",
    userConfirmation5: "        , ,      "
  },
  create: {
    button: "   ",
    info: ":    ",
    inputTitle: " ",
    point1: "  ",
    point2: "  ",
    point3: " ",
    text: "!,    "
  },
  createBackupFailed: ".  ,  ",
  initialize: {
    passwordText: ".   .      ",
    passwordTitle: "   ",
    text: "   !     02.          . <strong>       02</strong>",
    tip: ".    ",
    title: "  "
  },
  insertSDCard: "<strong>      02</strong>",
  noPasswordMatch: ".  ,   ",
  pairing: {
    failed: ".  .    02",
    paired: ".    .   ,       ",
    title: "  ",
    unpaired: ".02  .        .   ,         "
  },
  restoreFromMnemonic: {
    failed: ".,    mnemonic seed - "
  },
  stepBackup: {
    beforeProceed: ": ,       ",
    createBackup: ".    "
  },
  stepBackupSuccess: {
    fundsSafe: ":-   , ",
    title: "! "
  },
  stepConnected: {
    unlock: "   02   "
  },
  stepCreate: {
    nameLabel: " 02",
    namePlaceholder: "02 ",
    title: "  02",
    toastMicroSD: ".       02"
  },
  stepCreateSuccess: {
    removeMicroSD: ".     02    ",
    success: ".  "
  },
  stepInsertSD: {
    insertSDCard: ".     02  ",
    insertSDcardTitle: ".  "
  },
  stepPassword: {
    title: "  02",
    useControls: ".     02"
  },
  stepUninitialized: {
    create: ".   02 ",
    restore: ".      ",
    restoreMicroSD: "  ",
    restoreMnemonic: "mnemonic seed -",
    title: "  02 "
  },
  success: {
    text: ".! 02   \n\n.     ,          ",
    title: "!  "
  }
};
const blink$1 = {
  button: ""
};
const bootloader$1 = {
  button: "  ",
  progress: "%: {{progress}}",
  success: ". !     . ,   "
};
const button$6 = {
  abort: "",
  back: "",
  buy: "",
  changepin: "  ",
  check: " ",
  "continue": "",
  copy: "",
  create: "",
  download: "",
  hiddenwallet: "  ",
  next: "",
  ok: "",
  previous: "",
  receive: "",
  restore: "",
  select: "",
  send: "",
  unlock: " ",
  update: "",
  upgrade: ""
};
const buy$2 = {
  title: " {{name}}"
};
const changePin$1 = {
  newTitle: "  ",
  oldLabel: "  "
};
const chart$2 = {
  dataMissing: "   ,      ",
  dataUpdating: "... ",
  filter: {
    all: "",
    month: "",
    week: "",
    year: ""
  }
};
const checkSDcard$1 = "  ";
const clickHere$1 = ". ";
const confirm$3 = {
  abortInfo: " ",
  abortInfoRedText: "",
  approveInfo: " 4+  ",
  approveInfoGreenText: "",
  info: ". ",
  infoWhenPaired: "    "
};
const confirmOnDevice$1 = ".   ";
const device$1 = {
  appUpradeRequired: ".    - .     "
};
const deviceLock$1 = {
  button: "  -",
  condition1: "?  ",
  condition2: "?    ",
  condition3: " -     .       -",
  confirm: "  -",
  title: "  -"
};
const deviceSettings$1 = {
  firmware: {
    newVersion: {
      label: " "
    },
    title: "",
    upToDate: "  ",
    version: {
      label: ""
    }
  },
  hardware: {
    sdcard: {
      "false": " ",
      label: " ",
      "true": ""
    },
    title: ""
  },
  loading: "   ",
  pairing: {
    lock: {
      "false": "",
      label: " -",
      "true": ""
    },
    mobile: {
      "false": "",
      label: " ",
      "true": ""
    },
    status: {
      "false": " ",
      label: "",
      "true": ""
    },
    title: ""
  },
  secrets: {
    manageBackups: " ",
    title: ""
  }
};
const deviceTampered$1 = ".     ?  ,        .          ";
const dialog$2 = {
  cancel: "",
  confirm: "",
  confirmTitle: ""
};
const fiat$3 = {
  "default": " ",
  setDefault: " {{code}}  ",
  title: ""
};
const footer$3 = {
  appVersion: " :"
};
const generic$2 = {
  enabled_false: "",
  enabled_true: ""
};
const genericError$1 = " .    ,    .";
const goal$1 = {
  buttons: {
    create: "  ",
    restore: "  "
  },
  paragraph: "   :",
  step: {
    "1": {
      title: "  "
    },
    "2": {
      description: "  ",
      title: ""
    },
    "3-create": {
      description: "  ",
      title: ""
    },
    "3-restore": {
      description: "",
      title: ""
    },
    "4-create": {
      title: ""
    },
    "4-restore": {
      title: ""
    }
  }
};
const guide$2 = {
  accountDescription: {
    text: ".            .   ' '      ",
    title: "?    "
  },
  accountFiat: {
    text: "..         .      ",
    title: "?     "
  },
  accountIncomingBalance: {
    text: ".       ",
    title: "?  "
  },
  accountInfo: {
    xpub: {
      text: ".         \n.         ,    ",
      title: "?    "
    }
  },
  accountRates: {
    text: "        -.",
    title: "?   "
  },
  accountReload: {
    text: ". .     ",
    title: "?      "
  },
  accountSendDisabled: {
    text: ". ''    ",
    title: "?      {{unit}}"
  },
  accountSummaryAmount: {
    text: "coingecko.com        .    \n\n    ,      MyEtherWallet :    \n\n",
    title: "?   "
  },
  accountSummaryDescription: {
    text: "         .         ",
    title: "?    "
  },
  accountTransactionAttributesBTC: {
    text: ". :    .        \n.:        \n.     .      ,     .  -   ,          SegWit :    ",
    title: "?      "
  },
  accountTransactionAttributesGeneric: {
    text: ".:          ,    .         .             \n. :        \n.:          .  ,    ",
    title: "?    "
  },
  accountTransactionConfirmation: {
    text: ".     ",
    title: "?   "
  },
  accountTransactionLabel: {
    text: ".        ",
    title: "?     "
  },
  accountTransactionTime: {
    text: ".     ",
    title: "?   "
  },
  appendix: {
    link: "  ",
    text: " ?"
  },
  backups: {
    check: {
      text: ". '           .          .          '",
      title: "'  ' "
    },
    encrypt: {
      text: ". Seed -,          ",
      title: "?    "
    },
    howOften: {
      text: ".      .           ,       \n.     .          ",
      title: "?    "
    },
    whatIsABackup: {
      text: ".       Seed -   .  Seed -   ",
      title: "?  "
    }
  },
  backupsBB02: {
    check: {
      text: ". '           '",
      title: "?'  ' "
    },
    encrypt: {
      text: '. ,         "  Seed -     .      Seed -.      ,     ',
      title: "?    "
    },
    whatIsABackup: {
      text: ".    Seed -    ",
      title: "?  "
    }
  },
  bitbox: {
    "2FA": {
      text: ".  - ,           .          -,  ,       .                  \n\n.             -.  ,       .           ",
      title: "?  - "
    },
    disable2FA: {
      text: "-    -,           .               .    ' '.       '  '.       ''          .",
      title: "?      -"
    },
    ejectBitbox: {
      text: ".    ",
      title: "?    "
    },
    ejectSD: {
      text: ".      ,      ",
      title: "?     "
    },
    hiddenWallet: {
      text: ".     ,      Seed -     ,        ",
      title: "?   "
    },
    legacyHiddenWallet: {
      text: ".     (          - ),             ",
      title: "?     "
    },
    pairing: {
      text: ".      , QR       ,     \n. ,     ",
      title: "      "
    }
  },
  receive: {
    address: {
      text: "        .      ",
      title: "?    "
    },
    addressChange: {
      text: ".  ,     ,     20     ",
      title: "?  "
    },
    addressFormats: {
      text: " ,       .       ,        ",
      title: "?       "
    },
    howVerify: {
      text: "01,           .        \n02,           ",
      title: "?     "
    },
    why20: {
      text: '.    .         ,      .          20     .  " " - 20   -     .  20     Seed - ,     ',
      title: "?  20 "
    },
    whyMany: {
      text: ".   Seed -    ,       .   ,       .     20   .      .    ",
      title: "?   -  "
    },
    whyVerify: {
      text: "         .           .  01,          ,       -.  02,         02",
      title: "      ?"
    }
  },
  send: {
    fee: {
      text: ".        .               .         \n(: 24  ( 4  ,   \n(: 12  (  , 30   \n(: 6  ( , 15   \n(: 2  ( 20  , 5   \n      (2.5  )        ",
      title: "?  "
    },
    priority: {
      text: ".        ,      ",
      title: "?   "
    },
    revert: {
      text: "!    ,   .    ( )   \n.            (  )  ,      ",
      title: "?   "
    },
    whyFee: {
      text: ".    .        \n    .           (     ),            .   ,              ",
      title: "?   "
    }
  },
  "settings-electrum": {
    connection: {
      text: "          (,   ),    \n ,      ..  \n      ,    .    ..  ",
      title: "?   , ..  .."
    },
    instructions: {
      link: {
        text: "   "
      },
      text: ": ,   ",
      title: "?        "
    },
    options: {
      text: "     .    ,       \n       ,      .         \n   ,     ",
      title: "?    "
    },
    tor: {
      text: "         ,    .       ,           .        :\n -        9150\n -    \n       9050  ",
      title: "?  ,      "
    },
    what: {
      text: "           ",
      title: "? "
    },
    why: {
      text: "              . ,       ,       -    . ,       .",
      title: "?    "
    }
  },
  settings: {
    servers: {
      text: "  ,        Shift Crypto -    \n          -\n,    ,          \n.Etherscan.io APIs -   ERC20 -   ",
      title: "?    "
    }
  },
  title: "",
  toggle: {
    close: " ",
    open: ""
  },
  unlock: {
    forgotDevicePassword: {
      text: ".        ,   ",
      title: "?      "
    },
    reset: {
      text: ".   15 .        ",
      title: "?    "
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "     .     .   ,      ",
      title: " 01   "
    },
    getDevice: {
      link: {
        text: "  "
      },
      text: ":     ",
      title: "?    "
    },
    internet: {
      text: ",       ,      ",
      title: "    ?"
    },
    lostDevice: {
      link: {
        text: " "
      },
      text: "          ",
      title: "?  .  "
    },
    useWithoutDevice: {
      text: ".,    ",
      title: "?     "
    },
    welcome: {
      text: "        \n   ,     ",
      title: "!   "
    }
  }
};
const headerssync$1 = {
  blocksSynced: "{{blocks}}  "
};
const hiddenWallet$1 = {
  info1HTML: ".<strong></strong>  ,         +  ",
  info2HTML: ".          .      <strong></strong>     ",
  passwordLabel: "  ",
  passwordPlaceholder: "     ",
  pinLabel: "  ",
  pinRepeatLabel: "    ",
  pinRepeatPlaceholder: "     ",
  success: ".   .         "
};
const initialize$1 = {
  create: "  ",
  creating: "...  ",
  error: {
    e102: ".     4 "
  },
  info: {
    description1: ".   .       ",
    description2: ".  ,  .     ",
    description3: ".   ,       ",
    subtitle: "     ",
    title: "  "
  },
  input: {
    label: " ",
    labelRepeat: "   ",
    placeholderRepeat: "    "
  }
};
const invalidFormat$1 = " ";
const language$2 = {
  title: " "
};
const legacyhiddenwallet$1 = {
  disable: "     ",
  enable: "     ",
  successDisable: "      ",
  successEnable: "      .               "
};
const loading$1 = "...";
const mobile$1 = {
  usingMobileDataWarning: ".     WiFi-  :        -        .   \n. ,     "
};
const note$2 = {
  input: {
    description: "",
    placeholder: "... "
  },
  title: ""
};
const notification$1 = {
  newTxs_one: "{{count}}   : {{accountName}}",
  newTxs_other: "{{count}}   : {{accountName}}"
};
const pairing$1 = {
  aborted: {
    text: ".  -  ",
    title: ""
  },
  button: "  ",
  confirm: ".      ?     ,     ",
  connectOnly: {
    button: "  ",
    title: "'    , -   '  "
  },
  error: {
    text: ". .  ",
    title: ""
  },
  pullFailed: {
    text: ".       .       ,     ",
    title: " "
  },
  reconnectOnly: {
    button: "    "
  },
  scanningFailed: {
    text: ".      .  ",
    title: " "
  },
  start: {
    hideAppQRCode: "QR  ",
    revealAppQRCode: "QR  ",
    step1: ".     ,     QR      ,   ",
    step2: "Digital BitBox 2FA -   ,          "
  },
  started: {
    text: ",     ",
    title: ""
  },
  success: {
    text: "! ,         ",
    title: ""
  },
  timeout: {
    text: "     .        ",
    title: " "
  },
  title: " "
};
const password$1 = {
  show: " {{label}}",
  warning: {
    caps: ":  () ",
    paste: "  ,   {{label}}"
  }
};
const random$2 = {
  button: "  ",
  description: ":     {{bits}}- "
};
const receive$3 = {
  label: "",
  onlyThisCoin: {
    description: ".   ,   .    ,     ",
    warning: ".    {{coinName}}   "
  },
  showFull: "    ",
  title: " {{accountName}}",
  verify: "   ",
  verifyBitBox01: "   ",
  verifyBitBox02: "  02",
  verifyInstruction: ".            ",
  warning: {
    secureOutput: ".           .  ' '  "
  }
};
const reset$1 = {
  description: "!   ,      ",
  notReset: ".  ",
  title: "  ",
  understand: "    ",
  understandBB02: "   "
};
const securityInformation$1 = {
  create: {
    description1: ".      ,         ",
    description2: ".   ",
    description3: ".  <strong> </strong>          ",
    description4: ".  <strong> </strong>    .       ",
    description5: "        .           <strong> </strong>",
    title: "  "
  },
  restore: {
    description1: ".       ",
    description2: "   ,    ",
    description3: ".        .      .            ",
    title: "  "
  }
};
const seed$1 = {
  agreements: {
    "funds-access": "          ",
    "password-change": "        ",
    "password-required": "      "
  },
  create: " ",
  creating: " ",
  description: ":  ",
  error: {
    e102: ".    4 ",
    e200: ".     , -  ,    "
  },
  info: {
    button: "   ",
    description1: "    ",
    description2: "        ",
    description3: ".           ,       ",
    description4: ".      ,    ",
    title: "  "
  },
  password: {
    label: " ",
    repeatPlaceholder: "   "
  },
  walletName: {
    label: " "
  }
};
const seedRestore$1 = {
  error: {
    e200: ".     "
  },
  info: {
    description1: "       ",
    description2: "   ",
    description3: "   ",
    description4: ".        ",
    title: "   "
  }
};
const send$3 = {
  abort: " ",
  address: {
    label: " ",
    placeholder: " "
  },
  amount: {
    label: "",
    placeholder: " "
  },
  availableBalance: " ",
  button: "",
  coincontrol: {
    address: "",
    outpoint: " ",
    title: " "
  },
  confirm: {
    "selected-coins": " ",
    title: "  ",
    total: " "
  },
  error: {
    feeTooLow: "  ",
    insufficientFunds: "  ",
    invalidAddress: " ",
    invalidAmount: " ",
    invalidData: " "
  },
  fee: {
    customPlaceholder: " ",
    label: " ",
    placeholder: " "
  },
  feeTarget: {
    description: {
      economy: "(: 24 ( 4  ,  ",
      economy_ltc: "( (24 ",
      high: "(: 2 ( 20  , 5  ",
      high_ltc: "(  (2 ",
      low: "(: 12 (  , 30  ",
      low_ltc: "(  (12 ",
      normal: "(: 6 (  ,   ",
      normal_ltc: "(  (6 "
    },
    estimate: ":  ",
    label: {
      custom: "",
      economy: "",
      high: "",
      low: "",
      normal: ""
    },
    placeholder: "...  "
  },
  maximum: " ",
  priority: "",
  scanQR: "QR  ",
  signprogress: {
    description: ".    .      ,   {{steps}} ",
    label: ""
  },
  success: "  ",
  title: " {{accountName}}",
  toggleCoinControl: "  ",
  transactionDetails: " "
};
const settings$2 = {
  electrum: {
    add: " ",
    "add-server": "",
    check: "",
    checkFailed: "",
    checkSuccess: "   {{host}}",
    checking: "",
    "download-cert": "  ",
    "remove-server": "",
    removeConfirm: "? {{server}}",
    reset: "  ",
    resetConfirm: "?          ",
    servers: "",
    step1: "1",
    "step1-text": "  ",
    step2: "2",
    "step2-text": "      . ,       ",
    "step2-text-tcp": "TLS -        ",
    step3: "3",
    "step3-text": "     ",
    step4: "4",
    "step4-text": "   .       ,    ",
    "title-btc": "  ",
    "title-ltc": "  ",
    "title-tbtc": "Bitcoin Testnet Electrum ",
    "title-tltc": "Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "  ",
    electrum: {
      title: "    "
    },
    fee: "  ",
    setProxyAddress: "  ",
    title: " ",
    useProxy: "  "
  },
  header: {
    home: ""
  },
  restart: ".      ",
  services: {
    title: ""
  },
  success: ".       ",
  title: ""
};
const setup$1 = " ";
const sidebar$2 = {
  device: " ",
  leave: "",
  settings: ""
};
const success$8 = {
  create: {
    info1: "      .    .",
    info2: "       .",
    info3: ".     ,       ",
    summary: "    ",
    title: ""
  },
  getstarted: "",
  restore: {
    summary: ".    ",
    title: ""
  }
};
const transaction$2 = {
  confirmation: "",
  details: {
    activity: "",
    address: "",
    amount: "",
    date: "",
    fiat: "",
    fiatAmount: " ",
    status: "",
    type: ""
  },
  explorer: " ",
  explorerTitle: "   ",
  fee: "",
  fiatHistorical: "",
  gas: "",
  note: {
    edit: " ",
    save: " "
  },
  pending: " ",
  size: "",
  status: {
    complete: "",
    failed: "",
    pending: ""
  },
  tx: {
    received: " ",
    sent: " "
  },
  vsize: " ",
  weight: ""
};
const transactions$1 = {
  placeholder: ".  "
};
const unknownError$1 = "   : {{errorMessage}}";
const unlock$1 = {
  description: ".       ",
  error: {
    e109_normal: ".  . {{remainingAttempts}}     ",
    e109_touch: ".$t(unlock.error.e109_normal)       ",
    e113: ".  ,         4 "
  },
  input: {
    label: " ",
    placeholder: "       "
  },
  unlocking: "... "
};
const upgradeFirmware$2 = {
  button: " ",
  description: "?     {{currentVersion}} {{newVersion}}",
  label: "    ",
  locked: "  {{currentVersion}} {{newVersion}}},   ",
  title: " ",
  unlocked: ": .  ",
  unlocked1: "    ",
  unlocked2: "       ",
  unlocked3: "     "
};
const warning$7 = {
  receivePairing: ".    -     .  ' '  ",
  sdcard: "     ,      ",
  sendPairing: ".    -   .  ' '  "
};
const welcome$1 = {
  insertBitBox02: "   ",
  insertDevice: "    ",
  title: " "
};
const appTranslationsHE = {
  account: account$1,
  accountInfo: accountInfo$1,
  accountSummary: accountSummary$1,
  addAccount: addAccount$2,
  app: app$1,
  backup: backup$1,
  bb02Bootloader: bb02Bootloader$1,
  bitbox: bitbox$1,
  bitbox02Interact: bitbox02Interact$1,
  bitbox02Settings: bitbox02Settings$1,
  bitbox02Wizard: bitbox02Wizard$1,
  blink: blink$1,
  bootloader: bootloader$1,
  button: button$6,
  buy: buy$2,
  changePin: changePin$1,
  chart: chart$2,
  checkSDcard: checkSDcard$1,
  clickHere: clickHere$1,
  confirm: confirm$3,
  confirmOnDevice: confirmOnDevice$1,
  device: device$1,
  deviceLock: deviceLock$1,
  deviceSettings: deviceSettings$1,
  deviceTampered: deviceTampered$1,
  dialog: dialog$2,
  fiat: fiat$3,
  footer: footer$3,
  generic: generic$2,
  genericError: genericError$1,
  goal: goal$1,
  guide: guide$2,
  headerssync: headerssync$1,
  hiddenWallet: hiddenWallet$1,
  initialize: initialize$1,
  invalidFormat: invalidFormat$1,
  language: language$2,
  legacyhiddenwallet: legacyhiddenwallet$1,
  loading: loading$1,
  mobile: mobile$1,
  note: note$2,
  notification: notification$1,
  pairing: pairing$1,
  password: password$1,
  random: random$2,
  receive: receive$3,
  reset: reset$1,
  securityInformation: securityInformation$1,
  seed: seed$1,
  seedRestore: seedRestore$1,
  send: send$3,
  settings: settings$2,
  setup: setup$1,
  sidebar: sidebar$2,
  success: success$8,
  transaction: transaction$2,
  transactions: transactions$1,
  unknownError: unknownError$1,
  unlock: unlock$1,
  upgradeFirmware: upgradeFirmware$2,
  warning: warning$7,
  welcome: welcome$1
};
const account = {
  disconnect: "Connessione interrotta. Riprovo...",
  "export": "Esporta",
  exportTransactions: "Esporta transazioni in formato CSV nella cartella download",
  fatalError: "Si  verificato un errore inatteso",
  incoming: "In entrata",
  initializing: "Raccolgo informazioni dalla blockchain",
  insuranceExpired: "<strong>Account non pi assicurato</strong>\n\nIl piano assicurativo per questo conto  stato modificato.\nControlla la pagina dell'assicurazione per i dettagli.",
  insured: "Account assicurato",
  maybeProxyError: "Proxy Tor attivato. Assicurati che il tuo proxy Tor funzioni correttamente, oppure disabilita l'impostazione del proxy.",
  reconnecting: "Connessione persa, provo a riconnettermi...",
  syncedAddressesCount: "{{count}} indirizzi letti",
  uncoveredFunds: "L'account <strong>{{name}}</strong> ha fondi sui seguenti tipi di indirizzi non coperti: {{uncovered}}.\nL'account  assicurato, ma solo i fondi ricevuti tramite indirizzi di tipo <strong>Native Segwit</strong> sono coperti. I fondi ricevuti tramite indirizzi di altro tipo, anche se si trovano sullo stesso account, non sono assicurati.\nSposta tutte i tuoi fondi dagli indirizzi non supportati a indirizzi di tipo <strong>Native Segwit</strong>, cos che tutti i fondi di questo account siano coperti dall'assicurazione.",
  uncoveredFundsLink: "Segui questa guida per spostare i tuoi fondi.",
  warning: "Attenzione!"
};
const accountInfo = {
  address: "Indirizzo",
  buyCTA: {
    buy: "Acquista {{unit}}",
    buyCrypto: "Acquista cryptovalute",
    information: {
      looksEmpty: "Sembra che il wallet sia vuoto.",
      start: "Iniziate depositando alcune valute nel wallet o acquistando direttamente nella BitBoxApp."
    }
  },
  extendedPublicKey: "Chiave pubblica estesa",
  label: "Informazioni sull'account",
  scriptType: "Tipo di script",
  title: "Informazioni sull'account",
  verify: "Verifica sul dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizza la chiave pubblica estesa di P2PKH",
    p2tr: "Visualizza Taproot",
    p2wpkh: "Visualizza Native Segwit",
    "p2wpkh-p2sh": "Visualizza la chiave pubblica estesa Segwit pi vecchia"
  },
  xpubTypeInfo: "Attualmente viene visualizzata la chiave pubblica estesa {{scriptType}} ({{current}} di {{numberOfXPubs}})"
};
const accountSummary = {
  availableBalance: "Saldo disponibile",
  balance: "Saldo",
  exportSummary: "Esporta il riepilogo dell'account in formato CSV nella cartella download",
  fiatBalance: "Saldo fiat",
  name: "Nome account",
  noAccount: "Non ci sono account da mostrare",
  subtotalWithCoinName: "Totale ({{coinName}})",
  title: "Il mio portafoglio",
  total: "Totale",
  transactionHistory: "Storico transazioni"
};
const addAccount$1 = {
  chooseName: {
    nextButton: "Aggiungi account",
    step: "Nome dell'account",
    title: "Assegna un nome all'account"
  },
  selectCoin: {
    nextButton: "Avanti",
    step: "Seleziona valuta",
    title: "Seleziona cryptovaluta"
  },
  success: {
    addAnotherAccount: "Aggiungi un nuovo account",
    message: "<strong>{{accountName}}</strong>  stato aggiunto ai tuoi account.",
    nextButton: "Fatto",
    step: "Finito",
    title: "Account aggiunto"
  },
  title: "Aggiungi account"
};
const aopp = {
  addressRequest: "{{host}} richiede un indirizzo di ricezione.",
  addressRequestWithLogo: "richiede un indirizzo di ricezione\n",
  banner: "Richiesta dell'indirizzo in corso. Connetti il dispositivo per continuare.",
  errorTitle: "Errore durante la richiesta dell'indirizzo",
  labelAddress: "Indirizzo",
  labelMessage: "Messaggio",
  reverifyInfoText: "Verifica indirizzo",
  signing: "Per procedere, firmare il messaggio sul BitBox02\n",
  success: {
    message: "Continua su {{host}}",
    title: "Indirizzo inviato con successo"
  },
  syncing: "Sincronizzazione dell'account, attendere prego.\n",
  title: "Richiesta di indirizzo"
};
const app = {
  upgrade: "E' disponibile una nuova versione di questa app! Aggiorna dalla {{current}} alla {{version}}."
};
const auth$1 = {
  authButton: "Autenticati",
  title: "Autenticati per continuare"
};
const backup = {
  check: {
    checking: "Sto verificando backup...",
    confirmTitle: "Verifica backup",
    notOK: "Il backup NON combacia con il wallet.",
    ok: "Il backup combacia con il wallet.",
    password: {
      label: "Password di recupero",
      placeholder: "Password di recupero",
      showLabel: "password di recupero"
    },
    success: "Back verificato con successo:",
    title: "Verifica backup"
  },
  create: {
    alreadyExists: "Hai gi un backup valido. Vuoi ricrearlo?",
    fail: "Creazione backup FALLITA!",
    info: "Inserisci la password di recupero del wallet attuale per la verifica.",
    name: {
      label: "Nome del backup",
      placeholder: "Assegna un nome al backup"
    },
    password: {
      label: "Password di recupero",
      placeholder: "Inserisci la tua password di recupero"
    },
    title: "Crea backup",
    verificationFailed: "La password di recupero NON corrisponde al wallet attuale. Il backup  stato creato. Per favore usa 'Controlla backup' per verificare di nuovo la tua password di recupero."
  },
  description: "Scegli <strong>il file di backup del wallet</strong>",
  insert: "Inserisci la carta microSD per gestire i backup.",
  insertButton: "Ho inserito la carta microSD",
  list: "I tuoi backup sulla carta microSD",
  noBackups: "Non ci sono backup su questa carta microSD",
  restore: {
    confirmTitle: "Ripristina backup",
    error: {
      e200: "Carta microSD non trovata",
      general: "Errore nel ripristino del backup"
    },
    password: {
      label: "Password di recupero o password di recupero nascosta",
      placeholder: "Password di recupero",
      repeatPlaceholder: "Ripeti password di recupero",
      showLabel: "Password di recupero"
    },
    restoring: "Ripristino backup...",
    selectedBackup: "<strong>{{backupName}}</strong> creato in data {{createdDateTime}} verr ripristinato.",
    title: "Ripristina",
    understand: "Capisco che una password di recupero errata creer un wallet diverso"
  },
  showMnemonic: {
    description: "Ti verranno mostrate le parole di recupero, che formano un backup del tuo wallet. Scrivile su carta.\n\n<strong>Non custodirle digitalmente e non fotografarle.</strong>\n\n<strong>Non pronunciare le parole ad alta voce.</strong>\n\n<strong>Questo backup non  protetto da password.</strong>\n\nIn seguito ti sar richiesto di confermare ogni parola.",
    title: "Mostra le parole di recupero",
    warning: "<strong>Non condividere le tue parole di recupero con nessuno.</strong> Le parole di recupero danno pieno accesso al tuo wallet. Se qualcuno ti chiede le tue parole di recupero, vuole truffarti. Non condividerle!"
  },
  title: "Gestisci i backup"
};
const bb02Bootloader = {
  abort: "Non aggiornare - riportami indietro",
  abort_noUpgrade: "Indietro",
  advanced: {
    label: "Impostazioni avanzate",
    toggleShowFirmwareHash: "Mostrami l'hash del firmware ogni volta all'avvio"
  },
  flipscreen: "Capovolgi schermo",
  orientation: "Orientamento del dispositivo sbagliato?",
  success: "Aggiornamento riuscito! Passo successivo in {{rebootSeconds}} secondi...",
  success_install: "Installazione riuscita! Continua tra {{rebootSeconds}} secondi..."
};
const bitbox = {
  error: {
    e10000: "Password errata per questo dispositivo",
    e10001: "Impossibile sostituire la password del dispositivo",
    e102: "La password deve essere di almeno 4 caratteri.",
    e112: "La password nascosta non pu essere uguale alla password principale del dispositivo."
  }
};
const bitbox02Interact = {
  confirmDate: "Conferma la data di oggi sul tuo BitBox02",
  confirmDateText: "Questa data sar usata per creare il tuo backup.",
  confirmName: "Conferma il nome sul BitBox02",
  confirmWords: "Prendi nota delle {{amount}} parole di recupero dal tuo BitBox02",
  confirmWordsText: "In seguito il BitBox02 ti chieder di confermare ogni parola per verificare la correttezza del tuo backup.",
  followInstructions: "Segui le istruzioni sul tuo BitBox02",
  followInstructionsMnemonic: "Segui le istruzioni sul tuo BitBox02 per ripristinare utilizzando le parole di recupero.",
  followInstructionsMnemonicTitle: "Ripristina da parole di recupero\n"
};
const bitbox02Settings = {
  deviceName: {
    current: "Nome attuale del dispositivo",
    error: "Non  stato possibile configurare il nome del dispositivo",
    error_104: "La conferma del nome del dispositivo  stata abortita sul dispositivo.",
    input: "Nome del BitBox02",
    placeholder: "Nuovo nome del dispositivo",
    title: "Imposta il nome del BitBox02"
  },
  gotoStartupSettings: {
    description: "Questo riavvia il BitBox02 e inizializza le impostazioni di avvio.",
    title: "Vai alle impostazioni di avvio\n"
  }
};
const bitbox02Wizard = {
  advanced: {
    button: "Opzioni avanzate",
    outOfDate: "Firmware non aggiornato per questa funzionalit",
    seed12WordInfo: "Attenzione, il numero di parole non potr essere modificato dopo la creazione del wallet.",
    seed12WordLabel: "Crea un seed da 12 parole invece di 24",
    seed12WordText: "Il BitBox02 di default usa un seed da 24 parole. All'atto pratico, entrambe le lunghezze del seed sono sicure contro attacchi di tipo brute force. Alcuni utenti potrebbero preferire la comodit di un seed da 12 parole.",
    skipSDCardLabel: "Salta il backup su microSD e sostituiscilo annotando le parole di recupero",
    skipSDCardText: "Hai sempre l'opzione di creare un backup su microSD o annotare le parole di recupero dopo il setup. Puoi farlo dalle impostazioni.",
    title: "Opzioni di backup avanzate"
  },
  attestationFailed: "L'attestazione del dispositivo non  riuscita. Ci potrebbe essere dovuto al riavvio dell'app mentre il dispositivo stava aspettando l'input dell'utente. Si prega di ricollegarsi e riprovare. Contattare support@bitbox.swiss se l'errore persiste.",
  backup: {
    point1: "Scegli un backup sulla carta microSD",
    point2: "Imposta una password per il tuo dispositivo",
    restoreText: "Ok, ripristiniamo un backup!",
    text1: "Bene, la tua password di BitBox02  ora impostata e il wallet creato. Ora  il momento di creare il tuo primo backup. Assicurati che la tua scheda microSD sia inserita nel tuo BitBox02 e continua.",
    text2: "Segui le istruzioni sullo schermo del tuo dispositivo per creare un backup.",
    text3: "Dopo che il backup  stato creato, rimuovi la scheda microSD e conservala in un luogo <strong>sicuro</strong>. Il contenuto della scheda microSD non  protetto da password. Non inserirla mai in nessun altro dispositivo che non sia il tuo BitBox02.",
    userConfirmation1: "Devo conservare il backup in un luogo sicuro.",
    userConfirmation2: "Il backup non  protetto da una password. Chiunque abbia accesso ad esso pu accedere anche al mio wallet.",
    userConfirmation3: "Se perdo o danneggio il mio BitBox02, l'unico modo per recuperare i miei fondi  ripristinare il backup.",
    userConfirmation4: "Se perdo o danneggio sia il backup che il dispositivo BitBox02, i miei fondi andranno persi.",
    userConfirmation5: "Non devo inserire il mio backup su scheda microSD in un computer, telefono, stampante o qualsiasi altro dispositivo che non sia un BitBox02.",
    userConfirmation5mnemonic: "Non devo inserire le mie parole di recupero in un computer, telefono, stampante o altro dispositivo diverso da BitBox02."
  },
  create: {
    button: "Assegnare un nome al dispositivo e continuare",
    info: "Ecco i passaggi necessari per configurare il tuo BitBox: ",
    inputTitle: "Nome del wallet",
    point1: "Dai un nome al tuo dispositivo",
    point2: "Imposta una password per il tuo dispositivo",
    point3: "Crea un backup",
    text: "Bene, ora creiamo un nuovo wallet!"
  },
  createBackupAborted: "Creazione del backup interrotta.",
  createBackupFailed: "Creazione del backup fallita. Riprovare.",
  initialize: {
    passwordText: "Ora impostiamo la password del dispositivo. Usa i controlli sul tuo BitBox per scegliere i caratteri della password.",
    passwordTitle: "Imposta la password per il tuo BitBox",
    text: "BitBox02 abbinato con successo! Ora inizializziamo il tuo dispositivo. Inizia scegliendo se creare un nuovo wallet o ripristinare un wallet da un backup esistente. <strong>Assicurati di avere una scheda microSD inserita nel tuo BitBox02</strong>",
    tip: "Ti consigliamo di procedere in un luogo sicuro.",
    title: "Inizializza il tuo BitBox"
  },
  insertSDCard: "<strong>Assicurati di aver inserito la scheda microSD nel tuo BitBox02.</strong>",
  noPasswordMatch: "Le password non corrispondono. Riprovare.",
  pairing: {
    failed: "Abbinamento non confermato. Ricollega il tuo BitBox02.",
    paired: "Hai confermato il seguente codice sul tuo dispositivo. Puoi continuare.",
    title: "Verifica il codice di abbinamento",
    unpaired: " stato rilevato un nuovo BitBox02. Si prega di verificare che il seguente codice corrisponda a quello mostrato sul tuo dispositivo. Se il codice corrisponde, tocca sotto il segno di spunta sul tuo BitBox02 e poi clicca sul pulsante qui sotto per continuare."
  },
  restoreFromMnemonic: {
    e104: "Il ripristino tramite parole di recupero  stato cancellato.",
    failed: "Ripristino con parole di recupero non riuscito. Riprovare."
  },
  stepBackup: {
    beforeProceed: "Prima di procedere, leggi queste importanti considerazioni sulla sicurezza:",
    createBackup: "Ora si procede a creare un backup sulla scheda microSD.",
    createBackupMnemonic: "Scrivi le parole di recupero."
  },
  stepBackupSuccess: {
    fundsSafe: "Per tenere i tuoi fondi al sicuro, ricordati quanto segue:",
    title: "Backup ripristinato!"
  },
  stepConnected: {
    unlock: "Inserisci la password del BitBox02 per sbloccare."
  },
  stepCreate: {
    description: "Questo nome viene utilizzato come nome del dispositivo e per il backup.",
    nameLabel: "Nome del BitBox02",
    namePlaceholder: "Il mio BitBox02",
    title: "Scegli il nome del BitBox02",
    toastMicroSD: "Inserisci nel tuo BitBox02 la scheda microSD che sar utilizzata per salvare un backup del tuo wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Rimuovere la scheda microSD dal BitBox02 e conservarla in un luogo sicuro.",
    storeMnemonic: "Custodisci le tue parole di recupero in un posto sicuro",
    success: "Il backup  stato creato con successo."
  },
  stepInsertSD: {
    insertSDCard: "Inserisci la scheda microSD nel BitBox02 per continuare.",
    insertSDcardTitle: "Inserire la scheda microSD"
  },
  stepPassword: {
    e104: "L'impostazione della password  stata cancellata.",
    title: "Impostare la password del BitBox02",
    useControls: "Usa i controlli sul tuo BitBox02 per impostare la password."
  },
  stepUninitialized: {
    create: "Vorrei configurare un nuovo BitBox02.",
    restore: "Vorrei ripristinare il mio wallet da un backup.",
    restoreMicroSD: "Ripristina dalla scheda microSD",
    restoreMnemonic: "Ripristina utilizzando le parole di recupero",
    title: "Configurare il BitBox02"
  },
  success: {
    text: "Urr! Il tuo BitBox02  ora pronto all'uso. \n\nPer ulteriori informazioni su come utilizzare la BitBoxApp, si prega di utilizzare la guida in-app cliccando sul punto di domanda in alto a destra.",
    title: "Pronti a partire!"
  }
};
const bitsurance = {
  dashboard: {
    active: "Polizza d'assicurazione attiva",
    button: "Assicura un nuovo account",
    canceled: "Cancellata",
    coverage: "Copertura massima",
    inactive: "Inattiva",
    processing: "In elaborazione",
    refused: "Rifiutata",
    supportLink: "Gestisci contratto",
    title: "Account assicurati",
    waitpayment: "In attesa di pagamento"
  },
  detect: {
    button: "Verifica copertura assicurativa",
    insured: "Account assicurati:",
    notInsured: "Nessuna assicurazione rilevata. Se sei sicuro che uno degli account sia assicurato, verifica di aver inserito il wallet corretto.",
    text: "Se hai gi assicurato i tuoi fondi con Bitsurance, la BitBoxApp pu rilevare automaticamente la tua copertura assicurativa.",
    title: "Sei gi assicurato?"
  },
  insure: {
    button: "Verifica disponibilit e prezzi",
    faq: "Leggi di pi sulle FAQ di Bitsurance",
    listItem1: "Furto",
    listItem2: "Estorsione (ad esempio, $5 wrench attack)",
    listItem3: "Distruzione dovuta a incendi, acqua o calamit naturali",
    month: "mese",
    text: "Assicura il tuo BitBox02 e fino a 100.000 in bitcoin contro",
    text2: "I piani assicurativi partono da 30/anno (2,50/mese). Puoi saperne di pi su Bitsurance e sui dettagli dell'offerta sul",
    text3: "Attualmente disponibile in Germania, con altri Paesi in arrivo.",
    title: "Inizia"
  },
  intro: {
    link: "sito Bitsurance",
    text1: "BitBox collabora con Bitsurance per aggiungere un ulteriore livello di protezione per i tuoi bitcoin. Mentre BitBox02 mantiene i tuoi fondi al sicuro, Bitsurance copre le minacce domestiche che non possono essere mitigate con la sola tecnologia, come furti con scasso, estorsioni o la distruzione dello stesso hardware wallet."
  },
  terms: {
    link: "Privacy Policy di Bitsurance",
    text1: "Bitsurance  un servizio indipendente di terze parti. Per domande riguardanti le loro offerte e le richieste di risarcimento assicurativo, contatta direttamente Bitsurance.",
    text2: "La copertura assicurativa  attualmente disponibile in Germania, a cui seguiranno altri Paesi.",
    text3: "La copertura massima di Bitcoin attualmente disponibile  di 100.000 a persona. Prevediamo la disponibilit di importi pi elevati in futuro.",
    text4: "Le informazioni personali e la chiave pubblica estesa del tuo account assicurato fanno parte della polizza assicurativa e saranno condivise con Bitsurance e la compagnia assicurativa.",
    text5: "Per ulteriori informazioni sulla privacy, consulta la"
  },
  title: "Assicurazione"
};
const bitsuranceAccount = {
  errorNoXpub: "Errore: non  stato possibile ottenere la chiave pubblica dell'account.",
  noAccount: "Non ci sono account che possono essere assicurati.",
  select: "Seleziona un account",
  title: "Assicurazione"
};
const blink = {
  button: "Lampeggia"
};
const bootloader = {
  button: "Aggiornare il firmware",
  button_install: "Installa il firmware adesso",
  progress: "Aggiornamento: {{progress}}%",
  progress_install: "Installazione: {{progress}}%\n",
  success: "Aggiornamento riuscito! Ricollegare il dispositivo. Questa volta non toccare il pulsante."
};
const button$5 = {
  abort: "Interrompere",
  back: "Indietro",
  buy: "Acquista",
  changepin: "Cambia la password del dispositivo",
  check: "Verifica il backup",
  "continue": "Continua",
  copy: "Copia",
  create: "Creare",
  dismiss: "Sospendi",
  done: "Fatto",
  download: "Scarica",
  hiddenwallet: "Crea un wallet nascosto",
  next: "Successivo",
  ok: "OK",
  previous: "Precedente",
  receive: "Ricevi",
  restore: "Ripristina",
  select: "Selezionare",
  send: "Invia",
  unlock: "Sblocca",
  update: "Aggiorna",
  upgrade: "Aggiorna"
};
const buy$1 = {
  exchange: {
    bankTransfer: "Bonifico bancario",
    bestDeal: "Miglior prezzo",
    creditCard: "Carta di credito",
    fast: "Rapido",
    fee: "commissione",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bonifico Bancario: {{fee}}%",
          creditDebitCard: "Carta di debito/credito: {{fee}}%",
          learnMore: "Scopri di pi su Moonpay",
          title: "Commissioni"
        },
        fullCurrenciesList: "Vedi la lista completa di valute qui",
        payment: {
          asteriskText: "* Non disponibile per i residenti in US",
          bankTransfer: "Bonifico bancario*",
          bankTransferDetails: {
            pix: "PIX (Transazioni BR esclusivamente in Brasile)",
            sepa: "SEPA e SEPA istantaneo (transazioni EUR esclusivamente in Paesi SEPA)",
            uk: "UK Faster Payments (transazioni GBP esclusivamente in UK)"
          },
          creditDebitCard: "Carta di credito/debito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Vedi pi dettagli sui metodi di pagamento",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta tutte le principali valute fiat: USD, EUR, CHF, and altre."
      },
      pocket: {
        fees: {
          info: "Bonifico bancario: {{fee}}%",
          title: "Commissioni"
        },
        learnMore: "Scopri di pi su Pocket",
        payment: {
          bankTransfer: "Bonifico bancario",
          bankTransferDetails: {
            sepa: "SEPA e SEPA istantaneo (per le transazioni in EUR nei Paesi SEPA)",
            sic: "Swiss Interbank Clearing (per le transazioni in CHF in CH/LI)",
            uk: "UK Faster Payments (per le transazioni GBP in UK)"
          },
          bankTransferReccuring: "Come impostare degli acquisti ricorrenti tramite un ordine permanente?",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta le seguenti valute Europee: EUR, GBP e CHF",
        verification: {
          info: "Richiede una verifica dell'identit solamente al di sopra delle soglie giornaliere ed annuali",
          link: "Trova le soglie aggiornate qui",
          title: "Verifica dell'identit"
        }
      },
      region: {
        title: "Selezione il Paese in cui hai registrato il tuo conto bancario per vedere le opzioni disponibili per te."
      }
    },
    noExchanges: "Mi dispiace, non ci sono exchange disponibili in questo Paese",
    region: "Paese",
    selectRegion: "Non specificato",
    title: "Compra {{name}}"
  },
  info: {
    "continue": "Accetta e continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Siamo una partnership MoonPay per offrirti un modo semplice per comprare {{name}} direttamente all'interno della BitBoxApp. Bastano pochi click.",
        "MoonPay  una piattaforma che rende comprare {{name}} facile e veloce in oltre 160 paesi."
      ],
      payment: {
        details: "Puoi comprare {{name}} istantaneamente tramite MoonPay con i seguenti metodi di pagamento. Gli ordini con carta di credito o di debito sono immediati e convenienti, ma pi costosi a causa del maggior rischio di chargeback. Raccomandiamo di usare l'opzione del bonifico bancario per importi maggiori. La tariffa minima  di 4 USD/EUR o equivalente.",
        footnote: "Si prega di notare che i tassi di cambio di MoonPay possono differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
        table: {
          "1_description": "Tariffe pi basse, possono richiedere fino a 3 giorni lavorativi",
          "1_method": "Trasferimenti bancari (SEPA)",
          "2_description": "Commissioni pi alte, ma veloce ed istantaneo",
          "2_method": "Carte di debito e credito",
          description: "Descrizione",
          fee: "Commissione",
          method: "Metodo"
        },
        title: "Metodi di pagamento e commissioni"
      },
      privacyPolicy: "Privacy policy di MoonPay",
      protection: {
        description: "La BitBoxApp non raccoglie alcun dato quando si acquista {{name}} ed i fondi in entrata sono trattati come una normale transazione. MoonPay ha bisogno di raccogliere alcuni dati personali per operare. La loro privacy policy spiega in dettaglio come questi dati vengono gestiti.",
        descriptionGeneric: "BitBoxApp non registra nessun dato durante l'acquisto di {{name}}, i fondi in entrata sono trattati come comuni transazioni. Ci nonostante, gli exchange partner hanno bisogno di alcune informazioni per poter operare. Fai riferimento alle rispettive privacy policy per verificare come i dati vengono gestiti.",
        title: "Protezione dei dati"
      },
      security: {
        description: `Quando acquisti {{name}} tramite MoonPay, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione.`,
        descriptionGeneric: `Quando acquisti {{name}} tramite un exchange partner, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione.`,
        link: "Security threat model",
        title: "Security model"
      },
      title: "Benvenuto nel tuo sportello unico per l'acquisto di {{name}}"
    },
    next: "Prossimo",
    selectLabel: "Scegli un account",
    selectPlaceholder: "Seleziona una valuta",
    skip: "Non mostrare pi",
    title: "Acquista {{name}}"
  },
  pocket: {
    data: {
      link: "Privacy policy di Pocket",
      p1: "BitBoxApp non registra nessun dato durante l'acquisto di Bitcoin, i fondi in entrata sono trattati come comuni transazioni. Pocket ha bisogno di alcune informazioni personali per poter operare. La loro privacy policy spiega in dettaglio come i dati vengono gestiti.",
      title: "Protezione dei dati"
    },
    kyc: {
      link: "Leggi le FAQ di Pocket",
      p1: "Pocket cerca di mantenere al minimo il KYC. Per acquisti al di sotto dei 950 EUR (1000 CHF) al giorno, non  necessario nessun documento aggiuntivo. Per acquisti di importi superiori, sar necessario programmare una call con Pocket per completare le necessarie procedure KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puoi comprare Bitcoin istantaneamente con Pocket tramite un bonifico bancario SEPA. La commissione  del 1,5% e i Bitcoin vengono depositati sul tuo BitBox appena possibile una volta che Pocket ha ricevuto il bonifico (di solito in giornata).",
      p2: "Si prega di notare che i tassi di scambio utilizzati da Pocket potrebbero differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
      title: "Metodi di pagamento e commissioni"
    },
    previousTransactions: "Lo storico di transazioni di questo account non  vuoto. Condividere questo account render tutte le transazioni passate e future visibili per Pocket. Procedere comunque? ",
    security: {
      link: '"BitBox02 security threat model"',
      p1: `Quando acquisti Bitcoin tramite Pocket, stai usando un servizio esterno. Questo servizio  fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp  in esecuzione. Comunque, lavoriamo insieme per migliorare la sicurezza utilizzando un meccanismo di autenticazione a due fattori per verificare il tuo indirizzo di ricezione.`,
      title: "Modello di sicurezza "
    },
    usedAddress: "L'indirizzo {{address}}  gi stato utilizzato, per favore ricomincia da capo con un nuovo indirizzo.",
    verifyBitBox02: "Per favore, verifica che l'indirizzo che hai ricevuto via email corrisponda a quello visualizzato sul tuo BitBox. Se possibile, dovresti aprire la mail su un secondo dispositivo per maggiore sicurezza.",
    welcome: {
      p1: "Collaboriamo con Pocket per offrirti un modo fluido per acquistare Bitcoin direttamente nella BitBoxApp. Sono solo pochi click.",
      p2: "Pocket  una piattaforma Svizzera che rende semplice e veloce acquistare Bitcoin in gran parte dell'Europa (ovunque un bonifico bancario SEPA sia supportato).",
      p3: "Con Pocket, puoi anche acquistare regolarmente tramite singoli bonifici bancari, quindi puoi fare DCA (dollar-cost averaging) con semplicit.",
      title: "Benvenuto nel tuo sportello unico per l'acquisto di Bitcoin"
    }
  },
  title: "Acquista {{name}}"
};
const changePin = {
  newTitle: "Nuova password del dispositivo",
  oldLabel: "Password attuale del dispositivo"
};
const chart$1 = {
  dataMissing: "Raccolta di dati ... rimanete collegati.",
  dataOldTimestamp: "Aggiornamento dei tassi di cambio storici. Il grafico non visualizza dati posteriori al {{time}}",
  dataUpdating: "aggiornamento dei dati ...",
  filter: {
    all: "Tutto",
    month: "Mese",
    week: "Settimana",
    year: "Anno"
  }
};
const checkSDcard = "verifica della scheda microSD";
const clickHere = "Clicca qui.";
const confirm$2 = {
  abortInfo: "Tocca per",
  abortInfoRedText: "interrompere",
  approveInfo: "Tocca per almeno 4 secondi per",
  approveInfoGreenText: "confermare",
  info: "Continua sul tuo BitBox",
  infoWhenPaired: "Prima sul cellulare accoppiato e poi sul tuo BitBox"
};
const confirmOnDevice = "Conferma sul tuo dispositivo.";
const connectKeystore$1 = {
  promptNoName: "Connetti il tuo BitBox02 per continuare",
  promptWithName: 'Connetti il tuo BitBox02 con nome "{{name}}" per continuare'
};
const darkmode$1 = {
  toggle: "Modalit scura"
};
const device = {
  appUpradeRequired: "Il tuo BitBox non  compatibile con questa versione dell'applicazione desktop. Installa l'ultima versione.",
  keystoreConnected: "Wallet connesso"
};
const deviceLock = {
  button: "Abilita autenticazione a due fattori (2FA)",
  condition1: "Hai un backup?",
  condition2: "La verifica via applicazione mobile funziona?",
  condition3: "2FA DISABILITA i backup e l'abbinamento dell'applicazione mobile. Il dispositivo deve essere resettato per uscire da 2FA!",
  confirm: "Abilita autenticazione a due fattori (2FA)",
  title: "Abilita autenticazione a due fattori (2FA)"
};
const deviceSettings = {
  backups: {
    manageBackups: {
      description: "Crea o verifica il tuo backup su microSD."
    },
    showRecoveryWords: {
      description: "Mostra e verifica le parole di recupero."
    },
    title: "Backup"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp verifica che il tuo dispositivo sia autentico."
    },
    deviceName: {
      description: "Modifica il nome del tuo dispositivo."
    },
    rootFingerprint: {
      description: "La root fingerprint  un identificatore univoco del wallet attualmente in uso. Ti pu aiutare a distinguere wallet diversi se usi la passphrase."
    },
    securechip: {
      description: "Modello del secur chip."
    },
    title: "Informazioni sul dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Ripristina il dispositivo alle impostazioni di fabbrica. Questo cancella il wallet dal tuo BitBox02!",
      title: "Ripristino alle impostazioni di fabbrica"
    },
    goToStartupSettings: {
      description: "Entra nel bootloader del BitBox02. Da qui puoi abilitare il firmware hash"
    },
    passphrase: {
      description: "Abilita o disabilita la passphrase.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Versione Firmware",
    newVersion: {
      label: "Versione disponibile"
    },
    title: "Firmware",
    upToDate: "Il tuo dispositivo  aggiornato",
    upgradeAvailable: "Nuovo upgrade disponibile",
    version: {
      label: "Versione"
    }
  },
  hardware: {
    attestation: {
      "false": "Verifica di autenticit fallita",
      label: "Verifica di autenticit",
      "true": "Il tuo Bitbox02  autentico"
    },
    sdcard: {
      "false": "Non inserita",
      label: "carta microSD",
      "true": "Inserita"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Recupero delle informazioni sul dispositivo...",
  pairing: {
    lock: {
      "false": "Disabilitato",
      label: "Autenticazione a due fattori",
      "true": "Abilitato"
    },
    mobile: {
      "false": "Chiuso",
      label: "Applicazione mobile",
      "true": "Aperto"
    },
    status: {
      "false": "Non abbinato",
      label: "Status",
      "true": "Abbinato"
    },
    title: "Abbinamento"
  },
  secrets: {
    manageBackups: "Gestione backup",
    title: "Segreti"
  }
};
const deviceTampered = "Il tuo BitBox  stato fornito con una password di recupero? Se  cos, interrompi il processo di configurazione e contatta il supporto immediatamente. Shift non ti fornir mai un wallet pronto, n ti consiglier una password.";
const dialog$1 = {
  cancel: "Annulla",
  confirm: "Conferma",
  confirmTitle: "Conferma"
};
const error$2 = {
  accountAlreadyExists: "L'account esiste gi.",
  accountLimitReached: "Impossibile aggiungere un account.  stato raggiunto il numero massimo di account per questa moneta.",
  aoppCallback: "Si  verificato un errore nella consegna dell'indirizzo a {{host}}.\n",
  aoppInvalidRequest: "Richiesta non valida",
  aoppNoAccounts: "Non ci sono account disponibili.",
  aoppSigningAborted: "Richiesta di propriet dell'indirizzo annullata.\n",
  aoppUnknown: "Si  verificato un errore sconosciuto.\n",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "Non ci sono account disponibili che supportino il formato di indirizzo richiesto.",
  aoppUnsupportedKeystore: "Il dispositivo collegato non pu firmare i messaggi per questo asset.\n",
  aoppVersion: "Versione sconosciuta.",
  wrongKeystore: "Wallet connesso errato. Assicurati di inserire il dispositivo corretto per questo account.",
  wrongKeystore2: "Se stai utilizzando la passphrase opzionale, assicurati di avere inserito quella corretta per questo account."
};
const fiat$2 = {
  "default": "predefinito",
  setDefault: "Imposta {{code}} come valuta predefinita",
  title: "Valute"
};
const footer$2 = {
  appVersion: "Versione dell'app:"
};
const generic$1 = {
  enabled_false: "Disabilitato",
  enabled_true: "Abilitato"
};
const genericError = "Si  verificato un errore. Se noti qualche problema, riavvia l'applicazione.";
const goal = {
  buttons: {
    create: "Creare un nuovo wallet",
    restore: "Ripristina un wallet dal backup"
  },
  paragraph: "Seleziona una delle seguenti opzioni:",
  step: {
    "1": {
      title: "Informazioni sulla sicurezza"
    },
    "2": {
      description: "Impostare la password del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crea un nuovo wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "da un backup",
      title: "Ripristina"
    },
    "4-create": {
      title: "Riassunto"
    },
    "4-restore": {
      title: "Riassunto"
    }
  }
};
const guide$1 = {
  accountDescription: {
    text: "La panoramica dell'account mostra il tuo saldo disponibile e le transazioni in entrata e in uscita. La nostra guida in 'Impostazioni' contiene maggiori informazioni sui diversi tipi di account. ",
    title: "Cosa contiene questa pagina?"
  },
  accountFiat: {
    text: "Si. Clicca su qualsiasi ticker per scorrere tra le valute fiat. Puoi cambiare la lista delle valute nelle impostazioni.",
    title: "Posso visualizzare altri tassi di conversione?"
  },
  accountIncomingBalance: {
    text: "Le somme in entrata riassumono gli importi trasferiti a voi ma non ancora confermati dalla rete.",
    title: "Cosa significa somme in entrata?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Ogni xpub  legata al "Tipo" indicato: "Native Segwit (bech32)", "Wrapped Segwit" o "Taproot" (solo Bitcoin). Questi sono i tipi di script utilizzati da {{coinName}}. La BitBoxApp li combina, supportando pi tipi di script nello stesso account. Poich ogni tipo di script fornisce un xpub diverso, esistono pi xpub per account.

Se si riceve sempre sull'indirizzo predefinito (Native Segwit),  necessario solo l'xpub "bech32". Tuttavia, se si ricevono fondi anche su "Wrapped Segwit" o "Taproot",  necessario utilizzare anche le chiavi pubbliche estese "Wrapped Segwit" e "Taproot" rispettivamente.`,
      title: "Perch ci sono diverse xpub?\n"
    },
    privacy: {
      text: "Per questo specifico account, la chiave pubblica estesa rivela l'intera storia finanziaria, il saldo dell'account e tutte le transazioni future. L'xpub per non consente a nessuno di spendere i tuoi fondi.\n\nSe si condivide un'xpub con qualcuno, si deve essere consapevoli che questa persona o azienda pu vedere tutte le altre transazioni dello stesso account. Pertanto,  bene utilizzare quell'account solo per questo scopo e conservare gli altri fondi in account diversi.",
      title: "Devo tenere la my xpub segreta?"
    },
    verify: {
      text: "S,  sempre una buona idea ricontrollare la propria xpub. E' particolarmente importante nel caso in cui qualcun altro generi indirizzi di ricezione da questa xpub per inviare denaro.  necessario verificarla sul dispositivo per assicurarsi che questa xpub appartenga a voi; in caso contrario, tutti i fondi potrebbero andare a indirizzi sbagliati.",
      title: " necessario verificare l'xpub sul dispositivo?\n"
    },
    xpub: {
      text: `Una chiave pubblica estesa  una chiave "root" da cui derivano tutti gli indirizzi di ricezione di un account. 

 fornita qui per un uso avanzato e per l'interoperabilit con wallet watch-only, come Electrum o Sentinel. Se hai ricevuto su diversi tipi di indirizzo, importa tutti i diversi formati xpub nel wallet watch-only per vedere tutte le tue valute.

Nota bene: i wallet di terze parti potrebbero non supportare ancora gli xpub di Taproot.`,
      title: "Cos' una chiave pubblica estesa?"
    }
  },
  accountRates: {
    text: "Aggiorniamo i tassi di cambio ogni minuto da CoinGecko.",
    title: "Quali tassi di cambio si applicano?"
  },
  accountReload: {
    text: "Non ce n' bisogno. Le informazioni sulla tua transazione vengono aggiornate automaticamente.",
    title: "Posso ricaricare la cronologia delle transazioni?"
  },
  accountSendDisabled: {
    text: "Il pulsante 'Invia'  attivo quando hai un saldo maggiore di zero.",
    title: "Perch non posso inviare {{unit}}?"
  },
  accountSummaryAmount: {
    text: "L'importo totale  la somma di tutti i tuoi account. I tassi di cambio sono ottenuti da coingecko.com.\n\nNota: se usi MyEtherWallet per i token non supportati nella BitBoxApp, questi non saranno inclusi nell'importo visualizzato.",
    title: "Come viene calcolato l'importo totale?"
  },
  accountSummaryDescription: {
    text: "Qui pui vedere la performance del tuo portafogli nel tempo. Sotto il grafico viene visualizzato un riepilogo dei diversi account.",
    title: "Cosa contiene questa pagina?"
  },
  accountTransactionAttributesBTC: {
    text: 'Dimensione virtuale: Determina la tassa di rete. Si risparmia sulle commissioni se  pi piccola della dimensione della transazione.\nDimensione: Dimensione effettiva della transazione in byte quando serializzata secondo la blockchain sottostante.\nPeso: Una nuova metrica introdotta con Segwit per valutare le dimensioni delle transazioni e dei blocchi. Ogni byte del "segregated witness" conta come uno, tutto il resto come quattro unit di peso. Invece di un megabyte di dimensione effettiva, il limite della dimensione del blocco  ora di quattro milioni di unit di peso.',
    title: "E i dettagli delle transazioni in Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: "Conferme: La tua prima transazione trasmessa non  confermata fino a quando un minatore la include in un blocco, dopo di che ha una conferma. Ogni blocco trasmesso sulla rete aggiunge un'altra conferma alla tua transazione. Generalmente i commercianti e gli altri attori della rete saldano solo le transazioni con un numero di conferme compreso tra tre e sei.\nID della transazione: Un numero di identificazione unico che permette di cercare una transazione in un esploratore di blocchi.\nCommissione: Ai minatori viene pagata una tassa di transazione come incentivo per includere le transazioni nei blocchi che estraggono. Per saperne di pi, clicca sul pulsante invia.",
    title: "Quali sono le informazioni nei dettagli della transazione?"
  },
  accountTransactionConfirmation: {
    text: "Una transazione trasmessa alla rete ma non ancora confermata.",
    title: "Cos' una transazione in sospeso?"
  },
  accountTransactionLabel: {
    text: "L'indirizzo da cui hai ricevuto o a cui hai inviato delle monete.",
    title: "Quale indirizzo viene visualizzato per ogni transazione?"
  },
  accountTransactionTime: {
    text: "Il tempo di conferma della transazione su blockchain.",
    title: "Che ora viene visualizzata?"
  },
  accounts: {
    howManyAccounts: {
      text: "Non c' un limite al numero di account Bitcoin e Litecoin supportati. Dopo il quinto account, potrai aggiungerne uno nuovo solo se il precedente  gi stato utilizzato.\n",
      title: "Quanti account posso creare?"
    },
    howtoAddTokens: {
      text: 'I token che utilizzano lo standard ERC20 sono legati a uno specifico account Ethereum. Per attivare o disattivare un determinato token, aprire la schermata "Gestisci account", espandere il proprio account Ethereum e attivare o disattivare il token desiderato.',
      title: "Come posso aggiungere pi token?\n"
    },
    moveFunds: {
      text: "S, ma poich gli account sono indipendenti,  necessario inviare i fondi con una transazione regolare.\n",
      title: "Posso spostare fondi tra account diversi?"
    },
    recoverAccounts: {
      text: "S. BitBoxApp crea account utilizzando standard consolidati e compatibili con la maggior parte degli altri wallet per criptovalute.",
      title: "Posso recuperare i miei account con altri wallet?"
    },
    whatAreAccounts: {
      text: "Il tuo wallet pu gestire pi account della stessa moneta. Diversi account sono utili quando si desidera mantenere i fondi separati.",
      title: "Cosa sono gli account?"
    },
    whatIsRememberWallet: {
      text: `Abilitando "Ricorda wallet" puoi vedere gli account di questo wallet nella BitBoxApp anche quando il BitBox02 non  collegato. Questo ti consente di controllare il tuo saldo e il tuo portafoglio ogni volta che vuoi. Il BitBox02 dovr comunque essere collegato e sbloccato per inviare o ricevere fondi.

Disabilitando "Ricorda wallet" dovrai collegare il relativo BitBox02 (con l'eventuale passphrase) per vedere i suoi account nella BitBoxApp.`,
      title: "Cosa succede quando attivo/disattivo Ricorda wallet?"
    },
    whyIsThisUseful: {
      text: 'Gli account sono ottimi per gestire fondi per persone o scopi diversi, perch sono separati.  inoltre possibile condividere la "chiave pubblica estesa" di un account senza rivelare nulla degli altri account. Ci consente di ricevere ripetutamente fondi senza riutilizzare gli indirizzi, ad esempio per ricevere lo stipendio o per acquistare regolarmente criptovalute.',
      title: "Perch  utile?"
    }
  },
  appendix: {
    link: "Contattaci",
    text: "Altre domande?"
  },
  backups: {
    check: {
      text: "'Controlla backup' ti permette di verificare di avere un backup funzionante corrispondente al tuo wallet attuale. Pu anche essere usato per verificare che tu abbia ancora la password di recupero corretta. Puoi controllare la tua password di recupero principale o la tua password di recupero nascosta.",
      title: "Cos' il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No, ma la tua password di recupero  necessaria per ricavare il wallet dal "seed" memorizzato.',
      title: "Posso criptare il backup?"
    },
    howOften: {
      text: "Il backup viene generato automaticamente quando viene creato un nuovo wallet. Devi fare un nuovo backup solo se la tua scheda microSD viene persa o danneggiata, o se vuoi usare pi schede microSD come backup.\nNon  necessario creare nuovi backup dopo aver inviato o ricevuto transazioni. Tutti i dati delle tue transazioni possono essere ricreati dal tuo singolo backup che  stato generato automaticamente per te.",
      title: "Quanto spesso devo fare un backup?"
    },
    whatIsABackup: {
      text: ' una copia del "seed" su una scheda microSD. Il "seed" insieme alla tua password di recupero genera il tuo wallet.',
      title: "Cos' un backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Controlla backup' ti permette di verificare che hai un backup funzionante corrispondente al tuo wallet attuale.",
      title: "Cos' il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No. Tieni la scheda microSD al sicuro, perch contiene il "seed" non criptato per recuperare il tuo wallet. Se desideri proteggere con una password il tuo seed, puoi abilitare una passphrase opzionale nelle impostazioni avanzate sotto "Gestisci dispositivo".',
      title: "Posso criptare il backup?"
    },
    whatIsABackup: {
      text: ' una copia del "seed" su una scheda microSD.',
      title: "Cos' un backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando la 2FA  abilitata, tutte le transazioni devono essere approvate sul cellulare abbinato per poter spendere fondi. Un numero monouso criptato viene inviato all'applicazione mobile, decriptato l, e restituito al BitBox quando si preme il pulsante "Accetta". Questa comunicazione con il dispositivo avviene tramite un canale tra il telefono cellulare e l'applicazione desktop stabilita durante l'abbinamento.

Assicurati di fare il backup del tuo wallet e di abbinare l'applicazione mobile prima di abilitare il 2FA. Una volta abilitato, lo slot microSD e l'abbinamento dell'applicazione mobile sono disabilitati. Possono essere riabilitati resettando il BitBox, che cancella il dispositivo.`,
      title: "Come funziona l'autorizzazione a due fattori (2FA)?"
    },
    disable2FA: {
      text: "Per disabilitare il 2FA,  necessario resettare il BitBox e poi ripristinare il wallet dal suo backup. Assicurati di avere ancora la scheda microSD con il backup e di ricordare ancora la password di recupero. Poi premi 'Reset dispositivo'. Imposta una nuova password del dispositivo e scegli 'Ripristina un backup'. Seleziona il backup che hai fatto dal wallet. clicca su 'Ripristina' e inserisci la password di recupero che hai usato quando hai creato il wallet.",
      title: "Come posso disabilitare l'autorizzazione a due fattori (2FA)?"
    },
    ejectBitbox: {
      text: " possibile scollegare il BitBox in qualsiasi momento senza doverlo prima espellere.",
      title: "Come posso espellere il BitBox?"
    },
    ejectSD: {
      text: " possibile rimuovere la scheda microSD dal BitBox in qualsiasi momento, purch non si stia creando o ripristinando un backup.",
      title: "Come posso espellere la scheda microSD?"
    },
    hiddenWallet: {
      text: 'Si tratta di un secondo wallet sullo stesso dispositivo protetto da una password diversa da quella del dispositivo e quella di recupero, che puoi usare per una negazione plausibile. Lo stesso "seed" di backup viene utilizzato sia per il wallet normale che per quello nascosto, quindi non  necessario un backup aggiuntivo.',
      title: "Cos' un wallet nascosto?"
    },
    legacyHiddenWallet: {
      text: "Prima clicca il pulsante qui sotto (disponibile se il BitBox  sbloccato con la password del dispositivo principale e 2FA  disabilitato), poi ricollega il tuo Bitbox e sbloccalo con la tua password del dispositivo nascosto.",
      title: "Come si accede al wallet nascosto legacy?"
    },
    pairing: {
      text: "Dopo aver scaricato la nostra applicazione mobile per iOS o Android, scansiona il codice QR visualizzato, che stabilisce un canale sicuro tra l'applicazione mobile e questa applicazione. Una volta scansionato, segui le istruzioni dell'applicazione mobile.",
      title: "Come abbinare in modo sicuro il tuo telefono"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Per ulteriori dettagli, consulta il sito Web di Bitsurance e le FAQ",
      title: "Altre domande?"
    },
    privacy: {
      link: {
        text: "privacy policy di Bitsurance"
      },
      text: "Come ogni normale polizza assicurativa, contiene il tuo nome e indirizzo completo e specifica l'oggetto assicurato (definito dalla chiave pubblica estesa del conto Bitcoin assicurato). Questi dati vengono inviati direttamente a Bitsurance e non vengono condivisi con Shift Crypto. Per ulteriori informazioni, consultare la privacy policy Bitsurance",
      title: "Quali informazioni personali sono necessarie per l'assicurazione?"
    },
    renew: {
      text: 'Lassicurazione si rinnover automaticamente per lanno successivo. Puoi annullare il rinnovo in qualsiasi momento facendo clic su "Gestisci contratto" nella BitBoxApp, che ti porta al portale clienti Bitsurance.',
      title: "Come posso rinnovare o annullare l'assicurazione?"
    },
    status: {
      text: `Gli account assicurati con successo sono contrassegnati con un badge verde "Account assicurato" nell'angolo in alto a sinistra nella pagina dell'account. Nella sezione "Assicura" puoi vedere una panoramica di tutti gli account Bitcoin assicurati e il loro attuale stato assicurativo. Pu essere necessario attendere fino a 48 ore perch lo stato dell'assicurazione venga aggiornato.`,
      title: "Posso verificare lo stato di un account assicurato?"
    },
    what: {
      text: `Ogni contratto assicurativo Bitcoin copre uno specifico account. Puoi assicurare pi account stipulando pi polizze assicurative. I conti assicurati sono limitati all'utilizzo di indirizzi Bitcoin di tipo "Native Segwit".`,
      title: "L'assicurazione copre l'intero wallet BitBox?"
    },
    who: {
      text: "L'assicurazione  offerta da Bitsurance, un broker assicurativo creato da bitcoiner. Lavorano con la compagnia di assicurazioni ELEMENT per fornire un'assicurazione su Bitcoin. Entrambe le societ hanno sede in Germania.",
      title: "Chi assicura i miei bitcoin?"
    },
    why: {
      text: "Bitsurance copre alcuni rischi legati alla self-custody che non possono essere tutelati neanche dal pi sicuro dei wallet, ad es. furto con scasso, estorsione o distruzione del wallet stesso.  una tua decisione personale se hai bisogno di una copertura assicurativa per questi rischi.",
      title: "Ho bisogno di unassicurazione Bitcoin?"
    }
  },
  cointracking: {
    text: `Fai clic sul pulsante "Esporta" e apri la cartella dei download dove troverai l'esportazione CSV. Quindi fai clic sul link sottostante, carica il tuo file CSV BitBox e importa i dati per utilizzarli nel tuo gestore del portafoglio CoinTracking e per creare le tue dichiarazioni fiscali.`,
    title: "Come importo le mie transazioni in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leggi di pi sulla verifica di autenticit"
      },
      text: "La BitBoxApp effettua una verifica di autenticit sul BitBox02 per assicurarsi che il dispositivo sia autentico. La verifica viene eseguita localmente e non si connette a nessun server",
      title: "Come funziona la verifica di autenticit?"
    },
    name: {
      text: "Questo  il nome del tuo wallet e del backup. Il nome  utilizzato per i backup futuri e pu essere utilizzato per distinguere tra wallet diversi. Pu essere cambiato in ogni momento, ma tieni presente che i backup fatti prima del cambio avranno il nome precedente.",
      title: "Per cosa  utilizzato il nome del BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leggi di pi sul secure chip"
      },
      text: "Questa informazione mostra il modello del secure chip. Quello pi aggiornato  ATECC608B, con funzionalit di sicurezza migliorate rispetto ai modelli precedenti.",
      title: "Perch mostrare il modello del secure chip?"
    }
  },
  receive: {
    address: {
      text: "Puoi dare l'indirizzo ad altri per farti inviare dei fondi. Assicurati che stiano inviando all'indirizzo corretto.",
      title: "Cosa devo fare con un indirizzo?"
    },
    addressChange: {
      text: "Non appena si effettua una transazione, un nuovo indirizzo viene automaticamente aggiunto alla lista, quindi ci sono sempre 20 indirizzi disponibili che non hanno mai ricevuto fondi.",
      title: "Quando cambiano gli indirizzi?"
    },
    addressFormats: {
      text: "Da impostazione predefinita, il tipo di indirizzo  Native Segwit. Questo tipo di indirizzo  ampiamente adottato da altri wallet/exchange e offre le migliori tariffe per le transazioni quotidiane. Tuttavia, si pu anche scegliere di inviare a Taproot (solo Bitcoin), il tipo di indirizzo pi recente, ma potenzialmente non ancora ampiamente supportato. In alternativa, se hai problemi a inviare a Native Segwit (predefinito), puoi provare a passare al tipo di indirizzo pi vecchio Wrapped Segwit, che potrebbe essere compatibile con pi wallet/exchange.",
      title: 'Quando uso "Cambia tipo di indirizzo"?'
    },
    howVerify: {
      text: "Per il BitBox01, clicca sull'icona BitBox nella barra laterale a sinistra e vedi la sezione Abbinamento. La guida si aggiorner e potrai continuare a seguire le istruzioni da l.\nPer il BitBox02,  possibile verificare gli indirizzi direttamente sul dispositivo durante il processo di invio/ricezione.",
      title: "Come posso verificare un indirizzo in modo sicuro?"
    },
    plugout: {
      text: "No, una volta inviati fondi all'indirizzo del tuo BitBox, non  necessario lasciarlo collegato. Sei libero di scollegare il tuo BitBox.",
      title: " necessario lasciare il BitBox collegato durante la ricezione?"
    },
    why20: {
      text: `Durante l'avvio l'app genera indirizzi derivati dal tuo "seed" per vedere se hanno ricevuto fondi. Poich l'app pu generare un numero quasi infinito di indirizzi, potrebbero volerci anni per determinare il saldo. Per limitare questa ricerca, la app si ferma quando vede 20 indirizzi che non hanno mai ricevuto fondi. Questo  il "gap limit" e 20  uno standard de-facto anche se il numero  arbitrario. Questi sono i 20 indirizzi tra cui puoi scegliere.`,
      title: "Perch solo 20 indirizzi?"
    },
    whyMany: {
      text: 'Per mantenere la privacy e la sicurezza, non dare mai lo stesso indirizzo due volte. Se hai usato un indirizzo, clicca sulla freccia a destra per un nuovo indirizzo. Puoi generare fino a 20 indirizzi alla volta. Pensa agli indirizzi come ai numeri di fattura. Tutti gli indirizzi sono derivati dal tuo singolo "seed" di backup.',
      title: "Perch cos tanti indirizzi?"
    },
    whyVerify: {
      text: "Non dovresti fidarti del computer per generare e visualizzare indirizzi genuini. L'ampia superficie di attacco lo rende molto pi vulnerabile di un hardware wallet. Nel caso del BitBox01, il pulsante per verificare l'indirizzo invia in modo sicuro l'indirizzo a un telefono cellulare associato, dal quale  anche possibile scansionare e verificare il codice QR. Per il BitBox02, l'indirizzo pu essere verificato direttamente sul display del BitBox02.",
      title: "Perch dovrei verificare l'indirizzo in modo sicuro?"
    }
  },
  send: {
    change: {
      text: "Il resto verr restituito a un indirizzo Taproot se  presente almeno un UTXO Taproot. Se si usa il coin control, il resto verr restituito a un indirizzo Taproot se c' almeno un UTXO Taproot tra gli UTXO selezionati. In tutti gli altri casi, il resto viene restituito a un indirizzo Native Segwit.",
      title: "Come viene determinato l'output del resto?"
    },
    fee: {
      text: "La commissione si basa sulla dimensione dei dati della transazione e non sulla sua quantit. \nle commissioni sono calcolate dall'algoritmo di stima di Bitcoin Core per ogni priorit di rete scelta. Sono mostrate se hanno un valore diverso rispetto a quelli qui sotto.\nEconomica: 24 blocchi (circa 4 ore per Bitcoin, 1 ora per Litecoin)\nBasso: 12 blocchi (circa 2 ore per Bitcoin, 30 minuti per Litecoin)\nNormale: 6 blocchi (circa 1 ora per il Bitcoin, 15 minuti per il Litecoin)\nAlto: 2 blocchi (circa 20 minuti per il Bitcoin, 5 minuti per il Litecoin)\n(Un blocco impiega in media dieci minuti per Bitcoin (2,5 minuti in Litecoin) per essere estratto e il carico della rete pu variare considerevolmente nei periodi di cui sopra).",
      title: "Come sono determinate le commissioni?"
    },
    plugout: {
      text: "No, una volta effettuata una transazione, non  necessario lasciare il BitBox collegato. Si  liberi di scollegare il BitBox.",
      title: " necessario lasciare il BitBox collegato durante l'invio?"
    },
    priority: {
      text: "Pi commissioni paghi, tipicamente pi velocemente le transazioni sono confermate dalla rete",
      title: "Cos' la priorit di rete?"
    },
    revert: {
      text: "Una volta che una transazione  firmata e inviata (cio trasmessa alla rete), non pu pi essere annullata. Verificate bene le transazioni (compresa la commissione) prima di firmare!\nSe conosci il destinatario e lui/lei  disposto/a a rimandarti lo stesso importo (meno le commissioni della transazione), puoi inviargli/le un nuovo indirizzo di ricezione.",
      title: "Posso revocare una transazione?"
    },
    whyFee: {
      text: "Le transazioni sono in competizione per essere confermate da un minatore. I minatori scelgono le transazioni da includere nella blockchain in base al loro compenso.\nI minatori votano sulla storia delle transazioni. Dal momento che non c' una terza parte fidata che faccia rispettare un voto per persona (che  l'intero scopo delle blockchain), i minatori votano sulle transazioni sacrificando una risorsa costosa come la potenza di calcolo. Come ricompensa per il loro lavoro, possono reclamare fondi appena creati e le commissioni di tutte le transazioni che hanno incluso.",
      title: "Perch ci sono delle commissioni di rete?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Se intendi connetterti al tuo nodo solo quando sei connesso alla stessa rete (ad esempio il wifi di casa tua) allora  sufficiente utilizzare la normale comunicazione di rete.\nIn questo caso  consigliabile che il tuo server Electrum fornisca un certificato TLS per cifrare la comunicazione.\nSe hai intenzione di connetterti al tuo nodo da qualsiasi luogo, usare Tor  l'opzione migliore. In questo caso non  necessario alcun certificato TLS.",
      title: "Meglio usare clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guida per collegare il tuo nodo"
      },
      text: "Per un tutorial completo, visitate la nostra guida:",
      title: "Come faccio a collegare la mia BitBoxApp al mio full node?"
    },
    options: {
      text: "Ci sono diverse opzioni per utilizzare un proprio nodo come acquistare un dispositivo finito, costruire il proprio o utilizzare Bitcoin Core.\nSe vuoi collegare la BitBoxApp al tuo nodo, assicurati che esegua un server Electrum. Questo  un programma dedicato che permette ad un'app wallet di comunicare con il tuo nodo.\nLe opzioni supportate includono Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).",
      title: "Quali opzioni ci sono per gestire un nodo?"
    },
    tor: {
      text: "Tor  l'acronimo di 'The Onion Router', che  un software gratuito e open source che offre un sacco di vantaggi per la privacy ed  particolarmente utile quando si usa Bitcoin.\nSe hai intenzione di connetterti al tuo nodo tramite Tor, assicurati che Tor sia installato sul tuo computer e poi abilita il Proxy Tor nelle impostazioni di BitBoxApp.\nSulla maggior parte dei sistemi operativi ci sono due modi per eseguire Tor:\n1. 1. Tor Browser: scaricare e aprire il Tor Browser. Questo permetter alla BitBoxApp di connettersi alla rete Tor impostando la porta 9150 nelle impostazioni del proxy Tor.\n2. Servizio Tor in background: installare il daemon Tor, che viene sempre eseguito in background. La BitBoxApp pu quindi connettersi impostando la porta 9050 nelle impostazioni del proxy Tor.",
      title: "Cos' Tor, Tor proxy e quale porta usare?"
    },
    what: {
      text: " possibile utilizzare il tuo wallet con il mio full node invece di usare i server di Shift.",
      title: "Cosa significa?"
    },
    why: {
      text: "Utilizzare il proprio nodo non  necessario, ma migliora la privacy e riduce la necessit di fidarsi degli altri.\nIn primo luogo, significa che stai usando Bitcoin pi privatamente, poich la BitBoxApp non si connetter ai nostri server per recuperare la tua storia delle transazioni; invece recuperer quelle informazioni dal tuo nodo.\nIn secondo luogo, utilizzare il tuo nodo significa che il tuo nodo verifica tutte le transazioni, assicurandosi che le regole di consenso siano applicate.",
      title: "Perch dovrei utilizzare il mio nodo?"
    }
  },
  settings: {
    sats: {
      text: "Un Satoshi ('sat' in breve)  la pi piccola unit di Bitcoin. Un Satoshi  un centomilionesimo di Bitcoin (0.00000001 BTC). E' stato chiamato cos in omaggio al creatore di Bitcoin, Satoshi Nakamoto.",
      title: "Cos' un Satoshi? "
    },
    servers: {
      text: "Questa app comunica con i server Shift Crypto per controllare gli aggiornamenti, caricare le transazioni e inviare informazioni alle app mobili abbinate.\nL'app recupera anche gli ultimi tassi di cambio da CoinGecko. Tutte le conversioni sono calcolate localmente, il che significa che nessun dato sull'importo della tua transazione viene mai trasmesso.\nNota: Per Ethereum e i Token ERC20, usiamo le API di Etherscan.io.",
      title: "A quali server si connette questa app?"
    }
  },
  title: "Guida",
  toggle: {
    close: "Chiudi guida",
    open: "Guida"
  },
  trackingModePortfolioChart: {
    text: "Su Desktop, sposta il cursore sopra al grafico. Da mobile, tieni il dito premuto sul grafico e spostalo orizzontalmente.",
    title: "Come visualizzare lo storico dei prezzi sul grafico? "
  },
  unlock: {
    forgotDevicePassword: {
      text: "Devi resettare il dispositivo e ripristinare il wallet da un backup, utilizzando la password di recupero.",
      title: "Cosa devo fare se ho dimenticato la password del dispositivo?"
    },
    reset: {
      text: "Inserisci una password errata del dispositivo per 15 volte. Gli ultimi tentativi richiedono un lungo tocco sul dispositivo.",
      title: "Come faccio a resettare il dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Il dispositivo dovrebbe lampeggiare una volta quando viene inserito. Assicurati che sia inserito nel modo giusto. Se hai problemi, contattaci attraverso il link qui sotto.\n\nIl BitBox01 non  supportato su dispositivi mobili. Utilizzare la BitBoxApp su desktop per collegare il BitBox01.",
      title: "Il mio BitBox01 non viene riconosciuto"
    },
    getDevice: {
      link: {
        text: "Ordina un BitBox"
      },
      text: "Puoi comprare una BitBox nel nostro negozio online:",
      title: "Come posso ottenere un dispositivo?"
    },
    internet: {
      text: "S,  necessaria una connessione internet per sincronizzare il wallet, inviare transazioni e recuperare gli ultimi tassi di cambio.",
      title: "Questa app richiede una connessione a internet?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Puoi recuperare i tuoi account su un nuovo BitBox o con il nostro Backup center.",
      title: "Ho perso il mio dispositivo. E adesso?"
    },
    useWithoutDevice: {
      text: "Purtroppo, questo non  ancora possibile al momento.",
      title: "Posso usare l'applicazione senza un dispositivo?"
    },
    welcome: {
      text: "Grazie per aver usato questa app costruita da Shift Crypto in Svizzera. Apprezziamo qualsiasi input che hai da condividere. Inviaci il tuo feedback utilizzando il link in basso.",
      title: "Benvenuti nella BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se utilizzi la BitBoxApp su un nuovo telefono/computer, dovrai riconnetterti alle DApp per vedere le valute collegate come al solito.",
      title: "Non vedo le mie connessioni precedenti."
    },
    supportedNetworks: {
      text: "Al momento, solo la mainnet Ethereum  supportata da WalletConnect nella BiBoxApp. Se hai bisogno di un wallet per altre chain EVM puoi utilizzare l'estensione per il browser Rabby.",
      title: "Quali reti sono supportate?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect  un protocollo di comunicazione per applicazioni web3. Ti permette di connetterti comodamente a DApp e web wallet senza dover usare un'altra app. Particolarmente utile per gli utenti Android della BitBoxApp.",
      title: "Cos' WalletConnect?"
    }
  }
};
const headerssync = {
  blocksSynced: "{{blocks}} blocchi sincronizzati"
};
const hiddenWallet = {
  info1HTML: "Per scopi di negazione plausibile, un wallet nascosto pu essere creato sulla base di una combinazione <strong>diversa</strong> di password del dispositivo + password di recupero.",
  info2HTML: "Definisci la password del dispositivo e la password di recupero che vuoi associare al tuo wallet nascosto qui sotto. La password del dispositivo e la password di recupero devono essere <strong>diverse</strong> da quelle che hai definito per il tuo wallet principale.",
  passwordLabel: "Password di recupero nascosta",
  passwordPlaceholder: "Si prega di confermare la password di recupero nascosta",
  pinLabel: "Password nascosta del dispositivo",
  pinRepeatLabel: "Ripetere la password del dispositivo nascosto",
  pinRepeatPlaceholder: "Si prega di confermare la password del dispositivo nascosto",
  success: "Wallet nascosto creato con successo. Ricollega il tuo BitBox per sbloccarlo."
};
const initialize = {
  create: "Imposta la password del dispositivo",
  creating: "Impostazione della password del dispositivo...",
  error: {
    e102: "La password del dispositivo deve essere composta da almeno 4 caratteri."
  },
  info: {
    description1: "Scegli la password del tuo dispositivo. Questa sar usata per sbloccare il tuo BitBox.",
    description2: "Puoi usare numeri, lettere e simboli. Password pi lunghe offrono maggiore sicurezza.",
    description3: "Se perdi la password del dispositivo, dovrai resettare il tuo dispositivo e ripristinare il backup del wallet.",
    subtitle: "Ora imposterai la password del tuo dispositivo",
    title: "Inizializzazione del dispositivo"
  },
  input: {
    label: "Password del dispositivo",
    labelRepeat: "Ripetere la password del dispositivo",
    placeholderRepeat: "Si prega di confermare la password del dispositivo"
  }
};
const invalidFormat = "Formato non valido";
const language$1 = {
  title: "Seleziona lingua"
};
const legacyhiddenwallet = {
  disable: "Disattiva il wallet nascosto legacy",
  enable: "Abilita il wallet nascosto legacy",
  successDisable: "Wallet nascosto legacy disattivato con successo",
  successEnable: "Il wallet nascosto legacy  stato attivato con successo. Ricollega il tuo BitBox e inserisci la password del dispositivo nascosto per accedere al wallet nascosto legacy."
};
const loading = "caricamento...";
const manageAccounts = {
  accountHidden: "Questo account  stato nascosto dalla lista degli account watch-only. Per vederlo di nuovo, connetti il tuo BitBox02",
  editAccount: "Modifica",
  editAccountNameTitle: "Modifica il nome dell'account",
  noAccounts: "Nessun account trovato",
  settings: {
    hideTokens: "Nascondi token",
    showTokens: "Mostra token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aggiungi e mostra/nascondi gli account",
  title: "Gestisci gli account",
  watchAccount: "Watch-only account",
  watchAccountDescription: "Questo account  stato aggiunto alla lista degli account watch-only. Disattiva per nasconderlo."
};
const mobile = {
  usingMobileDataWarning: "Utilizzo di dati mobili: dopo aver sbloccato un account questa app pu scaricare fino a qualche centinaio di megabyte di dati dell'intestazione della blockchain. Si prega di connettersi al Wi-Fi per evitare di utilizzare i dati mobili. Dopo averlo chiuso, questo messaggio non verr pi visualizzato."
};
const newSettings = {
  about: {
    appVersion: {
      title: "Versione dell'app"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Blocca l'accesso all'app con blocco schermo/impronta digitale.",
      title: "Blocco schermo"
    },
    coinControl: {
      description: "Seleziona quali UTXOs fanno parte di una transazione per aiutarti ad aumentare la tua privacy."
    },
    customFees: {
      description: "Ti permette di inserire una fee a tua discrezione all'invio."
    },
    torProxy: {
      description: "Connettiti tramite Tor per una migliore privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Puoi ruotare tra queste valute aggiuntive dalla pagina del tuo account.",
      title: "Valute attive"
    },
    darkmode: {
      description: "Visualizza la BitBoxApp in modalit scura."
    },
    defaultCurrency: {
      description: "Selezione la valuta di default",
      title: "Valuta di default"
    },
    enableAccount: {
      description: "Disabilitare il tuo account significa che non comparir nella barra laterale o nel portafoglio. Puoi sempre riattivarlo da qui. I fondi su questo conto non saranno modificati e rimarranno al sicuro.",
      title: "Abilita/disabilita account"
    },
    hideAmounts: {
      description: "Visualizza un'opzione per nascondere il tuo bilancio e gli importi per aumentare la tua privacy quando usi l'app in pubblico.",
      hideAmounts: "Nascondi importi",
      showAmounts: "Mostra importi",
      title: "Abilita importi nascosti"
    },
    language: {
      description: "In che lingua preferisci visualizzare la BitBoxApp.",
      title: "Lingua"
    },
    remebmerWallet: {
      name: "Ricorda wallet",
      warning: "Questo far dimenticare il tuo wallet. Per vederlo di nuovo, dovrai collegare il relativo BitBox02. I fondi presenti sul wallet non saranno modificati. Vuoi continuare?",
      warningTitle: 'Disattiva "Ricorda wallet"'
    },
    toggleSats: {
      description: "Abilita o disabilita i Satoshi"
    }
  }
};
const note$1 = {
  input: {
    description: "(facoltativo)",
    placeholder: "Aggiungi nota..."
  },
  title: "Nota"
};
const notification = {
  newTxs_one: "Nuova transazione in: {{accountName}}",
  newTxs_other: "{{count}} nuove transazioni in: {{accountName}}"
};
const pairing = {
  aborted: {
    text: "L'abbinamento  stato interrotto dall'applicazione mobile.",
    title: "Interrotto"
  },
  button: "Abbina l'applicazione mobile",
  confirm: "Sei sicuro/a di voler abbinare il tuo BitBox? Si noti che in seguito, il telefono cellulare sar necessario per eseguire transazioni.",
  connectOnly: {
    button: "Collegare l'applicazione mobile",
    title: "Esegui la scansione con la nostra applicazione mobile selezionando la voce di menu 'Connetti a nuova applicazione desktop'."
  },
  error: {
    text: "Qualcosa  andato storto. Per favore, ricomincia.",
    title: "Errore"
  },
  pullFailed: {
    text: "Impossibile estrarre un messaggio dal tuo cellulare attraverso il server relay. Il server potrebbe essere offline, contatta il supporto.",
    title: "Fallito"
  },
  reconnectOnly: {
    button: "Riconnetti applicazione mobile"
  },
  scanningFailed: {
    text: "Il cellulare non  stato in grado di scansionare il messaggio con successo. Si prega di riprovare.",
    title: "Scansione fallita"
  },
  start: {
    hideAppQRCode: "Nascondi il codice QR",
    revealAppQRCode: "Mostra il codice QR",
    step1: "Se non hai l'applicazione mobile, puoi scansionare il codice QR per l'App Store di Apple o il Play Store di Google, a seconda del telefono che usi.",
    step2: "Scansiona con la nostra applicazione mobile, che puoi trovare sotto il nome 'Digital Bitbox 2FA' negli app store per iOS e Android:"
  },
  started: {
    text: "Ora segui le istruzioni dell'applicazione mobile.",
    title: "Ottimo"
  },
  success: {
    text: "Congratulazioni, hai abbinato con successo il tuo BitBox con l'applicazione mobile",
    title: "Successo"
  },
  timeout: {
    text: "L'abbinamento  scaduto dopo due minuti. Ricomincia se vuoi ancora abbinare l'applicaione mobile.",
    title: "Timeout"
  },
  title: "Abbinamento telefono cellulare"
};
const passphrase = {
  considerations: {
    button: "Considerazioni sul backup\n",
    message: "La passphrase aggiunge un livello di protezione al backup del wallet (scheda microSD o parole di recupero). Se qualcuno ha accesso al tuo backup, avr bisogno anche della passphrase per accedere al tuo wallet.\n\nTuttavia, questo significa che saranno necessari <strong>sia la passphrase che il backup del wallet</strong> per ripristinare il wallet con passphrase, nel caso in cui il BitBox02 venga perso o rotto. Se si dimentica o si perde la passphrase, si perde l'accesso a tutti i fondi del wallet.\n\nTi consigliamo di conservare la passphrase in un luogo separato rispetto al backup. In questo modo, se qualcuno trova il backup, non trover anche la passphrase.",
    title: "Considerazioni sul backup"
  },
  disable: "Disabilita la passphrase",
  disableInfo: {
    button: "Disabilita",
    message: "Una volta disabilitata la passphrase, non verr pi richiesto di inserire una passphrase dopo aver sbloccato il BitBox02. Pertanto, si acceder al proprio wallet predefinito.\n\nTutte le valute presenti nel wallet con la passphrase saranno ancora presenti in quel wallet, ma non sar possibile accedervi perch, dopo aver sbloccato il BitBox02, si aprir il wallet predefinito.\n\nPer accedere nuovamente ai wallet con passphrase,  sufficiente riattivare la funzione passphrase e inserire la stessa dopo aver sbloccato il BitBox02.\n\n<strong>Suggerimento:</strong>  ancora possibile accedere al wallet originale lasciando la passphrase vuota."
  },
  enable: "Abilita la passphrase",
  error: {
    e104: "La modifica dell'impostazione della passphrase  stata interrotta."
  },
  how: {
    button: "Come si presenta",
    message: "Una passphrase non funziona come una password a cui si  abituati. Se si sbaglia a digitare la passphrase, non si riceve alcuna notifica. Questo perch <strong>ogni passphrase crea un wallet diverso, ma valido</strong>. Ci significa che  possibile utilizzare diverse passphrase per tanti wallet quanti se ne desiderano. Ma si pu accedere a ciascun wallet solo digitando la passphrase corrispondente.\n\nQuando si collega il BitBox02, viene richiesta la password del dispositivo come di consueto. Successivamente, verr richiesto di inserire una passphrase sul dispositivo.\n\nDopo aver inserito la passphrase, ti verr mostrata la passphrase inserita. In questo modo puoi confermare di averla inserita correttamente.",
    title: "Come funziona"
  },
  intro: {
    message: "Una passphrase fornisce un livello di sicurezza aggiuntivo al tuo wallet.\nScopriamo come funziona.",
    title: "Impostare la passphrase"
  },
  progressDisable: {
    message: "Confermare sul BitBox che si desidera <strong>disabilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  progressEnable: {
    message: "Confermare su BitBox che si desidera <strong>abilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  successDisabled: {
    message: "Passphrase opzionale <strong>attivata con successo</strong>!\nD'ora in poi verr richiesto di fornire una passphrase.",
    messageEnd: "Ricollegare ora il BitBox02.\n",
    title: "Passphrase abilitata"
  },
  successEnabled: {
    message: "Passphrase opzionale <strong>disabilitata con successo</strong>!\n\nNon verr pi richiesto di fornire una passphrase.",
    messageEnd: "Ricollegare ora il BitBox02.\n",
    tips: "Suggerimenti",
    tipsList: [
      "Si consiglia di inviare prima un piccolo importo al wallet con passphrase. Quindi scollegare e ricollegare il BitBox02 e inserire la password e la passphrase. Se la passphrase  stata inserita correttamente, si dovrebbero vedere i fondi nel wallet.",
      "Se si desidera accedere al wallet originale senza passphrase,  ancora possibile farlo non inserendo nulla quando viene richiesto di inserire la passphrase. Oppure puoi disattivare la funzione passphrase."
    ],
    title: "Passphrase disabilitata"
  },
  summary: {
    button: "Passphrase disabilitata",
    title: "Riepilogo",
    understand: "Ho capito come funziona la passphrase e i rischi ad essa associati.\n",
    understandList: [
      "La passphrase  un ulteriore livello di sicurezza oltre al backup.\n",
      "L'inserimento di una passphrase diversa generer sempre un wallet diverso.",
      "Per ripristinare il wallet sono necessari <strong>sia la passphrase che il backup</strong>.",
      "Se si dimentica la passphrase, <strong>non  pi possibile accedere ai propri fondi</strong>.\n"
    ]
  },
  what: {
    button: "Scopri come funziona",
    message: "Un wallet viene creato (derivato) da un numero casuale molto grande, noto anche come seed. Questo seed viene creato quando si configura per la prima volta il BitBox02 e viene salvato nella scheda microSD o in una lista di parole di recupero. Chiunque abbia accesso al seed ha il pieno controllo sui fondi di quel wallet.\n\nUna passphrase  un <strong>segreto opzionale</strong>, aggiunto al seed. Quando si usa una passphrase, ogni passphrase crea un nuovo wallet basato sul seed + passphrase (segreto opzionale). Una passphrase pu essere qualsiasi cosa: lettere, parole, caratteri speciali o pu anche essere vuota. Il wallet predefinito deriva infatti dal seed + passphrase vuota.\n\nLa passphrase fa parte dello standard BIP39, il che significa che  compatibile con tutti i wallet che supportano lo stesso standard.",
    title: "Cos' una passphrase?"
  },
  why: {
    button: "Perch usare una passphrase",
    message: `BitBox02 protegge il seed dall'estrazione dal dispositivo stesso, ma il backup (scheda microSD o parole di recupero) d pieno accesso al wallet. Per questo motivo deve essere conservato in un luogo sicuro!

Poich una passphrase crea un nuovo wallet utilizzando il seed esistente, il wallet con la passphrase richiede sia il <strong>backup che la passphrase per il ripristino</strong>. Il vantaggio  che se qualcuno trova il tuo backup, ha comunque bisogno della passphrase per accedere al wallet con passphrase.

Inoltre, la funzione passphrase consente di creare piwallet sullo stesso dispositivo, o "wallet nascosti", oltre a quello predefinito.`,
    title: "Perch usare una passphrase?"
  }
};
const password = {
  show: "Mostra {{label}}",
  warning: {
    caps: 'per incollare il testo, attivare "MOSTRA {{etichetta}}"',
    paste: 'per incollare il testo, attivare "MOSTRA {{label}}"'
  }
};
const random$1 = {
  button: "Genera un numero casuale",
  description: "Il tuo BitBox ha generato il seguente numero casuale {{bits}}-bit:"
};
const receive$2 = {
  bitsuranceWarning: "Questo  un account assicurato, e pu ricevere transazioni solo su indirizzi di tipo Native Segwit. In questo modo non riceverai accidentalmente fondi su indirizzi di tipo Wrapped Segwit o Taproot, che non sono assicurati.",
  changeScriptType: "Cambia il tipo di indirizzo",
  label: "Il tuo indirizzo",
  onlyThisCoin: {
    description: "Per ricevere altri token, abilitali nelle impostazioni. Se depositi altri token, potrebbero non essere accessibili.",
    warning: "Assicurati di ricevere solo {{coinName}} su questo indirizzo."
  },
  scriptType: {
    p2tr: "Taproot (formato pi recente)",
    p2wpkh: "Native Segwit (predefinito)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatibile)"
  },
  selectAccount: "Scegli un account",
  showFull: "Mostra e verifica l'indirizzo completo sul dispositivo",
  taprootWarning: "Nota: Taproot  una nuova funzione di Bitcoin e non  ancora ampiamente adottata. I fondi ricevuti sugli indirizzi Taproot potrebbero non essere visibili nei wallet di terze parti. Molti wallet e exchange non sono ancora in grado di inviare ad indirizzi Taproot.",
  title: "Ricevi {{accountName}}",
  verify: "Verificare l'indirizzo in modo sicuro",
  verifyBitBox01: "Verificare l'indirizzo sull'applicazione mobile",
  verifyBitBox02: "Verificare l'indirizzo sul BitBox02",
  verifyInstruction: "Verifica che il seguente indirizzo corrisponda a quello visualizzato sul tuo dispositivo.",
  warning: {
    secureOutput: "Si prega di associare il tuo BitBox con il tuo dispositivo mobile per abilitare la verifica sicura dell'indirizzo. Vai su 'Gestisci dispositivo' nella barra laterale."
  }
};
const reset = {
  description: "Tutti i dati saranno cancellati dal dispositivo. Inclusa la tua chiave privata!",
  notReset: "Dispositivo NON resettato.",
  title: "Ripristino di fabbrica del dispositivo",
  understand: "Ho un backup e conosco la mia password di recupero",
  understandBB02: "Ho un backup valido"
};
const securityInformation = {
  create: {
    description1: "Ti consigliamo di impostare il tuo dispositivo in un ambiente sicuro, cio lontano da altre persone che potrebbero vedere la password che hai scelto.",
    description2: "Ti verr chiesto di creare due password.",
    description3: "La prima  la <strong>password del dispositivo</strong> che sblocca il tuo dispositivo BitBox e pu essere cambiata in seguito.",
    description4: "La seconda  la <strong>password di recupero</strong> che sblocca il tuo wallet. Questa password non pu essere cambiata in seguito.",
    description5: "Il wallet creato sar salvato in un file sulla scheda microSD fornita. Questo pu essere utilizzato in caso di emergenza per recuperare i tuoi fondi utilizzando la tua <strong>password di recupero</strong>.",
    title: "Informazioni di sicurezza"
  },
  restore: {
    description1: "Ti verr chiesto di inserire la scheda microSD che hai usato per memorizzare il tuo backup.",
    description2: "Per ripristinare il tuo dispositivo avrai bisogno della tua password di recupero. ",
    description3: "Fai attenzione quando inserisci la password di recupero. Qualsiasi password inserita creer un wallet valido. Se inserisci la password sbagliata, potrebbe esserti mostrato un saldo del wallet che non ti aspetti.",
    title: "Informazioni di sicurezza"
  }
};
const seed = {
  agreements: {
    "funds-access": "NON potr accedere ai miei fondi se dimentico la mia password di recupero",
    "password-change": "NON posso cambiare la password di recupero in futuro.",
    "password-required": "La password di recupero  necessaria per ripristinare un wallet da un backup"
  },
  create: "Crea un wallet",
  creating: "Creazione del wallet",
  description: "Capisco che:",
  error: {
    e102: "La password deve essere composta da almeno 4 caratteri.",
    e200: " necessario inserire una scheda microSD nel tuo BitBox per creare un wallet, cos un backup pu essere creato automaticamente."
  },
  info: {
    button: "Imposta ora la password di recupero\n",
    description1: "Inserire la scheda microSD nel BitBox",
    description2: 'Scegli una password di recupero per il wallet e seleziona "Imposta password di recupero ora".',
    description3: "Il backup su scheda microSD e la password di recupero sono l'unico metodo per recuperare i tuoi fondi in caso di perdita o furto del dispositivo BitBox.",
    description4: "Non  possibile cambiare la password di recupero in futuro senza dover trasferire i tuoi fondi.",
    title: "Crea un nuovo wallet"
  },
  password: {
    label: "Password di recupero",
    repeatPlaceholder: "Ripeti la password di recupero"
  },
  walletName: {
    label: "Nome del wallet"
  }
};
const seedRestore = {
  error: {
    e200: "Il ripristino di un wallet da un backup richiede la scheda microSD."
  },
  info: {
    description1: 'Inserire la scheda microSD nel BitBox e cliccare su "Continua".',
    description2: 'Scegliete un backup e cliccate su "Ripristina".',
    description3: "Inserisci la password di recupero",
    description4: "Confermo di aver capito che una password errata creer un wallet diverso.",
    title: "Come ripristinare un wallet da un backup"
  }
};
const send$2 = {
  abort: "La transazione  stata annullata",
  address: {
    label: "Indirizzo del destinatario",
    placeholder: "Inserisci indirizzo"
  },
  amount: {
    label: "Importo",
    placeholder: "Inserisci importo"
  },
  availableBalance: "Saldo disponibile",
  button: "Controlla",
  coincontrol: {
    address: "Indirizzo",
    outpoint: "Outpoint",
    title: "Invia da un output"
  },
  confirm: {
    "selected-coins": "Seleziona valute",
    title: "Conferma ed invia transazione",
    total: "Totale"
  },
  error: {
    erc20InsufficientGasFunds: "Sembra che tu non abbia abbastanza Ether per pagare questa transazione ERC20. Per favore, assicurati di avere abbastanza Ether nel tuo wallet.",
    feeTooLow: "commissione troppo bassa",
    feesNotAvailable: "Impossibile stimare le commissioni\n",
    insufficientFunds: "fondi insufficienti.",
    invalidAddress: "indirizzo non valido",
    invalidAmount: "importo non valido",
    invalidData: "dati non validi"
  },
  fee: {
    customPlaceholder: "Inserisci importo",
    label: "Commissioni di rete",
    placeholder: "Non disponibile"
  },
  feeTarget: {
    customLabel: "Tariffa",
    customLabel_eth: "Gas",
    description: {
      economy: "4 ore (24 blocchi)",
      economy_eth: "30 minuti al massimo",
      economy_ltc: "1 ora (24 blocchi)",
      high: "20 minuti (2 blocchi)",
      high_eth: "30 secondi al massimo",
      high_ltc: "5 minuti (2 blocchi)",
      low: "2 ore (12 blocchi)",
      low_eth: "5 minuti al massimo",
      low_ltc: "30 minuti (12 blocchi)",
      normal: "6 blocchi (circa 1 ora per Bitcoin, 15 minuti per Litecoin)",
      normal_eth: "2 minuti al massimo",
      normal_ltc: "15 minuti (6 blocchi)"
    },
    estimate: "Tempo di conferma stimato:",
    label: {
      custom: "Personalizzata",
      economy: "Economica",
      high: "Alta",
      low: "Bassa",
      normal: "Normale"
    },
    placeholder: "Calcolo delle commissioni..."
  },
  maximum: "Invia tutto",
  maximumSelectedCoins: "Invia le valute selezionate\n",
  noFeeTargets: "La stima delle fee al momento non  disponibile. Inserisci una fee a tua discrezione o riprova pi tardi.",
  priority: "Priorit",
  scanQR: "Leggi il QR code",
  signprogress: {
    description: "Questa  una transazione che contiene molti dati. Per firmare la transazione, ti verr chiesto di confermare {{steps}} volte.",
    label: "Progresso"
  },
  success: "La transazione  stata firmata ed inviata.",
  title: "Invia {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Dettagli della transazione"
};
const settings$1 = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Impostazioni avanzate",
  appearance: "Aspetto",
  electrum: {
    add: "Aggiungi un server",
    "add-server": "Aggiungi",
    check: "Verifica",
    checkFailed: "Fallito",
    checkSuccess: "Connessione stabilita con {{host}}",
    checking: "Verifico",
    "download-cert": "Scarica certificato remoto",
    "remove-server": "Rimuovi",
    removeConfirm: "Rimuovere {{server}}?",
    reset: "Ripristina le impostazioni predefinite",
    resetConfirm: "Vuoi rimuovere tutti i server e installare quelli di default?",
    servers: "Server",
    step1: "1",
    "step1-text": "Inserisci l'endpoint.",
    step2: "2",
    "step2-text": "Inserisci un certificato della catena dei certificati del server. In alternativa, scarica il certificato remoto e confrontalo visivamente.",
    "step2-text-tcp": "Puoi saltare questo passo se non vuoi usare TLS.",
    step3: "3",
    "step3-text": "Controlla la connessione e aggiungi il server.",
    step4: "4",
    "step4-text": "Riavvia il wallet. Se non rimuovi i server di default, il tuo nodo sar aggiunto come ridondanza.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: 'Abilita "coin control"',
    electrum: {
      description: "Puoi connetterti al tuo full node Electrum",
      title: "Connetti il tuo full node"
    },
    fee: "Abilitare commissioni personalizzate",
    setProxyAddress: "Imposta indirizzo proxy",
    title: "Impostazioni avanzate",
    useProxy: "Abilita il proxy per tor",
    useSats: "Mostra i valori BTC in Satoshi"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nuovo aggiornamento disponibile",
    title: "Informazioni",
    "up-to-date": "La tua app  aggiornata",
    version: "Versione App"
  },
  restart: "Si prega di riavviare la BitBoxApp affinch le modifiche abbiano effetto.",
  services: {
    title: "Servizi"
  },
  success: "Si prega di scollegare e ricollegare il BitBox affinch le modifiche abbiano effetto.",
  title: "Impostazioni"
};
const setup = "Imposta il dispositivo";
const sidebar$1 = {
  buy: "Acquista criptovalute",
  device: "Gestisci il dispositivo",
  insurance: "Assicura",
  leave: "Esci",
  settings: "Impostazioni"
};
const success$7 = {
  create: {
    info1: "Il tuo wallet  stato salvato in modo sicuro sulla scheda microSD. Rimuovila e tienila al sicuro.",
    info2: "Hai creato una password sicura del dispositivo che sblocca il BitBox.",
    info3: "Hai creato una password di recupero sicura per il tuo wallet che sblocca i tuoi fondi e ripristina i tuoi backup.",
    summary: "Ecco un riassunto di quello che hai fatto",
    title: "Successo"
  },
  getstarted: "Inizia",
  restore: {
    summary: "Hai ripristinato con successo un wallet dal tuo backup.",
    title: "Successo"
  }
};
const transaction$1 = {
  confirmation: "Conferme",
  details: {
    activity: "Attivit",
    address: "Indirizzo",
    amount: "Importo",
    date: "Data",
    fiat: "Fiat",
    fiatAmount: "Importo fiat",
    fiatAtTime: "Fiat al tempo della transazione",
    status: "Status",
    title: "Dettagli della Transazione",
    type: "Tipo"
  },
  explorer: "ID della transazione",
  explorerTitle: "Apri in un esploratore di blocchi esterno",
  fee: "Commissione",
  fiatHistorical: "Storico",
  gas: "Gas",
  note: {
    edit: "Modifica nota",
    save: "Salva nota"
  },
  pending: "Transazione in sospeso",
  size: "Dimensione",
  status: {
    complete: "Completata",
    failed: "Fallita",
    pending: "In sospeso"
  },
  tx: {
    received: "Ricevuta a",
    sent: "Inviata a"
  },
  vsize: "Dimensione virtuale",
  weight: "Peso"
};
const transactions = {
  errorLoadTransactions: "Si  verificato un errore nel carimento delle transazioni",
  placeholder: "Nessuna transazione."
};
const unknownError = "Si  verificato un errore sconosciuto: {{errorMessage}}";
const unlock = {
  description: "Inserisci la password del tuo dispositivo per sbloccarlo.",
  error: {
    e109_normal: "Password del dispositivo errata. Restano ancora {{remainingAttempts}} tentativi prima che il dispositivo venga resettato.",
    e109_touch: "$t(unlock.error.e109_normal) Il prossimo login richiede di tenere premuto il pulsante touch.",
    e113: "A causa di molti tentativi di login, il login successivo richiede di tenere premuto il pulsante a sfioramento per 4 secondi."
  },
  input: {
    label: "Password del dispositivo",
    placeholder: "Inserisci la password del tuo dispositivo per sbloccare il dispositivo"
  },
  unlocking: "Sblocco..."
};
const upgradeFirmware$1 = {
  button: "Aggiorna il firmware",
  description: "Vuoi aggiornare il firmware dalla versione {{currentVersion}} alla {{newVersion}}?",
  label: "Il tuo BitBox richiede un aggiornamento del firmware.",
  locked: "Per aggiornare da {{currentVersion}} a {{newVersion}}, fai un tocco lungo.",
  title: "Aggiorna il firmware",
  unlocked: "Il bootloader  sbloccato. Per continuare, per favore:",
  unlocked1: "Scollega e ricollega il tuo Bitbox",
  unlocked2: "Il LED si accende quando il tuo BitBox  ricollegato",
  unlocked3: "Tocca il pulsante a sfioramento quando il LED si accende"
};
const walletConnect$2 = {
  connect: {
    button: "Conneti",
    dappLabel: "Inserire indirizzo URI della DApp",
    invalidPairingUri: "URI di connessione non valido"
  },
  dashboard: {
    allSessions: "Tutte le sessioni",
    disclaimer: "WalletConnect  un protocollo per connettersi a Dapp basate su Ethereum. Queste DApp sono gestite da servizi di terze parti, per cui connettiti solo a DApp di cui ti fidi e accertati di sapere sempre cosa stai firmando quando crei una transazione.",
    newConnection: "Nuova Connessione",
    noConnectedSessions: "Nessun account  connesso a DApp al momento."
  },
  invalidPairingChain: "Errore nell'approvazione della connessione. Assicurati di utilizare una delle chain supportate: {{chains}}",
  pairingRequest: {
    approve: "Approva Connessione",
    reject: "Rifiuta",
    title: "Nuova richista di connessione da"
  },
  pairingSuccess: "DApp connessa. Puoi continuare sul sito della DApp.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Dati",
    dataParsingError: "Parse dei dati fallto.",
    decodeError: "Decodifica del messaggio fallita",
    method: {
      sendTransaction: "Firma ed invia transazione",
      signMessage: "Firma messaggio",
      signTransaction: "Firma transazione",
      signTypedData: "Firma typed data"
    },
    successfullySigned: "Richiesta firmata con successo",
    walletConnectRequest: "Richiesta WalletConnect"
  },
  useNewUri: "Questo URI  gi stato utilizzato per provare a connettersi. Per favore, utilizzare un nuovo URI.",
  walletConnect: "WalletConnect"
};
const warning$6 = {
  receivePairing: `Si prega di associare il BitBox per abilitare la verifica sicura dell'indirizzo. Vai su "Gestisci dispositivo" nella barra laterale.`,
  sdcard: "Tenere la scheda microSD separata dal BitBox, a meno che non si vogliano gestire i backup.",
  sendPairing: "Si prega di abbinare il BitBox per verificare in modo sicuro i dettagli della transazione. Vai su 'Gestisci dispositivo' nella barra laterale."
};
const welcome = {
  connect: "Connetti BitBox02",
  getStarted: "Iniziamo con l'installazione del firmware sul BitBox02.",
  insertBitBox02: "Se hai collegato un BitBox02, tocca il dispositivo per continuare.",
  insertDevice: "Collega il tuo dispositivo per cominciare",
  title: "Benvenuto"
};
const appTranslationsIT = {
  account,
  accountInfo,
  accountSummary,
  addAccount: addAccount$1,
  aopp,
  app,
  auth: auth$1,
  backup,
  bb02Bootloader,
  bitbox,
  bitbox02Interact,
  bitbox02Settings,
  bitbox02Wizard,
  bitsurance,
  bitsuranceAccount,
  blink,
  bootloader,
  button: button$5,
  buy: buy$1,
  changePin,
  chart: chart$1,
  checkSDcard,
  clickHere,
  confirm: confirm$2,
  confirmOnDevice,
  connectKeystore: connectKeystore$1,
  darkmode: darkmode$1,
  device,
  deviceLock,
  deviceSettings,
  deviceTampered,
  dialog: dialog$1,
  error: error$2,
  fiat: fiat$2,
  footer: footer$2,
  generic: generic$1,
  genericError,
  goal,
  guide: guide$1,
  headerssync,
  hiddenWallet,
  initialize,
  invalidFormat,
  language: language$1,
  legacyhiddenwallet,
  loading,
  manageAccounts,
  mobile,
  newSettings,
  note: note$1,
  notification,
  pairing,
  passphrase,
  password,
  random: random$1,
  receive: receive$2,
  reset,
  securityInformation,
  seed,
  seedRestore,
  send: send$2,
  settings: settings$1,
  setup,
  sidebar: sidebar$1,
  success: success$7,
  transaction: transaction$1,
  transactions,
  unknownError,
  unlock,
  upgradeFirmware: upgradeFirmware$1,
  walletConnect: walletConnect$2,
  warning: warning$6,
  welcome
};
function i18nextFormat(locale) {
  return locale.replace("_", "-");
}
const localeMainLanguage = (locale) => {
  return i18nextFormat(locale).split("-")[0];
};
const getRegionNameFromLocale = (nativeLocale) => {
  try {
    const formattedLocale = i18nextFormat(nativeLocale);
    return new Intl.Locale(formattedLocale).region || "";
  } catch {
    return "";
  }
};
const defaultUserLanguage = "en";
const languageFromConfig = {
  type: "languageDetector",
  async: true,
  detect: (cb2) => {
    apiGet("config").then(({ backend }) => {
      if (backend && backend.userLanguage) {
        cb2(backend.userLanguage);
        return;
      }
      apiGet("native-locale").then((locale) => {
        if (typeof locale === "string" && locale) {
          try {
            (/* @__PURE__ */ new Date()).toLocaleString(i18nextFormat(locale));
          } catch (e3) {
            cb2(defaultUserLanguage);
            return;
          }
          cb2(i18nextFormat(locale));
          return;
        }
        cb2(defaultUserLanguage);
      });
    });
  },
  init: () => {
  },
  cacheUserLanguage: () => {
  }
};
let pendingConfig = {};
const getConfig = () => {
  return apiGet("config");
};
const setConfig = (object) => {
  return getConfig().then((currentConfig = {}) => {
    const nextConfig = Object.assign(currentConfig, {
      backend: Object.assign({}, currentConfig.backend, pendingConfig.backend, object.backend),
      frontend: Object.assign({}, currentConfig.frontend, pendingConfig.frontend, object.frontend)
    });
    pendingConfig = nextConfig;
    return apiPost("config", nextConfig).then(() => {
      pendingConfig = {};
      return nextConfig;
    });
  });
};
const locizeProjectID = "fe4e5a24-e4a2-4903-96fc-3d62c11fc502";
let i18Init = instance.use(languageFromConfig);
i18Init.init({
  fallbackLng: "en",
  // have a common namespace used around the full app
  ns: ["app", "wallet"],
  defaultNS: "app",
  debug: false,
  returnObjects: true,
  interpolation: {
    escapeValue: false
    // not needed for react
  },
  react: {
    useSuspense: true
    // Not using Suspense you will need to handle the not ready state yourself
  },
  backend: {
    projectId: locizeProjectID,
    referenceLng: "en"
  }
});
instance.addResourceBundle("ar", "app", appTranslationsAR);
instance.addResourceBundle("cs", "app", appTranslationsCS);
instance.addResourceBundle("de", "app", appTranslationsDE);
instance.addResourceBundle("en", "app", appTranslationsEN);
instance.addResourceBundle("fr", "app", appTranslationsFR);
instance.addResourceBundle("ja", "app", appTranslationsJA);
instance.addResourceBundle("ms", "app", appTranslationsMS);
instance.addResourceBundle("nl", "app", appTranslationsNL);
instance.addResourceBundle("ru", "app", appTranslationsRU);
instance.addResourceBundle("pt", "app", appTranslationsPT);
instance.addResourceBundle("hi", "app", appTranslationsHI);
instance.addResourceBundle("bg", "app", appTranslationsBG);
instance.addResourceBundle("tr", "app", appTranslationsTR);
instance.addResourceBundle("zh", "app", appTranslationsZH);
instance.addResourceBundle("fa", "app", appTranslationsFA);
instance.addResourceBundle("es", "app", appTranslationsES);
instance.addResourceBundle("sl", "app", appTranslationsSL);
instance.addResourceBundle("he", "app", appTranslationsHE);
instance.addResourceBundle("it", "app", appTranslationsIT);
instance.on("languageChanged", (lng) => {
  return getNativeLocale().then((nativeLocale) => {
    let match2 = lng === nativeLocale;
    if (!match2) {
      const lngLang = localeMainLanguage(lng);
      const localeLang = localeMainLanguage(nativeLocale);
      match2 = lngLang === localeLang;
    }
    const uiLang = match2 ? null : lng;
    return setConfig({ backend: { userLanguage: uiLang } });
  });
});
const captureStrongElement = /^(.*)<strong>(.*)<\/strong>(.*)$/;
function SimpleMarkup({ tagName, markup, ...props }) {
  if (typeof markup !== "string") {
    return null;
  }
  const simpleMarkupChunks = captureStrongElement.exec(markup);
  if (simpleMarkupChunks === null || simpleMarkupChunks.length !== 4) {
    return reactExports.createElement(tagName, props, markup);
  }
  return reactExports.createElement(tagName, props, simpleMarkupChunks[1], reactExports.createElement("strong", null, simpleMarkupChunks[2]), simpleMarkupChunks[3]);
}
const MultilineMarkup = ({ tagName, markup, withBreaks, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: markup.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName, markup: line2, ...props }),
    withBreaks && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
  ] }, `${line2}-${i}`)) });
};
const DarkModeContext = reactExports.createContext({});
const useDarkmode = () => {
  const { isDarkMode, toggleDarkmode } = reactExports.useContext(DarkModeContext);
  return { isDarkMode, toggleDarkmode };
};
const alert = "" + new URL("alert-triangle.svg", import.meta.url).href;
const BB02StylizedDark = "" + new URL("bitbox02-stylized-reflection-dark.png", import.meta.url).href;
const BB02StylizedLight = "" + new URL("bitbox02-stylized-reflection-light.png", import.meta.url).href;
const info$4 = "" + new URL("info.svg", import.meta.url).href;
const arrowCircleLeftSVG = "" + new URL("arrow-circle-left.svg", import.meta.url).href;
const arrowCircleLeftActiveSVG = "" + new URL("arrow-circle-left-active.svg", import.meta.url).href;
const arrowCircleRightSVG = "" + new URL("arrow-circle-right.svg", import.meta.url).href;
const arrowCircleRightActiveSVG = "" + new URL("arrow-circle-right-active.svg", import.meta.url).href;
const bankDarkSVG = "" + new URL("bank.svg", import.meta.url).href;
const bankLightSVG = "" + new URL("bank-light.svg", import.meta.url).href;
const buyInfoSVG = "" + new URL("buy-info.svg", import.meta.url).href;
const checkedSmallSVG = "" + new URL("checked-small.svg", import.meta.url).href;
const checkSVG = "" + new URL("check.svg", import.meta.url).href;
const chevronRightDark = "" + new URL("chevron-right-dark.svg", import.meta.url).href;
const chevronLeftDark = "" + new URL("chevron-left-dark.svg", import.meta.url).href;
const cancelSVG = "" + new URL("cancel.svg", import.meta.url).href;
const creditCardDarkSVG = "" + new URL("credit-card.svg", import.meta.url).href;
const creditCardLightSVG = "" + new URL("credit-card-light.svg", import.meta.url).href;
const editSVG = "" + new URL("edit.svg", import.meta.url).href;
const editLightSVG = "" + new URL("edit-light.svg", import.meta.url).href;
const editActiveSVG = "" + new URL("edit-active.svg", import.meta.url).href;
const ETH = "" + new URL("eth-color.svg", import.meta.url).href;
const redDotSVG = "" + new URL("red-dot.svg", import.meta.url).href;
const greenDotSVG = "" + new URL("green-dot.svg", import.meta.url).href;
const yellowDotSVG = "" + new URL("yellow-dot.svg", import.meta.url).href;
const orangeDotSVG = "" + new URL("orange-dot.svg", import.meta.url).href;
const copySVG = "" + new URL("copy.svg", import.meta.url).href;
const shieldSVG = "" + new URL("shield.svg", import.meta.url).href;
const closeSVG = "" + new URL("close.svg", import.meta.url).href;
const closeXWhiteSVG = "" + new URL("close-x-white.svg", import.meta.url).href;
const closeXDarkSVG = "" + new URL("close-x-dark.svg", import.meta.url).href;
const externalLink = "" + new URL("external-link.svg", import.meta.url).href;
const eyeClosedSVG = "" + new URL("eye-closed.svg", import.meta.url).href;
const eyeOpenedSVG = "" + new URL("eye-opened.svg", import.meta.url).href;
const eyeOpenedDarkSVG = "" + new URL("eye-opened-dark.svg", import.meta.url).href;
const globeDarkSVG = "" + new URL("globe-dark.svg", import.meta.url).href;
const globeLightSVG = "" + new URL("globe-light.svg", import.meta.url).href;
const guideSVG = "" + new URL("guide.svg", import.meta.url).href;
const menuDarkSVG = "" + new URL("menu-dark.svg", import.meta.url).href;
const menuLightSVG = "" + new URL("menu-light.svg", import.meta.url).href;
const walletConnectDarkSVG = "" + new URL("wallet-connect-dark.svg", import.meta.url).href;
const walletConnectLightSVG = "" + new URL("wallet-connect-light.svg", import.meta.url).href;
const walletConnectDefaultSVG = "" + new URL("wallet-connect-default.svg", import.meta.url).href;
const warningPNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACowAAAqMBZNxfiQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOMSURBVGiB7ZjPS5RBGMe/877vrluJmLqR4KEfICJ46CB0CNwOGS5sLf0FYq63grqWseipJOzaD6N7lyBSUohAgkDpkgcREiI96Wp00d33dZ4Ou67uvvP6zjvvLFvg97bzzjzP892Z+bwzL3CsY4USq1Xg3FCqnwx+v5iEnra+mp6rRZ6aGNgaSV3hnH8GYJaaHIN4omVq5ovuXIbugJRNWJz4cxwUDwAWN4wXlE1YuvNpN5BbO5UBodv1gNC9ud44rDuf1iW0PZhu3rPsFQBxjy4bphPpPP3m3W9dObXOgGMWRuFdPADEuWU/1JlT2wxsZJKdjNgSgIhP1wIx6om/nF7RkVfbDDDOJuBfPABEGbEn2vLqCFJi/sdAiblxvfX1+9mwuUPPAGUTFpl8MvA4k0/qwGpoA57Y9JMmrIZaQhLY9FNorIaagRISVYsHgDiP2A/C1KA8AyVsfgcQrX4WSyQR679V0bYz8xb5eeE+D4VV5U3EOJsAcxcPAIhEYcbPVva3PAm7j9W0Sh1KSyg3lOoHww3PDoW8q4lsd9sh3cwNpfpVaglsQAabZBfcjQVB2+ExilgNbGBzvXHYD5skKNZnBopY/XXydtB6AhnYHkw3M6Ix346CYkWmqsUYG98eTDcHqSmQAVlsCosVLSu3AmNV2sBGJtlJwB2ZvqI9INwXorGEuxuZZKdsXdIGSqdNMTarJaKQxBIqKdBpVcqALzarJPy3/TZxpaSx6mtA5bQppJD8DBT7S2LV14AMNl0SUUhyDxwMkMPqkQaksVmd27bdjYJ94ScZrB5pQPW06XppEYEcgSl/+WLV00AQbLrkOADn5Z/k2ACRUig/rHpukiNPmxJyVpeBSHE45XdVwwA+p1XhfUDlkl5reX0EcC0h1Ut6reWFVZcBJWyKxBjMM+0w4+0A0/D1xgOrFZE1XNKLQWMn0HRvHNaFLgCA82MZf56NgnZ3woQFBB8BKmZAwyUdABDrGygXDwDWxS7E+gbChgUEWC0bCIXNKrHGJqk2FVVjtWyghCplbB5WYWG+4sVFjo3CwryO0AAQZcDj/R8MqA02zY5zaLh8FSAg//UT9tZ/6gxfxiqjbNbIrS0uAnRJa4ba61trR28v+xdfWtJiuGZwttdW7zpURUCb0WCaswC26l2MgnIN+egcA4CtkWQP5+wRgPN1LkpODKsGx1jL1IelepdyrP9efwF60oqTW0b3mgAAAABJRU5ErkJggg==";
const warningOutlinedSVG = "" + new URL("warning-outlined.svg", import.meta.url).href;
const qrCodeDarkSVG = "" + new URL("qr-dark.svg", import.meta.url).href;
const qrCodeLightSVG = "" + new URL("qr-light.svg", import.meta.url).href;
const saveSVG = "" + new URL("save.svg", import.meta.url).href;
const saveLightSVG = "" + new URL("save-light.svg", import.meta.url).href;
const syncSVG = "" + new URL("sync.svg", import.meta.url).href;
const syncLightSVG = "" + new URL("sync-light.svg", import.meta.url).href;
const selectedCheckLightSVG = "" + new URL("selected-check-light.svg", import.meta.url).href;
const usbSuccessSVG = "" + new URL("usb-success.svg", import.meta.url).href;
const expandIcon = "_expandIcon_j17uw_1";
const style$16 = {
  expandIcon
};
const ExpandOpen = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$16.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "11", y1: "8", x2: "11", y2: "14" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
);
const ExpandClose = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$16.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
);
const AnimatedChecked = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: `checked ${className || ""}`, viewBox: "0 0 52 52", ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "checked-circle", cx: "26", cy: "26", r: "25", fill: "none" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "checked-check", fill: "none", d: "M14.1 27.2l7.1 7.2 16.7-16.8" })
] });
const CaretDown = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `caretDown ${className || ""}`, viewBox: "0 0 1024 1024", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }) });
const ExpandIcon = ({
  expand = true
}) => expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandOpen, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandClose, {});
const ArrowCirlceLeft = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftSVG, draggable: false, ...props });
const ArrowCirlceLeftActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftActiveSVG, draggable: false, ...props });
const ArrowCirlceRight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightSVG, draggable: false, ...props });
const ArrowCirlceRightActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightActiveSVG, draggable: false, ...props });
const BankDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankDarkSVG, draggable: false, ...props });
const Bank = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankLightSVG, draggable: false, ...props });
const BitBox02StylizedDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedDark, draggable: false, ...props });
const BitBox02StylizedLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedLight, draggable: false, ...props });
const BuyInfo$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: buyInfoSVG, draggable: false, ...props });
const Checked = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkedSmallSVG, draggable: false, ...props });
const Check$3 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkSVG, draggable: false, ...props });
const ChevronLeftDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronLeftDark, draggable: false, ...props });
const ChevronRightDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronRightDark, draggable: false, ...props });
const Cancel = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cancelSVG, draggable: false, ...props });
const CreditCardDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardDarkSVG, draggable: false, ...props });
const CreditCard = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardLightSVG, draggable: false, ...props });
const Copy = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: copySVG, draggable: false, ...props });
const Close = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeSVG, draggable: false, ...props });
const CloseXWhite = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXWhiteSVG, draggable: false, ...props });
const CloseXDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXDarkSVG, draggable: false, ...props });
const Edit = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editSVG, draggable: false, ...props });
const EditLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editLightSVG, draggable: false, ...props });
const EditActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editActiveSVG, draggable: false, ...props });
const ETHLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ETH, draggable: false, ...props });
const ExternalLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: externalLink, draggable: false, ...props });
const EyeClosed = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeClosedSVG, draggable: false, ...props });
const EyeOpened = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedSVG, draggable: false, ...props });
const EyeOpenedDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedDarkSVG, draggable: false, ...props });
const GlobeDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeDarkSVG, draggable: false, ...props });
const GlobeLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeLightSVG, draggable: false, ...props });
const GreenDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: greenDotSVG, draggable: false, ...props });
const GuideActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: guideSVG, draggable: false, ...props });
const Info$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: info$4, draggable: false, ...props });
const MenuDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuDarkSVG, draggable: false, ...props });
const MenuLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuLightSVG, draggable: false, ...props });
const OrangeDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: orangeDotSVG, draggable: false, ...props });
const WalletConnectDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDarkSVG, draggable: false, ...props });
const WalletConnectLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectLightSVG, draggable: false, ...props });
const WalletConnectDefaultLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDefaultSVG, draggable: false, ...props });
const QRCodeDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeDarkSVG, draggable: false, ...props });
const QRCodeLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeLightSVG, draggable: false, ...props });
const RedDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: redDotSVG, draggable: false, ...props });
const Save = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveSVG, draggable: false, ...props });
const SaveLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveLightSVG, draggable: false, ...props });
const Shield = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: shieldSVG, draggable: false, ...props });
const Sync = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: syncSVG, draggable: false, ...props });
const SyncLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: syncLightSVG, draggable: false, ...props });
const SelectedCheckLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedCheckLightSVG, draggable: false, ...props });
const Warning = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningPNG, draggable: false, ...props });
const WarningOutlined = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningOutlinedSVG, draggable: false, ...props });
const YellowDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: yellowDotSVG, draggable: false, ...props });
const USBSuccess = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: usbSuccessSVG, draggable: false, ...props });
const Alert$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: alert, draggable: false, ...props });
const AppLogoInvertedImg = "" + new URL("app-logo-inverted.svg", import.meta.url).href;
const AppLogoImg = "" + new URL("app-logo.svg", import.meta.url).href;
const BitBoxLogo = "" + new URL("bitbox-logo.svg", import.meta.url).href;
const BitBox02Logo = "" + new URL("bitbox02-logo.svg", import.meta.url).href;
const BitBox02InvertedLogo = "" + new URL("bitbox02inverted-logo.svg", import.meta.url).href;
const BTC = "" + new URL("btc-color.svg", import.meta.url).href;
const BTC_GREY = "" + new URL("btc-white.svg", import.meta.url).href;
const ETH_GREY = "" + new URL("eth-white.svg", import.meta.url).href;
const LTC = "" + new URL("ltc-color.svg", import.meta.url).href;
const LTC_GREY = "" + new URL("ltc-white.svg", import.meta.url).href;
const SwissOpenSourceLight = "" + new URL("swiss-made-open-source-light.svg", import.meta.url).href;
const SwissOpenSourceDark = "" + new URL("swiss-made-open-source-dark.svg", import.meta.url).href;
const BAT = "" + new URL("bat-color.svg", import.meta.url).href;
const BAT_GREY = "" + new URL("bat-white.svg", import.meta.url).href;
const DAI = "" + new URL("dai-color.svg", import.meta.url).href;
const DAI_GREY = "" + new URL("dai-white.svg", import.meta.url).href;
const LINK = "" + new URL("link-color.svg", import.meta.url).href;
const LINK_GREY = "" + new URL("link-white.svg", import.meta.url).href;
const MKR = "" + new URL("mkr-color.svg", import.meta.url).href;
const MKR_GREY = "" + new URL("mkr-white.svg", import.meta.url).href;
const USDC = "" + new URL("usdc-color.svg", import.meta.url).href;
const USDC_GREY = "" + new URL("usdc-white.svg", import.meta.url).href;
const USDT = "" + new URL("usdt-color.svg", import.meta.url).href;
const USDT_GREY = "" + new URL("usdt-white.svg", import.meta.url).href;
const ZRX = "" + new URL("zrx-color.svg", import.meta.url).href;
const ZRX_GREY = "" + new URL("zrx-white.svg", import.meta.url).href;
const WBTC = "" + new URL("wbtc-color.svg", import.meta.url).href;
const WBTC_GREY = "" + new URL("wbtc-white.svg", import.meta.url).href;
const PAXG = "" + new URL("paxg-color.svg", import.meta.url).href;
const PAXG_GREY = "" + new URL("paxg-white.svg", import.meta.url).href;
const logo$1 = "_logo_gbled_1";
const swissOpenSource = "_swissOpenSource_gbled_7";
const large$2 = "_large_gbled_12";
const style$15 = {
  logo: logo$1,
  swissOpenSource,
  large: large$2
};
const BitBox = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBoxLogo, alt: "BitBox", className: style$15.logo });
const BitBox02$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBox02Logo, alt: "BitBox02", className: style$15.logo });
const BitBox02Inverted = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBox02InvertedLogo, alt: "BitBox02", className: style$15.logo });
const AppLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: AppLogoImg, alt: "BitBox", className: style$15.logo });
const AppLogoInverted = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: AppLogoInvertedImg, alt: "BitBox", className: style$15.logo });
const SwissMadeOpenSource = ({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: SwissOpenSourceLight, alt: "Swiss Made Open Source", className: `${style$15.swissOpenSource} ${props.large ? style$15.large : ""} ${className ? className : ""}` });
const SwissMadeOpenSourceDark = ({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: SwissOpenSourceDark, alt: "Swiss Made Open Source", className: `${style$15.swissOpenSource} ${props.large ? style$15.large : ""} ${className ? className : ""}` });
const logoMap = {
  "btc": [BTC, BTC_GREY],
  "tbtc": [BTC, BTC_GREY],
  "rbtc": [BTC, BTC_GREY],
  "ltc": [LTC, LTC_GREY],
  "tltc": [LTC, LTC_GREY],
  "eth": [ETH, ETH_GREY],
  "goeth": [ETH, ETH_GREY],
  "sepeth": [ETH, ETH_GREY],
  "erc20Test": [ETH, ETH_GREY],
  "eth-erc20-usdt": [USDT, USDT_GREY],
  "eth-erc20-usdc": [USDC, USDC_GREY],
  "eth-erc20-dai0x6b17": [DAI, DAI_GREY],
  "eth-erc20-link": [LINK, LINK_GREY],
  "eth-erc20-bat": [BAT, BAT_GREY],
  "eth-erc20-mkr": [MKR, MKR_GREY],
  "eth-erc20-zrx": [ZRX, ZRX_GREY],
  "eth-erc20-wbtc": [WBTC, WBTC_GREY],
  "eth-erc20-paxg": [PAXG, PAXG_GREY]
};
function Logo({ coinCode, active: active2, stacked, ...rest }) {
  if (!logoMap[coinCode]) {
    console.error("logo undefined for ", coinCode);
    return null;
  }
  if (!stacked) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: active2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][1], ...rest }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest })
  ] }) });
}
const point2bitbox02 = "_point2bitbox02_1vb0x_1";
const caret$1 = "_caret_1vb0x_5";
const bitbox02 = "_bitbox02_1vb0x_10";
const style$14 = {
  point2bitbox02,
  caret: caret$1,
  bitbox02
};
const PointToBitBox02 = () => {
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$14.point2bitbox02, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { className: style$14.caret }),
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: style$14.bitbox02 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: style$14.bitbox02 })
  ] });
};
const overlay$3 = "_overlay_1u8gr_1";
const activeOverlay$1 = "_activeOverlay_1u8gr_15";
const modal$1 = "_modal_1u8gr_19";
const header$9 = "_header_1u8gr_31";
const title$b = "_title_1u8gr_31";
const contentContainer$1 = "_contentContainer_1u8gr_37";
const small$2 = "_small_1u8gr_42";
const medium$1 = "_medium_1u8gr_47";
const large$1 = "_large_1u8gr_53";
const centered$1 = "_centered_1u8gr_68";
const closeButton$3 = "_closeButton_1u8gr_78";
const slim$1 = "_slim_1u8gr_105";
const padded$1 = "_padded_1u8gr_109";
const content$5 = "_content_1u8gr_37";
const actions$1 = "_actions_1u8gr_117";
const confirmationLabel$1 = "_confirmationLabel_1u8gr_135";
const confirmationLabelNumber$1 = "_confirmationLabelNumber_1u8gr_144";
const disabledLabel$1 = "_disabledLabel_1u8gr_150";
const noStep$1 = "_noStep_1u8gr_155";
const confirmationInstructions$1 = "_confirmationInstructions_1u8gr_159";
const confirm$1 = "_confirm_1u8gr_135";
const image$1 = "_image_1u8gr_179";
const modalContent$1 = "_modalContent_1u8gr_184";
const detail$2 = "_detail_1u8gr_193";
const description$1 = "_description_1u8gr_217";
const buttons$4 = "_buttons_1u8gr_221";
const dialogButtons$1 = "_dialogButtons_1u8gr_233";
const closingOverlay = "_closingOverlay_1u8gr_244";
const open$1 = "_open_1u8gr_268";
const style$13 = {
  overlay: overlay$3,
  activeOverlay: activeOverlay$1,
  modal: modal$1,
  header: header$9,
  title: title$b,
  contentContainer: contentContainer$1,
  small: small$2,
  medium: medium$1,
  large: large$1,
  centered: centered$1,
  closeButton: closeButton$3,
  slim: slim$1,
  padded: padded$1,
  content: content$5,
  actions: actions$1,
  confirmationLabel: confirmationLabel$1,
  confirmationLabelNumber: confirmationLabelNumber$1,
  disabledLabel: disabledLabel$1,
  noStep: noStep$1,
  confirmationInstructions: confirmationInstructions$1,
  confirm: confirm$1,
  image: image$1,
  modalContent: modalContent$1,
  detail: detail$2,
  description: description$1,
  buttons: buttons$4,
  dialogButtons: dialogButtons$1,
  closingOverlay,
  open: open$1
};
class Dialog extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.modalContent = reactExports.createRef();
    this.state = {
      currentTab: 0,
      renderDialog: false
    };
    this.handleFocus = (e3) => {
      const input2 = e3.target;
      const index2 = input2.getAttribute("index");
      this.setState({ currentTab: Number(index2) });
    };
    this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables) {
          c2.classList.add("tabbable");
          c2.setAttribute("index", focusables.indexOf(c2).toString());
          c2.addEventListener("focus", this.handleFocus);
        }
        document.addEventListener("keydown", this.handleKeyDown);
      }
    };
    this.focusFirst = () => {
      const focusables = this.focusableChildren;
      if (focusables.length && focusables[0].getAttribute("autofocus") !== "false") {
        focusables[0].focus();
      }
    };
    this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    };
    this.deactivateModal = (fireOnCloseProp) => {
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      this.overlay.current.classList.remove(style$13.closingOverlay);
      this.setState({ currentTab: 0, renderDialog: false }, () => {
        document.removeEventListener("keydown", this.handleKeyDown);
        if (this.props.onClose && fireOnCloseProp) {
          this.props.onClose();
        }
      });
    };
    this.handleKeyDown = (e3) => {
      const { disableEscape } = this.props;
      const isEsc = e3.keyCode === 27;
      const isTab = e3.keyCode === 9;
      if (!disableEscape && isEsc) {
        this.deactivate(true);
      } else if (isTab) {
        e3.preventDefault();
      }
      if (isTab && e3.shiftKey) {
        this.updateIndex(false);
      } else if (isTab) {
        this.updateIndex(true);
      }
    };
    this.deactivate = (fireOnCloseProp) => {
      var _a;
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
      this.overlay.current.classList.remove(style$13.activeOverlay);
      this.overlay.current.classList.add(style$13.closingOverlay);
      (_a = this.modal.current) == null ? void 0 : _a.classList.remove(style$13.open);
      const onTransitionEnd = (event2) => {
        var _a2;
        if (event2.target === this.modal.current) {
          this.deactivateModal(fireOnCloseProp);
          (_a2 = this.modal.current) == null ? void 0 : _a2.removeEventListener("transitionend", onTransitionEnd);
        }
      };
      const hasTransition = parseFloat(window.getComputedStyle(this.modal.current).transitionDuration) > 0;
      if (hasTransition) {
        this.modal.current.addEventListener("transitionend", onTransitionEnd);
        this.timerId = setTimeout(() => this.deactivateModal(fireOnCloseProp), 400);
      } else {
        this.deactivateModal(fireOnCloseProp);
      }
    };
    this.activate = () => {
      this.setState({ renderDialog: true }, () => {
        if (!this.modal.current || !this.overlay.current) {
          return;
        }
        if (this.timerId) {
          clearTimeout(this.timerId);
        }
        this.overlay.current.classList.add(style$13.activeOverlay);
        this.timerId = setTimeout(() => {
          var _a;
          (_a = this.modal.current) == null ? void 0 : _a.classList.add(style$13.open);
        }, 10);
        this.focusWithin();
        this.focusFirst();
      });
    };
  }
  componentDidMount() {
    if (this.props.open) {
      this.activate();
    }
  }
  componentDidUpdate(prevProps) {
    const { open: open2 } = this.props;
    if (open2 && !prevProps.open) {
      this.activate();
      return;
    }
    if (!open2 && prevProps.open) {
      this.deactivate(false);
      return;
    }
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state;
    const focusables = Array.from(this.focusableChildren);
    const arr = isNext ? focusables : focusables.reverse();
    const current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled"));
    next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2;
    return isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props;
    const { renderDialog } = this.state;
    const isSmall = small2 ? style$13.small : "";
    const isMedium = medium2 ? style$13.medium : "";
    const isLarge = large2 ? style$13.large : "";
    const isSlim = slim2 ? style$13.slim : "";
    const isCentered = centered2 && !onClose ? style$13.centered : "";
    if (!renderDialog) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$13.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$13.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$13.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$13.closeButton, onClick: () => {
              this.deactivate(true);
            }, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$13.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
}
function DialogButtons$1({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.dialogButtons, children: children2 });
}
const defaultLanguages = [
  { code: "ar", display: "" },
  { code: "bg", display: "" },
  { code: "cs", display: "etina" },
  { code: "de", display: "Deutsch" },
  { code: "en", display: "English" },
  { code: "es", display: "Espaol" },
  { code: "fa", display: "" },
  { code: "fr", display: "Franais" },
  { code: "he", display: "" },
  { code: "hi", display: " " },
  { code: "it", display: "Italiano" },
  { code: "ja", display: "" },
  { code: "ms", display: "Bahasa Melayu" },
  { code: "nl", display: "Nederlands" },
  { code: "pt", display: "Portugus" },
  { code: "ru", display: "" },
  { code: "sl", display: "Slovenina" },
  { code: "tr", display: "Trke" },
  { code: "zh", display: "" }
];
const link$5 = "_link_28asd_1";
const language = "_language_28asd_20";
const selected = "_selected_28asd_38";
const checked = "_checked_28asd_46";
const style$12 = {
  link: link$5,
  language,
  selected,
  checked
};
const getSelectedIndex = (languages, i18n) => {
  const lang = i18n.language;
  let index2 = languages.findIndex(({ code }) => code === lang);
  if (index2 === -1 && lang.indexOf("-") > 0) {
    const tag = lang.slice(0, lang.indexOf("-"));
    index2 = languages.findIndex(({ code }) => code === tag);
  }
  if (index2 === -1 && lang.indexOf("_") > 0) {
    const tag = lang.slice(0, lang.indexOf("_"));
    index2 = languages.findIndex(({ code }) => code === tag);
  }
  if (index2 === -1) {
    return languages.findIndex(({ code }) => code === "en") || 0;
  }
  return index2;
};
const LanguageSwitch = ({ languages }) => {
  const { t: t2, i18n } = useTranslation();
  const allLanguages = languages || defaultLanguages;
  const [selectedIndex, setSelectedIndex] = reactExports.useState(getSelectedIndex(allLanguages, i18n));
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const changeLanguage = (langCode, index2) => {
    setSelectedIndex(index2);
    setActiveDialog(false);
    i18n.changeLanguage(langCode);
  };
  if (allLanguages.length === 1) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type: "button",
        title: "Select Language",
        className: style$12.link,
        onClick: () => setActiveDialog(true),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
              ]
            }
          ),
          allLanguages[selectedIndex].code === "en" ? "Other languages" : "English"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { small: true, slim: true, title: t2("language.title"), onClose: () => setActiveDialog(false), open: activeDialog, children: allLanguages.map((language2, i) => {
      const selected2 = selectedIndex === i;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: [style$12.language, selected2 ? style$12.selected : ""].join(" "),
          onClick: () => changeLanguage(language2.code, i),
          "data-testid": `language-selection-${language2.code}`,
          children: [
            language2.display,
            selected2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: style$12.checked,
                xmlns: "http://www.w3.org/2000/svg",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" })
              }
            )
          ]
        },
        language2.code
      );
    }) })
  ] });
};
const getVersion$1 = () => {
  return apiGet("version");
};
const getUpdate = () => {
  return apiGet("update");
};
const Version = () => {
  const { t: t2 } = useTranslation();
  const version = useLoad(getVersion$1);
  if (!version) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
    t2("footer.appVersion"),
    " ",
    version
  ] });
};
const fullscreen = "_fullscreen_zy4hy_1";
const dialog = "_dialog_zy4hy_22";
const fill = "_fill_zy4hy_28";
const inner = "_inner_zy4hy_38";
const verticallyCentered = "_verticallyCentered_zy4hy_46";
const fit = "_fit_zy4hy_50";
const content$4 = "_content_zy4hy_50";
const textCenter = "_textCenter_zy4hy_64";
const header$8 = "_header_zy4hy_112";
const smallHeader = "_smallHeader_zy4hy_133";
const title$a = "_title_zy4hy_158";
const closeButton$2 = "_closeButton_zy4hy_172";
const fullWidth = "_fullWidth_zy4hy_200";
const largeIcon = "_largeIcon_zy4hy_218";
const buttons$3 = "_buttons_zy4hy_243";
const reverseRow = "_reverseRow_zy4hy_250";
const footer$1 = "_footer_zy4hy_310";
const style$11 = {
  fullscreen,
  dialog,
  fill,
  inner,
  verticallyCentered,
  fit,
  content: content$4,
  textCenter,
  "text-center": "_text-center_zy4hy_65",
  "text-left": "_text-left_zy4hy_68",
  header: header$8,
  smallHeader,
  title: title$a,
  closeButton: closeButton$2,
  fullWidth,
  largeIcon,
  buttons: buttons$3,
  reverseRow,
  footer: footer$1
};
const View = ({
  dialog: dialog2 = false,
  fitContent = false,
  fullscreen: fullscreen2,
  children: children2,
  minHeight,
  onClose,
  textCenter: textCenter2,
  verticallyCentered: verticallyCentered2 = false,
  width,
  withBottomBar
}) => {
  const { isDarkMode } = useDarkmode();
  const containerClasses = `${style$11[fullscreen2 ? "fullscreen" : "fill"]} ${verticallyCentered2 ? style$11.verticallyCentered : ""} ${dialog2 ? style$11.dialog : ""}`;
  let classNames2 = style$11.inner;
  if (fitContent) {
    classNames2 += ` ${style$11.fit}`;
  }
  if (textCenter2) {
    classNames2 += ` ${style$11.textCenter}`;
  }
  const inlineStyles = {
    ...minHeight && { minHeight },
    ...width && { width }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames2,
        style: inlineStyles,
        children: children2
      }
    ),
    onClose && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$11.closeButton, onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {}) }),
    withBottomBar && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: style$11.footer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
    ] }) })
  ] });
};
const ViewContent = ({
  children: children2,
  fullWidth: fullWidth2,
  minHeight,
  textAlign,
  withIcon,
  ...props
}) => {
  const align = textAlign ? style$11[`text-${textAlign}`] : "";
  const containerWidth = fullWidth2 ? style$11.fullWidth : "";
  const classes = `${style$11.content} ${containerWidth} ${align}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classes,
      style: minHeight ? { minHeight } : {},
      ...props,
      children: [
        withIcon === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: style$11.largeIcon }),
        children2
      ]
    }
  );
};
const ViewHeader = ({
  children: children2,
  small: small2,
  title: title2,
  withAppLogo
}) => {
  const { isDarkMode } = useDarkmode();
  const headerStyles = small2 ? `${style$11.header} ${style$11.smallHeader}` : style$11.header;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: headerStyles, children: [
    withAppLogo && (isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {})),
    title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$11.title, children: title2 }),
    children2
  ] });
};
const ViewButtons = ({ reverseRow: reverseRow2, children: children2 }) => {
  const classNames2 = `${style$11.buttons} ${reverseRow2 ? style$11.reverseRow : ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
};
const button$4 = "_button_1s0sp_1";
const primary$1 = "_primary_1s0sp_38 _button_1s0sp_1";
const secondary = "_secondary_1s0sp_49 _button_1s0sp_1";
const danger$1 = "_danger_1s0sp_67 _button_1s0sp_1";
const transparent = "_transparent_1s0sp_84 _button_1s0sp_1";
const style$10 = {
  button: button$4,
  primary: primary$1,
  secondary,
  danger: danger$1,
  transparent
};
const ButtonLink = ({
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  disabled: disabled2,
  ...props
}) => {
  const classNames2 = [
    style$10[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  if (disabled2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: classNames2,
        disabled: true,
        children: children2
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Link,
    {
      className: classNames2,
      ...props,
      children: children2
    }
  );
};
const Button = ({
  type: type2 = "button",
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  ...props
}) => {
  const classNames2 = [
    style$10[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: type2,
      className: classNames2,
      ...props,
      children: children2
    }
  );
};
const checkbox = "_checkbox_1m6k1_1";
const success$6 = "_success_1m6k1_33";
const warning$5 = "_warning_1m6k1_37";
const info$3 = "_info_1m6k1_41";
const styles$r = {
  checkbox,
  success: success$6,
  warning: warning$5,
  info: info$3
};
const Checkbox = ({
  disabled: disabled2 = false,
  label: label2,
  id: id2,
  className = "",
  children: children2,
  checkboxStyle = "default",
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$r.checkbox} ${className} ${styles$r[checkboxStyle] || ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      " ",
      children2
    ] })
  ] });
};
const radio$1 = "_radio_198i3_1";
const style$$ = {
  radio: radio$1
};
function Radio({
  disabled: disabled2 = false,
  label: label2,
  id: id2,
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$$.radio, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "radio",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      children2
    ] })
  ] });
}
const field = "_field_d2mb0_1";
const style$_ = {
  field
};
function Field({
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$_.field, ...props, children: children2 });
}
const input = "_input_1dgl0_1";
const isTransparent = "_isTransparent_1dgl0_58";
const errorText = "_errorText_1dgl0_64";
const styles$q = {
  input,
  "align-left": "_align-left_1dgl0_12",
  "align-right": "_align-right_1dgl0_16",
  isTransparent,
  errorText
};
const Input$2 = reactExports.forwardRef(function Input({
  id: id2,
  label: label2 = "",
  error: error3,
  align = "left",
  className = "",
  children: children2,
  transparent: transparent2 = false,
  type: type2 = "text",
  labelSection,
  ...props
}, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    styles$q.input,
    styles$q[`align-${align}`],
    className,
    transparent2 ? styles$q.isTransparent : ""
  ].join(" "), children: [
    label2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: error3 ? styles$q.errorText : "", children: [
        label2,
        error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          ":",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: error3.toString() })
        ] }) : null
      ] }),
      labelSection && labelSection
    ] }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: false,
        type: type2,
        id: id2,
        ref,
        ...props
      }
    ),
    children2
  ] });
});
const label$6 = "_label_53nw1_1";
const style$Z = {
  label: label$6
};
function Label({
  className,
  children: children2,
  id: id2,
  // TODO: change to htmlFor when mirgated away from preact@8.x
  ...props
}) {
  const classes = [style$Z.label, className].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: classes, ...props, children: children2 });
}
const select$5 = "_select_yd5xu_1";
const styles$p = {
  select: select$5
};
const Select$1 = ({
  id: id2,
  label: label2,
  options: options2 = [],
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$p.select, children: [
    label2 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("select", { id: id2, ...props, children: options2.map(({ value, text: text2, disabled: disabled2 = false }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "option",
      {
        value,
        disabled: disabled2,
        children: text2
      },
      `${value}`
    )) })
  ] });
};
let alertUser;
let callback;
const Alert = () => {
  const [active2, setActive] = reactExports.useState(false);
  const [asDialog, setAsDialog] = reactExports.useState(true);
  const [message2, setMessage] = reactExports.useState();
  const { t: t2 } = useTranslation();
  alertUser = (message22, options2 = {}) => {
    const {
      asDialog: asDialog2 = true
    } = options2;
    callback = options2.callback;
    setActive(true);
    setAsDialog(asDialog2);
    setMessage(message22);
  };
  const handleClose = () => {
    if (callback) {
      callback();
    }
    setActive(false);
  };
  return active2 && message2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: () => setActive(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      dialog: asDialog,
      fullscreen: true,
      textCenter: !asDialog,
      verticallyCentered: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "span", markup: message2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: true,
            primary: true,
            onClick: handleClose,
            children: t2("button.ok")
          }
        ) })
      ]
    },
    "alert-overlay"
  ) }) : null;
};
var QWebChannelMessageTypes = {
  signal: 1,
  propertyUpdate: 2,
  init: 3,
  idle: 4,
  debug: 5,
  invokeMethod: 6,
  connectToSignal: 7,
  disconnectFromSignal: 8,
  setProperty: 9,
  response: 10
};
const QWebChannel = function(transport, initCallback) {
  if (typeof transport !== "object" || typeof transport.send !== "function") {
    console.error("The QWebChannel expects a transport object with a send function and onmessage callback property. Given is: transport: " + typeof transport + ", transport.send: " + typeof transport.send);
    return;
  }
  var channel = this;
  this.transport = transport;
  this.send = function(data) {
    if (typeof data !== "string") {
      data = JSON.stringify(data);
    }
    channel.transport.send(data);
  };
  this.transport.onmessage = function(message2) {
    var data = message2.data;
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    switch (data.type) {
      case QWebChannelMessageTypes.signal:
        channel.handleSignal(data);
        break;
      case QWebChannelMessageTypes.response:
        channel.handleResponse(data);
        break;
      case QWebChannelMessageTypes.propertyUpdate:
        channel.handlePropertyUpdate(data);
        break;
      default:
        console.error("invalid message received:", message2.data);
        break;
    }
  };
  this.execCallbacks = {};
  this.execId = 0;
  this.exec = function(data, callback2) {
    if (!callback2) {
      channel.send(data);
      return;
    }
    if (channel.execId === Number.MAX_VALUE) {
      channel.execId = Number.MIN_VALUE;
    }
    if (data.hasOwnProperty("id")) {
      console.error("Cannot exec message with property id: " + JSON.stringify(data));
      return;
    }
    data.id = channel.execId++;
    channel.execCallbacks[data.id] = callback2;
    channel.send(data);
  };
  this.objects = {};
  this.handleSignal = function(message2) {
    var object = channel.objects[message2.object];
    if (object) {
      object.signalEmitted(message2.signal, message2.args);
    } else {
      console.warn("Unhandled signal: " + message2.object + "::" + message2.signal);
    }
  };
  this.handleResponse = function(message2) {
    if (!message2.hasOwnProperty("id")) {
      console.error("Invalid response message received: ", JSON.stringify(message2));
      return;
    }
    channel.execCallbacks[message2.id](message2.data);
    delete channel.execCallbacks[message2.id];
  };
  this.handlePropertyUpdate = function(message2) {
    for (var i in message2.data) {
      var data = message2.data[i];
      var object = channel.objects[data.object];
      if (object) {
        object.propertyUpdate(data.signals, data.properties);
      } else {
        console.warn("Unhandled property update: " + data.object + "::" + data.signal);
      }
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  };
  this.debug = function(message2) {
    channel.send({ type: QWebChannelMessageTypes.debug, data: message2 });
  };
  channel.exec({ type: QWebChannelMessageTypes.init }, function(data) {
    for (var objectName in data) {
      new QObject(objectName, data[objectName], channel);
    }
    for (var objectName in channel.objects) {
      channel.objects[objectName].unwrapProperties();
    }
    if (initCallback) {
      initCallback(channel);
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  });
};
function QObject(name, data, webChannel2) {
  this.__id__ = name;
  webChannel2.objects[name] = this;
  this.__objectSignals__ = {};
  this.__propertyCache__ = {};
  var object = this;
  this.unwrapQObject = function(response) {
    if (response instanceof Array) {
      var ret = new Array(response.length);
      for (var i = 0; i < response.length; ++i) {
        ret[i] = object.unwrapQObject(response[i]);
      }
      return ret;
    }
    if (!response || !response["__QObject*__"] || response.id === void 0) {
      return response;
    }
    var objectId = response.id;
    if (webChannel2.objects[objectId])
      return webChannel2.objects[objectId];
    if (!response.data) {
      console.error("Cannot unwrap unknown QObject " + objectId + " without data.");
      return;
    }
    var qObject = new QObject(objectId, response.data, webChannel2);
    qObject.destroyed.connect(function() {
      if (webChannel2.objects[objectId] === qObject) {
        delete webChannel2.objects[objectId];
        var propertyNames = [];
        for (var propertyName in qObject) {
          propertyNames.push(propertyName);
        }
        for (var idx in propertyNames) {
          delete qObject[propertyNames[idx]];
        }
      }
    });
    qObject.unwrapProperties();
    return qObject;
  };
  this.unwrapProperties = function() {
    for (var propertyIdx in object.__propertyCache__) {
      object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);
    }
  };
  function addSignal(signalData, isPropertyNotifySignal) {
    var signalName = signalData[0];
    var signalIndex = signalData[1];
    object[signalName] = {
      connect: function(callback2) {
        if (typeof callback2 !== "function") {
          console.error("Bad callback given to connect to signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        object.__objectSignals__[signalIndex].push(callback2);
        if (!isPropertyNotifySignal && signalName !== "destroyed") {
          webChannel2.exec({
            type: QWebChannelMessageTypes.connectToSignal,
            object: object.__id__,
            signal: signalIndex
          });
        }
      },
      disconnect: function(callback2) {
        if (typeof callback2 !== "function") {
          console.error("Bad callback given to disconnect from signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        var idx = object.__objectSignals__[signalIndex].indexOf(callback2);
        if (idx === -1) {
          console.error("Cannot find connection of signal " + signalName + " to " + callback2.name);
          return;
        }
        object.__objectSignals__[signalIndex].splice(idx, 1);
        if (!isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0) {
          webChannel2.exec({
            type: QWebChannelMessageTypes.disconnectFromSignal,
            object: object.__id__,
            signal: signalIndex
          });
        }
      }
    };
  }
  function invokeSignalCallbacks(signalName, signalArgs) {
    var connections = object.__objectSignals__[signalName];
    if (connections) {
      connections.forEach(function(callback2) {
        callback2.apply(callback2, signalArgs);
      });
    }
  }
  this.propertyUpdate = function(signals, propertyMap) {
    for (var propertyIndex in propertyMap) {
      var propertyValue = propertyMap[propertyIndex];
      object.__propertyCache__[propertyIndex] = propertyValue;
    }
    for (var signalName in signals) {
      invokeSignalCallbacks(signalName, signals[signalName]);
    }
  };
  this.signalEmitted = function(signalName, signalArgs) {
    invokeSignalCallbacks(signalName, this.unwrapQObject(signalArgs));
  };
  function addMethod(methodData) {
    var methodName = methodData[0];
    var methodIdx = methodData[1];
    object[methodName] = function() {
      var args = [];
      var callback2;
      for (var i = 0; i < arguments.length; ++i) {
        var argument = arguments[i];
        if (typeof argument === "function")
          callback2 = argument;
        else if (argument instanceof QObject && webChannel2.objects[argument.__id__] !== void 0)
          args.push({
            "id": argument.__id__
          });
        else
          args.push(argument);
      }
      webChannel2.exec({
        "type": QWebChannelMessageTypes.invokeMethod,
        "object": object.__id__,
        "method": methodIdx,
        "args": args
      }, function(response) {
        if (response !== void 0) {
          var result = object.unwrapQObject(response);
          if (callback2) {
            callback2(result);
          }
        }
      });
    };
  }
  function bindGetterSetter(propertyInfo) {
    var propertyIndex = propertyInfo[0];
    var propertyName = propertyInfo[1];
    var notifySignalData = propertyInfo[2];
    object.__propertyCache__[propertyIndex] = propertyInfo[3];
    if (notifySignalData) {
      if (notifySignalData[0] === 1) {
        notifySignalData[0] = propertyName + "Changed";
      }
      addSignal(notifySignalData, true);
    }
    Object.defineProperty(object, propertyName, {
      configurable: true,
      get: function() {
        var propertyValue = object.__propertyCache__[propertyIndex];
        if (propertyValue === void 0) {
          console.warn('Undefined value in property cache for property "' + propertyName + '" in object ' + object.__id__);
        }
        return propertyValue;
      },
      set: function(value) {
        if (value === void 0) {
          console.warn("Property setter for " + propertyName + " called with undefined value!");
          return;
        }
        object.__propertyCache__[propertyIndex] = value;
        var valueToSend = value;
        if (valueToSend instanceof QObject && webChannel2.objects[valueToSend.__id__] !== void 0)
          valueToSend = { "id": valueToSend.__id__ };
        webChannel2.exec({
          "type": QWebChannelMessageTypes.setProperty,
          "object": object.__id__,
          "property": propertyIndex,
          "value": valueToSend
        });
      }
    });
  }
  data.methods.forEach(addMethod);
  data.properties.forEach(bindGetterSetter);
  data.signals.forEach(function(signal) {
    addSignal(signal, false);
  });
  for (var name in data.enums) {
    object[name] = data.enums[name];
  }
}
const debug = false;
function runningInQtWebEngine() {
  return typeof window.qt !== "undefined";
}
function runningInAndroid() {
  return typeof window.android !== "undefined";
}
function runningOnMobile() {
  return runningInAndroid();
}
let webChannel = null;
let queryID$1 = 0;
const queryPromises$1 = {};
const currentListeners$2 = [];
async function initTransport() {
  if (!runningInQtWebEngine()) {
    throw new Error("Must be running in Qt");
  }
  if (webChannel) {
    return webChannel;
  }
  const initWebChannel = function(channel) {
    channel.objects.backend.gotResponse.connect((queryID2, response) => {
      queryPromises$1[queryID2].resolve(JSON.parse(response));
      delete queryPromises$1[queryID2];
    });
    channel.objects.backend.pushNotify.connect((msg) => {
      currentListeners$2.forEach((listener) => listener(JSON.parse(msg)));
    });
    webChannel = channel;
  };
  new QWebChannel(window.qt.webChannelTransport, initWebChannel);
  while (!webChannel) {
    await new Promise((r2) => setTimeout(r2, 1));
  }
  return webChannel;
}
function call(query) {
  return new Promise((resolve, reject2) => {
    initTransport().then((channel) => {
      queryID$1++;
      queryPromises$1[queryID$1] = { resolve, reject: reject2 };
      channel.objects.backend.call(queryID$1, query);
    });
  });
}
function qtSubscribePushNotifications(msgCallback) {
  currentListeners$2.push(msgCallback);
  return () => {
    if (!currentListeners$2.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners$2.indexOf(msgCallback);
    currentListeners$2.splice(index2, 1);
    if (currentListeners$2.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
let queryID = 0;
const queryPromises = {};
const currentListeners$1 = [];
function mobileCall(query) {
  return new Promise((resolve, reject2) => {
    if (runningOnMobile()) {
      if (typeof window.onMobileCallResponse === "undefined") {
        window.onMobileCallResponse = (queryID2, response) => {
          queryPromises[queryID2].resolve(response);
          delete queryPromises[queryID2];
        };
      }
      queryID++;
      queryPromises[queryID] = { resolve, reject: reject2 };
      window.android.call(queryID, query);
    } else {
      reject2();
    }
  });
}
function mobileSubscribePushNotifications(msgCallback) {
  if (typeof window.onMobilePushNotification === "undefined") {
    window.onMobilePushNotification = (msg) => {
      currentListeners$1.forEach((listener) => listener(msg));
    };
  }
  currentListeners$1.push(msgCallback);
  return () => {
    if (!currentListeners$1.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners$1.indexOf(msgCallback);
    currentListeners$1.splice(index2, 1);
    if (currentListeners$1.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
function extConfig(key, defaultValue) {
  if (key.startsWith("{{ ") && key.endsWith(" }}")) {
    return defaultValue;
  }
  return key;
}
const apiPort = extConfig("{{ API_PORT }}", "8082");
const apiToken = extConfig("{{ API_TOKEN }}", "");
function isTLS() {
  return document.URL.startsWith("https://");
}
function apiURL(endpoint) {
  return (isTLS() ? "https://" : "http://") + "localhost:" + apiPort + "/api/" + endpoint;
}
function handleError(endpoint) {
  return function(json) {
    return new Promise((resolve, reject2) => {
      if (json && json.error) {
        if (json.error.indexOf("hidapi: unknown failure") !== -1) {
          return;
        }
        console.error("error from endpoint", endpoint, json);
        alertUser(instance.t("genericError"));
        reject2(json.error);
        return;
      }
      resolve(json);
    });
  };
}
function apiGet(endpoint) {
  if (runningInQtWebEngine()) {
    return call(JSON.stringify({
      method: "GET",
      endpoint
    }));
  }
  if (runningOnMobile()) {
    return mobileCall(JSON.stringify({
      method: "GET",
      endpoint
    }));
  }
  return fetch(apiURL(endpoint), {
    method: "GET"
  }).then((response) => response.json()).then(handleError(endpoint));
}
function apiPost(endpoint, body) {
  if (runningInQtWebEngine()) {
    return call(JSON.stringify({
      method: "POST",
      endpoint,
      body: JSON.stringify(body)
    }));
  }
  if (runningOnMobile()) {
    return mobileCall(JSON.stringify({
      method: "POST",
      endpoint,
      body: JSON.stringify(body)
    }));
  }
  return fetch(apiURL(endpoint), {
    method: "POST",
    body: JSON.stringify(body)
  }).then((response) => response.json()).then(handleError(endpoint));
}
let socket;
const currentListeners = [];
function webSubscribePushNotifications(msgCallback) {
  currentListeners.push(msgCallback);
  if (!socket) {
    socket = new WebSocket((isTLS() ? "wss://" : "ws://") + "localhost:" + apiPort + "/api/events");
    socket.onopen = function() {
      if (socket) {
        socket.send("Authorization: Basic " + apiToken);
      }
    };
    socket.onerror = function(event2) {
      console.error("websocket error", event2);
    };
    socket.onmessage = function(event2) {
      const payload = JSON.parse(event2.data);
      currentListeners.forEach((listener) => listener(payload));
    };
    socket.onclose = function() {
      currentListeners.forEach((listener) => listener({ subject: "backend/connected", action: "replace", object: false }));
    };
  }
  return () => {
    if (!currentListeners.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners.indexOf(msgCallback);
    currentListeners.splice(index2, 1);
    if (currentListeners.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
function apiWebsocket(msgCallback) {
  if (runningInQtWebEngine()) {
    return qtSubscribePushNotifications(msgCallback);
  }
  if (runningOnMobile()) {
    return mobileSubscribePushNotifications(msgCallback);
  }
  return webSubscribePushNotifications(msgCallback);
}
const subscriptions$1 = {};
function handleEvent(payload) {
  if ("subject" in payload && typeof payload.subject === "string") {
    if (subscriptions$1[payload.subject]) {
      for (const observer of subscriptions$1[payload.subject]) {
        observer(payload);
      }
    }
  }
}
let subscribed = null;
function apiSubscribe(subject, observer) {
  if (!subscribed) {
    subscribed = apiWebsocket(handleEvent);
  }
  let observers = subscriptions$1[subject];
  if (observers === void 0) {
    observers = [];
    subscriptions$1[subject] = observers;
  }
  observers.push(observer);
  return () => {
    if (!observers.includes(observer)) {
      console.warn("!observers.includes(observer)");
    }
    const index2 = observers.indexOf(observer);
    observers.splice(index2, 1);
    if (observers.includes(observer)) {
      console.warn("observers.includes(observer)");
    }
  };
}
function subscribeEndpoint(endpoint, cb2) {
  return apiSubscribe(endpoint, (event2) => {
    switch (event2.action) {
      case "replace":
        cb2(event2.object);
        break;
      case "reload":
        apiGet(event2.subject).then((object) => cb2(object)).catch(console.error);
        break;
      default:
        throw new Error(`Event: ${event2} not supported`);
    }
  });
}
const backendConnected = (cb2) => {
  return subscribeEndpoint("backend/connected", cb2);
};
const getSupportedCoins = () => {
  return apiGet("supported-coins");
};
const setAccountActive = (accountCode, active2) => {
  return apiPost("set-account-active", { accountCode, active: active2 });
};
const setTokenActive = (accountCode, tokenCode, active2) => {
  return apiPost("set-token-active", { accountCode, tokenCode, active: active2 });
};
const renameAccount = (accountCode, name) => {
  return apiPost("rename-account", { accountCode, name });
};
const reinitializeAccounts = () => {
  return apiPost("accounts/reinitialize");
};
const getTesting = () => {
  return apiGet("testing");
};
const getQRCode = (data) => {
  return () => {
    return apiGet(`qr?data=${encodeURIComponent(data)}`);
  };
};
const getDefaultConfig = () => {
  return apiGet("config/default");
};
const socksProxyCheck = (proxyAddress) => {
  return apiPost("socksproxy/check", proxyAddress);
};
const syncConnectKeystore = () => {
  return (cb2) => {
    return subscribeEndpoint("connect-keystore", (obj) => {
      cb2(obj);
    });
  };
};
const cancelConnectKeystore = () => {
  return apiPost("cancel-connect-keystore");
};
const setWatchonly = (rootFingerprint, watchonly) => {
  return apiPost("set-watchonly", { rootFingerprint, watchonly });
};
const authenticate = (force = false) => {
  return apiPost("authenticate", force);
};
const forceAuth = () => {
  return apiPost("force-auth");
};
const subscribeAuth = (cb2) => subscribeEndpoint("auth", cb2);
const onAuthSettingChanged = () => {
  return apiPost("on-auth-setting-changed");
};
const subscribeKeystores = (cb2) => {
  return subscribeEndpoint("keystores", cb2);
};
const getKeystores = () => {
  return apiGet("keystores");
};
const message$1 = "_message_ncb43_1";
const small$1 = "_small_ncb43_15";
const success$5 = "_success_ncb43_28 _message_ncb43_1";
const info$2 = "_info_ncb43_34 _message_ncb43_1";
const warning$4 = "_warning_ncb43_40 _message_ncb43_1";
const error$1 = "_error_ncb43_46 _message_ncb43_1";
const styles$o = {
  message: message$1,
  small: small$1,
  success: success$5,
  info: info$2,
  warning: warning$4,
  error: error$1
};
function Message({
  hidden,
  small: small2,
  type: type2 = "message",
  children: children2
}) {
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$o[type2]} ${small2 ? styles$o.small : ""}`, children: children2 });
}
const AppContext = reactExports.createContext({});
const children$1 = "_children_byj6x_1";
const container$o = "_container_byj6x_22";
const fixed = "_fixed_byj6x_26";
const disabled$2 = "_disabled_byj6x_34";
const forceHidden = "_forceHidden_byj6x_38";
const sidebarToggler = "_sidebarToggler_byj6x_38";
const guideIcon = "_guideIcon_byj6x_42";
const guideIconContainer = "_guideIconContainer_byj6x_57";
const header$7 = "_header_byj6x_62";
const narrow = "_narrow_byj6x_76";
const title$9 = "_title_byj6x_99";
const hideSidebarToggler = "_hideSidebarToggler_byj6x_125";
const style$Y = {
  children: children$1,
  container: container$o,
  fixed,
  disabled: disabled$2,
  forceHidden,
  sidebarToggler,
  guideIcon,
  guideIconContainer,
  header: header$7,
  narrow,
  title: title$9,
  hideSidebarToggler
};
const Header = ({
  narrow: narrow2,
  title: title2,
  hideSidebarToggler: hideSidebarToggler2,
  children: children2
}) => {
  const { t: t2 } = useTranslation();
  const { guideShown, guideExists, toggleGuide, toggleSidebar, sidebarStatus } = reactExports.useContext(AppContext);
  const toggle2 = (e3) => {
    e3.preventDefault();
    if (!guideShown) {
      toggleGuide();
    }
    return false;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$Y.container, sidebarStatus ? style$Y[sidebarStatus] : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$Y.header, narrow2 ? style$Y.narrow : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$Y.sidebarToggler} ${hideSidebarToggler2 ? style$Y.hideSidebarToggler : ""}`, onClick: toggleSidebar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, { className: "show-in-lightmode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuLight, { className: "show-in-darkmode" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$Y.title, children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Y.children, children: [
      children2,
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$Y.guideIconContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", onClick: toggle2, className: [style$Y.guideIcon, guideShown ? style$Y.disabled : ""].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GuideActive, {}),
        t2("guide.toggle.open")
      ] }) })
    ] })
  ] }) });
};
const main$1 = "_main_1ntet_1";
const style$X = {
  main: main$1
};
const Main = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: style$X.main, children: children2 });
};
const columnAsCard = "_columnAsCard_1rob5_1";
const column$2 = "_column_1rob5_1";
const columnButtons = "_columnButtons_1rob5_10";
const columnButtonsInline = "_columnButtonsInline_1rob5_10";
const left$1 = "_left_1rob5_29";
const center = "_center_1rob5_33";
const grid = "_grid_1rob5_47";
const style$W = {
  columnAsCard,
  column: column$2,
  columnButtons,
  columnButtonsInline,
  left: left$1,
  center,
  grid,
  "grid-columns-1": "_grid-columns-1_1rob5_53",
  "grid-columns-2": "_grid-columns-2_1rob5_56"
};
const Grid = ({
  children: children2,
  col = "2",
  textAlign
}) => {
  const styles2 = `
    ${style$W.grid}
    ${style$W[`grid-columns-${col}`]}
    ${textAlign !== void 0 ? style$W[textAlign] : ""}
  `;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: styles2, children: children2 });
};
const Column = ({
  asCard,
  children: children2,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$W.column} ${asCard ? style$W.columnAsCard : ""} ${className || ""}`, children: children2 });
};
const ColumnButtons = ({
  children: children2,
  className = "",
  inline
}) => {
  const classNames2 = `${style$W.columnButtons} ${inline ? style$W.columnButtonsInline : ""} ${className}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
};
const footer = "_footer_19w3c_1";
const style$V = {
  footer
};
function Footer({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: [style$V.footer, "flex flex-row flex-items-center flex-end"].join(" "), children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
  ] });
}
const contentWithGuide = "_contentWithGuide_1gscs_1";
const container$n = "_container_1gscs_8";
const styles$n = {
  contentWithGuide,
  container: container$n
};
const GuideWrapper = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.contentWithGuide, children: children2 });
};
const GuidedContent = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.container, children: children2 });
};
const steps = "_steps_1l429_6";
const step = "_step_1l429_6";
const dot = "_dot_1l429_38";
const line$1 = "_line_1l429_72";
const finish = "_finish_1l429_76";
const wait = "_wait_1l429_81";
const process$1 = "_process_1l429_97";
const content$3 = "_content_1l429_110";
const style$U = {
  steps,
  step,
  dot,
  line: line$1,
  finish,
  wait,
  process: process$1,
  content: content$3
};
const Steps = ({
  current,
  children: children2
}) => {
  let childrens = React.Children.toArray(children2).filter(React.isValidElement);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.steps, children: childrens.filter((child) => !child.props.hidden).map((child, step2) => {
    if (!child) {
      return null;
    }
    const status2 = step2 === current ? "process" : step2 < current ? "finish" : "wait";
    const line2 = step2 > 0;
    return reactExports.cloneElement(child, {
      step: step2 + 1,
      line: line2,
      status: status2
    });
  }) });
};
function Step({
  children: children2,
  hidden = false,
  line: line2,
  status: status2 = "wait"
}) {
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$U.step} ${style$U[status2]} ${line2 ? style$U.line : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.dot }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.content, children: children2 })
  ] });
}
const CoinDropDown = ({
  onChange: onChange2,
  supportedCoins,
  value
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select$1,
    {
      autoFocus: true,
      options: [
        {
          text: t2("buy.info.selectPlaceholder"),
          disabled: true,
          value: "choose"
        },
        ...supportedCoins.map(({ coinCode, name, canAddAccount }) => ({
          value: coinCode,
          text: name,
          disabled: !canAddAccount
        }))
      ],
      onInput: (e3) => onChange2(supportedCoins.find((c2) => {
        return c2.coinCode === e3.target.value;
      })),
      value,
      id: "coinCodeDropDown"
    }
  );
};
const notifyUser = (text2) => {
  return apiPost("notify-user", { text: text2 });
};
const open = (href) => {
  return apiPost("open", href);
};
const link$4 = "_link_1o1mh_1";
const style$T = {
  link: link$4
};
const A$3 = ({
  href,
  icon: icon2,
  className,
  children: children2,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$T.link} ${className || ""}`,
      title: props.title || href,
      onClick: (e3) => {
        e3.preventDefault();
        open(href).catch(console.error);
      },
      tabIndex: 0,
      ...props,
      children: [
        icon2 ? icon2 : null,
        children2
      ]
    }
  );
};
const overlay$2 = "_overlay_14an4_1";
const close$2 = "_close_14an4_13";
const wrapper = "_wrapper_14an4_29";
const guide = "_guide_14an4_33";
const header$6 = "_header_14an4_44";
const content$2 = "_content_14an4_62";
const show$1 = "_show_14an4_83";
const entry$1 = "_entry_14an4_87";
const entryTitle = "_entryTitle_14an4_91";
const entryToggle = "_entryToggle_14an4_99";
const entryTitleText = "_entryTitleText_14an4_109";
const entryContent = "_entryContent_14an4_113";
const expanded = "_expanded_14an4_121";
const link$3 = "_link_14an4_125";
const guideWrapper = "_guideWrapper_14an4_135";
const style$S = {
  overlay: overlay$2,
  close: close$2,
  wrapper,
  guide,
  header: header$6,
  content: content$2,
  show: show$1,
  entry: entry$1,
  entryTitle,
  entryToggle,
  entryTitleText,
  entryContent,
  expanded,
  link: link$3,
  guideWrapper
};
const Entry = (props) => {
  const [shown, setShown] = reactExports.useState(props.shown || false);
  const toggle2 = () => {
    setShown((shown2) => !shown2);
  };
  const entry2 = props.entry;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entry, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entryTitle, onClick: toggle2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.entryToggle, children: shown ? "" : "+" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.entryTitleText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: entry2.title }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.entryContent, shown ? style$S.expanded : ""].join(" "), children: shown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      entry2.text.trim().split("\n").map((p2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: p2 }, idx)),
      entry2.link && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        A$3,
        {
          className: style$S.link,
          "data-testid": "link",
          href: entry2.link.url,
          children: entry2.link.text
        }
      ) }),
      props.children
    ] }) : null })
  ] });
};
const Guide = ({ children: children2 }) => {
  const { guideShown, toggleGuide, setGuideExists } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => {
    setGuideExists(true);
    return () => {
      setGuideExists(false);
    };
  }, [setGuideExists]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.overlay, guideShown && style$S.show].join(" "), onClick: toggleGuide }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.guide, guideShown && style$S.show].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.header, "flex flex-row flex-between flex-items-center"].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("guide.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: style$S.close, onClick: toggleGuide, children: [
          t2("guide.toggle.close"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.content, children: [
        children2,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entry, children: [
          t2("guide.appendix.text"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { className: style$S.link, href: "https://bitbox.swiss/support/", children: t2("guide.appendix.link") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
        ] })
      ] })
    ] })
  ] });
};
function findAccount(accounts, accountCode) {
  return accounts.find(({ code }) => accountCode === code);
}
function getCryptoName(cryptoLabel, account2) {
  if (account2 && isBitcoinOnly(account2.coinCode)) {
    return "Bitcoin";
  }
  return cryptoLabel;
}
function isBitcoinOnly(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return true;
    default:
      return false;
  }
}
const isBitcoinCoin = (coin) => coin === "BTC" || coin === "TBTC" || coin === "sat" || coin === "tsat";
function isBitcoinBased(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
    case "ltc":
    case "tltc":
      return true;
    default:
      return false;
  }
}
function isEthereumBased(coinCode) {
  return coinCode === "eth" || coinCode === "goeth" || coinCode === "sepeth" || coinCode.startsWith("eth-erc20-");
}
function getCoinCode(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return "btc";
    case "ltc":
    case "tltc":
      return "ltc";
    case "eth":
    case "goeth":
    case "sepeth":
      return "eth";
  }
}
function getScriptName(scriptType) {
  switch (scriptType) {
    case "p2pkh":
      return "Legacy (P2PKH)";
    case "p2wpkh-p2sh":
      return "Wrapped Segwit (P2WPKH-P2SH)";
    case "p2wpkh":
      return "Native segwit (bech32, P2WPKH)";
    case "p2tr":
      return "Taproot (bech32m, P2TR)";
  }
}
function customFeeUnit$1(coinCode) {
  if (isBitcoinBased(coinCode)) {
    return "sat/vB";
  }
  if (isEthereumBased(coinCode)) {
    return "Gwei";
  }
  return "";
}
function getAccountsByKeystore(accounts) {
  return Object.values(accounts.reduce((acc, account2) => {
    const key = account2.keystore.rootFingerprint;
    if (!acc[key]) {
      acc[key] = {
        keystore: account2.keystore,
        accounts: []
      };
    }
    acc[key].accounts.push(account2);
    return acc;
  }, {}));
}
function isAmbiguiousName(name, accounts) {
  return accounts.filter((keystore2) => keystore2.keystore.name === name).length > 1;
}
const getCoinsLink$1 = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/coins/";
    case "es":
      return "https://bitbox.swiss/es/monedas/";
    default:
      return "https://bitbox.swiss/coins/";
  }
};
const AddAccountGuide = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    !hasOnlyBTCAccounts && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.accounts.supportedCoins.link.text"),
          url: getCoinsLink$1()
        },
        text: t2("guide.accounts.supportedCoins.text"),
        title: t2("guide.accounts.supportedCoins.title")
      } }, "supportedCoins"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
};
let navigate;
const route = (route2, replace2) => {
  navigate == null ? void 0 : navigate(route2, { replace: replace2 });
};
const RouterWatcher = () => {
  navigate = useNavigate();
  const { setActiveSidebar } = reactExports.useContext(AppContext);
  const { pathname } = useLocation();
  reactExports.useEffect(() => {
    setActiveSidebar(false);
  }, [pathname, setActiveSidebar]);
  return null;
};
const getAccounts = () => {
  return apiGet("accounts");
};
const getAccountsBalance = () => {
  return apiGet("accounts/balance");
};
const getAccountsTotalBalance = () => {
  return apiGet("accounts/total-balance");
};
const getEthAccountCodeAndNameByAddress = (address2) => {
  return apiPost("accounts/eth-account-code", { address: address2 });
};
const getStatus$2 = (code) => {
  return apiGet(`account/${code}/status`);
};
const allScriptTypes = ["p2pkh", "p2wpkh-p2sh", "p2wpkh", "p2tr"];
const getInfo = (code) => {
  return () => {
    return apiGet(`account/${code}/info`);
  };
};
const init = (code) => {
  return apiPost(`account/${code}/init`);
};
const getSummary = () => {
  return apiGet("account-summary");
};
const getBalance = (code) => {
  return apiGet(`account/${code}/balance`);
};
const postNotesTx = (code, {
  internalTxID,
  note: note2
}) => {
  return apiPost(`account/${code}/notes/tx`, { internalTxID, note: note2 });
};
const proposeTxNote = (code, note2) => {
  return apiPost(`account/${code}/propose-tx-note`, note2);
};
const getTransactionList = (code) => {
  return apiGet(`account/${code}/transactions`);
};
const getTransaction = (code, id2) => {
  return apiGet(`account/${code}/transaction?id=${id2}`);
};
const exportAccount = (code) => {
  return apiPost(`account/${code}/export`);
};
const verifyXPub = (code, signingConfigIndex) => {
  return apiPost(`account/${code}/verify-extended-public-key`, { signingConfigIndex });
};
const getReceiveAddressList = (code) => {
  return () => {
    return apiGet(`account/${code}/receive-addresses`);
  };
};
const sendTx = (code) => {
  return apiPost(`account/${code}/sendtx`);
};
const getFeeTargetList = (code) => {
  return apiGet(`account/${code}/fee-targets`);
};
const verifyAddress$1 = (code, addressID) => {
  return apiPost(`account/${code}/verify-address`, addressID);
};
const getUTXOs = (code) => {
  return apiGet(`account/${code}/utxos`);
};
const hasSecureOutput = (code) => {
  return () => {
    return apiGet(`account/${code}/has-secure-output`);
  };
};
const addAccount = (coinCode, name) => {
  return apiPost("account-add", {
    coinCode,
    name
  });
};
const testRegister = (pin) => {
  return apiPost("test/register", { pin });
};
const connectKeystore = (code) => {
  return apiPost(`account/${code}/connect-keystore`);
};
const ethSignMessage = (code, message2) => {
  return apiPost(`account/${code}/eth-sign-msg`, message2);
};
const ethSignTypedMessage = (code, chainId, data) => {
  return apiPost(`account/${code}/eth-sign-typed-msg`, { chainId, data });
};
const ethSignWalletConnectTx = (code, send2, chainId, tx) => {
  return apiPost(`account/${code}/eth-sign-wallet-connect-tx`, { send: send2, chainId, tx });
};
const signAddress = (format, msg, code) => {
  return apiPost(`account/${code}/sign-address`, { format, msg, code });
};
const manageContainer = "_manageContainer_1n5md_1";
const title$8 = "_title_1n5md_9";
const successCheck = "_successCheck_1n5md_14";
const successMessage = "_successMessage_1n5md_20";
const styles$m = {
  manageContainer,
  title: title$8,
  successCheck,
  successMessage
};
const AddAccount = ({ accounts }) => {
  const [accountCode, setAccountCode] = reactExports.useState();
  const [accountName2, setAccountName] = reactExports.useState("");
  const [coinCode, setCoinCode] = reactExports.useState("choose");
  const [errorMessage2, setErrorMessage] = reactExports.useState();
  const [step2, setStep] = reactExports.useState("select-coin");
  const [supportedCoins, setSupportedCoins] = reactExports.useState([]);
  const [adding, setAdding] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    var _a;
    if (step2 === "choose-name") {
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    }
  }, [step2]);
  const onlyOneSupportedCoin = () => {
    return supportedCoins.length === 1;
  };
  const startProcess = reactExports.useCallback(async () => {
    var _a;
    try {
      const coins2 = await getSupportedCoins();
      const onlyOneCoinIsSupported = coins2.length === 1;
      setCoinCode(onlyOneCoinIsSupported ? coins2[0].coinCode : "choose");
      setStep(onlyOneCoinIsSupported ? "choose-name" : "select-coin");
      setSupportedCoins(coins2);
      if (onlyOneCoinIsSupported) {
        setAccountCode(coins2[0].suggestedAccountName);
      }
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    } catch (err) {
      console.error(err);
    }
  }, []);
  reactExports.useEffect(() => {
    startProcess();
    const unsubscribe2 = subscribeKeystores(() => {
      startProcess();
    });
    return unsubscribe2;
  }, [startProcess]);
  const back = () => {
    switch (step2) {
      case "select-coin":
        route("/settings/manage-accounts");
        break;
      case "choose-name":
        setStep("select-coin");
        setErrorMessage(void 0);
        break;
      case "success":
        setStep("choose-name");
        break;
    }
  };
  const next2 = async (e3) => {
    e3.preventDefault();
    switch (step2) {
      case "select-coin":
        setStep("choose-name");
        break;
      case "choose-name":
        setAdding(true);
        const responseData = await addAccount(coinCode, accountName2);
        setAdding(false);
        if (responseData.success) {
          setAccountCode(responseData.accountCode);
          setErrorMessage(void 0);
          setStep("success");
        } else if (responseData.errorCode) {
          setErrorMessage(t2(`error.${responseData.errorCode}`));
        } else if (responseData.errorMessage) {
          setErrorMessage(t2("unknownError", { errorMessage: responseData.errorMessage }));
        }
        break;
      case "success":
        if (accountCode) {
          route(`/account/${accountCode}`);
        }
        break;
    }
  };
  const renderContent = () => {
    switch (step2) {
      case "select-coin":
        if (supportedCoins.length === 0) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("connectKeystore.promptNoName") });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CoinDropDown,
          {
            onChange: (coin) => {
              setCoinCode(coin.coinCode);
              setAccountName(coin.suggestedAccountName);
            },
            supportedCoins,
            value: coinCode
          }
        );
      case "choose-name":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            autoFocus: true,
            ref: inputRef,
            id: "accountName",
            onInput: (e3) => setAccountName(e3.target.value),
            value: accountName2
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { className: styles$m.successCheck }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleMarkup,
            {
              className: styles$m.successMessage,
              markup: t2("addAccount.success.message", { accountName: accountName2 }),
              tagName: "p"
            }
          )
        ] });
    }
  };
  const getTextFor = (step22) => {
    switch (step22) {
      case "select-coin":
        return {
          titleText: t2("addAccount.selectCoin.title"),
          nextButtonText: t2("addAccount.selectCoin.nextButton")
        };
      case "choose-name":
        return {
          titleText: t2("addAccount.chooseName.title"),
          nextButtonText: t2("addAccount.chooseName.nextButton")
        };
      case "success":
        return {
          titleText: t2("addAccount.success.title"),
          nextButtonText: t2("addAccount.success.nextButton")
        };
    }
  };
  const handleAddAnotherAccount = async () => {
    setAccountCode(void 0);
    setAccountName("");
    setCoinCode("choose");
    setErrorMessage(void 0);
    setStep("select-coin");
    await startProcess();
  };
  const currentStep = [
    ...!onlyOneSupportedCoin() ? ["select-coin"] : [],
    "choose-name",
    "success"
  ].indexOf(step2);
  const { titleText, nextButtonText } = getTextFor(step2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("manageAccounts.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content larger isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: `${styles$m.manageContainer} box larger flex flex-column flex-between`,
          onSubmit: next2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              t2("addAccount.title"),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$m.title, children: titleText })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", hidden: !errorMessage2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: errorMessage2 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: renderContent() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Steps, { current: currentStep, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { hidden: onlyOneSupportedCoin(), children: t2("addAccount.selectCoin.step") }, "select-coin"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.chooseName.step") }, "choose-name"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.success.step") }, "success")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row flex flex-row flex-between m-bottom", style: { flexDirection: "row-reverse" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: step2 === "select-coin" && coinCode === "choose" || step2 === "choose-name" && (accountName2 === "" || adding),
                  primary: true,
                  type: "submit",
                  children: nextButtonText
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: back,
                  hidden: step2 === "success",
                  secondary: true,
                  children: t2("button.back")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleAddAnotherAccount,
                  hidden: step2 !== "success",
                  secondary: true,
                  children: t2("addAccount.success.addAnotherAccount")
                }
              )
            ] })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccountGuide, { accounts })
  ] });
};
const getExchangesByRegion = (code) => {
  return () => {
    return apiGet(`exchange/by-region/${code}`);
  };
};
const getExchangeDeals = () => {
  return apiGet("exchange/deals");
};
const getMoonpayBuyInfo = (code) => {
  return () => {
    return apiGet(`exchange/moonpay/buy-info/${code}`);
  };
};
const verifyAddress = (address2, accountCode) => {
  return apiPost("exchange/pocket/verify-address", { address: address2, accountCode });
};
const getPocketURL = () => {
  return apiGet("exchange/pocket/api-url");
};
const getExchangeBuySupported = (code) => {
  return () => {
    return apiGet(`exchange/buy-supported/${code}`);
  };
};
function BuyGuide({ name, exchange }) {
  const { t: t2 } = useTranslation();
  const pocketLink = {
    text: t2("buy.pocket.data.link"),
    url: "https://pocketbitcoin.com/policy/privacy"
  };
  const moonpayLink = {
    text: t2("buy.info.disclaimer.privacyPolicy"),
    url: "https://www.moonpay.com/privacy_policy"
  };
  const privacyLink = exchange === "pocket" ? pocketLink : moonpayLink;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("buy.info.disclaimer.security.link"),
        url: "https://bitbox.swiss/bitbox02/threat-model/"
      },
      text: t2("buy.info.disclaimer.security.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.security.title")
    }, shown: true }, "guide.buy.security"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: exchange ? privacyLink : void 0,
      text: t2("buy.info.disclaimer.protection.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.protection.title")
    } }, "guide.buy.protection")
  ] });
}
const spinnerContainer$2 = "_spinnerContainer_rthjr_1";
const spinner$2 = "_spinner_rthjr_1";
const spinnerText = "_spinnerText_rthjr_24";
const spinner1 = "_spinner1_rthjr_1";
const spinner2 = "_spinner2_rthjr_1";
const spinner3 = "_spinner3_rthjr_1";
const horizontallyCentered = "_horizontallyCentered_rthjr_59";
const overlay$1 = "_overlay_rthjr_81";
const fadein = "_fadein_rthjr_1";
const togglersContainer = "_togglersContainer_rthjr_98";
const guideToggler = "_guideToggler_rthjr_111";
const toggler = "_toggler_rthjr_98";
const togglerContainer = "_togglerContainer_rthjr_145";
const style$R = {
  spinnerContainer: spinnerContainer$2,
  spinner: spinner$2,
  spinnerText,
  spinner1,
  spinner2,
  spinner3,
  horizontallyCentered,
  overlay: overlay$1,
  fadein,
  togglersContainer,
  guideToggler,
  toggler,
  togglerContainer
};
const SpinnerAnimation = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.spinner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
  ] });
};
const HorizontallyCenteredSpinner = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.horizontallyCentered, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) });
};
const Spinner = ({ text: text2, guideExists }) => {
  const { t: t2 } = useTranslation();
  const { toggleGuide, toggleSidebar } = reactExports.useContext(AppContext);
  const handleKeyDown = (e3) => {
    e3.preventDefault();
    document.activeElement.blur();
  };
  reactExports.useEffect(() => {
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.spinnerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.togglersContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.togglerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.toggler, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, {}) }) }),
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.guideToggler, onClick: toggleGuide, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "4.93", x2: "9.17", y2: "9.17" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "14.83", x2: "19.07", y2: "19.07" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "19.07", y2: "4.93" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "18.36", y2: "5.64" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "19.07", x2: "9.17", y2: "14.83" })
            ]
          }
        ),
        t2("guide.toggle.open")
      ] })
    ] }),
    text2 && text2.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$R.spinnerText, children: line2 }, `${line2}-${i}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.overlay })
  ] });
};
const disclaimerContainer = "_disclaimerContainer_5gxwf_1";
const title$7 = "_title_5gxwf_15";
const disclaimer = "_disclaimer_5gxwf_1";
const table$1 = "_table_5gxwf_52";
const nowrap = "_nowrap_5gxwf_77";
const style$Q = {
  disclaimerContainer,
  title: title$7,
  disclaimer,
  table: table$1,
  nowrap
};
const MoonpayTerms = ({ account: account2, onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipMoonpayDisclaimer: e3.target.checked } });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.title", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.0", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.1", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.details", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$Q.table, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "50px" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.method") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.fee") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$Q.nowrap, children: "1.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_description") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$Q.nowrap, children: "4.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_description") })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.footnote") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.security.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.info.disclaimer.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.protection.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.protection.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/privacy_policy", children: t2("buy.info.disclaimer.privacyPolicy") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const container$m = "_container_yg57j_1";
const iframe$1 = "_iframe_yg57j_12";
const header$5 = "_header_yg57j_18";
const style$P = {
  container: container$m,
  iframe: iframe$1,
  header: header$5
};
const Moonpay = ({ accounts, code }) => {
  const { t: t2 } = useTranslation();
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [height, setHeight] = reactExports.useState(0);
  const { isDarkMode } = useDarkmode();
  const config = useLoad(getConfig);
  const moonpay = useLoad(getMoonpayBuyInfo(code));
  const account2 = findAccount(accounts, code);
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const ref = reactExports.createRef();
  let resizeTimerID;
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipMoonpayDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  if (!account2 || !config) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$P.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$P.container, children: !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        MoonpayTerms,
        {
          account: account2,
          onAgreedTerms: () => setAgreedTerms(true)
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
        moonpay && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(true);
              onResize();
            },
            title: "Moonpay",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$P.iframe,
            allow: "camera; payment",
            src: `${moonpay.url}&colorCode=%235E94BF&theme=${isDarkMode ? "dark" : "light"}`
          }
        )
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "moonpay" })
  ] });
};
function findLowestFee(providers) {
  let allFees = [];
  providers.exchanges.forEach((provider) => {
    provider.deals.forEach((deal) => {
      if (provider.supported) {
        allFees = [...allFees, deal.fee];
      }
    });
  });
  return Math.min(...allFees);
}
function findBestDeal(providers, lowestFee) {
  const hasMultipleSupportedExchanges = providers.exchanges.filter((p2) => p2.supported).length > 1;
  const exchanges = providers.exchanges.map((exchange) => ({
    ...exchange,
    deals: exchange.deals.map((deal) => ({
      ...deal,
      isBestDeal: deal.fee === lowestFee && hasMultipleSupportedExchanges
    }))
  }));
  return { exchanges };
}
function getFormattedName(name) {
  switch (name) {
    case "moonpay":
      return "MoonPay";
    case "pocket":
      return "Pocket";
  }
}
async function getExchangeSupportedAccounts(accounts) {
  const accountsWithFalsyValue = await Promise.all(
    accounts.map(async (account2) => {
      const supported = await getExchangeBuySupported(account2.code)();
      return supported.exchanges.length ? account2 : false;
    })
  );
  return accountsWithFalsyValue.filter((result) => result);
}
const button$3 = "_button_10lad_1";
const styles$l = {
  button: button$3
};
const HideAmountsButton = () => {
  const { t: t2 } = useTranslation();
  const { hideAmounts, toggleHideAmounts } = reactExports.useContext(AppContext);
  const config = useLoad(getConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: config && config.frontend.allowHideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$l.button, onClick: toggleHideAmounts, transparent: true, children: hideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeClosed, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.showAmounts") })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpened, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.hideAmounts") })
  ] }) }) : null });
};
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$6);
  var _useState = reactExports.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = reactExports.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = reactExports.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = reactExports.useCallback(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = reactExports.useCallback(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = reactExports.useCallback(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = reactExports.useCallback(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from$1 = String.fromCharCode;
var assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback2) {
  return array.map(callback2).join("");
}
var line = 1;
var column$1 = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node$1(value, root2, parent, type2, props, children2, length2) {
  return { value, root: root2, parent, type: type2, props, children: children2, line, column: column$1, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column$1--, character === 10)
    column$1 = 1, line--;
  return character;
}
function next$1() {
  character = position < length ? charat(characters, position++) : 0;
  if (column$1++, character === 10)
    column$1 = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token$2(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column$1 = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next$1();
    else
      break;
  return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next$1())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
function delimiter(type2) {
  while (next$1())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next$1())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from$1(type2 === 47 ? type2 : next$1());
}
function identifier(index2) {
  while (!token$2(peek()))
    next$1();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous2 = character2, character2 = next$1()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next$1());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children2, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
}
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children2, callback2) {
  var output2 = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output2 += callback2(children2[i], i, children2, callback2) || "";
  return output2;
}
function stringify(element, index2, children2, callback2) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback2)) ? element.return = element.value + "{" + children2 + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children2, callback2) {
    var output2 = "";
    for (var i = 0; i < length2; i++)
      output2 += collection[i](element, index2, children2, callback2) || "";
    return output2;
  };
}
function rulesheet(callback2) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback2(element);
    }
  };
}
function memoize(fn3) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn3(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$2(character2)) {
      break;
    }
    next$1();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$2(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children2, callback2) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback2);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback2);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback2);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$2 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$3 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$2:
          case e$2:
          case g$1:
          case f$1:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n:
              case t:
              case r$1:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$2(a2) {
  return z$1(a2) === m$2;
}
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$2;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$2;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$2;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$2(a2) || z$1(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$2;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$2;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$2 || a2 === g$1 || a2 === f$1 || a2 === p$2 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n || a2.$$typeof === w$3 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css$2.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null ? void 0 : (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0;
  let height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css4 = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left2;
      y2 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left2 + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref3) => {
      let [firstEntry] = _ref3;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var index$1 = reactExports.useLayoutEffect;
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop = function noop2() {
};
function applyPrefixToName(prefix2, name) {
  if (!name) {
    return prefix2;
  } else if (name[0] === "-") {
    return prefix2 + name;
  } else {
    return prefix2 + "__" + name;
  }
}
function classNames(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix2) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix2, key)));
      }
    }
  }
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray$1(value))
    return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
function normalizedHeight(el2) {
  if (isDocumentElement(el2)) {
    return window.innerHeight;
  }
  return el2.clientHeight;
}
function getScrollTop(el2) {
  if (isDocumentElement(el2)) {
    return window.pageYOffset;
  }
  return el2.scrollTop;
}
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
function getScrollParent(element) {
  var style2 = getComputedStyle(element);
  var excludeStaticParent = style2.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style2.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style2 = getComputedStyle(parent);
    if (excludeStaticParent && style2.position === "static") {
      continue;
    }
    if (overflowRx.test(style2.overflow + style2.overflowY + style2.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback2(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e3) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e3) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w$2 = typeof window !== "undefined" ? window : {};
if (w$2.addEventListener && w$2.removeEventListener) {
  w$2.addEventListener("p", noop, options);
  w$2.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item2) {
  return item2 != null;
}
function isArray$1(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key = _ref22[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref22, unstyled) {
  var _objectSpread2$1;
  var placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "width", "100%"), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ reactExports.createContext(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children2 = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = reactExports.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = reactExports.useRef(null);
  var _useState = reactExports.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  index$1(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children2({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children2 = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children2);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children2 = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children2);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children2 = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children2);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children2 = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children2);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children2 = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = reactExports.useRef(null);
  var cleanupRef = reactExports.useRef(null);
  var _useState5 = reactExports.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = reactExports.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = reactExports.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = reactExports.useCallback(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index$1(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = reactExports.useCallback(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index$1(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = reactExports.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children2);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children2);
};
var valueContainerCSS = function valueContainerCSS2(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children2);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children2);
};
var _templateObject;
var _excluded$2 = ["size"], _excluded2 = ["innerProps", "isRtl", "size"];
var _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
};
var Svg = function Svg2(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator$3 = function DropdownIndicator(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children2 || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children2 || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay2 = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children2);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group$1 = function Group(props) {
  var children2 = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label2 = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label2), jsx("div", null, children2));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading$1 = function GroupHeading(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1$1 = Group$1;
var _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input2 = function Input3(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input2;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children2 = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children2);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children2 = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children2 || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children2 = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children2), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children2 || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option$1 = function Option(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children2);
};
var Option$1$1 = Option$1;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children2);
};
var Placeholder$1 = Placeholder;
var css2 = function css3(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue$1 = function SingleValue(props) {
  var children2 = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children2);
};
var SingleValue$1$1 = SingleValue$1;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator: DropdownIndicator$3,
  DownChevron,
  CrossIcon,
  Group: Group$1$1,
  GroupHeading: GroupHeading$1,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action2 = props.action, _props$label = props.label, label2 = _props$label === void 0 ? "" : _props$label, labels2 = props.labels, isDisabled = props.isDisabled;
    switch (action2) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label2, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels2.length > 1 ? "s" : "", " ").concat(labels2.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label2, " is disabled. Select another option.") : "option ".concat(label2, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label2 = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item2) {
      return arr && arr.length ? "".concat(arr.indexOf(item2) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label2, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled2 = isDisabled ? " disabled" : "";
      var status2 = "".concat(isSelected ? "selected" : "focused").concat(disabled2);
      return "option ".concat(label2, " ").concat(status2, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = reactExports.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = reactExports.useMemo(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected2 = removedValue || option || asOption(value);
      var label2 = selected2 ? getOptionLabel4(selected2) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels2 = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected2 && isOptionDisabled3(selected2, selectValue),
        label: label2,
        labels: labels2
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = reactExports.useMemo(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = reactExports.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = reactExports.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "A"
}, {
  base: "AA",
  letters: ""
}, {
  base: "AE",
  letters: ""
}, {
  base: "AO",
  letters: ""
}, {
  base: "AU",
  letters: ""
}, {
  base: "AV",
  letters: ""
}, {
  base: "AY",
  letters: ""
}, {
  base: "B",
  letters: "B"
}, {
  base: "C",
  letters: "C"
}, {
  base: "D",
  letters: "D"
}, {
  base: "DZ",
  letters: ""
}, {
  base: "Dz",
  letters: ""
}, {
  base: "E",
  letters: "E"
}, {
  base: "F",
  letters: "F"
}, {
  base: "G",
  letters: "G"
}, {
  base: "H",
  letters: "H"
}, {
  base: "I",
  letters: "I"
}, {
  base: "J",
  letters: "J"
}, {
  base: "K",
  letters: "K"
}, {
  base: "L",
  letters: "L"
}, {
  base: "LJ",
  letters: ""
}, {
  base: "Lj",
  letters: ""
}, {
  base: "M",
  letters: "M"
}, {
  base: "N",
  letters: "N"
}, {
  base: "NJ",
  letters: ""
}, {
  base: "Nj",
  letters: ""
}, {
  base: "O",
  letters: "O"
}, {
  base: "OI",
  letters: ""
}, {
  base: "OO",
  letters: ""
}, {
  base: "OU",
  letters: ""
}, {
  base: "P",
  letters: "P"
}, {
  base: "Q",
  letters: "Q"
}, {
  base: "R",
  letters: "R"
}, {
  base: "S",
  letters: "S"
}, {
  base: "T",
  letters: "T"
}, {
  base: "TZ",
  letters: ""
}, {
  base: "U",
  letters: "U"
}, {
  base: "V",
  letters: "V"
}, {
  base: "VY",
  letters: ""
}, {
  base: "W",
  letters: "W"
}, {
  base: "X",
  letters: "X"
}, {
  base: "Y",
  letters: "Y"
}, {
  base: "Z",
  letters: "Z"
}, {
  base: "a",
  letters: "a"
}, {
  base: "aa",
  letters: ""
}, {
  base: "ae",
  letters: ""
}, {
  base: "ao",
  letters: ""
}, {
  base: "au",
  letters: ""
}, {
  base: "av",
  letters: ""
}, {
  base: "ay",
  letters: ""
}, {
  base: "b",
  letters: "b"
}, {
  base: "c",
  letters: "c"
}, {
  base: "d",
  letters: "d"
}, {
  base: "dz",
  letters: ""
}, {
  base: "e",
  letters: "e"
}, {
  base: "f",
  letters: "f"
}, {
  base: "g",
  letters: "g"
}, {
  base: "h",
  letters: "h"
}, {
  base: "hv",
  letters: ""
}, {
  base: "i",
  letters: "i"
}, {
  base: "j",
  letters: "j"
}, {
  base: "k",
  letters: "k"
}, {
  base: "l",
  letters: "l"
}, {
  base: "lj",
  letters: ""
}, {
  base: "m",
  letters: "m"
}, {
  base: "n",
  letters: "n"
}, {
  base: "nj",
  letters: ""
}, {
  base: "o",
  letters: "o"
}, {
  base: "oi",
  letters: ""
}, {
  base: "ou",
  letters: ""
}, {
  base: "oo",
  letters: ""
}, {
  base: "p",
  letters: "p"
}, {
  base: "q",
  letters: "q"
}, {
  base: "r",
  letters: "r"
}, {
  base: "s",
  letters: "s"
}, {
  base: "t",
  letters: "t"
}, {
  base: "tz",
  letters: ""
}, {
  base: "u",
  letters: "u"
}, {
  base: "v",
  letters: "v"
}, {
  base: "vy",
  letters: ""
}, {
  base: "w",
  letters: "w"
}, {
  base: "x",
  letters: "x"
}, {
  base: "y",
  letters: "y"
}, {
  base: "z",
  letters: "z"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j$1 = 0; j$1 < diacritic.letters.length; j$1++) {
    diacriticToBase[diacritic.letters[j$1]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input2 = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input2 = input2.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = memoizedStripDiacriticsForInput(input2);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
};
var _excluded = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$2({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var cancelScroll = function cancelScroll2(event2) {
  event2.preventDefault();
  event2.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = reactExports.useRef(false);
  var isTop = reactExports.useRef(false);
  var touchStart = reactExports.useRef(0);
  var scrollTarget = reactExports.useRef(null);
  var handleEventDelta = reactExports.useCallback(function(event2, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event2);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event2);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event2);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event2);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event2);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = reactExports.useCallback(function(event2) {
    handleEventDelta(event2, event2.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = reactExports.useCallback(function(event2) {
    touchStart.current = event2.changedTouches[0].clientY;
  }, []);
  var onTouchMove = reactExports.useCallback(function(event2) {
    var deltaY = touchStart.current - event2.changedTouches[0].clientY;
    handleEventDelta(event2, deltaY);
  }, [handleEventDelta]);
  var startListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el2.addEventListener("wheel", onWheel, notPassive);
    el2.addEventListener("touchstart", onTouchStart, notPassive);
    el2.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    el2.removeEventListener("wheel", onWheel, false);
    el2.removeEventListener("touchstart", onTouchStart, false);
    el2.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e3) {
  e3.preventDefault();
}
function allowTouchMove(e3) {
  e3.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = reactExports.useRef({});
  var scrollTarget = reactExports.useRef(null);
  var addScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function ScrollManager(_ref3) {
  var children2 = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children2(targetRef));
}
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref2,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label2 = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label: label2,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label2 = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label2,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action2, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action2,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base3 = defaultStyles[key](props, unstyled);
      base3.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base3, props) : base3;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event2) {
      if (event2.button !== 0) {
        return;
      }
      event2.stopPropagation();
      event2.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event2) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event2) {
      if (event2.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA") {
        event2.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event2) {
      if (event2 && event2.type === "mousedown" && event2.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event2.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event2) {
      if (event2 && event2.type === "mousedown" && event2.button !== 0) {
        return;
      }
      _this.clearValue();
      event2.preventDefault();
      _this.openAfterFocus = false;
      if (event2.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event2) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event2.target instanceof HTMLElement && isDocumentElement(event2.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event2)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event2.target) && _this.menuListRef && !_this.menuListRef.contains(event2.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event2);
    };
    _this.onClearIndicatorTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event2);
    };
    _this.onDropdownIndicatorTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event2);
    };
    _this.handleInputChange = function(event2) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event2.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event2) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event2);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event2) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event2);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event2) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event2);
        if (event2.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event2.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event2.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event2.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event2.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id2 = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ reactExports.createElement(DummyInput, _extends({
            id: id2,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ reactExports.createElement(Input4, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ reactExports.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ reactExports.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e3) {
                e3.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ reactExports.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ reactExports.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = function render2(props, id2) {
        var type2 = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label2 = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id2);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ reactExports.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label: label2,
          type: type2,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item2) {
          if (item2.type === "group") {
            var _data = item2.data, options2 = item2.options, groupIndex = item2.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ reactExports.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item2.data
              },
              label: _this4.formatGroupLabel(item2.data)
            }), item2.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item2.type === "option") {
            return render(item2, "".concat(item2.index));
          }
        });
      } else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ reactExports.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ reactExports.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ reactExports.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ reactExports.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance2) {
              _this4.getMenuListRef(instance2);
              scrollTargetRef(instance2);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ reactExports.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /* @__PURE__ */ reactExports.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input2 = selectValue.length > 0 ? selectValue.map(function(opt, i) {
            return /* @__PURE__ */ reactExports.createElement("input", {
              key: "i-".concat(i),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ reactExports.createElement("div", null, input2);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ reactExports.createElement("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ reactExports.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ reactExports.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ reactExports.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ reactExports.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ reactExports.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(reactExports.Component);
Select.defaultProps = defaultProps;
var StateManagedSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;
const badge$3 = "_badge_f2nw5_1";
const iconOnly = "_iconOnly_f2nw5_11";
const badgeIcon = "_badgeIcon_f2nw5_20";
const withChildren = "_withChildren_f2nw5_24";
const success$4 = "_success_f2nw5_34";
const warning$3 = "_warning_f2nw5_40";
const style$O = {
  badge: badge$3,
  iconOnly,
  badgeIcon,
  withChildren,
  success: success$4,
  warning: warning$3
};
const Badge = ({
  children: children2,
  className,
  icon: icon2,
  type: type2 = "success",
  ...props
}) => {
  const withChildrenStyle = children2 !== void 0 ? style$O.withChildren : "";
  const iconOnlyStyle = children2 === void 0 && icon2 ? style$O.iconOnly : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$O.badge} ${style$O[type2]} ${withChildrenStyle} ${iconOnlyStyle} ${className || ""}`,
      ...props,
      children: [
        icon2 && icon2({ className: style$O.badgeIcon }),
        children2
      ]
    }
  );
};
const insured = "_insured_15jr2_1";
const insuredShield = "_insuredShield_15jr2_30";
const style$N = {
  insured,
  insuredShield
};
const Insured = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: style$N.insured, to: "/bitsurance/dashboard", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("account.insured") })
  ] }) });
};
const InsuredShield = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$N.insured} ${style$N.insuredShield}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {}) });
};
const createGroupedOptions = (accountsByKeystore) => {
  return accountsByKeystore.map(({ keystore: keystore2, accounts }) => ({
    label: `${keystore2.name} ${isAmbiguiousName(keystore2.name, accountsByKeystore) ? `(${keystore2.rootFingerprint})` : ""}`,
    connected: keystore2.connected,
    options: accounts.map((account2) => ({ label: account2.name, value: account2.code, coinCode: account2.coinCode, disabled: false }))
  }));
};
const appendBalance = async (option) => {
  const balance2 = await getBalance(option.value);
  return { ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` };
};
const getBalancesForGroupedAccountSelector = async (originalGroupedOptions) => {
  const groupedOptions = originalGroupedOptions.map((group) => ({
    ...group,
    options: [...group.options]
  }));
  for (const group of groupedOptions) {
    const promises = group.options.map(appendBalance);
    group.options = await Promise.all(promises);
  }
  return groupedOptions;
};
const balance = "_balance_1lxsi_1";
const balanceSingleValue = "_balanceSingleValue_1lxsi_1";
const dropdown$2 = "_dropdown_1lxsi_12";
const groupHeader = "_groupHeader_1lxsi_21";
const select$4 = "_select_1lxsi_28";
const selectLabelText$1 = "_selectLabelText_1lxsi_82";
const singleValueContainer$1 = "_singleValueContainer_1lxsi_86";
const valueContainer = "_valueContainer_1lxsi_94";
const styles$k = {
  balance,
  balanceSingleValue,
  dropdown: dropdown$2,
  groupHeader,
  select: select$4,
  selectLabelText: selectLabelText$1,
  singleValueContainer: singleValueContainer$1,
  valueContainer
};
const SelectSingleValue$1 = (props) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const { label: label2, coinCode, balance: balance2, insured: insured2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.singleValueContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }),
    insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InsuredShield, {}),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.balanceSingleValue, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) }) });
};
const SelectOption$1 = (props) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const { label: label2, coinCode, balance: balance2, insured: insured2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }),
    insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InsuredShield, {}),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.balance, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) });
};
const DropdownIndicator$2 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.dropdown }) });
};
const Group2 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.Group, { ...props }) });
const GroupHeading2 = ({ customData, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$k.groupHeader}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.GroupHeading, { ...props, data: customData }),
    customData.connected && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Badge,
      {
        icon: (props2) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props2 }),
        type: "success"
      }
    )
  ] });
};
const GroupedAccountSelector = ({ title: title2, disabled: disabled2, selected: selected2, onChange: onChange2, onProceed, accounts }) => {
  const { t: t2 } = useTranslation();
  const [options2, setOptions] = reactExports.useState();
  reactExports.useEffect(() => {
    const accountsByKeystore = getAccountsByKeystore(accounts);
    const groupedOpts = createGroupedOptions(accountsByKeystore);
    setOptions(groupedOpts);
    getBalancesForGroupedAccountSelector(groupedOpts).then(setOptions);
  }, [accounts]);
  if (!options2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title text-center", children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        className: styles$k.select,
        classNamePrefix: "react-select",
        options: options2,
        isSearchable: false,
        value: selected2 === "" ? {
          label: t2("buy.info.selectLabel"),
          value: "choose",
          disabled: true
        } : options2.flatMap((o2) => o2.options).find((opt) => opt.value === selected2),
        onChange: (e3) => {
          const value = (e3 == null ? void 0 : e3.value) || "";
          onChange2(value);
        },
        components: {
          Group: Group2,
          GroupHeading: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(GroupHeading2, { customData: props.data, ...props }),
          DropdownIndicator: DropdownIndicator$2,
          Option: SelectOption$1,
          SingleValue: SelectSingleValue$1,
          IndicatorSeparator: () => null
        },
        defaultValue: options2[0].options[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onProceed,
        disabled: !selected2 || disabled2,
        children: t2("buy.info.next")
      }
    ) })
  ] });
};
const BuyInfo = ({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState();
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    try {
      getExchangeSupportedAccounts(accounts).then((exchangeSupportedAccounts) => {
        setSupportedAccounts(exchangeSupportedAccounts);
      });
    } catch (e3) {
      console.error(e3);
    }
  }, [accounts]);
  reactExports.useEffect(() => {
    if (supportedAccounts !== void 0 && supportedAccounts.length === 1) {
      const accountCode = supportedAccounts[0].code;
      connectKeystore$12(accountCode).then((connected) => {
        if (connected) {
          route(`/buy/exchange/${accountCode}`);
        }
      });
    }
  }, [supportedAccounts]);
  const handleProceed = async () => {
    setDisabled(true);
    try {
      const connected = await connectKeystore$12(selected2);
      if (connected) {
        route(`/buy/exchange/${selected2}`);
      }
    } finally {
      setDisabled(false);
    }
  };
  const connectKeystore$12 = async (keystore2) => {
    const connectResult = await connectKeystore(keystore2);
    return connectResult.success;
  };
  if (supportedAccounts === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") });
  }
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const name = hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: !supportedAccounts || supportedAccounts.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: t2("accountSummary.noAccount") }) : supportedAccounts && /* @__PURE__ */ jsxRuntimeExports.jsx(
        GroupedAccountSelector,
        {
          accounts: supportedAccounts,
          title: t2("buy.title", { name }),
          disabled: disabled2,
          selected: selected2,
          onChange: setSelected,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] }) });
};
const flagIcons = "";
const button$2 = "_button_diw5d_1";
const style$M = {
  button: button$2
};
const InfoButton = ({ onClick, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick, ...props, className: style$M.button, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BuyInfo$1, {}) });
};
const container$l = "_container_1ksto_17";
const paymentMethodContainer = "_paymentMethodContainer_1ksto_17";
const exchangeName = "_exchangeName_1ksto_21";
const infoButton = "_infoButton_1ksto_25";
const outerContainer$2 = "_outerContainer_1ksto_37";
const paymentMethodsContainer = "_paymentMethodsContainer_1ksto_41";
const paymentMethodName = "_paymentMethodName_1ksto_47";
const radio = "_radio_1ksto_67";
const radioLabel = "_radioLabel_1ksto_123";
const text$2 = "_text_1ksto_127";
const style$L = {
  container: container$l,
  paymentMethodContainer,
  exchangeName,
  infoButton,
  outerContainer: outerContainer$2,
  paymentMethodsContainer,
  paymentMethodName,
  radio,
  radioLabel,
  text: text$2
};
const PaymentMethod = ({ methodName }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  switch (methodName) {
    case "bank-transfer":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$L.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Bank, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BankDark, {}),
        t2("buy.exchange.bankTransfer")
      ] });
    case "card":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$L.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCardDark, {}),
        t2("buy.exchange.creditCard")
      ] });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: methodName });
  }
};
const Deal = ({ deal }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.paymentMethodContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, { methodName: deal.payment }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      deal.isBestDeal && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "success", children: t2("buy.exchange.bestDeal") }),
      deal.isFast && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "warning", children: t2("buy.exchange.fast") })
    ] })
  ] });
};
function ExchangeSelectionRadio({
  disabled: disabled2 = false,
  id: id2,
  children: children2,
  checked: checked2,
  deals,
  onChange: onChange2,
  exchangeName: exchangeName2,
  onClickInfoButton,
  ...props
}) {
  const handleClick = () => {
    if (!disabled2) {
      onChange2();
    }
  };
  const handleKeyDown = (e3) => {
    if (!disabled2 && e3.key === "Enter") {
      onChange2();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.outerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "aria-checked": checked2, onKeyDown: handleKeyDown, "aria-disabled": disabled2, role: "radio", tabIndex: 0, onClick: handleClick, className: style$L.radio, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          checked: checked2,
          type: "radio",
          id: id2,
          disabled: disabled2,
          onChange: onChange2,
          ...props
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: style$L.radioLabel, htmlFor: id2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$L.text, style$L.exchangeName].join(" "), children: getFormattedName(exchangeName2) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.paymentMethodsContainer, children: deals.map((deal) => /* @__PURE__ */ jsxRuntimeExports.jsx(Deal, { deal }, deal.payment)) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => onClickInfoButton(exchangeName2) })
  ] });
}
const container$k = "_container_h94uh_1";
const style$K = {
  container: container$k
};
const MoonPayInfo = ({ cardFee, bankTransferFee }) => {
  const { t: t2 } = useTranslation();
  const formattedCardFee = cardFee && cardFee * 100;
  const formattedBankTransferFee = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-", children: t2("buy.exchange.infoContent.moonpay.fullCurrenciesList") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCard") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCardDetails.cards") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.pix") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: t2("buy.exchange.infoContent.moonpay.payment.asteriskText") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/4406210084113-What-payment-methods-do-you-support-", children: t2("buy.exchange.infoContent.moonpay.payment.learnMore") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.creditDebitCard", { fee: formattedCardFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.bankTransfer", { fee: formattedBankTransferFee }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/", children: t2("buy.exchange.infoContent.moonpay.fees.learnMore") }) })
  ] });
};
const PocketInfo = ({ bankTransferFee }) => {
  const { t: t2 } = useTranslation();
  const fee2 = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sic") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/how-do-I-set-up-my-standing-order", children: t2("buy.exchange.infoContent.pocket.payment.bankTransferReccuring") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.verification.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.verification.info") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/are-there-any-limits-with-pocket", children: t2("buy.exchange.infoContent.pocket.verification.link") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.fees.info", { fee: fee2 }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/", children: t2("buy.exchange.infoContent.pocket.learnMore") }) })
  ] });
};
const RegionInfo = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.region.title") }) });
};
const InfoContent = ({ info: info2, cardFee, bankTransferFee }) => {
  switch (info2) {
    case "moonpay":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MoonPayInfo, { cardFee, bankTransferFee });
    case "pocket":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PocketInfo, { bankTransferFee });
    case "region":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RegionInfo, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
};
const buttonBack = "_buttonBack_62uya_17";
const buttonsContainer$1 = "_buttonsContainer_62uya_21";
const container$j = "_container_62uya_27";
const exchangeContainer = "_exchangeContainer_62uya_31";
const header$4 = "_header_62uya_44";
const selectContainer = "_selectContainer_62uya_49";
const label$5 = "_label_62uya_62";
const noExchangeText = "_noExchangeText_62uya_69";
const radioButtonsContainer = "_radioButtonsContainer_62uya_77";
const title$6 = "_title_62uya_81";
const style$J = {
  buttonBack,
  buttonsContainer: buttonsContainer$1,
  container: container$j,
  exchangeContainer,
  header: header$4,
  selectContainer,
  label: label$5,
  noExchangeText,
  radioButtonsContainer,
  title: title$6
};
const dropdown$1 = "_dropdown_9chnx_1";
const flag = "_flag_9chnx_10";
const globe = "_globe_9chnx_14";
const optionsContainer = "_optionsContainer_9chnx_20";
const select$3 = "_select_9chnx_25";
const selectLabelText = "_selectLabelText_9chnx_59";
const singleValueContainer = "_singleValueContainer_9chnx_64";
const styles$j = {
  dropdown: dropdown$1,
  flag,
  globe,
  optionsContainer,
  select: select$3,
  selectLabelText,
  singleValueContainer
};
const SelectedRegionIcon = ({ regionCode }) => {
  const { isDarkMode } = useDarkmode();
  const globe2 = isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeLight, { className: styles$j.globe }) : /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeDark, { className: styles$j.globe });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: regionCode === "" ? globe2 : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `fi fi-${regionCode} ${styles$j.flag}` }) });
};
const SelectSingleValue = (props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.singleValueContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.selectLabelText, children: label2 }) })
  ] });
};
const SelectOption = (props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.optionsContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.selectLabelText, children: label2 })
  ] }) });
};
const DropdownIndicator$1 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.dropdown }) });
};
const CountrySelect = ({ onChangeRegion, regions, selectedRegion }) => {
  const { t: t2 } = useTranslation();
  const formattedRegionName = new Intl.DisplayNames([instance.language], { type: "region" }).of(selectedRegion) || "";
  const selectedRegionName = selectedRegion === "" ? t2("buy.exchange.selectRegion") : formattedRegionName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: styles$j.select,
      classNamePrefix: "react-select",
      components: { DropdownIndicator: DropdownIndicator$1, SingleValue: SelectSingleValue, Option: SelectOption, IndicatorSeparator: () => null },
      defaultValue: { label: selectedRegionName, value: selectedRegion },
      isSearchable: true,
      onChange: (e3) => onChangeRegion(e3),
      options: [
        {
          label: t2("buy.exchange.selectRegion") || "",
          value: ""
        },
        ...regions
      ]
    }
  );
};
const Exchange = ({ code, accounts }) => {
  var _a, _b, _c;
  const { t: t2 } = useTranslation();
  const [showPocket, setShowPocket] = reactExports.useState(false);
  const [showMoonpay, setShowMoonpay] = reactExports.useState(false);
  const [selectedRegion, setSelectedRegion] = reactExports.useState("");
  const [selectedExchange, setSelectedExchange] = reactExports.useState("");
  const [regions, setRegions] = reactExports.useState([]);
  const [allExchangeDeals, setAllExchanges] = reactExports.useState();
  const [info2, setInfo] = reactExports.useState();
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState([]);
  const regionList = useLoad(getExchangesByRegion(code));
  const exchangeDeals = useLoad(getExchangeDeals);
  const nativeLocale = useLoad(getNativeLocale);
  const supportedExchanges = useLoad(getExchangeBuySupported(code));
  const config = useLoad(getConfig);
  const account2 = findAccount(accounts, code);
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const hasOnlyOneSupportedExchange = allExchangeDeals ? allExchangeDeals.exchanges.filter((exchange) => exchange.supported).length === 1 : false;
  reactExports.useEffect(() => {
    getExchangeSupportedAccounts(accounts).then(setSupportedAccounts);
  }, [accounts]);
  reactExports.useEffect(() => {
    if (!regionList || !config) {
      return;
    }
    const regionNames = new Intl.DisplayNames([instance.language], { type: "region" }) || "";
    const regions2 = regionList.regions.map((region) => ({ value: region.code, label: regionNames.of(region.code) }));
    regions2.sort((a2, b2) => a2.label.localeCompare(b2.label, instance.language));
    setRegions(regions2);
    if (config.frontend.selectedExchangeRegion === "") {
      return;
    }
    if (config.frontend.selectedExchangeRegion) {
      setSelectedRegion(config.frontend.selectedExchangeRegion);
      return;
    }
    const userRegion = getRegionNameFromLocale(nativeLocale || "");
    const regionAvailable = !!regionList.regions.find((region) => region.code === userRegion);
    setSelectedRegion(regionAvailable ? userRegion : "");
  }, [regionList, config, nativeLocale]);
  reactExports.useEffect(() => {
    if (!exchangeDeals) {
      return;
    }
    const deals = { exchanges: exchangeDeals.exchanges.map((ex) => ({ ...ex, supported: ex.exchangeName === "pocket" ? showPocket : showMoonpay })) };
    const lowestFee = findLowestFee(deals);
    const exchangesWithBestDeal = findBestDeal(deals, lowestFee);
    setAllExchanges(exchangesWithBestDeal);
  }, [selectedRegion, showMoonpay, showPocket, exchangeDeals]);
  reactExports.useEffect(() => {
    if (hasOnlyOneSupportedExchange && allExchangeDeals && selectedRegion !== "") {
      const exchange = allExchangeDeals.exchanges.filter((exchange2) => exchange2.supported);
      setSelectedExchange(exchange[0].exchangeName);
    }
  }, [hasOnlyOneSupportedExchange, allExchangeDeals, selectedRegion]);
  reactExports.useEffect(() => {
    setSelectedExchange("");
    if (!supportedExchanges) {
      setShowPocket(false);
      setShowMoonpay(false);
      return;
    }
    if (selectedRegion === "") {
      setShowPocket(supportedExchanges.exchanges.includes("pocket"));
      setShowMoonpay(supportedExchanges.exchanges.includes("moonpay"));
      return;
    }
    if (!regionList) {
      return;
    }
    setShowPocket(false);
    setShowMoonpay(false);
    regionList.regions.forEach((region) => {
      if (region.code === selectedRegion) {
        setShowPocket(region.isPocketEnabled);
        setShowMoonpay(region.isMoonpayEnabled);
        return;
      }
    });
  }, [selectedRegion, regionList, supportedExchanges]);
  const goToExchange = () => {
    if (!selectedExchange) {
      return;
    }
    route(`/buy/${selectedExchange}/${code}`);
  };
  const handleChangeRegion = (newValue) => {
    if (newValue) {
      const selectedRegion2 = newValue.value;
      setSelectedRegion(selectedRegion2);
      setConfig({ frontend: { selectedExchangeRegion: selectedRegion2 } });
    }
  };
  const noExchangeAvailable = !showMoonpay && !showPocket;
  const infoFeesDetail = (_a = exchangeDeals == null ? void 0 : exchangeDeals.exchanges.find((exchange) => exchange.exchangeName === info2)) == null ? void 0 : _a.deals;
  const cardFee = infoFeesDetail && ((_b = infoFeesDetail.find((feeDetail) => feeDetail.payment === "card")) == null ? void 0 : _b.fee);
  const bankTransferFee = infoFeesDetail && ((_c = infoFeesDetail.find((feeDetail) => feeDetail.payment === "bank-transfer")) == null ? void 0 : _c.fee);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { medium: true, title: info2 && info2 !== "region" ? getFormattedName(info2) : t2("buy.exchange.region"), onClose: () => setInfo(void 0), open: !!info2, children: info2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoContent, { info: info2, cardFee, bankTransferFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.exchange.title", { name }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$J.exchangeContainer, "content", "narrow", "isVerticallyCentered"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$J.title, children: t2("buy.title", { name }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$J.label, children: t2("buy.exchange.region") }),
          regions.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.selectContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CountrySelect,
                {
                  onChangeRegion: handleChangeRegion,
                  regions,
                  selectedRegion
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => setInfo("region") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.radioButtonsContainer, children: [
              noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$J.noExchangeText, children: t2("buy.exchange.noExchanges") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !noExchangeAvailable && allExchangeDeals && allExchangeDeals.exchanges.map((exchange) => exchange.supported && /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExchangeSelectionRadio,
                {
                  id: exchange.exchangeName,
                  exchangeName: exchange.exchangeName,
                  deals: exchange.deals,
                  checked: selectedExchange === exchange.exchangeName,
                  onChange: () => setSelectedExchange(exchange.exchangeName),
                  onClickInfoButton: setInfo
                },
                exchange.exchangeName
              )) }),
              !noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.buttonsContainer, children: [
                supportedAccounts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: style$J.buttonBack,
                    secondary: true,
                    onClick: () => route("/buy/info"),
                    children: t2("button.back")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    primary: true,
                    disabled: !selectedExchange,
                    onClick: goToExchange,
                    children: t2("button.next")
                  }
                )
              ] })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] });
};
var dist = {};
var utils$1 = {};
Object.defineProperty(utils$1, "__esModule", { value: true });
utils$1.isOneOf = utils$1.isLiteral = utils$1.isNullish = utils$1.isBoolean = utils$1.isString = utils$1.isObject = void 0;
function isObject(value) {
  return Object(value) === value;
}
utils$1.isObject = isObject;
function isString(value) {
  return typeof value === "string";
}
utils$1.isString = isString;
function isBoolean(value) {
  return typeof value === "boolean";
}
utils$1.isBoolean = isBoolean;
function isNullish(value) {
  return value === void 0 || value === null;
}
utils$1.isNullish = isNullish;
function isLiteral(value, literal) {
  return value === literal;
}
utils$1.isLiteral = isLiteral;
function isOneOf(value, ...literal) {
  return literal.some((l2) => l2 === value);
}
utils$1.isOneOf = isOneOf;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseMessage = exports.serializeMessage = exports.V0MessageScriptType = exports.V0MessageType = exports.MessageVersion = void 0;
  const utils_1 = utils$1;
  var MessageVersion;
  (function(MessageVersion2) {
    MessageVersion2["V0"] = "0";
  })(MessageVersion = exports.MessageVersion || (exports.MessageVersion = {}));
  var V0MessageType;
  (function(V0MessageType2) {
    V0MessageType2["RequestAddress"] = "requestAddress";
    V0MessageType2["RequestExtendedPublicKey"] = "requestExtendedPublicKey";
    V0MessageType2["VerifyAddress"] = "verifyAddress";
    V0MessageType2["Address"] = "address";
    V0MessageType2["ExtendedPublicKey"] = "extendedPublicKey";
  })(V0MessageType = exports.V0MessageType || (exports.V0MessageType = {}));
  var V0MessageScriptType;
  (function(V0MessageScriptType2) {
    V0MessageScriptType2["P2PKH"] = "p2pkh";
    V0MessageScriptType2["P2WPKH"] = "p2wpkh";
    V0MessageScriptType2["P2SH"] = "p2sh";
    V0MessageScriptType2["P2TR"] = "p2tr";
  })(V0MessageScriptType = exports.V0MessageScriptType || (exports.V0MessageScriptType = {}));
  function serializeMessage(message2) {
    return JSON.stringify(message2);
  }
  exports.serializeMessage = serializeMessage;
  function parseMessage(value) {
    let object = value;
    if (typeof object === "string") {
      try {
        object = JSON.parse(object);
      } catch (e3) {
        throw new Error("could not parse as json");
      }
    }
    if (!(0, utils_1.isObject)(object)) {
      throw new Error("not an object");
    }
    const { version } = object;
    if ((0, utils_1.isLiteral)(version, MessageVersion.V0)) {
      const { type: type2 } = object;
      if (!(0, utils_1.isOneOf)(type2, ...Object.values(V0MessageType))) {
        throw new Error("invalid type");
      }
      if (type2 === V0MessageType.RequestAddress) {
        const { withMessageSignature } = object;
        if (!(0, utils_1.isString)(withMessageSignature) && !(0, utils_1.isNullish)(withMessageSignature)) {
          throw new Error("message signature indicator invalid");
        }
        const { withExtendedPublicKey } = object;
        if (!(0, utils_1.isBoolean)(withExtendedPublicKey) && !(0, utils_1.isNullish)(withExtendedPublicKey)) {
          throw new Error("extended public key indicator invalid");
        }
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType)) {
          throw new Error("script type indicator invalid");
        }
        return {
          version,
          type: type2,
          withMessageSignature,
          withExtendedPublicKey,
          withScriptType
        };
      } else if (type2 === V0MessageType.RequestExtendedPublicKey) {
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType)) {
          throw new Error("script type indicator invalid");
        }
        return {
          version,
          type: type2,
          withScriptType
        };
      } else if (type2 === V0MessageType.VerifyAddress) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress)) {
          throw new Error("bitcoin address missing");
        }
        return {
          version,
          type: type2,
          bitcoinAddress
        };
      } else if (type2 === V0MessageType.Address) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress)) {
          throw new Error("bitcoin address missing");
        }
        const { signature } = object;
        if (!(0, utils_1.isString)(signature) && !(0, utils_1.isNullish)(signature)) {
          throw new Error("signature invalid");
        }
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey) && !(0, utils_1.isNullish)(extendedPublicKey)) {
          throw new Error("extended public key invalid");
        }
        return {
          version,
          type: type2,
          bitcoinAddress,
          signature,
          extendedPublicKey
        };
      } else if (type2 === V0MessageType.ExtendedPublicKey) {
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey)) {
          throw new Error("extended public key missing");
        }
        return {
          version,
          type: type2,
          extendedPublicKey
        };
      } else {
        throw new Error("unsupported type");
      }
    }
    throw new Error("unsupported version");
  }
  exports.parseMessage = parseMessage;
})(dist);
const overlay = "_overlay_12k4v_1";
const activeOverlay = "_activeOverlay_12k4v_16";
const modal = "_modal_12k4v_20";
const activeModal = "_activeModal_12k4v_32";
const active$3 = "_active_12k4v_16";
const small = "_small_12k4v_38";
const medium = "_medium_12k4v_43";
const large = "_large_12k4v_49";
const header$3 = "_header_12k4v_54";
const centered = "_centered_12k4v_64";
const title$5 = "_title_12k4v_68";
const closeButton$1 = "_closeButton_12k4v_74";
const contentContainer = "_contentContainer_12k4v_95";
const slim = "_slim_12k4v_101";
const padded = "_padded_12k4v_105";
const content$1 = "_content_12k4v_95";
const actions = "_actions_12k4v_113";
const confirmationLabel = "_confirmationLabel_12k4v_131";
const confirmationLabelNumber = "_confirmationLabelNumber_12k4v_140";
const disabledLabel = "_disabledLabel_12k4v_146";
const noStep = "_noStep_12k4v_151";
const confirmationInstructions = "_confirmationInstructions_12k4v_155";
const confirm = "_confirm_12k4v_131";
const image = "_image_12k4v_175";
const modalContent = "_modalContent_12k4v_180";
const detail$1 = "_detail_12k4v_189";
const description = "_description_12k4v_213";
const buttons$2 = "_buttons_12k4v_217";
const dialogButtons = "_dialogButtons_12k4v_229";
const style$I = {
  overlay,
  activeOverlay,
  modal,
  activeModal,
  active: active$3,
  small,
  medium,
  large,
  header: header$3,
  centered,
  title: title$5,
  closeButton: closeButton$1,
  contentContainer,
  slim,
  padded,
  content: content$1,
  actions,
  confirmationLabel,
  confirmationLabelNumber,
  disabledLabel,
  noStep,
  confirmationInstructions,
  confirm,
  image,
  modalContent,
  detail: detail$1,
  description,
  buttons: buttons$2,
  dialogButtons
};
class DialogLegacy extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.modalContent = reactExports.createRef();
    this.state = {
      active: false,
      currentTab: 0
    };
    this.handleFocus = (e3) => {
      const input2 = e3.target;
      const index2 = input2.getAttribute("index");
      this.setState({ currentTab: Number(index2) });
    };
    this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables) {
          c2.classList.add("tabbable");
          c2.setAttribute("index", focusables.indexOf(c2).toString());
          c2.addEventListener("focus", this.handleFocus);
        }
        document.addEventListener("keydown", this.handleKeyDown);
      }
    };
    this.focusFirst = () => {
      const focusables = this.focusableChildren;
      if (focusables.length && focusables[0].getAttribute("autofocus") !== "false") {
        focusables[0].focus();
      }
    };
    this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    };
    this.handleKeyDown = (e3) => {
      const { disableEscape } = this.props;
      const isEsc = e3.keyCode === 27;
      const isTab = e3.keyCode === 9;
      if (!disableEscape && isEsc) {
        this.deactivate();
      } else if (isTab) {
        e3.preventDefault();
      }
      if (isTab && e3.shiftKey) {
        this.updateIndex(false);
      } else if (isTab) {
        this.updateIndex(true);
      }
    };
    this.deactivate = () => {
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      this.modal.current.classList.remove(style$I.activeModal);
      this.overlay.current.classList.remove(style$I.activeOverlay);
      this.setState({ active: false, currentTab: 0 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown);
        if (this.props.onClose) {
          this.props.onClose();
        }
      });
    };
    this.activate = () => {
      this.setState({ active: true }, () => {
        if (!this.modal.current || !this.overlay.current) {
          return;
        }
        this.overlay.current.classList.add(style$I.activeOverlay);
        this.modal.current.classList.add(style$I.activeModal);
        this.focusWithin();
        this.focusFirst();
      });
    };
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state;
    const focusables = Array.from(this.focusableChildren);
    const arr = isNext ? focusables : focusables.reverse();
    const current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled"));
    next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2;
    return isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props;
    const isSmall = small2 ? style$I.small : "";
    const isMedium = medium2 ? style$I.medium : "";
    const isLarge = large2 ? style$I.large : "";
    const isSlim = slim2 ? style$I.slim : "";
    const isCentered = centered2 && !onClose ? style$I.centered : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$I.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$I.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$I.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$I.closeButton, onClick: this.deactivate, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$I.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
}
function DialogButtons({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.dialogButtons, children: children2 });
}
let confirmation;
const Confirm = () => {
  const [state, setState] = reactExports.useState({ active: false });
  const { t: t2 } = useTranslation();
  const callback2 = reactExports.useRef(() => {
  });
  confirmation = (message22, cb2, customButtonText2) => {
    callback2.current = cb2;
    setState({
      active: true,
      message: message22,
      customButtonText: customButtonText2
    });
  };
  const respond = (response) => {
    callback2.current(response);
    setState({
      active: false
    });
  };
  const { message: message2, active: active2, customButtonText } = state;
  if (!active2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("dialog.confirmTitle"), onClose: () => respond(false), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: message2 ? message2.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: i === 0 ? "first" : "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: line2 })
      },
      i
    )) : null }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: () => respond(true), children: customButtonText ? customButtonText : t2("dialog.confirm") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: () => respond(false), children: t2("dialog.cancel") })
    ] })
  ] });
};
const PocketTerms = ({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipPocketDisclaimer: e3.target.checked } });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.welcome.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.security.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.pocket.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.kyc.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.kyc.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq", children: t2("buy.pocket.kyc.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.data.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.data.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/policy/privacy", children: t2("buy.pocket.data.link") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const Pocket = ({ code }) => {
  const { t: t2 } = useTranslation();
  const [height, setHeight] = reactExports.useState(0);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const [verifying, setVerifying] = reactExports.useState(false);
  const iframeURL = useLoad(getPocketURL);
  const config = useLoad(getConfig);
  const accountInfo2 = useLoad(getInfo(code));
  const ref = reactExports.createRef();
  const iframeRef = reactExports.createRef();
  let signing = false;
  let resizeTimerID = void 0;
  const name = "Bitcoin";
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipPocketDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    window.addEventListener("message", onMessage);
    return () => {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("message", onMessage);
    };
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  const sendAddress = (address2, sig) => {
    var _a;
    const { current } = iframeRef;
    if (!current) {
      return;
    }
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      signature: sig
    });
    (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
  };
  const handleRequestAddress = (message2) => {
    signing = true;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "";
    const withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = false;
      if (response.success) {
        sendAddress(response.address, response.signature);
      } else {
        if (response.errorCode !== "userAbort") {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const handleVerifyAddress = (address2) => {
    setVerifying(true);
    verifyAddress(address2, code).then((response) => {
      setVerifying(false);
      if (!response.success) {
        if (response.errorCode === "addressNotFound") {
          alertUser(t2("buy.pocket.usedAddress", { address: address2 }));
        } else {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const sendXpub = () => {
    var _a;
    if (accountInfo2) {
      const bitcoinSimple = accountInfo2.signingConfigurations[0].bitcoinSimple;
      if (bitcoinSimple) {
        const xpub = bitcoinSimple.keyInfo.xpub;
        const { current } = iframeRef;
        if (!current) {
          return;
        }
        const message2 = dist.serializeMessage({
          version: dist.MessageVersion.V0,
          type: dist.V0MessageType.ExtendedPublicKey,
          extendedPublicKey: xpub
        });
        (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
      }
    }
  };
  const handleRequestXpub = () => {
    getTransactionList(code).then((txs) => {
      if (!txs.success) {
        alertUser(t2("transactions.errorLoadTransactions"));
        return;
      }
      if (txs.list.length > 0) {
        confirmation(t2("buy.pocket.previousTransactions"), (result) => {
          if (result) {
            sendXpub();
          }
        });
      } else {
        sendXpub();
      }
    });
  };
  const onMessage = (m2) => {
    if (!iframeURL || !code) {
      return;
    }
    if (m2.origin !== new URL(iframeURL).origin) {
      return;
    }
    try {
      const message2 = dist.parseMessage(m2.data);
      switch (message2.type) {
        case dist.V0MessageType.RequestAddress:
          if (!signing) {
            handleRequestAddress(message2);
          }
          break;
        case dist.V0MessageType.VerifyAddress:
          if (!verifying) {
            handleVerifyAddress(message2.bitcoinAddress);
          }
          break;
        case dist.V0MessageType.RequestExtendedPublicKey:
          handleRequestXpub();
      }
    } catch (e3) {
      console.log(e3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$P.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: style$P.container, children: [
        !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          PocketTerms,
          {
            onAgreedTerms: () => setAgreedTerms(true)
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
          !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "iframe",
            {
              onLoad: () => {
                setIframeLoaded(true);
              },
              ref: iframeRef,
              title: "Pocket",
              width: "100%",
              height,
              frameBorder: "0",
              className: style$P.iframe,
              allow: "camera; payment",
              src: iframeURL
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: verifying,
            title: t2("receive.verifyBitBox02"),
            disableEscape: true,
            medium: true,
            centered: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: t2("buy.pocket.verifyBitBox02") })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "pocket" })
  ] });
};
const useEsc = (callback2) => {
  reactExports.useEffect(() => {
    const handleKeyDown = (e3) => {
      if (e3.key === "Escape") {
        callback2();
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [callback2]);
};
const button$1 = "_button_1djzh_1";
const success$3 = "_success_1djzh_34";
const container$i = "_container_1djzh_38";
const inputField = "_inputField_1djzh_42";
const flexibleHeight = "_flexibleHeight_1djzh_72";
const alignLeft = "_alignLeft_1djzh_76";
const alignRight = "_alignRight_1djzh_80";
const borderLess = "_borderLess_1djzh_84";
const style$H = {
  button: button$1,
  success: success$3,
  container: container$i,
  inputField,
  flexibleHeight,
  alignLeft,
  alignRight,
  borderLess
};
const CopyableInput = ({ alignLeft: alignLeft2, alignRight: alignRight2, borderLess: borderLess2, value, className, disabled: disabled2, flexibleHeight: flexibleHeight2 }) => {
  const [success2, setSuccess] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const textAreaRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setHeight();
  }, []);
  reactExports.useEffect(() => {
    if (success2) {
      setTimeout(() => setSuccess(false), 1500);
    }
  }, [success2]);
  const setHeight = () => {
    const textarea2 = textAreaRef.current;
    if (!textarea2) {
      return;
    }
    const fontSize = window.getComputedStyle(textarea2, null).getPropertyValue("font-size");
    const units = Number(fontSize.replace("px", "")) + 2;
    textarea2.setAttribute("rows", "1");
    textarea2.setAttribute("rows", String(Math.round(textarea2.scrollHeight / units - 2)));
  };
  const onFocus2 = (e3) => {
    e3.currentTarget.focus();
  };
  const copy2 = () => {
    var _a;
    (_a = textAreaRef.current) == null ? void 0 : _a.select();
    if (document.execCommand("copy")) {
      setSuccess(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    "flex flex-row flex-start flex-items-start",
    style$H.container,
    className ? className : ""
  ].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        disabled: disabled2,
        readOnly: true,
        onFocus: onFocus2,
        value,
        ref: textAreaRef,
        rows: 1,
        className: [
          style$H.inputField,
          flexibleHeight2 && style$H.flexibleHeight,
          alignLeft2 && style$H.alignLeft,
          alignRight2 && style$H.alignRight,
          borderLess2 && style$H.borderLess
        ].join(" ")
      }
    ),
    disabled2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: copy2,
        className: [style$H.button, success2 && style$H.success, "ignore"].join(" "),
        title: t2("button.copy"),
        children: success2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, {})
      }
    )
  ] });
};
const checkContainer = "_checkContainer_a90m5_2";
const copiedText = "_copiedText_a90m5_14";
const empty$1 = "_empty_a90m5_19";
const hide$1 = "_hide_a90m5_25";
const hiddenInput = "_hiddenInput_a90m5_29";
const outerContainer$1 = "_outerContainer_a90m5_34";
const qrCodeContainer$1 = "_qrCodeContainer_a90m5_40";
const show = "_show_a90m5_53";
const style$G = {
  checkContainer,
  copiedText,
  empty: empty$1,
  hide: hide$1,
  hiddenInput,
  outerContainer: outerContainer$1,
  qrCodeContainer: qrCodeContainer$1,
  show
};
const QRCode = ({
  data,
  size: size2 = 256,
  tapToCopy = true
}) => {
  const qrCode2 = useLoad(data !== void 0 ? getQRCode(data) : null, [data]);
  if (!qrCode2) {
    if (data !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$G.empty });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: style$G.empty, style: { verticalAlign: "middle", fill: "currentColor", overflow: "hidden" }, viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M433.282171 47.939849 94.944396 47.939849c-23.327288 0-42.304502 18.975167-42.304502 42.300408l0 338.341868c0 23.324218 18.977213 42.300408 42.304502 42.300408L433.282171 470.882534c23.324218 0 42.300408-18.97619 42.300408-42.300408L475.582579 90.240257C475.581556 66.915016 456.606389 47.939849 433.282171 47.939849zM438.742533 428.582125c0 3.01159-2.449795 5.461385-5.461385 5.461385L94.944396 434.04351c-3.013637 0-5.465478-2.450818-5.465478-5.461385L89.478917 90.240257c0-3.01159 2.451842-5.461385 5.465478-5.461385L433.282171 84.778872c3.01159 0 5.461385 2.449795 5.461385 5.461385L438.743556 428.582125zM322.914504 173.887352l-117.608581 0c-14.733563 0-26.719548 11.985986-26.719548 26.719548l0 117.608581c0 14.735609 11.985986 26.724665 26.719548 26.724665l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581C349.640192 185.873338 337.651137 173.887352 322.914504 173.887352zM312.801169 308.101123l-97.374748 0 0-97.374748 97.374748 0L312.801169 308.101123zM322.914504 675.606195l-117.608581 0c-14.733563 0-26.719548 11.989055-26.719548 26.724665l0 117.608581c0 14.732539 11.985986 26.719548 26.719548 26.719548l117.608581 0c14.735609 0 26.724665-11.987009 26.724665-26.719548l0-117.608581C349.640192 687.59525 337.651137 675.606195 322.914504 675.606195zM312.801169 809.819966l-97.374748 0 0-97.374748 97.374748 0L312.801169 809.819966zM699.123818 344.940147l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581c0-14.733563-11.989055-26.719548-26.724665-26.719548l-117.608581 0c-14.732539 0-26.719548 11.985986-26.719548 26.719548l0 117.608581C672.40427 332.951091 684.391279 344.940147 699.123818 344.940147zM709.243293 210.726376l97.374748 0 0 97.374748-97.374748 0L709.243293 210.726376zM433.282171 546.435277 94.944396 546.435277c-23.327288 0-42.304502 18.97619-42.304502 42.300408L52.639894 927.077553c0 23.325241 18.977213 42.301432 42.304502 42.301432L433.282171 969.378985c23.324218 0 42.300408-18.97619 42.300408-42.301432L475.582579 588.735685C475.581556 565.411467 456.606389 546.435277 433.282171 546.435277zM438.742533 927.077553c0 3.01159-2.449795 5.462408-5.461385 5.462408L94.944396 932.539962c-3.013637 0-5.465478-2.450818-5.465478-5.462408L89.478917 588.735685c0-3.010567 2.451842-5.461385 5.465478-5.461385L433.282171 583.2743c3.01159 0 5.461385 2.450818 5.461385 5.461385L438.743556 927.077553zM590.849836 547.776831c-23.325241 0-42.301432 18.978237-42.301432 42.305525l0 194.649212c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L585.387427 590.082356c0-3.013637 2.450818-5.466502 5.462408-5.466502l204.825992 0c10.172687 0 18.419512-8.246825 18.419512-18.419512s-8.246825-18.419512-18.419512-18.419512L590.849836 547.776831zM588.757175 470.882534l338.341868 0c23.325241 0 42.301432-18.97619 42.301432-42.300408L969.400474 90.240257c0-23.324218-18.97619-42.300408-42.301432-42.300408L588.757175 47.939849c-23.324218 0-42.300408 18.975167-42.300408 42.300408l0 338.341868C546.456766 451.906343 565.432956 470.882534 588.757175 470.882534zM583.295789 90.240257c0-3.01159 2.450818-5.461385 5.461385-5.461385l338.341868 0c3.01159 0 5.462408 2.449795 5.462408 5.461385l0 338.341868c0 3.01159-2.450818 5.461385-5.462408 5.461385L588.757175 434.04351c-3.010567 0-5.461385-2.450818-5.461385-5.461385L583.295789 90.240257zM969.676767 566.196343c0-10.172687-8.246825-18.419512-18.419512-18.419512l-67.50444 0c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l49.084928 0 0 71.009264L779.708158 655.625118c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l171.549098 0c10.172687 0 18.419512-8.246825 18.419512-18.419512 0-0.076748-0.010233-0.151449-0.011256-0.228197 0.001023-0.076748 0.011256-0.150426 0.011256-0.228197L969.676767 566.196343zM630.202099 933.142689l-44.813648 0 0-51.2922c0-10.172687-8.246825-18.419512-18.419512-18.419512s-18.419512 8.246825-18.419512 18.419512l0 69.711711c0 10.172687 8.246825 18.419512 18.419512 18.419512l63.23316 0c10.172687 0 18.419512-8.246825 18.419512-18.419512S640.374786 933.142689 630.202099 933.142689zM834.04981 790.359752c0-10.172687-8.246825-18.419512-18.419512-18.419512L699.257871 771.940241c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 163.013701c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L717.677383 808.779264 815.630299 808.779264C825.802986 808.779264 834.04981 800.532439 834.04981 790.359752zM951.060781 723.425294c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 194.301288L765.943666 936.146093c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l185.117115 0c10.172687 0 18.419512-8.246825 18.419512-18.419512L969.480292 741.844805C969.480292 731.672118 961.234491 723.425294 951.060781 723.425294zM655.979182 623.620194c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 59.869552c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512l0-59.869552C674.398694 631.867018 666.151869 623.620194 655.979182 623.620194z" }) });
  }
  if (!qrCode2.success) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: qrCode2.message });
  }
  return tapToCopy ? /* @__PURE__ */ jsxRuntimeExports.jsx(TapToCopyQRCode, { data, qrCodeData: qrCode2.data, size: size2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { width: size2, height: size2, src: qrCode2.data });
};
const TapToCopyQRCode = ({ data, qrCodeData, size: size2 }) => {
  const inputRef = reactExports.useRef(null);
  const [success2, setSuccess] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (success2) {
      setTimeout(() => setSuccess(false), 1500);
    }
  }, [success2]);
  const handleCopy = () => {
    var _a;
    (_a = inputRef.current) == null ? void 0 : _a.select();
    if (document.execCommand("copy")) {
      setSuccess(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: handleCopy, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: style$G.hiddenInput, ref: inputRef, value: data, readOnly: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: size2, height: size2 }, className: style$G.outerContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: `${style$G.qrCodeContainer}  ${success2 ? style$G.hide : style$G.show}`, width: size2, height: size2, src: qrCodeData }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$G.checkContainer} ${style$G.show}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { width: size2 / 2, height: size2 / 2 }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$G.copiedText} ${success2 ? style$G.show : style$G.hide}`, children: t2("receive.qrCodeCopiedMessage") })
  ] });
};
const title$4 = "_title_nnme6_1";
const nextButton = "_nextButton_nnme6_6";
const details = "_details_nnme6_17";
const qrCode = "_qrCode_nnme6_22";
const address$3 = "_address_nnme6_32";
const buttons$1 = "_buttons_nnme6_35";
const verifyButton = "_verifyButton_nnme6_42";
const entry = "_entry_nnme6_46";
const xPubInfo = "_xPubInfo_nnme6_55";
const infoContent = "_infoContent_nnme6_82";
const largeEntry = "_largeEntry_nnme6_86";
const addressField = "_addressField_nnme6_96";
const style$F = {
  title: title$4,
  nextButton,
  details,
  qrCode,
  address: address$3,
  buttons: buttons$1,
  verifyButton,
  entry,
  xPubInfo,
  infoContent,
  largeEntry,
  addressField
};
const SigningConfiguration = ({ account: account2, info: info2, code, signingConfigIndex, children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const getSimpleInfo = () => {
    if (info2.bitcoinSimple !== void 0) {
      return info2.bitcoinSimple;
    }
    return info2.ethereumSimple;
  };
  const config = getSimpleInfo();
  const bitcoinBased = isBitcoinBased(account2.coinCode);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.address, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$F.qrCode, children: bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      QRCode,
      {
        data: config.keyInfo.xpub
      }
    ) : null }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.details, children: [
      account2.isToken ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountSummary.name"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name })
      ] }, "accountname"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Keypath:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.keypath })
      ] }, "keypath"),
      "scriptType" in config ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountInfo.scriptType"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getScriptName(config.scriptType) })
      ] }, "scriptName") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Root fingerprint:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.rootFingerprint })
      ] }, "rootFingerprint"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          account2.isToken ? "Token" : "Coin",
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          account2.coinName,
          " (",
          account2.coinUnit,
          ")"
        ] })
      ] }, "coinName"),
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$F.entry} ${style$F.largeEntry}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { className: "m-right-half", children: [
          t2("accountInfo.extendedPublicKey"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyableInput,
          {
            className: "flex-grow",
            alignLeft: true,
            flexibleHeight: true,
            value: config.keyInfo.xpub
          }
        )
      ] }, "xpub") : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.buttons, children: [
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$F.verifyButton, primary: true, disabled: verifying, onClick: async () => {
        setVerifying(true);
        try {
          const result = await verifyXPub(code, signingConfigIndex);
          if (!result.success) {
            alertUser(result.errorMessage);
          }
        } finally {
          setVerifying(false);
        }
      }, children: t2("accountInfo.verify") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$F.verifyButton, primary: true, onClick: () => route(`/account/${code}/receive`), children: t2("receive.verify") }),
      children2
    ] })
  ] });
};
function BitcoinBasedAccountInfoGuide({
  coinName: coinName2
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.xpub"), shown: true }, "guide.accountInfo.xpub"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      text: t2("guide.accountInfo.multipleXPubs.text", { coinName: coinName2 }),
      title: t2("guide.accountInfo.multipleXPubs.title")
    } }, "guide.accountInfo.multipleXPubs"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.privacy") }, "guide.accountInfo.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.verify") }, "guide.accountInfo.verify")
  ] });
}
const Info = ({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation();
  const info2 = useLoad(getInfo(code));
  const [viewXPub, setViewXPub] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  useEsc(() => route(`/account/${code}`));
  if (!account2 || !info2) {
    return null;
  }
  const config = info2.signingConfigurations[viewXPub];
  const numberOfXPubs = info2.signingConfigurations.length;
  const xpubTypes = info2.signingConfigurations.map((cfg) => {
    var _a;
    return (_a = cfg.bitcoinSimple) == null ? void 0 : _a.scriptType;
  });
  const showNextXPub = () => {
    if (!info2) {
      return;
    }
    const numberOfXPubs2 = info2.signingConfigurations.length;
    setViewXPub((viewXPub + 1) % numberOfXPubs2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountInfo.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box larger", children: [
        isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$F.title, children: t2("accountInfo.extendedPublicKey") }) : null,
        config.bitcoinSimple !== void 0 && numberOfXPubs > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$F.xPubInfo, children: [
          t2("accountInfo.xpubTypeInfo", {
            current: `${viewXPub + 1}`,
            numberOfXPubs: numberOfXPubs.toString(),
            scriptType: config.bitcoinSimple.scriptType.toUpperCase()
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$F.nextButton, onClick: showNextXPub, children: t2(`accountInfo.xpubTypeChangeBtn.${xpubTypes[(viewXPub + 1) % numberOfXPubs]}`) })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SigningConfiguration,
          {
            account: account2,
            code,
            info: config,
            signingConfigIndex: viewXPub,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: true,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          },
          viewXPub
        )
      ] }) })
    ] }) }),
    isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitcoinBasedAccountInfoGuide, { coinName: account2.coinName }) : null
  ] });
};
function ReceiveGuide({
  hasMultipleAddresses,
  hasDifferentFormats
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.address") }, "guide.receive.address"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyVerify") }, "guide.receive.whyVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.howVerify") }, "guide.receive.howVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.plugout") }, "guide.receive.plugout"),
    hasMultipleAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyMany") }, "guide.receive.whyMany"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.why20") }, "guide.receive.why20"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressChange") }, "guide.receive.addressChange"),
      hasDifferentFormats && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressFormats") }, "guide.receive.addressFormats")
    ] })
  ] });
}
const labels = "_labels_1m4jx_1";
const label$4 = "_label_1m4jx_1";
const qrCodeContainer = "_qrCodeContainer_1m4jx_17";
const arrowLeft = "_arrowLeft_1m4jx_22";
const arrowRight = "_arrowRight_1m4jx_23";
const previous = "_previous_1m4jx_37";
const next = "_next_1m4jx_38";
const hide = "_hide_1m4jx_49";
const changeType = "_changeType_1m4jx_58";
const style$E = {
  labels,
  label: label$4,
  qrCodeContainer,
  arrowLeft,
  arrowRight,
  previous,
  next,
  hide,
  changeType
};
const scriptTypes$1 = ["p2wpkh", "p2tr", "p2wpkh-p2sh"];
const getIndexOfMatchingScriptType$1 = (receiveAddresses, scriptType) => {
  if (!receiveAddresses) {
    return -1;
  }
  return receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType);
};
const Receive$2 = ({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const [activeIndex, setActiveIndex] = reactExports.useState(0);
  const [addressType, setAddressType] = reactExports.useState(0);
  const [addressDialog, setAddressDialog] = reactExports.useState();
  const [currentAddresses, setCurrentAddresses] = reactExports.useState();
  const [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  const insured2 = (account2 == null ? void 0 : account2.bitsuranceStatus) === "active";
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const availableScriptTypes = reactExports.useRef();
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  const scriptTypeDialogOpened = !!(addressDialog && (hasManyScriptTypes || insured2));
  useEsc(() => !scriptTypeDialogOpened && !verifying && route(`/account/${code}`));
  reactExports.useEffect(() => {
    if (receiveAddresses) {
      availableScriptTypes.current = scriptTypes$1.filter((sc2) => getIndexOfMatchingScriptType$1(receiveAddresses, sc2) >= 0);
    }
  }, [receiveAddresses]);
  reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType$1(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      if (addressIndex === -1) {
        addressIndex = 0;
      }
      setCurrentAddressIndex(addressIndex);
      setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const handleSubmit = (e3) => {
    if (addressDialog) {
      e3.preventDefault();
      setActiveIndex(0);
      setAddressType(addressDialog.addressType);
      setAddressDialog(void 0);
    }
  };
  const verifyAddress2 = async (addressesIndex) => {
    if (!receiveAddresses || code === void 0) {
      return;
    }
    const connectResult = await connectKeystore(code);
    if (!connectResult.success) {
      return;
    }
    const hasSecureOutput$1 = await hasSecureOutput(code)();
    if (!hasSecureOutput$1.hasSecureOutput) {
      setVerifying("insecure");
      return;
    }
    setVerifying("secure");
    try {
      await verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID);
    } finally {
      setVerifying(false);
    }
  };
  const previous2 = (e3) => {
    e3.preventDefault();
    if (!verifying && activeIndex > 0) {
      setActiveIndex(activeIndex - 1);
    }
  };
  const next2 = (e3, numAddresses) => {
    e3.preventDefault();
    if (!verifying && activeIndex < numAddresses - 1) {
      setActiveIndex(activeIndex + 1);
    }
  };
  let uriPrefix = "";
  if (account2) {
    if (account2.coinCode === "btc" || account2.coinCode === "tbtc") {
      uriPrefix = "bitcoin:";
    } else if (account2.coinCode === "ltc" || account2.coinCode === "tltc") {
      uriPrefix = "litecoin:";
    }
  }
  let address2 = "";
  if (currentAddresses) {
    address2 = currentAddresses[activeIndex].address;
    if (!verifying) {
      address2 = address2.substring(0, 8) + "...";
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: void 0 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$E.labels, children: [
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.previous,
              onClick: previous2,
              children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$E.label, children: [
            t2("receive.label"),
            " ",
            currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
          ] }),
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.next,
              onClick: (e3) => next2(e3, currentAddresses.length),
              children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: true, value: address2, flexibleHeight: true }),
        (hasManyScriptTypes || insured2) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: style$E.changeType,
            onClick: () => setAddressDialog(!addressDialog ? { addressType } : void 0),
            children: t2("receive.changeScriptType")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: scriptTypeDialogOpened, onClose: () => setAddressDialog(void 0), medium: true, title: t2("receive.changeScriptType"), children: [
          availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio,
              {
                checked: addressDialog.addressType === i,
                id: scriptType,
                name: "scriptType",
                onChange: () => setAddressDialog({ addressType: i }),
                title: getScriptName(scriptType),
                children: t2(`receive.scriptType.${scriptType}`)
              }
            ),
            scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
          ] }) }, scriptType)),
          insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.bitsuranceWarning") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.done") }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              disabled: verifying !== false,
              onClick: () => verifyAddress2(currentAddressIndex),
              primary: true,
              children: t2("receive.verifyBitBox02")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonLink,
            {
              secondary: true,
              to: `/account/${code}`,
              children: t2("button.back")
            }
          )
        ] }),
        verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.hide }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: !!(account2 && verifying),
            title: t2("receive.verifyBitBox02"),
            disableEscape: verifying === "secure",
            onClose: verifying === "insecure" ? () => {
              setVerifying(false);
            } : void 0,
            medium: true,
            centered: true,
            children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                    coinName: account2.coinName
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  t2("receive.onlyThisCoin.description")
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: true }) })
            ] })
          }
        )
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : false,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : false
      }
    )
  ] });
};
const getDeviceList = () => {
  return apiGet("devices/registered");
};
const hasMobileChannel = (deviceID) => {
  return () => {
    return apiGet(`devices/${deviceID}/has-mobile-channel`);
  };
};
const container$h = "_container_1ooxc_1";
const withCloseBtn = "_withCloseBtn_1ooxc_7";
const status$2 = "_status_1ooxc_15";
const success$2 = "_success_1ooxc_21";
const warning$2 = "_warning_1ooxc_25";
const info$1 = "_info_1ooxc_29";
const close$1 = "_close_1ooxc_42";
const style$D = {
  container: container$h,
  withCloseBtn,
  status: status$2,
  success: success$2,
  warning: warning$2,
  info: info$1,
  "close-success": "_close-success_1ooxc_42",
  "close-warning": "_close-warning_1ooxc_46",
  "close-info": "_close-info_1ooxc_50",
  close: close$1
};
const Status = ({
  hidden,
  type: type2 = "warning",
  dismissible,
  className,
  children: children2
}) => {
  const [show2, setShow] = reactExports.useState(dismissible ? false : true);
  const checkConfig = reactExports.useCallback(async () => {
    if (dismissible) {
      const config = await getConfig();
      setShow(!config ? true : !config.frontend[dismissible]);
    }
  }, [dismissible]);
  reactExports.useEffect(() => {
    checkConfig();
  }, [checkConfig]);
  const dismiss = async () => {
    if (!dismissible) {
      return;
    }
    setConfig({
      frontend: {
        [dismissible]: true
      }
    });
    setShow(false);
  };
  if (hidden || !show2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$D.container, style$D[type2], className ? className : "", dismissible ? style$D.withCloseBtn : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$D.status, children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        hidden: !dismissible,
        className: `${style$D.close} ${style$D[`close-${type2}`]}`,
        onClick: dismiss,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
      }
    )
  ] }) });
};
const PairedWarning = ({
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const paired = useLoad(hasMobileChannel(deviceID));
  if (paired) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== false, children: t2("warning.receivePairing") });
};
const useVerifyLabel = (device2) => {
  const { t: t2 } = useTranslation();
  if (device2 === "bitbox") {
    return t2("receive.verifyBitBox01");
  } else if (device2 === "bitbox02") {
    return t2("receive.verifyBitBox02");
  }
  return t2("receive.verify");
};
const VerifyButton = ({
  device: device2,
  forceVerification,
  ...props
}) => {
  const { t: t2 } = useTranslation();
  const verifyLabel = useVerifyLabel(device2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, ...props, children: forceVerification ? t2("receive.showFull") : verifyLabel });
};
const scriptTypes = ["p2wpkh", "p2tr", "p2wpkh-p2sh"];
const getIndexOfMatchingScriptType = (receiveAddresses, scriptType) => {
  if (!receiveAddresses) {
    return -1;
  }
  return receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType);
};
const Receive$1 = ({
  accounts,
  code,
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const [activeIndex, setActiveIndex] = reactExports.useState(0);
  const [addressType, setAddressType] = reactExports.useState(0);
  const [addressDialog, setAddressDialog] = reactExports.useState();
  const [currentAddresses, setCurrentAddresses] = reactExports.useState();
  const [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  const verifyLabel = useVerifyLabel("bitbox");
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const secureOutput = useLoad(hasSecureOutput(code));
  useEsc(() => !verifying && route(`/account/${code}`));
  const availableScriptTypes = reactExports.useRef();
  reactExports.useEffect(() => {
    if (receiveAddresses) {
      availableScriptTypes.current = scriptTypes.filter((sc2) => getIndexOfMatchingScriptType(receiveAddresses, sc2) >= 0);
    }
  }, [receiveAddresses]);
  reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      if (addressIndex === -1) {
        addressIndex = 0;
      }
      setCurrentAddressIndex(addressIndex);
      setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const verifyAddress2 = (addressesIndex) => {
    if (receiveAddresses && secureOutput) {
      if (code === void 0) {
        return;
      }
      if (!secureOutput.hasSecureOutput) {
        alertUser(t2("receive.warning.secureOutput"));
        return;
      }
      setVerifying(true);
      verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID).then(() => setVerifying(false));
    }
  };
  const previous2 = (e3) => {
    e3.preventDefault();
    if (!verifying && activeIndex > 0) {
      setActiveIndex(activeIndex - 1);
    }
  };
  const next2 = (e3, numAddresses) => {
    e3.preventDefault();
    if (!verifying && activeIndex < numAddresses - 1) {
      setActiveIndex(activeIndex + 1);
    }
  };
  const forceVerification = secureOutput === void 0 ? true : secureOutput.hasSecureOutput && !secureOutput.optional;
  const enableCopy = !forceVerification;
  let uriPrefix = "";
  if (account2) {
    if (account2.coinCode === "btc" || account2.coinCode === "tbtc") {
      uriPrefix = "bitcoin:";
    } else if (account2.coinCode === "ltc" || account2.coinCode === "tltc") {
      uriPrefix = "litecoin:";
    }
  }
  let address2 = "";
  if (currentAddresses) {
    address2 = currentAddresses[activeIndex].address;
    if (!enableCopy && !verifying) {
      address2 = address2.substring(0, 8) + "...";
    }
  }
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PairedWarning, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: enableCopy ? uriPrefix + address2 : void 0 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$E.labels, children: [
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$E.previous,
                onClick: previous2,
                children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$E.label, children: [
              t2("receive.label"),
              " ",
              currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
            ] }),
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$E.next,
                onClick: (e3) => next2(e3, currentAddresses.length),
                children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !enableCopy, value: address2, flexibleHeight: true }),
          hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.changeType,
              onClick: () => setAddressDialog(!addressDialog ? { addressType } : void 0),
              children: t2("receive.changeScriptType")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: (e3) => {
            e3.preventDefault();
            setActiveIndex(0);
            setAddressType(addressDialog ? addressDialog == null ? void 0 : addressDialog.addressType : addressType);
            setAddressDialog(void 0);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !!addressDialog, medium: true, title: t2("receive.changeScriptType"), children: [
            availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Radio,
                {
                  checked: addressDialog.addressType === i,
                  id: scriptType,
                  name: "scriptType",
                  onChange: () => setAddressDialog({ addressType: i }),
                  title: getScriptName(scriptType),
                  children: t2(`receive.scriptType.${scriptType}`)
                }
              ),
              scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
            ] }) }, scriptType)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.done") }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              VerifyButton,
              {
                device: "bitbox",
                disabled: verifying || secureOutput === void 0,
                forceVerification,
                onClick: () => verifyAddress2(currentAddressIndex)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: true,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          ] }),
          forceVerification && verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.hide }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dialog,
            {
              open: !!account2 && forceVerification && verifying,
              title: verifyLabel,
              disableEscape: true,
              medium: true,
              centered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                      coinName: account2.coinName
                    }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                    t2("receive.onlyThisCoin.description")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: uriPrefix + address2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: true }) })
              ]
            }
          )
        ] }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : false,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : false
      }
    )
  ] });
};
const Receive = (props) => {
  const {
    devices,
    deviceIDs
  } = props;
  const deviceID = deviceIDs[0];
  const device2 = deviceIDs.length ? devices[deviceID] : void 0;
  switch (device2) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$1,
        {
          deviceID,
          ...props
        }
      );
    case "bitbox02":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$2,
        {
          ...props
        }
      );
  }
};
const RatesContext = reactExports.createContext({});
const subscriptions = {};
function handleMessages(payload) {
  if ("type" in payload && payload.data && typeof payload.data === "string" && payload.data in subscriptions && subscriptions[payload.data].length) {
    for (const observer of subscriptions[payload.data]) {
      observer(payload);
    }
  }
}
function subscribe(subject, observer) {
  if (!subscriptions[subject]) {
    subscriptions[subject] = [];
  }
  const observers = subscriptions[subject];
  if (observers.includes(observer)) {
    console.error(`observer already registered for ${subject}`);
  }
  observers.push(observer);
  return () => {
    if (!observers.includes(observer)) {
      console.error("!observers.includes(observer)");
    }
    const index2 = observers.indexOf(observer);
    observers.splice(index2, 1);
  };
}
apiWebsocket(handleMessages);
const syncAccountsList = (cb2) => {
  return subscribeEndpoint("accounts", cb2);
};
const syncAddressesCount = (code) => {
  return (cb2) => {
    return subscribeEndpoint(`account/${code}/synced-addresses-count`, (count) => {
      cb2(count);
    });
  };
};
const statusChanged$1 = (cb2) => {
  const unsubscribe2 = subscribe("statusChanged", (event2) => {
    if (event2.type === "account" && event2.code) {
      cb2(event2.code);
    }
  });
  return unsubscribe2;
};
const syncdone = (cb2) => {
  return subscribe("syncdone", (event2) => {
    if (event2.type === "account" && event2.code) {
      cb2(event2.code);
    }
  });
};
const subscribeCoinHeaders = (coinCode) => (cb2) => subscribeEndpoint(`coins/${coinCode}/headers/status`, cb2);
const setBtcUnit = (unit2) => {
  return apiPost("coins/btc/set-unit", { unit: unit2 });
};
const parseExternalBtcAmount = (amount2) => {
  return apiGet(`coins/btc/parse-external-amount?amount=${amount2}`);
};
const getDeviceInfo$1 = (deviceID) => {
  return apiGet(`devices/${deviceID}/info`);
};
const space = "_space_tpxrt_1";
const style$C = {
  space
};
const Amount = ({ amount: amount2, unit: unit2, removeBtcTrailingZeroes, alwaysShowAmounts = false }) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const formatSats = (amount22) => {
    const blocks = [];
    const blockSize = 3;
    for (let i = amount22.length; i > 0; i -= blockSize) {
      const start = Math.max(0, i - blockSize);
      blocks.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: start === 0 ? "" : style$C.space, children: amount22.slice(start, i) }, "block_" + blocks.length)
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "amountBlocks", children: blocks.reverse() });
  };
  const formatBtc = (amount22) => {
    const dot2 = amount22.indexOf(".");
    if (dot2 === -1) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount22 });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "amountBlocks", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: amount22.slice(0, dot2 + 3) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$C.space, children: amount22.slice(dot2 + 3, dot2 + 6) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$C.space, children: amount22.slice(dot2 + 6, dot2 + 9) })
    ] });
  };
  if (hideAmounts && !alwaysShowAmounts) {
    return "***";
  }
  switch (unit2) {
    case "BTC":
    case "TBTC":
    case "LTC":
    case "TLTC":
      if (removeBtcTrailingZeroes && amount2.includes(".")) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2.replace(/\.?0+$/, "") });
      } else {
        return formatBtc(amount2);
      }
    case "sat":
    case "tsat":
      return formatSats(amount2);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2 });
};
const rates = "_rates_19qqe_1";
const unit$1 = "_unit_19qqe_8";
const unitAction = "_unitAction_19qqe_13";
const fiatRow = "_fiatRow_19qqe_20";
const availableFiatAmount = "_availableFiatAmount_19qqe_24";
const availableFiatUnitNoAction = "_availableFiatUnitNoAction_19qqe_29";
const availableFiatUnit = "_availableFiatUnit_19qqe_29";
const notAvailable = "_notAvailable_19qqe_46";
const style$B = {
  rates,
  unit: unit$1,
  unitAction,
  fiatRow,
  availableFiatAmount,
  availableFiatUnitNoAction,
  availableFiatUnit,
  notAvailable
};
const currenciesWithDisplayName = [
  { currency: "AUD", displayName: "Australian Dollar" },
  { currency: "BRL", displayName: "Brazilian Real" },
  { currency: "CAD", displayName: "Canadian Dollar" },
  { currency: "CHF", displayName: "Swiss franc" },
  { currency: "CNY", displayName: "Chinese Yuan" },
  { currency: "CZK", displayName: "Czech Koruna" },
  { currency: "EUR", displayName: "Euro" },
  { currency: "GBP", displayName: "British Pound" },
  { currency: "HKD", displayName: "Hong Kong Dollar" },
  { currency: "ILS", displayName: "Israeli New Shekel" },
  { currency: "JPY", displayName: "Japanese Yen" },
  { currency: "KRW", displayName: "South Korean Won" },
  { currency: "NOK", displayName: "Norwegian Krone" },
  { currency: "PLN", displayName: "Polish Zloty" },
  { currency: "RUB", displayName: "Russian ruble" },
  { currency: "SEK", displayName: "Swedish Krona" },
  { currency: "SGD", displayName: "Singapore Dollar" },
  { currency: "USD", displayName: "United States Dollar" },
  { currency: "BTC", displayName: "Bitcoin" }
];
function Conversion({
  amount: amount2,
  tableRow,
  unstyled,
  skipUnit,
  noAction,
  sign,
  noBtcZeroes,
  alwaysShowAmounts = false
}) {
  const { rotateFiat, defaultCurrency: defaultCurrency2, btcUnit } = reactExports.useContext(RatesContext);
  let formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "---" });
  let isAvailable = false;
  let activeUnit = defaultCurrency2;
  if (defaultCurrency2 === "BTC" && btcUnit === "sat") {
    activeUnit = "sat";
  }
  if (amount2 && amount2.conversions && amount2.conversions[defaultCurrency2] && amount2.conversions[defaultCurrency2] !== "") {
    isAvailable = true;
    formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts, amount: amount2.conversions[defaultCurrency2], unit: activeUnit, removeBtcTrailingZeroes: !!noBtcZeroes });
  }
  if (tableRow) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: unstyled ? "" : style$B.fiatRow, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatAmount, children: formattedAmount }),
      !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatUnit, onClick: rotateFiat, children: activeUnit }),
      noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatUnitNoAction, children: activeUnit })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${style$B.rates} ${!isAvailable ? style$B.notAvailable : ""}`, children: [
    isAvailable ? sign : "",
    formattedAmount,
    " ",
    !skipUnit && !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$B.unitAction, onClick: rotateFiat, children: activeUnit }),
    !skipUnit && noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$B.unit, children: activeUnit })
  ] });
}
const formattedCurrencies = currenciesWithDisplayName.map((fiat2) => ({ label: `${fiat2.displayName} (${fiat2.currency})`, value: fiat2.currency }));
const FiatConversion = Conversion;
const balanceTable$1 = "_balanceTable_m2hui_1";
const availableAmount = "_availableAmount_m2hui_27";
const availableUnit = "_availableUnit_m2hui_32";
const pendingBalance = "_pendingBalance_m2hui_37";
const style$A = {
  balanceTable: balanceTable$1,
  availableAmount,
  availableUnit,
  pendingBalance
};
const Balance = ({
  balance: balance2,
  noRotateFiat
}) => {
  const { t: t2 } = useTranslation();
  if (!balance2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: style$A.balance });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: style$A.balance, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: style$A.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { "data-testid": "availableBalance", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$A.availableAmount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.available.amount,
            unit: balance2.available.unit,
            removeBtcTrailingZeroes: true
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$A.availableUnit, children: balance2.available.unit })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FiatConversion,
        {
          amount: balance2.available,
          tableRow: true,
          noAction: noRotateFiat,
          noBtcZeroes: true
        }
      )
    ] }) }),
    balance2.hasIncoming && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.pendingBalance, children: [
      t2("account.incoming"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "incomingBalance", children: [
        "+",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.incoming.amount,
            unit: balance2.incoming.unit,
            removeBtcTrailingZeroes: true
          }
        ),
        " ",
        balance2.incoming.unit,
        " /",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$A.incomingConversion, children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.incoming, noBtcZeroes: true })
        ] })
      ] })
    ] })
  ] });
};
const translate = withTranslation;
const row$2 = "_row_1qpuo_1";
const rowCustomFee = "_rowCustomFee_1qpuo_6";
const column = "_column_1qpuo_12";
const priority = "_priority_1qpuo_38";
const fee$1 = "_fee_1qpuo_42";
const feeCustom = "_feeCustom_1qpuo_91";
const feeDescription = "_feeDescription_1qpuo_95";
const feeProposed = "_feeProposed_1qpuo_96";
const customFeeUnit = "_customFeeUnit_1qpuo_112";
const style$z = {
  row: row$2,
  rowCustomFee,
  column,
  priority,
  fee: fee$1,
  feeCustom,
  feeDescription,
  feeProposed,
  customFeeUnit
};
const FeeTargets = ({
  accountCode,
  coinCode,
  disabled: disabled2,
  fiatUnit,
  proposedFee,
  customFee,
  showCalculatingFeeLabel,
  onFeeTargetChange,
  onCustomFee,
  error: error3
}) => {
  const { t: t2 } = useTranslation();
  const config = useLoad(getConfig);
  const [feeTarget, setFeeTarget] = reactExports.useState("");
  const [options2, setOptions] = reactExports.useState(null);
  const [noFeeTargets, setNoFeeTargets] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  const focusInput = reactExports.useCallback(() => {
    if (!disabled2 && inputRef.current && inputRef.current.autofocus) {
      inputRef.current.focus();
    }
  }, [disabled2]);
  reactExports.useEffect(() => {
    getFeeTargetList(accountCode).then(({ feeTargets, defaultFeeTarget }) => {
      if (config) {
        const expert = config.frontend.expertFee || feeTargets.length === 0;
        const options22 = feeTargets.map(({ code, feeRateInfo }) => ({
          value: code,
          text: t2(`send.feeTarget.label.${code}`) + (expert && feeRateInfo ? ` (${feeRateInfo})` : "")
        }));
        if (expert) {
          options22.push({
            value: "custom",
            text: t2("send.feeTarget.label.custom")
          });
        }
        setOptions(options22);
        setFeeTarget(defaultFeeTarget);
        onFeeTargetChange(defaultFeeTarget);
        if (feeTargets.length === 0) {
          setNoFeeTargets(true);
        }
      }
    }).catch(console.error);
    focusInput();
  }, [t2, focusInput, accountCode, config, onFeeTargetChange]);
  const handleFeeTargetChange = (event2) => {
    const target = event2.target;
    const value = target.options[target.selectedIndex].value;
    setFeeTarget(value);
    onFeeTargetChange(value);
  };
  const handleCustomFee = (event2) => {
    onCustomFee(event2.target.value);
  };
  const getProposeFeeText = () => {
    if (!proposedFee) {
      return "";
    }
    const { amount: amount2, unit: unit2, conversions } = proposedFee;
    return `${amount2} ${unit2} ${conversions ? ` = ${conversions[fiatUnit === "sat" ? "BTC" : fiatUnit]} ${fiatUnit}` : ""}`;
  };
  if (options2 === null) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.priority"),
        id: "feetarget",
        placeholder: t2("send.feeTarget.placeholder"),
        disabled: true,
        value: "",
        transparent: true
      }
    );
  }
  const isCustom = feeTarget === "custom";
  const hasOptions = options2.length > 0;
  const proposeFeeText = getProposeFeeText();
  const preventFocus = document.activeElement && document.activeElement.nodeName === "INPUT";
  return hasOptions ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    !isCustom ? showCalculatingFeeLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        disabled: true,
        label: t2("send.priority"),
        placeholder: t2("send.feeTarget.placeholder"),
        value: "",
        transparent: true
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select$1,
      {
        className: style$z.priority,
        label: t2("send.priority"),
        id: "feeTarget",
        disabled: disabled2,
        onChange: handleFeeTargetChange,
        value: feeTarget,
        options: options2
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$z.rowCustomFee, children: [
      noFeeTargets ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { small: true, type: "warning", children: t2("send.noFeeTargets") }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$z.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select$1,
        {
          className: style$z.priority,
          label: t2("send.priority"),
          id: "feeTarget",
          disabled: disabled2,
          onChange: handleFeeTargetChange,
          value: feeTarget,
          options: options2
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$z.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          type: disabled2 ? "text" : "number",
          min: "0",
          step: "any",
          autoFocus: !preventFocus,
          align: "right",
          className: `${style$z.fee} ${style$z.feeCustom}`,
          disabled: disabled2,
          label: t2("send.feeTarget.customLabel", {
            context: isEthereumBased(coinCode) ? "eth" : ""
          }),
          id: "proposedFee",
          placeholder: t2("send.fee.customPlaceholder"),
          error: error3,
          transparent: true,
          onInput: handleCustomFee,
          ref: inputRef,
          value: customFee,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$z.customFeeUnit, children: customFeeUnit$1(coinCode) })
        }
      ) })
    ] }),
    feeTarget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      showCalculatingFeeLabel || proposeFeeText ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$z.feeProposed, children: [
        t2("send.fee.label"),
        ":",
        " ",
        showCalculatingFeeLabel ? t2("send.feeTarget.placeholder") : proposeFeeText
      ] }) : null,
      !isCustom ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$z.feeDescription, children: [
        t2("send.feeTarget.estimate"),
        " ",
        t2(`send.feeTarget.description.${feeTarget}`, {
          context: getCoinCode(coinCode) || ""
        })
      ] }) : null
    ] })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      disabled: true,
      label: t2("send.fee.label"),
      id: "proposedFee",
      placeholder: t2("send.fee.placeholder"),
      error: error3,
      transparent: true,
      value: proposeFeeText
    }
  );
};
const syncDeviceList = (cb2) => {
  return subscribeEndpoint("devices/registered", cb2);
};
const statusChanged = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("statusChanged", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2();
    }
  });
  return unsubscribe2;
};
const channelHashChanged = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("channelHashChanged", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2(deviceID);
    }
  });
  return unsubscribe2;
};
const attestationCheckDone = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("attestationCheckDone", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2();
    }
  });
  return unsubscribe2;
};
const signProgress = (cb2) => {
  const unsubscribe2 = subscribe("signProgress", (event2) => {
    if ("type" in event2 && event2.type === "device" && event2.data === "signProgress") {
      cb2(event2.meta);
    }
  });
  return unsubscribe2;
};
const signConfirm = (cb2) => {
  const unsubscribe2 = subscribe("signConfirm", (event2) => {
    if ("type" in event2 && event2.type === "device" && event2.data === "signConfirm") {
      cb2();
    }
  });
  return unsubscribe2;
};
function unsubscribe(unsubscribeList) {
  for (const unsubscribeCallback of unsubscribeList) {
    unsubscribeCallback();
  }
  unsubscribeList.splice(0, unsubscribeList.length);
}
const approve$1 = "" + new URL("hold.png", import.meta.url).href;
const reject = "" + new URL("tap.png", import.meta.url).href;
class WaitDialog extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.state = {
      active: false
    };
    this.handleKeyDown = (e3) => {
      const activeElement = document.activeElement;
      if (activeElement && activeElement instanceof HTMLElement) {
        activeElement.blur();
      }
      e3.preventDefault();
      e3.stopPropagation();
    };
    this.activate = () => {
      this.setState({ active: true }, () => {
        if (!this.overlay.current || !this.modal.current) {
          return;
        }
        this.overlay.current.classList.add(style$13.activeOverlay);
        this.modal.current.classList.add(style$13.activeModal);
      });
    };
  }
  UNSAFE_componentWillMount() {
    document.body.addEventListener("keydown", this.handleKeyDown);
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.body.removeEventListener("keydown", this.handleKeyDown);
  }
  render() {
    const {
      t: t2,
      includeDefault,
      prequel,
      title: title2,
      paired = false,
      touchConfirm = true,
      children: children2
    } = this.props;
    const defaultContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      prequel && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: prequel }),
      paired ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$13.confirmationLabel, touchConfirm && paired ? style$13.disabledLabel : "", "m-top-none"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$13.confirmationLabelNumber, children: "1." }),
          t2("confirm.infoWhenPaired")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$13.confirmationLabel, !touchConfirm && paired ? style$13.disabledLabel : ""].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$13.confirmationLabelNumber, children: "2." }),
          t2("confirm.info")
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$13.confirmationLabel, style$13.noStep, "m-top-none"].join(" "), children: t2("confirm.info") }),
      touchConfirm && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-between flex-items-stretch", style$13.confirmationInstructions].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$13.image, src: reject, alt: "Reject" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.abortInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red", children: t2("confirm.abortInfoRedText") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$13.image, src: approve$1, alt: "Approve" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.approveInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green", children: t2("confirm.approveInfoGreenText") })
          ] })
        ] })
      ] })
    ] });
    const hasChildren = React.Children.toArray(children2).length > 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: style$13.overlay,
        ref: this.overlay,
        style: { zIndex: 10001 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$13.modal, style$13.open].join(" "), ref: this.modal, children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$13.title, children: title2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.contentContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.content, children: [
            hasChildren && includeDefault ? defaultContent : null,
            hasChildren ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-start", children: children2 }) : defaultContent
          ] }) })
        ] })
      }
    );
  }
}
const TranslatedWaitDialog = translate()(WaitDialog);
const confirmItem = "_confirmItem_1e5e5_1";
const confirmationValue = "_confirmationValue_1e5e5_6";
const total = "_total_1e5e5_15";
const style$y = {
  confirmItem,
  confirmationValue,
  total
};
const ConfirmingWaitDialog = ({
  paired,
  baseCurrencyUnit,
  note: note2,
  hasSelectedUTXOs,
  selectedUTXOs,
  coinCode,
  transactionStatus,
  transactionDetails
}) => {
  const { t: t2 } = useTranslation();
  const { isConfirming, signConfirm: signConfirm2, signProgress: signProgress2 } = transactionStatus;
  const {
    proposedFee,
    proposedAmount,
    proposedTotal,
    customFee,
    feeTarget,
    recipientAddress,
    fiatUnit
  } = transactionDetails;
  if (!isConfirming) {
    return null;
  }
  const confirmPrequel = signProgress2 && signProgress2.steps > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    t2("send.signprogress.description", {
      steps: signProgress2.steps.toString()
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    t2("send.signprogress.label"),
    ": ",
    signProgress2.step,
    "/",
    signProgress2.steps
  ] }) : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TranslatedWaitDialog,
    {
      title: t2("send.confirm.title"),
      prequel: confirmPrequel,
      paired,
      touchConfirm: signConfirm2,
      includeDefault: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.address.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: recipientAddress || "N/A" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.amount.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedAmount && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedAmount.amount, unit: proposedAmount.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedAmount && proposedAmount.unit || "N/A" })
            ] }, "proposedAmount"),
            proposedAmount && proposedAmount.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedAmount.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: note2 })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            t2("send.fee.label"),
            feeTarget ? " (" + t2(`send.feeTarget.label.${feeTarget}`) + ")" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedFee && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedFee.amount, unit: proposedFee.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedFee && proposedFee.unit || "N/A" })
            ] }, "amount"),
            proposedFee && proposedFee.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedFee.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] }, "conversation"),
            customFee ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "(",
                customFee,
                " ",
                customFeeUnit$1(coinCode),
                ")"
              ] })
            ] }, "customFee") : null
          ] })
        ] }),
        hasSelectedUTXOs && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$y.confirmItem].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.selected-coins") }),
          selectedUTXOs.map((uxto, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$y.confirmationValue, children: uxto }, `selectedCoin-${i}`))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$y.confirmItem, style$y.total].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.total") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: proposedTotal && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedTotal.amount, unit: proposedTotal.unit }) || "N/A" }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedTotal && proposedTotal.unit || "N/A" })
            ] }),
            proposedTotal && proposedTotal.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedTotal.conversions[fiatUnit], unit: baseCurrencyUnit }) }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] })
      ]
    }
  );
};
const SendGuide = ({ coinCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.whyFee") }, "guide.send.whyFee"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.priority") }, "guide.send.priority"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.fee") }, "guide.send.fee"),
    isBitcoinOnly(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.change") }, "guide.send.change"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.revert") }, "guide.send.revert"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.plugout") }, "guide.send.plugout")
  ] });
};
const MessageWaitDialog = ({ isShown, messageType }) => {
  if (!isShown) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-center flex-items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconAndMessage, { messageType }) }) });
};
const IconAndMessage = ({ messageType }) => {
  const { t: t2 } = useTranslation();
  switch (messageType) {
    case "sent":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, { style: { height: 18, marginRight: "1rem" } }),
        t2("send.success")
      ] });
    case "abort":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { alt: "Abort", style: { height: 18, marginRight: "1rem" } }),
        t2("send.abort")
      ] });
    default:
      return null;
  }
};
const useMediaQuery = (query) => {
  const getMatches = (query2) => window.matchMedia(query2).matches;
  const [matches, setMatches] = reactExports.useState(getMatches(query));
  reactExports.useEffect(() => {
    const handleChange = () => {
      setMatches(getMatches(query));
    };
    const matchMedia = window.matchMedia(query);
    handleChange();
    matchMedia.addEventListener("change", handleChange);
    return () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]);
  return matches;
};
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link2 = document.createElement("link");
    link2.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link2.as = "script";
      link2.crossOrigin = "";
    }
    link2.href = dep;
    document.head.appendChild(link2);
    if (isCss) {
      return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e3 = new Event("vite:preloadError", { cancelable: true });
    e3.payload = err;
    window.dispatchEvent(e3);
    if (!e3.defaultPrevented) {
      throw err;
    }
  });
};
let e$1 = class e {
  constructor(a2, b2, c2, d2, f2) {
    this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE;
    this._preferredCamera = "environment";
    this._maxScansPerSecond = 25;
    this._lastScanTimestamp = -1;
    this._destroyed = this._flashOn = this._paused = this._active = false;
    this.$video = a2;
    this.$canvas = document.createElement("canvas");
    c2 && "object" === typeof c2 ? this._onDecode = b2 : (c2 || d2 || f2 ? console.warn("You're using a deprecated version of the QrScanner constructor which will be removed in the future") : console.warn("Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), this._legacyOnDecode = b2);
    b2 = "object" === typeof c2 ? c2 : {};
    this._onDecodeError = b2.onDecodeError || ("function" === typeof c2 ? c2 : this._onDecodeError);
    this._calculateScanRegion = b2.calculateScanRegion || ("function" === typeof d2 ? d2 : this._calculateScanRegion);
    this._preferredCamera = b2.preferredCamera || f2 || this._preferredCamera;
    this._legacyCanvasSize = "number" === typeof c2 ? c2 : "number" === typeof d2 ? d2 : this._legacyCanvasSize;
    this._maxScansPerSecond = b2.maxScansPerSecond || this._maxScansPerSecond;
    this._onPlay = this._onPlay.bind(this);
    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);
    this._onVisibilityChange = this._onVisibilityChange.bind(this);
    this._updateOverlay = this._updateOverlay.bind(this);
    a2.disablePictureInPicture = true;
    a2.playsInline = true;
    a2.muted = true;
    let h2 = false;
    a2.hidden && (a2.hidden = false, h2 = true);
    document.body.contains(a2) || (document.body.appendChild(a2), h2 = true);
    c2 = a2.parentElement;
    if (b2.highlightScanRegion || b2.highlightCodeOutline) {
      d2 = !!b2.overlay;
      this.$overlay = b2.overlay || document.createElement("div");
      f2 = this.$overlay.style;
      f2.position = "absolute";
      f2.display = "none";
      f2.pointerEvents = "none";
      this.$overlay.classList.add("scan-region-highlight");
      if (!d2 && b2.highlightScanRegion) {
        this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
        try {
          this.$overlay.firstElementChild.animate({ transform: [
            "scale(.98)",
            "scale(1.01)"
          ] }, { duration: 400, iterations: Infinity, direction: "alternate", easing: "ease-in-out" });
        } catch (m2) {
        }
        c2.insertBefore(this.$overlay, this.$video.nextSibling);
      }
      b2.highlightCodeOutline && (this.$overlay.insertAdjacentHTML("beforeend", '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);
    }
    this._scanRegion = this._calculateScanRegion(a2);
    requestAnimationFrame(() => {
      let m2 = window.getComputedStyle(a2);
      "none" === m2.display && (a2.style.setProperty("display", "block", "important"), h2 = true);
      "visible" !== m2.visibility && (a2.style.setProperty("visibility", "visible", "important"), h2 = true);
      h2 && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), a2.style.opacity = "0", a2.style.width = "0", a2.style.height = "0", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight);
      this.$overlay && this._updateOverlay();
    });
    a2.addEventListener("play", this._onPlay);
    a2.addEventListener("loadedmetadata", this._onLoadedMetaData);
    document.addEventListener("visibilitychange", this._onVisibilityChange);
    window.addEventListener("resize", this._updateOverlay);
    this._qrEnginePromise = e.createQrEngine();
  }
  static set WORKER_PATH(a2) {
    console.warn("Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.");
  }
  static async hasCamera() {
    try {
      return !!(await e.listCameras(false)).length;
    } catch (a2) {
      return false;
    }
  }
  static async listCameras(a2 = false) {
    if (!navigator.mediaDevices)
      return [];
    let b2 = async () => (await navigator.mediaDevices.enumerateDevices()).filter((d2) => "videoinput" === d2.kind), c2;
    try {
      a2 && (await b2()).every((d2) => !d2.label) && (c2 = await navigator.mediaDevices.getUserMedia({ audio: false, video: true }));
    } catch (d2) {
    }
    try {
      return (await b2()).map((d2, f2) => ({ id: d2.deviceId, label: d2.label || (0 === f2 ? "Default Camera" : `Camera ${f2 + 1}`) }));
    } finally {
      c2 && (console.warn("Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"), e._stopVideoStream(c2));
    }
  }
  async hasFlash() {
    let a2;
    try {
      if (this.$video.srcObject) {
        if (!(this.$video.srcObject instanceof MediaStream))
          return false;
        a2 = this.$video.srcObject;
      } else
        a2 = (await this._getCameraStream()).stream;
      return "torch" in a2.getVideoTracks()[0].getSettings();
    } catch (b2) {
      return false;
    } finally {
      a2 && a2 !== this.$video.srcObject && (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), e._stopVideoStream(a2));
    }
  }
  isFlashOn() {
    return this._flashOn;
  }
  async toggleFlash() {
    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();
  }
  async turnFlashOn() {
    if (!this._flashOn && !this._destroyed && (this._flashOn = true, this._active && !this._paused))
      try {
        if (!await this.hasFlash())
          throw "No flash available";
        await this.$video.srcObject.getVideoTracks()[0].applyConstraints({ advanced: [{ torch: true }] });
      } catch (a2) {
        throw this._flashOn = false, a2;
      }
  }
  async turnFlashOff() {
    this._flashOn && (this._flashOn = false, await this._restartVideoStream());
  }
  destroy() {
    this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData);
    this.$video.removeEventListener("play", this._onPlay);
    document.removeEventListener(
      "visibilitychange",
      this._onVisibilityChange
    );
    window.removeEventListener("resize", this._updateOverlay);
    this._destroyed = true;
    this._flashOn = false;
    this.stop();
    e._postWorkerMessage(this._qrEnginePromise, "close");
  }
  async start() {
    if (this._destroyed)
      throw Error("The QR scanner can not be started as it had been destroyed.");
    if (!this._active || this._paused) {
      if ("https:" !== window.location.protocol && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = true, !document.hidden)
        if (this._paused = false, this.$video.srcObject)
          await this.$video.play();
        else
          try {
            let { stream: a2, facingMode: b2 } = await this._getCameraStream();
            !this._active || this._paused ? e._stopVideoStream(a2) : (this._setVideoMirror(b2), this.$video.srcObject = a2, await this.$video.play(), this._flashOn && (this._flashOn = false, this.turnFlashOn().catch(() => {
            })));
          } catch (a2) {
            if (!this._paused)
              throw this._active = false, a2;
          }
    }
  }
  stop() {
    this.pause();
    this._active = false;
  }
  async pause(a2 = false) {
    this._paused = true;
    if (!this._active)
      return true;
    this.$video.pause();
    this.$overlay && (this.$overlay.style.display = "none");
    let b2 = () => {
      this.$video.srcObject instanceof MediaStream && (e._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);
    };
    if (a2)
      return b2(), true;
    await new Promise((c2) => setTimeout(c2, 300));
    if (!this._paused)
      return false;
    b2();
    return true;
  }
  async setCamera(a2) {
    a2 !== this._preferredCamera && (this._preferredCamera = a2, await this._restartVideoStream());
  }
  static async scanImage(a2, b2, c2, d2, f2 = false, h2 = false) {
    let m2, n2 = false;
    b2 && ("scanRegion" in b2 || "qrEngine" in b2 || "canvas" in b2 || "disallowCanvasResizing" in b2 || "alsoTryWithoutScanRegion" in b2 || "returnDetailedScanResult" in b2) ? (m2 = b2.scanRegion, c2 = b2.qrEngine, d2 = b2.canvas, f2 = b2.disallowCanvasResizing || false, h2 = b2.alsoTryWithoutScanRegion || false, n2 = true) : b2 || c2 || d2 || f2 || h2 ? console.warn("You're using a deprecated api for scanImage which will be removed in the future.") : console.warn("Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.");
    b2 = !!c2;
    try {
      let p2, k2;
      [c2, p2] = await Promise.all([c2 || e.createQrEngine(), e._loadImage(a2)]);
      [d2, k2] = e._drawToCanvas(p2, m2, d2, f2);
      let q2;
      if (c2 instanceof Worker) {
        let g2 = c2;
        b2 || e._postWorkerMessageSync(g2, "inversionMode", "both");
        q2 = await new Promise((l2, v2) => {
          let w2, u2, r2, y2 = -1;
          u2 = (t2) => {
            t2.data.id === y2 && (g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), null !== t2.data.data ? l2({ data: t2.data.data, cornerPoints: e._convertPoints(t2.data.cornerPoints, m2) }) : v2(e.NO_QR_CODE_FOUND));
          };
          r2 = (t2) => {
            g2.removeEventListener("message", u2);
            g2.removeEventListener("error", r2);
            clearTimeout(w2);
            v2("Scanner error: " + (t2 ? t2.message || t2 : "Unknown Error"));
          };
          g2.addEventListener("message", u2);
          g2.addEventListener("error", r2);
          w2 = setTimeout(() => r2("timeout"), 1e4);
          let x2 = k2.getImageData(0, 0, d2.width, d2.height);
          y2 = e._postWorkerMessageSync(g2, "decode", x2, [x2.data.buffer]);
        });
      } else
        q2 = await Promise.race([new Promise((g2, l2) => window.setTimeout(() => l2("Scanner error: timeout"), 1e4)), (async () => {
          try {
            var [g2] = await c2.detect(d2);
            if (!g2)
              throw e.NO_QR_CODE_FOUND;
            return { data: g2.rawValue, cornerPoints: e._convertPoints(g2.cornerPoints, m2) };
          } catch (l2) {
            g2 = l2.message || l2;
            if (/not implemented|service unavailable/.test(g2))
              return e._disableBarcodeDetector = true, e.scanImage(a2, { scanRegion: m2, canvas: d2, disallowCanvasResizing: f2, alsoTryWithoutScanRegion: h2 });
            throw `Scanner error: ${g2}`;
          }
        })()]);
      return n2 ? q2 : q2.data;
    } catch (p2) {
      if (!m2 || !h2)
        throw p2;
      let k2 = await e.scanImage(a2, { qrEngine: c2, canvas: d2, disallowCanvasResizing: f2 });
      return n2 ? k2 : k2.data;
    } finally {
      b2 || e._postWorkerMessage(c2, "close");
    }
  }
  setGrayscaleWeights(a2, b2, c2, d2 = true) {
    e._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
      red: a2,
      green: b2,
      blue: c2,
      useIntegerApproximation: d2
    });
  }
  setInversionMode(a2) {
    e._postWorkerMessage(this._qrEnginePromise, "inversionMode", a2);
  }
  static async createQrEngine(a2) {
    a2 && console.warn("Specifying a worker path is not required and not supported anymore.");
    a2 = () => __vitePreload(() => import("./qr-scanner-worker.min.js"), true ? [] : void 0, import.meta.url).then((c2) => c2.createWorker());
    if (!(!e._disableBarcodeDetector && "BarcodeDetector" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes("qr_code")))
      return a2();
    let b2 = navigator.userAgentData;
    return b2 && b2.brands.some(({ brand: c2 }) => /Chromium/i.test(c2)) && /mac ?OS/i.test(b2.platform) && await b2.getHighEntropyValues(["architecture", "platformVersion"]).then(({ architecture: c2, platformVersion: d2 }) => /arm/i.test(c2 || "arm") && 13 <= parseInt(d2 || "13")).catch(() => true) ? a2() : new BarcodeDetector({ formats: ["qr_code"] });
  }
  _onPlay() {
    this._scanRegion = this._calculateScanRegion(this.$video);
    this._updateOverlay();
    this.$overlay && (this.$overlay.style.display = "");
    this._scanFrame();
  }
  _onLoadedMetaData() {
    this._scanRegion = this._calculateScanRegion(this.$video);
    this._updateOverlay();
  }
  _onVisibilityChange() {
    document.hidden ? this.pause() : this._active && this.start();
  }
  _calculateScanRegion(a2) {
    let b2 = Math.round(2 / 3 * Math.min(a2.videoWidth, a2.videoHeight));
    return { x: Math.round((a2.videoWidth - b2) / 2), y: Math.round((a2.videoHeight - b2) / 2), width: b2, height: b2, downScaledWidth: this._legacyCanvasSize, downScaledHeight: this._legacyCanvasSize };
  }
  _updateOverlay() {
    requestAnimationFrame(() => {
      if (this.$overlay) {
        var a2 = this.$video, b2 = a2.videoWidth, c2 = a2.videoHeight, d2 = a2.offsetWidth, f2 = a2.offsetHeight, h2 = a2.offsetLeft, m2 = a2.offsetTop, n2 = window.getComputedStyle(a2), p2 = n2.objectFit, k2 = b2 / c2, q2 = d2 / f2;
        switch (p2) {
          case "none":
            var g2 = b2;
            var l2 = c2;
            break;
          case "fill":
            g2 = d2;
            l2 = f2;
            break;
          default:
            ("cover" === p2 ? k2 > q2 : k2 < q2) ? (l2 = f2, g2 = l2 * k2) : (g2 = d2, l2 = g2 / k2), "scale-down" === p2 && (g2 = Math.min(g2, b2), l2 = Math.min(l2, c2));
        }
        var [v2, w2] = n2.objectPosition.split(" ").map((r2, y2) => {
          const x2 = parseFloat(r2);
          return r2.endsWith("%") ? (y2 ? f2 - l2 : d2 - g2) * x2 / 100 : x2;
        });
        n2 = this._scanRegion.width || b2;
        q2 = this._scanRegion.height || c2;
        p2 = this._scanRegion.x || 0;
        var u2 = this._scanRegion.y || 0;
        k2 = this.$overlay.style;
        k2.width = `${n2 / b2 * g2}px`;
        k2.height = `${q2 / c2 * l2}px`;
        k2.top = `${m2 + w2 + u2 / c2 * l2}px`;
        c2 = /scaleX\(-1\)/.test(a2.style.transform);
        k2.left = `${h2 + (c2 ? d2 - v2 - g2 : v2) + (c2 ? b2 - p2 - n2 : p2) / b2 * g2}px`;
        k2.transform = a2.style.transform;
      }
    });
  }
  static _convertPoints(a2, b2) {
    if (!b2)
      return a2;
    let c2 = b2.x || 0, d2 = b2.y || 0, f2 = b2.width && b2.downScaledWidth ? b2.width / b2.downScaledWidth : 1;
    b2 = b2.height && b2.downScaledHeight ? b2.height / b2.downScaledHeight : 1;
    for (let h2 of a2)
      h2.x = h2.x * f2 + c2, h2.y = h2.y * b2 + d2;
    return a2;
  }
  _scanFrame() {
    !this._active || this.$video.paused || this.$video.ended || ("requestVideoFrameCallback" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {
      if (!(1 >= this.$video.readyState)) {
        var a2 = Date.now() - this._lastScanTimestamp, b2 = 1e3 / this._maxScansPerSecond;
        a2 < b2 && await new Promise((d2) => setTimeout(d2, b2 - a2));
        this._lastScanTimestamp = Date.now();
        try {
          var c2 = await e.scanImage(this.$video, { scanRegion: this._scanRegion, qrEngine: this._qrEnginePromise, canvas: this.$canvas });
        } catch (d2) {
          if (!this._active)
            return;
          this._onDecodeError(d2);
        }
        !e._disableBarcodeDetector || await this._qrEnginePromise instanceof Worker || (this._qrEnginePromise = e.createQrEngine());
        c2 ? (this._onDecode ? this._onDecode(c2) : this._legacyOnDecode && this._legacyOnDecode(c2.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute("viewBox", `${this._scanRegion.x || 0} ${this._scanRegion.y || 0} ${this._scanRegion.width || this.$video.videoWidth} ${this._scanRegion.height || this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute(
          "points",
          c2.cornerPoints.map(({ x: d2, y: f2 }) => `${d2},${f2}`).join(" ")
        ), this.$codeOutlineHighlight.style.display = "")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = "none", 100));
      }
      this._scanFrame();
    });
  }
  _onDecodeError(a2) {
    a2 !== e.NO_QR_CODE_FOUND && console.log(a2);
  }
  async _getCameraStream() {
    if (!navigator.mediaDevices)
      throw "Camera not found.";
    let a2 = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId", b2 = [{ width: { min: 1024 } }, { width: { min: 768 } }, {}], c2 = b2.map((d2) => Object.assign({}, d2, { [a2]: { exact: this._preferredCamera } }));
    for (let d2 of [...c2, ...b2])
      try {
        let f2 = await navigator.mediaDevices.getUserMedia({ video: d2, audio: false }), h2 = this._getFacingMode(f2) || (d2.facingMode ? this._preferredCamera : "environment" === this._preferredCamera ? "user" : "environment");
        return { stream: f2, facingMode: h2 };
      } catch (f2) {
      }
    throw "Camera not found.";
  }
  async _restartVideoStream() {
    let a2 = this._paused;
    await this.pause(true) && !a2 && this._active && await this.start();
  }
  static _stopVideoStream(a2) {
    for (let b2 of a2.getTracks())
      b2.stop(), a2.removeTrack(b2);
  }
  _setVideoMirror(a2) {
    this.$video.style.transform = "scaleX(" + ("user" === a2 ? -1 : 1) + ")";
  }
  _getFacingMode(a2) {
    return (a2 = a2.getVideoTracks()[0]) ? /rear|back|environment/i.test(a2.label) ? "environment" : /front|user|face/i.test(a2.label) ? "user" : null : null;
  }
  static _drawToCanvas(a2, b2, c2, d2 = false) {
    c2 = c2 || document.createElement("canvas");
    let f2 = b2 && b2.x ? b2.x : 0, h2 = b2 && b2.y ? b2.y : 0, m2 = b2 && b2.width ? b2.width : a2.videoWidth || a2.width, n2 = b2 && b2.height ? b2.height : a2.videoHeight || a2.height;
    d2 || (d2 = b2 && b2.downScaledWidth ? b2.downScaledWidth : m2, b2 = b2 && b2.downScaledHeight ? b2.downScaledHeight : n2, c2.width !== d2 && (c2.width = d2), c2.height !== b2 && (c2.height = b2));
    b2 = c2.getContext("2d", { alpha: false });
    b2.imageSmoothingEnabled = false;
    b2.drawImage(a2, f2, h2, m2, n2, 0, 0, c2.width, c2.height);
    return [c2, b2];
  }
  static async _loadImage(a2) {
    if (a2 instanceof Image)
      return await e._awaitImageLoad(a2), a2;
    if (a2 instanceof HTMLVideoElement || a2 instanceof HTMLCanvasElement || a2 instanceof SVGImageElement || "OffscreenCanvas" in window && a2 instanceof OffscreenCanvas || "ImageBitmap" in window && a2 instanceof ImageBitmap)
      return a2;
    if (a2 instanceof File || a2 instanceof Blob || a2 instanceof URL || "string" === typeof a2) {
      let b2 = new Image();
      b2.src = a2 instanceof File || a2 instanceof Blob ? URL.createObjectURL(a2) : a2.toString();
      try {
        return await e._awaitImageLoad(b2), b2;
      } finally {
        (a2 instanceof File || a2 instanceof Blob) && URL.revokeObjectURL(b2.src);
      }
    } else
      throw "Unsupported image type.";
  }
  static async _awaitImageLoad(a2) {
    a2.complete && 0 !== a2.naturalWidth || await new Promise((b2, c2) => {
      let d2 = (f2) => {
        a2.removeEventListener("load", d2);
        a2.removeEventListener("error", d2);
        f2 instanceof ErrorEvent ? c2("Image load error") : b2();
      };
      a2.addEventListener("load", d2);
      a2.addEventListener("error", d2);
    });
  }
  static async _postWorkerMessage(a2, b2, c2, d2) {
    return e._postWorkerMessageSync(await a2, b2, c2, d2);
  }
  static _postWorkerMessageSync(a2, b2, c2, d2) {
    if (!(a2 instanceof Worker))
      return -1;
    let f2 = e._workerMessageId++;
    a2.postMessage({ id: f2, type: b2, data: c2 }, d2);
    return f2;
  }
};
e$1.DEFAULT_CANVAS_SIZE = 400;
e$1.NO_QR_CODE_FOUND = "No QR code found";
e$1._disableBarcodeDetector = false;
e$1._workerMessageId = 0;
const useQRScanner = (videoRef, {
  onStart,
  onResult,
  onError
}) => {
  const { t: t2 } = useTranslation();
  const [initErrorMessage, setInitErrorMessage] = reactExports.useState();
  const scanner = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (videoRef.current && !scanner.current) {
      scanner.current = new e$1(
        videoRef.current,
        (result) => {
          var _a;
          (_a = scanner.current) == null ? void 0 : _a.stop();
          onResult(result);
        },
        {
          onDecodeError: (err) => {
            const errorString = err.toString();
            if (err && !errorString.includes("No QR code found")) {
              onError(err);
            }
          },
          highlightScanRegion: true,
          highlightCodeOutline: true,
          calculateScanRegion: (v2) => {
            const videoWidth = v2.videoWidth;
            const videoHeight = v2.videoHeight;
            const factor = 0.5;
            const size2 = Math.floor(Math.min(videoWidth, videoHeight) * factor);
            return {
              x: (videoWidth - size2) / 2,
              y: (videoHeight - size2) / 2,
              width: size2,
              height: size2
            };
          }
        }
      );
    }
  });
  reactExports.useEffect(() => {
    (async () => {
      var _a;
      try {
        await ((_a = scanner.current) == null ? void 0 : _a.start());
        if (onStart) {
          onStart();
        }
      } catch (error3) {
        const stringifiedError = error3.toString();
        const cameraNotFound = stringifiedError === "Camera not found.";
        setInitErrorMessage(cameraNotFound ? t2("send.scanQRNoCameraMessage") : stringifiedError);
      }
    })();
  }, [videoRef, onStart, onResult, onError, t2]);
  reactExports.useEffect(() => {
    return () => {
      var _a, _b;
      (_a = scanner.current) == null ? void 0 : _a.stop();
      (_b = scanner.current) == null ? void 0 : _b.destroy();
      scanner.current = null;
    };
  });
  return { initErrorMessage };
};
const spinnerAnimationContainer = "_spinnerAnimationContainer_1utsx_1";
const qrVideo = "_qrVideo_1utsx_13";
const style$x = {
  spinnerAnimationContainer,
  qrVideo
};
const ScanQRVideo = ({
  onResult
}) => {
  const videoRef = reactExports.useRef(null);
  const { initErrorMessage } = useQRScanner(videoRef, {
    onResult: (result) => onResult(result.data),
    onError: (err) => console.error(err)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$x.spinnerAnimationContainer, children: initErrorMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: initErrorMessage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        className: style$x.qrVideo,
        ref: videoRef,
        poster: "data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%3E%20width=%2264%22%20height=%2248%22%3C/svg%3E"
      }
    )
  ] });
};
const ScanQRDialog = ({
  parseQRResult,
  toggleScanQR,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: true,
      fullscreen: true,
      dialog: !isMobile,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ScanQRVideo,
          {
            onResult: (result) => {
              parseQRResult(result);
              onChangeActiveScanQR(false);
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { reverseRow: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: toggleScanQR,
            children: t2("button.back")
          }
        ) })
      ]
    }
  );
};
const inputWithIcon$1 = "_inputWithIcon_drrz7_1";
const action$2 = "_action_drrz7_9";
const qrButton = "_qrButton_drrz7_18";
const style$w = {
  inputWithIcon: inputWithIcon$1,
  action: action$2,
  qrButton
};
const ScanQRButton = ({ onClick }) => {
  const { isDarkMode } = reactExports.useContext(DarkModeContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick, className: style$w.qrButton, children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeDark, {}) });
};
const ReceiverAddressInput = ({
  accountCode,
  addressError,
  onInputChange,
  recipientAddress,
  activeScanQR,
  parseQRResult,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation();
  reactExports.useCallback(async () => {
    if (!accountCode) {
      return;
    }
    try {
      const receiveAddresses = await getReceiveAddressList(accountCode)();
      if (receiveAddresses && receiveAddresses.length > 0 && receiveAddresses[0].addresses.length > 1) {
        onInputChange(receiveAddresses[0].addresses[0].address);
      }
    } catch (e3) {
      console.error(e3);
    }
  }, [accountCode, onInputChange]);
  const toggleScanQR = reactExports.useCallback(() => {
    if (activeScanQR) {
      onChangeActiveScanQR(false);
      return;
    }
    onChangeActiveScanQR(true);
  }, [activeScanQR, onChangeActiveScanQR]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    activeScanQR && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScanQRDialog,
      {
        toggleScanQR,
        onChangeActiveScanQR,
        parseQRResult
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.address.label"),
        placeholder: t2("send.address.placeholder"),
        id: "recipientAddress",
        error: addressError,
        onInput: (e3) => onInputChange(e3.target.value),
        value: recipientAddress,
        className: style$w.inputWithIcon,
        labelSection: void 0,
        autoFocus: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
      }
    )
  ] });
};
const maxAmount = "_maxAmount_1t5n0_1";
const style$v = {
  maxAmount
};
const CoinInput = ({
  balance: balance2,
  onAmountChange,
  onSendAllChange,
  sendAll,
  amountError,
  proposedAmount,
  amount: amount2,
  hasSelectedUTXOs
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: balance2 ? balance2.available.unit : t2("send.amount.label"),
      id: "amount",
      onInput: (e3) => onAmountChange(e3.target.value),
      disabled: sendAll,
      error: amountError,
      value: sendAll ? proposedAmount ? proposedAmount.amount : "" : amount2,
      placeholder: t2("send.amount.placeholder"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          label: t2(hasSelectedUTXOs ? "send.maximumSelectedCoins" : "send.maximum"),
          id: "sendAll",
          onChange: (e3) => onSendAllChange(e3.target.checked),
          checked: sendAll,
          className: style$v.maxAmount
        }
      )
    }
  );
};
const FiatInput = ({ label: label2, onFiatChange, disabled: disabled2, error: error3, fiatAmount }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: label2,
      id: "fiatAmount",
      onInput: onFiatChange,
      disabled: disabled2,
      error: error3,
      value: fiatAmount,
      placeholder: t2("send.amount.placeholder")
    }
  );
};
const labelDescription = "_labelDescription_5etm5_1";
const style$u = {
  labelDescription
};
const NoteInput = ({ onNoteChange, note: note2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      label: t2("note.title"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.labelDescription, children: t2("note.input.description") }),
      id: "note",
      onInput: onNoteChange,
      value: note2,
      placeholder: t2("note.input.placeholder")
    }
  );
};
const utxosList = "_utxosList_8ra1q_1";
const utxo = "_utxo_8ra1q_1";
const utxoContent = "_utxoContent_8ra1q_17";
const note = "_note_8ra1q_25";
const utxoData = "_utxoData_8ra1q_33";
const utxoExplorer = "_utxoExplorer_8ra1q_41";
const amounts = "_amounts_8ra1q_51";
const amount$1 = "_amount_8ra1q_51";
const label$3 = "_label_8ra1q_59";
const unit = "_unit_8ra1q_60";
const address$2 = "_address_8ra1q_73";
const transaction = "_transaction_8ra1q_74";
const shrink = "_shrink_8ra1q_81";
const style$t = {
  utxosList,
  utxo,
  utxoContent,
  note,
  utxoData,
  utxoExplorer,
  amounts,
  amount: amount$1,
  label: label$3,
  unit,
  address: address$2,
  transaction,
  shrink
};
const UTXOs = ({
  accountCode,
  active: active2,
  explorerURL,
  onChange: onChange2,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  const [utxos, setUtxos] = reactExports.useState([]);
  const [selectedUTXOs, setSelectedUTXOs] = reactExports.useState({});
  reactExports.useEffect(() => {
    getUTXOs(accountCode).then(setUtxos);
    return () => setUtxos([]);
  }, [accountCode]);
  reactExports.useEffect(() => {
    const unsubscribe2 = syncdone((code) => {
      if (accountCode === code) {
        getUTXOs(accountCode).then(setUtxos);
      }
    });
    return () => unsubscribe2();
  }, [accountCode]);
  const handleUTXOChange = (event2) => {
    const target = event2.target;
    const outPoint = target.dataset.outpoint;
    const proposedUTXOs = Object.assign({}, selectedUTXOs);
    if (target.checked) {
      proposedUTXOs[outPoint] = true;
    } else {
      delete proposedUTXOs[outPoint];
    }
    setSelectedUTXOs(proposedUTXOs);
    onChange2(proposedUTXOs);
  };
  const renderUTXOs = (scriptType) => {
    const filteredUTXOs = utxos.filter((utxo2) => utxo2.scriptType === scriptType);
    if (filteredUTXOs.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "subTitle", children: getScriptName(scriptType) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$t.utxosList, children: filteredUTXOs.map((utxo2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: style$t.utxo, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Checkbox,
        {
          checked: !!selectedUTXOs[utxo2.outPoint],
          id: "utxo-" + utxo2.outPoint,
          "data-outpoint": utxo2.outPoint,
          onChange: handleUTXOChange,
          children: [
            utxo2.note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$t.note, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              utxo2.note,
              " "
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.utxoContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.utxoData, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.amounts, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.amount, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: utxo2.amount.amount, unit: utxo2.amount.unit }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.unit, children: utxo2.amount.unit })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { alwaysShowAmounts: true, amount: utxo2.amount, unstyled: true, noAction: true })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.address, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.label, children: [
                    t2("send.coincontrol.address"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.shrink, children: utxo2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.transaction, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.label, children: [
                    t2("send.coincontrol.outpoint"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.shrink, children: utxo2.txId }),
                  ":",
                  utxo2.txOutput
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: style$t.utxoExplorer,
                  href: explorerURL + utxo2.txId,
                  title: t2("transaction.explorerTitle"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, {})
                }
              )
            ] })
          ]
        }
      ) }, "utxo-" + utxo2.outPoint)) })
    ] }, "utxos-" + scriptType);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      open: active2,
      title: t2("send.coincontrol.title"),
      large: true,
      onClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        allScriptTypes.map(renderUTXOs),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-top-none m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onClose, children: t2("button.continue") }) })
      ] })
    }
  );
};
const txProposalErrorHandling = (registerEvents, unregisterEvents, errorCode) => {
  const { t: t2 } = instance;
  switch (errorCode) {
    case "invalidAddress":
      return { addressError: t2("send.error.invalidAddress") };
    case "invalidAmount":
    case "insufficientFunds":
      return { amountError: t2(`send.error.${errorCode}`), proposedFee: void 0 };
    case "feeTooLow":
    case "feesNotAvailable":
      return { feeError: t2(`send.error.${errorCode}`) };
    default:
      if (errorCode) {
        unregisterEvents();
        alertUser(errorCode, { callback: registerEvents });
      }
      return { proposedFee: void 0 };
  }
};
const container$g = "_container_8f83b_1";
const style$s = {
  container: container$g
};
class Send extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.selectedUTXOs = {};
    this.unsubscribeList = [];
    this.pendingProposals = [];
    this.proposeTimeout = null;
    this.state = {
      recipientAddress: "",
      amount: "",
      fiatAmount: "",
      valid: false,
      sendAll: false,
      isConfirming: false,
      signConfirm: false,
      isSent: false,
      isAborted: false,
      isUpdatingProposal: false,
      noMobileChannelError: false,
      fiatUnit: this.props.activeCurrency,
      coinControl: false,
      btcUnit: "default",
      activeCoinControl: false,
      activeScanQR: false,
      note: "",
      customFee: ""
    };
    this.isBitcoinBased = () => {
      const account2 = this.getAccount();
      if (!account2) {
        return false;
      }
      return isBitcoinBased(account2.coinCode);
    };
    this.registerEvents = () => {
      document.addEventListener("keydown", this.handleKeyDown);
    };
    this.unregisterEvents = () => {
      document.removeEventListener("keydown", this.handleKeyDown);
    };
    this.handleKeyDown = (e3) => {
      if (e3.keyCode === 27 && !this.state.activeCoinControl && !this.state.activeScanQR) {
        route(`/account/${this.props.code}`);
      }
    };
    this.send = async () => {
      if (this.state.noMobileChannelError) {
        alertUser(this.props.t("warning.sendPairing"));
        return;
      }
      const code = this.getAccount().code;
      const connectResult = await connectKeystore(code);
      if (!connectResult.success) {
        return;
      }
      this.setState({ signProgress: void 0, isConfirming: true });
      try {
        const result = await sendTx(code);
        if (result.success) {
          this.setState({
            sendAll: false,
            isConfirming: false,
            isSent: true,
            recipientAddress: "",
            proposedAmount: void 0,
            proposedFee: void 0,
            proposedTotal: void 0,
            fiatAmount: "",
            amount: "",
            note: "",
            customFee: ""
          });
          this.selectedUTXOs = {};
          setTimeout(() => this.setState({
            isSent: false,
            isConfirming: false
          }), 5e3);
        } else if (result.aborted) {
          this.setState({ isAborted: true });
          setTimeout(() => this.setState({ isAborted: false }), 5e3);
        } else {
          switch (result.errorCode) {
            case "erc20InsufficientGasFunds":
              alertUser(this.props.t(`send.error.${result.errorCode}`));
              break;
            default:
              const { errorMessage: errorMessage2 } = result;
              alertUser(this.props.t("unknownError", errorMessage2 && { errorMessage: errorMessage2 }));
          }
        }
      } catch (err) {
        console.error(err);
      } finally {
        this.setState({ isConfirming: false, signProgress: void 0, signConfirm: false });
      }
    };
    this.txInput = () => ({
      address: this.state.recipientAddress,
      amount: this.state.amount,
      feeTarget: this.state.feeTarget || "",
      customFee: this.state.customFee,
      sendAll: this.state.sendAll ? "yes" : "no",
      selectedUTXOs: Object.keys(this.selectedUTXOs)
    });
    this.sendDisabled = () => {
      const txInput = this.txInput();
      return !txInput.address || this.state.feeTarget === void 0 || txInput.sendAll === "no" && !txInput.amount || this.state.feeTarget === "custom" && !this.state.customFee;
    };
    this.validateAndDisplayFee = (updateFiat = true) => {
      this.setState({
        proposedTotal: void 0,
        addressError: void 0,
        amountError: void 0,
        feeError: void 0
      });
      if (this.sendDisabled()) {
        return;
      }
      const txInput = this.txInput();
      if (this.proposeTimeout) {
        clearTimeout(this.proposeTimeout);
        this.proposeTimeout = null;
      }
      this.setState({ isUpdatingProposal: true });
      this.proposeTimeout = setTimeout(() => {
        const propose = apiPost("account/" + this.getAccount().code + "/tx-proposal", txInput).then((result) => {
          const pos = this.pendingProposals.indexOf(propose);
          if (this.pendingProposals.length - 1 === pos) {
            this.txProposal(updateFiat, result);
          }
          this.pendingProposals.splice(pos, 1);
        }).catch(() => {
          this.setState({ valid: false });
          this.pendingProposals.splice(this.pendingProposals.indexOf(propose), 1);
        });
        this.pendingProposals.push(propose);
      }, 400);
    };
    this.handleNoteInput = (event2) => {
      const target = event2.target;
      this.setState({
        "note": target.value
      }, () => {
        proposeTxNote(this.getAccount().code, this.state.note);
      });
    };
    this.txProposal = (updateFiat, result) => {
      this.setState({ valid: result.success });
      if (result.success) {
        this.setState({
          addressError: void 0,
          amountError: void 0,
          feeError: void 0,
          proposedFee: result.fee,
          proposedAmount: result.amount,
          proposedTotal: result.total,
          isUpdatingProposal: false
        });
        if (updateFiat) {
          this.convertToFiat(result.amount.amount);
        }
      } else {
        const errorHandling = txProposalErrorHandling(this.registerEvents, this.unregisterEvents, result.errorCode);
        this.setState({ ...errorHandling, isUpdatingProposal: false });
      }
    };
    this.handleFiatInput = (event2) => {
      const value = event2.target.value;
      this.setState({ fiatAmount: value });
      this.convertFromFiat(value);
    };
    this.convertToFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-to-plain-fiat?from=${coinCode}&to=${this.state.fiatUnit}&amount=${value}`).then((data) => {
          if (data.success) {
            this.setState({ fiatAmount: data.fiatAmount });
          } else {
            this.setState({ amountError: this.props.t("send.error.invalidAmount") });
          }
        });
      } else {
        this.setState({ fiatAmount: "" });
      }
    };
    this.convertFromFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-from-fiat?from=${this.state.fiatUnit}&to=${coinCode}&amount=${value}`).then((data) => {
          if (data.success) {
            this.setState({ amount: data.amount }, () => this.validateAndDisplayFee(false));
          } else {
            this.setState({ amountError: this.props.t("send.error.invalidAmount") });
          }
        });
      } else {
        this.setState({ amount: "" });
      }
    };
    this.feeTargetChange = (feeTarget) => {
      this.setState(
        { feeTarget, customFee: "" },
        () => this.validateAndDisplayFee(this.state.sendAll)
      );
    };
    this.onSelectedUTXOsChange = (selectedUTXOs) => {
      this.selectedUTXOs = selectedUTXOs;
      this.validateAndDisplayFee(true);
    };
    this.hasSelectedUTXOs = () => {
      return Object.keys(this.selectedUTXOs).length !== 0;
    };
    this.getAccount = () => {
      if (!this.props.code) {
        return void 0;
      }
      return findAccount(this.props.accounts, this.props.code);
    };
    this.toggleCoinControl = () => {
      this.setState(({ activeCoinControl }) => {
        if (activeCoinControl) {
          this.selectedUTXOs = {};
        }
        return { activeCoinControl: !activeCoinControl };
      });
    };
    this.setActiveScanQR = (activeScanQR) => {
      this.setState({ activeScanQR });
    };
    this.parseQRResult = async (uri) => {
      let address2;
      let amount2 = "";
      try {
        const url = new URL(uri);
        if (url.protocol !== "bitcoin:" && url.protocol !== "litecoin:" && url.protocol !== "ethereum:") {
          alertUser(this.props.t("invalidFormat"));
          return;
        }
        address2 = url.pathname;
        if (this.isBitcoinBased()) {
          amount2 = url.searchParams.get("amount") || "";
        }
      } catch {
        address2 = uri;
      }
      let updateState = {
        recipientAddress: address2,
        sendAll: false,
        fiatAmount: ""
      };
      const coinCode = this.getAccount().coinCode;
      if (amount2) {
        if (coinCode === "btc" || coinCode === "tbtc") {
          const result = await parseExternalBtcAmount(amount2);
          if (result.success) {
            updateState["amount"] = result.amount;
          } else {
            updateState["amountError"] = this.props.t("send.error.invalidAmount");
            this.setState(updateState);
            return;
          }
        } else {
          updateState["amount"] = amount2;
        }
      }
      this.setState(updateState, () => {
        this.convertToFiat(this.state.amount);
        this.validateAndDisplayFee(true);
      });
    };
    this.deactivateCoinControl = () => {
      this.setState({ activeCoinControl: false });
    };
    this.onReceiverAddressInputChange = (recipientAddress) => {
      this.setState({ recipientAddress }, () => {
        this.validateAndDisplayFee(true);
      });
    };
    this.onCoinAmountChange = (amount2) => {
      this.convertToFiat(amount2);
      this.setState({ amount: amount2 }, () => {
        this.validateAndDisplayFee(true);
      });
    };
    this.onSendAllChange = (sendAll) => {
      if (!sendAll) {
        this.convertToFiat(this.state.amount);
      }
      this.setState({ sendAll }, () => {
        this.validateAndDisplayFee(true);
      });
    };
  }
  componentDidMount() {
    const updateBalance = (code) => getBalance(code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error);
    if (this.props.code) {
      updateBalance(this.props.code);
    }
    if (this.props.deviceIDs.length > 0 && this.props.devices[this.props.deviceIDs[0]] === "bitbox") {
      apiGet("devices/" + this.props.deviceIDs[0] + "/has-mobile-channel").then((mobileChannel) => {
        getDeviceInfo$1(this.props.deviceIDs[0]).then(({ pairing: pairing2 }) => {
          const account2 = this.getAccount();
          const paired = mobileChannel && pairing2;
          const noMobileChannelError = pairing2 && !mobileChannel && account2 && isBitcoinBased(account2.coinCode);
          this.setState((prevState) => ({ ...prevState, paired, noMobileChannelError }));
        });
      });
    }
    apiGet("config").then((config) => {
      this.setState({ btcUnit: config.backend.btcUnit });
      if (this.isBitcoinBased()) {
        this.setState({ coinControl: !!(config.frontend || {}).coinControl });
      }
    });
    this.unsubscribeList = [
      signProgress(
        (progress) => this.setState({ signProgress: progress, signConfirm: false })
      ),
      signConfirm(
        () => this.setState({ signConfirm: true })
      ),
      syncdone((code) => {
        if (this.props.code === code) {
          updateBalance(code);
        }
      })
    ];
  }
  UNSAFE_componentWillMount() {
    this.registerEvents();
  }
  componentWillUnmount() {
    this.unregisterEvents();
    unsubscribe(this.unsubscribeList);
  }
  render() {
    var _a;
    const { t: t2, code } = this.props;
    const {
      balance: balance2,
      proposedFee,
      proposedTotal,
      recipientAddress,
      proposedAmount,
      valid,
      amount: amount2,
      /* data, */
      fiatAmount,
      fiatUnit,
      sendAll,
      feeTarget,
      customFee,
      isConfirming,
      isSent,
      isAborted,
      isUpdatingProposal,
      addressError,
      amountError,
      feeError,
      paired,
      signProgress: signProgress2,
      signConfirm: signConfirm2,
      coinControl,
      btcUnit,
      activeCoinControl,
      activeScanQR,
      note: note2
    } = this.state;
    const waitDialogTransactionDetails = {
      proposedFee,
      proposedAmount,
      proposedTotal,
      customFee,
      feeTarget,
      recipientAddress,
      fiatUnit
    };
    const waitDialogTransactionStatus = {
      isConfirming,
      signProgress: signProgress2,
      signConfirm: signConfirm2
    };
    const account2 = this.getAccount();
    if (!account2) {
      return null;
    }
    const baseCurrencyUnit = fiatUnit === "BTC" && btcUnit === "sat" ? "sat" : fiatUnit;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== false, children: t2("warning.sendPairing") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Header,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("send.title", { accountName: account2.coinName }) }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.availableBalance") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2, noRotateFiat: true }),
            coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              UTXOs,
              {
                accountCode: account2.code,
                active: activeCoinControl,
                explorerURL: account2.blockExplorerTxPrefix,
                onClose: this.deactivateCoinControl,
                onChange: this.onSelectedUTXOsChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-row flex-between ${style$s.container}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.transactionDetails") }),
              coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: "m-bottom-quarter p-right-none",
                  transparent: true,
                  onClick: this.toggleCoinControl,
                  children: t2("send.toggleCoinControl")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ReceiverAddressInput,
              {
                accountCode: (_a = this.getAccount()) == null ? void 0 : _a.code,
                addressError,
                onInputChange: this.onReceiverAddressInputChange,
                recipientAddress,
                parseQRResult: this.parseQRResult,
                activeScanQR,
                onChangeActiveScanQR: this.setActiveScanQR
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CoinInput,
                {
                  balance: balance2,
                  onAmountChange: this.onCoinAmountChange,
                  onSendAllChange: this.onSendAllChange,
                  sendAll,
                  amountError,
                  proposedAmount,
                  amount: amount2,
                  hasSelectedUTXOs: this.hasSelectedUTXOs()
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FiatInput,
                {
                  onFiatChange: this.handleFiatInput,
                  disabled: sendAll,
                  error: amountError,
                  fiatAmount,
                  label: baseCurrencyUnit
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeeTargets,
                {
                  accountCode: account2.code,
                  coinCode: account2.coinCode,
                  disabled: !amount2 && !sendAll,
                  fiatUnit: baseCurrencyUnit,
                  proposedFee,
                  customFee,
                  showCalculatingFeeLabel: isUpdatingProposal,
                  onFeeTargetChange: this.feeTargetChange,
                  onCustomFee: (customFee2) => this.setState({ customFee: customFee2 }, this.validateAndDisplayFee),
                  error: feeError
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NoteInput,
                  {
                    note: note2,
                    onNoteChange: this.handleNoteInput
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  ColumnButtons,
                  {
                    className: "m-top-default m-bottom-xlarge",
                    inline: true,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          primary: true,
                          onClick: this.send,
                          disabled: this.sendDisabled() || !valid || isUpdatingProposal,
                          children: t2("send.button")
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ButtonLink,
                        {
                          secondary: true,
                          to: `/account/${code}`,
                          children: t2("button.back")
                        }
                      )
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConfirmingWaitDialog,
            {
              paired,
              baseCurrencyUnit,
              note: note2,
              hasSelectedUTXOs: this.hasSelectedUTXOs(),
              selectedUTXOs: Object.keys(this.selectedUTXOs),
              coinCode: account2.coinCode,
              transactionDetails: waitDialogTransactionDetails,
              transactionStatus: waitDialogTransactionStatus
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isSent, messageType: "sent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isAborted, messageType: "abort" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SendGuide, { coinCode: account2.coinCode })
    ] });
  }
}
const TranslatedSend = translate()(Send);
const SendWrapper = ({ accounts, code, deviceIDs, devices }) => {
  const { defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedSend,
    {
      accounts,
      code,
      devices,
      deviceIDs,
      activeCurrency: defaultCurrency2
    }
  );
};
const errUserAbort = 104;
const resetDevice = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/reset`);
};
const getDeviceInfo = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/info`);
};
const checkSDCard = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/check-sdcard`);
};
const insertSDCard = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/insert-sdcard`);
};
const setDeviceName = (deviceID, newDeviceName) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-device-name`, {
    name: newDeviceName
  });
};
const getVersion = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/version`);
};
const setMnemonicPassphraseEnabled = (deviceID, enabled) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-mnemonic-passphrase-enabled`, enabled);
};
const verifyAttestation = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/attestation`);
};
const checkBackup = (deviceID, silent) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/check`, { silent });
};
const createBackup = (deviceID, method) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/create`, method);
};
const restoreBackup = (deviceID, selectedBackup) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/restore`, selectedBackup);
};
const upgradeDeviceFirmware = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/upgrade-firmware`);
};
const showMnemonic = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/show-mnemonic`);
};
const restoreFromMnemonic = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/restore-from-mnemonic`);
};
const getStatus$1 = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/status`);
};
const getChannelHash = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/channel-hash`);
};
const verifyChannelHash = (deviceID, ok2) => {
  return apiPost(`devices/bitbox02/${deviceID}/channel-hash-verify`, ok2);
};
const setPassword = (deviceID, seedLen) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-password`, seedLen);
};
const getRootFingerprint = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/root-fingerprint`);
};
const useSDCard = (devices, dependencies) => {
  const [sdcard, setSDCard] = reactExports.useState(false);
  const mounted = useMountedRef();
  reactExports.useEffect(() => {
    const deviceIDs = Object.keys(devices);
    Promise.all(deviceIDs.map((deviceID) => {
      switch (devices[deviceID]) {
        case "bitbox":
          return getDeviceInfo$1(deviceID).then(({ sdcard: sdcard2 }) => sdcard2);
        case "bitbox02":
          return checkSDCard(deviceID);
        default:
          return false;
      }
    })).then((sdcards) => sdcards.some((sdcard2) => sdcard2)).then((result) => {
      if (mounted.current) {
        setSDCard(result);
      }
    }).catch(console.error);
  }, [devices, ...dependencies || []]);
  return sdcard;
};
function size(_a) {
  var width = _a.width, height = _a.height;
  if (width < 0) {
    throw new Error("Negative width is not allowed for Size");
  }
  if (height < 0) {
    throw new Error("Negative height is not allowed for Size");
  }
  return {
    width,
    height
  };
}
function equalSizes(first2, second) {
  return first2.width === second.width && first2.height === second.height;
}
var Observable = (
  /** @class */
  function() {
    function Observable2(win) {
      var _this = this;
      this._resolutionListener = function() {
        return _this._onResolutionChanged();
      };
      this._resolutionMediaQueryList = null;
      this._observers = [];
      this._window = win;
      this._installResolutionListener();
    }
    Observable2.prototype.dispose = function() {
      this._uninstallResolutionListener();
      this._window = null;
    };
    Object.defineProperty(Observable2.prototype, "value", {
      get: function() {
        return this._window.devicePixelRatio;
      },
      enumerable: false,
      configurable: true
    });
    Observable2.prototype.subscribe = function(next2) {
      var _this = this;
      var observer = { next: next2 };
      this._observers.push(observer);
      return {
        unsubscribe: function() {
          _this._observers = _this._observers.filter(function(o2) {
            return o2 !== observer;
          });
        }
      };
    };
    Observable2.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        throw new Error("Resolution listener is already installed");
      }
      var dppx = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(dppx, "dppx)"));
      this._resolutionMediaQueryList.addListener(this._resolutionListener);
    };
    Observable2.prototype._uninstallResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        this._resolutionMediaQueryList.removeListener(this._resolutionListener);
        this._resolutionMediaQueryList = null;
      }
    };
    Observable2.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener();
      this._installResolutionListener();
    };
    Observable2.prototype._onResolutionChanged = function() {
      var _this = this;
      this._observers.forEach(function(observer) {
        return observer.next(_this._window.devicePixelRatio);
      });
      this._reinstallResolutionListener();
    };
    return Observable2;
  }()
);
function createObservable(win) {
  return new Observable(win);
}
var DevicePixelContentBoxBinding = (
  /** @class */
  function() {
    function DevicePixelContentBoxBinding2(canvasElement, transformBitmapSize, options2) {
      var _a;
      this._canvasElement = null;
      this._bitmapSizeChangedListeners = [];
      this._suggestedBitmapSize = null;
      this._suggestedBitmapSizeChangedListeners = [];
      this._devicePixelRatioObservable = null;
      this._canvasElementResizeObserver = null;
      this._canvasElement = canvasElement;
      this._canvasElementClientSize = size({
        width: this._canvasElement.clientWidth,
        height: this._canvasElement.clientHeight
      });
      this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : function(size2) {
        return size2;
      };
      this._allowResizeObserver = (_a = options2 === null || options2 === void 0 ? void 0 : options2.allowResizeObserver) !== null && _a !== void 0 ? _a : true;
      this._chooseAndInitObserver();
    }
    DevicePixelContentBoxBinding2.prototype.dispose = function() {
      var _a, _b;
      if (this._canvasElement === null) {
        throw new Error("Object is disposed");
      }
      (_a = this._canvasElementResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this._canvasElementResizeObserver = null;
      (_b = this._devicePixelRatioObservable) === null || _b === void 0 ? void 0 : _b.dispose();
      this._devicePixelRatioObservable = null;
      this._suggestedBitmapSizeChangedListeners.length = 0;
      this._bitmapSizeChangedListeners.length = 0;
      this._canvasElement = null;
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElement", {
      get: function() {
        if (this._canvasElement === null) {
          throw new Error("Object is disposed");
        }
        return this._canvasElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElementClientSize", {
      get: function() {
        return this._canvasElementClientSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "bitmapSize", {
      get: function() {
        return size({
          width: this.canvasElement.width,
          height: this.canvasElement.height
        });
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.resizeCanvasElement = function(clientSize) {
      this._canvasElementClientSize = size(clientSize);
      this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px");
      this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px");
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype.subscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "suggestedBitmapSize", {
      get: function() {
        return this._suggestedBitmapSize;
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    DevicePixelContentBoxBinding2.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize === null) {
        return;
      }
      var oldSuggestedSize = this._suggestedBitmapSize;
      this._suggestedBitmapSize = null;
      this._resizeBitmap(oldSuggestedSize);
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);
    };
    DevicePixelContentBoxBinding2.prototype._resizeBitmap = function(newSize) {
      var oldSize = this.bitmapSize;
      if (equalSizes(oldSize, newSize)) {
        return;
      }
      this.canvasElement.width = newSize.width;
      this.canvasElement.height = newSize.height;
      this._emitBitmapSizeChanged(oldSize, newSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._bitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._suggestNewBitmapSize = function(newSize) {
      var oldSuggestedSize = this._suggestedBitmapSize;
      var finalNewSize = size(this._transformBitmapSize(newSize, this._canvasElementClientSize));
      var newSuggestedSize = equalSizes(this.bitmapSize, finalNewSize) ? null : finalNewSize;
      if (oldSuggestedSize === null && newSuggestedSize === null) {
        return;
      }
      if (oldSuggestedSize !== null && newSuggestedSize !== null && equalSizes(oldSuggestedSize, newSuggestedSize)) {
        return;
      }
      this._suggestedBitmapSize = newSuggestedSize;
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._chooseAndInitObserver = function() {
      var _this = this;
      if (!this._allowResizeObserver) {
        this._initDevicePixelRatioObservable();
        return;
      }
      isDevicePixelContentBoxSupported().then(function(isSupported) {
        return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();
      });
    };
    DevicePixelContentBoxBinding2.prototype._initDevicePixelRatioObservable = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        throw new Error("No window is associated with the canvas");
      }
      this._devicePixelRatioObservable = createObservable(win);
      this._devicePixelRatioObservable.subscribe(function() {
        return _this._invalidateBitmapSize();
      });
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype._invalidateBitmapSize = function() {
      var _a, _b;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        return;
      }
      var ratio = (_b = (_a = this._devicePixelRatioObservable) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio;
      var canvasRects = this._canvasElement.getClientRects();
      var newSize = (
        // eslint-disable-next-line no-negated-condition
        canvasRects[0] !== void 0 ? predictedBitmapSize(canvasRects[0], ratio) : size({
          width: this._canvasElementClientSize.width * ratio,
          height: this._canvasElementClientSize.height * ratio
        })
      );
      this._suggestNewBitmapSize(newSize);
    };
    DevicePixelContentBoxBinding2.prototype._initResizeObserver = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      this._canvasElementResizeObserver = new ResizeObserver(function(entries) {
        var entry2 = entries.find(function(entry3) {
          return entry3.target === _this._canvasElement;
        });
        if (!entry2 || !entry2.devicePixelContentBoxSize || !entry2.devicePixelContentBoxSize[0]) {
          return;
        }
        var entrySize = entry2.devicePixelContentBoxSize[0];
        var newSize = size({
          width: entrySize.inlineSize,
          height: entrySize.blockSize
        });
        _this._suggestNewBitmapSize(newSize);
      });
      this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" });
    };
    return DevicePixelContentBoxBinding2;
  }()
);
function bindTo(canvasElement, target) {
  if (target.type === "device-pixel-content-box") {
    return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);
  }
  throw new Error("Unsupported binding target");
}
function canvasElementWindow(canvasElement) {
  return canvasElement.ownerDocument.defaultView;
}
function isDevicePixelContentBoxSupported() {
  return new Promise(function(resolve) {
    var ro = new ResizeObserver(function(entries) {
      resolve(entries.every(function(entry2) {
        return "devicePixelContentBoxSize" in entry2;
      }));
      ro.disconnect();
    });
    ro.observe(document.body, { box: "device-pixel-content-box" });
  }).catch(function() {
    return false;
  });
}
function predictedBitmapSize(canvasRect, ratio) {
  return size({
    width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),
    height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)
  });
}
var CanvasRenderingTarget2D = (
  /** @class */
  function() {
    function CanvasRenderingTarget2D2(context, mediaSize, bitmapSize) {
      if (mediaSize.width === 0 || mediaSize.height === 0) {
        throw new TypeError("Rendering target could only be created on a media with positive width and height");
      }
      this._mediaSize = mediaSize;
      if (bitmapSize.width === 0 || bitmapSize.height === 0) {
        throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      }
      this._bitmapSize = bitmapSize;
      this._context = context;
    }
    CanvasRenderingTarget2D2.prototype.useMediaCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize
        });
      } finally {
        this._context.restore();
      }
    };
    CanvasRenderingTarget2D2.prototype.useBitmapCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize,
          bitmapSize: this._bitmapSize,
          horizontalPixelRatio: this._horizontalPixelRatio,
          verticalPixelRatio: this._verticalPixelRatio
        });
      } finally {
        this._context.restore();
      }
    };
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_horizontalPixelRatio", {
      get: function() {
        return this._bitmapSize.width / this._mediaSize.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_verticalPixelRatio", {
      get: function() {
        return this._bitmapSize.height / this._mediaSize.height;
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderingTarget2D2;
  }()
);
function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {
  var mediaSize = binding.canvasElementClientSize;
  if (mediaSize.width === 0 || mediaSize.height === 0) {
    return null;
  }
  var bitmapSize = binding.bitmapSize;
  if (bitmapSize.width === 0 || bitmapSize.height === 0) {
    return null;
  }
  var context = binding.canvasElement.getContext("2d", contextOptions);
  if (context === null) {
    return null;
  }
  return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);
}
/*!
 * @license
 * TradingView Lightweight Charts v4.1.1
 * Copyright (c) 2023 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
const e2 = { upColor: "#26a69a", downColor: "#ef5350", wickVisible: true, borderVisible: true, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, r = { upColor: "#26a69a", downColor: "#ef5350", openVisible: true, thinBars: true }, h$1 = { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, l = { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: false, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, a = { baseValue: { type: "price", price: 0 }, topFillColor1: "rgba(38, 166, 154, 0.28)", topFillColor2: "rgba(38, 166, 154, 0.05)", topLineColor: "rgba(38, 166, 154, 1)", bottomFillColor1: "rgba(239, 83, 80, 0.05)", bottomFillColor2: "rgba(239, 83, 80, 0.28)", bottomLineColor: "rgba(239, 83, 80, 1)", lineWidth: 3, lineStyle: 0, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, o = { color: "#26a69a", base: 0 }, _$1 = { color: "#2196f3" }, u = { title: "", visible: true, lastValueVisible: true, priceLineVisible: true, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: true, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: 0.01 } };
var c, d;
function f(t2, i) {
  const n2 = { 0: [], 1: [t2.lineWidth, t2.lineWidth], 2: [2 * t2.lineWidth, 2 * t2.lineWidth], 3: [6 * t2.lineWidth, 6 * t2.lineWidth], 4: [t2.lineWidth, 4 * t2.lineWidth] }[i];
  t2.setLineDash(n2);
}
function v(t2, i, n2, s) {
  t2.beginPath();
  const e3 = t2.lineWidth % 2 ? 0.5 : 0;
  t2.moveTo(n2, i + e3), t2.lineTo(s, i + e3), t2.stroke();
}
function p$1(t2, i) {
  if (!t2)
    throw new Error("Assertion failed" + (i ? ": " + i : ""));
}
function m$1(t2) {
  if (void 0 === t2)
    throw new Error("Value is undefined");
  return t2;
}
function b(t2) {
  if (null === t2)
    throw new Error("Value is null");
  return t2;
}
function w$1(t2) {
  return b(m$1(t2));
}
!function(t2) {
  t2[t2.Simple = 0] = "Simple", t2[t2.WithSteps = 1] = "WithSteps", t2[t2.Curved = 2] = "Curved";
}(c || (c = {})), function(t2) {
  t2[t2.Solid = 0] = "Solid", t2[t2.Dotted = 1] = "Dotted", t2[t2.Dashed = 2] = "Dashed", t2[t2.LargeDashed = 3] = "LargeDashed", t2[t2.SparseDotted = 4] = "SparseDotted";
}(d || (d = {}));
const g = { khaki: "#f0e68c", azure: "#f0ffff", aliceblue: "#f0f8ff", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", gray: "#808080", green: "#008000", honeydew: "#f0fff0", floralwhite: "#fffaf0", lightblue: "#add8e6", lightcoral: "#f08080", lemonchiffon: "#fffacd", hotpink: "#ff69b4", lightyellow: "#ffffe0", greenyellow: "#adff2f", lightgoldenrodyellow: "#fafad2", limegreen: "#32cd32", linen: "#faf0e6", lightcyan: "#e0ffff", magenta: "#f0f", maroon: "#800000", olive: "#808000", orange: "#ffa500", oldlace: "#fdf5e6", mediumblue: "#0000cd", transparent: "#0000", lime: "#0f0", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", midnightblue: "#191970", orchid: "#da70d6", mediumorchid: "#ba55d3", mediumturquoise: "#48d1cc", orangered: "#ff4500", royalblue: "#4169e1", powderblue: "#b0e0e6", red: "#f00", coral: "#ff7f50", turquoise: "#40e0d0", white: "#fff", whitesmoke: "#f5f5f5", wheat: "#f5deb3", teal: "#008080", steelblue: "#4682b4", bisque: "#ffe4c4", aquamarine: "#7fffd4", aqua: "#0ff", sienna: "#a0522d", silver: "#c0c0c0", springgreen: "#00ff7f", antiquewhite: "#faebd7", burlywood: "#deb887", brown: "#a52a2a", beige: "#f5f5dc", chocolate: "#d2691e", chartreuse: "#7fff00", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cadetblue: "#5f9ea0", tomato: "#ff6347", fuchsia: "#f0f", blue: "#00f", salmon: "#fa8072", blanchedalmond: "#ffebcd", slateblue: "#6a5acd", slategray: "#708090", thistle: "#d8bfd8", tan: "#d2b48c", cyan: "#0ff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", blueviolet: "#8a2be2", black: "#000", darkmagenta: "#8b008b", darkslateblue: "#483d8b", darkkhaki: "#bdb76b", darkorchid: "#9932cc", darkorange: "#ff8c00", darkgreen: "#006400", darkred: "#8b0000", dodgerblue: "#1e90ff", darkslategray: "#2f4f4f", dimgray: "#696969", deepskyblue: "#00bfff", firebrick: "#b22222", forestgreen: "#228b22", indigo: "#4b0082", ivory: "#fffff0", lavenderblush: "#fff0f5", feldspar: "#d19275", indianred: "#cd5c5c", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightskyblue: "#87cefa", lightslategray: "#789", lightslateblue: "#8470ff", snow: "#fffafa", lightseagreen: "#20b2aa", lightsalmon: "#ffa07a", darksalmon: "#e9967a", darkviolet: "#9400d3", mediumpurple: "#9370d8", mediumaquamarine: "#66cdaa", skyblue: "#87ceeb", lavender: "#e6e6fa", lightsteelblue: "#b0c4de", mediumvioletred: "#c71585", mintcream: "#f5fffa", navajowhite: "#ffdead", navy: "#000080", olivedrab: "#6b8e23", palevioletred: "#d87093", violetred: "#d02090", yellow: "#ff0", yellowgreen: "#9acd32", lawngreen: "#7cfc00", pink: "#ffc0cb", paleturquoise: "#afeeee", palegoldenrod: "#eee8aa", darkolivegreen: "#556b2f", darkseagreen: "#8fbc8f", darkturquoise: "#00ced1", peachpuff: "#ffdab9", deeppink: "#ff1493", violet: "#ee82ee", palegreen: "#98fb98", mediumseagreen: "#3cb371", peru: "#cd853f", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", purple: "#800080", seagreen: "#2e8b57", seashell: "#fff5ee", papayawhip: "#ffefd5", mediumslateblue: "#7b68ee", plum: "#dda0dd", mediumspringgreen: "#00fa9a" };
function M(t2) {
  return t2 < 0 ? 0 : t2 > 255 ? 255 : Math.round(t2) || 0;
}
function x(t2) {
  return t2 <= 0 || t2 > 0 ? t2 < 0 ? 0 : t2 > 1 ? 1 : Math.round(1e4 * t2) / 1e4 : 0;
}
const S$1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i, k$1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i, y = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/, C$1 = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
function T$1(t2) {
  (t2 = t2.toLowerCase()) in g && (t2 = g[t2]);
  {
    const i = C$1.exec(t2) || y.exec(t2);
    if (i)
      return [M(parseInt(i[1], 10)), M(parseInt(i[2], 10)), M(parseInt(i[3], 10)), x(i.length < 5 ? 1 : parseFloat(i[4]))];
  }
  {
    const i = k$1.exec(t2);
    if (i)
      return [M(parseInt(i[1], 16)), M(parseInt(i[2], 16)), M(parseInt(i[3], 16)), 1];
  }
  {
    const i = S$1.exec(t2);
    if (i)
      return [M(17 * parseInt(i[1], 16)), M(17 * parseInt(i[2], 16)), M(17 * parseInt(i[3], 16)), 1];
  }
  throw new Error(`Cannot parse color: ${t2}`);
}
function P(t2) {
  const i = T$1(t2);
  return { t: `rgb(${i[0]}, ${i[1]}, ${i[2]})`, i: (n2 = i, 0.199 * n2[0] + 0.687 * n2[1] + 0.114 * n2[2] > 160 ? "black" : "white") };
  var n2;
}
class R {
  constructor() {
    this.h = [];
  }
  l(t2, i, n2) {
    const s = { o: t2, _: i, u: true === n2 };
    this.h.push(s);
  }
  v(t2) {
    const i = this.h.findIndex((i2) => t2 === i2.o);
    i > -1 && this.h.splice(i, 1);
  }
  p(t2) {
    this.h = this.h.filter((i) => i._ !== t2);
  }
  m(t2, i, n2) {
    const s = [...this.h];
    this.h = this.h.filter((t3) => !t3.u), s.forEach((s2) => s2.o(t2, i, n2));
  }
  M() {
    return this.h.length > 0;
  }
  S() {
    this.h = [];
  }
}
function D$1(t2, ...i) {
  for (const n2 of i)
    for (const i2 in n2)
      void 0 !== n2[i2] && ("object" != typeof n2[i2] || void 0 === t2[i2] || Array.isArray(n2[i2]) ? t2[i2] = n2[i2] : D$1(t2[i2], n2[i2]));
  return t2;
}
function O$1(t2) {
  return "number" == typeof t2 && isFinite(t2);
}
function A$1(t2) {
  return "number" == typeof t2 && t2 % 1 == 0;
}
function V$1(t2) {
  return "string" == typeof t2;
}
function B$1(t2) {
  return "boolean" == typeof t2;
}
function I(t2) {
  const i = t2;
  if (!i || "object" != typeof i)
    return i;
  let n2, s, e3;
  for (s in n2 = Array.isArray(i) ? [] : {}, i)
    i.hasOwnProperty(s) && (e3 = i[s], n2[s] = e3 && "object" == typeof e3 ? I(e3) : e3);
  return n2;
}
function z(t2) {
  return null !== t2;
}
function E(t2) {
  return null === t2 ? void 0 : t2;
}
const L$1 = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
function N$1(t2, i, n2) {
  return void 0 === i && (i = L$1), `${n2 = void 0 !== n2 ? `${n2} ` : ""}${t2}px ${i}`;
}
let F$1 = class F {
  constructor(t2) {
    this.k = { C: 1, T: 5, P: NaN, R: "", D: "", O: "", A: "", V: 0, B: 0, I: 0, L: 0, N: 0 }, this.F = t2;
  }
  W() {
    const t2 = this.k, i = this.j(), n2 = this.H();
    return t2.P === i && t2.D === n2 || (t2.P = i, t2.D = n2, t2.R = N$1(i, n2), t2.L = 2.5 / 12 * i, t2.V = t2.L, t2.B = i / 12 * t2.T, t2.I = i / 12 * t2.T, t2.N = 0), t2.O = this.$(), t2.A = this.U(), this.k;
  }
  $() {
    return this.F.W().layout.textColor;
  }
  U() {
    return this.F.q();
  }
  j() {
    return this.F.W().layout.fontSize;
  }
  H() {
    return this.F.W().layout.fontFamily;
  }
};
class W {
  constructor() {
    this.Y = [];
  }
  X(t2) {
    this.Y = t2;
  }
  K(t2, i, n2) {
    this.Y.forEach((s) => {
      s.K(t2, i, n2);
    });
  }
}
class j {
  K(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
  G(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.J(t3, i, n2));
  }
  J(t2, i, n2) {
  }
}
let H$1 = class H extends j {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z({ context: t2 }) {
    if (null === this.tt || null === this.tt.nt)
      return;
    const i = this.tt.nt, n2 = this.tt, s = (s2) => {
      t2.beginPath();
      for (let e3 = i.to - 1; e3 >= i.from; --e3) {
        const i2 = n2.st[e3];
        t2.moveTo(i2.et, i2.rt), t2.arc(i2.et, i2.rt, s2, 0, 2 * Math.PI);
      }
      t2.fill();
    };
    n2.ht > 0 && (t2.fillStyle = n2.lt, s(n2.ot + n2.ht)), t2.fillStyle = n2._t, s(n2.ot);
  }
};
function $$1() {
  return { st: [{ et: 0, rt: 0, ut: 0, ct: 0 }], _t: "", lt: "", ot: 0, ht: 0, nt: null };
}
const U$1 = { from: 0, to: 1 };
class q {
  constructor(t2, i) {
    this.dt = new W(), this.ft = [], this.vt = [], this.bt = true, this.F = t2, this.wt = i, this.dt.X(this.ft);
  }
  gt(t2) {
    const i = this.F.Mt();
    i.length !== this.ft.length && (this.vt = i.map($$1), this.ft = this.vt.map((t3) => {
      const i2 = new H$1();
      return i2.it(t3), i2;
    }), this.dt.X(this.ft)), this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.dt;
  }
  St() {
    const t2 = 2 === this.wt.W().mode, i = this.F.Mt(), n2 = this.wt.kt(), s = this.F.yt();
    i.forEach((i2, e3) => {
      var r2;
      const h2 = this.vt[e3], l2 = i2.Ct(n2);
      if (t2 || null === l2 || !i2.Tt())
        return void (h2.nt = null);
      const a2 = b(i2.Pt());
      h2._t = l2.Rt, h2.ot = l2.ot, h2.ht = l2.Dt, h2.st[0].ct = l2.ct, h2.st[0].rt = i2.At().Ot(l2.ct, a2.Vt), h2.lt = null !== (r2 = l2.Bt) && void 0 !== r2 ? r2 : this.F.It(h2.st[0].rt / i2.At().zt()), h2.st[0].ut = n2, h2.st[0].et = s.Et(n2), h2.nt = U$1;
    });
  }
}
class Y {
  K(t2, i, n2) {
    t2.useBitmapCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
}
let X$1 = class X extends Y {
  constructor(t2) {
    super(), this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    const e3 = this.Lt.Nt.Tt, r2 = this.Lt.Ft.Tt;
    if (!e3 && !r2)
      return;
    const h2 = Math.round(this.Lt.et * n2), l2 = Math.round(this.Lt.rt * s);
    t2.lineCap = "butt", e3 && h2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Nt.ht * n2), t2.strokeStyle = this.Lt.Nt.O, t2.fillStyle = this.Lt.Nt.O, f(t2, this.Lt.Nt.Wt), function(t3, i2, n3, s2) {
      t3.beginPath();
      const e4 = t3.lineWidth % 2 ? 0.5 : 0;
      t3.moveTo(i2 + e4, n3), t3.lineTo(i2 + e4, s2), t3.stroke();
    }(t2, h2, 0, i.height)), r2 && l2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Ft.ht * s), t2.strokeStyle = this.Lt.Ft.O, t2.fillStyle = this.Lt.Ft.O, f(t2, this.Lt.Ft.Wt), v(t2, l2, 0, i.width));
  }
};
class K {
  constructor(t2) {
    this.bt = true, this.jt = { Nt: { ht: 1, Wt: 0, O: "", Tt: false }, Ft: { ht: 1, Wt: 0, O: "", Tt: false }, et: 0, rt: 0 }, this.Ht = new X$1(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht;
  }
  St() {
    const t2 = this.$t.Tt(), i = b(this.$t.Ut()), n2 = i.qt().W().crosshair, s = this.jt;
    if (2 === n2.mode)
      return s.Ft.Tt = false, void (s.Nt.Tt = false);
    s.Ft.Tt = t2 && this.$t.Yt(i), s.Nt.Tt = t2 && this.$t.Xt(), s.Ft.ht = n2.horzLine.width, s.Ft.Wt = n2.horzLine.style, s.Ft.O = n2.horzLine.color, s.Nt.ht = n2.vertLine.width, s.Nt.Wt = n2.vertLine.style, s.Nt.O = n2.vertLine.color, s.et = this.$t.Kt(), s.rt = this.$t.Zt();
  }
}
function Z$1(t2, i, n2, s, e3, r2) {
  t2.fillRect(i + r2, n2, s - 2 * r2, r2), t2.fillRect(i + r2, n2 + e3 - r2, s - 2 * r2, r2), t2.fillRect(i, n2, r2, e3), t2.fillRect(i + s - r2, n2, r2, e3);
}
function G$1(t2, i, n2, s, e3, r2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.fillStyle = r2, t2.fillRect(i, n2, s, e3), t2.restore();
}
function J$1(t2, i) {
  return t2.map((t3) => 0 === t3 ? t3 : t3 + i);
}
function Q$1(t2, i, n2, s, e3, r2) {
  t2.beginPath(), t2.lineTo(i + s - r2[1], n2), 0 !== r2[1] && t2.arcTo(i + s, n2, i + s, n2 + r2[1], r2[1]), t2.lineTo(i + s, n2 + e3 - r2[2]), 0 !== r2[2] && t2.arcTo(i + s, n2 + e3, i + s - r2[2], n2 + e3, r2[2]), t2.lineTo(i + r2[3], n2 + e3), 0 !== r2[3] && t2.arcTo(i, n2 + e3, i, n2 + e3 - r2[3], r2[3]), t2.lineTo(i, n2 + r2[0]), 0 !== r2[0] && t2.arcTo(i, n2, i + r2[0], n2, r2[0]);
}
function tt(t2, i, n2, s, e3, r2, h2 = 0, l2 = [0, 0, 0, 0], a2 = "") {
  if (t2.save(), !h2 || !a2 || a2 === r2)
    return Q$1(t2, i, n2, s, e3, l2), t2.fillStyle = r2, t2.fill(), void t2.restore();
  const o2 = h2 / 2;
  if ("transparent" !== r2) {
    Q$1(t2, i + h2, n2 + h2, s - 2 * h2, e3 - 2 * h2, J$1(l2, -h2)), t2.fillStyle = r2, t2.fill();
  }
  if ("transparent" !== a2) {
    Q$1(t2, i + o2, n2 + o2, s - h2, e3 - h2, J$1(l2, -o2)), t2.lineWidth = h2, t2.strokeStyle = a2, t2.closePath(), t2.stroke();
  }
  t2.restore();
}
function it(t2, i, n2, s, e3, r2, h2) {
  t2.save(), t2.globalCompositeOperation = "copy";
  const l2 = t2.createLinearGradient(0, 0, 0, e3);
  l2.addColorStop(0, r2), l2.addColorStop(1, h2), t2.fillStyle = l2, t2.fillRect(i, n2, s, e3), t2.restore();
}
class nt {
  constructor(t2, i) {
    this.it(t2, i);
  }
  it(t2, i) {
    this.Lt = t2, this.Gt = i;
  }
  zt(t2, i) {
    return this.Lt.Tt ? t2.P + t2.L + t2.V : 0;
  }
  K(t2, i, n2, s) {
    if (!this.Lt.Tt || 0 === this.Lt.Jt.length)
      return;
    const e3 = this.Lt.O, r2 = this.Gt.t, h2 = t2.useBitmapCoordinateSpace((t3) => {
      const h3 = t3.context;
      h3.font = i.R;
      const l2 = this.Qt(t3, i, n2, s), a2 = l2.ti, o2 = (t4, i2) => {
        l2.ii ? tt(h3, a2.ni, a2.si, a2.ei, a2.ri, t4, a2.hi, [a2.ot, 0, 0, a2.ot], i2) : tt(h3, a2.li, a2.si, a2.ei, a2.ri, t4, a2.hi, [0, a2.ot, a2.ot, 0], i2);
      };
      return o2(r2, "transparent"), this.Lt.ai && (h3.fillStyle = e3, h3.fillRect(a2.li, a2.oi, a2._i - a2.li, a2.ui)), o2("transparent", r2), this.Lt.ci && (h3.fillStyle = i.A, h3.fillRect(l2.ii ? a2.di - a2.hi : 0, a2.si, a2.hi, a2.fi - a2.si)), l2;
    });
    t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = h2.vi;
      t3.font = i.R, t3.textAlign = h2.ii ? "right" : "left", t3.textBaseline = "middle", t3.fillStyle = e3, t3.fillText(this.Lt.Jt, n3.pi, (n3.si + n3.fi) / 2 + n3.mi);
    });
  }
  Qt(t2, i, n2, s) {
    var e3;
    const { context: r2, bitmapSize: h2, mediaSize: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = this.Lt.ai || !this.Lt.bi ? i.T : 0, u2 = this.Lt.wi ? i.C : 0, c2 = i.L + this.Gt.gi, d2 = i.V + this.Gt.Mi, f2 = i.B, v2 = i.I, p2 = this.Lt.Jt, m2 = i.P, b2 = n2.xi(r2, p2), w2 = Math.ceil(n2.Si(r2, p2)), g2 = m2 + c2 + d2, M2 = i.C + f2 + v2 + w2 + _24, x2 = Math.max(1, Math.floor(o2));
    let S2 = Math.round(g2 * o2);
    S2 % 2 != x2 % 2 && (S2 += 1);
    const k2 = u2 > 0 ? Math.max(1, Math.floor(u2 * a2)) : 0, y2 = Math.round(M2 * a2), C2 = Math.round(_24 * a2), T2 = null !== (e3 = this.Gt.ki) && void 0 !== e3 ? e3 : this.Gt.yi, P2 = Math.round(T2 * o2) - Math.floor(0.5 * o2), R2 = Math.floor(P2 + x2 / 2 - S2 / 2), D2 = R2 + S2, O2 = "right" === s, A2 = O2 ? l2.width - u2 : u2, V2 = O2 ? h2.width - k2 : k2;
    let B2, I2, z2;
    return O2 ? (B2 = V2 - y2, I2 = V2 - C2, z2 = A2 - _24 - f2 - u2) : (B2 = V2 + y2, I2 = V2 + C2, z2 = A2 + _24 + f2), { ii: O2, ti: { si: R2, oi: P2, fi: D2, ei: y2, ri: S2, ot: 2 * a2, hi: k2, ni: B2, li: V2, _i: I2, ui: x2, di: h2.width }, vi: { si: R2 / o2, fi: D2 / o2, pi: z2, mi: b2 } };
  }
}
class st {
  constructor(t2) {
    this.Ci = { yi: 0, t: "#000", Mi: 0, gi: 0 }, this.Ti = { Jt: "", Tt: false, ai: true, bi: false, Bt: "", O: "#FFF", ci: false, wi: false }, this.Pi = { Jt: "", Tt: false, ai: false, bi: true, Bt: "", O: "#FFF", ci: true, wi: true }, this.bt = true, this.Ri = new (t2 || nt)(this.Ti, this.Ci), this.Di = new (t2 || nt)(this.Pi, this.Ci);
  }
  Jt() {
    return this.Oi(), this.Ti.Jt;
  }
  yi() {
    return this.Oi(), this.Ci.yi;
  }
  gt() {
    this.bt = true;
  }
  zt(t2, i = false) {
    return Math.max(this.Ri.zt(t2, i), this.Di.zt(t2, i));
  }
  Ai() {
    return this.Ci.ki || 0;
  }
  Vi(t2) {
    this.Ci.ki = t2;
  }
  Bi() {
    return this.Oi(), this.Ti.Tt || this.Pi.Tt;
  }
  Ii() {
    return this.Oi(), this.Ti.Tt;
  }
  xt(t2) {
    return this.Oi(), this.Ti.ai = this.Ti.ai && t2.W().ticksVisible, this.Pi.ai = this.Pi.ai && t2.W().ticksVisible, this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Ri;
  }
  zi() {
    return this.Oi(), this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Di;
  }
  Oi() {
    this.bt && (this.Ti.ai = true, this.Pi.ai = false, this.Ei(this.Ti, this.Pi, this.Ci));
  }
}
class et extends st {
  constructor(t2, i, n2) {
    super(), this.$t = t2, this.Li = i, this.Ni = n2;
  }
  Ei(t2, i, n2) {
    if (t2.Tt = false, 2 === this.$t.W().mode)
      return;
    const s = this.$t.W().horzLine;
    if (!s.labelVisible)
      return;
    const e3 = this.Li.Pt();
    if (!this.$t.Tt() || this.Li.Fi() || null === e3)
      return;
    const r2 = P(s.labelBackgroundColor);
    n2.t = r2.t, t2.O = r2.i;
    const h2 = 2 / 12 * this.Li.P();
    n2.gi = h2, n2.Mi = h2;
    const l2 = this.Ni(this.Li);
    n2.yi = l2.yi, t2.Jt = this.Li.Wi(l2.ct, e3), t2.Tt = true;
  }
}
const rt$1 = /[1-9]/g;
let ht$1 = class ht {
  constructor() {
    this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  K(t2, i) {
    if (null === this.Lt || false === this.Lt.Tt || 0 === this.Lt.Jt.length)
      return;
    const n2 = t2.useMediaCoordinateSpace(({ context: t3 }) => (t3.font = i.R, Math.round(i.ji.Si(t3, b(this.Lt).Jt, rt$1))));
    if (n2 <= 0)
      return;
    const s = i.Hi, e3 = n2 + 2 * s, r2 = e3 / 2, h2 = this.Lt.$i;
    let l2 = this.Lt.yi, a2 = Math.floor(l2 - r2) + 0.5;
    a2 < 0 ? (l2 += Math.abs(0 - a2), a2 = Math.floor(l2 - r2) + 0.5) : a2 + e3 > h2 && (l2 -= Math.abs(h2 - (a2 + e3)), a2 = Math.floor(l2 - r2) + 0.5);
    const o2 = a2 + e3, _24 = Math.ceil(0 + i.C + i.T + i.L + i.P + i.V);
    t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: n3, verticalPixelRatio: s2 }) => {
      const e4 = b(this.Lt);
      t3.fillStyle = e4.t;
      const r3 = Math.round(a2 * n3), h3 = Math.round(0 * s2), l3 = Math.round(o2 * n3), u2 = Math.round(_24 * s2), c2 = Math.round(2 * n3);
      if (t3.beginPath(), t3.moveTo(r3, h3), t3.lineTo(r3, u2 - c2), t3.arcTo(r3, u2, r3 + c2, u2, c2), t3.lineTo(l3 - c2, u2), t3.arcTo(l3, u2, l3, u2 - c2, c2), t3.lineTo(l3, h3), t3.fill(), e4.ai) {
        const r4 = Math.round(e4.yi * n3), l4 = h3, a3 = Math.round((l4 + i.T) * s2);
        t3.fillStyle = e4.O;
        const o3 = Math.max(1, Math.floor(n3)), _25 = Math.floor(0.5 * n3);
        t3.fillRect(r4 - _25, l4, o3, a3 - l4);
      }
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = b(this.Lt), e4 = 0 + i.C + i.T + i.L + i.P / 2;
      t3.font = i.R, t3.textAlign = "left", t3.textBaseline = "middle", t3.fillStyle = n3.O;
      const r3 = i.ji.xi(t3, "Apr0");
      t3.translate(a2 + s, e4 + r3), t3.fillText(n3.Jt, 0, 0);
    });
  }
};
let lt$1 = class lt {
  constructor(t2, i, n2) {
    this.bt = true, this.Ht = new ht$1(), this.jt = { Tt: false, t: "#4c525e", O: "white", Jt: "", $i: 0, yi: NaN, ai: true }, this.wt = t2, this.Ui = i, this.Ni = n2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht.it(this.jt), this.Ht;
  }
  St() {
    const t2 = this.jt;
    if (t2.Tt = false, 2 === this.wt.W().mode)
      return;
    const i = this.wt.W().vertLine;
    if (!i.labelVisible)
      return;
    const n2 = this.Ui.yt();
    if (n2.Fi())
      return;
    t2.$i = n2.$i();
    const s = this.Ni();
    if (null === s)
      return;
    t2.yi = s.yi;
    const e3 = n2.qi(this.wt.kt());
    t2.Jt = n2.Yi(b(e3)), t2.Tt = true;
    const r2 = P(i.labelBackgroundColor);
    t2.t = r2.t, t2.O = r2.i, t2.ai = n2.W().ticksVisible;
  }
};
let at$1 = class at {
  constructor() {
    this.Xi = null, this.Ki = 0;
  }
  Zi() {
    return this.Ki;
  }
  Gi(t2) {
    this.Ki = t2;
  }
  At() {
    return this.Xi;
  }
  Ji(t2) {
    this.Xi = t2;
  }
  Qi(t2) {
    return [];
  }
  tn() {
    return [];
  }
  Tt() {
    return true;
  }
};
var ot$1;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Magnet = 1] = "Magnet", t2[t2.Hidden = 2] = "Hidden";
}(ot$1 || (ot$1 = {}));
let _t$1 = class _t extends at$1 {
  constructor(t2, i) {
    super(), this.nn = null, this.sn = NaN, this.en = 0, this.rn = true, this.hn = /* @__PURE__ */ new Map(), this.ln = false, this.an = NaN, this.on = NaN, this._n = NaN, this.un = NaN, this.Ui = t2, this.cn = i, this.dn = new q(t2, this);
    this.fn = ((t3, i2) => (n3) => {
      const s = i2(), e3 = t3();
      if (n3 === b(this.nn).vn())
        return { ct: e3, yi: s };
      {
        const t4 = b(n3.Pt());
        return { ct: n3.pn(s, t4), yi: s };
      }
    })(() => this.sn, () => this.on);
    const n2 = ((t3, i2) => () => {
      const n3 = this.Ui.yt().mn(t3()), s = i2();
      return n3 && Number.isFinite(s) ? { ut: n3, yi: s } : null;
    })(() => this.en, () => this.Kt());
    this.bn = new lt$1(this, t2, n2), this.wn = new K(this);
  }
  W() {
    return this.cn;
  }
  gn(t2, i) {
    this._n = t2, this.un = i;
  }
  Mn() {
    this._n = NaN, this.un = NaN;
  }
  xn() {
    return this._n;
  }
  Sn() {
    return this.un;
  }
  kn(t2, i, n2) {
    this.ln || (this.ln = true), this.rn = true, this.yn(t2, i, n2);
  }
  kt() {
    return this.en;
  }
  Kt() {
    return this.an;
  }
  Zt() {
    return this.on;
  }
  Tt() {
    return this.rn;
  }
  Cn() {
    this.rn = false, this.Tn(), this.sn = NaN, this.an = NaN, this.on = NaN, this.nn = null, this.Mn();
  }
  Pn(t2) {
    return null !== this.nn ? [this.wn, this.dn] : [];
  }
  Yt(t2) {
    return t2 === this.nn && this.cn.horzLine.visible;
  }
  Xt() {
    return this.cn.vertLine.visible;
  }
  Rn(t2, i) {
    this.rn && this.nn === t2 || this.hn.clear();
    const n2 = [];
    return this.nn === t2 && n2.push(this.Dn(this.hn, i, this.fn)), n2;
  }
  tn() {
    return this.rn ? [this.bn] : [];
  }
  Ut() {
    return this.nn;
  }
  On() {
    this.wn.gt(), this.hn.forEach((t2) => t2.gt()), this.bn.gt(), this.dn.gt();
  }
  An(t2) {
    return t2 && !t2.vn().Fi() ? t2.vn() : null;
  }
  yn(t2, i, n2) {
    this.Vn(t2, i, n2) && this.On();
  }
  Vn(t2, i, n2) {
    const s = this.an, e3 = this.on, r2 = this.sn, h2 = this.en, l2 = this.nn, a2 = this.An(n2);
    this.en = t2, this.an = isNaN(t2) ? NaN : this.Ui.yt().Et(t2), this.nn = n2;
    const o2 = null !== a2 ? a2.Pt() : null;
    return null !== a2 && null !== o2 ? (this.sn = i, this.on = a2.Ot(i, o2)) : (this.sn = NaN, this.on = NaN), s !== this.an || e3 !== this.on || h2 !== this.en || r2 !== this.sn || l2 !== this.nn;
  }
  Tn() {
    const t2 = this.Ui.Mt().map((t3) => t3.In().Bn()).filter(z), i = 0 === t2.length ? null : Math.max(...t2);
    this.en = null !== i ? i : NaN;
  }
  Dn(t2, i, n2) {
    let s = t2.get(i);
    return void 0 === s && (s = new et(this, i, n2), t2.set(i, s)), s;
  }
};
function ut$1(t2) {
  return "left" === t2 || "right" === t2;
}
class ct {
  constructor(t2) {
    this.zn = /* @__PURE__ */ new Map(), this.En = [], this.Ln = t2;
  }
  Nn(t2, i) {
    const n2 = function(t3, i2) {
      return void 0 === t3 ? i2 : { Fn: Math.max(t3.Fn, i2.Fn), Wn: t3.Wn || i2.Wn };
    }(this.zn.get(t2), i);
    this.zn.set(t2, n2);
  }
  jn() {
    return this.Ln;
  }
  Hn(t2) {
    const i = this.zn.get(t2);
    return void 0 === i ? { Fn: this.Ln } : { Fn: Math.max(this.Ln, i.Fn), Wn: i.Wn };
  }
  $n() {
    this.Un(), this.En = [{ qn: 0 }];
  }
  Yn(t2) {
    this.Un(), this.En = [{ qn: 1, Vt: t2 }];
  }
  Xn(t2) {
    this.Kn(), this.En.push({ qn: 5, Vt: t2 });
  }
  Un() {
    this.Kn(), this.En.push({ qn: 6 });
  }
  Zn() {
    this.Un(), this.En = [{ qn: 4 }];
  }
  Gn(t2) {
    this.Un(), this.En.push({ qn: 2, Vt: t2 });
  }
  Jn(t2) {
    this.Un(), this.En.push({ qn: 3, Vt: t2 });
  }
  Qn() {
    return this.En;
  }
  ts(t2) {
    for (const i of t2.En)
      this.ns(i);
    this.Ln = Math.max(this.Ln, t2.Ln), t2.zn.forEach((t3, i) => {
      this.Nn(i, t3);
    });
  }
  static ss() {
    return new ct(2);
  }
  static es() {
    return new ct(3);
  }
  ns(t2) {
    switch (t2.qn) {
      case 0:
        this.$n();
        break;
      case 1:
        this.Yn(t2.Vt);
        break;
      case 2:
        this.Gn(t2.Vt);
        break;
      case 3:
        this.Jn(t2.Vt);
        break;
      case 4:
        this.Zn();
        break;
      case 5:
        this.Xn(t2.Vt);
        break;
      case 6:
        this.Kn();
    }
  }
  Kn() {
    const t2 = this.En.findIndex((t3) => 5 === t3.qn);
    -1 !== t2 && this.En.splice(t2, 1);
  }
}
const dt$1 = ".";
function ft$1(t2, i) {
  if (!O$1(t2))
    return "n/a";
  if (!A$1(i))
    throw new TypeError("invalid length");
  if (i < 0 || i > 16)
    throw new TypeError("invalid length");
  if (0 === i)
    return t2.toString();
  return ("0000000000000000" + t2.toString()).slice(-i);
}
let vt$1 = class vt {
  constructor(t2, i) {
    if (i || (i = 1), O$1(t2) && A$1(t2) || (t2 = 100), t2 < 0)
      throw new TypeError("invalid base");
    this.Li = t2, this.rs = i, this.hs();
  }
  format(t2) {
    const i = t2 < 0 ? "" : "";
    return t2 = Math.abs(t2), i + this.ls(t2);
  }
  hs() {
    if (this.os = 0, this.Li > 0 && this.rs > 0) {
      let t2 = this.Li;
      for (; t2 > 1; )
        t2 /= 10, this.os++;
    }
  }
  ls(t2) {
    const i = this.Li / this.rs;
    let n2 = Math.floor(t2), s = "";
    const e3 = void 0 !== this.os ? this.os : NaN;
    if (i > 1) {
      let r2 = +(Math.round(t2 * i) - n2 * i).toFixed(this.os);
      r2 >= i && (r2 -= i, n2 += 1), s = dt$1 + ft$1(+r2.toFixed(this.os) * this.rs, e3);
    } else
      n2 = Math.round(n2 * i) / i, e3 > 0 && (s = dt$1 + ft$1(0, e3));
    return n2.toFixed(0) + s;
  }
};
let pt$1 = class pt extends vt$1 {
  constructor(t2 = 100) {
    super(t2);
  }
  format(t2) {
    return `${super.format(t2)}%`;
  }
};
let mt$1 = class mt {
  constructor(t2) {
    this._s = t2;
  }
  format(t2) {
    let i = "";
    return t2 < 0 && (i = "-", t2 = -t2), t2 < 995 ? i + this.us(t2) : t2 < 999995 ? i + this.us(t2 / 1e3) + "K" : t2 < 999999995 ? (t2 = 1e3 * Math.round(t2 / 1e3), i + this.us(t2 / 1e6) + "M") : (t2 = 1e6 * Math.round(t2 / 1e6), i + this.us(t2 / 1e9) + "B");
  }
  us(t2) {
    let i;
    const n2 = Math.pow(10, this._s);
    return i = (t2 = Math.round(t2 * n2) / n2) >= 1e-15 && t2 < 1 ? t2.toFixed(this._s).replace(/\.?0+$/, "") : String(t2), i.replace(/(\.[1-9]*)0+$/, (t3, i2) => i2);
  }
};
function bt$1(t2, i, n2, s, e3, r2, h2) {
  if (0 === i.length || s.from >= i.length || s.to <= 0)
    return;
  const { context: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = i[s.from];
  let u2 = r2(t2, _24), c2 = _24;
  if (s.to - s.from < 2) {
    const i2 = e3 / 2;
    l2.beginPath();
    const n3 = { et: _24.et - i2, rt: _24.rt }, s2 = { et: _24.et + i2, rt: _24.rt };
    l2.moveTo(n3.et * a2, n3.rt * o2), l2.lineTo(s2.et * a2, s2.rt * o2), h2(t2, u2, n3, s2);
  } else {
    const e4 = (i2, n3) => {
      h2(t2, u2, c2, n3), l2.beginPath(), u2 = i2, c2 = n3;
    };
    let d2 = c2;
    l2.beginPath(), l2.moveTo(_24.et * a2, _24.rt * o2);
    for (let h3 = s.from + 1; h3 < s.to; ++h3) {
      d2 = i[h3];
      const s2 = r2(t2, d2);
      switch (n2) {
        case 0:
          l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 1:
          l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2), s2 !== u2 && (e4(s2, d2), l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2)), l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 2: {
          const [t3, n3] = xt$1(i, h3 - 1, h3);
          l2.bezierCurveTo(t3.et * a2, t3.rt * o2, n3.et * a2, n3.rt * o2, d2.et * a2, d2.rt * o2);
          break;
        }
      }
      1 !== n2 && s2 !== u2 && (e4(s2, d2), l2.moveTo(d2.et * a2, d2.rt * o2));
    }
    (c2 !== d2 || c2 === d2 && 1 === n2) && h2(t2, u2, c2, d2);
  }
}
const wt$1 = 6;
function gt$1(t2, i) {
  return { et: t2.et - i.et, rt: t2.rt - i.rt };
}
function Mt(t2, i) {
  return { et: t2.et / i, rt: t2.rt / i };
}
function xt$1(t2, i, n2) {
  const s = Math.max(0, i - 1), e3 = Math.min(t2.length - 1, n2 + 1);
  var r2, h2;
  return [(r2 = t2[i], h2 = Mt(gt$1(t2[n2], t2[s]), wt$1), { et: r2.et + h2.et, rt: r2.rt + h2.rt }), gt$1(t2[n2], Mt(gt$1(t2[e3], t2[i]), wt$1))];
}
function St$1(t2, i, n2, s, e3) {
  const { context: r2, horizontalPixelRatio: h2, verticalPixelRatio: l2 } = i;
  r2.lineTo(e3.et * h2, t2 * l2), r2.lineTo(s.et * h2, t2 * l2), r2.closePath(), r2.fillStyle = n2, r2.fill();
}
class kt extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    var i;
    if (null === this.tt)
      return;
    const { st: n2, nt: s, cs: e3, ht: r2, Wt: h2, ds: l2 } = this.tt, a2 = null !== (i = this.tt.fs) && void 0 !== i ? i : this.tt.vs ? 0 : t2.mediaSize.height;
    if (null === s)
      return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineJoin = "round", o2.lineWidth = r2, f(o2, h2), o2.lineWidth = 1, bt$1(t2, n2, l2, s, e3, this.ps.bind(this), St$1.bind(null, a2));
  }
}
function yt$1(t2, i, n2) {
  return Math.min(Math.max(t2, i), n2);
}
function Ct$1(t2, i, n2) {
  return i - t2 <= n2;
}
function Tt$1(t2) {
  const i = Math.ceil(t2);
  return i % 2 == 0 ? i - 1 : i;
}
let Pt$1 = class Pt {
  bs(t2, i) {
    const n2 = this.ws, { gs: s, Ms: e3, xs: r2, Ss: h2, ks: l2, fs: a2 } = i;
    if (void 0 === this.ys || void 0 === n2 || n2.gs !== s || n2.Ms !== e3 || n2.xs !== r2 || n2.Ss !== h2 || n2.fs !== a2 || n2.ks !== l2) {
      const n3 = t2.context.createLinearGradient(0, 0, 0, l2);
      if (n3.addColorStop(0, s), null != a2) {
        const i2 = yt$1(a2 * t2.verticalPixelRatio / l2, 0, 1);
        n3.addColorStop(i2, e3), n3.addColorStop(i2, r2);
      }
      n3.addColorStop(1, h2), this.ys = n3, this.ws = i;
    }
    return this.ys;
  }
};
let Rt$1 = class Rt extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    return this.Cs.bs(t2, { gs: i.Ts, Ms: "", xs: "", Ss: i.Ps, ks: t2.bitmapSize.height });
  }
};
function Dt$1(t2, i) {
  const n2 = t2.context;
  n2.strokeStyle = i, n2.stroke();
}
let Ot$1 = class Ot extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    if (null === this.tt)
      return;
    const { st: i, nt: n2, cs: s, ds: e3, ht: r2, Wt: h2, Rs: l2 } = this.tt;
    if (null === n2)
      return;
    const a2 = t2.context;
    a2.lineCap = "butt", a2.lineWidth = r2 * t2.verticalPixelRatio, f(a2, h2), a2.lineJoin = "round";
    const o2 = this.Ds.bind(this);
    void 0 !== e3 && bt$1(t2, i, e3, n2, s, o2, Dt$1), l2 && function(t3, i2, n3, s2, e4) {
      const { horizontalPixelRatio: r3, verticalPixelRatio: h3, context: l3 } = t3;
      let a3 = null;
      const o3 = Math.max(1, Math.floor(r3)) % 2 / 2, _24 = n3 * h3 + o3;
      for (let n4 = s2.to - 1; n4 >= s2.from; --n4) {
        const s3 = i2[n4];
        if (s3) {
          const i3 = e4(t3, s3);
          i3 !== a3 && (l3.beginPath(), null !== a3 && l3.fill(), l3.fillStyle = i3, a3 = i3);
          const n5 = Math.round(s3.et * r3) + o3, u2 = s3.rt * h3;
          l3.moveTo(n5, u2), l3.arc(n5, u2, _24, 0, 2 * Math.PI);
        }
      }
      l3.fill();
    }(t2, i, l2, n2, o2);
  }
};
let At$1 = class At extends Ot$1 {
  Ds(t2, i) {
    return i._t;
  }
};
function Vt$1(t2, i, n2, s, e3 = 0, r2 = i.length) {
  let h2 = r2 - e3;
  for (; 0 < h2; ) {
    const r3 = h2 >> 1, l2 = e3 + r3;
    s(i[l2], n2) === t2 ? (e3 = l2 + 1, h2 -= r3 + 1) : h2 = r3;
  }
  return e3;
}
const Bt$1 = Vt$1.bind(null, true), It$1 = Vt$1.bind(null, false);
function zt$1(t2, i) {
  return t2.ut < i;
}
function Et$1(t2, i) {
  return i < t2.ut;
}
function Lt$1(t2, i, n2) {
  const s = i.Os(), e3 = i.di(), r2 = Bt$1(t2, s, zt$1), h2 = It$1(t2, e3, Et$1);
  if (!n2)
    return { from: r2, to: h2 };
  let l2 = r2, a2 = h2;
  return r2 > 0 && r2 < t2.length && t2[r2].ut >= s && (l2 = r2 - 1), h2 > 0 && h2 < t2.length && t2[h2 - 1].ut <= e3 && (a2 = h2 + 1), { from: l2, to: a2 };
}
let Nt$1 = class Nt {
  constructor(t2, i, n2) {
    this.As = true, this.Vs = true, this.Bs = true, this.Is = [], this.zs = null, this.Es = t2, this.Ls = i, this.Ns = n2;
  }
  gt(t2) {
    this.As = true, "data" === t2 && (this.Vs = true), "options" === t2 && (this.Bs = true);
  }
  xt() {
    return this.Es.Tt() ? (this.Fs(), null === this.zs ? null : this.Ws) : null;
  }
  js() {
    this.Is = this.Is.map((t2) => Object.assign(Object.assign({}, t2), this.Es.$s().Hs(t2.ut)));
  }
  Us() {
    this.zs = null;
  }
  Fs() {
    this.Vs && (this.qs(), this.Vs = false), this.Bs && (this.js(), this.Bs = false), this.As && (this.Ys(), this.As = false);
  }
  Ys() {
    const t2 = this.Es.At(), i = this.Ls.yt();
    if (this.Us(), i.Fi() || t2.Fi())
      return;
    const n2 = i.Xs();
    if (null === n2)
      return;
    if (0 === this.Es.In().Ks())
      return;
    const s = this.Es.Pt();
    null !== s && (this.zs = Lt$1(this.Is, n2, this.Ns), this.Zs(t2, i, s.Vt), this.Gs());
  }
};
let Ft$1 = class Ft extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, true);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.Qs(this.Is, n2, E(this.zs));
  }
  te(t2, i) {
    return { ut: t2, ct: i, et: NaN, rt: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => {
      const n2 = i.Vt[3];
      return this.ne(i.se, n2, t2);
    });
  }
};
let Wt$1 = class Wt extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.ee = new Rt$1(), this.re = new At$1(), this.Ws.X([this.ee, this.re]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.ee.it({ ds: t2.lineType, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, fs: null, vs: t2.invertFilledArea, nt: this.zs, cs: this.Ls.yt().he() }), this.re.it({ ds: t2.lineVisible ? t2.lineType : void 0, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, nt: this.zs, cs: this.Ls.yt().he(), Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0 });
  }
};
let jt$1 = class jt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0, this.ae = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (null === this.Lt || 0 === this.Lt.In.length || null === this.Lt.nt)
      return;
    if (this.le = this.oe(i), this.le >= 2) {
      Math.max(1, Math.floor(i)) % 2 != this.le % 2 && this.le--;
    }
    this.ae = this.Lt._e ? Math.min(this.le, Math.floor(i)) : this.le;
    let s = null;
    const e3 = this.ae <= this.le && this.Lt.he >= Math.floor(1.5 * i);
    for (let r2 = this.Lt.nt.from; r2 < this.Lt.nt.to; ++r2) {
      const h2 = this.Lt.In[r2];
      s !== h2.ue && (t2.fillStyle = h2.ue, s = h2.ue);
      const l2 = Math.floor(0.5 * this.ae), a2 = Math.round(h2.et * i), o2 = a2 - l2, _24 = this.ae, u2 = o2 + _24 - 1, c2 = Math.min(h2.ce, h2.de), d2 = Math.max(h2.ce, h2.de), f2 = Math.round(c2 * n2) - l2, v2 = Math.round(d2 * n2) + l2, p2 = Math.max(v2 - f2, this.ae);
      t2.fillRect(o2, f2, _24, p2);
      const m2 = Math.ceil(1.5 * this.le);
      if (e3) {
        if (this.Lt.fe) {
          const i3 = a2 - m2;
          let s3 = Math.max(f2, Math.round(h2.ve * n2) - l2), e5 = s3 + _24 - 1;
          e5 > f2 + p2 - 1 && (e5 = f2 + p2 - 1, s3 = e5 - _24 + 1), t2.fillRect(i3, s3, o2 - i3, e5 - s3 + 1);
        }
        const i2 = a2 + m2;
        let s2 = Math.max(f2, Math.round(h2.pe * n2) - l2), e4 = s2 + _24 - 1;
        e4 > f2 + p2 - 1 && (e4 = f2 + p2 - 1, s2 = e4 - _24 + 1), t2.fillRect(u2 + 1, s2, i2 - u2, e4 - s2 + 1);
      }
    }
  }
  oe(t2) {
    const i = Math.floor(t2);
    return Math.max(i, Math.floor(function(t3, i2) {
      return Math.floor(0.3 * t3 * i2);
    }(b(this.Lt).he, t2)));
  }
};
let Ht$1 = class Ht extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, false);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.me(this.Is, n2, E(this.zs));
  }
  be(t2, i, n2) {
    return { ut: t2, we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3], et: NaN, ve: NaN, ce: NaN, de: NaN, pe: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => this.ne(i.se, i, t2));
  }
};
let $t$1 = class $t extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new jt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), fe: t2.openVisible, _e: t2.thinBars, nt: this.zs });
  }
};
let Ut$1 = class Ut extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    const n2 = this.tt;
    return this.Cs.bs(t2, { gs: i.Se, Ms: i.ke, xs: i.ye, Ss: i.Ce, ks: t2.bitmapSize.height, fs: n2.fs });
  }
};
let qt$1 = class qt extends Ot$1 {
  constructor() {
    super(...arguments), this.Te = new Pt$1();
  }
  Ds(t2, i) {
    const n2 = this.tt;
    return this.Te.bs(t2, { gs: i.Pe, Ms: i.Pe, xs: i.Re, Ss: i.Re, ks: t2.bitmapSize.height, fs: n2.fs });
  }
};
let Yt$1 = class Yt extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.De = new Ut$1(), this.Oe = new qt$1(), this.Ws.X([this.De, this.Oe]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.Pt();
    if (null === t2)
      return;
    const i = this.Es.W(), n2 = this.Es.At().Ot(i.baseValue.price, t2.Vt), s = this.Ls.yt().he();
    this.De.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineType, fs: n2, vs: false, nt: this.zs, cs: s }), this.Oe.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineVisible ? i.lineType : void 0, Rs: i.pointMarkersVisible ? i.pointMarkersRadius || i.lineWidth / 2 + 2 : void 0, fs: n2, nt: this.zs, cs: s });
  }
};
let Xt$1 = class Xt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z(t2) {
    if (null === this.Lt || 0 === this.Lt.In.length || null === this.Lt.nt)
      return;
    const { horizontalPixelRatio: i } = t2;
    if (this.le = function(t3, i2) {
      if (t3 >= 2.5 && t3 <= 4)
        return Math.floor(3 * i2);
      const n3 = 1 - 0.2 * Math.atan(Math.max(4, t3) - 4) / (0.5 * Math.PI), s2 = Math.floor(t3 * n3 * i2), e3 = Math.floor(t3 * i2), r2 = Math.min(s2, e3);
      return Math.max(Math.floor(i2), r2);
    }(this.Lt.he, i), this.le >= 2) {
      Math.floor(i) % 2 != this.le % 2 && this.le--;
    }
    const n2 = this.Lt.In;
    this.Lt.Ae && this.Ve(t2, n2, this.Lt.nt), this.Lt.ci && this.Be(t2, n2, this.Lt.nt);
    const s = this.Ie(i);
    (!this.Lt.ci || this.le > 2 * s) && this.ze(t2, n2, this.Lt.nt);
  }
  Ve(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "", l2 = Math.min(Math.floor(e3), Math.floor(this.Lt.he * e3));
    l2 = Math.max(Math.floor(e3), Math.min(l2, this.le));
    const a2 = Math.floor(0.5 * l2);
    let o2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Ee !== h2 && (s.fillStyle = n3.Ee, h2 = n3.Ee);
      const _24 = Math.round(Math.min(n3.ve, n3.pe) * r2), u2 = Math.round(Math.max(n3.ve, n3.pe) * r2), c2 = Math.round(n3.ce * r2), d2 = Math.round(n3.de * r2);
      let f2 = Math.round(e3 * n3.et) - a2;
      const v2 = f2 + l2 - 1;
      null !== o2 && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, v2));
      const p2 = v2 - f2 + 1;
      s.fillRect(f2, c2, p2, _24 - c2), s.fillRect(f2, u2 + 1, p2, d2 - u2), o2 = v2;
    }
  }
  Ie(t2) {
    let i = Math.floor(1 * t2);
    this.le <= 2 * i && (i = Math.floor(0.5 * (this.le - 1)));
    const n2 = Math.max(Math.floor(t2), i);
    return this.le <= 2 * n2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : n2;
  }
  Be(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e3);
    let a2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Le !== h2 && (s.fillStyle = n3.Le, h2 = n3.Le);
      let o2 = Math.round(n3.et * e3) - Math.floor(0.5 * this.le);
      const _24 = o2 + this.le - 1, u2 = Math.round(Math.min(n3.ve, n3.pe) * r2), c2 = Math.round(Math.max(n3.ve, n3.pe) * r2);
      if (null !== a2 && (o2 = Math.max(a2 + 1, o2), o2 = Math.min(o2, _24)), this.Lt.he * e3 > 2 * l2)
        Z$1(s, o2, u2, _24 - o2 + 1, c2 - u2 + 1, l2);
      else {
        const t4 = _24 - o2 + 1;
        s.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      a2 = _24;
    }
  }
  ze(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e3);
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      let a2 = Math.round(Math.min(n3.ve, n3.pe) * r2), o2 = Math.round(Math.max(n3.ve, n3.pe) * r2), _24 = Math.round(n3.et * e3) - Math.floor(0.5 * this.le), u2 = _24 + this.le - 1;
      if (n3.ue !== h2) {
        const t4 = n3.ue;
        s.fillStyle = t4, h2 = t4;
      }
      this.Lt.ci && (_24 += l2, a2 += l2, u2 -= l2, o2 -= l2), a2 > o2 || s.fillRect(_24, a2, u2 - _24 + 1, o2 - a2 + 1);
    }
  }
};
let Kt$1 = class Kt extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new Xt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), Ae: t2.wickVisible, ci: t2.borderVisible, nt: this.zs });
  }
};
let Zt$1 = class Zt {
  constructor(t2, i) {
    this.Ne = t2, this.Li = i;
  }
  K(t2, i, n2) {
    this.Ne.draw(t2, this.Li, i, n2);
  }
};
let Gt$1 = class Gt extends Nt$1 {
  constructor(t2, i, n2) {
    super(t2, i, false), this.wn = n2, this.Ws = new Zt$1(this.wn.renderer(), (i2) => {
      const n3 = t2.Pt();
      return null === n3 ? null : t2.At().Ot(i2, n3.Vt);
    });
  }
  Fe(t2) {
    return this.wn.priceValueBuilder(t2);
  }
  We(t2) {
    return this.wn.isWhitespace(t2);
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => Object.assign(Object.assign({ ut: i.se, et: NaN }, t2.Hs(i.se)), { je: i.He }));
  }
  Zs(t2, i) {
    i.Js(this.Is, E(this.zs));
  }
  Gs() {
    this.wn.update({ bars: this.Is.map(Jt$1), barSpacing: this.Ls.yt().he(), visibleRange: this.zs }, this.Es.W());
  }
};
function Jt$1(t2) {
  return { x: t2.et, time: t2.ut, originalData: t2.je, barColor: t2.ue };
}
let Qt$1 = class Qt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.$e = [];
  }
  it(t2) {
    this.Lt = t2, this.$e = [];
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (null === this.Lt || 0 === this.Lt.st.length || null === this.Lt.nt)
      return;
    this.$e.length || this.Ue(i);
    const s = Math.max(1, Math.floor(n2)), e3 = Math.round(this.Lt.qe * n2) - Math.floor(s / 2), r2 = e3 + s;
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const h2 = this.Lt.st[i2], l2 = this.$e[i2 - this.Lt.nt.from], a2 = Math.round(h2.rt * n2);
      let o2, _24;
      t2.fillStyle = h2.ue, a2 <= e3 ? (o2 = a2, _24 = r2) : (o2 = e3, _24 = a2 - Math.floor(s / 2) + s), t2.fillRect(l2.Os, o2, l2.di - l2.Os + 1, _24 - o2);
    }
  }
  Ue(t2) {
    if (null === this.Lt || 0 === this.Lt.st.length || null === this.Lt.nt)
      return void (this.$e = []);
    const i = Math.ceil(this.Lt.he * t2) <= 1 ? 0 : Math.max(1, Math.floor(t2)), n2 = Math.round(this.Lt.he * t2) - i;
    this.$e = new Array(this.Lt.nt.to - this.Lt.nt.from);
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const s2 = this.Lt.st[i2], e3 = Math.round(s2.et * t2);
      let r2, h2;
      if (n2 % 2) {
        const t3 = (n2 - 1) / 2;
        r2 = e3 - t3, h2 = e3 + t3;
      } else {
        const t3 = n2 / 2;
        r2 = e3 - t3, h2 = e3 + t3 - 1;
      }
      this.$e[i2 - this.Lt.nt.from] = { Os: r2, di: h2, Ye: e3, Xe: s2.et * t2, ut: s2.ut };
    }
    for (let t3 = this.Lt.nt.from + 1; t3 < this.Lt.nt.to; t3++) {
      const n3 = this.$e[t3 - this.Lt.nt.from], s2 = this.$e[t3 - this.Lt.nt.from - 1];
      n3.ut === s2.ut + 1 && (n3.Os - s2.di !== i + 1 && (s2.Ye > s2.Xe ? s2.di = n3.Os - i - 1 : n3.Os = s2.di + i + 1));
    }
    let s = Math.ceil(this.Lt.he * t2);
    for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
      const i2 = this.$e[t3 - this.Lt.nt.from];
      i2.di < i2.Os && (i2.di = i2.Os);
      const n3 = i2.di - i2.Os + 1;
      s = Math.min(n3, s);
    }
    if (i > 0 && s < 4)
      for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
        const i2 = this.$e[t3 - this.Lt.nt.from];
        i2.di - i2.Os + 1 > s && (i2.Ye > i2.Xe ? i2.di -= 1 : i2.Os += 1);
      }
  }
};
class ti extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new Qt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = { st: this.Is, he: this.Ls.yt().he(), nt: this.zs, qe: this.Es.At().Ot(this.Es.W().base, b(this.Es.Pt()).Vt) };
    this.Ws.it(t2);
  }
}
class ii extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new At$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W(), i = { st: this.Is, Wt: t2.lineStyle, ds: t2.lineVisible ? t2.lineType : void 0, ht: t2.lineWidth, Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0, nt: this.zs, cs: this.Ls.yt().he() };
    this.Ws.it(i);
  }
}
const ni = /[2-9]/g;
class si {
  constructor(t2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Je = {}, this.Qe = /* @__PURE__ */ new Map(), this.tr = t2;
  }
  ir() {
    this.Ke = 0, this.Qe.clear(), this.Ze = 1, this.Ge = 1, this.Je = {};
  }
  Si(t2, i, n2) {
    return this.nr(t2, i, n2).width;
  }
  xi(t2, i, n2) {
    const s = this.nr(t2, i, n2);
    return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2;
  }
  nr(t2, i, n2) {
    const s = n2 || ni, e3 = String(i).replace(s, "0");
    if (this.Qe.has(e3))
      return m$1(this.Qe.get(e3)).sr;
    if (this.Ke === this.tr) {
      const t3 = this.Je[this.Ge];
      delete this.Je[this.Ge], this.Qe.delete(t3), this.Ge++, this.Ke--;
    }
    t2.save(), t2.textBaseline = "middle";
    const r2 = t2.measureText(e3);
    return t2.restore(), 0 === r2.width && i.length || (this.Qe.set(e3, { sr: r2, er: this.Ze }), this.Je[this.Ze] = e3, this.Ke++, this.Ze++), r2;
  }
}
class ei {
  constructor(t2) {
    this.rr = null, this.k = null, this.hr = "right", this.lr = t2;
  }
  ar(t2, i, n2) {
    this.rr = t2, this.k = i, this.hr = n2;
  }
  K(t2) {
    null !== this.k && null !== this.rr && this.rr.K(t2, this.k, this.lr, this.hr);
  }
}
class ri {
  constructor(t2, i, n2) {
    this._r = t2, this.lr = new si(50), this.ur = i, this.F = n2, this.j = -1, this.Ht = new ei(this.lr);
  }
  xt() {
    const t2 = this.F.cr(this.ur);
    if (null === t2)
      return null;
    const i = t2.dr(this.ur) ? t2.vr() : this.ur.At();
    if (null === i)
      return null;
    const n2 = t2.pr(i);
    if ("overlay" === n2)
      return null;
    const s = this.F.mr();
    return s.P !== this.j && (this.j = s.P, this.lr.ir()), this.Ht.ar(this._r.zi(), s, n2), this.Ht;
  }
}
class hi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  br(t2, i) {
    var n2;
    if (!(null === (n2 = this.Lt) || void 0 === n2 ? void 0 : n2.Tt))
      return null;
    const { rt: s, ht: e3, wr: r2 } = this.Lt;
    return i >= s - e3 - 7 && i <= s + e3 + 7 ? { gr: this.Lt, wr: r2 } : null;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    if (false === this.Lt.Tt)
      return;
    const e3 = Math.round(this.Lt.rt * s);
    e3 < 0 || e3 > i.height || (t2.lineCap = "butt", t2.strokeStyle = this.Lt.O, t2.lineWidth = Math.floor(this.Lt.ht * n2), f(t2, this.Lt.Wt), v(t2, e3, 0, i.width));
  }
}
class li {
  constructor(t2) {
    this.Mr = { rt: 0, O: "rgba(0, 0, 0, 0)", ht: 1, Wt: 0, Tt: false }, this.Sr = new hi(), this.bt = true, this.Es = t2, this.Ls = t2.qt(), this.Sr.it(this.Mr);
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.Es.Tt() ? (this.bt && (this.kr(), this.bt = false), this.Sr) : null;
  }
}
class ai extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    this.Mr.Tt = false;
    const t2 = this.Es.At(), i = t2.yr().yr;
    if (2 !== i && 3 !== i)
      return;
    const n2 = this.Es.W();
    if (!n2.baseLineVisible || !this.Es.Tt())
      return;
    const s = this.Es.Pt();
    null !== s && (this.Mr.Tt = true, this.Mr.rt = t2.Ot(s.Vt, s.Vt), this.Mr.O = n2.baseLineColor, this.Mr.ht = n2.baseLineWidth, this.Mr.Wt = n2.baseLineStyle);
  }
}
class oi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  He() {
    return this.Lt;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    const s = this.Lt;
    if (null === s)
      return;
    const e3 = Math.max(1, Math.floor(i)), r2 = e3 % 2 / 2, h2 = Math.round(s.Xe.x * i) + r2, l2 = s.Xe.y * n2;
    t2.fillStyle = s.Cr, t2.beginPath();
    const a2 = Math.max(2, 1.5 * s.Tr) * i;
    t2.arc(h2, l2, a2, 0, 2 * Math.PI, false), t2.fill(), t2.fillStyle = s.Pr, t2.beginPath(), t2.arc(h2, l2, s.ot * i, 0, 2 * Math.PI, false), t2.fill(), t2.lineWidth = e3, t2.strokeStyle = s.Rr, t2.beginPath(), t2.arc(h2, l2, s.ot * i + e3 / 2, 0, 2 * Math.PI, false), t2.stroke();
  }
}
const _i = [{ Dr: 0, Or: 0.25, Ar: 4, Vr: 10, Br: 0.25, Ir: 0, zr: 0.4, Er: 0.8 }, { Dr: 0.25, Or: 0.525, Ar: 10, Vr: 14, Br: 0, Ir: 0, zr: 0.8, Er: 0 }, { Dr: 0.525, Or: 1, Ar: 14, Vr: 14, Br: 0, Ir: 0, zr: 0, Er: 0 }];
function ui(t2, i, n2, s) {
  return function(t3, i2) {
    if ("transparent" === t3)
      return t3;
    const n3 = T$1(t3), s2 = n3[3];
    return `rgba(${n3[0]}, ${n3[1]}, ${n3[2]}, ${i2 * s2})`;
  }(t2, n2 + (s - n2) * i);
}
function ci(t2, i) {
  const n2 = t2 % 2600 / 2600;
  let s;
  for (const t3 of _i)
    if (n2 >= t3.Dr && n2 <= t3.Or) {
      s = t3;
      break;
    }
  p$1(void 0 !== s, "Last price animation internal logic error");
  const e3 = (n2 - s.Dr) / (s.Or - s.Dr);
  return { Pr: ui(i, e3, s.Br, s.Ir), Rr: ui(i, e3, s.zr, s.Er), ot: (r2 = e3, h2 = s.Ar, l2 = s.Vr, h2 + (l2 - h2) * r2) };
  var r2, h2, l2;
}
class di {
  constructor(t2) {
    this.Ht = new oi(), this.bt = true, this.Lr = true, this.Nr = performance.now(), this.Fr = this.Nr - 1, this.Wr = t2;
  }
  jr() {
    this.Fr = this.Nr - 1, this.gt();
  }
  Hr() {
    if (this.gt(), 2 === this.Wr.W().lastPriceAnimation) {
      const t2 = performance.now(), i = this.Fr - t2;
      if (i > 0)
        return void (i < 650 && (this.Fr += 2600));
      this.Nr = t2, this.Fr = t2 + 2600;
    }
  }
  gt() {
    this.bt = true;
  }
  $r() {
    this.Lr = true;
  }
  Tt() {
    return 0 !== this.Wr.W().lastPriceAnimation;
  }
  Ur() {
    switch (this.Wr.W().lastPriceAnimation) {
      case 0:
        return false;
      case 1:
        return true;
      case 2:
        return performance.now() <= this.Fr;
    }
  }
  xt() {
    return this.bt ? (this.St(), this.bt = false, this.Lr = false) : this.Lr && (this.qr(), this.Lr = false), this.Ht;
  }
  St() {
    this.Ht.it(null);
    const t2 = this.Wr.qt().yt(), i = t2.Xs(), n2 = this.Wr.Pt();
    if (null === i || null === n2)
      return;
    const s = this.Wr.Yr(true);
    if (s.Xr || !i.Kr(s.se))
      return;
    const e3 = { x: t2.Et(s.se), y: this.Wr.At().Ot(s.ct, n2.Vt) }, r2 = s.O, h2 = this.Wr.W().lineWidth, l2 = ci(this.Zr(), r2);
    this.Ht.it({ Cr: r2, Tr: h2, Pr: l2.Pr, Rr: l2.Rr, ot: l2.ot, Xe: e3 });
  }
  qr() {
    const t2 = this.Ht.He();
    if (null !== t2) {
      const i = ci(this.Zr(), t2.Cr);
      t2.Pr = i.Pr, t2.Rr = i.Rr, t2.ot = i.ot;
    }
  }
  Zr() {
    return this.Ur() ? performance.now() - this.Nr : 2599;
  }
}
function fi(t2, i) {
  return Tt$1(Math.min(Math.max(t2, 12), 30) * i);
}
function vi(t2, i) {
  switch (t2) {
    case "arrowDown":
    case "arrowUp":
      return fi(i, 1);
    case "circle":
      return fi(i, 0.8);
    case "square":
      return fi(i, 0.7);
  }
}
function pi(t2) {
  return function(t3) {
    const i = Math.ceil(t3);
    return i % 2 != 0 ? i - 1 : i;
  }(fi(t2, 1));
}
function mi(t2) {
  return Math.max(fi(t2, 0.1), 3);
}
function bi(t2, i, n2, s, e3) {
  const r2 = vi("square", n2), h2 = (r2 - 1) / 2, l2 = t2 - h2, a2 = i - h2;
  return s >= l2 && s <= l2 + r2 && e3 >= a2 && e3 <= a2 + r2;
}
function wi(t2, i, n2, s, e3) {
  const r2 = (vi("arrowUp", e3) - 1) / 2, h2 = (Tt$1(e3 / 2) - 1) / 2;
  i.beginPath(), t2 ? (i.moveTo(n2 - r2, s), i.lineTo(n2, s - r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s + r2), i.lineTo(n2 - h2, s + r2), i.lineTo(n2 - h2, s)) : (i.moveTo(n2 - r2, s), i.lineTo(n2, s + r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s - r2), i.lineTo(n2 - h2, s - r2), i.lineTo(n2 - h2, s)), i.fill();
}
function gi(t2, i, n2, s, e3, r2) {
  return bi(i, n2, s, e3, r2);
}
class Mi extends j {
  constructor() {
    super(...arguments), this.Lt = null, this.lr = new si(), this.j = -1, this.H = "", this.Gr = "";
  }
  it(t2) {
    this.Lt = t2;
  }
  ar(t2, i) {
    this.j === t2 && this.H === i || (this.j = t2, this.H = i, this.Gr = N$1(t2, i), this.lr.ir());
  }
  br(t2, i) {
    if (null === this.Lt || null === this.Lt.nt)
      return null;
    for (let n2 = this.Lt.nt.from; n2 < this.Lt.nt.to; n2++) {
      const s = this.Lt.st[n2];
      if (Si(s, t2, i))
        return { gr: s.Jr, wr: s.wr };
    }
    return null;
  }
  Z({ context: t2 }, i, n2) {
    if (null !== this.Lt && null !== this.Lt.nt) {
      t2.textBaseline = "middle", t2.font = this.Gr;
      for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
        const n3 = this.Lt.st[i2];
        void 0 !== n3.Jt && (n3.Jt.$i = this.lr.Si(t2, n3.Jt.Qr), n3.Jt.zt = this.j, n3.Jt.et = n3.et - n3.Jt.$i / 2), xi(n3, t2);
      }
    }
  }
}
function xi(t2, i) {
  i.fillStyle = t2.O, void 0 !== t2.Jt && function(t3, i2, n2, s) {
    t3.fillText(i2, n2, s);
  }(i, t2.Jt.Qr, t2.Jt.et, t2.Jt.rt), function(t3, i2) {
    if (0 === t3.Ks)
      return;
    switch (t3.th) {
      case "arrowDown":
        return void wi(false, i2, t3.et, t3.rt, t3.Ks);
      case "arrowUp":
        return void wi(true, i2, t3.et, t3.rt, t3.Ks);
      case "circle":
        return void function(t4, i3, n2, s) {
          const e3 = (vi("circle", s) - 1) / 2;
          t4.beginPath(), t4.arc(i3, n2, e3, 0, 2 * Math.PI, false), t4.fill();
        }(i2, t3.et, t3.rt, t3.Ks);
      case "square":
        return void function(t4, i3, n2, s) {
          const e3 = vi("square", s), r2 = (e3 - 1) / 2, h2 = i3 - r2, l2 = n2 - r2;
          t4.fillRect(h2, l2, e3, e3);
        }(i2, t3.et, t3.rt, t3.Ks);
    }
    t3.th;
  }(t2, i);
}
function Si(t2, i, n2) {
  return !(void 0 === t2.Jt || !function(t3, i2, n3, s, e3, r2) {
    const h2 = s / 2;
    return e3 >= t3 && e3 <= t3 + n3 && r2 >= i2 - h2 && r2 <= i2 + h2;
  }(t2.Jt.et, t2.Jt.rt, t2.Jt.$i, t2.Jt.zt, i, n2)) || function(t3, i2, n3) {
    if (0 === t3.Ks)
      return false;
    switch (t3.th) {
      case "arrowDown":
      case "arrowUp":
        return gi(0, t3.et, t3.rt, t3.Ks, i2, n3);
      case "circle":
        return function(t4, i3, n4, s, e3) {
          const r2 = 2 + vi("circle", n4) / 2, h2 = t4 - s, l2 = i3 - e3;
          return Math.sqrt(h2 * h2 + l2 * l2) <= r2;
        }(t3.et, t3.rt, t3.Ks, i2, n3);
      case "square":
        return bi(t3.et, t3.rt, t3.Ks, i2, n3);
    }
  }(t2, i, n2);
}
function ki(t2, i, n2, s, e3, r2, h2, l2, a2) {
  const o2 = O$1(n2) ? n2 : n2.xe, _24 = O$1(n2) ? n2 : n2.ge, u2 = O$1(n2) ? n2 : n2.Me, c2 = O$1(i.size) ? Math.max(i.size, 0) : 1, d2 = pi(l2.he()) * c2, f2 = d2 / 2;
  switch (t2.Ks = d2, i.position) {
    case "inBar":
      return t2.rt = h2.Ot(o2, a2), void (void 0 !== t2.Jt && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e3));
    case "aboveBar":
      return t2.rt = h2.Ot(_24, a2) - f2 - s.ih, void 0 !== t2.Jt && (t2.Jt.rt = t2.rt - f2 - 0.6 * e3, s.ih += 1.2 * e3), void (s.ih += d2 + r2);
    case "belowBar":
      return t2.rt = h2.Ot(u2, a2) + f2 + s.nh, void 0 !== t2.Jt && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e3, s.nh += 1.2 * e3), void (s.nh += d2 + r2);
  }
  i.position;
}
class yi {
  constructor(t2, i) {
    this.bt = true, this.sh = true, this.eh = true, this.rh = null, this.Ht = new Mi(), this.Wr = t2, this.Ui = i, this.Lt = { st: [], nt: null };
  }
  gt(t2) {
    this.bt = true, this.eh = true, "data" === t2 && (this.sh = true);
  }
  xt(t2) {
    if (!this.Wr.Tt())
      return null;
    this.bt && this.hh();
    const i = this.Ui.W().layout;
    return this.Ht.ar(i.fontSize, i.fontFamily), this.Ht.it(this.Lt), this.Ht;
  }
  lh() {
    if (this.eh) {
      if (this.Wr.ah().length > 0) {
        const t2 = this.Ui.yt().he(), i = mi(t2), n2 = 1.5 * pi(t2) + 2 * i;
        this.rh = { above: n2, below: n2 };
      } else
        this.rh = null;
      this.eh = false;
    }
    return this.rh;
  }
  hh() {
    const t2 = this.Wr.At(), i = this.Ui.yt(), n2 = this.Wr.ah();
    this.sh && (this.Lt.st = n2.map((t3) => ({ ut: t3.time, et: 0, rt: 0, Ks: 0, th: t3.shape, O: t3.color, Jr: t3.Jr, wr: t3.id, Jt: void 0 })), this.sh = false);
    const s = this.Ui.W().layout;
    this.Lt.nt = null;
    const e3 = i.Xs();
    if (null === e3)
      return;
    const r2 = this.Wr.Pt();
    if (null === r2)
      return;
    if (0 === this.Lt.st.length)
      return;
    let h2 = NaN;
    const l2 = mi(i.he()), a2 = { ih: l2, nh: l2 };
    this.Lt.nt = Lt$1(this.Lt.st, e3, true);
    for (let e4 = this.Lt.nt.from; e4 < this.Lt.nt.to; e4++) {
      const o2 = n2[e4];
      o2.time !== h2 && (a2.ih = l2, a2.nh = l2, h2 = o2.time);
      const _24 = this.Lt.st[e4];
      _24.et = i.Et(o2.time), void 0 !== o2.text && o2.text.length > 0 && (_24.Jt = { Qr: o2.text, et: 0, rt: 0, $i: 0, zt: 0 });
      const u2 = this.Wr.oh(o2.time);
      null !== u2 && ki(_24, o2, u2, a2, s.fontSize, l2, t2, i, r2.Vt);
    }
    this.bt = false;
  }
}
class Ci extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = false;
    const i = this.Es.W();
    if (!i.priceLineVisible || !this.Es.Tt())
      return;
    const n2 = this.Es.Yr(0 === i.priceLineSource);
    n2.Xr || (t2.Tt = true, t2.rt = n2.yi, t2.O = this.Es._h(n2.O), t2.ht = i.priceLineWidth, t2.Wt = i.priceLineStyle);
  }
}
class Ti extends st {
  constructor(t2) {
    super(), this.$t = t2;
  }
  Ei(t2, i, n2) {
    t2.Tt = false, i.Tt = false;
    const s = this.$t;
    if (!s.Tt())
      return;
    const e3 = s.W(), r2 = e3.lastValueVisible, h2 = "" !== s.uh(), l2 = 0 === e3.seriesLastValueMode, a2 = s.Yr(false);
    if (a2.Xr)
      return;
    r2 && (t2.Jt = this.dh(a2, r2, l2), t2.Tt = 0 !== t2.Jt.length), (h2 || l2) && (i.Jt = this.fh(a2, r2, h2, l2), i.Tt = i.Jt.length > 0);
    const o2 = s._h(a2.O), _24 = P(o2);
    n2.t = _24.t, n2.yi = a2.yi, i.Bt = s.qt().It(a2.yi / s.At().zt()), t2.Bt = o2, t2.O = _24.i, i.O = _24.i;
  }
  fh(t2, i, n2, s) {
    let e3 = "";
    const r2 = this.$t.uh();
    return n2 && 0 !== r2.length && (e3 += `${r2} `), i && s && (e3 += this.$t.At().ph() ? t2.mh : t2.bh), e3.trim();
  }
  dh(t2, i, n2) {
    return i ? n2 ? this.$t.At().ph() ? t2.bh : t2.mh : t2.Jt : "";
  }
}
function Pi(t2, i, n2, s) {
  const e3 = Number.isFinite(i), r2 = Number.isFinite(n2);
  return e3 && r2 ? t2(i, n2) : e3 || r2 ? e3 ? i : n2 : s;
}
class Ri {
  constructor(t2, i) {
    this.wh = t2, this.gh = i;
  }
  Mh(t2) {
    return null !== t2 && (this.wh === t2.wh && this.gh === t2.gh);
  }
  xh() {
    return new Ri(this.wh, this.gh);
  }
  Sh() {
    return this.wh;
  }
  kh() {
    return this.gh;
  }
  yh() {
    return this.gh - this.wh;
  }
  Fi() {
    return this.gh === this.wh || Number.isNaN(this.gh) || Number.isNaN(this.wh);
  }
  ts(t2) {
    return null === t2 ? this : new Ri(Pi(Math.min, this.Sh(), t2.Sh(), -1 / 0), Pi(Math.max, this.kh(), t2.kh(), 1 / 0));
  }
  Ch(t2) {
    if (!O$1(t2))
      return;
    if (0 === this.gh - this.wh)
      return;
    const i = 0.5 * (this.gh + this.wh);
    let n2 = this.gh - i, s = this.wh - i;
    n2 *= t2, s *= t2, this.gh = i + n2, this.wh = i + s;
  }
  Th(t2) {
    O$1(t2) && (this.gh += t2, this.wh += t2);
  }
  Ph() {
    return { minValue: this.wh, maxValue: this.gh };
  }
  static Rh(t2) {
    return null === t2 ? null : new Ri(t2.minValue, t2.maxValue);
  }
}
class Di {
  constructor(t2, i) {
    this.Dh = t2, this.Oh = i || null;
  }
  Ah() {
    return this.Dh;
  }
  Vh() {
    return this.Oh;
  }
  Ph() {
    return null === this.Dh ? null : { priceRange: this.Dh.Ph(), margins: this.Oh || void 0 };
  }
  static Rh(t2) {
    return null === t2 ? null : new Di(Ri.Rh(t2.priceRange), t2.margins);
  }
}
class Oi extends li {
  constructor(t2, i) {
    super(t2), this.Bh = i;
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = false;
    const i = this.Bh.W();
    if (!this.Es.Tt() || !i.lineVisible)
      return;
    const n2 = this.Bh.Ih();
    null !== n2 && (t2.Tt = true, t2.rt = n2, t2.O = i.color, t2.ht = i.lineWidth, t2.Wt = i.lineStyle, t2.wr = this.Bh.W().id);
  }
}
class Ai extends st {
  constructor(t2, i) {
    super(), this.Wr = t2, this.Bh = i;
  }
  Ei(t2, i, n2) {
    t2.Tt = false, i.Tt = false;
    const s = this.Bh.W(), e3 = s.axisLabelVisible, r2 = "" !== s.title, h2 = this.Wr;
    if (!e3 || !h2.Tt())
      return;
    const l2 = this.Bh.Ih();
    if (null === l2)
      return;
    r2 && (i.Jt = s.title, i.Tt = true), i.Bt = h2.qt().It(l2 / h2.At().zt()), t2.Jt = this.zh(s.price), t2.Tt = true;
    const a2 = P(s.axisLabelColor || s.color);
    n2.t = a2.t;
    const o2 = s.axisLabelTextColor || a2.i;
    t2.O = o2, i.O = o2, n2.yi = l2;
  }
  zh(t2) {
    const i = this.Wr.Pt();
    return null === i ? "" : this.Wr.At().Wi(t2, i.Vt);
  }
}
class Vi {
  constructor(t2, i) {
    this.Wr = t2, this.cn = i, this.Eh = new Oi(t2, this), this._r = new Ai(t2, this), this.Lh = new ri(this._r, t2, t2.qt());
  }
  Nh(t2) {
    D$1(this.cn, t2), this.gt(), this.Wr.qt().Fh();
  }
  W() {
    return this.cn;
  }
  Wh() {
    return this.Eh;
  }
  jh() {
    return this.Lh;
  }
  Hh() {
    return this._r;
  }
  gt() {
    this.Eh.gt(), this._r.gt();
  }
  Ih() {
    const t2 = this.Wr, i = t2.At();
    if (t2.qt().yt().Fi() || i.Fi())
      return null;
    const n2 = t2.Pt();
    return null === n2 ? null : i.Ot(this.cn.price, n2.Vt);
  }
}
class Bi extends at$1 {
  constructor(t2) {
    super(), this.Ui = t2;
  }
  qt() {
    return this.Ui;
  }
}
const Ii = { Bar: (t2, i, n2, s) => {
  var e3;
  const r2 = i.upColor, h2 = i.downColor, l2 = b(t2(n2, s)), a2 = w$1(l2.Vt[0]) <= w$1(l2.Vt[3]);
  return { ue: null !== (e3 = l2.O) && void 0 !== e3 ? e3 : a2 ? r2 : h2 };
}, Candlestick: (t2, i, n2, s) => {
  var e3, r2, h2;
  const l2 = i.upColor, a2 = i.downColor, o2 = i.borderUpColor, _24 = i.borderDownColor, u2 = i.wickUpColor, c2 = i.wickDownColor, d2 = b(t2(n2, s)), f2 = w$1(d2.Vt[0]) <= w$1(d2.Vt[3]);
  return { ue: null !== (e3 = d2.O) && void 0 !== e3 ? e3 : f2 ? l2 : a2, Le: null !== (r2 = d2.Bt) && void 0 !== r2 ? r2 : f2 ? o2 : _24, Ee: null !== (h2 = d2.$h) && void 0 !== h2 ? h2 : f2 ? u2 : c2 };
}, Custom: (t2, i, n2, s) => {
  var e3;
  return { ue: null !== (e3 = b(t2(n2, s)).O) && void 0 !== e3 ? e3 : i.color };
}, Area: (t2, i, n2, s) => {
  var e3, r2, h2, l2;
  const a2 = b(t2(n2, s));
  return { ue: null !== (e3 = a2._t) && void 0 !== e3 ? e3 : i.lineColor, _t: null !== (r2 = a2._t) && void 0 !== r2 ? r2 : i.lineColor, Ts: null !== (h2 = a2.Ts) && void 0 !== h2 ? h2 : i.topColor, Ps: null !== (l2 = a2.Ps) && void 0 !== l2 ? l2 : i.bottomColor };
}, Baseline: (t2, i, n2, s) => {
  var e3, r2, h2, l2, a2, o2;
  const _24 = b(t2(n2, s));
  return { ue: _24.Vt[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor, Pe: null !== (e3 = _24.Pe) && void 0 !== e3 ? e3 : i.topLineColor, Re: null !== (r2 = _24.Re) && void 0 !== r2 ? r2 : i.bottomLineColor, Se: null !== (h2 = _24.Se) && void 0 !== h2 ? h2 : i.topFillColor1, ke: null !== (l2 = _24.ke) && void 0 !== l2 ? l2 : i.topFillColor2, ye: null !== (a2 = _24.ye) && void 0 !== a2 ? a2 : i.bottomFillColor1, Ce: null !== (o2 = _24.Ce) && void 0 !== o2 ? o2 : i.bottomFillColor2 };
}, Line: (t2, i, n2, s) => {
  var e3, r2;
  const h2 = b(t2(n2, s));
  return { ue: null !== (e3 = h2.O) && void 0 !== e3 ? e3 : i.color, _t: null !== (r2 = h2.O) && void 0 !== r2 ? r2 : i.color };
}, Histogram: (t2, i, n2, s) => {
  var e3;
  return { ue: null !== (e3 = b(t2(n2, s)).O) && void 0 !== e3 ? e3 : i.color };
} };
class zi {
  constructor(t2) {
    this.Uh = (t3, i) => void 0 !== i ? i.Vt : this.Wr.In().qh(t3), this.Wr = t2, this.Yh = Ii[t2.Xh()];
  }
  Hs(t2, i) {
    return this.Yh(this.Uh, this.Wr.W(), t2, i);
  }
}
var Ei;
!function(t2) {
  t2[t2.NearestLeft = -1] = "NearestLeft", t2[t2.None = 0] = "None", t2[t2.NearestRight = 1] = "NearestRight";
}(Ei || (Ei = {}));
const Li = 30;
class Ni {
  constructor() {
    this.Kh = [], this.Zh = /* @__PURE__ */ new Map(), this.Gh = /* @__PURE__ */ new Map();
  }
  Jh() {
    return this.Ks() > 0 ? this.Kh[this.Kh.length - 1] : null;
  }
  Qh() {
    return this.Ks() > 0 ? this.tl(0) : null;
  }
  Bn() {
    return this.Ks() > 0 ? this.tl(this.Kh.length - 1) : null;
  }
  Ks() {
    return this.Kh.length;
  }
  Fi() {
    return 0 === this.Ks();
  }
  Kr(t2) {
    return null !== this.il(t2, 0);
  }
  qh(t2) {
    return this.nl(t2);
  }
  nl(t2, i = 0) {
    const n2 = this.il(t2, i);
    return null === n2 ? null : Object.assign(Object.assign({}, this.sl(n2)), { se: this.tl(n2) });
  }
  ie() {
    return this.Kh;
  }
  el(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    for (const e3 of n2) {
      s = Fi(s, this.rl(t2, i, e3));
    }
    return s;
  }
  it(t2) {
    this.Gh.clear(), this.Zh.clear(), this.Kh = t2;
  }
  tl(t2) {
    return this.Kh[t2].se;
  }
  sl(t2) {
    return this.Kh[t2];
  }
  il(t2, i) {
    const n2 = this.hl(t2);
    if (null === n2 && 0 !== i)
      switch (i) {
        case -1:
          return this.ll(t2);
        case 1:
          return this.al(t2);
        default:
          throw new TypeError("Unknown search mode");
      }
    return n2;
  }
  ll(t2) {
    let i = this.ol(t2);
    return i > 0 && (i -= 1), i !== this.Kh.length && this.tl(i) < t2 ? i : null;
  }
  al(t2) {
    const i = this._l(t2);
    return i !== this.Kh.length && t2 < this.tl(i) ? i : null;
  }
  hl(t2) {
    const i = this.ol(t2);
    return i === this.Kh.length || t2 < this.Kh[i].se ? null : i;
  }
  ol(t2) {
    return Bt$1(this.Kh, t2, (t3, i) => t3.se < i);
  }
  _l(t2) {
    return It$1(this.Kh, t2, (t3, i) => t3.se > i);
  }
  ul(t2, i, n2) {
    let s = null;
    for (let e3 = t2; e3 < i; e3++) {
      const t3 = this.Kh[e3].Vt[n2];
      Number.isNaN(t3) || (null === s ? s = { cl: t3, dl: t3 } : (t3 < s.cl && (s.cl = t3), t3 > s.dl && (s.dl = t3)));
    }
    return s;
  }
  rl(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    const e3 = b(this.Qh()), r2 = b(this.Bn()), h2 = Math.max(t2, e3), l2 = Math.min(i, r2), a2 = Math.ceil(h2 / Li) * Li, o2 = Math.max(a2, Math.floor(l2 / Li) * Li);
    {
      const t3 = this.ol(h2), e4 = this._l(Math.min(l2, a2, i));
      s = Fi(s, this.ul(t3, e4, n2));
    }
    let _24 = this.Zh.get(n2);
    void 0 === _24 && (_24 = /* @__PURE__ */ new Map(), this.Zh.set(n2, _24));
    for (let t3 = Math.max(a2 + 1, h2); t3 < o2; t3 += Li) {
      const i2 = Math.floor(t3 / Li);
      let e4 = _24.get(i2);
      if (void 0 === e4) {
        const t4 = this.ol(i2 * Li), s2 = this._l((i2 + 1) * Li - 1);
        e4 = this.ul(t4, s2, n2), _24.set(i2, e4);
      }
      s = Fi(s, e4);
    }
    {
      const t3 = this.ol(o2), i2 = this._l(l2);
      s = Fi(s, this.ul(t3, i2, n2));
    }
    return s;
  }
}
function Fi(t2, i) {
  if (null === t2)
    return i;
  if (null === i)
    return t2;
  return { cl: Math.min(t2.cl, i.cl), dl: Math.max(t2.dl, i.dl) };
}
class Wi {
  constructor(t2) {
    this.fl = t2;
  }
  K(t2, i, n2) {
    this.fl.draw(t2);
  }
  G(t2, i, n2) {
    var s, e3;
    null === (e3 = (s = this.fl).drawBackground) || void 0 === e3 || e3.call(s, t2);
  }
}
class ji {
  constructor(t2) {
    this.Qe = null, this.wn = t2;
  }
  xt() {
    var t2;
    const i = this.wn.renderer();
    if (null === i)
      return null;
    if ((null === (t2 = this.Qe) || void 0 === t2 ? void 0 : t2.vl) === i)
      return this.Qe.pl;
    const n2 = new Wi(i);
    return this.Qe = { vl: i, pl: n2 }, n2;
  }
  ml() {
    var t2, i, n2;
    return null !== (n2 = null === (i = (t2 = this.wn).zOrder) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : "normal";
  }
}
function Hi(t2) {
  var i, n2, s, e3, r2;
  return { Jt: t2.text(), yi: t2.coordinate(), ki: null === (i = t2.fixedCoordinate) || void 0 === i ? void 0 : i.call(t2), O: t2.textColor(), t: t2.backColor(), Tt: null === (s = null === (n2 = t2.visible) || void 0 === n2 ? void 0 : n2.call(t2)) || void 0 === s || s, ai: null === (r2 = null === (e3 = t2.tickVisible) || void 0 === e3 ? void 0 : e3.call(t2)) || void 0 === r2 || r2 };
}
class $i {
  constructor(t2, i) {
    this.Ht = new ht$1(), this.bl = t2, this.wl = i;
  }
  xt() {
    return this.Ht.it(Object.assign({ $i: this.wl.$i() }, Hi(this.bl))), this.Ht;
  }
}
class Ui extends st {
  constructor(t2, i) {
    super(), this.bl = t2, this.Li = i;
  }
  Ei(t2, i, n2) {
    const s = Hi(this.bl);
    n2.t = s.t, t2.O = s.O;
    const e3 = 2 / 12 * this.Li.P();
    n2.gi = e3, n2.Mi = e3, n2.yi = s.yi, n2.ki = s.ki, t2.Jt = s.Jt, t2.Tt = s.Tt, t2.ai = s.ai;
  }
}
class qi {
  constructor(t2, i) {
    this.gl = null, this.Ml = null, this.xl = null, this.Sl = null, this.kl = null, this.yl = t2, this.Wr = i;
  }
  Cl() {
    return this.yl;
  }
  On() {
    var t2, i;
    null === (i = (t2 = this.yl).updateAllViews) || void 0 === i || i.call(t2);
  }
  Pn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).paneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.gl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.gl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.gl = { vl: e3, pl: r2 }, r2;
  }
  tn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).timeAxisViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.Ml) || void 0 === s ? void 0 : s.vl) === e3)
      return this.Ml.pl;
    const r2 = this.Wr.qt().yt(), h2 = e3.map((t3) => new $i(t3, r2));
    return this.Ml = { vl: e3, pl: h2 }, h2;
  }
  Rn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).priceAxisViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.xl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.xl.pl;
    const r2 = this.Wr.At(), h2 = e3.map((t3) => new Ui(t3, r2));
    return this.xl = { vl: e3, pl: h2 }, h2;
  }
  Tl() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).priceAxisPaneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.Sl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.Sl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.Sl = { vl: e3, pl: r2 }, r2;
  }
  Pl() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).timeAxisPaneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.kl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.kl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.kl = { vl: e3, pl: r2 }, r2;
  }
  Rl(t2, i) {
    var n2, s, e3;
    return null !== (e3 = null === (s = (n2 = this.yl).autoscaleInfo) || void 0 === s ? void 0 : s.call(n2, t2, i)) && void 0 !== e3 ? e3 : null;
  }
  br(t2, i) {
    var n2, s, e3;
    return null !== (e3 = null === (s = (n2 = this.yl).hitTest) || void 0 === s ? void 0 : s.call(n2, t2, i)) && void 0 !== e3 ? e3 : null;
  }
}
function Yi(t2, i, n2, s) {
  t2.forEach((t3) => {
    i(t3).forEach((t4) => {
      t4.ml() === n2 && s.push(t4);
    });
  });
}
function Xi(t2) {
  return t2.Pn();
}
function Ki(t2) {
  return t2.Tl();
}
function Zi(t2) {
  return t2.Pl();
}
class Gi extends Bi {
  constructor(t2, i, n2, s, e3) {
    super(t2), this.Lt = new Ni(), this.Eh = new Ci(this), this.Dl = [], this.Ol = new ai(this), this.Al = null, this.Vl = null, this.Bl = [], this.Il = [], this.zl = null, this.El = [], this.cn = i, this.Ll = n2;
    const r2 = new Ti(this);
    this.hn = [r2], this.Lh = new ri(r2, this, t2), "Area" !== n2 && "Line" !== n2 && "Baseline" !== n2 || (this.Al = new di(this)), this.Nl(), this.Fl(e3);
  }
  S() {
    null !== this.zl && clearTimeout(this.zl);
  }
  _h(t2) {
    return this.cn.priceLineColor || t2;
  }
  Yr(t2) {
    const i = { Xr: true }, n2 = this.At();
    if (this.qt().yt().Fi() || n2.Fi() || this.Lt.Fi())
      return i;
    const s = this.qt().yt().Xs(), e3 = this.Pt();
    if (null === s || null === e3)
      return i;
    let r2, h2;
    if (t2) {
      const t3 = this.Lt.Jh();
      if (null === t3)
        return i;
      r2 = t3, h2 = t3.se;
    } else {
      const t3 = this.Lt.nl(s.di(), -1);
      if (null === t3)
        return i;
      if (r2 = this.Lt.qh(t3.se), null === r2)
        return i;
      h2 = t3.se;
    }
    const l2 = r2.Vt[3], a2 = this.$s().Hs(h2, { Vt: r2 }), o2 = n2.Ot(l2, e3.Vt);
    return { Xr: false, ct: l2, Jt: n2.Wi(l2, e3.Vt), mh: n2.Wl(l2), bh: n2.jl(l2, e3.Vt), O: a2.ue, yi: o2, se: h2 };
  }
  $s() {
    return null !== this.Vl || (this.Vl = new zi(this)), this.Vl;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    const i = t2.priceScaleId;
    void 0 !== i && i !== this.cn.priceScaleId && this.qt().Hl(this, i), D$1(this.cn, t2), void 0 !== t2.priceFormat && (this.Nl(), this.qt().$l()), this.qt().Ul(this), this.qt().ql(), this.wn.gt("options");
  }
  it(t2, i) {
    this.Lt.it(t2), this.Yl(), this.wn.gt("data"), this.dn.gt("data"), null !== this.Al && (i && i.Xl ? this.Al.Hr() : 0 === t2.length && this.Al.jr());
    const n2 = this.qt().cr(this);
    this.qt().Kl(n2), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Zl(t2) {
    this.Bl = t2, this.Yl();
    const i = this.qt().cr(this);
    this.dn.gt("data"), this.qt().Kl(i), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Gl() {
    return this.Bl;
  }
  ah() {
    return this.Il;
  }
  Jl(t2) {
    const i = new Vi(this, t2);
    return this.Dl.push(i), this.qt().Ul(this), i;
  }
  Ql(t2) {
    const i = this.Dl.indexOf(t2);
    -1 !== i && this.Dl.splice(i, 1), this.qt().Ul(this);
  }
  Xh() {
    return this.Ll;
  }
  Pt() {
    const t2 = this.ta();
    return null === t2 ? null : { Vt: t2.Vt[3], ia: t2.ut };
  }
  ta() {
    const t2 = this.qt().yt().Xs();
    if (null === t2)
      return null;
    const i = t2.Os();
    return this.Lt.nl(i, 1);
  }
  In() {
    return this.Lt;
  }
  oh(t2) {
    const i = this.Lt.qh(t2);
    return null === i ? null : "Bar" === this.Ll || "Candlestick" === this.Ll || "Custom" === this.Ll ? { we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3] } : i.Vt[3];
  }
  na(t2) {
    const i = [];
    Yi(this.El, Xi, "top", i);
    const n2 = this.Al;
    return null !== n2 && n2.Tt() ? (null === this.zl && n2.Ur() && (this.zl = setTimeout(() => {
      this.zl = null, this.qt().sa();
    }, 0)), n2.$r(), i.push(n2), i) : i;
  }
  Pn() {
    const t2 = [];
    this.ea() || t2.push(this.Ol), t2.push(this.wn, this.Eh, this.dn);
    const i = this.Dl.map((t3) => t3.Wh());
    return t2.push(...i), Yi(this.El, Xi, "normal", t2), t2;
  }
  ra() {
    return this.ha(Xi, "bottom");
  }
  la(t2) {
    return this.ha(Ki, t2);
  }
  aa(t2) {
    return this.ha(Zi, t2);
  }
  oa(t2, i) {
    return this.El.map((n2) => n2.br(t2, i)).filter((t3) => null !== t3);
  }
  Qi(t2) {
    return [this.Lh, ...this.Dl.map((t3) => t3.jh())];
  }
  Rn(t2, i) {
    if (i !== this.Xi && !this.ea())
      return [];
    const n2 = [...this.hn];
    for (const t3 of this.Dl)
      n2.push(t3.Hh());
    return this.El.forEach((t3) => {
      n2.push(...t3.Rn());
    }), n2;
  }
  tn() {
    const t2 = [];
    return this.El.forEach((i) => {
      t2.push(...i.tn());
    }), t2;
  }
  Rl(t2, i) {
    if (void 0 !== this.cn.autoscaleInfoProvider) {
      const n2 = this.cn.autoscaleInfoProvider(() => {
        const n3 = this._a(t2, i);
        return null === n3 ? null : n3.Ph();
      });
      return Di.Rh(n2);
    }
    return this._a(t2, i);
  }
  ua() {
    return this.cn.priceFormat.minMove;
  }
  ca() {
    return this.da;
  }
  On() {
    var t2;
    this.wn.gt(), this.dn.gt();
    for (const t3 of this.hn)
      t3.gt();
    for (const t3 of this.Dl)
      t3.gt();
    this.Eh.gt(), this.Ol.gt(), null === (t2 = this.Al) || void 0 === t2 || t2.gt(), this.El.forEach((t3) => t3.On());
  }
  At() {
    return b(super.At());
  }
  Ct(t2) {
    if (!(("Line" === this.Ll || "Area" === this.Ll || "Baseline" === this.Ll) && this.cn.crosshairMarkerVisible))
      return null;
    const i = this.Lt.qh(t2);
    if (null === i)
      return null;
    return { ct: i.Vt[3], ot: this.fa(), Bt: this.va(), Dt: this.pa(), Rt: this.ma(t2) };
  }
  uh() {
    return this.cn.title;
  }
  Tt() {
    return this.cn.visible;
  }
  ba(t2) {
    this.El.push(new qi(t2, this));
  }
  wa(t2) {
    this.El = this.El.filter((i) => i.Cl() !== t2);
  }
  ga() {
    if (this.wn instanceof Gt$1 != false)
      return (t2) => this.wn.Fe(t2);
  }
  Ma() {
    if (this.wn instanceof Gt$1 != false)
      return (t2) => this.wn.We(t2);
  }
  ea() {
    return !ut$1(this.At().xa());
  }
  _a(t2, i) {
    if (!A$1(t2) || !A$1(i) || this.Lt.Fi())
      return null;
    const n2 = "Line" === this.Ll || "Area" === this.Ll || "Baseline" === this.Ll || "Histogram" === this.Ll ? [3] : [2, 1], s = this.Lt.el(t2, i, n2);
    let e3 = null !== s ? new Ri(s.cl, s.dl) : null;
    if ("Histogram" === this.Xh()) {
      const t3 = this.cn.base, i2 = new Ri(t3, t3);
      e3 = null !== e3 ? e3.ts(i2) : i2;
    }
    let r2 = this.dn.lh();
    return this.El.forEach((n3) => {
      const s2 = n3.Rl(t2, i);
      if (null == s2 ? void 0 : s2.priceRange) {
        const t3 = new Ri(s2.priceRange.minValue, s2.priceRange.maxValue);
        e3 = null !== e3 ? e3.ts(t3) : t3;
      }
      var h2, l2, a2, o2;
      (null == s2 ? void 0 : s2.margins) && (h2 = r2, l2 = s2.margins, r2 = { above: Math.max(null !== (a2 = null == h2 ? void 0 : h2.above) && void 0 !== a2 ? a2 : 0, l2.above), below: Math.max(null !== (o2 = null == h2 ? void 0 : h2.below) && void 0 !== o2 ? o2 : 0, l2.below) });
    }), new Di(e3, r2);
  }
  fa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerRadius;
    }
    return 0;
  }
  va() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t2 = this.cn.crosshairMarkerBorderColor;
        if (0 !== t2.length)
          return t2;
      }
    }
    return null;
  }
  pa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerBorderWidth;
    }
    return 0;
  }
  ma(t2) {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t3 = this.cn.crosshairMarkerBackgroundColor;
        if (0 !== t3.length)
          return t3;
      }
    }
    return this.$s().Hs(t2).ue;
  }
  Nl() {
    switch (this.cn.priceFormat.type) {
      case "custom":
        this.da = { format: this.cn.priceFormat.formatter };
        break;
      case "volume":
        this.da = new mt$1(this.cn.priceFormat.precision);
        break;
      case "percent":
        this.da = new pt$1(this.cn.priceFormat.precision);
        break;
      default: {
        const t2 = Math.pow(10, this.cn.priceFormat.precision);
        this.da = new vt$1(t2, this.cn.priceFormat.minMove * t2);
      }
    }
    null !== this.Xi && this.Xi.Sa();
  }
  Yl() {
    const t2 = this.qt().yt();
    if (!t2.ka() || this.Lt.Fi())
      return void (this.Il = []);
    const i = b(this.Lt.Qh());
    this.Il = this.Bl.map((n2, s) => {
      const e3 = b(t2.ya(n2.time, true)), r2 = e3 < i ? 1 : -1;
      return { time: b(this.Lt.nl(e3, r2)).se, position: n2.position, shape: n2.shape, color: n2.color, id: n2.id, Jr: s, text: n2.text, size: n2.size, originalTime: n2.originalTime };
    });
  }
  Fl(t2) {
    switch (this.dn = new yi(this, this.qt()), this.Ll) {
      case "Bar":
        this.wn = new $t$1(this, this.qt());
        break;
      case "Candlestick":
        this.wn = new Kt$1(this, this.qt());
        break;
      case "Line":
        this.wn = new ii(this, this.qt());
        break;
      case "Custom":
        this.wn = new Gt$1(this, this.qt(), m$1(t2));
        break;
      case "Area":
        this.wn = new Wt$1(this, this.qt());
        break;
      case "Baseline":
        this.wn = new Yt$1(this, this.qt());
        break;
      case "Histogram":
        this.wn = new ti(this, this.qt());
        break;
      default:
        throw Error("Unknown chart style assigned: " + this.Ll);
    }
  }
  ha(t2, i) {
    const n2 = [];
    return Yi(this.El, t2, i, n2), n2;
  }
}
class Ji {
  constructor(t2) {
    this.cn = t2;
  }
  Ca(t2, i, n2) {
    let s = t2;
    if (0 === this.cn.mode)
      return s;
    const e3 = n2.vn(), r2 = e3.Pt();
    if (null === r2)
      return s;
    const h2 = e3.Ot(t2, r2), l2 = n2.Ta().filter((t3) => t3 instanceof Gi).reduce((t3, s2) => {
      if (n2.dr(s2) || !s2.Tt())
        return t3;
      const e4 = s2.At(), r3 = s2.In();
      if (e4.Fi() || !r3.Kr(i))
        return t3;
      const h3 = r3.qh(i);
      if (null === h3)
        return t3;
      const l3 = w$1(s2.Pt());
      return t3.concat([e4.Ot(h3.Vt[3], l3.Vt)]);
    }, []);
    if (0 === l2.length)
      return s;
    l2.sort((t3, i2) => Math.abs(t3 - h2) - Math.abs(i2 - h2));
    const a2 = l2[0];
    return s = e3.pn(a2, r2), s;
  }
}
class Qi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    const e3 = Math.max(1, Math.floor(n2));
    t2.lineWidth = e3, function(t3, i2) {
      t3.save(), t3.lineWidth % 2 && t3.translate(0.5, 0.5), i2(), t3.restore();
    }(t2, () => {
      const r2 = b(this.Lt);
      if (r2.Pa) {
        t2.strokeStyle = r2.Ra, f(t2, r2.Da), t2.beginPath();
        for (const s2 of r2.Oa) {
          const r3 = Math.round(s2.Aa * n2);
          t2.moveTo(r3, -e3), t2.lineTo(r3, i.height + e3);
        }
        t2.stroke();
      }
      if (r2.Va) {
        t2.strokeStyle = r2.Ba, f(t2, r2.Ia), t2.beginPath();
        for (const n3 of r2.za) {
          const r3 = Math.round(n3.Aa * s);
          t2.moveTo(-e3, r3), t2.lineTo(i.width + e3, r3);
        }
        t2.stroke();
      }
    });
  }
}
let tn$1 = class tn {
  constructor(t2) {
    this.Ht = new Qi(), this.bt = true, this.nn = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    if (this.bt) {
      const t2 = this.nn.qt().W().grid, i = { Va: t2.horzLines.visible, Pa: t2.vertLines.visible, Ba: t2.horzLines.color, Ra: t2.vertLines.color, Ia: t2.horzLines.style, Da: t2.vertLines.style, za: this.nn.vn().Ea(), Oa: (this.nn.qt().yt().Ea() || []).map((t3) => ({ Aa: t3.coord })) };
      this.Ht.it(i), this.bt = false;
    }
    return this.Ht;
  }
};
let nn$1 = class nn {
  constructor(t2) {
    this.wn = new tn$1(t2);
  }
  Wh() {
    return this.wn;
  }
};
const sn$1 = { La: 4, Na: 1e-4 };
function en$1(t2, i) {
  const n2 = 100 * (t2 - i) / i;
  return i < 0 ? -n2 : n2;
}
function rn$1(t2, i) {
  const n2 = en$1(t2.Sh(), i), s = en$1(t2.kh(), i);
  return new Ri(n2, s);
}
function hn$1(t2, i) {
  const n2 = 100 * (t2 - i) / i + 100;
  return i < 0 ? -n2 : n2;
}
function ln$1(t2, i) {
  const n2 = hn$1(t2.Sh(), i), s = hn$1(t2.kh(), i);
  return new Ri(n2, s);
}
function an$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.log10(n2 + i.Na) + i.La;
  return t2 < 0 ? -s : s;
}
function on$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.pow(10, n2 - i.La) - i.Na;
  return t2 < 0 ? -s : s;
}
function _n(t2, i) {
  if (null === t2)
    return null;
  const n2 = an$1(t2.Sh(), i), s = an$1(t2.kh(), i);
  return new Ri(n2, s);
}
function un$1(t2, i) {
  if (null === t2)
    return null;
  const n2 = on$1(t2.Sh(), i), s = on$1(t2.kh(), i);
  return new Ri(n2, s);
}
function cn$1(t2) {
  if (null === t2)
    return sn$1;
  const i = Math.abs(t2.kh() - t2.Sh());
  if (i >= 1 || i < 1e-15)
    return sn$1;
  const n2 = Math.ceil(Math.abs(Math.log10(i))), s = sn$1.La + n2;
  return { La: s, Na: 1 / Math.pow(10, s) };
}
let dn$1 = class dn {
  constructor(t2, i) {
    if (this.Fa = t2, this.Wa = i, function(t3) {
      if (t3 < 0)
        return false;
      for (let i2 = t3; i2 > 1; i2 /= 10)
        if (i2 % 10 != 0)
          return false;
      return true;
    }(this.Fa))
      this.ja = [2, 2.5, 2];
    else {
      this.ja = [];
      for (let t3 = this.Fa; 1 !== t3; ) {
        if (t3 % 2 == 0)
          this.ja.push(2), t3 /= 2;
        else {
          if (t3 % 5 != 0)
            throw new Error("unexpected base");
          this.ja.push(2, 2.5), t3 /= 5;
        }
        if (this.ja.length > 100)
          throw new Error("something wrong with base");
      }
    }
  }
  Ha(t2, i, n2) {
    const s = 0 === this.Fa ? 0 : 1 / this.Fa;
    let e3 = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t2 - i)))), r2 = 0, h2 = this.Wa[0];
    for (; ; ) {
      const t3 = Ct$1(e3, s, 1e-14) && e3 > s + 1e-14, i2 = Ct$1(e3, n2 * h2, 1e-14), l3 = Ct$1(e3, 1, 1e-14);
      if (!(t3 && i2 && l3))
        break;
      e3 /= h2, h2 = this.Wa[++r2 % this.Wa.length];
    }
    if (e3 <= s + 1e-14 && (e3 = s), e3 = Math.max(1, e3), this.ja.length > 0 && (l2 = e3, a2 = 1, o2 = 1e-14, Math.abs(l2 - a2) < o2))
      for (r2 = 0, h2 = this.ja[0]; Ct$1(e3, n2 * h2, 1e-14) && e3 > s + 1e-14; )
        e3 /= h2, h2 = this.ja[++r2 % this.ja.length];
    var l2, a2, o2;
    return e3;
  }
};
let fn$1 = class fn {
  constructor(t2, i, n2, s) {
    this.$a = [], this.Li = t2, this.Fa = i, this.Ua = n2, this.qa = s;
  }
  Ha(t2, i) {
    if (t2 < i)
      throw new Error("high < low");
    const n2 = this.Li.zt(), s = (t2 - i) * this.Ya() / n2, e3 = new dn$1(this.Fa, [2, 2.5, 2]), r2 = new dn$1(this.Fa, [2, 2, 2.5]), h2 = new dn$1(this.Fa, [2.5, 2, 2]), l2 = [];
    return l2.push(e3.Ha(t2, i, s), r2.Ha(t2, i, s), h2.Ha(t2, i, s)), function(t3) {
      if (t3.length < 1)
        throw Error("array is empty");
      let i2 = t3[0];
      for (let n3 = 1; n3 < t3.length; ++n3)
        t3[n3] < i2 && (i2 = t3[n3]);
      return i2;
    }(l2);
  }
  Xa() {
    const t2 = this.Li, i = t2.Pt();
    if (null === i)
      return void (this.$a = []);
    const n2 = t2.zt(), s = this.Ua(n2 - 1, i), e3 = this.Ua(0, i), r2 = this.Li.W().entireTextOnly ? this.Ka() / 2 : 0, h2 = r2, l2 = n2 - 1 - r2, a2 = Math.max(s, e3), o2 = Math.min(s, e3);
    if (a2 === o2)
      return void (this.$a = []);
    let _24 = this.Ha(a2, o2), u2 = a2 % _24;
    u2 += u2 < 0 ? _24 : 0;
    const c2 = a2 >= o2 ? 1 : -1;
    let d2 = null, f2 = 0;
    for (let n3 = a2 - u2; n3 > o2; n3 -= _24) {
      const s2 = this.qa(n3, i, true);
      null !== d2 && Math.abs(s2 - d2) < this.Ya() || (s2 < h2 || s2 > l2 || (f2 < this.$a.length ? (this.$a[f2].Aa = s2, this.$a[f2].Za = t2.Ga(n3)) : this.$a.push({ Aa: s2, Za: t2.Ga(n3) }), f2++, d2 = s2, t2.Ja() && (_24 = this.Ha(n3 * c2, o2))));
    }
    this.$a.length = f2;
  }
  Ea() {
    return this.$a;
  }
  Ka() {
    return this.Li.P();
  }
  Ya() {
    return Math.ceil(2.5 * this.Ka());
  }
};
function vn(t2) {
  return t2.slice().sort((t3, i) => b(t3.Zi()) - b(i.Zi()));
}
var pn$1;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Logarithmic = 1] = "Logarithmic", t2[t2.Percentage = 2] = "Percentage", t2[t2.IndexedTo100 = 3] = "IndexedTo100";
}(pn$1 || (pn$1 = {}));
const mn$1 = new pt$1(), bn = new vt$1(100, 1);
class wn {
  constructor(t2, i, n2, s) {
    this.Qa = 0, this.io = null, this.Dh = null, this.no = null, this.so = { eo: false, ro: null }, this.ho = 0, this.lo = 0, this.ao = new R(), this.oo = new R(), this._o = [], this.uo = null, this.co = null, this.do = null, this.fo = null, this.da = bn, this.vo = cn$1(null), this.po = t2, this.cn = i, this.mo = n2, this.bo = s, this.wo = new fn$1(this, 100, this.Mo.bind(this), this.xo.bind(this));
  }
  xa() {
    return this.po;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    if (D$1(this.cn, t2), this.Sa(), void 0 !== t2.mode && this.So({ yr: t2.mode }), void 0 !== t2.scaleMargins) {
      const i = m$1(t2.scaleMargins.top), n2 = m$1(t2.scaleMargins.bottom);
      if (i < 0 || i > 1)
        throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i}`);
      if (n2 < 0 || n2 > 1 || i + n2 > 1)
        throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n2}`);
      if (i + n2 > 1)
        throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i + n2}`);
      this.ko(), this.co = null;
    }
  }
  yo() {
    return this.cn.autoScale;
  }
  Ja() {
    return 1 === this.cn.mode;
  }
  ph() {
    return 2 === this.cn.mode;
  }
  Co() {
    return 3 === this.cn.mode;
  }
  yr() {
    return { Wn: this.cn.autoScale, To: this.cn.invertScale, yr: this.cn.mode };
  }
  So(t2) {
    const i = this.yr();
    let n2 = null;
    void 0 !== t2.Wn && (this.cn.autoScale = t2.Wn), void 0 !== t2.yr && (this.cn.mode = t2.yr, 2 !== t2.yr && 3 !== t2.yr || (this.cn.autoScale = true), this.so.eo = false), 1 === i.yr && t2.yr !== i.yr && (!function(t3, i2) {
      if (null === t3)
        return false;
      const n3 = on$1(t3.Sh(), i2), s2 = on$1(t3.kh(), i2);
      return isFinite(n3) && isFinite(s2);
    }(this.Dh, this.vo) ? this.cn.autoScale = true : (n2 = un$1(this.Dh, this.vo), null !== n2 && this.Po(n2))), 1 === t2.yr && t2.yr !== i.yr && (n2 = _n(this.Dh, this.vo), null !== n2 && this.Po(n2));
    const s = i.yr !== this.cn.mode;
    s && (2 === i.yr || this.ph()) && this.Sa(), s && (3 === i.yr || this.Co()) && this.Sa(), void 0 !== t2.To && i.To !== t2.To && (this.cn.invertScale = t2.To, this.Ro()), this.oo.m(i, this.yr());
  }
  Do() {
    return this.oo;
  }
  P() {
    return this.mo.fontSize;
  }
  zt() {
    return this.Qa;
  }
  Oo(t2) {
    this.Qa !== t2 && (this.Qa = t2, this.ko(), this.co = null);
  }
  Ao() {
    if (this.io)
      return this.io;
    const t2 = this.zt() - this.Vo() - this.Bo();
    return this.io = t2, t2;
  }
  Ah() {
    return this.Io(), this.Dh;
  }
  Po(t2, i) {
    const n2 = this.Dh;
    (i || null === n2 && null !== t2 || null !== n2 && !n2.Mh(t2)) && (this.co = null, this.Dh = t2);
  }
  Fi() {
    return this.Io(), 0 === this.Qa || !this.Dh || this.Dh.Fi();
  }
  zo(t2) {
    return this.To() ? t2 : this.zt() - 1 - t2;
  }
  Ot(t2, i) {
    return this.ph() ? t2 = en$1(t2, i) : this.Co() && (t2 = hn$1(t2, i)), this.xo(t2, i);
  }
  Qs(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e3 = b(this.Ah()), r2 = e3.Sh(), h2 = e3.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = void 0 === n2 ? 0 : n2.from, u2 = void 0 === n2 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e4 = t2[n3], h3 = e4.ct;
      if (isNaN(h3))
        continue;
      let l3 = h3;
      null !== c2 && (l3 = c2(e4.ct, i));
      const _25 = s + o2 * (l3 - r2), u3 = a2 ? _25 : this.Qa - 1 - _25;
      e4.rt = u3;
    }
  }
  me(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e3 = b(this.Ah()), r2 = e3.Sh(), h2 = e3.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = void 0 === n2 ? 0 : n2.from, u2 = void 0 === n2 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e4 = t2[n3];
      let h3 = e4.we, l3 = e4.ge, _25 = e4.Me, u3 = e4.xe;
      null !== c2 && (h3 = c2(e4.we, i), l3 = c2(e4.ge, i), _25 = c2(e4.Me, i), u3 = c2(e4.xe, i));
      let d2 = s + o2 * (h3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2;
      e4.ve = f2, d2 = s + o2 * (l3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.ce = f2, d2 = s + o2 * (_25 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.de = f2, d2 = s + o2 * (u3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.pe = f2;
    }
  }
  pn(t2, i) {
    const n2 = this.Mo(t2, i);
    return this.Lo(n2, i);
  }
  Lo(t2, i) {
    let n2 = t2;
    return this.ph() ? n2 = function(t3, i2) {
      return i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i) : this.Co() && (n2 = function(t3, i2) {
      return t3 -= 100, i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i)), n2;
  }
  Ta() {
    return this._o;
  }
  No() {
    if (this.uo)
      return this.uo;
    let t2 = [];
    for (let i = 0; i < this._o.length; i++) {
      const n2 = this._o[i];
      null === n2.Zi() && n2.Gi(i + 1), t2.push(n2);
    }
    return t2 = vn(t2), this.uo = t2, this.uo;
  }
  Fo(t2) {
    -1 === this._o.indexOf(t2) && (this._o.push(t2), this.Sa(), this.Wo());
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    if (-1 === i)
      throw new Error("source is not attached to scale");
    this._o.splice(i, 1), 0 === this._o.length && (this.So({ Wn: true }), this.Po(null)), this.Sa(), this.Wo();
  }
  Pt() {
    let t2 = null;
    for (const i of this._o) {
      const n2 = i.Pt();
      null !== n2 && ((null === t2 || n2.ia < t2.ia) && (t2 = n2));
    }
    return null === t2 ? null : t2.Vt;
  }
  To() {
    return this.cn.invertScale;
  }
  Ea() {
    const t2 = null === this.Pt();
    if (null !== this.co && (t2 || this.co.Ho === t2))
      return this.co.Ea;
    this.wo.Xa();
    const i = this.wo.Ea();
    return this.co = { Ea: i, Ho: t2 }, this.ao.m(), i;
  }
  $o() {
    return this.ao;
  }
  Uo(t2) {
    this.ph() || this.Co() || null === this.do && null === this.no && (this.Fi() || (this.do = this.Qa - t2, this.no = b(this.Ah()).xh()));
  }
  qo(t2) {
    if (this.ph() || this.Co())
      return;
    if (null === this.do)
      return;
    this.So({ Wn: false }), (t2 = this.Qa - t2) < 0 && (t2 = 0);
    let i = (this.do + 0.2 * (this.Qa - 1)) / (t2 + 0.2 * (this.Qa - 1));
    const n2 = b(this.no).xh();
    i = Math.max(i, 0.1), n2.Ch(i), this.Po(n2);
  }
  Yo() {
    this.ph() || this.Co() || (this.do = null, this.no = null);
  }
  Xo(t2) {
    this.yo() || null === this.fo && null === this.no && (this.Fi() || (this.fo = t2, this.no = b(this.Ah()).xh()));
  }
  Ko(t2) {
    if (this.yo())
      return;
    if (null === this.fo)
      return;
    const i = b(this.Ah()).yh() / (this.Ao() - 1);
    let n2 = t2 - this.fo;
    this.To() && (n2 *= -1);
    const s = n2 * i, e3 = b(this.no).xh();
    e3.Th(s), this.Po(e3, true), this.co = null;
  }
  Zo() {
    this.yo() || null !== this.fo && (this.fo = null, this.no = null);
  }
  ca() {
    return this.da || this.Sa(), this.da;
  }
  Wi(t2, i) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(en$1(t2, i));
      case 3:
        return this.ca().format(hn$1(t2, i));
      default:
        return this.zh(t2);
    }
  }
  Ga(t2) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(t2);
      case 3:
        return this.ca().format(t2);
      default:
        return this.zh(t2);
    }
  }
  Wl(t2) {
    return this.zh(t2, b(this.Jo()).ca());
  }
  jl(t2, i) {
    return t2 = en$1(t2, i), this.Go(t2, mn$1);
  }
  Qo() {
    return this._o;
  }
  t_(t2) {
    this.so = { ro: t2, eo: false };
  }
  On() {
    this._o.forEach((t2) => t2.On());
  }
  Sa() {
    this.co = null;
    const t2 = this.Jo();
    let i = 100;
    null !== t2 && (i = Math.round(1 / t2.ua())), this.da = bn, this.ph() ? (this.da = mn$1, i = 100) : this.Co() ? (this.da = new vt$1(100, 1), i = 100) : null !== t2 && (this.da = t2.ca()), this.wo = new fn$1(this, i, this.Mo.bind(this), this.xo.bind(this)), this.wo.Xa();
  }
  Wo() {
    this.uo = null;
  }
  Jo() {
    return this._o[0] || null;
  }
  Vo() {
    return this.To() ? this.cn.scaleMargins.bottom * this.zt() + this.lo : this.cn.scaleMargins.top * this.zt() + this.ho;
  }
  Bo() {
    return this.To() ? this.cn.scaleMargins.top * this.zt() + this.ho : this.cn.scaleMargins.bottom * this.zt() + this.lo;
  }
  Io() {
    this.so.eo || (this.so.eo = true, this.i_());
  }
  ko() {
    this.io = null;
  }
  xo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    t2 = this.Ja() && t2 ? an$1(t2, this.vo) : t2;
    const n2 = b(this.Ah()), s = this.Bo() + (this.Ao() - 1) * (t2 - n2.Sh()) / n2.yh();
    return this.zo(s);
  }
  Mo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    const n2 = this.zo(t2), s = b(this.Ah()), e3 = s.Sh() + s.yh() * ((n2 - this.Bo()) / (this.Ao() - 1));
    return this.Ja() ? on$1(e3, this.vo) : e3;
  }
  Ro() {
    this.co = null, this.wo.Xa();
  }
  i_() {
    const t2 = this.so.ro;
    if (null === t2)
      return;
    let i = null;
    const n2 = this.Qo();
    let s = 0, e3 = 0;
    for (const r3 of n2) {
      if (!r3.Tt())
        continue;
      const n3 = r3.Pt();
      if (null === n3)
        continue;
      const h3 = r3.Rl(t2.Os(), t2.di());
      let l2 = h3 && h3.Ah();
      if (null !== l2) {
        switch (this.cn.mode) {
          case 1:
            l2 = _n(l2, this.vo);
            break;
          case 2:
            l2 = rn$1(l2, n3.Vt);
            break;
          case 3:
            l2 = ln$1(l2, n3.Vt);
        }
        if (i = null === i ? l2 : i.ts(b(l2)), null !== h3) {
          const t3 = h3.Vh();
          null !== t3 && (s = Math.max(s, t3.above), e3 = Math.max(s, t3.below));
        }
      }
    }
    if (s === this.ho && e3 === this.lo || (this.ho = s, this.lo = e3, this.co = null, this.ko()), null !== i) {
      if (i.Sh() === i.kh()) {
        const t3 = this.Jo(), n3 = 5 * (null === t3 || this.ph() || this.Co() ? 1 : t3.ua());
        this.Ja() && (i = un$1(i, this.vo)), i = new Ri(i.Sh() - n3, i.kh() + n3), this.Ja() && (i = _n(i, this.vo));
      }
      if (this.Ja()) {
        const t3 = un$1(i, this.vo), n3 = cn$1(t3);
        if (r2 = n3, h2 = this.vo, r2.La !== h2.La || r2.Na !== h2.Na) {
          const s2 = null !== this.no ? un$1(this.no, this.vo) : null;
          this.vo = n3, i = _n(t3, n3), null !== s2 && (this.no = _n(s2, n3));
        }
      }
      this.Po(i);
    } else
      null === this.Dh && (this.Po(new Ri(-0.5, 0.5)), this.vo = cn$1(null));
    var r2, h2;
    this.so.eo = true;
  }
  Eo() {
    return this.ph() ? en$1 : this.Co() ? hn$1 : this.Ja() ? (t2) => an$1(t2, this.vo) : null;
  }
  n_(t2, i, n2) {
    return void 0 === i ? (void 0 === n2 && (n2 = this.ca()), n2.format(t2)) : i(t2);
  }
  zh(t2, i) {
    return this.n_(t2, this.bo.priceFormatter, i);
  }
  Go(t2, i) {
    return this.n_(t2, this.bo.percentageFormatter, i);
  }
}
let gn$1 = class gn {
  constructor(t2, i) {
    this._o = [], this.s_ = /* @__PURE__ */ new Map(), this.Qa = 0, this.e_ = 0, this.r_ = 1e3, this.uo = null, this.h_ = new R(), this.wl = t2, this.Ui = i, this.l_ = new nn$1(this);
    const n2 = i.W();
    this.a_ = this.o_("left", n2.leftPriceScale), this.__ = this.o_("right", n2.rightPriceScale), this.a_.Do().l(this.u_.bind(this, this.a_), this), this.__.Do().l(this.u_.bind(this, this.__), this), this.c_(n2);
  }
  c_(t2) {
    if (t2.leftPriceScale && this.a_.Nh(t2.leftPriceScale), t2.rightPriceScale && this.__.Nh(t2.rightPriceScale), t2.localization && (this.a_.Sa(), this.__.Sa()), t2.overlayPriceScales) {
      const i = Array.from(this.s_.values());
      for (const n2 of i) {
        const i2 = b(n2[0].At());
        i2.Nh(t2.overlayPriceScales), t2.localization && i2.Sa();
      }
    }
  }
  d_(t2) {
    switch (t2) {
      case "left":
        return this.a_;
      case "right":
        return this.__;
    }
    return this.s_.has(t2) ? m$1(this.s_.get(t2))[0].At() : null;
  }
  S() {
    this.qt().f_().p(this), this.a_.Do().p(this), this.__.Do().p(this), this._o.forEach((t2) => {
      t2.S && t2.S();
    }), this.h_.m();
  }
  v_() {
    return this.r_;
  }
  p_(t2) {
    this.r_ = t2;
  }
  qt() {
    return this.Ui;
  }
  $i() {
    return this.e_;
  }
  zt() {
    return this.Qa;
  }
  m_(t2) {
    this.e_ = t2, this.b_();
  }
  Oo(t2) {
    this.Qa = t2, this.a_.Oo(t2), this.__.Oo(t2), this._o.forEach((i) => {
      if (this.dr(i)) {
        const n2 = i.At();
        null !== n2 && n2.Oo(t2);
      }
    }), this.b_();
  }
  Ta() {
    return this._o;
  }
  dr(t2) {
    const i = t2.At();
    return null === i || this.a_ !== i && this.__ !== i;
  }
  Fo(t2, i, n2) {
    const s = void 0 !== n2 ? n2 : this.g_().w_ + 1;
    this.M_(t2, i, s);
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    p$1(-1 !== i, "removeDataSource: invalid data source"), this._o.splice(i, 1);
    const n2 = b(t2.At()).xa();
    if (this.s_.has(n2)) {
      const i2 = m$1(this.s_.get(n2)), s2 = i2.indexOf(t2);
      -1 !== s2 && (i2.splice(s2, 1), 0 === i2.length && this.s_.delete(n2));
    }
    const s = t2.At();
    s && s.Ta().indexOf(t2) >= 0 && s.jo(t2), null !== s && (s.Wo(), this.x_(s)), this.uo = null;
  }
  pr(t2) {
    return t2 === this.a_ ? "left" : t2 === this.__ ? "right" : "overlay";
  }
  S_() {
    return this.a_;
  }
  k_() {
    return this.__;
  }
  y_(t2, i) {
    t2.Uo(i);
  }
  C_(t2, i) {
    t2.qo(i), this.b_();
  }
  T_(t2) {
    t2.Yo();
  }
  P_(t2, i) {
    t2.Xo(i);
  }
  R_(t2, i) {
    t2.Ko(i), this.b_();
  }
  D_(t2) {
    t2.Zo();
  }
  b_() {
    this._o.forEach((t2) => {
      t2.On();
    });
  }
  vn() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible && 0 !== this.__.Ta().length ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && 0 !== this.a_.Ta().length ? t2 = this.a_ : 0 !== this._o.length && (t2 = this._o[0].At()), null === t2 && (t2 = this.__), t2;
  }
  vr() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && (t2 = this.a_), t2;
  }
  x_(t2) {
    null !== t2 && t2.yo() && this.O_(t2);
  }
  A_(t2) {
    const i = this.wl.Xs();
    t2.So({ Wn: true }), null !== i && t2.t_(i), this.b_();
  }
  V_() {
    this.O_(this.a_), this.O_(this.__);
  }
  B_() {
    this.x_(this.a_), this.x_(this.__), this._o.forEach((t2) => {
      this.dr(t2) && this.x_(t2.At());
    }), this.b_(), this.Ui.Fh();
  }
  No() {
    return null === this.uo && (this.uo = vn(this._o)), this.uo;
  }
  I_() {
    return this.h_;
  }
  z_() {
    return this.l_;
  }
  O_(t2) {
    const i = t2.Qo();
    if (i && i.length > 0 && !this.wl.Fi()) {
      const i2 = this.wl.Xs();
      null !== i2 && t2.t_(i2);
    }
    t2.On();
  }
  g_() {
    const t2 = this.No();
    if (0 === t2.length)
      return { E_: 0, w_: 0 };
    let i = 0, n2 = 0;
    for (let s = 0; s < t2.length; s++) {
      const e3 = t2[s].Zi();
      null !== e3 && (e3 < i && (i = e3), e3 > n2 && (n2 = e3));
    }
    return { E_: i, w_: n2 };
  }
  M_(t2, i, n2) {
    let s = this.d_(i);
    if (null === s && (s = this.o_(i, this.Ui.W().overlayPriceScales)), this._o.push(t2), !ut$1(i)) {
      const n3 = this.s_.get(i) || [];
      n3.push(t2), this.s_.set(i, n3);
    }
    s.Fo(t2), t2.Ji(s), t2.Gi(n2), this.x_(s), this.uo = null;
  }
  u_(t2, i, n2) {
    i.yr !== n2.yr && this.O_(t2);
  }
  o_(t2, i) {
    const n2 = Object.assign({ visible: true, autoScale: true }, I(i)), s = new wn(t2, n2, this.Ui.W().layout, this.Ui.W().localization);
    return s.Oo(this.zt()), s;
  }
};
let Mn$1 = class Mn {
  constructor(t2, i, n2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Qe = /* @__PURE__ */ new Map(), this.Je = /* @__PURE__ */ new Map(), this.L_ = t2, this.N_ = i, this.tr = n2;
  }
  F_(t2) {
    const i = t2.time, n2 = this.N_.cacheKey(i), s = this.Qe.get(n2);
    if (void 0 !== s)
      return s.W_;
    if (this.Ke === this.tr) {
      const t3 = this.Je.get(this.Ge);
      this.Je.delete(this.Ge), this.Qe.delete(m$1(t3)), this.Ge++, this.Ke--;
    }
    const e3 = this.L_(t2);
    return this.Qe.set(n2, { W_: e3, er: this.Ze }), this.Je.set(this.Ze, n2), this.Ke++, this.Ze++, e3;
  }
};
let xn$1 = class xn {
  constructor(t2, i) {
    p$1(t2 <= i, "right should be >= left"), this.j_ = t2, this.H_ = i;
  }
  Os() {
    return this.j_;
  }
  di() {
    return this.H_;
  }
  U_() {
    return this.H_ - this.j_ + 1;
  }
  Kr(t2) {
    return this.j_ <= t2 && t2 <= this.H_;
  }
  Mh(t2) {
    return this.j_ === t2.Os() && this.H_ === t2.di();
  }
};
function Sn(t2, i) {
  return null === t2 || null === i ? t2 === i : t2.Mh(i);
}
let kn$1 = class kn {
  constructor() {
    this.q_ = /* @__PURE__ */ new Map(), this.Qe = null, this.Y_ = false;
  }
  X_(t2) {
    this.Y_ = t2, this.Qe = null;
  }
  K_(t2, i) {
    this.Z_(i), this.Qe = null;
    for (let n2 = i; n2 < t2.length; ++n2) {
      const i2 = t2[n2];
      let s = this.q_.get(i2.timeWeight);
      void 0 === s && (s = [], this.q_.set(i2.timeWeight, s)), s.push({ index: n2, time: i2.time, weight: i2.timeWeight, originalTime: i2.originalTime });
    }
  }
  G_(t2, i) {
    const n2 = Math.ceil(i / t2);
    return null !== this.Qe && this.Qe.J_ === n2 || (this.Qe = { Ea: this.Q_(n2), J_: n2 }), this.Qe.Ea;
  }
  Z_(t2) {
    if (0 === t2)
      return void this.q_.clear();
    const i = [];
    this.q_.forEach((n2, s) => {
      t2 <= n2[0].index ? i.push(s) : n2.splice(Bt$1(n2, t2, (i2) => i2.index < t2), 1 / 0);
    });
    for (const t3 of i)
      this.q_.delete(t3);
  }
  Q_(t2) {
    let i = [];
    for (const n2 of Array.from(this.q_.keys()).sort((t3, i2) => i2 - t3)) {
      if (!this.q_.get(n2))
        continue;
      const s = i;
      i = [];
      const e3 = s.length;
      let r2 = 0;
      const h2 = m$1(this.q_.get(n2)), l2 = h2.length;
      let a2 = 1 / 0, o2 = -1 / 0;
      for (let n3 = 0; n3 < l2; n3++) {
        const l3 = h2[n3], _24 = l3.index;
        for (; r2 < e3; ) {
          const t3 = s[r2], n4 = t3.index;
          if (!(n4 < _24)) {
            a2 = n4;
            break;
          }
          r2++, i.push(t3), o2 = n4, a2 = 1 / 0;
        }
        if (a2 - _24 >= t2 && _24 - o2 >= t2)
          i.push(l3), o2 = _24;
        else if (this.Y_)
          return s;
      }
      for (; r2 < e3; r2++)
        i.push(s[r2]);
    }
    return i;
  }
};
let yn$1 = class yn {
  constructor(t2) {
    this.tu = t2;
  }
  iu() {
    return null === this.tu ? null : new xn$1(Math.floor(this.tu.Os()), Math.ceil(this.tu.di()));
  }
  nu() {
    return this.tu;
  }
  static su() {
    return new yn(null);
  }
};
function Cn(t2, i) {
  return t2.weight > i.weight ? t2 : i;
}
class Tn {
  constructor(t2, i, n2, s) {
    this.e_ = 0, this.eu = null, this.ru = [], this.fo = null, this.do = null, this.hu = new kn$1(), this.lu = /* @__PURE__ */ new Map(), this.au = yn$1.su(), this.ou = true, this._u = new R(), this.uu = new R(), this.cu = new R(), this.du = null, this.fu = null, this.vu = [], this.cn = i, this.bo = n2, this.pu = i.rightOffset, this.mu = i.barSpacing, this.Ui = t2, this.N_ = s, this.bu(), this.hu.X_(i.uniformDistribution);
  }
  W() {
    return this.cn;
  }
  wu(t2) {
    D$1(this.bo, t2), this.gu(), this.bu();
  }
  Nh(t2, i) {
    var n2;
    D$1(this.cn, t2), this.cn.fixLeftEdge && this.Mu(), this.cn.fixRightEdge && this.xu(), void 0 !== t2.barSpacing && this.Ui.Gn(t2.barSpacing), void 0 !== t2.rightOffset && this.Ui.Jn(t2.rightOffset), void 0 !== t2.minBarSpacing && this.Ui.Gn(null !== (n2 = t2.barSpacing) && void 0 !== n2 ? n2 : this.mu), this.gu(), this.bu(), this.cu.m();
  }
  mn(t2) {
    var i, n2;
    return null !== (n2 = null === (i = this.ru[t2]) || void 0 === i ? void 0 : i.time) && void 0 !== n2 ? n2 : null;
  }
  qi(t2) {
    var i;
    return null !== (i = this.ru[t2]) && void 0 !== i ? i : null;
  }
  ya(t2, i) {
    if (this.ru.length < 1)
      return null;
    if (this.N_.key(t2) > this.N_.key(this.ru[this.ru.length - 1].time))
      return i ? this.ru.length - 1 : null;
    const n2 = Bt$1(this.ru, this.N_.key(t2), (t3, i2) => this.N_.key(t3.time) < i2);
    return this.N_.key(t2) < this.N_.key(this.ru[n2].time) ? i ? n2 : null : n2;
  }
  Fi() {
    return 0 === this.e_ || 0 === this.ru.length || null === this.eu;
  }
  ka() {
    return this.ru.length > 0;
  }
  Xs() {
    return this.Su(), this.au.iu();
  }
  ku() {
    return this.Su(), this.au.nu();
  }
  yu() {
    const t2 = this.Xs();
    if (null === t2)
      return null;
    const i = { from: t2.Os(), to: t2.di() };
    return this.Cu(i);
  }
  Cu(t2) {
    const i = Math.round(t2.from), n2 = Math.round(t2.to), s = b(this.Tu()), e3 = b(this.Pu());
    return { from: b(this.qi(Math.max(s, i))), to: b(this.qi(Math.min(e3, n2))) };
  }
  Ru(t2) {
    return { from: b(this.ya(t2.from, true)), to: b(this.ya(t2.to, true)) };
  }
  $i() {
    return this.e_;
  }
  m_(t2) {
    if (!isFinite(t2) || t2 <= 0)
      return;
    if (this.e_ === t2)
      return;
    const i = this.ku(), n2 = this.e_;
    if (this.e_ = t2, this.ou = true, this.cn.lockVisibleTimeRangeOnResize && 0 !== n2) {
      const i2 = this.mu * t2 / n2;
      this.mu = i2;
    }
    if (this.cn.fixLeftEdge && null !== i && i.Os() <= 0) {
      const i2 = n2 - t2;
      this.pu -= Math.round(i2 / this.mu) + 1, this.ou = true;
    }
    this.Du(), this.Ou();
  }
  Et(t2) {
    if (this.Fi() || !A$1(t2))
      return 0;
    const i = this.Au() + this.pu - t2;
    return this.e_ - (i + 0.5) * this.mu - 1;
  }
  Js(t2, i) {
    const n2 = this.Au(), s = void 0 === i ? 0 : i.from, e3 = void 0 === i ? t2.length : i.to;
    for (let i2 = s; i2 < e3; i2++) {
      const s2 = t2[i2].ut, e4 = n2 + this.pu - s2, r2 = this.e_ - (e4 + 0.5) * this.mu - 1;
      t2[i2].et = r2;
    }
  }
  Vu(t2) {
    return Math.ceil(this.Bu(t2));
  }
  Jn(t2) {
    this.ou = true, this.pu = t2, this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  he() {
    return this.mu;
  }
  Gn(t2) {
    this.zu(t2), this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  Eu() {
    return this.pu;
  }
  Ea() {
    if (this.Fi())
      return null;
    if (null !== this.fu)
      return this.fu;
    const t2 = this.mu, i = 5 * (this.Ui.W().layout.fontSize + 4) / 8 * (this.cn.tickMarkMaxCharacterLength || 8), n2 = Math.round(i / t2), s = b(this.Xs()), e3 = Math.max(s.Os(), s.Os() - n2), r2 = Math.max(s.di(), s.di() - n2), h2 = this.hu.G_(t2, i), l2 = this.Tu() + n2, a2 = this.Pu() - n2, o2 = this.Lu(), _24 = this.cn.fixLeftEdge || o2, u2 = this.cn.fixRightEdge || o2;
    let c2 = 0;
    for (const t3 of h2) {
      if (!(e3 <= t3.index && t3.index <= r2))
        continue;
      let n3;
      c2 < this.vu.length ? (n3 = this.vu[c2], n3.coord = this.Et(t3.index), n3.label = this.Nu(t3), n3.weight = t3.weight) : (n3 = { needAlignCoordinate: false, coord: this.Et(t3.index), label: this.Nu(t3), weight: t3.weight }, this.vu.push(n3)), this.mu > i / 2 && !o2 ? n3.needAlignCoordinate = false : n3.needAlignCoordinate = _24 && t3.index <= l2 || u2 && t3.index >= a2, c2++;
    }
    return this.vu.length = c2, this.fu = this.vu, this.vu;
  }
  Fu() {
    this.ou = true, this.Gn(this.cn.barSpacing), this.Jn(this.cn.rightOffset);
  }
  Wu(t2) {
    this.ou = true, this.eu = t2, this.Ou(), this.Mu();
  }
  ju(t2, i) {
    const n2 = this.Bu(t2), s = this.he(), e3 = s + i * (s / 10);
    this.Gn(e3), this.cn.rightBarStaysOnScroll || this.Jn(this.Eu() + (n2 - this.Bu(t2)));
  }
  Uo(t2) {
    this.fo && this.Zo(), null === this.do && null === this.du && (this.Fi() || (this.do = t2, this.Hu()));
  }
  qo(t2) {
    if (null === this.du)
      return;
    const i = yt$1(this.e_ - t2, 0, this.e_), n2 = yt$1(this.e_ - b(this.do), 0, this.e_);
    0 !== i && 0 !== n2 && this.Gn(this.du.he * i / n2);
  }
  Yo() {
    null !== this.do && (this.do = null, this.$u());
  }
  Xo(t2) {
    null === this.fo && null === this.du && (this.Fi() || (this.fo = t2, this.Hu()));
  }
  Ko(t2) {
    if (null === this.fo)
      return;
    const i = (this.fo - t2) / this.he();
    this.pu = b(this.du).Eu + i, this.ou = true, this.Ou();
  }
  Zo() {
    null !== this.fo && (this.fo = null, this.$u());
  }
  Uu() {
    this.qu(this.cn.rightOffset);
  }
  qu(t2, i = 400) {
    if (!isFinite(t2))
      throw new RangeError("offset is required and must be finite number");
    if (!isFinite(i) || i <= 0)
      throw new RangeError("animationDuration (optional) must be finite positive number");
    const n2 = this.pu, s = performance.now();
    this.Ui.Xn({ Yu: (t3) => (t3 - s) / i >= 1, Xu: (e3) => {
      const r2 = (e3 - s) / i;
      return r2 >= 1 ? t2 : n2 + (t2 - n2) * r2;
    } });
  }
  gt(t2, i) {
    this.ou = true, this.ru = t2, this.hu.K_(t2, i), this.Ou();
  }
  Ku() {
    return this._u;
  }
  Zu() {
    return this.uu;
  }
  Gu() {
    return this.cu;
  }
  Au() {
    return this.eu || 0;
  }
  Ju(t2) {
    const i = t2.U_();
    this.zu(this.e_ / i), this.pu = t2.di() - this.Au(), this.Ou(), this.ou = true, this.Ui.Iu(), this.Ui.Fh();
  }
  Qu() {
    const t2 = this.Tu(), i = this.Pu();
    null !== t2 && null !== i && this.Ju(new xn$1(t2, i + this.cn.rightOffset));
  }
  tc(t2) {
    const i = new xn$1(t2.from, t2.to);
    this.Ju(i);
  }
  Yi(t2) {
    return void 0 !== this.bo.timeFormatter ? this.bo.timeFormatter(t2.originalTime) : this.N_.formatHorzItem(t2.time);
  }
  Lu() {
    const { handleScroll: t2, handleScale: i } = this.Ui.W();
    return !(t2.horzTouchDrag || t2.mouseWheel || t2.pressedMouseMove || t2.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch);
  }
  Tu() {
    return 0 === this.ru.length ? null : 0;
  }
  Pu() {
    return 0 === this.ru.length ? null : this.ru.length - 1;
  }
  ic(t2) {
    return (this.e_ - 1 - t2) / this.mu;
  }
  Bu(t2) {
    const i = this.ic(t2), n2 = this.Au() + this.pu - i;
    return Math.round(1e6 * n2) / 1e6;
  }
  zu(t2) {
    const i = this.mu;
    this.mu = t2, this.Du(), i !== this.mu && (this.ou = true, this.nc());
  }
  Su() {
    if (!this.ou)
      return;
    if (this.ou = false, this.Fi())
      return void this.sc(yn$1.su());
    const t2 = this.Au(), i = this.e_ / this.mu, n2 = this.pu + t2, s = new xn$1(n2 - i + 1, n2);
    this.sc(new yn$1(s));
  }
  Du() {
    const t2 = this.ec();
    if (this.mu < t2 && (this.mu = t2, this.ou = true), 0 !== this.e_) {
      const t3 = 0.5 * this.e_;
      this.mu > t3 && (this.mu = t3, this.ou = true);
    }
  }
  ec() {
    return this.cn.fixLeftEdge && this.cn.fixRightEdge && 0 !== this.ru.length ? this.e_ / this.ru.length : this.cn.minBarSpacing;
  }
  Ou() {
    const t2 = this.rc();
    this.pu > t2 && (this.pu = t2, this.ou = true);
    const i = this.hc();
    null !== i && this.pu < i && (this.pu = i, this.ou = true);
  }
  hc() {
    const t2 = this.Tu(), i = this.eu;
    if (null === t2 || null === i)
      return null;
    return t2 - i - 1 + (this.cn.fixLeftEdge ? this.e_ / this.mu : Math.min(2, this.ru.length));
  }
  rc() {
    return this.cn.fixRightEdge ? 0 : this.e_ / this.mu - Math.min(2, this.ru.length);
  }
  Hu() {
    this.du = { he: this.he(), Eu: this.Eu() };
  }
  $u() {
    this.du = null;
  }
  Nu(t2) {
    let i = this.lu.get(t2.weight);
    return void 0 === i && (i = new Mn$1((t3) => this.lc(t3), this.N_), this.lu.set(t2.weight, i)), i.F_(t2);
  }
  lc(t2) {
    return this.N_.formatTickmark(t2, this.bo);
  }
  sc(t2) {
    const i = this.au;
    this.au = t2, Sn(i.iu(), this.au.iu()) || this._u.m(), Sn(i.nu(), this.au.nu()) || this.uu.m(), this.nc();
  }
  nc() {
    this.fu = null;
  }
  gu() {
    this.nc(), this.lu.clear();
  }
  bu() {
    this.N_.updateFormatter(this.bo);
  }
  Mu() {
    if (!this.cn.fixLeftEdge)
      return;
    const t2 = this.Tu();
    if (null === t2)
      return;
    const i = this.Xs();
    if (null === i)
      return;
    const n2 = i.Os() - t2;
    if (n2 < 0) {
      const t3 = this.pu - n2 - 1;
      this.Jn(t3);
    }
    this.Du();
  }
  xu() {
    this.Ou(), this.Du();
  }
}
class Pn extends j {
  constructor(t2) {
    super(), this.ac = /* @__PURE__ */ new Map(), this.Lt = t2;
  }
  Z(t2) {
  }
  J(t2) {
    if (!this.Lt.Tt)
      return;
    const { context: i, mediaSize: n2 } = t2;
    let s = 0;
    for (const t3 of this.Lt.oc) {
      if (0 === t3.Jt.length)
        continue;
      i.font = t3.R;
      const e4 = this._c(i, t3.Jt);
      e4 > n2.width ? t3.ju = n2.width / e4 : t3.ju = 1, s += t3.uc * t3.ju;
    }
    let e3 = 0;
    switch (this.Lt.cc) {
      case "top":
        e3 = 0;
        break;
      case "center":
        e3 = Math.max((n2.height - s) / 2, 0);
        break;
      case "bottom":
        e3 = Math.max(n2.height - s, 0);
    }
    i.fillStyle = this.Lt.O;
    for (const t3 of this.Lt.oc) {
      i.save();
      let s2 = 0;
      switch (this.Lt.dc) {
        case "left":
          i.textAlign = "left", s2 = t3.uc / 2;
          break;
        case "center":
          i.textAlign = "center", s2 = n2.width / 2;
          break;
        case "right":
          i.textAlign = "right", s2 = n2.width - 1 - t3.uc / 2;
      }
      i.translate(s2, e3), i.textBaseline = "top", i.font = t3.R, i.scale(t3.ju, t3.ju), i.fillText(t3.Jt, 0, t3.fc), i.restore(), e3 += t3.uc * t3.ju;
    }
  }
  _c(t2, i) {
    const n2 = this.vc(t2.font);
    let s = n2.get(i);
    return void 0 === s && (s = t2.measureText(i).width, n2.set(i, s)), s;
  }
  vc(t2) {
    let i = this.ac.get(t2);
    return void 0 === i && (i = /* @__PURE__ */ new Map(), this.ac.set(t2, i)), i;
  }
}
class Rn {
  constructor(t2) {
    this.bt = true, this.jt = { Tt: false, O: "", oc: [], cc: "center", dc: "center" }, this.Ht = new Pn(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht;
  }
  St() {
    const t2 = this.$t.W(), i = this.jt;
    i.Tt = t2.visible, i.Tt && (i.O = t2.color, i.dc = t2.horzAlign, i.cc = t2.vertAlign, i.oc = [{ Jt: t2.text, R: N$1(t2.fontSize, t2.fontFamily, t2.fontStyle), uc: 1.2 * t2.fontSize, fc: 0, ju: 0 }]);
  }
}
let Dn$1 = class Dn extends at$1 {
  constructor(t2, i) {
    super(), this.cn = i, this.wn = new Rn(this);
  }
  Rn() {
    return [];
  }
  Pn() {
    return [this.wn];
  }
  W() {
    return this.cn;
  }
  On() {
    this.wn.gt();
  }
};
var On, An, Vn$1, Bn$1, In;
!function(t2) {
  t2[t2.OnTouchEnd = 0] = "OnTouchEnd", t2[t2.OnNextTap = 1] = "OnNextTap";
}(On || (On = {}));
class zn {
  constructor(t2, i, n2) {
    this.mc = [], this.bc = [], this.e_ = 0, this.wc = null, this.gc = new R(), this.Mc = new R(), this.xc = null, this.Sc = t2, this.cn = i, this.N_ = n2, this.kc = new F$1(this), this.wl = new Tn(this, i.timeScale, this.cn.localization, n2), this.wt = new _t$1(this, i.crosshair), this.yc = new Ji(i.crosshair), this.Cc = new Dn$1(this, i.watermark), this.Tc(), this.mc[0].p_(2e3), this.Pc = this.Rc(0), this.Dc = this.Rc(1);
  }
  $l() {
    this.Oc(ct.es());
  }
  Fh() {
    this.Oc(ct.ss());
  }
  sa() {
    this.Oc(new ct(1));
  }
  Ul(t2) {
    const i = this.Ac(t2);
    this.Oc(i);
  }
  Vc() {
    return this.wc;
  }
  Bc(t2) {
    const i = this.wc;
    this.wc = t2, null !== i && this.Ul(i.Ic), null !== t2 && this.Ul(t2.Ic);
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    D$1(this.cn, t2), this.mc.forEach((i) => i.c_(t2)), void 0 !== t2.timeScale && this.wl.Nh(t2.timeScale), void 0 !== t2.localization && this.wl.wu(t2.localization), (t2.leftPriceScale || t2.rightPriceScale) && this.gc.m(), this.Pc = this.Rc(0), this.Dc = this.Rc(1), this.$l();
  }
  zc(t2, i) {
    if ("left" === t2)
      return void this.Nh({ leftPriceScale: i });
    if ("right" === t2)
      return void this.Nh({ rightPriceScale: i });
    const n2 = this.Ec(t2);
    null !== n2 && (n2.At.Nh(i), this.gc.m());
  }
  Ec(t2) {
    for (const i of this.mc) {
      const n2 = i.d_(t2);
      if (null !== n2)
        return { Ut: i, At: n2 };
    }
    return null;
  }
  yt() {
    return this.wl;
  }
  Lc() {
    return this.mc;
  }
  Nc() {
    return this.Cc;
  }
  Fc() {
    return this.wt;
  }
  Wc() {
    return this.Mc;
  }
  jc(t2, i) {
    t2.Oo(i), this.Iu();
  }
  m_(t2) {
    this.e_ = t2, this.wl.m_(this.e_), this.mc.forEach((i) => i.m_(t2)), this.Iu();
  }
  Tc(t2) {
    const i = new gn$1(this.wl, this);
    void 0 !== t2 ? this.mc.splice(t2, 0, i) : this.mc.push(i);
    const n2 = void 0 === t2 ? this.mc.length - 1 : t2, s = ct.es();
    return s.Nn(n2, { Fn: 0, Wn: true }), this.Oc(s), i;
  }
  y_(t2, i, n2) {
    t2.y_(i, n2);
  }
  C_(t2, i, n2) {
    t2.C_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2));
  }
  T_(t2, i) {
    t2.T_(i), this.Oc(this.Hc(t2, 2));
  }
  P_(t2, i, n2) {
    i.yo() || t2.P_(i, n2);
  }
  R_(t2, i, n2) {
    i.yo() || (t2.R_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2)));
  }
  D_(t2, i) {
    i.yo() || (t2.D_(i), this.Oc(this.Hc(t2, 2)));
  }
  A_(t2, i) {
    t2.A_(i), this.Oc(this.Hc(t2, 2));
  }
  $c(t2) {
    this.wl.Uo(t2);
  }
  Uc(t2, i) {
    const n2 = this.yt();
    if (n2.Fi() || 0 === i)
      return;
    const s = n2.$i();
    t2 = Math.max(1, Math.min(t2, s)), n2.ju(t2, i), this.Iu();
  }
  qc(t2) {
    this.Yc(0), this.Xc(t2), this.Kc();
  }
  Zc(t2) {
    this.wl.qo(t2), this.Iu();
  }
  Gc() {
    this.wl.Yo(), this.Fh();
  }
  Yc(t2) {
    this.wl.Xo(t2);
  }
  Xc(t2) {
    this.wl.Ko(t2), this.Iu();
  }
  Kc() {
    this.wl.Zo(), this.Fh();
  }
  Mt() {
    return this.bc;
  }
  Jc(t2, i, n2, s, e3) {
    this.wt.gn(t2, i);
    let r2 = NaN, h2 = this.wl.Vu(t2);
    const l2 = this.wl.Xs();
    null !== l2 && (h2 = Math.min(Math.max(l2.Os(), h2), l2.di()));
    const a2 = s.vn(), o2 = a2.Pt();
    null !== o2 && (r2 = a2.pn(i, o2)), r2 = this.yc.Ca(r2, h2, s), this.wt.kn(h2, r2, s), this.sa(), e3 || this.Mc.m(this.wt.kt(), { x: t2, y: i }, n2);
  }
  Qc(t2, i, n2) {
    const s = n2.vn(), e3 = s.Pt(), r2 = s.Ot(t2, b(e3)), h2 = this.wl.ya(i, true), l2 = this.wl.Et(b(h2));
    this.Jc(l2, r2, null, n2, true);
  }
  td(t2) {
    this.Fc().Cn(), this.sa(), t2 || this.Mc.m(null, null, null);
  }
  ql() {
    const t2 = this.wt.Ut();
    if (null !== t2) {
      const i = this.wt.xn(), n2 = this.wt.Sn();
      this.Jc(i, n2, null, t2);
    }
    this.wt.On();
  }
  nd(t2, i, n2) {
    const s = this.wl.mn(0);
    void 0 !== i && void 0 !== n2 && this.wl.gt(i, n2);
    const e3 = this.wl.mn(0), r2 = this.wl.Au(), h2 = this.wl.Xs();
    if (null !== h2 && null !== s && null !== e3) {
      const i2 = h2.Kr(r2), l2 = this.N_.key(s) > this.N_.key(e3), a2 = null !== t2 && t2 > r2 && !l2, o2 = this.wl.W().allowShiftVisibleRangeOnWhitespaceReplacement, _24 = i2 && (!(void 0 === n2) || o2) && this.wl.W().shiftVisibleRangeOnNewBar;
      if (a2 && !_24) {
        const i3 = t2 - r2;
        this.wl.Jn(this.wl.Eu() - i3);
      }
    }
    this.wl.Wu(t2);
  }
  Kl(t2) {
    null !== t2 && t2.B_();
  }
  cr(t2) {
    const i = this.mc.find((i2) => i2.No().includes(t2));
    return void 0 === i ? null : i;
  }
  Iu() {
    this.Cc.On(), this.mc.forEach((t2) => t2.B_()), this.ql();
  }
  S() {
    this.mc.forEach((t2) => t2.S()), this.mc.length = 0, this.cn.localization.priceFormatter = void 0, this.cn.localization.percentageFormatter = void 0, this.cn.localization.timeFormatter = void 0;
  }
  sd() {
    return this.kc;
  }
  mr() {
    return this.kc.W();
  }
  f_() {
    return this.gc;
  }
  ed(t2, i, n2) {
    const s = this.mc[0], e3 = this.rd(i, t2, s, n2);
    return this.bc.push(e3), 1 === this.bc.length ? this.$l() : this.Fh(), e3;
  }
  hd(t2) {
    const i = this.cr(t2), n2 = this.bc.indexOf(t2);
    p$1(-1 !== n2, "Series not found"), this.bc.splice(n2, 1), b(i).jo(t2), t2.S && t2.S();
  }
  Hl(t2, i) {
    const n2 = b(this.cr(t2));
    n2.jo(t2);
    const s = this.Ec(i);
    if (null === s) {
      const s2 = t2.Zi();
      n2.Fo(t2, i, s2);
    } else {
      const e3 = s.Ut === n2 ? t2.Zi() : void 0;
      s.Ut.Fo(t2, i, e3);
    }
  }
  Qu() {
    const t2 = ct.ss();
    t2.$n(), this.Oc(t2);
  }
  ld(t2) {
    const i = ct.ss();
    i.Yn(t2), this.Oc(i);
  }
  Zn() {
    const t2 = ct.ss();
    t2.Zn(), this.Oc(t2);
  }
  Gn(t2) {
    const i = ct.ss();
    i.Gn(t2), this.Oc(i);
  }
  Jn(t2) {
    const i = ct.ss();
    i.Jn(t2), this.Oc(i);
  }
  Xn(t2) {
    const i = ct.ss();
    i.Xn(t2), this.Oc(i);
  }
  Un() {
    const t2 = ct.ss();
    t2.Un(), this.Oc(t2);
  }
  ad() {
    return this.cn.rightPriceScale.visible ? "right" : "left";
  }
  od() {
    return this.Dc;
  }
  q() {
    return this.Pc;
  }
  It(t2) {
    const i = this.Dc, n2 = this.Pc;
    if (i === n2)
      return i;
    if (t2 = Math.max(0, Math.min(100, Math.round(100 * t2))), null === this.xc || this.xc.Ts !== n2 || this.xc.Ps !== i)
      this.xc = { Ts: n2, Ps: i, _d: /* @__PURE__ */ new Map() };
    else {
      const i2 = this.xc._d.get(t2);
      if (void 0 !== i2)
        return i2;
    }
    const s = function(t3, i2, n3) {
      const [s2, e3, r2, h2] = T$1(t3), [l2, a2, o2, _24] = T$1(i2), u2 = [M(s2 + n3 * (l2 - s2)), M(e3 + n3 * (a2 - e3)), M(r2 + n3 * (o2 - r2)), x(h2 + n3 * (_24 - h2))];
      return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
    }(n2, i, t2 / 100);
    return this.xc._d.set(t2, s), s;
  }
  Hc(t2, i) {
    const n2 = new ct(i);
    if (null !== t2) {
      const s = this.mc.indexOf(t2);
      n2.Nn(s, { Fn: i });
    }
    return n2;
  }
  Ac(t2, i) {
    return void 0 === i && (i = 2), this.Hc(this.cr(t2), i);
  }
  Oc(t2) {
    this.Sc && this.Sc(t2), this.mc.forEach((t3) => t3.z_().Wh().gt());
  }
  rd(t2, i, n2, s) {
    const e3 = new Gi(this, t2, i, n2, s), r2 = void 0 !== t2.priceScaleId ? t2.priceScaleId : this.ad();
    return n2.Fo(e3, r2), ut$1(r2) || e3.Nh(t2), e3;
  }
  Rc(t2) {
    const i = this.cn.layout;
    return "gradient" === i.background.type ? 0 === t2 ? i.background.topColor : i.background.bottomColor : i.background.color;
  }
}
function En(t2) {
  return !O$1(t2) && !V$1(t2);
}
function Ln$1(t2) {
  return O$1(t2);
}
!function(t2) {
  t2[t2.Disabled = 0] = "Disabled", t2[t2.Continuous = 1] = "Continuous", t2[t2.OnDataUpdate = 2] = "OnDataUpdate";
}(An || (An = {})), function(t2) {
  t2[t2.LastBar = 0] = "LastBar", t2[t2.LastVisible = 1] = "LastVisible";
}(Vn$1 || (Vn$1 = {})), function(t2) {
  t2.Solid = "solid", t2.VerticalGradient = "gradient";
}(Bn$1 || (Bn$1 = {})), function(t2) {
  t2[t2.Year = 0] = "Year", t2[t2.Month = 1] = "Month", t2[t2.DayOfMonth = 2] = "DayOfMonth", t2[t2.Time = 3] = "Time", t2[t2.TimeWithSeconds = 4] = "TimeWithSeconds";
}(In || (In = {}));
const Nn = (t2) => t2.getUTCFullYear();
function Fn$1(t2, i, n2) {
  return i.replace(/yyyy/g, ((t3) => ft$1(Nn(t3), 4))(t2)).replace(/yy/g, ((t3) => ft$1(Nn(t3) % 100, 2))(t2)).replace(/MMMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "long" }))(t2, n2)).replace(/MMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "short" }))(t2, n2)).replace(/MM/g, ((t3) => ft$1(((t4) => t4.getUTCMonth() + 1)(t3), 2))(t2)).replace(/dd/g, ((t3) => ft$1(((t4) => t4.getUTCDate())(t3), 2))(t2));
}
let Wn$1 = class Wn {
  constructor(t2 = "yyyy-MM-dd", i = "default") {
    this.ud = t2, this.dd = i;
  }
  F_(t2) {
    return Fn$1(t2, this.ud, this.dd);
  }
};
class jn {
  constructor(t2) {
    this.fd = t2 || "%h:%m:%s";
  }
  F_(t2) {
    return this.fd.replace("%h", ft$1(t2.getUTCHours(), 2)).replace("%m", ft$1(t2.getUTCMinutes(), 2)).replace("%s", ft$1(t2.getUTCSeconds(), 2));
  }
}
const Hn$1 = { vd: "yyyy-MM-dd", pd: "%h:%m:%s", md: " ", bd: "default" };
class $n {
  constructor(t2 = {}) {
    const i = Object.assign(Object.assign({}, Hn$1), t2);
    this.wd = new Wn$1(i.vd, i.bd), this.gd = new jn(i.pd), this.Md = i.md;
  }
  F_(t2) {
    return `${this.wd.F_(t2)}${this.Md}${this.gd.F_(t2)}`;
  }
}
function Un(t2) {
  return 60 * t2 * 60 * 1e3;
}
function qn$1(t2) {
  return 60 * t2 * 1e3;
}
const Yn = [{ xd: (Xn$1 = 1, 1e3 * Xn$1), Sd: 10 }, { xd: qn$1(1), Sd: 20 }, { xd: qn$1(5), Sd: 21 }, { xd: qn$1(30), Sd: 22 }, { xd: Un(1), Sd: 30 }, { xd: Un(3), Sd: 31 }, { xd: Un(6), Sd: 32 }, { xd: Un(12), Sd: 33 }];
var Xn$1;
function Kn$1(t2, i) {
  if (t2.getUTCFullYear() !== i.getUTCFullYear())
    return 70;
  if (t2.getUTCMonth() !== i.getUTCMonth())
    return 60;
  if (t2.getUTCDate() !== i.getUTCDate())
    return 50;
  for (let n2 = Yn.length - 1; n2 >= 0; --n2)
    if (Math.floor(i.getTime() / Yn[n2].xd) !== Math.floor(t2.getTime() / Yn[n2].xd))
      return Yn[n2].Sd;
  return 0;
}
function Zn(t2) {
  let i = t2;
  if (V$1(t2) && (i = Jn$1(t2)), !En(i))
    throw new Error("time must be of type BusinessDay");
  const n2 = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0));
  return { kd: Math.round(n2.getTime() / 1e3), yd: i };
}
function Gn$1(t2) {
  if (!Ln$1(t2))
    throw new Error("time must be of type isUTCTimestamp");
  return { kd: t2 };
}
function Jn$1(t2) {
  const i = new Date(t2);
  if (isNaN(i.getTime()))
    throw new Error(`Invalid date string=${t2}, expected format=yyyy-mm-dd`);
  return { day: i.getUTCDate(), month: i.getUTCMonth() + 1, year: i.getUTCFullYear() };
}
function Qn$1(t2) {
  V$1(t2.time) && (t2.time = Jn$1(t2.time));
}
class ts {
  options() {
    return this.cn;
  }
  setOptions(t2) {
    this.cn = t2, this.updateFormatter(t2.localization);
  }
  preprocessData(t2) {
    Array.isArray(t2) ? function(t3) {
      t3.forEach(Qn$1);
    }(t2) : Qn$1(t2);
  }
  createConverterToInternalObj(t2) {
    return b(function(t3) {
      return 0 === t3.length ? null : En(t3[0].time) || V$1(t3[0].time) ? Zn : Gn$1;
    }(t2));
  }
  key(t2) {
    return "object" == typeof t2 && "kd" in t2 ? t2.kd : this.key(this.convertHorzItemToInternal(t2));
  }
  cacheKey(t2) {
    const i = t2;
    return void 0 === i.yd ? new Date(1e3 * i.kd).getTime() : new Date(Date.UTC(i.yd.year, i.yd.month - 1, i.yd.day)).getTime();
  }
  convertHorzItemToInternal(t2) {
    return Ln$1(i = t2) ? Gn$1(i) : En(i) ? Zn(i) : Zn(Jn$1(i));
    var i;
  }
  updateFormatter(t2) {
    if (!this.cn)
      return;
    const i = t2.dateFormat;
    this.cn.timeScale.timeVisible ? this.Cd = new $n({ vd: i, pd: this.cn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", md: "   ", bd: t2.locale }) : this.Cd = new Wn$1(i, t2.locale);
  }
  formatHorzItem(t2) {
    const i = t2;
    return this.Cd.F_(new Date(1e3 * i.kd));
  }
  formatTickmark(t2, i) {
    const n2 = function(t3, i2, n3) {
      switch (t3) {
        case 0:
        case 10:
          return i2 ? n3 ? 4 : 3 : 2;
        case 20:
        case 21:
        case 22:
        case 30:
        case 31:
        case 32:
        case 33:
          return i2 ? 3 : 2;
        case 50:
          return 2;
        case 60:
          return 1;
        case 70:
          return 0;
      }
    }(t2.weight, this.cn.timeScale.timeVisible, this.cn.timeScale.secondsVisible), s = this.cn.timeScale;
    if (void 0 !== s.tickMarkFormatter) {
      const e3 = s.tickMarkFormatter(t2.originalTime, n2, i.locale);
      if (null !== e3)
        return e3;
    }
    return function(t3, i2, n3) {
      const s2 = {};
      switch (i2) {
        case 0:
          s2.year = "numeric";
          break;
        case 1:
          s2.month = "short";
          break;
        case 2:
          s2.day = "numeric";
          break;
        case 3:
          s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit";
          break;
        case 4:
          s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
      }
      const e3 = void 0 === t3.yd ? new Date(1e3 * t3.kd) : new Date(Date.UTC(t3.yd.year, t3.yd.month - 1, t3.yd.day));
      return new Date(e3.getUTCFullYear(), e3.getUTCMonth(), e3.getUTCDate(), e3.getUTCHours(), e3.getUTCMinutes(), e3.getUTCSeconds(), e3.getUTCMilliseconds()).toLocaleString(n3, s2);
    }(t2.time, n2, i.locale);
  }
  maxTickMarkWeight(t2) {
    let i = t2.reduce(Cn, t2[0]).weight;
    return i > 30 && i < 50 && (i = 30), i;
  }
  fillWeightsForPoints(t2, i) {
    !function(t3, i2 = 0) {
      if (0 === t3.length)
        return;
      let n2 = 0 === i2 ? null : t3[i2 - 1].time.kd, s = null !== n2 ? new Date(1e3 * n2) : null, e3 = 0;
      for (let r2 = i2; r2 < t3.length; ++r2) {
        const i3 = t3[r2], h2 = new Date(1e3 * i3.time.kd);
        null !== s && (i3.timeWeight = Kn$1(h2, s)), e3 += i3.time.kd - (n2 || i3.time.kd), n2 = i3.time.kd, s = h2;
      }
      if (0 === i2 && t3.length > 1) {
        const i3 = Math.ceil(e3 / (t3.length - 1)), n3 = new Date(1e3 * (t3[0].time.kd - i3));
        t3[0].timeWeight = Kn$1(new Date(1e3 * t3[0].time.kd), n3);
      }
    }(t2, i);
  }
  static Td(t2) {
    return D$1({ localization: { dateFormat: "dd MMM 'yy" } }, null != t2 ? t2 : {});
  }
}
const is = "undefined" != typeof window;
function ns() {
  return !!is && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
}
function ss() {
  return !!is && /iPhone|iPad|iPod/.test(window.navigator.platform);
}
function es(t2) {
  return t2 + t2 % 2;
}
function rs(t2, i) {
  return t2.Pd - i.Pd;
}
function hs(t2, i, n2) {
  const s = (t2.Pd - i.Pd) / (t2.ut - i.ut);
  return Math.sign(s) * Math.min(Math.abs(s), n2);
}
class ls {
  constructor(t2, i, n2, s) {
    this.Rd = null, this.Dd = null, this.Od = null, this.Ad = null, this.Vd = null, this.Bd = 0, this.Id = 0, this.zd = t2, this.Ed = i, this.Ld = n2, this.rs = s;
  }
  Nd(t2, i) {
    if (null !== this.Rd) {
      if (this.Rd.ut === i)
        return void (this.Rd.Pd = t2);
      if (Math.abs(this.Rd.Pd - t2) < this.rs)
        return;
    }
    this.Ad = this.Od, this.Od = this.Dd, this.Dd = this.Rd, this.Rd = { ut: i, Pd: t2 };
  }
  Dr(t2, i) {
    if (null === this.Rd || null === this.Dd)
      return;
    if (i - this.Rd.ut > 50)
      return;
    let n2 = 0;
    const s = hs(this.Rd, this.Dd, this.Ed), e3 = rs(this.Rd, this.Dd), r2 = [s], h2 = [e3];
    if (n2 += e3, null !== this.Od) {
      const t3 = hs(this.Dd, this.Od, this.Ed);
      if (Math.sign(t3) === Math.sign(s)) {
        const i2 = rs(this.Dd, this.Od);
        if (r2.push(t3), h2.push(i2), n2 += i2, null !== this.Ad) {
          const t4 = hs(this.Od, this.Ad, this.Ed);
          if (Math.sign(t4) === Math.sign(s)) {
            const i3 = rs(this.Od, this.Ad);
            r2.push(t4), h2.push(i3), n2 += i3;
          }
        }
      }
    }
    let l2 = 0;
    for (let t3 = 0; t3 < r2.length; ++t3)
      l2 += h2[t3] / n2 * r2[t3];
    Math.abs(l2) < this.zd || (this.Vd = { Pd: t2, ut: i }, this.Id = l2, this.Bd = function(t3, i2) {
      const n3 = Math.log(i2);
      return Math.log(1 * n3 / -t3) / n3;
    }(Math.abs(l2), this.Ld));
  }
  Xu(t2) {
    const i = b(this.Vd), n2 = t2 - i.ut;
    return i.Pd + this.Id * (Math.pow(this.Ld, n2) - 1) / Math.log(this.Ld);
  }
  Yu(t2) {
    return null === this.Vd || this.Fd(t2) === this.Bd;
  }
  Fd(t2) {
    const i = t2 - b(this.Vd).ut;
    return Math.min(i, this.Bd);
  }
}
function as(t2, n2) {
  const s = b(t2.ownerDocument).createElement("canvas");
  t2.appendChild(s);
  const e3 = bindTo(s, { type: "device-pixel-content-box", options: { allowResizeObserver: false }, transform: (t3, i) => ({ width: Math.max(t3.width, i.width), height: Math.max(t3.height, i.height) }) });
  return e3.resizeCanvasElement(n2), e3;
}
function os(t2, i, n2, s) {
  t2.G && t2.G(i, n2, s);
}
function _s(t2, i, n2, s) {
  t2.K(i, n2, s);
}
function us(t2, i, n2, s) {
  const e3 = t2(n2, s);
  for (const t3 of e3) {
    const n3 = t3.xt();
    null !== n3 && i(n3);
  }
}
function cs(t2) {
  is && void 0 !== window.chrome && t2.addEventListener("mousedown", (t3) => {
    if (1 === t3.button)
      return t3.preventDefault(), false;
  });
}
class ds {
  constructor(t2, i, n2) {
    this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.Yd = null, this.Xd = false, this.Kd = null, this.Zd = null, this.Gd = false, this.Jd = false, this.Qd = false, this.tf = null, this.if = null, this.nf = null, this.sf = null, this.ef = null, this.rf = null, this.hf = null, this.lf = 0, this.af = false, this._f = false, this.uf = false, this.cf = 0, this.df = null, this.ff = !ss(), this.vf = (t3) => {
      this.pf(t3);
    }, this.mf = (t3) => {
      if (this.bf(t3)) {
        const i2 = this.wf(t3);
        if (++this.$d, this.Ud && this.$d > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.qd);
          n3 < 30 && !this.Qd && this.xf(i2, this.kf.Sf), this.yf();
        }
      } else {
        const i2 = this.wf(t3);
        if (++this.Wd, this.jd && this.Wd > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.Hd);
          n3 < 5 && !this.Jd && this.Cf(i2, this.kf.Tf), this.Pf();
        }
      }
    }, this.Rf = t2, this.kf = i, this.cn = n2, this.Df();
  }
  S() {
    null !== this.tf && (this.tf(), this.tf = null), null !== this.if && (this.if(), this.if = null), null !== this.sf && (this.sf(), this.sf = null), null !== this.ef && (this.ef(), this.ef = null), null !== this.rf && (this.rf(), this.rf = null), null !== this.nf && (this.nf(), this.nf = null), this.Of(), this.Pf();
  }
  Af(t2) {
    this.sf && this.sf();
    const i = this.Vf.bind(this);
    if (this.sf = () => {
      this.Rf.removeEventListener("mousemove", i);
    }, this.Rf.addEventListener("mousemove", i), this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Bf), this.ff = true;
  }
  Pf() {
    null !== this.jd && clearTimeout(this.jd), this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  yf() {
    null !== this.Ud && clearTimeout(this.Ud), this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  Vf(t2) {
    if (this.uf || null !== this.Zd)
      return;
    if (this.bf(t2))
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.If), this.ff = true;
  }
  zf(t2) {
    const i = bs(t2.changedTouches, b(this.df));
    if (null === i)
      return;
    if (this.cf = ms(t2), null !== this.hf)
      return;
    if (this._f)
      return;
    this.af = true;
    const n2 = this.Mf(ps(i), b(this.Zd)), { Ef: s, Lf: e3, gf: r2 } = n2;
    if (this.Gd || !(r2 < 5)) {
      if (!this.Gd) {
        const t3 = 0.5 * s, i2 = e3 >= t3 && !this.cn.Nf(), n3 = t3 > e3 && !this.cn.Ff();
        i2 || n3 || (this._f = true), this.Gd = true, this.Qd = true, this.Of(), this.yf();
      }
      if (!this._f) {
        const n3 = this.wf(t2, i);
        this.xf(n3, this.kf.Wf), vs(t2);
      }
    }
  }
  jf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.Mf(ps(t2), b(this.Kd)), { gf: n2 } = i;
    if (n2 >= 5 && (this.Jd = true, this.Pf()), this.Jd) {
      const i2 = this.wf(t2);
      this.Cf(i2, this.kf.Hf);
    }
  }
  Mf(t2, i) {
    const n2 = Math.abs(i.et - t2.et), s = Math.abs(i.rt - t2.rt);
    return { Ef: n2, Lf: s, gf: n2 + s };
  }
  $f(t2) {
    let i = bs(t2.changedTouches, b(this.df));
    if (null === i && 0 === t2.touches.length && (i = t2.changedTouches[0]), null === i)
      return;
    this.df = null, this.cf = ms(t2), this.Of(), this.Zd = null, this.rf && (this.rf(), this.rf = null);
    const n2 = this.wf(t2, i);
    if (this.xf(n2, this.kf.Uf), ++this.$d, this.Ud && this.$d > 1) {
      const { gf: t3 } = this.Mf(ps(i), this.qd);
      t3 < 30 && !this.Qd && this.xf(n2, this.kf.Sf), this.yf();
    } else
      this.Qd || (this.xf(n2, this.kf.qf), this.kf.qf && vs(t2));
    0 === this.$d && vs(t2), 0 === t2.touches.length && this.Xd && (this.Xd = false, vs(t2));
  }
  pf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.wf(t2);
    if (this.Kd = null, this.uf = false, this.ef && (this.ef(), this.ef = null), ns()) {
      this.Rf.ownerDocument.documentElement.removeEventListener("mouseleave", this.vf);
    }
    if (!this.bf(t2))
      if (this.Cf(i, this.kf.Yf), ++this.Wd, this.jd && this.Wd > 1) {
        const { gf: n2 } = this.Mf(ps(t2), this.Hd);
        n2 < 5 && !this.Jd && this.Cf(i, this.kf.Tf), this.Pf();
      } else
        this.Jd || this.Cf(i, this.kf.Xf);
  }
  Of() {
    null !== this.Yd && (clearTimeout(this.Yd), this.Yd = null);
  }
  Kf(t2) {
    if (null !== this.df)
      return;
    const i = t2.changedTouches[0];
    this.df = i.identifier, this.cf = ms(t2);
    const n2 = this.Rf.ownerDocument.documentElement;
    this.Qd = false, this.Gd = false, this._f = false, this.Zd = ps(i), this.rf && (this.rf(), this.rf = null);
    {
      const i2 = this.zf.bind(this), s2 = this.$f.bind(this);
      this.rf = () => {
        n2.removeEventListener("touchmove", i2), n2.removeEventListener("touchend", s2);
      }, n2.addEventListener("touchmove", i2, { passive: false }), n2.addEventListener("touchend", s2, { passive: false }), this.Of(), this.Yd = setTimeout(this.Zf.bind(this, t2), 240);
    }
    const s = this.wf(t2, i);
    this.xf(s, this.kf.Gf), this.Ud || (this.$d = 0, this.Ud = setTimeout(this.yf.bind(this), 500), this.qd = ps(i));
  }
  Jf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.Rf.ownerDocument.documentElement;
    ns() && i.addEventListener("mouseleave", this.vf), this.Jd = false, this.Kd = ps(t2), this.ef && (this.ef(), this.ef = null);
    {
      const t3 = this.jf.bind(this), n3 = this.pf.bind(this);
      this.ef = () => {
        i.removeEventListener("mousemove", t3), i.removeEventListener("mouseup", n3);
      }, i.addEventListener("mousemove", t3), i.addEventListener("mouseup", n3);
    }
    if (this.uf = true, this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Qf), this.jd || (this.Wd = 0, this.jd = setTimeout(this.Pf.bind(this), 500), this.Hd = ps(t2));
  }
  Df() {
    this.Rf.addEventListener("mouseenter", this.Af.bind(this)), this.Rf.addEventListener("touchcancel", this.Of.bind(this));
    {
      const t2 = this.Rf.ownerDocument, i = (t3) => {
        this.kf.tv && (t3.composed && this.Rf.contains(t3.composedPath()[0]) || t3.target && this.Rf.contains(t3.target) || this.kf.tv());
      };
      this.if = () => {
        t2.removeEventListener("touchstart", i);
      }, this.tf = () => {
        t2.removeEventListener("mousedown", i);
      }, t2.addEventListener("mousedown", i), t2.addEventListener("touchstart", i, { passive: true });
    }
    ss() && (this.nf = () => {
      this.Rf.removeEventListener("dblclick", this.mf);
    }, this.Rf.addEventListener("dblclick", this.mf)), this.Rf.addEventListener("mouseleave", this.iv.bind(this)), this.Rf.addEventListener("touchstart", this.Kf.bind(this), { passive: true }), cs(this.Rf), this.Rf.addEventListener("mousedown", this.Jf.bind(this)), this.nv(), this.Rf.addEventListener("touchmove", () => {
    }, { passive: false });
  }
  nv() {
    void 0 === this.kf.sv && void 0 === this.kf.ev && void 0 === this.kf.rv || (this.Rf.addEventListener("touchstart", (t2) => this.hv(t2.touches), { passive: true }), this.Rf.addEventListener("touchmove", (t2) => {
      if (2 === t2.touches.length && null !== this.hf && void 0 !== this.kf.ev) {
        const i = fs(t2.touches[0], t2.touches[1]) / this.lf;
        this.kf.ev(this.hf, i), vs(t2);
      }
    }, { passive: false }), this.Rf.addEventListener("touchend", (t2) => {
      this.hv(t2.touches);
    }));
  }
  hv(t2) {
    1 === t2.length && (this.af = false), 2 !== t2.length || this.af || this.Xd ? this.lv() : this.av(t2);
  }
  av(t2) {
    const i = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    this.hf = { et: (t2[0].clientX - i.left + (t2[1].clientX - i.left)) / 2, rt: (t2[0].clientY - i.top + (t2[1].clientY - i.top)) / 2 }, this.lf = fs(t2[0], t2[1]), void 0 !== this.kf.sv && this.kf.sv(), this.Of();
  }
  lv() {
    null !== this.hf && (this.hf = null, void 0 !== this.kf.rv && this.kf.rv());
  }
  iv(t2) {
    if (this.sf && this.sf(), this.bf(t2))
      return;
    if (!this.ff)
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.ov), this.ff = !ss();
  }
  Zf(t2) {
    const i = bs(t2.touches, b(this.df));
    if (null === i)
      return;
    const n2 = this.wf(t2, i);
    this.xf(n2, this.kf._v), this.Qd = true, this.Xd = true;
  }
  bf(t2) {
    return t2.sourceCapabilities && void 0 !== t2.sourceCapabilities.firesTouchEvents ? t2.sourceCapabilities.firesTouchEvents : ms(t2) < this.cf + 500;
  }
  xf(t2, i) {
    i && i.call(this.kf, t2);
  }
  Cf(t2, i) {
    i && i.call(this.kf, t2);
  }
  wf(t2, i) {
    const n2 = i || t2, s = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    return { clientX: n2.clientX, clientY: n2.clientY, pageX: n2.pageX, pageY: n2.pageY, screenX: n2.screenX, screenY: n2.screenY, localX: n2.clientX - s.left, localY: n2.clientY - s.top, ctrlKey: t2.ctrlKey, altKey: t2.altKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, uv: !t2.type.startsWith("mouse") && "contextmenu" !== t2.type && "click" !== t2.type, cv: t2.type, dv: n2.target, fv: t2.view, vv: () => {
      "touchstart" !== t2.type && vs(t2);
    } };
  }
}
function fs(t2, i) {
  const n2 = t2.clientX - i.clientX, s = t2.clientY - i.clientY;
  return Math.sqrt(n2 * n2 + s * s);
}
function vs(t2) {
  t2.cancelable && t2.preventDefault();
}
function ps(t2) {
  return { et: t2.pageX, rt: t2.pageY };
}
function ms(t2) {
  return t2.timeStamp || performance.now();
}
function bs(t2, i) {
  for (let n2 = 0; n2 < t2.length; ++n2)
    if (t2[n2].identifier === i)
      return t2[n2];
  return null;
}
function ws(t2) {
  return { Ic: t2.Ic, pv: { wr: t2.mv.externalId }, bv: t2.mv.cursorStyle };
}
function gs(t2, i, n2) {
  for (const s of t2) {
    const t3 = s.xt();
    if (null !== t3 && t3.br) {
      const e3 = t3.br(i, n2);
      if (null !== e3)
        return { fv: s, pv: e3 };
    }
  }
  return null;
}
function Ms(t2, i) {
  return (n2) => {
    var s, e3, r2, h2;
    return (null !== (e3 = null === (s = n2.At()) || void 0 === s ? void 0 : s.xa()) && void 0 !== e3 ? e3 : "") !== i ? [] : null !== (h2 = null === (r2 = n2.la) || void 0 === r2 ? void 0 : r2.call(n2, t2)) && void 0 !== h2 ? h2 : [];
  };
}
class xs {
  constructor(i, n2, s, e3) {
    this.Li = null, this.wv = null, this.gv = false, this.Mv = new si(200), this.Gr = null, this.xv = 0, this.Sv = false, this.kv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.nn = i, this.cn = n2, this.mo = n2.layout, this.kc = s, this.Tv = "left" === e3, this.Pv = Ms("normal", e3), this.Rv = Ms("top", e3), this.Dv = Ms("bottom", e3), this.Ov = document.createElement("div"), this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Ov.style.width = "25px", this.Ov.style.left = "0", this.Ov.style.position = "relative", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const r2 = this.Av.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "1", r2.style.left = "0", r2.style.top = "0", this.Vv = as(this.Ov, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const h2 = this.Vv.canvasElement;
    h2.style.position = "absolute", h2.style.zIndex = "2", h2.style.left = "0", h2.style.top = "0";
    const l2 = { Qf: this.Bv.bind(this), Gf: this.Bv.bind(this), Hf: this.Iv.bind(this), Wf: this.Iv.bind(this), tv: this.zv.bind(this), Yf: this.Ev.bind(this), Uf: this.Ev.bind(this), Tf: this.Lv.bind(this), Sf: this.Lv.bind(this), Bf: this.Nv.bind(this), ov: this.Fv.bind(this) };
    this.Wv = new ds(this.Vv.canvasElement, l2, { Nf: () => !this.cn.handleScroll.vertTouchDrag, Ff: () => true });
  }
  S() {
    this.Wv.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), null !== this.Li && this.Li.$o().p(this), this.Li = null;
  }
  jv() {
    return this.Ov;
  }
  P() {
    return this.mo.fontSize;
  }
  Hv() {
    const t2 = this.kc.W();
    return this.Gr !== t2.R && (this.Mv.ir(), this.Gr = t2.R), t2;
  }
  $v() {
    if (null === this.Li)
      return 0;
    let t2 = 0;
    const i = this.Hv(), n2 = b(this.Av.canvasElement.getContext("2d"));
    n2.save();
    const s = this.Li.Ea();
    n2.font = this.Uv(), s.length > 0 && (t2 = Math.max(this.Mv.Si(n2, s[0].Za), this.Mv.Si(n2, s[s.length - 1].Za)));
    const e3 = this.qv();
    for (let i2 = e3.length; i2--; ) {
      const s2 = this.Mv.Si(n2, e3[i2].Jt());
      s2 > t2 && (t2 = s2);
    }
    const r2 = this.Li.Pt();
    if (null !== r2 && null !== this.wv) {
      const i2 = this.Li.pn(1, r2), s2 = this.Li.pn(this.wv.height - 2, r2);
      t2 = Math.max(t2, this.Mv.Si(n2, this.Li.Wi(Math.floor(Math.min(i2, s2)) + 0.11111111111111, r2)), this.Mv.Si(n2, this.Li.Wi(Math.ceil(Math.max(i2, s2)) - 0.11111111111111, r2)));
    }
    n2.restore();
    const h2 = t2 || 34;
    return es(Math.ceil(i.C + i.T + i.B + i.I + 5 + h2));
  }
  Yv(t2) {
    null !== this.wv && equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = true, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = false, this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`);
  }
  Xv() {
    return b(this.wv).width;
  }
  Ji(t2) {
    this.Li !== t2 && (null !== this.Li && this.Li.$o().p(this), this.Li = t2, t2.$o().l(this.ao.bind(this), this));
  }
  At() {
    return this.Li;
  }
  ir() {
    const t2 = this.nn.Kv();
    this.nn.yv().qt().A_(t2, b(this.At()));
  }
  Zv(t2) {
    if (null === this.wv)
      return;
    if (1 !== t2) {
      this.Gv(), this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4), this.Be(t4);
      }), this.nn.Qv(t3, this.Dv), this.tp(t3), this.nn.Qv(t3, this.Pv), this.ip(t3));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.np(i), this.nn.Qv(i, this.Rv));
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  gt() {
    var t2;
    null === (t2 = this.Li) || void 0 === t2 || t2.Ea();
  }
  Bv(t2) {
    if (null === this.Li || this.Li.Fi() || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = true, i.y_(n2, this.Li, t2.localY);
  }
  Iv(t2) {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv(), s = this.Li;
    i.C_(n2, s, t2.localY);
  }
  zv() {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const t2 = this.nn.yv().qt(), i = this.nn.Kv(), n2 = this.Li;
    this.gv && (this.gv = false, t2.T_(i, n2));
  }
  Ev(t2) {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = false, i.T_(n2, this.Li);
  }
  Lv(t2) {
    this.cn.handleScale.axisDoubleClickReset.price && this.ir();
  }
  Nv(t2) {
    if (null === this.Li)
      return;
    !this.nn.yv().qt().W().handleScale.axisPressedMouseMove.price || this.Li.ph() || this.Li.Co() || this.rp(1);
  }
  Fv(t2) {
    this.rp(0);
  }
  qv() {
    const t2 = [], i = null === this.Li ? void 0 : this.Li;
    return ((n2) => {
      for (let s = 0; s < n2.length; ++s) {
        const e3 = n2[s].Rn(this.nn.Kv(), i);
        for (let i2 = 0; i2 < e3.length; i2++)
          t2.push(e3[i2]);
      }
    })(this.nn.Kv().No()), t2;
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e3 = this.nn.Kv().qt(), r2 = e3.q(), h2 = e3.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, r2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2 }) {
    if (null === this.wv || null === this.Li || !this.Li.W().borderVisible)
      return;
    t2.fillStyle = this.Li.W().borderColor;
    const s = Math.max(1, Math.floor(this.Hv().C * n2));
    let e3;
    e3 = this.Tv ? i.width - s : 0, t2.fillRect(e3, 0, s, i.height);
  }
  tp(t2) {
    if (null === this.wv || null === this.Li)
      return;
    const i = this.Li.Ea(), n2 = this.Li.W(), s = this.Hv(), e3 = this.Tv ? this.wv.width - s.T : 0;
    n2.borderVisible && n2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: r2, verticalPixelRatio: h2 }) => {
      t3.fillStyle = n2.borderColor;
      const l2 = Math.max(1, Math.floor(h2)), a2 = Math.floor(0.5 * h2), o2 = Math.round(s.T * r2);
      t3.beginPath();
      for (const n3 of i)
        t3.rect(Math.floor(e3 * r2), Math.round(n3.Aa * h2) - a2, o2, l2);
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      var r2;
      t3.font = this.Uv(), t3.fillStyle = null !== (r2 = n2.textColor) && void 0 !== r2 ? r2 : this.mo.textColor, t3.textAlign = this.Tv ? "right" : "left", t3.textBaseline = "middle";
      const h2 = this.Tv ? Math.round(e3 - s.B) : Math.round(e3 + s.T + s.B), l2 = i.map((i2) => this.Mv.xi(t3, i2.Za));
      for (let n3 = i.length; n3--; ) {
        const s2 = i[n3];
        t3.fillText(s2.Za, h2, s2.Aa + l2[n3]);
      }
    });
  }
  Gv() {
    if (null === this.wv || null === this.Li)
      return;
    let t2 = this.wv.height / 2;
    const i = [], n2 = this.Li.No().slice(), s = this.nn.Kv(), e3 = this.Hv();
    this.Li === s.vr() && this.nn.Kv().No().forEach((t3) => {
      s.dr(t3) && n2.push(t3);
    });
    const r2 = this.Li.Ta()[0], h2 = this.Li;
    n2.forEach((n3) => {
      const e4 = n3.Rn(s, h2);
      e4.forEach((t3) => {
        t3.Vi(null), t3.Bi() && i.push(t3);
      }), r2 === n3 && e4.length > 0 && (t2 = e4[0].yi());
    }), i.forEach((t3) => t3.Vi(t3.yi()));
    this.Li.W().alignLabels && this.hp(i, e3, t2);
  }
  hp(t2, i, n2) {
    if (null === this.wv)
      return;
    const s = t2.filter((t3) => t3.yi() <= n2), e3 = t2.filter((t3) => t3.yi() > n2);
    s.sort((t3, i2) => i2.yi() - t3.yi()), s.length && e3.length && e3.push(s[0]), e3.sort((t3, i2) => t3.yi() - i2.yi());
    for (const n3 of t2) {
      const t3 = Math.floor(n3.zt(i) / 2), s2 = n3.yi();
      s2 > -t3 && s2 < t3 && n3.Vi(t3), s2 > this.wv.height - t3 && s2 < this.wv.height + t3 && n3.Vi(this.wv.height - t3);
    }
    for (let t3 = 1; t3 < s.length; t3++) {
      const n3 = s[t3], e4 = s[t3 - 1], r2 = e4.zt(i, false), h2 = n3.yi(), l2 = e4.Ai();
      h2 > l2 - r2 && n3.Vi(l2 - r2);
    }
    for (let t3 = 1; t3 < e3.length; t3++) {
      const n3 = e3[t3], s2 = e3[t3 - 1], r2 = s2.zt(i, true), h2 = n3.yi(), l2 = s2.Ai();
      h2 < l2 + r2 && n3.Vi(l2 + r2);
    }
  }
  ip(t2) {
    if (null === this.wv)
      return;
    const i = this.qv(), n2 = this.Hv(), s = this.Tv ? "right" : "left";
    i.forEach((i2) => {
      if (i2.Ii()) {
        i2.xt(b(this.Li)).K(t2, n2, this.Mv, s);
      }
    });
  }
  np(t2) {
    if (null === this.wv || null === this.Li)
      return;
    const i = this.nn.yv().qt(), n2 = [], s = this.nn.Kv(), e3 = i.Fc().Rn(s, this.Li);
    e3.length && n2.push(e3);
    const r2 = this.Hv(), h2 = this.Tv ? "right" : "left";
    n2.forEach((i2) => {
      i2.forEach((i3) => {
        i3.xt(b(this.Li)).K(t2, r2, this.Mv, h2);
      });
    });
  }
  rp(t2) {
    this.Ov.style.cursor = 1 === t2 ? "ns-resize" : "default";
  }
  ao() {
    const t2 = this.$v();
    this.xv < t2 && this.nn.yv().qt().$l(), this.xv = t2;
  }
  Uv() {
    return N$1(this.mo.fontSize, this.mo.fontFamily);
  }
}
function Ss(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.ra) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function ks(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.Pn) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function ys(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.Qi) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function Cs(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.na) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
class Ts {
  constructor(i, n2) {
    this.wv = size({ width: 0, height: 0 }), this.lp = null, this.ap = null, this.op = null, this._p = false, this.up = new R(), this.cp = new R(), this.dp = 0, this.fp = false, this.vp = null, this.pp = false, this.mp = null, this.bp = null, this.Sv = false, this.kv = () => {
      this.Sv || null === this.wp || this.Ui().Fh();
    }, this.Cv = () => {
      this.Sv || null === this.wp || this.Ui().Fh();
    }, this.gp = i, this.wp = n2, this.wp.I_().l(this.Mp.bind(this), this, true), this.xp = document.createElement("td"), this.xp.style.padding = "0", this.xp.style.position = "relative";
    const s = document.createElement("div");
    s.style.width = "100%", s.style.height = "100%", s.style.position = "relative", s.style.overflow = "hidden", this.Sp = document.createElement("td"), this.Sp.style.padding = "0", this.kp = document.createElement("td"), this.kp.style.padding = "0", this.xp.appendChild(s), this.Av = as(s, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const e3 = this.Av.canvasElement;
    e3.style.position = "absolute", e3.style.zIndex = "1", e3.style.left = "0", e3.style.top = "0", this.Vv = as(s, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const r2 = this.Vv.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0", this.yp = document.createElement("tr"), this.yp.appendChild(this.Sp), this.yp.appendChild(this.xp), this.yp.appendChild(this.kp), this.Cp(), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => null === this.vp && !this.gp.W().handleScroll.vertTouchDrag, Ff: () => null === this.vp && !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    null !== this.lp && this.lp.S(), null !== this.ap && this.ap.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), null !== this.wp && this.wp.I_().p(this), this.Wv.S();
  }
  Kv() {
    return b(this.wp);
  }
  Tp(t2) {
    null !== this.wp && this.wp.I_().p(this), this.wp = t2, null !== this.wp && this.wp.I_().l(Ts.prototype.Mp.bind(this), this, true), this.Cp();
  }
  yv() {
    return this.gp;
  }
  jv() {
    return this.yp;
  }
  Cp() {
    if (null !== this.wp && (this.Pp(), 0 !== this.Ui().Mt().length)) {
      if (null !== this.lp) {
        const t2 = this.wp.S_();
        this.lp.Ji(b(t2));
      }
      if (null !== this.ap) {
        const t2 = this.wp.k_();
        this.ap.Ji(b(t2));
      }
    }
  }
  Rp() {
    null !== this.lp && this.lp.gt(), null !== this.ap && this.ap.gt();
  }
  v_() {
    return null !== this.wp ? this.wp.v_() : 0;
  }
  p_(t2) {
    this.wp && this.wp.p_(t2);
  }
  Bf(t2) {
    if (!this.wp)
      return;
    this.Dp();
    const i = t2.localX, n2 = t2.localY;
    this.Op(i, n2, t2);
  }
  Qf(t2) {
    this.Dp(), this.Ap(), this.Op(t2.localX, t2.localY, t2);
  }
  If(t2) {
    var i;
    if (!this.wp)
      return;
    this.Dp();
    const n2 = t2.localX, s = t2.localY;
    this.Op(n2, s, t2);
    const e3 = this.br(n2, s);
    this.gp.Vp(null !== (i = null == e3 ? void 0 : e3.bv) && void 0 !== i ? i : null), this.Ui().Bc(e3 && { Ic: e3.Ic, pv: e3.pv });
  }
  Xf(t2) {
    null !== this.wp && (this.Dp(), this.Bp(t2));
  }
  Tf(t2) {
    null !== this.wp && this.Ip(this.cp, t2);
  }
  Sf(t2) {
    this.Tf(t2);
  }
  Hf(t2) {
    this.Dp(), this.zp(t2), this.Op(t2.localX, t2.localY, t2);
  }
  Yf(t2) {
    null !== this.wp && (this.Dp(), this.fp = false, this.Ep(t2));
  }
  qf(t2) {
    null !== this.wp && this.Bp(t2);
  }
  _v(t2) {
    if (this.fp = true, null === this.vp) {
      const i = { x: t2.localX, y: t2.localY };
      this.Lp(i, i, t2);
    }
  }
  ov(t2) {
    null !== this.wp && (this.Dp(), this.wp.qt().Bc(null), this.Np());
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  sv() {
    this.dp = 1, this.Ui().Un();
  }
  ev(t2, i) {
    if (!this.gp.W().handleScale.pinch)
      return;
    const n2 = 5 * (i - this.dp);
    this.dp = i, this.Ui().Uc(t2.et, n2);
  }
  Gf(t2) {
    this.fp = false, this.pp = null !== this.vp, this.Ap();
    const i = this.Ui().Fc();
    null !== this.vp && i.Tt() && (this.mp = { x: i.Kt(), y: i.Zt() }, this.vp = { x: t2.localX, y: t2.localY });
  }
  Wf(t2) {
    if (null === this.wp)
      return;
    const i = t2.localX, n2 = t2.localY;
    if (null === this.vp)
      this.zp(t2);
    else {
      this.pp = false;
      const s = b(this.mp), e3 = s.x + (i - this.vp.x), r2 = s.y + (n2 - this.vp.y);
      this.Op(e3, r2, t2);
    }
  }
  Uf(t2) {
    0 === this.yv().W().trackingMode.exitMode && (this.pp = true), this.jp(), this.Ep(t2);
  }
  br(t2, i) {
    const n2 = this.wp;
    return null === n2 ? null : function(t3, i2, n3) {
      const s = t3.No(), e3 = function(t4, i3, n4) {
        var s2, e4;
        let r2, h2;
        for (const o2 of t4) {
          const t5 = null !== (e4 = null === (s2 = o2.oa) || void 0 === s2 ? void 0 : s2.call(o2, i3, n4)) && void 0 !== e4 ? e4 : [];
          for (const i4 of t5)
            l2 = i4.zOrder, (!(a2 = null == r2 ? void 0 : r2.zOrder) || "top" === l2 && "top" !== a2 || "normal" === l2 && "bottom" === a2) && (r2 = i4, h2 = o2);
        }
        var l2, a2;
        return r2 && h2 ? { mv: r2, Ic: h2 } : null;
      }(s, i2, n3);
      if ("top" === (null == e3 ? void 0 : e3.mv.zOrder))
        return ws(e3);
      for (const r2 of s) {
        if (e3 && e3.Ic === r2 && "bottom" !== e3.mv.zOrder && !e3.mv.isBackground)
          return ws(e3);
        const s2 = gs(r2.Pn(t3), i2, n3);
        if (null !== s2)
          return { Ic: r2, fv: s2.fv, pv: s2.pv };
        if (e3 && e3.Ic === r2 && "bottom" !== e3.mv.zOrder && e3.mv.isBackground)
          return ws(e3);
      }
      return (null == e3 ? void 0 : e3.mv) ? ws(e3) : null;
    }(n2, t2, i);
  }
  Hp(i, n2) {
    b("left" === n2 ? this.lp : this.ap).Yv(size({ width: i, height: this.wv.height }));
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = true, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = false, this.xp.style.width = t2.width + "px", this.xp.style.height = t2.height + "px");
  }
  Up() {
    const t2 = b(this.wp);
    t2.x_(t2.S_()), t2.x_(t2.k_());
    for (const i of t2.Ta())
      if (t2.dr(i)) {
        const n2 = i.At();
        null !== n2 && t2.x_(n2), i.On();
      }
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (0 === t2)
      return;
    if (null === this.wp)
      return;
    if (t2 > 1 && this.Up(), null !== this.lp && this.lp.Zv(t2), null !== this.ap && this.ap.Zv(t2), 1 !== t2) {
      this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4);
      }), this.wp && (this.qp(t3, Ss), this.Yp(t3), this.Xp(t3), this.qp(t3, ks), this.qp(t3, ys)));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Kp(i), this.qp(i, Cs));
  }
  Zp() {
    return this.lp;
  }
  Gp() {
    return this.ap;
  }
  Qv(t2, i) {
    this.qp(t2, i);
  }
  Mp() {
    null !== this.wp && this.wp.I_().p(this), this.wp = null;
  }
  Bp(t2) {
    this.Ip(this.up, t2);
  }
  Ip(t2, i) {
    const n2 = i.localX, s = i.localY;
    t2.M() && t2.m(this.Ui().yt().Vu(n2), { x: n2, y: s }, i);
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e3 = this.Ui(), r2 = e3.q(), h2 = e3.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, h2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Yp(t2) {
    const i = b(this.wp).z_().Wh().xt();
    null !== i && i.K(t2, false);
  }
  Xp(t2) {
    const i = this.Ui().Nc();
    this.Jp(t2, ks, os, i), this.Jp(t2, ks, _s, i);
  }
  Kp(t2) {
    this.Jp(t2, ks, _s, this.Ui().Fc());
  }
  qp(t2, i) {
    const n2 = b(this.wp).No();
    for (const s of n2)
      this.Jp(t2, i, os, s);
    for (const s of n2)
      this.Jp(t2, i, _s, s);
  }
  Jp(t2, i, n2, s) {
    const e3 = b(this.wp), r2 = e3.qt().Vc(), h2 = null !== r2 && r2.Ic === s, l2 = null !== r2 && h2 && void 0 !== r2.pv ? r2.pv.gr : void 0;
    us(i, (i2) => n2(i2, t2, h2, l2), s, e3);
  }
  Pp() {
    if (null === this.wp)
      return;
    const t2 = this.gp, i = this.wp.S_().W().visible, n2 = this.wp.k_().W().visible;
    i || null === this.lp || (this.Sp.removeChild(this.lp.jv()), this.lp.S(), this.lp = null), n2 || null === this.ap || (this.kp.removeChild(this.ap.jv()), this.ap.S(), this.ap = null);
    const s = t2.qt().sd();
    i && null === this.lp && (this.lp = new xs(this, t2.W(), s, "left"), this.Sp.appendChild(this.lp.jv())), n2 && null === this.ap && (this.ap = new xs(this, t2.W(), s, "right"), this.kp.appendChild(this.ap.jv()));
  }
  Qp(t2) {
    return t2.uv && this.fp || null !== this.vp;
  }
  tm(t2) {
    return Math.max(0, Math.min(t2, this.wv.width - 1));
  }
  im(t2) {
    return Math.max(0, Math.min(t2, this.wv.height - 1));
  }
  Op(t2, i, n2) {
    this.Ui().Jc(this.tm(t2), this.im(i), n2, b(this.wp));
  }
  Np() {
    this.Ui().td();
  }
  jp() {
    this.pp && (this.vp = null, this.Np());
  }
  Lp(t2, i, n2) {
    this.vp = t2, this.pp = false, this.Op(i.x, i.y, n2);
    const s = this.Ui().Fc();
    this.mp = { x: s.Kt(), y: s.Zt() };
  }
  Ui() {
    return this.gp.qt();
  }
  Ep(t2) {
    if (!this._p)
      return;
    const i = this.Ui(), n2 = this.Kv();
    if (i.D_(n2, n2.vn()), this.op = null, this._p = false, i.Kc(), null !== this.bp) {
      const t3 = performance.now(), n3 = i.yt();
      this.bp.Dr(n3.Eu(), t3), this.bp.Yu(t3) || i.Xn(this.bp);
    }
  }
  Dp() {
    this.vp = null;
  }
  Ap() {
    if (!this.wp)
      return;
    if (this.Ui().Un(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
      b(document.activeElement).blur();
    else {
      const t2 = document.getSelection();
      null !== t2 && t2.removeAllRanges();
    }
    !this.wp.vn().Fi() && this.Ui().yt().Fi();
  }
  zp(t2) {
    if (null === this.wp)
      return;
    const i = this.Ui(), n2 = i.yt();
    if (n2.Fi())
      return;
    const s = this.gp.W(), e3 = s.handleScroll, r2 = s.kineticScroll;
    if ((!e3.pressedMouseMove || t2.uv) && (!e3.horzTouchDrag && !e3.vertTouchDrag || !t2.uv))
      return;
    const h2 = this.wp.vn(), l2 = performance.now();
    if (null !== this.op || this.Qp(t2) || (this.op = { x: t2.clientX, y: t2.clientY, kd: l2, nm: t2.localX, sm: t2.localY }), null !== this.op && !this._p && (this.op.x !== t2.clientX || this.op.y !== t2.clientY)) {
      if (t2.uv && r2.touch || !t2.uv && r2.mouse) {
        const t3 = n2.he();
        this.bp = new ls(0.2 / t3, 7 / t3, 0.997, 15 / t3), this.bp.Nd(n2.Eu(), this.op.kd);
      } else
        this.bp = null;
      h2.Fi() || i.P_(this.wp, h2, t2.localY), i.Yc(t2.localX), this._p = true;
    }
    this._p && (h2.Fi() || i.R_(this.wp, h2, t2.localY), i.Xc(t2.localX), null !== this.bp && this.bp.Nd(n2.Eu(), l2));
  }
}
class Ps {
  constructor(i, n2, s, e3, r2) {
    this.bt = true, this.wv = size({ width: 0, height: 0 }), this.kv = () => this.Zv(3), this.Tv = "left" === i, this.kc = s.sd, this.cn = n2, this.rm = e3, this.hm = r2, this.Ov = document.createElement("div"), this.Ov.style.width = "25px", this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
  }
  S() {
    this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.Ov;
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Av.resizeCanvasElement(t2), this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`, this.bt = true);
  }
  Zv(t2) {
    if (t2 < 3 && !this.bt)
      return;
    if (0 === this.wv.width || 0 === this.wv.height)
      return;
    this.bt = false, this.Av.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Av);
    null !== i && i.useBitmapCoordinateSpace((t3) => {
      this.Jv(t3), this.Be(t3);
    });
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (!this.rm())
      return;
    t2.fillStyle = this.cn.timeScale.borderColor;
    const e3 = Math.floor(this.kc.W().C * n2), r2 = Math.floor(this.kc.W().C * s), h2 = this.Tv ? i.width - e3 : 0;
    t2.fillRect(h2, 0, e3, r2);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.hm());
  }
}
function Rs(t2) {
  return (i) => {
    var n2, s;
    return null !== (s = null === (n2 = i.aa) || void 0 === n2 ? void 0 : n2.call(i, t2)) && void 0 !== s ? s : [];
  };
}
const Ds = Rs("normal"), Os = Rs("top"), As = Rs("bottom");
class Vs {
  constructor(i, n2) {
    this.lm = null, this.am = null, this.k = null, this.om = false, this.wv = size({ width: 0, height: 0 }), this._m = new R(), this.Mv = new si(5), this.Sv = false, this.kv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.gp = i, this.N_ = n2, this.cn = i.W().layout, this.um = document.createElement("tr"), this.dm = document.createElement("td"), this.dm.style.padding = "0", this.fm = document.createElement("td"), this.fm.style.padding = "0", this.Ov = document.createElement("td"), this.Ov.style.height = "25px", this.Ov.style.padding = "0", this.vm = document.createElement("div"), this.vm.style.width = "100%", this.vm.style.height = "100%", this.vm.style.position = "relative", this.vm.style.overflow = "hidden", this.Ov.appendChild(this.vm), this.Av = as(this.vm, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const s = this.Av.canvasElement;
    s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Vv = as(this.vm, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const e3 = this.Vv.canvasElement;
    e3.style.position = "absolute", e3.style.zIndex = "2", e3.style.left = "0", e3.style.top = "0", this.um.appendChild(this.dm), this.um.appendChild(this.Ov), this.um.appendChild(this.fm), this.pm(), this.gp.qt().f_().l(this.pm.bind(this), this), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => true, Ff: () => !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.Wv.S(), null !== this.lm && this.lm.S(), null !== this.am && this.am.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.um;
  }
  bm() {
    return this.lm;
  }
  wm() {
    return this.am;
  }
  Qf(t2) {
    if (this.om)
      return;
    this.om = true;
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.$c(t2.localX);
  }
  Gf(t2) {
    this.Qf(t2);
  }
  tv() {
    const t2 = this.gp.qt();
    !t2.yt().Fi() && this.om && (this.om = false, this.gp.W().handleScale.axisPressedMouseMove.time && t2.Gc());
  }
  Hf(t2) {
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.Zc(t2.localX);
  }
  Wf(t2) {
    this.Hf(t2);
  }
  Yf() {
    this.om = false;
    const t2 = this.gp.qt();
    t2.yt().Fi() && !this.gp.W().handleScale.axisPressedMouseMove.time || t2.Gc();
  }
  Uf() {
    this.Yf();
  }
  Tf() {
    this.gp.W().handleScale.axisDoubleClickReset.time && this.gp.qt().Zn();
  }
  Sf() {
    this.Tf();
  }
  Bf() {
    this.gp.qt().W().handleScale.axisPressedMouseMove.time && this.rp(1);
  }
  ov() {
    this.rp(0);
  }
  $p() {
    return this.wv;
  }
  gm() {
    return this._m;
  }
  Mm(i, s, e3) {
    equalSizes(this.wv, i) || (this.wv = i, this.Sv = true, this.Av.resizeCanvasElement(i), this.Vv.resizeCanvasElement(i), this.Sv = false, this.Ov.style.width = `${i.width}px`, this.Ov.style.height = `${i.height}px`, this._m.m(i)), null !== this.lm && this.lm.Yv(size({ width: s, height: i.height })), null !== this.am && this.am.Yv(size({ width: e3, height: i.height }));
  }
  xm() {
    const t2 = this.Sm();
    return Math.ceil(t2.C + t2.T + t2.P + t2.L + t2.V + t2.km);
  }
  gt() {
    this.gp.qt().yt().Ea();
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (0 === t2)
      return;
    if (1 !== t2) {
      this.Av.applySuggestedBitmapSize();
      const i2 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== i2 && (i2.useBitmapCoordinateSpace((t3) => {
        this.Jv(t3), this.Be(t3), this.ym(i2, As);
      }), this.tp(i2), this.ym(i2, Ds)), null !== this.lm && this.lm.Zv(t2), null !== this.am && this.am.Zv(t2);
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Cm([...this.gp.qt().Mt(), this.gp.qt().Fc()], i), this.ym(i, Os));
  }
  ym(t2, i) {
    const n2 = this.gp.qt().Mt();
    for (const s of n2)
      us(i, (i2) => os(i2, t2, false, void 0), s, void 0);
    for (const s of n2)
      us(i, (i2) => _s(i2, t2, false, void 0), s, void 0);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.gp.qt().od());
  }
  Be({ context: t2, bitmapSize: i, verticalPixelRatio: n2 }) {
    if (this.gp.W().timeScale.borderVisible) {
      t2.fillStyle = this.Tm();
      const s = Math.max(1, Math.floor(this.Sm().C * n2));
      t2.fillRect(0, 0, i.width, s);
    }
  }
  tp(t2) {
    const i = this.gp.qt().yt(), n2 = i.Ea();
    if (!n2 || 0 === n2.length)
      return;
    const s = this.N_.maxTickMarkWeight(n2), e3 = this.Sm(), r2 = i.W();
    r2.borderVisible && r2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) => {
      t3.strokeStyle = this.Tm(), t3.fillStyle = this.Tm();
      const r3 = Math.max(1, Math.floor(i2)), h2 = Math.floor(0.5 * i2);
      t3.beginPath();
      const l2 = Math.round(e3.T * s2);
      for (let s3 = n2.length; s3--; ) {
        const e4 = Math.round(n2[s3].coord * i2);
        t3.rect(e4 - h2, 0, r3, l2);
      }
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const i2 = e3.C + e3.T + e3.L + e3.P / 2;
      t3.textAlign = "center", t3.textBaseline = "middle", t3.fillStyle = this.$(), t3.font = this.Uv();
      for (const e4 of n2)
        if (e4.weight < s) {
          const n3 = e4.needAlignCoordinate ? this.Pm(t3, e4.coord, e4.label) : e4.coord;
          t3.fillText(e4.label, n3, i2);
        }
      t3.font = this.Rm();
      for (const e4 of n2)
        if (e4.weight >= s) {
          const n3 = e4.needAlignCoordinate ? this.Pm(t3, e4.coord, e4.label) : e4.coord;
          t3.fillText(e4.label, n3, i2);
        }
    });
  }
  Pm(t2, i, n2) {
    const s = this.Mv.Si(t2, n2), e3 = s / 2, r2 = Math.floor(i - e3) + 0.5;
    return r2 < 0 ? i += Math.abs(0 - r2) : r2 + s > this.wv.width && (i -= Math.abs(this.wv.width - (r2 + s))), i;
  }
  Cm(t2, i) {
    const n2 = this.Sm();
    for (const s of t2)
      for (const t3 of s.tn())
        t3.xt().K(i, n2);
  }
  Tm() {
    return this.gp.W().timeScale.borderColor;
  }
  $() {
    return this.cn.textColor;
  }
  j() {
    return this.cn.fontSize;
  }
  Uv() {
    return N$1(this.j(), this.cn.fontFamily);
  }
  Rm() {
    return N$1(this.j(), this.cn.fontFamily, "bold");
  }
  Sm() {
    null === this.k && (this.k = { C: 1, N: NaN, L: NaN, V: NaN, Hi: NaN, T: 5, P: NaN, R: "", ji: new si(), km: 0 });
    const t2 = this.k, i = this.Uv();
    if (t2.R !== i) {
      const n2 = this.j();
      t2.P = n2, t2.R = i, t2.L = 3 * n2 / 12, t2.V = 3 * n2 / 12, t2.Hi = 9 * n2 / 12, t2.N = 0, t2.km = 4 * n2 / 12, t2.ji.ir();
    }
    return this.k;
  }
  rp(t2) {
    this.Ov.style.cursor = 1 === t2 ? "ew-resize" : "default";
  }
  pm() {
    const t2 = this.gp.qt(), i = t2.W();
    i.leftPriceScale.visible || null === this.lm || (this.dm.removeChild(this.lm.jv()), this.lm.S(), this.lm = null), i.rightPriceScale.visible || null === this.am || (this.fm.removeChild(this.am.jv()), this.am.S(), this.am = null);
    const n2 = { sd: this.gp.qt().sd() }, s = () => i.leftPriceScale.borderVisible && t2.yt().W().borderVisible, e3 = () => t2.od();
    i.leftPriceScale.visible && null === this.lm && (this.lm = new Ps("left", i, n2, s, e3), this.dm.appendChild(this.lm.jv())), i.rightPriceScale.visible && null === this.am && (this.am = new Ps("right", i, n2, s, e3), this.fm.appendChild(this.am.jv()));
  }
}
const Bs = !!is && !!navigator.userAgentData && navigator.userAgentData.brands.some((t2) => t2.brand.includes("Chromium")) && !!is && ((null === (Is = null === navigator || void 0 === navigator ? void 0 : navigator.userAgentData) || void 0 === Is ? void 0 : Is.platform) ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
var Is;
class zs {
  constructor(t2, i, n2) {
    var s;
    this.Dm = [], this.Om = 0, this.Qa = 0, this.e_ = 0, this.Am = 0, this.Vm = 0, this.Bm = null, this.Im = false, this.up = new R(), this.cp = new R(), this.Mc = new R(), this.zm = null, this.Em = null, this.Lm = t2, this.cn = i, this.N_ = n2, this.um = document.createElement("div"), this.um.classList.add("tv-lightweight-charts"), this.um.style.overflow = "hidden", this.um.style.direction = "ltr", this.um.style.width = "100%", this.um.style.height = "100%", (s = this.um).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.Nm = document.createElement("table"), this.Nm.setAttribute("cellspacing", "0"), this.um.appendChild(this.Nm), this.Fm = this.Wm.bind(this), Es(this.cn) && this.jm(true), this.Ui = new zn(this.Sc.bind(this), this.cn, n2), this.qt().Wc().l(this.Hm.bind(this), this), this.$m = new Vs(this, this.N_), this.Nm.appendChild(this.$m.jv());
    const e3 = i.autoSize && this.Um();
    let r2 = this.cn.width, h2 = this.cn.height;
    if (e3 || 0 === r2 || 0 === h2) {
      const i2 = t2.getBoundingClientRect();
      r2 = r2 || i2.width, h2 = h2 || i2.height;
    }
    this.qm(r2, h2), this.Ym(), t2.appendChild(this.um), this.Xm(), this.Ui.yt().Gu().l(this.Ui.$l.bind(this.Ui), this), this.Ui.f_().l(this.Ui.$l.bind(this.Ui), this);
  }
  qt() {
    return this.Ui;
  }
  W() {
    return this.cn;
  }
  Km() {
    return this.Dm;
  }
  Zm() {
    return this.$m;
  }
  S() {
    this.jm(false), 0 !== this.Om && window.cancelAnimationFrame(this.Om), this.Ui.Wc().p(this), this.Ui.yt().Gu().p(this), this.Ui.f_().p(this), this.Ui.S();
    for (const t2 of this.Dm)
      this.Nm.removeChild(t2.jv()), t2.Fp().p(this), t2.Wp().p(this), t2.S();
    this.Dm = [], b(this.$m).S(), null !== this.um.parentElement && this.um.parentElement.removeChild(this.um), this.Mc.S(), this.up.S(), this.cp.S(), this.Gm();
  }
  qm(i, n2, s = false) {
    if (this.Qa === n2 && this.e_ === i)
      return;
    const e3 = function(i2) {
      const n3 = Math.floor(i2.width), s2 = Math.floor(i2.height);
      return size({ width: n3 - n3 % 2, height: s2 - s2 % 2 });
    }(size({ width: i, height: n2 }));
    this.Qa = e3.height, this.e_ = e3.width;
    const r2 = this.Qa + "px", h2 = this.e_ + "px";
    b(this.um).style.height = r2, b(this.um).style.width = h2, this.Nm.style.height = r2, this.Nm.style.width = h2, s ? this.Jm(ct.es(), performance.now()) : this.Ui.$l();
  }
  Zv(t2) {
    void 0 === t2 && (t2 = ct.es());
    for (let i = 0; i < this.Dm.length; i++)
      this.Dm[i].Zv(t2.Hn(i).Fn);
    this.cn.timeScale.visible && this.$m.Zv(t2.jn());
  }
  Nh(t2) {
    const i = Es(this.cn);
    this.Ui.Nh(t2);
    const n2 = Es(this.cn);
    n2 !== i && this.jm(n2), this.Xm(), this.Qm(t2);
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  Wc() {
    return this.Mc;
  }
  tb() {
    null !== this.Bm && (this.Jm(this.Bm, performance.now()), this.Bm = null);
    const t2 = this.ib(null), i = document.createElement("canvas");
    i.width = t2.width, i.height = t2.height;
    const n2 = b(i.getContext("2d"));
    return this.ib(n2), i;
  }
  nb(t2) {
    if ("left" === t2 && !this.sb())
      return 0;
    if ("right" === t2 && !this.eb())
      return 0;
    if (0 === this.Dm.length)
      return 0;
    return b("left" === t2 ? this.Dm[0].Zp() : this.Dm[0].Gp()).Xv();
  }
  rb() {
    return this.cn.autoSize && null !== this.zm;
  }
  hb() {
    return this.um;
  }
  Vp(t2) {
    this.Em = t2, this.Em ? this.hb().style.setProperty("cursor", t2) : this.hb().style.removeProperty("cursor");
  }
  lb() {
    return this.Em;
  }
  ab() {
    return m$1(this.Dm[0]).$p();
  }
  Qm(t2) {
    (void 0 !== t2.autoSize || !this.zm || void 0 === t2.width && void 0 === t2.height) && (t2.autoSize && !this.zm && this.Um(), false === t2.autoSize && null !== this.zm && this.Gm(), t2.autoSize || void 0 === t2.width && void 0 === t2.height || this.qm(t2.width || this.e_, t2.height || this.Qa));
  }
  ib(i) {
    let n2 = 0, s = 0;
    const e3 = this.Dm[0], r2 = (t2, n3) => {
      let s2 = 0;
      for (let e4 = 0; e4 < this.Dm.length; e4++) {
        const r3 = this.Dm[e4], h3 = b("left" === t2 ? r3.Zp() : r3.Gp()), l2 = h3.sp();
        null !== i && h3.ep(i, n3, s2), s2 += l2.height;
      }
    };
    if (this.sb()) {
      r2("left", 0);
      n2 += b(e3.Zp()).sp().width;
    }
    for (let t2 = 0; t2 < this.Dm.length; t2++) {
      const e4 = this.Dm[t2], r3 = e4.sp();
      null !== i && e4.ep(i, n2, s), s += r3.height;
    }
    if (n2 += e3.sp().width, this.eb()) {
      r2("right", n2);
      n2 += b(e3.Gp()).sp().width;
    }
    const h2 = (t2, n3, s2) => {
      b("left" === t2 ? this.$m.bm() : this.$m.wm()).ep(b(i), n3, s2);
    };
    if (this.cn.timeScale.visible) {
      const t2 = this.$m.sp();
      if (null !== i) {
        let n3 = 0;
        this.sb() && (h2("left", n3, s), n3 = b(e3.Zp()).sp().width), this.$m.ep(i, n3, s), n3 += t2.width, this.eb() && h2("right", n3, s);
      }
      s += t2.height;
    }
    return size({ width: n2, height: s });
  }
  ob() {
    let i = 0, n2 = 0, s = 0;
    for (const t2 of this.Dm)
      this.sb() && (n2 = Math.max(n2, b(t2.Zp()).$v(), this.cn.leftPriceScale.minimumWidth)), this.eb() && (s = Math.max(s, b(t2.Gp()).$v(), this.cn.rightPriceScale.minimumWidth)), i += t2.v_();
    n2 = es(n2), s = es(s);
    const e3 = this.e_, r2 = this.Qa, h2 = Math.max(e3 - n2 - s, 0), l2 = this.cn.timeScale.visible;
    let a2 = l2 ? Math.max(this.$m.xm(), this.cn.timeScale.minimumHeight) : 0;
    var o2;
    a2 = (o2 = a2) + o2 % 2;
    const _24 = 0 + a2, u2 = r2 < _24 ? 0 : r2 - _24, c2 = u2 / i;
    let d2 = 0;
    for (let i2 = 0; i2 < this.Dm.length; ++i2) {
      const e4 = this.Dm[i2];
      e4.Tp(this.Ui.Lc()[i2]);
      let r3 = 0, l3 = 0;
      l3 = i2 === this.Dm.length - 1 ? u2 - d2 : Math.round(e4.v_() * c2), r3 = Math.max(l3, 2), d2 += r3, e4.Yv(size({ width: h2, height: r3 })), this.sb() && e4.Hp(n2, "left"), this.eb() && e4.Hp(s, "right"), e4.Kv() && this.Ui.jc(e4.Kv(), r3);
    }
    this.$m.Mm(size({ width: l2 ? h2 : 0, height: a2 }), l2 ? n2 : 0, l2 ? s : 0), this.Ui.m_(h2), this.Am !== n2 && (this.Am = n2), this.Vm !== s && (this.Vm = s);
  }
  jm(t2) {
    t2 ? this.um.addEventListener("wheel", this.Fm, { passive: false }) : this.um.removeEventListener("wheel", this.Fm);
  }
  _b(t2) {
    switch (t2.deltaMode) {
      case t2.DOM_DELTA_PAGE:
        return 120;
      case t2.DOM_DELTA_LINE:
        return 32;
    }
    return Bs ? 1 / window.devicePixelRatio : 1;
  }
  Wm(t2) {
    if (!(0 !== t2.deltaX && this.cn.handleScroll.mouseWheel || 0 !== t2.deltaY && this.cn.handleScale.mouseWheel))
      return;
    const i = this._b(t2), n2 = i * t2.deltaX / 100, s = -i * t2.deltaY / 100;
    if (t2.cancelable && t2.preventDefault(), 0 !== s && this.cn.handleScale.mouseWheel) {
      const i2 = Math.sign(s) * Math.min(1, Math.abs(s)), n3 = t2.clientX - this.um.getBoundingClientRect().left;
      this.qt().Uc(n3, i2);
    }
    0 !== n2 && this.cn.handleScroll.mouseWheel && this.qt().qc(-80 * n2);
  }
  Jm(t2, i) {
    var n2;
    const s = t2.jn();
    3 === s && this.ub(), 3 !== s && 2 !== s || (this.cb(t2), this.fb(t2, i), this.$m.gt(), this.Dm.forEach((t3) => {
      t3.Rp();
    }), 3 === (null === (n2 = this.Bm) || void 0 === n2 ? void 0 : n2.jn()) && (this.Bm.ts(t2), this.ub(), this.cb(this.Bm), this.fb(this.Bm, i), t2 = this.Bm, this.Bm = null)), this.Zv(t2);
  }
  fb(t2, i) {
    for (const n2 of t2.Qn())
      this.ns(n2, i);
  }
  cb(t2) {
    const i = this.Ui.Lc();
    for (let n2 = 0; n2 < i.length; n2++)
      t2.Hn(n2).Wn && i[n2].V_();
  }
  ns(t2, i) {
    const n2 = this.Ui.yt();
    switch (t2.qn) {
      case 0:
        n2.Qu();
        break;
      case 1:
        n2.tc(t2.Vt);
        break;
      case 2:
        n2.Gn(t2.Vt);
        break;
      case 3:
        n2.Jn(t2.Vt);
        break;
      case 4:
        n2.Fu();
        break;
      case 5:
        t2.Vt.Yu(i) || n2.Jn(t2.Vt.Xu(i));
    }
  }
  Sc(t2) {
    null !== this.Bm ? this.Bm.ts(t2) : this.Bm = t2, this.Im || (this.Im = true, this.Om = window.requestAnimationFrame((t3) => {
      if (this.Im = false, this.Om = 0, null !== this.Bm) {
        const i = this.Bm;
        this.Bm = null, this.Jm(i, t3);
        for (const n2 of i.Qn())
          if (5 === n2.qn && !n2.Vt.Yu(t3)) {
            this.qt().Xn(n2.Vt);
            break;
          }
      }
    }));
  }
  ub() {
    this.Ym();
  }
  Ym() {
    const t2 = this.Ui.Lc(), i = t2.length, n2 = this.Dm.length;
    for (let t3 = i; t3 < n2; t3++) {
      const t4 = m$1(this.Dm.pop());
      this.Nm.removeChild(t4.jv()), t4.Fp().p(this), t4.Wp().p(this), t4.S();
    }
    for (let s = n2; s < i; s++) {
      const i2 = new Ts(this, t2[s]);
      i2.Fp().l(this.vb.bind(this), this), i2.Wp().l(this.pb.bind(this), this), this.Dm.push(i2), this.Nm.insertBefore(i2.jv(), this.$m.jv());
    }
    for (let n3 = 0; n3 < i; n3++) {
      const i2 = t2[n3], s = this.Dm[n3];
      s.Kv() !== i2 ? s.Tp(i2) : s.Cp();
    }
    this.Xm(), this.ob();
  }
  mb(t2, i, n2) {
    var s;
    const e3 = /* @__PURE__ */ new Map();
    if (null !== t2) {
      this.Ui.Mt().forEach((i2) => {
        const n3 = i2.In().nl(t2);
        null !== n3 && e3.set(i2, n3);
      });
    }
    let r2;
    if (null !== t2) {
      const i2 = null === (s = this.Ui.yt().qi(t2)) || void 0 === s ? void 0 : s.originalTime;
      void 0 !== i2 && (r2 = i2);
    }
    const h2 = this.qt().Vc(), l2 = null !== h2 && h2.Ic instanceof Gi ? h2.Ic : void 0, a2 = null !== h2 && void 0 !== h2.pv ? h2.pv.wr : void 0;
    return { bb: r2, se: null != t2 ? t2 : void 0, wb: null != i ? i : void 0, gb: l2, Mb: e3, xb: a2, Sb: null != n2 ? n2 : void 0 };
  }
  vb(t2, i, n2) {
    this.up.m(() => this.mb(t2, i, n2));
  }
  pb(t2, i, n2) {
    this.cp.m(() => this.mb(t2, i, n2));
  }
  Hm(t2, i, n2) {
    this.Mc.m(() => this.mb(t2, i, n2));
  }
  Xm() {
    const t2 = this.cn.timeScale.visible ? "" : "none";
    this.$m.jv().style.display = t2;
  }
  sb() {
    return this.Dm[0].Kv().S_().W().visible;
  }
  eb() {
    return this.Dm[0].Kv().k_().W().visible;
  }
  Um() {
    return "ResizeObserver" in window && (this.zm = new ResizeObserver((t2) => {
      const i = t2.find((t3) => t3.target === this.Lm);
      i && this.qm(i.contentRect.width, i.contentRect.height);
    }), this.zm.observe(this.Lm, { box: "border-box" }), true);
  }
  Gm() {
    null !== this.zm && this.zm.disconnect(), this.zm = null;
  }
}
function Es(t2) {
  return Boolean(t2.handleScroll.mouseWheel || t2.handleScale.mouseWheel);
}
function Ls(t2, i) {
  var n2 = {};
  for (var s in t2)
    Object.prototype.hasOwnProperty.call(t2, s) && i.indexOf(s) < 0 && (n2[s] = t2[s]);
  if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
    var e3 = 0;
    for (s = Object.getOwnPropertySymbols(t2); e3 < s.length; e3++)
      i.indexOf(s[e3]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, s[e3]) && (n2[s[e3]] = t2[s[e3]]);
  }
  return n2;
}
function Ns(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.color && (r2.O = n2.color), r2;
}
function Fs(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.lineColor && (r2._t = n2.lineColor), void 0 !== n2.topColor && (r2.Ts = n2.topColor), void 0 !== n2.bottomColor && (r2.Ps = n2.bottomColor), r2;
}
function Ws(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.topLineColor && (r2.Pe = n2.topLineColor), void 0 !== n2.bottomLineColor && (r2.Re = n2.bottomLineColor), void 0 !== n2.topFillColor1 && (r2.Se = n2.topFillColor1), void 0 !== n2.topFillColor2 && (r2.ke = n2.topFillColor2), void 0 !== n2.bottomFillColor1 && (r2.ye = n2.bottomFillColor1), void 0 !== n2.bottomFillColor2 && (r2.Ce = n2.bottomFillColor2), r2;
}
function js(t2, i, n2, s) {
  const e3 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return void 0 !== n2.color && (e3.O = n2.color), e3;
}
function Hs(t2, i, n2, s) {
  const e3 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return void 0 !== n2.color && (e3.O = n2.color), void 0 !== n2.borderColor && (e3.Bt = n2.borderColor), void 0 !== n2.wickColor && (e3.$h = n2.wickColor), e3;
}
function $s(t2, i, n2, s, e3) {
  const r2 = m$1(e3)(n2), h2 = Math.max(...r2), l2 = Math.min(...r2), a2 = r2[r2.length - 1], o2 = [a2, h2, l2, a2], _24 = n2, { time: u2, color: c2 } = _24;
  return { se: i, ut: t2, Vt: o2, bb: s, He: Ls(_24, ["time", "color"]), O: c2 };
}
function Us(t2) {
  return void 0 !== t2.Vt;
}
function qs(t2, i) {
  return void 0 !== i.customValues && (t2.kb = i.customValues), t2;
}
function Ys(t2) {
  return (i, n2, s, e3, r2, h2) => function(t3, i2) {
    return i2 ? i2(t3) : void 0 === (n3 = t3).open && void 0 === n3.value;
    var n3;
  }(s, h2) ? qs({ ut: i, se: n2, bb: e3 }, s) : qs(t2(i, n2, s, e3, r2), s);
}
function Xs(t2) {
  return { Candlestick: Ys(Hs), Bar: Ys(js), Area: Ys(Fs), Baseline: Ys(Ws), Histogram: Ys(Ns), Line: Ys(Ns), Custom: Ys($s) }[t2];
}
function Ks(t2) {
  return { se: 0, yb: /* @__PURE__ */ new Map(), ia: t2 };
}
function Zs(t2, i) {
  if (void 0 !== t2 && 0 !== t2.length)
    return { Cb: i.key(t2[0].ut), Tb: i.key(t2[t2.length - 1].ut) };
}
function Gs(t2) {
  let i;
  return t2.forEach((t3) => {
    void 0 === i && (i = t3.bb);
  }), m$1(i);
}
class Js {
  constructor(t2) {
    this.Pb = /* @__PURE__ */ new Map(), this.Rb = /* @__PURE__ */ new Map(), this.Db = /* @__PURE__ */ new Map(), this.Ob = [], this.N_ = t2;
  }
  S() {
    this.Pb.clear(), this.Rb.clear(), this.Db.clear(), this.Ob = [];
  }
  Ab(t2, i) {
    let n2 = 0 !== this.Pb.size, s = false;
    const e3 = this.Rb.get(t2);
    if (void 0 !== e3)
      if (1 === this.Rb.size)
        n2 = false, s = true, this.Pb.clear();
      else
        for (const i2 of this.Ob)
          i2.pointData.yb.delete(t2) && (s = true);
    let r2 = [];
    if (0 !== i.length) {
      const n3 = i.map((t3) => t3.time), e4 = this.N_.createConverterToInternalObj(i), h3 = Xs(t2.Xh()), l2 = t2.ga(), a2 = t2.Ma();
      r2 = i.map((i2, r3) => {
        const o2 = e4(i2.time), _24 = this.N_.key(o2);
        let u2 = this.Pb.get(_24);
        void 0 === u2 && (u2 = Ks(o2), this.Pb.set(_24, u2), s = true);
        const c2 = h3(o2, u2.se, i2, n3[r3], l2, a2);
        return u2.yb.set(t2, c2), c2;
      });
    }
    n2 && this.Vb(), this.Bb(t2, r2);
    let h2 = -1;
    if (s) {
      const t3 = [];
      this.Pb.forEach((i2) => {
        t3.push({ timeWeight: 0, time: i2.ia, pointData: i2, originalTime: Gs(i2.yb) });
      }), t3.sort((t4, i2) => this.N_.key(t4.time) - this.N_.key(i2.time)), h2 = this.Ib(t3);
    }
    return this.zb(t2, h2, function(t3, i2, n3) {
      const s2 = Zs(t3, n3), e4 = Zs(i2, n3);
      if (void 0 !== s2 && void 0 !== e4)
        return { Xl: s2.Tb >= e4.Tb && s2.Cb >= e4.Cb };
    }(this.Rb.get(t2), e3, this.N_));
  }
  hd(t2) {
    return this.Ab(t2, []);
  }
  Eb(t2, i) {
    const n2 = i;
    !function(t3) {
      void 0 === t3.bb && (t3.bb = t3.time);
    }(n2), this.N_.preprocessData(i);
    const s = this.N_.createConverterToInternalObj([i])(i.time), e3 = this.Db.get(t2);
    if (void 0 !== e3 && this.N_.key(s) < this.N_.key(e3))
      throw new Error(`Cannot update oldest data, last time=${e3}, new time=${s}`);
    let r2 = this.Pb.get(this.N_.key(s));
    const h2 = void 0 === r2;
    void 0 === r2 && (r2 = Ks(s), this.Pb.set(this.N_.key(s), r2));
    const l2 = Xs(t2.Xh()), a2 = t2.ga(), o2 = t2.Ma(), _24 = l2(s, r2.se, i, n2.bb, a2, o2);
    r2.yb.set(t2, _24), this.Lb(t2, _24);
    const u2 = { Xl: Us(_24) };
    if (!h2)
      return this.zb(t2, -1, u2);
    const c2 = { timeWeight: 0, time: r2.ia, pointData: r2, originalTime: Gs(r2.yb) }, d2 = Bt$1(this.Ob, this.N_.key(c2.time), (t3, i2) => this.N_.key(t3.time) < i2);
    this.Ob.splice(d2, 0, c2);
    for (let t3 = d2; t3 < this.Ob.length; ++t3)
      Qs(this.Ob[t3].pointData, t3);
    return this.N_.fillWeightsForPoints(this.Ob, d2), this.zb(t2, d2, u2);
  }
  Lb(t2, i) {
    let n2 = this.Rb.get(t2);
    void 0 === n2 && (n2 = [], this.Rb.set(t2, n2));
    const s = 0 !== n2.length ? n2[n2.length - 1] : null;
    null === s || this.N_.key(i.ut) > this.N_.key(s.ut) ? Us(i) && n2.push(i) : Us(i) ? n2[n2.length - 1] = i : n2.splice(-1, 1), this.Db.set(t2, i.ut);
  }
  Bb(t2, i) {
    0 !== i.length ? (this.Rb.set(t2, i.filter(Us)), this.Db.set(t2, i[i.length - 1].ut)) : (this.Rb.delete(t2), this.Db.delete(t2));
  }
  Vb() {
    for (const t2 of this.Ob)
      0 === t2.pointData.yb.size && this.Pb.delete(this.N_.key(t2.time));
  }
  Ib(t2) {
    let i = -1;
    for (let n2 = 0; n2 < this.Ob.length && n2 < t2.length; ++n2) {
      const s = this.Ob[n2], e3 = t2[n2];
      if (this.N_.key(s.time) !== this.N_.key(e3.time)) {
        i = n2;
        break;
      }
      e3.timeWeight = s.timeWeight, Qs(e3.pointData, n2);
    }
    if (-1 === i && this.Ob.length !== t2.length && (i = Math.min(this.Ob.length, t2.length)), -1 === i)
      return -1;
    for (let n2 = i; n2 < t2.length; ++n2)
      Qs(t2[n2].pointData, n2);
    return this.N_.fillWeightsForPoints(t2, i), this.Ob = t2, i;
  }
  Nb() {
    if (0 === this.Rb.size)
      return null;
    let t2 = 0;
    return this.Rb.forEach((i) => {
      0 !== i.length && (t2 = Math.max(t2, i[i.length - 1].se));
    }), t2;
  }
  zb(t2, i, n2) {
    const s = { Fb: /* @__PURE__ */ new Map(), yt: { Au: this.Nb() } };
    if (-1 !== i)
      this.Rb.forEach((i2, e3) => {
        s.Fb.set(e3, { He: i2, Wb: e3 === t2 ? n2 : void 0 });
      }), this.Rb.has(t2) || s.Fb.set(t2, { He: [], Wb: n2 }), s.yt.jb = this.Ob, s.yt.Hb = i;
    else {
      const i2 = this.Rb.get(t2);
      s.Fb.set(t2, { He: i2 || [], Wb: n2 });
    }
    return s;
  }
}
function Qs(t2, i) {
  t2.se = i, t2.yb.forEach((t3) => {
    t3.se = i;
  });
}
function te$1(t2) {
  const i = { value: t2.Vt[3], time: t2.bb };
  return void 0 !== t2.kb && (i.customValues = t2.kb), i;
}
function ie$1(t2) {
  const i = te$1(t2);
  return void 0 !== t2.O && (i.color = t2.O), i;
}
function ne(t2) {
  const i = te$1(t2);
  return void 0 !== t2._t && (i.lineColor = t2._t), void 0 !== t2.Ts && (i.topColor = t2.Ts), void 0 !== t2.Ps && (i.bottomColor = t2.Ps), i;
}
function se$1(t2) {
  const i = te$1(t2);
  return void 0 !== t2.Pe && (i.topLineColor = t2.Pe), void 0 !== t2.Re && (i.bottomLineColor = t2.Re), void 0 !== t2.Se && (i.topFillColor1 = t2.Se), void 0 !== t2.ke && (i.topFillColor2 = t2.ke), void 0 !== t2.ye && (i.bottomFillColor1 = t2.ye), void 0 !== t2.Ce && (i.bottomFillColor2 = t2.Ce), i;
}
function ee$1(t2) {
  const i = { open: t2.Vt[0], high: t2.Vt[1], low: t2.Vt[2], close: t2.Vt[3], time: t2.bb };
  return void 0 !== t2.kb && (i.customValues = t2.kb), i;
}
function re$1(t2) {
  const i = ee$1(t2);
  return void 0 !== t2.O && (i.color = t2.O), i;
}
function he(t2) {
  const i = ee$1(t2), { O: n2, Bt: s, $h: e3 } = t2;
  return void 0 !== n2 && (i.color = n2), void 0 !== s && (i.borderColor = s), void 0 !== e3 && (i.wickColor = e3), i;
}
function le(t2) {
  return { Area: ne, Line: ie$1, Baseline: se$1, Histogram: ie$1, Bar: re$1, Candlestick: he, Custom: ae$1 }[t2];
}
function ae$1(t2) {
  const i = t2.bb;
  return Object.assign(Object.assign({}, t2.He), { time: i });
}
const oe$1 = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, mode: 1 }, _e$1 = { vertLines: { color: "#D6DCDE", style: 0, visible: true }, horzLines: { color: "#D6DCDE", style: 0, visible: true } }, ue = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: L$1 }, ce$1 = { autoScale: true, mode: 0, invertScale: false, alignLabels: true, borderVisible: true, borderColor: "#2B2B43", entireTextOnly: false, visible: false, ticksVisible: false, scaleMargins: { bottom: 0.1, top: 0.2 }, minimumWidth: 0 }, de = { rightOffset: 0, barSpacing: 6, minBarSpacing: 0.5, fixLeftEdge: false, fixRightEdge: false, lockVisibleTimeRangeOnResize: false, rightBarStaysOnScroll: false, borderVisible: true, borderColor: "#2B2B43", visible: true, timeVisible: false, secondsVisible: true, shiftVisibleRangeOnNewBar: true, allowShiftVisibleRangeOnWhitespaceReplacement: false, ticksVisible: false, uniformDistribution: false, minimumHeight: 0 }, fe = { color: "rgba(0, 0, 0, 0)", visible: false, fontSize: 48, fontFamily: L$1, fontStyle: "", text: "", horzAlign: "center", vertAlign: "center" };
function ve() {
  return { width: 0, height: 0, autoSize: false, layout: ue, crosshair: oe$1, grid: _e$1, overlayPriceScales: Object.assign({}, ce$1), leftPriceScale: Object.assign(Object.assign({}, ce$1), { visible: false }), rightPriceScale: Object.assign(Object.assign({}, ce$1), { visible: true }), timeScale: de, watermark: fe, localization: { locale: is ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true }, handleScale: { axisPressedMouseMove: { time: true, price: true }, axisDoubleClickReset: { time: true, price: true }, mouseWheel: true, pinch: true }, kineticScroll: { mouse: false, touch: true }, trackingMode: { exitMode: 1 } };
}
class pe {
  constructor(t2, i) {
    this.$b = t2, this.Ub = i;
  }
  applyOptions(t2) {
    this.$b.qt().zc(this.Ub, t2);
  }
  options() {
    return this.Li().W();
  }
  width() {
    return ut$1(this.Ub) ? this.$b.nb(this.Ub) : 0;
  }
  Li() {
    return b(this.$b.qt().Ec(this.Ub)).At;
  }
}
function me(t2, i, n2) {
  const s = Ls(t2, ["time", "originalTime"]), e3 = Object.assign({ time: i }, s);
  return void 0 !== n2 && (e3.originalTime = n2), e3;
}
const be = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: true, axisLabelVisible: true, title: "", axisLabelColor: "", axisLabelTextColor: "" };
class we {
  constructor(t2) {
    this.Bh = t2;
  }
  applyOptions(t2) {
    this.Bh.Nh(t2);
  }
  options() {
    return this.Bh.W();
  }
  qb() {
    return this.Bh;
  }
}
class ge {
  constructor(t2, i, n2, s, e3) {
    this.Yb = new R(), this.Es = t2, this.Xb = i, this.Kb = n2, this.N_ = e3, this.Zb = s;
  }
  S() {
    this.Yb.S();
  }
  priceFormatter() {
    return this.Es.ca();
  }
  priceToCoordinate(t2) {
    const i = this.Es.Pt();
    return null === i ? null : this.Es.At().Ot(t2, i.Vt);
  }
  coordinateToPrice(t2) {
    const i = this.Es.Pt();
    return null === i ? null : this.Es.At().pn(t2, i.Vt);
  }
  barsInLogicalRange(t2) {
    if (null === t2)
      return null;
    const i = new yn$1(new xn$1(t2.from, t2.to)).iu(), n2 = this.Es.In();
    if (n2.Fi())
      return null;
    const s = n2.nl(i.Os(), 1), e3 = n2.nl(i.di(), -1), r2 = b(n2.Qh()), h2 = b(n2.Bn());
    if (null !== s && null !== e3 && s.se > e3.se)
      return { barsBefore: t2.from - r2, barsAfter: h2 - t2.to };
    const l2 = { barsBefore: null === s || s.se === r2 ? t2.from - r2 : s.se - r2, barsAfter: null === e3 || e3.se === h2 ? h2 - t2.to : h2 - e3.se };
    return null !== s && null !== e3 && (l2.from = s.bb, l2.to = e3.bb), l2;
  }
  setData(t2) {
    this.N_, this.Es.Xh(), this.Xb.Gb(this.Es, t2), this.Jb("full");
  }
  update(t2) {
    this.Es.Xh(), this.Xb.Qb(this.Es, t2), this.Jb("update");
  }
  dataByIndex(t2, i) {
    const n2 = this.Es.In().nl(t2, i);
    if (null === n2)
      return null;
    return le(this.seriesType())(n2);
  }
  data() {
    const t2 = le(this.seriesType());
    return this.Es.In().ie().map((i) => t2(i));
  }
  subscribeDataChanged(t2) {
    this.Yb.l(t2);
  }
  unsubscribeDataChanged(t2) {
    this.Yb.v(t2);
  }
  setMarkers(t2) {
    this.N_;
    const i = t2.map((t3) => me(t3, this.N_.convertHorzItemToInternal(t3.time), t3.time));
    this.Es.Zl(i);
  }
  markers() {
    return this.Es.Gl().map((t2) => me(t2, t2.originalTime, void 0));
  }
  applyOptions(t2) {
    this.Es.Nh(t2);
  }
  options() {
    return I(this.Es.W());
  }
  priceScale() {
    return this.Kb.priceScale(this.Es.At().xa());
  }
  createPriceLine(t2) {
    const i = D$1(I(be), t2), n2 = this.Es.Jl(i);
    return new we(n2);
  }
  removePriceLine(t2) {
    this.Es.Ql(t2.qb());
  }
  seriesType() {
    return this.Es.Xh();
  }
  attachPrimitive(t2) {
    this.Es.ba(t2), t2.attached && t2.attached({ chart: this.Zb, series: this, requestUpdate: () => this.Es.qt().$l() });
  }
  detachPrimitive(t2) {
    this.Es.wa(t2), t2.detached && t2.detached();
  }
  Jb(t2) {
    this.Yb.M() && this.Yb.m(t2);
  }
}
let Me$1 = class Me {
  constructor(t2, i, n2) {
    this.tw = new R(), this.uu = new R(), this._m = new R(), this.Ui = t2, this.wl = t2.yt(), this.$m = i, this.wl.Ku().l(this.iw.bind(this)), this.wl.Zu().l(this.nw.bind(this)), this.$m.gm().l(this.sw.bind(this)), this.N_ = n2;
  }
  S() {
    this.wl.Ku().p(this), this.wl.Zu().p(this), this.$m.gm().p(this), this.tw.S(), this.uu.S(), this._m.S();
  }
  scrollPosition() {
    return this.wl.Eu();
  }
  scrollToPosition(t2, i) {
    i ? this.wl.qu(t2, 1e3) : this.Ui.Jn(t2);
  }
  scrollToRealTime() {
    this.wl.Uu();
  }
  getVisibleRange() {
    const t2 = this.wl.yu();
    return null === t2 ? null : { from: t2.from.originalTime, to: t2.to.originalTime };
  }
  setVisibleRange(t2) {
    const i = { from: this.N_.convertHorzItemToInternal(t2.from), to: this.N_.convertHorzItemToInternal(t2.to) }, n2 = this.wl.Ru(i);
    this.Ui.ld(n2);
  }
  getVisibleLogicalRange() {
    const t2 = this.wl.ku();
    return null === t2 ? null : { from: t2.Os(), to: t2.di() };
  }
  setVisibleLogicalRange(t2) {
    p$1(t2.from <= t2.to, "The from index cannot be after the to index."), this.Ui.ld(t2);
  }
  resetTimeScale() {
    this.Ui.Zn();
  }
  fitContent() {
    this.Ui.Qu();
  }
  logicalToCoordinate(t2) {
    const i = this.Ui.yt();
    return i.Fi() ? null : i.Et(t2);
  }
  coordinateToLogical(t2) {
    return this.wl.Fi() ? null : this.wl.Vu(t2);
  }
  timeToCoordinate(t2) {
    const i = this.N_.convertHorzItemToInternal(t2), n2 = this.wl.ya(i, false);
    return null === n2 ? null : this.wl.Et(n2);
  }
  coordinateToTime(t2) {
    const i = this.Ui.yt(), n2 = i.Vu(t2), s = i.qi(n2);
    return null === s ? null : s.originalTime;
  }
  width() {
    return this.$m.$p().width;
  }
  height() {
    return this.$m.$p().height;
  }
  subscribeVisibleTimeRangeChange(t2) {
    this.tw.l(t2);
  }
  unsubscribeVisibleTimeRangeChange(t2) {
    this.tw.v(t2);
  }
  subscribeVisibleLogicalRangeChange(t2) {
    this.uu.l(t2);
  }
  unsubscribeVisibleLogicalRangeChange(t2) {
    this.uu.v(t2);
  }
  subscribeSizeChange(t2) {
    this._m.l(t2);
  }
  unsubscribeSizeChange(t2) {
    this._m.v(t2);
  }
  applyOptions(t2) {
    this.wl.Nh(t2);
  }
  options() {
    return Object.assign(Object.assign({}, I(this.wl.W())), { barSpacing: this.wl.he() });
  }
  iw() {
    this.tw.M() && this.tw.m(this.getVisibleRange());
  }
  nw() {
    this.uu.M() && this.uu.m(this.getVisibleLogicalRange());
  }
  sw(t2) {
    this._m.m(t2.width, t2.height);
  }
};
function xe(t2) {
  if (void 0 === t2 || "custom" === t2.type)
    return;
  const i = t2;
  void 0 !== i.minMove && void 0 === i.precision && (i.precision = function(t3) {
    if (t3 >= 1)
      return 0;
    let i2 = 0;
    for (; i2 < 8; i2++) {
      const n2 = Math.round(t3);
      if (Math.abs(n2 - t3) < 1e-8)
        return i2;
      t3 *= 10;
    }
    return i2;
  }(i.minMove));
}
function Se(t2) {
  return function(t3) {
    if (B$1(t3.handleScale)) {
      const i2 = t3.handleScale;
      t3.handleScale = { axisDoubleClickReset: { time: i2, price: i2 }, axisPressedMouseMove: { time: i2, price: i2 }, mouseWheel: i2, pinch: i2 };
    } else if (void 0 !== t3.handleScale) {
      const { axisPressedMouseMove: i2, axisDoubleClickReset: n2 } = t3.handleScale;
      B$1(i2) && (t3.handleScale.axisPressedMouseMove = { time: i2, price: i2 }), B$1(n2) && (t3.handleScale.axisDoubleClickReset = { time: n2, price: n2 });
    }
    const i = t3.handleScroll;
    B$1(i) && (t3.handleScroll = { horzTouchDrag: i, vertTouchDrag: i, mouseWheel: i, pressedMouseMove: i });
  }(t2), t2;
}
let ke$1 = class ke {
  constructor(t2, i, n2) {
    this.ew = /* @__PURE__ */ new Map(), this.rw = /* @__PURE__ */ new Map(), this.hw = new R(), this.lw = new R(), this.aw = new R(), this.ow = new Js(i);
    const s = void 0 === n2 ? I(ve()) : D$1(I(ve()), Se(n2));
    this.N_ = i, this.$b = new zs(t2, s, i), this.$b.Fp().l((t3) => {
      this.hw.M() && this.hw.m(this._w(t3()));
    }, this), this.$b.Wp().l((t3) => {
      this.lw.M() && this.lw.m(this._w(t3()));
    }, this), this.$b.Wc().l((t3) => {
      this.aw.M() && this.aw.m(this._w(t3()));
    }, this);
    const e3 = this.$b.qt();
    this.uw = new Me$1(e3, this.$b.Zm(), this.N_);
  }
  remove() {
    this.$b.Fp().p(this), this.$b.Wp().p(this), this.$b.Wc().p(this), this.uw.S(), this.$b.S(), this.ew.clear(), this.rw.clear(), this.hw.S(), this.lw.S(), this.aw.S(), this.ow.S();
  }
  resize(t2, i, n2) {
    this.autoSizeActive() || this.$b.qm(t2, i, n2);
  }
  addCustomSeries(t2, i) {
    const n2 = w$1(t2), s = Object.assign(Object.assign({}, _$1), n2.defaultOptions());
    return this.cw("Custom", s, i, n2);
  }
  addAreaSeries(t2) {
    return this.cw("Area", l, t2);
  }
  addBaselineSeries(t2) {
    return this.cw("Baseline", a, t2);
  }
  addBarSeries(t2) {
    return this.cw("Bar", r, t2);
  }
  addCandlestickSeries(t2 = {}) {
    return function(t3) {
      void 0 !== t3.borderColor && (t3.borderUpColor = t3.borderColor, t3.borderDownColor = t3.borderColor), void 0 !== t3.wickColor && (t3.wickUpColor = t3.wickColor, t3.wickDownColor = t3.wickColor);
    }(t2), this.cw("Candlestick", e2, t2);
  }
  addHistogramSeries(t2) {
    return this.cw("Histogram", o, t2);
  }
  addLineSeries(t2) {
    return this.cw("Line", h$1, t2);
  }
  removeSeries(t2) {
    const i = m$1(this.ew.get(t2)), n2 = this.ow.hd(i);
    this.$b.qt().hd(i), this.dw(n2), this.ew.delete(t2), this.rw.delete(i);
  }
  Gb(t2, i) {
    this.dw(this.ow.Ab(t2, i));
  }
  Qb(t2, i) {
    this.dw(this.ow.Eb(t2, i));
  }
  subscribeClick(t2) {
    this.hw.l(t2);
  }
  unsubscribeClick(t2) {
    this.hw.v(t2);
  }
  subscribeCrosshairMove(t2) {
    this.aw.l(t2);
  }
  unsubscribeCrosshairMove(t2) {
    this.aw.v(t2);
  }
  subscribeDblClick(t2) {
    this.lw.l(t2);
  }
  unsubscribeDblClick(t2) {
    this.lw.v(t2);
  }
  priceScale(t2) {
    return new pe(this.$b, t2);
  }
  timeScale() {
    return this.uw;
  }
  applyOptions(t2) {
    this.$b.Nh(Se(t2));
  }
  options() {
    return this.$b.W();
  }
  takeScreenshot() {
    return this.$b.tb();
  }
  autoSizeActive() {
    return this.$b.rb();
  }
  chartElement() {
    return this.$b.hb();
  }
  paneSize() {
    const t2 = this.$b.ab();
    return { height: t2.height, width: t2.width };
  }
  setCrosshairPosition(t2, i, n2) {
    const s = this.ew.get(n2);
    if (void 0 === s)
      return;
    const e3 = this.$b.qt().cr(s);
    null !== e3 && this.$b.qt().Qc(t2, i, e3);
  }
  clearCrosshairPosition() {
    this.$b.qt().td(true);
  }
  cw(t2, i, n2 = {}, s) {
    xe(n2.priceFormat);
    const e3 = D$1(I(u), I(i), n2), r2 = this.$b.qt().ed(t2, e3, s), h2 = new ge(r2, this, this, this, this.N_);
    return this.ew.set(h2, r2), this.rw.set(r2, h2), h2;
  }
  dw(t2) {
    const i = this.$b.qt();
    i.nd(t2.yt.Au, t2.yt.jb, t2.yt.Hb), t2.Fb.forEach((t3, i2) => i2.it(t3.He, t3.Wb)), i.Iu();
  }
  fw(t2) {
    return m$1(this.rw.get(t2));
  }
  _w(t2) {
    const i = /* @__PURE__ */ new Map();
    t2.Mb.forEach((t3, n3) => {
      const s = n3.Xh(), e3 = le(s)(t3);
      if ("Custom" !== s)
        p$1(function(t4) {
          return void 0 !== t4.open || void 0 !== t4.value;
        }(e3));
      else {
        const t4 = n3.Ma();
        p$1(!t4 || false === t4(e3));
      }
      i.set(this.fw(n3), e3);
    });
    const n2 = void 0 === t2.gb ? void 0 : this.fw(t2.gb);
    return { time: t2.bb, logical: t2.se, point: t2.wb, hoveredSeries: n2, hoveredObjectId: t2.xb, seriesData: i, sourceEvent: t2.Sb };
  }
};
function ye(t2, i, n2) {
  let s;
  if (V$1(t2)) {
    const i2 = document.getElementById(t2);
    p$1(null !== i2, `Cannot find element in DOM with id=${t2}`), s = i2;
  } else
    s = t2;
  const e3 = new ke$1(s, i, n2);
  return i.setOptions(e3.options()), e3;
}
function Ce$1(t2, i) {
  return ye(t2, new ts(), ts.Td(i));
}
Object.assign(Object.assign({}, u), _$1);
const skeleton = "_skeleton_13p4i_1";
const style$r = {
  skeleton,
  "skeleton-loading": "_skeleton-loading_13p4i_1"
};
const Skeleton = ({
  fontSize,
  minWidth = "100%"
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$r.skeleton, style: { fontSize, minWidth } });
};
function formatNumber(amount2, maxDigits) {
  let formatted = amount2.toFixed(maxDigits);
  let position2 = formatted.indexOf(".") - 3;
  const start = formatted[0] === "-" ? 1 : 0;
  while (position2 > start) {
    formatted = formatted.slice(0, position2) + "'" + formatted.slice(position2);
    position2 -= 3;
  }
  return formatted;
}
const chart = "_chart_1bo3n_1";
const invisible = "_invisible_1bo3n_7";
const chartUpdatingMessage = "_chartUpdatingMessage_1bo3n_11";
const summary$1 = "_summary_1bo3n_28";
const filters = "_filters_1bo3n_35";
const filterActive = "_filterActive_1bo3n_87";
const arrow = "_arrow_1bo3n_104";
const up = "_up_1bo3n_109";
const down = "_down_1bo3n_113";
const totalValue = "_totalValue_1bo3n_117";
const totalUnit = "_totalUnit_1bo3n_121";
const diffValue = "_diffValue_1bo3n_128";
const diffUnit = "_diffUnit_1bo3n_132";
const chartCanvas = "_chartCanvas_1bo3n_137";
const tooltip = "_tooltip_1bo3n_149";
const toolTipValue = "_toolTipValue_1bo3n_164";
const toolTipUnit = "_toolTipUnit_1bo3n_170";
const toolTipTime = "_toolTipTime_1bo3n_176";
const styles$i = {
  chart,
  invisible,
  chartUpdatingMessage,
  summary: summary$1,
  filters,
  filterActive,
  arrow,
  up,
  down,
  totalValue,
  totalUnit,
  diffValue,
  diffUnit,
  chartCanvas,
  tooltip,
  toolTipValue,
  toolTipUnit,
  toolTipTime
};
const Filters = ({
  display,
  disableFilters,
  disableWeeklyFilters,
  onDisplayWeek,
  onDisplayMonth,
  onDisplayYear,
  onDisplayAll
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.filters, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "week" ? styles$i.filterActive : void 0,
        disabled: disableFilters || disableWeeklyFilters,
        onClick: onDisplayWeek,
        children: t2("chart.filter.week")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "month" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayMonth,
        children: t2("chart.filter.month")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "year" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayYear,
        children: t2("chart.filter.year")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "all" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayAll,
        children: t2("chart.filter.all")
      }
    )
  ] });
};
let darkmode;
const Darkmode = () => {
  const { isDarkMode } = useDarkmode();
  darkmode = isDarkMode;
  return null;
};
const getDarkmode = () => darkmode;
class Chart extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.ref = reactExports.createRef();
    this.refToolTip = reactExports.createRef();
    this.height = 300;
    this.mobileHeight = 150;
    this.state = {
      display: "all",
      source: "daily",
      toolTipVisible: false,
      toolTipValue: void 0,
      toolTipTop: 0,
      toolTipLeft: 0,
      toolTipTime: 0,
      isMobile: false
    };
    this.hasData = () => {
      return this.props.data.chartDataDaily && this.props.data.chartDataDaily.length > 0;
    };
    this.hasHourlyData = () => {
      return this.props.data.chartDataHourly && this.props.data.chartDataHourly.length > 0;
    };
    this.checkIfMobile = () => {
      this.setState({ isMobile: window.innerWidth <= 640 });
    };
    this.createChart = () => {
      const { data: { chartDataMissing } } = this.props;
      const darkmode2 = getDarkmode();
      if (this.ref.current && this.hasData() && !chartDataMissing) {
        if (!this.chart) {
          const chartWidth = !this.state.isMobile ? this.ref.current.offsetWidth : document.body.clientWidth;
          const chartHeight = !this.state.isMobile ? this.height : this.mobileHeight;
          this.chart = Ce$1(this.ref.current, {
            width: chartWidth,
            height: chartHeight,
            handleScroll: false,
            handleScale: false,
            crosshair: {
              vertLine: {
                visible: false,
                labelVisible: false
              },
              horzLine: {
                visible: false,
                labelVisible: false
              },
              mode: 1
            },
            grid: {
              vertLines: {
                visible: false
              },
              horzLines: {
                color: darkmode2 ? "#333333" : "#dedede",
                style: d.Solid,
                visible: !this.state.isMobile
              }
            },
            layout: {
              background: {
                type: Bn$1.Solid,
                color: darkmode2 ? "#1D1D1B" : "#F5F5F5"
              },
              fontSize: 11,
              fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Ubuntu", "Roboto", "Oxygen", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
              textColor: darkmode2 ? "#F5F5F5" : "#1D1D1B"
            },
            leftPriceScale: {
              borderVisible: false,
              ticksVisible: false,
              visible: this.props.hideAmounts ? false : !this.state.isMobile,
              entireTextOnly: true
            },
            localization: {
              locale: this.props.i18n.language
            },
            rightPriceScale: {
              visible: false,
              ticksVisible: false
            },
            timeScale: {
              borderVisible: false,
              timeVisible: false,
              visible: !this.state.isMobile
            },
            trackingMode: {
              exitMode: 0
            }
          });
        }
        this.lineSeries = this.chart.addAreaSeries({
          priceLineVisible: false,
          lastValueVisible: false,
          priceFormat: {
            type: "volume"
          },
          topColor: darkmode2 ? "#5E94BF" : "#DFF1FF",
          bottomColor: darkmode2 ? "#1D1D1B" : "#F5F5F5",
          lineColor: "rgba(94, 148, 192, 1)",
          crosshairMarkerRadius: 6
        });
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.timeScale().subscribeVisibleLogicalRangeChange(this.calculateChange);
        this.chart.subscribeCrosshairMove(this.handleCrosshair);
        this.chart.timeScale().fitContent();
        window.addEventListener("resize", this.onResize);
        setTimeout(() => {
          var _a;
          return (_a = this.ref.current) == null ? void 0 : _a.classList.remove(styles$i.invisible);
        }, 200);
      }
    };
    this.onResize = () => {
      this.checkIfMobile();
      if (this.resizeTimerID) {
        clearTimeout(this.resizeTimerID);
      }
      this.resizeTimerID = setTimeout(() => {
        if (!this.chart || !this.ref.current) {
          return;
        }
        const chartWidth = !this.state.isMobile ? this.ref.current.offsetWidth : document.body.clientWidth;
        const chartHeight = !this.state.isMobile ? this.height : this.mobileHeight;
        this.chart.resize(chartWidth, chartHeight);
        this.chart.applyOptions({
          grid: {
            horzLines: {
              visible: !this.state.isMobile
            }
          },
          timeScale: {
            visible: !this.state.isMobile
          },
          leftPriceScale: {
            visible: this.props.hideAmounts ? false : !this.state.isMobile
          }
        });
      }, 200);
    };
    this.getUTCRange = () => {
      const now = /* @__PURE__ */ new Date();
      const utcYear = now.getUTCFullYear();
      const utcMonth = now.getUTCMonth();
      const utcDate = now.getUTCDate();
      const utcHours = now.getUTCHours();
      const to = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      const from2 = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      return {
        utcYear,
        utcMonth,
        utcDate,
        to,
        from: from2
      };
    };
    this.displayWeek = () => {
      if (this.state.source !== "hourly" && this.lineSeries && this.props.data.chartDataHourly && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataHourly || []);
        this.setFormattedData(this.props.data.chartDataHourly || []);
        this.chart.applyOptions({ timeScale: { timeVisible: true } });
      }
      this.setState(
        { display: "week", source: "hourly" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcDate, from: from2, to } = this.getUTCRange();
          from2.setUTCDate(utcDate - 7);
          this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayMonth = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily || []);
        this.setFormattedData(this.props.data.chartDataDaily || []);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "month", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcMonth, from: from2, to } = this.getUTCRange();
          from2.setUTCMonth(utcMonth - 1);
          this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayYear = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "year", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcYear, from: from2, to } = this.getUTCRange();
          from2.setUTCFullYear(utcYear - 1);
          this.chart && this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayAll = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "all", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          this.chart.timeScale().fitContent();
        }
      );
    };
    this.calculateChange = () => {
      const data = this.props.data[this.state.source === "daily" ? "chartDataDaily" : "chartDataHourly"];
      if (!data || !this.chart || !this.lineSeries) {
        return;
      }
      const logicalrange = this.chart.timeScale().getVisibleLogicalRange();
      const visiblerange = this.lineSeries.barsInLogicalRange(logicalrange);
      if (!visiblerange) {
        return;
      }
      const rangeFrom = Math.max(Math.floor(visiblerange.barsBefore), 0);
      if (!data[rangeFrom]) {
        this.setState({ difference: 0, diffSince: "" });
        return;
      }
      const valueFrom = data[rangeFrom].value === 0 ? data[rangeFrom + 1].value : data[rangeFrom].value;
      const valueTo = this.props.data.chartTotal;
      const valueDiff = valueTo ? valueTo - valueFrom : 0;
      this.setState({
        difference: valueDiff / valueFrom * 100,
        diffSince: `${data[rangeFrom].formattedValue} (${this.renderDate(Number(data[rangeFrom].time) * 1e3)})`
      });
    };
    this.handleCrosshair = ({ point, time: time2, seriesData }) => {
      if (!this.refToolTip.current) {
        return;
      }
      const tooltip2 = this.refToolTip.current;
      const parent = tooltip2.parentNode;
      if (!this.lineSeries || !point || !time2 || point.x < 0 || point.x > parent.clientWidth || point.y < 0 || point.y > parent.clientHeight) {
        this.setState({
          toolTipVisible: false
        });
        return;
      }
      const price = seriesData.get(this.lineSeries);
      if (!price) {
        return;
      }
      const coordinate = this.lineSeries.priceToCoordinate(price.value);
      if (!coordinate) {
        return;
      }
      const coordinateY = coordinate - tooltip2.clientHeight > 0 ? coordinate - tooltip2.clientHeight : Math.max(
        0,
        Math.min(
          parent.clientHeight - tooltip2.clientHeight,
          coordinate + 70
        )
      );
      const toolTipTop = Math.floor(Math.max(coordinateY, 0));
      const toolTipLeft = Math.floor(Math.max(40, Math.min(parent.clientWidth - 140, point.x + 40 - 70)));
      this.setState({
        toolTipVisible: true,
        toolTipValue: this.formattedData ? this.formattedData[time2] : "",
        toolTipTop,
        toolTipLeft,
        toolTipTime: time2
      });
    };
    this.renderDate = (date2) => {
      return new Date(date2).toLocaleString(
        this.props.i18n.language,
        {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          ...this.state.source === "hourly" ? {
            hour: "2-digit",
            minute: "2-digit"
          } : null
        }
      );
    };
  }
  componentDidMount() {
    this.checkIfMobile();
    this.createChart();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.onResize);
    if (this.chart) {
      this.chart.timeScale().unsubscribeVisibleLogicalRangeChange(this.calculateChange);
      this.chart.unsubscribeCrosshairMove(this.handleCrosshair);
    }
  }
  componentDidUpdate(prev2) {
    var _a;
    const { chartDataDaily, chartDataHourly } = this.props.data;
    if (!this.chart) {
      this.createChart();
    }
    if (this.lineSeries && prev2.data.chartDataDaily && prev2.data.chartDataHourly && chartDataDaily && chartDataHourly && (prev2.data.chartDataDaily.length !== chartDataDaily.length || prev2.data.chartDataHourly.length !== chartDataHourly.length)) {
      const data = this.state.source === "hourly" ? chartDataHourly : chartDataDaily;
      this.lineSeries.setData(data);
      this.setFormattedData(data);
    }
    if (prev2.hideAmounts !== this.props.hideAmounts) {
      (_a = this.chart) == null ? void 0 : _a.applyOptions({
        leftPriceScale: {
          visible: this.props.hideAmounts ? false : !this.state.isMobile
        }
      });
    }
  }
  setFormattedData(data) {
    this.formattedData = {};
    data.forEach((entry2) => {
      if (this.formattedData) {
        this.formattedData[entry2.time] = entry2.formattedValue;
      }
    });
  }
  render() {
    const {
      t: t2,
      data: {
        lastTimestamp,
        chartDataMissing,
        chartFiat,
        chartIsUpToDate,
        chartTotal,
        formattedChartTotal
      },
      noDataPlaceholder,
      hideAmounts
    } = this.props;
    const {
      difference,
      diffSince,
      display,
      toolTipVisible,
      toolTipValue: toolTipValue2,
      toolTipTop,
      toolTipLeft,
      toolTipTime: toolTipTime2,
      isMobile
    } = this.state;
    const hasDifference = difference && Number.isFinite(difference);
    const hasData = this.hasData();
    const hasHourlyData = this.hasHourlyData();
    const disableFilters = !hasData || chartDataMissing;
    const disableWeeklyFilters = !hasHourlyData || chartDataMissing;
    const showMobileTotalValue = toolTipVisible && !!toolTipValue2 && isMobile;
    const chartFiltersProps = {
      display,
      disableFilters,
      disableWeeklyFilters,
      onDisplayWeek: this.displayWeek,
      onDisplayMonth: this.displayMonth,
      onDisplayYear: this.displayYear,
      onDisplayAll: this.displayAll
    };
    const chartHeight = `${!isMobile ? this.height : this.mobileHeight}px`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: styles$i.chart, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.summary, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.totalValue, children: [
            formattedChartTotal !== null ? (
              // remove trailing zeroes for BTC fiat total
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: !showMobileTotalValue ? formattedChartTotal : toolTipValue2, unit: chartFiat, removeBtcTrailingZeroes: true })
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { minWidth: "220px" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.totalUnit, children: chartTotal !== null && chartFiat })
          ] }),
          !showMobileTotalValue ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: !hasDifference ? "" : styles$i[difference < 0 ? "down" : "up"], title: diffSince, children: hasDifference ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.arrow, children: difference < 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDown, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$i.diffValue, children: [
              hideAmounts ? "***" : formatNumber(difference, 2),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.diffUnit, children: "%" })
            ] })
          ] }) : null }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.diffValue, children: this.renderDate(toolTipTime2 * 1e3) })
        ] }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.chartCanvas, style: { minHeight: chartHeight }, children: [
        chartDataMissing ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.chartUpdatingMessage, style: { height: chartHeight }, children: t2("chart.dataMissing") }) : hasData ? !chartIsUpToDate && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.chartUpdatingMessage, children: t2("chart.dataOldTimestamp", { time: new Date(lastTimestamp).toLocaleString(this.props.i18n.language) }) }) : noDataPlaceholder,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: this.ref, className: styles$i.invisible }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ref: this.refToolTip,
            className: styles$i.tooltip,
            style: { left: toolTipLeft, top: toolTipTop },
            hidden: !toolTipVisible || isMobile,
            children: toolTipValue2 !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: styles$i.toolTipValue, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: toolTipValue2, unit: chartFiat }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.toolTipUnit, children: chartFiat })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.toolTipTime, children: this.renderDate(toolTipTime2 * 1e3) })
            ] }) : null
          }
        )
      ] }),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
    ] });
  }
}
Chart.defaultProps = {
  data: {
    chartDataMissing: true,
    chartDataDaily: [],
    chartDataHourly: [],
    chartFiat: "USD",
    chartTotal: null,
    formattedChartTotal: null,
    chartIsUpToDate: false,
    lastTimestamp: 0
  },
  hideAmounts: false
};
const HOC$2 = translate()(Chart);
const ArrowUp = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
);
const ArrowDown = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
);
const spinnerContainer$1 = "_spinnerContainer_1akm7_1";
const spinner$1 = "_spinner_1akm7_1";
const changeContent$2 = "_changeContent_1akm7_1";
const style$q = {
  spinnerContainer: spinnerContainer$1,
  spinner: spinner$1,
  changeContent: changeContent$2
};
function AsciiSpinner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$q.spinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$q.spinner }) });
}
const accountName$4 = "_accountName_i87d0_1";
const balanceTable = "_balanceTable_i87d0_10";
const coincode = "_coincode_i87d0_13";
const coinheader = "_coinheader_i87d0_18";
const dataMissing = "_dataMissing_i87d0_29";
const openFileText = "_openFileText_i87d0_33";
const table = "_table_i87d0_39";
const noAccount = "_noAccount_i87d0_54";
const clickable = "_clickable_i87d0_89";
const summaryTableBalance = "_summaryTableBalance_i87d0_93";
const coinName = "_coinName_i87d0_103";
const coinUnit = "_coinUnit_i87d0_113";
const syncText$1 = "_syncText_i87d0_117";
const showOnTableView = "_showOnTableView_i87d0_121";
const showInCollapsedView = "_showInCollapsedView_i87d0_125";
const subTotal = "_subTotal_i87d0_182";
const style$p = {
  accountName: accountName$4,
  balanceTable,
  coincode,
  coinheader,
  dataMissing,
  openFileText,
  table,
  noAccount,
  clickable,
  summaryTableBalance,
  coinName,
  coinUnit,
  syncText: syncText$1,
  showOnTableView,
  showInCollapsedView,
  subTotal
};
function BalanceRow({ code, name, coinCode, balance: balance2 }) {
  const { t: t2 } = useTranslation();
  const syncStatus2 = useSubscribe(syncAddressesCount(code));
  const nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      className: style$p.clickable,
      "data-label": t2("accountSummary.name"),
      onClick: () => route(`/account/${code}`),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.coinName, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$p.coincode, coinCode, active: true, alt: coinCode }),
        name
      ] })
    }
  );
  if (balance2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      nameCol,
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$p.summaryTableBalance, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.available.amount, unit: balance2.available.unit }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: balance2.available.unit })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.available, noAction: true }) })
    ] }, `${code}_balance`);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 2, className: style$p.syncText, children: [
      t2("account.syncedAddressesCount", {
        count: syncStatus2 == null ? void 0 : syncStatus2.toString(),
        defaultValue: 0
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] })
  ] }, `${code}_syncing`);
}
function SubTotalRow({ coinCode, coinName: coinName2, balance: balance2 }) {
  const { t: t2 } = useTranslation();
  const nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.total"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.coinName, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$p.coincode, coinCode, active: true, alt: coinCode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$p.showOnTableView, children: t2("accountSummary.subtotalWithCoinName", { coinName: coinName2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$p.showInCollapsedView, children: coinName2 })
  ] }) });
  if (!balance2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: style$p.subTotal, children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$p.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.amount, unit: balance2.unit }) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: balance2.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2, noAction: true }) }) })
  ] }, `${coinCode}_subtotal`);
}
function TotalBalance({ total: total2, fiatUnit }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: total2, unit: fiatUnit }) }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: fiatUnit })
  ] });
}
function SummaryBalance({
  accounts,
  connected,
  keystoreName,
  totalBalancePerCoin,
  totalBalance,
  balances,
  keystoreDisambiguatorName
}) {
  const { t: t2 } = useTranslation();
  const getAccountsPerCoin = () => {
    return accounts.reduce((accountPerCoin, account2) => {
      accountPerCoin[account2.coinCode] ? accountPerCoin[account2.coinCode].push(account2) : accountPerCoin[account2.coinCode] = [account2];
      return accountPerCoin;
    }, {});
  };
  const accountsPerCoin = getAccountsPerCoin();
  const coins2 = Object.keys(accountsPerCoin);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.accountName, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        keystoreName,
        " ",
        keystoreDisambiguatorName && `(${keystoreDisambiguatorName})`
      ] }),
      connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Badge,
        {
          icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
          type: "success",
          children: t2("device.keystoreConnected")
        }
      ) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$p.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: style$p.table, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.name") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.balance") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.fiatBalance") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: accounts.length > 0 ? coins2.map((coinCode) => {
        const balanceRows = accountsPerCoin[coinCode].map(
          (account2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            BalanceRow,
            {
              code: account2.code,
              name: account2.name,
              coinCode: account2.coinCode,
              balance: balances && balances[account2.code]
            },
            account2.code
          )
        );
        if ((balanceRows == null ? void 0 : balanceRows.length) > 1) {
          const account2 = accountsPerCoin[coinCode][0];
          balanceRows.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SubTotalRow,
              {
                coinCode: account2.coinCode,
                coinName: account2.coinName,
                balance: totalBalancePerCoin && totalBalancePerCoin[coinCode]
              },
              account2.coinCode
            )
          );
        }
        return balanceRows;
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 3, className: style$p.noAccount, children: t2("accountSummary.noAccount") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tfoot", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("accountSummary.total") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 2, children: totalBalance ? /* @__PURE__ */ jsxRuntimeExports.jsx(TotalBalance, { total: totalBalance.total, fiatUnit: totalBalance.fiatUnit }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
      ] }) })
    ] }) })
  ] });
}
const container$f = "_container_1mptn_1";
const main = "_main_1mptn_8";
const walletConnect$1 = "_walletConnect_1mptn_17";
const styles$h = {
  container: container$f,
  main,
  walletConnect: walletConnect$1
};
const BuyReceiveCTA = ({ code, unit: unit2, balanceList, exchangeBuySupported = true, account: account2 }) => {
  const formattedUnit = isBitcoinCoin(unit2) ? "BTC" : unit2;
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  const onBuyCTA = () => route(code ? `/buy/info/${code}` : "/buy/info");
  const onWalletConnect = () => route(`/account/${code}/wallet-connect/dashboard`);
  const onReceiveCTA = () => {
    if (balanceList) {
      if (balanceList.length > 1) {
        route("accounts/select-receive");
        return;
      }
      route(`/account/${code}/receive`);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$h.main}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.looksEmpty") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.start") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.container, children: [
      balanceList && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onReceiveCTA, children: formattedUnit ? t2("receive.title", { accountName: formattedUnit }) : t2("receive.title", { accountName: t2("buy.info.crypto") }) }),
      exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onBuyCTA, children: formattedUnit ? t2("accountInfo.buyCTA.buy", { unit: formattedUnit }) : t2("accountInfo.buyCTA.buyCrypto") }),
      account2 && isEthereumBased(account2.coinCode) && !account2.isToken && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onWalletConnect, className: styles$h.walletConnect, children: isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
      ] }) })
    ] })
  ] });
};
const AddBuyReceiveOnEmptyBalances = ({ balances, accounts }) => {
  const mounted = useMountedRef();
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState();
  const onlyHasOneActiveAccount = accounts.length === 1;
  reactExports.useEffect(() => {
    if (mounted.current) {
      getExchangeSupportedAccounts(accounts).then((supportedAccounts2) => {
        if (mounted.current) {
          setSupportedAccounts(supportedAccounts2);
        }
      }).catch(console.error);
    }
  }, [accounts, mounted]);
  if (balances === void 0 || supportedAccounts === void 0) {
    return null;
  }
  const balanceList = accounts.map((account2) => balances[account2.code]).filter((balance2) => !!balance2);
  if (balanceList.some((entry2) => entry2.hasAvailable)) {
    return null;
  }
  if (balanceList.map((entry2) => entry2.available.unit).every(isBitcoinCoin)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { code: onlyHasOneActiveAccount ? accounts[0].code : void 0, unit: "BTC", balanceList });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { exchangeBuySupported: supportedAccounts.length > 0, balanceList });
};
function AccountsSummary({
  accounts,
  devices
}) {
  const { t: t2 } = useTranslation();
  const summaryReqTimerID = reactExports.useRef();
  const mounted = useMountedRef();
  const { hideAmounts } = reactExports.useContext(AppContext);
  const accountsByKeystore = getAccountsByKeystore(accounts);
  const [summaryData, setSummaryData] = reactExports.useState();
  const [balancePerCoin, setBalancePerCoin] = reactExports.useState();
  const [accountsTotalBalance, setAccountsTotalBalance] = reactExports.useState();
  const [balances, setBalances] = reactExports.useState();
  const hasCard = useSDCard(devices);
  const getAccountSummary = reactExports.useCallback(async () => {
    if (summaryReqTimerID.current) {
      window.clearTimeout(summaryReqTimerID.current);
    }
    try {
      const summaryData2 = await getSummary();
      if (!mounted.current) {
        return;
      }
      setSummaryData(summaryData2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]);
  const getAccountsBalance$1 = reactExports.useCallback(async () => {
    try {
      const balance2 = await getAccountsBalance();
      if (!mounted.current) {
        return;
      }
      setBalancePerCoin(balance2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]);
  const getAccountsTotalBalance$1 = reactExports.useCallback(async () => {
    const totalBalance = await getAccountsTotalBalance();
    if (!mounted.current) {
      return;
    }
    if (totalBalance.success) {
      setAccountsTotalBalance(totalBalance.totalBalance);
    } else {
      if (totalBalance.errorCode !== "ratesNotAvailable") {
        console.error(totalBalance.errorMessage);
      } else {
        console.log("rates not available");
      }
    }
  }, [mounted]);
  const onStatusChanged = reactExports.useCallback(async (code) => {
    if (!mounted.current) {
      return;
    }
    const status2 = await getStatus$2(code);
    if (status2.disabled || !mounted.current) {
      return;
    }
    if (!status2.synced) {
      return init(code);
    }
    const balance2 = await getBalance(code);
    if (!mounted.current) {
      return;
    }
    setBalances((prevBalances) => ({
      ...prevBalances,
      [code]: balance2
    }));
  }, [mounted]);
  const update = reactExports.useCallback((code) => {
    if (mounted.current) {
      onStatusChanged(code);
      getAccountSummary();
    }
  }, [getAccountSummary, mounted, onStatusChanged]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      statusChanged$1(update),
      syncdone(update)
    ];
    getAccountSummary();
    getAccountsBalance$1();
    getAccountsTotalBalance$1();
    return () => unsubscribe(subscriptions2);
  }, [getAccountSummary, getAccountsBalance$1, getAccountsTotalBalance$1, update]);
  reactExports.useEffect(() => {
    const delay2 = !summaryData || summaryData.chartDataMissing ? 1e3 : 1e4;
    summaryReqTimerID.current = window.setTimeout(getAccountSummary, delay2);
    return () => {
      if (summaryReqTimerID.current) {
        window.clearTimeout(summaryReqTimerID.current);
      }
    };
  }, [summaryData, getAccountSummary]);
  reactExports.useEffect(() => {
    accounts.forEach((account2) => {
      onStatusChanged(account2.code);
    });
    getAccountsBalance$1();
  }, [onStatusChanged, getAccountsBalance$1, accounts]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountSummary.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HOC$2,
          {
            hideAmounts,
            data: summaryData,
            noDataPlaceholder: accounts.length && accounts.length <= Object.keys(balances || {}).length ? /* @__PURE__ */ jsxRuntimeExports.jsx(AddBuyReceiveOnEmptyBalances, { accounts, balances }) : void 0
          }
        ),
        accountsByKeystore && accountsByKeystore.map(
          ({ keystore: keystore2, accounts: accounts2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            SummaryBalance,
            {
              keystoreDisambiguatorName: isAmbiguiousName(keystore2.name, accountsByKeystore) ? keystore2.rootFingerprint : void 0,
              connected: keystore2.connected,
              keystoreName: keystore2.name,
              accounts: accounts2,
              totalBalancePerCoin: balancePerCoin ? balancePerCoin[keystore2.rootFingerprint] : void 0,
              totalBalance: accountsTotalBalance ? accountsTotalBalance[keystore2.rootFingerprint] : void 0,
              balances
            },
            keystore2.rootFingerprint
          )
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSummaryDescription") }, "accountSummaryDescription"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: "www.coingecko.com",
          url: "https://www.coingecko.com/"
        },
        text: t2("guide.accountSummaryAmount.text"),
        title: t2("guide.accountSummaryAmount.title")
      } }, "accountSummaryAmount"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.trackingModePortfolioChart") }, "trackingModePortfolioChart")
    ] })
  ] });
}
const URL_CONSTANTS = {
  DOWNLOAD_LINK_GLOBAL: "https://bitbox.swiss/download/?source=bitboxapp",
  DOWNLOAD_LINK_DE: "https://bitbox.swiss/de/download/?source=bitboxapp",
  DOWNLOAD_LINK_ES: "https://bitbox.swiss/es/descargar/?source=bitboxapp"
};
const downloadLinkByLanguage = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return URL_CONSTANTS.DOWNLOAD_LINK_DE;
    case "es":
      return URL_CONSTANTS.DOWNLOAD_LINK_ES;
    default:
      return URL_CONSTANTS.DOWNLOAD_LINK_GLOBAL;
  }
};
const AppDownloadLink = ({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: t2("button.download") });
};
const AppDownloadButton = ({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, children: t2("button.download") }) });
};
const AppUpgradeRequired = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        verticallyCentered: true,
        width: "840px",
        withBottomBar: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("device.appUpradeRequired") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadButton, {}) })
        ]
      }
    )
  ] });
};
const capsWarning = "_capsWarning_1xqma_1";
const style$o = {
  capsWarning
};
function PasswordInput(props) {
  const { seePlaintext, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: seePlaintext ? "text" : "password",
      ...rest
    }
  );
}
class PasswordSingleInputClass extends reactExports.Component {
  state = {
    password: "",
    seePlaintext: false,
    capsLock: false
  };
  password = reactExports.createRef();
  idPrefix = () => {
    return this.props.idPrefix || "";
  };
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a;
    if (this.props.pattern) {
      this.regex = new RegExp(this.props.pattern);
    }
    if (this.props.autoFocus && ((_a = this.password) == null ? void 0 : _a.current)) {
      this.password.current.focus();
    }
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  tryPaste = (event2) => {
    if (event2.target.type === "password") {
      event2.preventDefault();
      alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      }));
    }
  };
  clear = () => {
    this.setState({
      password: "",
      seePlaintext: false,
      capsLock: false
    });
  };
  validate = () => {
    if (this.regex && this.password.current && !this.password.current.validity.valid) {
      return this.props.onValidPassword(null);
    }
    if (this.state.password) {
      this.props.onValidPassword(this.state.password);
    } else {
      this.props.onValidPassword(null);
    }
  };
  handleFormChange = (event2) => {
    let value = event2.target.value;
    if (event2.target.type === "checkbox") {
      value = event2.target.checked;
    }
    const stateKey = event2.target.id.slice(this.idPrefix().length);
    this.setState({ [stateKey]: value }, this.validate);
  };
  handleCheckCaps = (event2) => {
    const capsLock = hasCaps(event2);
    if (capsLock !== null) {
      this.setState({ capsLock });
    }
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      showLabel
    } = this.props;
    const {
      password: password2,
      seePlaintext,
      capsLock
    } = this.state;
    const warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$o.capsWarning,
        title: t2("password.warning.caps"),
        children: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        autoFocus: true,
        disabled: disabled2,
        type: seePlaintext ? "text" : "password",
        pattern,
        title: title2,
        id: this.idPrefix() + "password",
        label: label2,
        placeholder,
        onInput: this.handleFormChange,
        onPaste: this.tryPaste,
        ref: this.password,
        value: password2,
        labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: this.idPrefix() + "seePlaintext",
            onChange: this.handleFormChange,
            checked: seePlaintext,
            label: t2("password.show", {
              label: showLabel || label2
            })
          }
        ),
        children: warning2
      }
    );
  }
}
const PasswordSingleInput = withTranslation(null, { withRef: true })(PasswordSingleInputClass);
class PasswordRepeatInputClass extends reactExports.Component {
  state = {
    password: "",
    passwordRepeat: "",
    seePlaintext: false,
    capsLock: false
  };
  password = reactExports.createRef();
  passwordRepeat = reactExports.createRef();
  idPrefix = () => {
    return this.props.idPrefix || "";
  };
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a;
    if (this.props.pattern) {
      this.regex = new RegExp(this.props.pattern);
    }
    if (this.props.autoFocus && ((_a = this.password) == null ? void 0 : _a.current)) {
      this.password.current.focus();
    }
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  tryPaste = (event2) => {
    if (event2.target.type === "password") {
      event2.preventDefault();
      alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      }));
    }
  };
  validate = () => {
    if (this.regex && this.password.current && this.passwordRepeat.current && (!this.password.current.validity.valid || !this.passwordRepeat.current.validity.valid)) {
      return this.props.onValidPassword(null);
    }
    if (this.state.password && this.state.password === this.state.passwordRepeat) {
      this.props.onValidPassword(this.state.password);
    } else {
      this.props.onValidPassword(null);
    }
  };
  handleFormChange = (event2) => {
    let value = event2.target.value;
    if (event2.target.type === "checkbox") {
      value = event2.target.checked;
    }
    const stateKey = event2.target.id.slice(this.idPrefix().length);
    this.setState({ [stateKey]: value }, this.validate);
  };
  handleCheckCaps = (event2) => {
    const capsLock = hasCaps(event2);
    if (capsLock != null) {
      this.setState({ capsLock });
    }
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      repeatLabel,
      repeatPlaceholder,
      showLabel
    } = this.props;
    const {
      password: password2,
      passwordRepeat,
      seePlaintext,
      capsLock
    } = this.state;
    const warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$o.capsWarning,
        title: t2("password.warning.caps"),
        children: ""
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          autoFocus: true,
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "password",
          label: label2,
          placeholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: password2,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: password2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "passwordRepeat",
          label: repeatLabel,
          placeholder: repeatPlaceholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: passwordRepeat,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: passwordRepeat
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          id: this.idPrefix() + "seePlaintext",
          onChange: this.handleFormChange,
          checked: seePlaintext,
          label: t2("password.show", {
            label: showLabel || label2
          })
        }
      ) })
    ] });
  }
}
const PasswordRepeatInput = withTranslation(null, { withRef: true })(PasswordRepeatInputClass);
function MatchesPattern({ regex, value = "", text: text2 }) {
  if (!regex || !value.length || regex.test(value)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--color-error)" }, children: text2 });
}
const excludeKeys = /^(Shift|Alt|Backspace|CapsLock|Tab)$/i;
function hasCaps({ key }) {
  if (key.length > 1 || key.toUpperCase() === key.toLowerCase() || excludeKeys.test(key)) {
    return null;
  }
  return key.toUpperCase() === key && key.toLowerCase() !== key && !event.shiftKey;
}
const stateEnum$1 = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
let Unlock$1 = class Unlock extends reactExports.Component {
  state = {
    status: stateEnum$1.DEFAULT,
    errorMessage: "",
    errorCode: null,
    remainingAttempts: null,
    needsLongTouch: false,
    password: ""
  };
  handleFormChange = (password2) => {
    this.setState({ password: password2 });
  };
  validate = () => {
    return this.state.password !== "";
  };
  handleSubmit = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      status: stateEnum$1.WAITING
    });
    apiPost("devices/" + this.props.deviceID + "/login", { password: this.state.password }).then((data) => {
      if (data.success) {
        apiGet("devices/" + this.props.deviceID + "/status").then((status2) => {
          if (status2 === "seeded") {
            console.info("unlock.jsx route to /account-summary");
            route("/account-summary", true);
          }
        });
      }
      if (!data.success) {
        if (data.code) {
          this.setState({ errorCode: data.code });
        }
        if (data.remainingAttempts) {
          this.setState({ remainingAttempts: data.remainingAttempts });
        }
        if (data.needsLongTouch) {
          this.setState({ needsLongTouch: data.needsLongTouch });
        }
        this.setState({ status: stateEnum$1.ERROR, errorMessage: data.errorMessage });
      }
    });
    this.setState({ password: "" });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      status: status2,
      password: password2,
      errorCode,
      errorMessage: errorMessage2,
      remainingAttempts,
      needsLongTouch
    } = this.state;
    let submissionState = null;
    switch (status2) {
      case stateEnum$1.DEFAULT:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("unlock.description") });
        break;
      case stateEnum$1.WAITING:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("unlock.unlocking") });
        break;
      case stateEnum$1.ERROR:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`unlock.error.e${errorCode}`, {
          defaultValue: errorMessage2,
          remainingAttempts,
          context: needsLongTouch ? "touch" : "normal"
        }) });
        break;
    }
    const darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content narrow padded isVerticallyCentered", children: [
          darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            submissionState,
            status2 !== stateEnum$1.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordSingleInput,
                {
                  autoFocus: true,
                  id: "password",
                  type: "password",
                  label: t2("unlock.input.label"),
                  disabled: status2 === stateEnum$1.WAITING,
                  placeholder: t2("unlock.input.placeholder"),
                  onValidPassword: this.handleFormChange,
                  value: password2
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  type: "submit",
                  disabled: !this.validate() || status2 === stateEnum$1.WAITING,
                  children: t2("button.unlock")
                }
              ) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.forgotDevicePassword") }, "guide.unlock.forgotDevicePassword"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.reset") }, "guide.unlock.reset")
      ] })
    ] });
  }
};
const Unlock$2 = withTranslation()(Unlock$1);
const container$e = "_container_17oq2_1";
const scrollable = "_scrollable_17oq2_17";
const agreements$1 = "_agreements_17oq2_22";
const agreementsLabel = "_agreementsLabel_17oq2_26";
const title$3 = "_title_17oq2_30";
const summary = "_summary_17oq2_36";
const heading = "_heading_17oq2_45";
const content = "_content_17oq2_49";
const verticalButtons = "_verticalButtons_17oq2_60";
const block$1 = "_block_17oq2_72";
const list = "_list_17oq2_85";
const buttons = "_buttons_17oq2_93";
const stepNumber = "_stepNumber_17oq2_98";
const badge$2 = "_badge_17oq2_108";
const waitingLogo = "_waitingLogo_17oq2_113";
const waitingContent = "_waitingContent_17oq2_117";
const waitingText = "_waitingText_17oq2_126";
const waitingDescription = "_waitingDescription_17oq2_134";
const qrcodeContainer = "_qrcodeContainer_17oq2_140";
const style$n = {
  container: container$e,
  scrollable,
  agreements: agreements$1,
  agreementsLabel,
  title: title$3,
  summary,
  heading,
  content,
  verticalButtons,
  block: block$1,
  list,
  buttons,
  stepNumber,
  badge: badge$2,
  waitingLogo,
  waitingContent,
  waitingText,
  waitingDescription,
  qrcodeContainer
};
class Bootloader extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      upgrading: false,
      errMsg: null,
      progress: 0,
      upgradeSuccessful: false
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onEvent);
    this.onStatusChanged();
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  onEvent = (data) => {
    if (data.type !== "device") {
      return;
    }
    switch (data.data) {
      case "bootloaderStatusChanged":
        this.onStatusChanged();
        break;
    }
  };
  onStatusChanged = () => {
    apiGet("devices/" + this.props.deviceID + "/bootloader-status").then(({ upgrading, progress, upgradeSuccessful, errMsg }) => {
      this.setState({
        upgrading,
        progress,
        upgradeSuccessful,
        errMsg
      });
    });
  };
  upgradeFirmware = () => {
    apiPost("devices/" + this.props.deviceID + "/bootloader/upgrade-firmware");
  };
  render() {
    const { t: t2 } = this.props;
    const {
      upgrading,
      progress,
      upgradeSuccessful,
      errMsg
    } = this.state;
    let UpgradeOrStatus;
    if (upgrading) {
      if (upgradeSuccessful) {
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bootloader.success") });
      } else {
        const value = Math.round(progress * 100);
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
            value,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none text-center", children: t2("bootloader.progress", {
            progress: value
          }) })
        ] });
      }
    } else {
      UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: this.upgradeFirmware,
          children: t2("bootloader.button")
        }
      ) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$n.container, style$n.scrollable].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        UpgradeOrStatus,
        errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none", children: errMsg })
      ] })
    ] }) }) }) }) });
  }
}
const Bootloader$1 = withTranslation()(Bootloader);
const container$d = "_container_l7fdu_1";
const danger = "_danger_l7fdu_27";
const children = "_children_l7fdu_31";
const optionalText = "_optionalText_l7fdu_35";
const secondaryText$1 = "_secondaryText_l7fdu_46";
const primaryText$1 = "_primaryText_l7fdu_54";
const icon = "_icon_l7fdu_58";
const disabled$1 = "_disabled_l7fdu_63";
const item$2 = "_item_l7fdu_68";
const style$m = {
  container: container$d,
  danger,
  children,
  optionalText,
  secondaryText: secondaryText$1,
  primaryText: primaryText$1,
  icon,
  disabled: disabled$1,
  item: item$2
};
const SettingsButton = ({
  onClick,
  danger: danger2,
  optionalText: optionalText2,
  secondaryText: secondaryText2,
  disabled: disabled2,
  children: children2,
  optionalIcon
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      className: [
        style$m.container,
        danger2 ? style$m.danger : "",
        disabled2 === true ? style$m.disabled : ""
      ].join(" "),
      onClick: !disabled2 ? onClick : void 0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$m.children, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.primaryText, children: children2 }),
          secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.secondaryText, children: secondaryText2 }) : null
        ] }),
        optionalText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.optionalText, children: optionalText2 }) : null,
        optionalIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.icon, children: optionalIcon }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 18 15 12 9 6" }) })
      ]
    }
  );
};
class UpgradeFirmware extends reactExports.Component {
  state = {
    unlocked: false,
    newVersion: "",
    isConfirming: false,
    activeDialog: false
  };
  upgradeFirmware = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/unlock-bootloader").then((success2) => {
      this.setState({
        unlocked: success2,
        isConfirming: success2
      });
    }).catch(() => {
      this.setState({
        isConfirming: false
      });
    });
  };
  componentDidMount() {
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
  }
  abort = () => {
    this.setState({ activeDialog: false });
  };
  render() {
    const {
      t: t2,
      currentVersion,
      disabled: disabled2,
      asButton
    } = this.props;
    const {
      unlocked,
      newVersion,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("upgradeFirmware.button")
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: () => this.setState({ activeDialog: true }),
          disabled: disabled2,
          optionalText: newVersion,
          children: t2("upgradeFirmware.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("upgradeFirmware.title"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.description", {
          currentVersion,
          newVersion
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.upgradeFirmware, children: t2("button.upgrade") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
        ] })
      ] }),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("upgradeFirmware.title"), includeDefault: !unlocked, children: unlocked ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.unlocked") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { style: { lineHeight: "1.5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked3") })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.locked", {
        currentVersion,
        newVersion
      }) }) })
    ] });
  }
}
const UpgradeFirmware$1 = withTranslation()(UpgradeFirmware);
class RequireUpgrade extends reactExports.Component {
  state = {
    firmwareVersion: null
  };
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({ version }) => {
      this.setState({
        firmwareVersion: version.replace("v", "")
      });
    });
  }
  render() {
    const { t: t2, deviceID } = this.props;
    const { firmwareVersion } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$n.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion, asButton: true }) })
      ] })
    ] }) });
  }
}
const RequireUpgrade$1 = withTranslation()(RequireUpgrade);
class Goal extends reactExports.Component {
  render() {
    const {
      t: t2,
      onCreate,
      onRestore
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("goal.paragraph") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onCreate, children: t2("goal.buttons.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: onRestore, children: t2("goal.buttons.restore") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) })
    ] }) });
  }
}
const Goal$1 = withTranslation()(Goal);
class SecurityInformation extends reactExports.Component {
  constructor(props) {
    super(props);
    this.handleStart = () => {
      this.setState({ showInfo: false });
    };
    this.state = {
      showInfo: true
    };
  }
  render() {
    const { t: t2, goBack, goal: goal2, children: children2 } = this.props;
    const { showInfo } = this.state;
    if (!showInfo) {
      return children2;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(`securityInformation.${goal2}.title`) }),
        goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$n.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description4") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$n.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description2") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("securityInformation.restore.description3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "warning", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("deviceTampered") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) })
    ] }) });
  }
}
const translatedSecutiryInformation = translate()(SecurityInformation);
const STATUS$1 = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
});
class SeedCreateNew extends reactExports.Component {
  state = {
    showInfo: true,
    status: STATUS$1.CHECKING,
    walletName: "",
    backupPassword: "",
    error: "",
    agreements: {
      password_change: false,
      password_required: false,
      funds_access: false
    }
  };
  walletNameInput = reactExports.createRef();
  componentDidMount() {
    this.checkSDcard();
  }
  validate = () => {
    if (!this.walletNameInput.current || !this.walletNameInput.current.validity.valid || !this.validAgreements()) {
      return false;
    }
    return this.state.backupPassword && this.state.walletName !== "";
  };
  handleFormChange = ({ target }) => {
    this.setState({ [target.id]: target.value });
  };
  handleSubmit = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ status: STATUS$1.CREATING, error: "" });
    apiPost("devices/" + this.props.deviceID + "/create-wallet", {
      walletName: this.state.walletName,
      backupPassword: this.state.backupPassword
    }).then((data) => {
      if (!data.success) {
        this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t(`seed.error.e${data.code}`, {
            defaultValue: data.errorMessage
          })
        });
      } else {
        this.props.onSuccess();
      }
      this.setState({ backupPassword: "" });
    });
  };
  setValidBackupPassword = (backupPassword) => {
    this.setState({ backupPassword });
  };
  validAgreements = () => {
    const { agreements: agreements2 } = this.state;
    const invalid = Object.keys(agreements2).map((agr) => agreements2[agr]).includes(false);
    return !invalid;
  };
  handleAgreementChange = ({ target }) => {
    this.setState((state) => ({ agreements: {
      ...state.agreements,
      [target.id]: target.checked
    } }));
  };
  checkSDcard = () => {
    getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
      if (sdcard) {
        return this.setState({ status: STATUS$1.DEFAULT, error: "" });
      }
      this.setState({
        status: STATUS$1.ERROR,
        error: this.props.t("seed.error.e200")
      });
      setTimeout(this.checkSDcard, 2500);
    });
  };
  handleStart = () => {
    this.setState({ showInfo: false });
    this.checkSDcard();
  };
  renderSpinner() {
    switch (this.state.status) {
      case STATUS$1.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("checkSDcard") });
      case STATUS$1.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      goBack
    } = this.props;
    const {
      showInfo,
      status: status2,
      walletName,
      error: error3,
      agreements: agreements2
    } = this.state;
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: this.handleStart,
            disabled: status2 !== STATUS$1.DEFAULT,
            children: t2("seed.info.button")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            pattern: "^[0-9a-zA-Z-_]{1,31}$",
            autoFocus: true,
            id: "walletName",
            label: t2("seed.walletName.label"),
            disabled: status2 === STATUS$1.CREATING,
            onInput: this.handleFormChange,
            ref: this.walletNameInput,
            value: walletName
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PasswordRepeatInput,
          {
            label: t2("seed.password.label"),
            repeatPlaceholder: t2("seed.password.repeatPlaceholder"),
            disabled: status2 === STATUS$1.CREATING,
            onValidPassword: this.setValidBackupPassword
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$n.agreements, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { width: 18, marginRight: 10, position: "relative", bottom: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$n.agreementsLabel, children: t2("seed.description") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_change",
            label: t2("seed.agreements.password-change"),
            checked: agreements2.password_change,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_required",
            label: t2("seed.agreements.password-required"),
            checked: agreements2.password_required,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "funds_access",
            label: t2("seed.agreements.funds-access"),
            checked: agreements2.funds_access,
            onChange: this.handleAgreementChange
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: true,
            disabled: !this.validate() || status2 === STATUS$1.CREATING,
            children: t2("seed.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2("seed.info.title") }),
          error3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS$1.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }),
          content2,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
}
const SeedCreateNew$1 = withTranslation()(SeedCreateNew);
const convertDateToLocaleString = (date2, language2) => {
  return new Date(date2).toLocaleString(language2, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  });
};
const stepContext = "_stepContext_g2o2c_1";
const backupsList = "_backupsList_g2o2c_5";
const listContainer$1 = "_listContainer_g2o2c_14";
const item$1 = "_item_g2o2c_24";
const agreements = "_agreements_g2o2c_37";
const emptyText = "_emptyText_g2o2c_41";
const backupItem = "_backupItem_g2o2c_47";
const backupID = "_backupID_g2o2c_52";
const backupButtons = "_backupButtons_g2o2c_59";
const backupStyle = {
  stepContext,
  backupsList,
  listContainer: listContainer$1,
  item: item$1,
  agreements,
  emptyText,
  backupItem,
  backupID,
  backupButtons
};
const BackupsListItem = ({
  backup: backup2,
  disabled: disabled2,
  handleChange,
  onFocus: onFocus2,
  radio: radio2,
  selectedBackup
}) => {
  let date2 = "";
  if (backup2.date && backup2.date !== "") {
    date2 = convertDateToLocaleString(backup2.date, instance.language);
  } else {
    date2 = "unknown";
  }
  return radio2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Radio,
    {
      disabled: !!disabled2,
      checked: selectedBackup === backup2.id,
      onChange: (event2) => {
        handleChange && handleChange(event2.target.value);
      },
      id: backup2.id,
      label: backup2.name && backup2.name !== "" ? backup2.name : backup2.id,
      value: backup2.id,
      onFocus: onFocus2,
      className: backupStyle.backupItem,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-small text-gray", children: date2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-small text-gray", children: [
          "ID: ",
          backup2.id
        ] })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-medium m-bottom-quarter", children: backup2.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupID, children: [
      "ID: ",
      backup2.id
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-small text-gray", children: date2 })
  ] });
};
let Check$1 = class Check extends reactExports.Component {
  state = {
    password: null,
    activeDialog: false,
    message: null
  };
  abort = () => {
    this.setState({
      password: null,
      activeDialog: false,
      message: null
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return this.props.selectedBackup && this.state.password;
  };
  check = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ message: this.props.t("backup.check.checking") });
    apiPost("devices/" + this.props.deviceID + "/backups/check", {
      password: this.state.password,
      filename: this.props.selectedBackup
    }).catch(() => {
    }).then(({ success: success2, matches, errorMessage: errorMessage2 }) => {
      let message2;
      if (success2) {
        if (matches) {
          message2 = this.props.t("backup.check.ok");
        } else {
          message2 = this.props.t("backup.check.notOK");
        }
      } else if (errorMessage2) {
        message2 = errorMessage2;
      }
      this.setState({ message: message2 });
    });
  };
  setValidPassword = (password2) => {
    this.setState({ password: password2 });
  };
  render() {
    const {
      t: t2,
      selectedBackup
    } = this.props;
    const {
      activeDialog,
      message: message2
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          secondary: true,
          disabled: selectedBackup === null,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.check")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.check.title"),
          onClose: this.abort,
          children: message2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { minHeight: "3rem" }, children: message2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.check, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordSingleInput,
              {
                label: t2("backup.check.password.label"),
                placeholder: t2("backup.check.password.placeholder"),
                showLabel: t2("backup.check.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: true, disabled: !this.validate(), children: t2("button.check") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
            ] })
          ] })
        }
      )
    ] });
  }
};
const Check$2 = withTranslation()(Check$1);
let Create$1 = class Create extends reactExports.Component {
  state = {
    waiting: false,
    backupName: "",
    recoveryPassword: "",
    activeDialog: false
  };
  abort = () => {
    this.setState({
      waiting: false,
      backupName: "",
      recoveryPassword: "",
      activeDialog: false
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return !this.state.waiting && this.state.backupName !== "";
  };
  create = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ waiting: true });
    apiPost("devices/" + this.props.deviceID + "/backups/create", {
      backupName: this.state.backupName,
      recoveryPassword: this.state.recoveryPassword
    }).then((data) => {
      this.abort();
      if (!data.success) {
        alertUser(data.errorMessage);
      } else {
        this.props.onCreate();
        if (!data.verification) {
          alertUser(this.props.t("backup.create.verificationFailed"));
        }
      }
    });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      waiting,
      recoveryPassword,
      backupName,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.create")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.create.title"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.create, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: true,
                id: "backupName",
                label: t2("backup.create.name.label"),
                placeholder: t2("backup.create.name.placeholder"),
                onInput: this.handleFormChange,
                value: backupName
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.create.info") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                id: "recoveryPassword",
                label: t2("backup.create.password.label"),
                placeholder: t2("backup.create.password.placeholder"),
                onInput: this.handleFormChange,
                value: recoveryPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: true, disabled: waiting || !this.validate(), children: t2("button.create") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.abort") })
            ] })
          ] })
        }
      )
    ] });
  }
};
const Create$2 = withTranslation()(Create$1);
class Restore extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      isConfirming: false,
      activeDialog: false,
      isLoading: false,
      understand: false,
      password: void 0
    };
    this.abort = () => {
      this.setState({
        isConfirming: false,
        activeDialog: false,
        isLoading: false,
        understand: false,
        password: void 0
      });
    };
    this.validate = () => {
      return this.props.selectedBackup && this.state.password;
    };
    this.restore = (event2) => {
      event2.preventDefault();
      if (!this.validate()) {
        return;
      }
      if (this.props.requireConfirmation) {
        this.setState({
          activeDialog: false,
          isConfirming: true
        });
      } else {
        this.setState({
          activeDialog: false,
          isLoading: true
        });
      }
      apiPost("devices/" + this.props.deviceID + "/backups/restore", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).then((data) => {
        const { success: success2, didRestore, errorMessage: errorMessage2, code } = data;
        this.abort();
        if (success2) {
          if (didRestore) {
            if (this.props.onRestore) {
              return this.props.onRestore();
            }
            console.info("restore.jsx route to /");
            route("/", true);
          }
        } else {
          alertUser(this.props.t(`backup.restore.error.e${code}`, {
            defaultValue: errorMessage2
          }));
        }
      });
    };
    this.handleUnderstandChange = (e3) => {
      this.setState({ understand: e3.target.checked });
    };
    this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
  }
  render() {
    const {
      t: t2,
      selectedBackup,
      requireConfirmation
    } = this.props;
    const {
      isConfirming,
      activeDialog,
      isLoading,
      understand
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          ...requireConfirmation ? { danger: true } : { primary: true },
          disabled: !selectedBackup,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.restore")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.restore.title"),
          disableEscape: isConfirming || isLoading,
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.restore, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                label: t2("backup.restore.password.label"),
                placeholder: t2("backup.restore.password.placeholder"),
                repeatPlaceholder: t2("backup.restore.password.repeatPlaceholder"),
                showLabel: t2("backup.restore.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("backup.restore.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "submit",
                  ...requireConfirmation ? { danger: true } : { primary: true },
                  disabled: !understand || !this.validate() || isConfirming,
                  children: t2("button.restore")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: this.abort,
                  disabled: isConfirming,
                  children: t2("button.back")
                }
              )
            ] })
          ] })
        }
      ),
      isConfirming && requireConfirmation && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.restore.confirmTitle") }),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("backup.restore.restoring") })
    ] });
  }
}
const TranslatedRestore = translate()(Restore);
class Backups extends reactExports.Component {
  constructor(props) {
    super(props);
    this.scrollableContainer = reactExports.createRef();
    this.refresh = () => {
      getDeviceInfo$1(this.props.deviceID).then(({ lock }) => this.setState({ lock }));
      apiGet("devices/" + this.props.deviceID + "/backups/list").then(({ sdCardInserted, backupList, success: success2, errorMessage: errorMessage2 }) => {
        if (success2) {
          this.setState({
            sdCardInserted,
            backupList
          });
        } else if (errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.handleBackuplistChange = (backupID2) => {
      this.setState({ selectedBackup: backupID2 });
    };
    this.scrollIntoView = (event2) => {
      if (!this.scrollableContainer.current) {
        return;
      }
      const target = event2.target;
      const offsetTop = target.offsetTop;
      const offsetHeight = target.parentNode.offsetHeight;
      if (offsetTop > this.scrollableContainer.current.scrollTop + offsetHeight) {
        return;
      }
      const top = Math.max(offsetTop + offsetHeight - this.scrollableContainer.current.offsetHeight, 0);
      this.scrollableContainer.current.scroll({ top, behavior: "smooth" });
    };
    this.state = {
      backupList: [],
      sdCardInserted: null
    };
  }
  componentDidMount() {
    this.refresh();
  }
  render() {
    const {
      t: t2,
      children: children2,
      showCreate = false,
      showRestore = true,
      deviceID,
      requireConfirmation = true,
      onRestore
    } = this.props;
    const { backupList, selectedBackup, sdCardInserted, lock } = this.state;
    if (lock === void 0) {
      return null;
    }
    if (sdCardInserted === false) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box m-top-default", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("backup.insert") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.refresh, children: t2("backup.insertButton") }),
          children2
        ] })
      ] });
    } else if (!sdCardInserted) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("backup.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, ref: this.scrollableContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backupList.length ? backupList.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: backup2,
          selectedBackup,
          handleChange: this.handleBackuplistChange,
          onFocus: this.scrollIntoView,
          radio: true
        }
      ) }, backup2.id)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: backupStyle.emptyText, children: t2("backup.noBackups") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        showCreate && !lock && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Create$2,
          {
            onCreate: this.refresh,
            deviceID
          }
        ),
        showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Check$2,
          {
            selectedBackup,
            deviceID
          }
        ),
        showRestore && onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedRestore,
          {
            selectedBackup,
            deviceID,
            onRestore,
            requireConfirmation
          }
        ),
        children2
      ] })
    ] });
  }
}
const TranslatedBackups = translate()(Backups);
const STATUS = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
});
class SeedRestore extends reactExports.Component {
  state = {
    showInfo: true,
    status: STATUS.CHECKING,
    error: ""
  };
  componentDidMount() {
    this.checkSDcard();
  }
  checkSDcard = () => {
    getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
      if (sdcard) {
        return this.setState({ status: STATUS.DEFAULT, error: "" });
      }
      this.setState({
        status: STATUS.ERROR,
        error: this.props.t("seedRestore.error.e200")
      });
      setTimeout(this.checkSDcard, 2500);
    });
  };
  handleStart = () => {
    this.setState({ showInfo: false });
    this.checkSDcard();
  };
  renderSpinner() {
    switch (this.state.status) {
      case STATUS.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("checkSDcard") });
      case STATUS.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      deviceID,
      goBack,
      onSuccess
    } = this.props;
    const {
      showInfo,
      status: status2,
      error: error3
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2("seedRestore.info.title") }),
          error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }) : null,
          showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description3") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seedRestore.info.description4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  onClick: this.handleStart,
                  disabled: status2 !== STATUS.DEFAULT,
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              showCreate: false,
              deviceID,
              requireConfirmation: false,
              onRestore: onSuccess,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
}
const SeedRestore$1 = withTranslation()(SeedRestore);
const stateEnum = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
class Initialize extends reactExports.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = (event2) => {
      event2.preventDefault();
      if (!this.state.password) {
        return;
      }
      this.setState({
        status: stateEnum.WAITING,
        errorCode: null,
        errorMessage: ""
      });
      apiPost("devices/" + this.props.deviceID + "/set-password", {
        password: this.state.password
      }).then((data) => {
        if (!data.success) {
          if (data.code) {
            this.setState({ errorCode: data.code });
          }
          this.setState({
            status: stateEnum.ERROR,
            errorMessage: data.errorMessage
          });
        }
      });
    };
    this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
    this.handleStart = () => {
      this.setState({ showInfo: false });
    };
    this.state = {
      showInfo: true,
      password: null,
      status: stateEnum.DEFAULT,
      errorCode: null,
      errorMessage: ""
    };
  }
  render() {
    const { t: t2, goBack } = this.props;
    const { showInfo, password: password2, status: status2, errorCode, errorMessage: errorMessage2 } = this.state;
    let formSubmissionState;
    switch (status2) {
      case stateEnum.DEFAULT:
        formSubmissionState = null;
        break;
      case stateEnum.WAITING:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("initialize.creating") });
        break;
      case stateEnum.ERROR:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`initialize.error.e${errorCode}`, {
          defaultValue: errorMessage2
        }) });
    }
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("initialize.info.subtitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("initialize.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordRepeatInput,
        {
          pattern: "^.{4,}$",
          label: t2("initialize.input.label"),
          repeatLabel: t2("initialize.input.labelRepeat"),
          repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
          disabled: status2 === stateEnum.WAITING,
          onValidPassword: this.setValidPassword
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: true,
            disabled: !password2 || status2 === stateEnum.WAITING,
            children: t2("initialize.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(showInfo ? "initialize.info.title" : "setup") }),
        formSubmissionState,
        content2,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) }),
      status2 === stateEnum.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("initialize.creating") })
    ] }) });
  }
}
const TranslatedInitialize = translate()(Initialize);
class Success extends reactExports.Component {
  handleGetStarted = () => {
    route("/account-summary", true);
  };
  render() {
    const {
      t: t2,
      handleHideSuccess,
      goal: goal2
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(`success.${goal2}.title`) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { textAlign: "center" }, children: t2(`success.${goal2}.summary`) }),
          goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$n.summary, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info3") })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleGetStarted, children: t2("success.getstarted") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: handleHideSuccess, children: t2("sidebar.device") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] })
    ] }) }) });
  }
}
const Success$1 = withTranslation()(Success);
class Blink extends reactExports.Component {
  blinkDevice = () => {
    apiPost("devices/" + this.props.deviceID + "/blink");
  };
  render() {
    const { t: t2 } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.blinkDevice, children: t2("blink.button") });
  }
}
const Blink$1 = withTranslation()(Blink);
class LegacyHiddenWallet extends reactExports.Component {
  toggle = () => {
    const newValue = !this.props.newHiddenWallet;
    apiPost("devices/" + this.props.deviceID + "/feature-set", {
      new_hidden_wallet: newValue
    }).then(() => {
      if (newValue) {
        alertUser(this.props.t("legacyhiddenwallet.successDisable"));
      } else {
        alertUser(this.props.t("legacyhiddenwallet.successEnable"));
      }
      if (this.props.onChange) {
        this.props.onChange(newValue);
      }
    });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      newHiddenWallet
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        danger: true,
        disabled: disabled2,
        onclick: this.toggle,
        children: newHiddenWallet ? t2("legacyhiddenwallet.enable") : t2("legacyhiddenwallet.disable")
      }
    );
  }
}
const LegacyHiddenWallet$1 = withTranslation()(LegacyHiddenWallet);
class RandomNumber extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      active: false,
      number: ""
    };
  }
  getRandomNumber = () => {
    apiPost(this.props.apiPrefix + "/random-number").then((number) => {
      this.setState({
        active: true,
        number
      });
    });
  };
  abort = () => {
    this.setState({
      active: false,
      number: void 0
    });
  };
  render() {
    const { t: t2 } = this.props;
    const { number, active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.getRandomNumber, children: t2("random.button") }),
      // @ts-ignore Object is possibly 'undefined'.
      active2 && number ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: "Generate Random Number", onClose: this.abort, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("random.description", {
            // @ts-ignore
            bits: number.length * 4
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: number, flexibleHeight: true })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.abort, children: t2("button.ok") }) })
      ] }) : null
    ] });
  }
}
const RandomNumber$1 = withTranslation()(RandomNumber);
class HiddenWallet extends reactExports.Component {
  state = {
    password: null,
    pin: null,
    isConfirming: false,
    activeDialog: false
  };
  abort = () => {
    this.setState({
      password: null,
      isConfirming: false,
      activeDialog: false
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return this.state.password && this.state.pin;
  };
  createHiddenWallet = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/set-hidden-password", {
      pin: this.state.pin,
      backupPassword: this.state.password
    }).catch(() => {
    }).then(({ success: success2, didCreate, errorMessage: errorMessage2, code }) => {
      this.abort();
      if (success2) {
        if (didCreate) {
          alertUser(this.props.t("hiddenWallet.success"));
        }
      } else {
        alertUser(this.props.t(`bitbox.error.e${code}`, {
          defaultValue: errorMessage2
        }));
      }
    });
  };
  setValidPassword = (password2) => {
    this.setState({ password: password2 });
  };
  setValidPIN = (pin) => {
    this.setState({ pin });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props;
    const {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.hiddenwallet")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("button.hiddenwallet"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info1HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info2HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.createHiddenWallet, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "pin",
                  pattern: "^.{4,}$",
                  label: t2("hiddenWallet.pinLabel"),
                  repeatLabel: t2("hiddenWallet.pinRepeatLabel"),
                  repeatPlaceholder: t2("hiddenWallet.pinRepeatPlaceholder"),
                  onValidPassword: this.setValidPIN
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "password",
                  label: t2("hiddenWallet.passwordLabel"),
                  repeatPlaceholder: t2("hiddenWallet.passwordPlaceholder"),
                  onValidPassword: this.setValidPassword
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: true, disabled: !this.validate() || isConfirming, children: t2("button.hiddenwallet") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.abort") })
              ] })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.hiddenwallet") })
    ] });
  }
}
const HiddenWallet$1 = withTranslation()(HiddenWallet);
class ChangePIN extends reactExports.Component {
  state = {
    oldPIN: null,
    newPIN: null,
    errorCode: null,
    isConfirming: false,
    activeDialog: false
  };
  abort = () => {
    this.setState({
      oldPIN: null,
      newPIN: null,
      isConfirming: false,
      activeDialog: false
    });
  };
  validate = () => {
    return this.state.newPIN && this.state.oldPIN;
  };
  changePin = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/change-password", {
      oldPIN: this.state.oldPIN,
      newPIN: this.state.newPIN
    }).catch(() => {
    }).then((data) => {
      this.abort();
      if (!data.success) {
        alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }
    });
  };
  setValidOldPIN = (e3) => {
    this.setState({ oldPIN: e3.target.value });
  };
  setValidNewPIN = (newPIN) => {
    this.setState({ newPIN });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props;
    const {
      oldPIN,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.changepin")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("button.changepin"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.changePin, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "oldPIN",
                label: t2("changePin.oldLabel"),
                value: oldPIN,
                onInput: this.setValidOldPIN
              }
            ),
            t2("changePin.newTitle") && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("changePin.newTitle") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                idPrefix: "newPIN",
                pattern: "^.{4,}$",
                label: t2("initialize.input.label"),
                repeatLabel: t2("initialize.input.labelRepeat"),
                repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
                onValidPassword: this.setValidNewPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: true, disabled: !this.validate() || isConfirming, children: t2("button.changepin") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ] })
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.changepin") })
    ] });
  }
}
const ChangePIN$1 = withTranslation()(ChangePIN);
class Reset extends reactExports.Component {
  state = {
    pin: null,
    isConfirming: false,
    activeDialog: false,
    understand: false
  };
  handleUnderstandChange = (e3) => {
    this.setState({ understand: e3.target.checked });
  };
  resetDevice = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/reset", { pin: this.state.pin }).then((data) => {
      this.abort();
      if (data.success) {
        if (data.didReset) {
          route("/", true);
        }
      } else if (data.errorMessage) {
        alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }
    });
  };
  setValidPIN = (e3) => {
    this.setState({ pin: e3.target.value });
  };
  abort = () => {
    this.setState({
      pin: null,
      understand: false,
      isConfirming: false,
      activeDialog: false
    });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      isConfirming,
      activeDialog,
      understand,
      pin
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { danger: true, onClick: () => this.setState({ activeDialog: true }), children: t2("reset.title") }),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("reset.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "pin",
                label: t2("initialize.input.label"),
                value: pin,
                onInput: this.setValidPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$n.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("reset.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, disabled: !pin || !understand, onClick: this.resetDevice, children: t2("reset.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("reset.title") }) : null
    ] });
  }
}
const Reset$1 = withTranslation()(Reset);
const appStoreBadge = "" + new URL("app-store-badge.svg", import.meta.url).href;
const playStoreBadge = "" + new URL("google-play-badge.png", import.meta.url).href;
class MobilePairing extends reactExports.Component {
  constructor(props) {
    super(props);
    this.onDeviceStatus = (payload) => {
      if ("type" in payload) {
        const { type: type2, data, deviceID } = payload;
        if (type2 === "device" && deviceID === this.props.deviceID) {
          switch (data) {
            case "pairingStarted":
              this.setState({ status: "started" });
              break;
            case "pairingTimedout":
              if (this.state.status) {
                this.setState({ status: "timeout" });
              }
              break;
            case "pairingPullMessageFailed":
              this.setState({ status: "pullFailed" });
              break;
            case "pairingScanningFailed":
              this.setState({ status: "scanningFailed" });
              break;
            case "pairingAborted":
              this.setState({ status: "aborted" });
              break;
            case "pairingError":
              this.setState({ status: "error" });
              break;
            case "pairingSuccess":
              this.setState({ status: "success" });
              break;
          }
        }
      }
    };
    this.reconnectUnpaired = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        if (!response) {
          return;
        }
        apiPost("devices/" + this.props.deviceID + "/feature-set", {
          pairing: true
        }).then(() => {
          this.props.onPairingEnabled();
          alertUser(this.props.t("pairing.success.text"));
        });
      });
    };
    this.startPairing = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        if (!response) {
          return;
        }
        this.setState({
          channel: null,
          status: "loading"
        });
        apiPost("devices/" + this.props.deviceID + "/pairing/start").then((channel) => {
          if (this.props.deviceLocked) {
            this.setState({
              channel,
              status: "connectOnly"
            });
          } else {
            this.setState({
              channel,
              status: "start"
            });
          }
        });
      });
    };
    this.abort = () => {
      this.setState({
        showQRCode: false,
        status: false
      });
    };
    this.toggleQRCode = () => {
      this.setState({ showQRCode: !this.state.showQRCode });
    };
    this.state = {
      channel: null,
      status: false,
      showQRCode: false
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onDeviceStatus);
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  render() {
    const { t: t2, deviceLocked, paired, hasMobileChannel: hasMobileChannel2 } = this.props;
    const { channel, status: status2, showQRCode } = this.state;
    let content2;
    if (status2 === "start") {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "1." }),
            " ",
            t2("pairing.start.step1")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.toggleQRCode, className: "width-1-1", children: t2(`pairing.start.${showQRCode ? "hideAppQRCode" : "revealAppQRCode"}`) }) }),
          showQRCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Apple App Store" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", size: 148 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: appStoreBadge, className: style$n.badge }) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Google Play Store" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", size: 148 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playStoreBadge, className: style$n.badge }) })
              ] })
            ] })
          ] }) }) : null
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "2." }),
            t2("pairing.start.step2")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: JSON.stringify(channel), size: 196 }) })
        ] }) })
      ] });
    } else if (status2 === "connectOnly") {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: JSON.stringify({ channel, connectOnly: true }) });
    } else {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2(`pairing.${status2}.text`) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: hasMobileChannel2 && !paired ? this.reconnectUnpaired : this.startPairing,
          optionalText: t2(`deviceSettings.pairing.status.${paired}`),
          children: deviceLocked ? hasMobileChannel2 ? t2("pairing.reconnectOnly.button") : t2("pairing.connectOnly.button") : hasMobileChannel2 && !paired ? t2("pairing.reconnectOnly.button") : t2("pairing.button")
        }
      ),
      status2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("pairing.title"),
          onClose: this.abort,
          medium: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-center flex-items-center", children: channel ? content2 : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("loading") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") }) })
          ]
        }
      )
    ] });
  }
}
const translatedMobilePairing = translate()(MobilePairing);
class DeviceLock extends reactExports.Component {
  state = {
    isConfirming: false,
    activeDialog: false
  };
  resetDevice = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/lock").then((didLock) => {
      this.setState({
        isConfirming: false
      });
      if (didLock) {
        this.props.onLock();
      }
    });
  };
  abort = () => {
    this.setState({ activeDialog: false });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      lock
    } = this.props;
    const {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          danger: true,
          onClick: () => this.setState({ activeDialog: true }),
          disabled: disabled2,
          optionalText: t2(`deviceSettings.pairing.lock.${lock}`),
          children: t2("deviceLock.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("deviceLock.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, onClick: this.resetDevice, children: t2("deviceLock.confirm") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("deviceLock.title") })
    ] });
  }
}
const DeviceLock$1 = withTranslation()(DeviceLock);
const SettingsItem$1 = ({ optionalText: optionalText2, optionalIcon, children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$m.container, style$m.item].join(" "), children: [
    children2,
    optionalText2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.optionalText, children: optionalText2 }),
    optionalIcon
  ] });
};
class Settings extends reactExports.Component {
  state = {
    firmwareVersion: null,
    newVersion: null,
    lock: true,
    name: null,
    spinner: true,
    sdcard: false,
    serial: "",
    pairing: false,
    mobileChannel: false,
    connected: false,
    newHiddenWallet: true
  };
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({
      lock,
      name,
      new_hidden_wallet,
      pairing: pairing2,
      sdcard,
      serial,
      version
    }) => {
      this.setState({
        firmwareVersion: version.replace("v", ""),
        lock,
        name,
        newHiddenWallet: new_hidden_wallet,
        pairing: pairing2,
        sdcard,
        serial,
        spinner: false
      });
    });
    apiGet("devices/" + this.props.deviceID + "/has-mobile-channel").then((mobileChannel) => {
      this.setState({ mobileChannel });
    });
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
    this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "device") {
        if (deviceID !== this.props.deviceID) {
          return;
        }
        switch (data) {
          case "mobileDisconnected":
            this.setState({ connected: false });
            break;
          case "mobileConnected":
            this.setState({ connected: true });
            break;
          case "pairingSuccess":
            this.setState({ pairing: true, mobileChannel: true });
            break;
          case "pairingFalse":
            this.setState({ mobileChannel: false });
            break;
        }
      }
    });
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  render() {
    const {
      t: t2,
      deviceID
    } = this.props;
    const {
      firmwareVersion,
      newVersion,
      lock,
      name,
      spinner: spinner4,
      sdcard,
      serial,
      pairing: pairing2,
      mobileChannel,
      connected,
      newHiddenWallet
    } = this.state;
    const canUpgrade = firmwareVersion && newVersion !== firmwareVersion;
    const paired = pairing2 && mobileChannel;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: name === null ? "" : name || "BitBox" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columnsContainer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.secrets.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: () => route(`/manage-backups/${deviceID}`), children: t2("deviceSettings.secrets.manageBackups") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChangePIN$1, { deviceID }),
                newHiddenWallet ? /* @__PURE__ */ jsxRuntimeExports.jsx(HiddenWallet$1, { deviceID, disabled: lock }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LegacyHiddenWallet$1,
                  {
                    deviceID,
                    newHiddenWallet,
                    disabled: lock,
                    onChange: (value) => this.setState({ newHiddenWallet: value })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Reset$1, { deviceID })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.pairing.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.pairing.mobile.${connected}`), children: t2("deviceSettings.pairing.mobile.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  translatedMobilePairing,
                  {
                    deviceID,
                    deviceLocked: lock,
                    hasMobileChannel: mobileChannel,
                    paired,
                    onPairingEnabled: () => this.setState({ pairing: true })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DeviceLock$1,
                  {
                    lock,
                    deviceID,
                    onLock: () => this.setState({ lock: true }),
                    disabled: lock || !paired
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.firmware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box slim divide", children: canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: `${t2("deviceSettings.firmware.version.label")} ${firmwareVersion ? firmwareVersion : t2("loading")}`, children: t2("deviceSettings.firmware.upToDate") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.hardware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: serial, children: "Serial number" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.hardware.sdcard.${sdcard}`), children: t2("deviceSettings.hardware.sdcard.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(RandomNumber$1, { apiPrefix: "devices/" + deviceID }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Blink$1, { deviceID })
              ] })
            ] })
          ] })
        ] }) }),
        spinner4 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("deviceSettings.loading") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectBitbox") }, "guide.bitbox.ejectBitbox"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectSD") }, "guide.bitbox.ejectSD"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.hiddenWallet") }, "guide.bitbox.hiddenWallet"),
        !lock && newHiddenWallet && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.legacyHiddenWallet"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LegacyHiddenWallet$1,
          {
            deviceID,
            newHiddenWallet,
            onChange: (value) => this.setState({ newHiddenWallet: value })
          }
        ) }) }, "guide.bitbox.legacyHiddenWallet"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.pairing") }, "guide.bitbox.pairing"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.2FA") }, "guide.bitbox.2FA"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.disable2FA") }, "guide.bitbox.disable2FA")
      ] })
    ] });
  }
}
const Settings$1 = withTranslation()(Settings);
const DeviceStatus = Object.freeze({
  BOOTLOADER: "bootloader",
  INITIALIZED: "initialized",
  UNINITIALIZED: "uninitialized",
  LOGGED_IN: "logged_in",
  SEEDED: "seeded",
  REQUIRE_FIRMWARE_UPGRADE: "require_firmware_upgrade",
  REQUIRE_APP_UPGRADE: "require_app_upgrade"
});
const GOAL = Object.freeze({
  CREATE: "create",
  RESTORE: "restore"
});
class Device extends reactExports.Component {
  static contextType = AppContext;
  state = {
    firmwareVersion: null,
    deviceRegistered: false,
    deviceStatus: "",
    goal: "",
    success: null
  };
  componentDidMount() {
    this.onDevicesRegisteredChanged();
    this.onDeviceStatusChanged();
    this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "devices" && data === "registeredChanged") {
        this.onDevicesRegisteredChanged();
      }
      if (type2 === "device" && data === "statusChanged" && deviceID === this.getDeviceID()) {
        this.onDeviceStatusChanged();
      }
    });
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  componentDidUpdate(prevProps) {
    if (this.props.deviceID !== prevProps.deviceID) {
      this.onDevicesRegisteredChanged();
    }
  }
  onDevicesRegisteredChanged = () => {
    apiGet("devices/registered").then((devices) => {
      const deviceIDs = Object.keys(devices);
      const deviceRegistered = deviceIDs.includes(this.getDeviceID());
      this.setState({
        deviceRegistered,
        deviceStatus: null
      }, () => {
        if (this.state.deviceRegistered) {
          this.onDeviceStatusChanged();
        }
      });
    });
  };
  onDeviceStatusChanged = () => {
    if (this.state.deviceRegistered) {
      apiGet("devices/" + this.props.deviceID + "/status").then((deviceStatus) => {
        if (["seeded", "initialized"].includes(deviceStatus)) {
          this.context.setSidebarStatus("");
        } else {
          this.context.setSidebarStatus("forceHidden");
        }
        this.setState({ deviceStatus });
      });
    }
  };
  getDeviceID() {
    return this.props.deviceID || null;
  }
  handleCreate = () => {
    this.setState({ goal: GOAL.CREATE });
  };
  handleRestore = () => {
    this.setState({ goal: GOAL.RESTORE });
  };
  handleBack = () => {
    this.setState({ goal: null });
  };
  handleSuccess = () => {
    this.setState({ success: true });
  };
  render() {
    const {
      deviceID
    } = this.props;
    const {
      deviceRegistered,
      deviceStatus,
      goal: goal2,
      success: success2
    } = this.state;
    if (!deviceRegistered || !deviceStatus) {
      return null;
    }
    if (success2) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Success$1, { goal: goal2, handleHideSuccess: () => this.setState({ success: null }) });
    }
    switch (deviceStatus) {
      case DeviceStatus.BOOTLOADER:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Bootloader$1, { deviceID });
      case DeviceStatus.REQUIRE_FIRMWARE_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RequireUpgrade$1, { deviceID });
      case DeviceStatus.REQUIRE_APP_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
      case DeviceStatus.INITIALIZED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Unlock$2, { deviceID });
      case DeviceStatus.UNINITIALIZED:
        if (!goal2) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(translatedSecutiryInformation, { goal: goal2, goBack: this.handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedInitialize, { goBack: this.handleBack, deviceID }) });
      case DeviceStatus.LOGGED_IN:
        switch (goal2) {
          case GOAL.CREATE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedCreateNew$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          case GOAL.RESTORE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedRestore$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
      case DeviceStatus.SEEDED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, { deviceID });
      default:
        return null;
    }
  }
}
const BitBox01 = withTranslation()(Device);
const container$c = "_container_6tizs_1";
const primaryText = "_primaryText_6tizs_21";
const isButton = "_isButton_6tizs_27";
const rightContentContainer = "_rightContentContainer_6tizs_32";
const displayedValue = "_displayedValue_6tizs_38";
const withMargin = "_withMargin_6tizs_47";
const secondaryText = "_secondaryText_6tizs_51";
const collapse = "_collapse_6tizs_74";
const hideDisplayedValueOnSmall = "_hideDisplayedValueOnSmall_6tizs_87";
const styles$g = {
  container: container$c,
  primaryText,
  isButton,
  rightContentContainer,
  displayedValue,
  withMargin,
  secondaryText,
  collapse,
  hideDisplayedValueOnSmall
};
const SettingsItem = ({
  className = "",
  collapseOnSmall = false,
  displayedValue: displayedValue2 = "",
  extraComponent,
  hideDisplayedValueOnSmall: hideDisplayedValueOnSmall2 = false,
  onClick,
  secondaryText: secondaryText2,
  settingName: settingName2
}) => {
  const notButton = onClick === void 0;
  const rightContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.rightContentContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: `
        ${displayedValue2 ? styles$g.displayedValue : ""}
        ${extraComponent ? styles$g.withMargin : ""}
        ${hideDisplayedValueOnSmall2 ? styles$g.hideDisplayedValueOnSmall : ""}
       `,
        children: displayedValue2
      }
    ),
    extraComponent ? extraComponent : null
  ] });
  const content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      typeof settingName2 === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$g.primaryText, children: settingName2 }) : settingName2,
      secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$g.secondaryText, children: secondaryText2 }) : null
    ] }),
    rightContent
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: notButton ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$g.container} ${className} 
          ${collapseOnSmall ? styles$g.collapse : ""}`, children: content2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: `${styles$g.container} ${styles$g.isButton} ${className}`,
      onClick,
      children: content2
    }
  ) });
};
const container$b = "_container_1rta5_1";
const active$2 = "_active_1rta5_13";
const styles$f = {
  container: container$b,
  active: active$2
};
const WithSettingsTabs = ({
  children: children2,
  deviceIDs,
  hideMobileMenu,
  hasAccounts
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { hideMobileMenu, deviceIDs, hasAccounts }) }),
    children2
  ] });
};
const Tab = ({ name, url, hideMobileMenu }) => {
  if (!hideMobileMenu) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "show-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: name,
        onClick: () => route(url),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
      }
    ) }, url);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavLink,
    {
      className: ({ isActive }) => isActive ? `${styles$f.active} hide-on-small` : "hide-on-small",
      to: url,
      children: name
    },
    url
  );
};
const Tabs = ({ deviceIDs, hideMobileMenu, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.appearance"), url: "/settings/appearance" }, "appearance"),
    hasAccounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("manageAccounts.title"), url: "/settings/manage-accounts" }, "manage-accounts") : null,
    deviceIDs.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("sidebar.device"), url: `/settings/device-settings/${id2}` }, `device-${id2}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.advancedSettings"), url: "/settings/advanced-settings" }, "advanced-settings"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.about"), url: "/settings/about" }, "about")
  ] });
};
const ManageBackupSetting = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/manage-backups/${deviceID}`),
      settingName: t2("backup.title"),
      secondaryText: t2("deviceSettings.backups.manageBackups.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
};
const ShowRecoveryWordsSetting = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [inProgress, setInProgress] = reactExports.useState(false);
  const [showDialog, setShowDialog] = reactExports.useState(false);
  const confirmShowWords = async () => {
    setShowDialog(false);
    setInProgress(true);
    await showMnemonic(deviceID);
    setInProgress(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("backup.showMnemonic.title"),
        secondaryText: t2("deviceSettings.backups.showRecoveryWords.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setShowDialog(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMnemonicWaitDialog, { inProgress }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("backup.showMnemonic.title"), open: showDialog, onClose: () => setShowDialog(false), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MultilineMarkup,
        {
          markup: t2("backup.showMnemonic.description"),
          tagName: "span",
          withBreaks: true
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: confirmShowWords, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: () => setShowDialog(false), children: t2("dialog.cancel") })
      ] })
    ] })
  ] });
};
const ShowMnemonicWaitDialog = ({ inProgress }) => {
  const { t: t2 } = useTranslation();
  if (!inProgress) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TranslatedWaitDialog, { title: t2("backup.showMnemonic.title"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MultilineMarkup,
      {
        markup: t2("backup.showMnemonic.description"),
        tagName: "span",
        withBreaks: true
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Interact.followInstructions") })
  ] });
};
const StartupSettingsWaitDialog = ({ show: show2 }) => {
  const { t: t2 } = useTranslation();
  if (!show2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("bitbox02Settings.gotoStartupSettings.title"),
      children: t2("bitbox02Settings.gotoStartupSettings.description")
    }
  );
};
const GoToStartupSettings = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [show2, setShow] = reactExports.useState(false);
  const handleGoToStartupSettings = async () => {
    setShow(true);
    await apiPost(`devices/bitbox02/${deviceID}/goto-startup-settings`).catch(console.error);
    setShow(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.gotoStartupSettings.title"),
        secondaryText: t2("deviceSettings.expert.goToStartupSettings.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: handleGoToStartupSettings
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StartupSettingsWaitDialog, { show: show2 })
  ] });
};
const PassphraseSetting = ({ deviceID, passphraseEnabled }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/settings/device-settings/passphrase/${deviceID}`),
      settingName: t2("deviceSettings.expert.passphrase.title"),
      secondaryText: t2("deviceSettings.expert.passphrase.description"),
      displayedValue: passphraseEnabled ? t2("generic.enabled_true") : t2("generic.enabled_false"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
};
const AttestationCheckSetting = ({ deviceID }) => {
  const [attestation, setAttestation] = reactExports.useState(null);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    verifyAttestation(deviceID).then(setAttestation);
  }, [deviceID]);
  const icon2 = attestation ? /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { width: 20, height: 20 });
  if (attestation === null) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.attestation.label"),
      secondaryText: t2("deviceSettings.deviceInformation.attestation.description"),
      extraComponent: icon2,
      displayedValue: t2(`deviceSettings.hardware.attestation.${attestation}`),
      hideDisplayedValueOnSmall: true
    }
  );
};
const FirmwareSetting = ({ deviceID, versionInfo, asButton = false }) => {
  const { t: t2 } = useTranslation();
  const [dialogOpen, setDialogOpen] = reactExports.useState(false);
  const [confirming, setConfirming] = reactExports.useState(false);
  const canUpgrade = versionInfo.canUpgrade;
  const secondaryText2 = canUpgrade ? t2("deviceSettings.firmware.upgradeAvailable") : t2("deviceSettings.firmware.upToDate");
  const extraComponent = canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {});
  const handleOpenDialog = canUpgrade ? () => setDialogOpen(true) : void 0;
  const handleUpgradeFirmware = async () => {
    setConfirming(true);
    await upgradeDeviceFirmware(deviceID);
    setConfirming(false);
    setDialogOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleOpenDialog,
        primary: true,
        children: t2("button.upgrade")
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("deviceSettings.firmware.title"),
        secondaryText: secondaryText2,
        onClick: handleOpenDialog,
        displayedValue: versionInfo.currentVersion,
        extraComponent
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UpgradeDialog,
      {
        open: dialogOpen && canUpgrade,
        versionInfo,
        confirming,
        onUpgradeFirmware: handleUpgradeFirmware,
        onClose: () => setDialogOpen(false)
      }
    )
  ] });
};
const UpgradeDialog = ({
  open: open2,
  versionInfo,
  confirming,
  onUpgradeFirmware,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onClose, open: open2, title: t2("upgradeFirmware.title"), children: [
    confirming ? t2("confirmOnDevice") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("upgradeFirmware.description", {
      currentVersion: versionInfo.currentVersion,
      newVersion: versionInfo.newVersion
    }) }),
    !confirming && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: onUpgradeFirmware,
          children: t2("button.upgrade")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: onClose, children: t2("button.back") })
    ] })
  ] });
};
const SecureChipSetting = ({ secureChipModel }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.securechip"),
      secondaryText: t2("deviceSettings.deviceInformation.securechip.description"),
      displayedValue: secureChipModel
    }
  );
};
const wizardLabel = "_wizardLabel_1tll2_2";
const inputError = "_inputError_1tll2_6";
const errorMessage$1 = "_errorMessage_1tll2_11";
const nameStyle = {
  wizardLabel,
  inputError,
  errorMessage: errorMessage$1
};
const regexInvalid = /[^ -~]/g;
const useValidateDeviceName = (name) => {
  const getDeviceNameValidationError = reactExports.useCallback((name2) => {
    const trimmed = name2.trim();
    regexInvalid.lastIndex = 0;
    if (trimmed.length < 1) {
      return "tooShort";
    }
    if (trimmed.length > 30) {
      return "tooLong";
    }
    if (regexInvalid.test(trimmed)) {
      return "invalidChars";
    }
  }, []);
  const getInvalidCharsInDeviceName = reactExports.useCallback((deviceName) => {
    var _a;
    return (_a = deviceName.match(regexInvalid)) == null ? void 0 : _a.filter(filterUnique).join(", ");
  }, []);
  const { error: error3, invalidChars, nameIsTooShort } = reactExports.useMemo(() => {
    const error22 = getDeviceNameValidationError(name);
    const invalidChars2 = getInvalidCharsInDeviceName(name);
    const nameIsTooShort2 = error22 === "tooShort";
    return { error: error22, invalidChars: invalidChars2, nameIsTooShort: nameIsTooShort2 };
  }, [getDeviceNameValidationError, getInvalidCharsInDeviceName, name]);
  const filterUnique = (value, index2, array) => {
    return array.indexOf(value) === index2;
  };
  return { error: error3, invalidChars, nameIsTooShort };
};
const SetDeviceName = ({
  onDeviceName,
  onBack,
  missingSDCardWarning
}) => {
  const { t: t2 } = useTranslation();
  const [deviceName, setDeviceName2] = reactExports.useState("");
  const { error: error3, invalidChars, nameIsTooShort } = useValidateDeviceName(deviceName);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "form",
    {
      onSubmit: (event2) => {
        event2.preventDefault();
        onDeviceName(deviceName);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          textCenter: true,
          withBottomBar: true,
          verticallyCentered: true,
          width: "600px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepCreate.title"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreate.description") }),
              missingSDCardWarning && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { className: "m-bottom-half", type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitbox02Wizard.stepCreate.toastMicroSD") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { textAlign: "left", minHeight: "140px", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: true,
                className: `${nameStyle.wizardLabel} ${error3 && !nameIsTooShort ? nameStyle.inputError : ""}`,
                label: t2("bitbox02Wizard.stepCreate.nameLabel"),
                onInput: (e3) => setDeviceName2(e3.target.value),
                placeholder: t2("bitbox02Wizard.stepCreate.namePlaceholder"),
                value: deviceName,
                id: "deviceName",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeviceNameErrorMessage, { error: error3, invalidChars })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: !!error3,
                  primary: true,
                  type: "submit",
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onBack,
                  secondary: true,
                  type: "button",
                  children: t2("button.back")
                }
              )
            ] })
          ]
        }
      )
    }
  );
};
const DeviceNameErrorMessage = ({ error: error3, invalidChars }) => {
  const { t: t2 } = useTranslation();
  if (error3 === "tooShort") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { hidden: !error3, className: nameStyle.errorMessage, children: [
    t2(`bitbox02Wizard.stepCreate.error.${error3}`, {
      invalidChars
    }),
    " ",
    t2("bitbox02Wizard.stepCreate.error.genericMessage")
  ] });
};
const SetDeviceNameWithSDCard = ({
  deviceID,
  onDeviceName,
  onBack
}) => {
  const [hasSDCard, setSDCard] = reactExports.useState();
  reactExports.useEffect(() => {
    checkSDCard(deviceID).then(setSDCard);
  }, [deviceID]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SetDeviceName,
    {
      onDeviceName,
      onBack,
      missingSDCardWarning: hasSDCard === false
    }
  );
};
const DeviceNameSetting = ({ deviceName, deviceID }) => {
  const { t: t2 } = useTranslation();
  const [active2, setActive] = reactExports.useState(false);
  const [currentName, setCurrentName] = reactExports.useState(deviceName);
  const [name, setName] = reactExports.useState("");
  const [inProgress, setInProgress] = reactExports.useState(false);
  const updateName = async () => {
    setInProgress(true);
    try {
      const setNameResult = await setDeviceName(deviceID, name);
      if (!setNameResult.success) {
        throw new Error(setNameResult.message);
      }
      const deviceInfoResult = await getDeviceInfo(deviceID);
      if (!deviceInfoResult.success) {
        throw new Error(deviceInfoResult.message);
      }
      setCurrentName(deviceInfoResult.deviceInfo.name);
    } catch (error3) {
      alertUser(t2("bitbox02Settings.deviceName.error"));
      console.error(error3);
    } finally {
      setActive(false);
      setInProgress(false);
    }
  };
  const handleCloseDialog = () => {
    setActive(false);
    setName("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.deviceName.input"),
        secondaryText: t2("deviceSettings.deviceInformation.deviceName.description"),
        displayedValue: currentName,
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActive(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetDeviceNameDialog,
      {
        open: active2,
        onClose: handleCloseDialog,
        currentName,
        onInputChange: setName,
        name,
        handleUpdateName: updateName
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetDeviceNameWaitDialog, { inProgress })
  ] });
};
const SetDeviceNameDialog = ({ open: open2, onClose, currentName, onInputChange, name, handleUpdateName }) => {
  const { t: t2 } = useTranslation();
  const { error: error3, invalidChars, nameIsTooShort } = useValidateDeviceName(name);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      onClose,
      title: t2("bitbox02Settings.deviceName.title"),
      small: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns half", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("bitbox02Settings.deviceName.current") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-half", children: currentName })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                className: `m-none ${error3 && !nameIsTooShort ? nameStyle.inputError : ""}`,
                label: t2("bitbox02Settings.deviceName.input"),
                onInput: (e3) => onInputChange(e3.target.value),
                placeholder: t2("bitbox02Settings.deviceName.placeholder"),
                value: name,
                id: "deviceName"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DeviceNameErrorMessage, { error: error3, invalidChars })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            disabled: !!error3,
            onClick: handleUpdateName,
            children: t2("button.ok")
          }
        ) })
      ]
    }
  );
};
const SetDeviceNameWaitDialog = ({ inProgress }) => {
  const { t: t2 } = useTranslation();
  if (!inProgress) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: t2("bitbox02Interact.followInstructions") });
};
const settingNameContainer = "_settingNameContainer_usdew_1";
const settingName = "_settingName_usdew_1";
const styles$e = {
  settingNameContainer,
  settingName
};
const FactoryResetSetting = ({ deviceID }) => {
  const [understand, setUnderstand] = reactExports.useState(false);
  const [isConfirming, setIsConfirming] = reactExports.useState(false);
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const abort = () => {
    setUnderstand(false);
    setIsConfirming(false);
    setActiveDialog(false);
  };
  const handleUnderstandChange = (e3) => {
    setUnderstand(e3.target.checked);
  };
  const reset2 = async () => {
    setActiveDialog(false);
    setIsConfirming(true);
    const responseData = await resetDevice(deviceID);
    abort();
    if (!responseData.success) {
      alertUser(t2("reset.notReset"));
    }
  };
  const settingName2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.settingNameContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WarningOutlined, { width: 16, height: 16 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$e.settingName, children: t2("deviceSettings.expert.factoryReset.title") })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: settingName2,
        secondaryText: t2("deviceSettings.expert.factoryReset.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActiveDialog(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FactoryResetDialog,
      {
        open: activeDialog,
        handleCloseDialog: abort,
        isConfirming,
        understand,
        handleUnderstandChange,
        handleReset: reset2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetWaitDialog, { isConfirming })
  ] });
};
const FactoryResetDialog = ({
  open: open2,
  handleCloseDialog,
  isConfirming,
  understand,
  handleUnderstandChange,
  handleReset
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      title: t2("reset.title"),
      onClose: handleCloseDialog,
      disabledClose: isConfirming,
      small: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: "reset_understand",
              label: t2("reset.understandBB02"),
              checked: understand,
              onChange: handleUnderstandChange
            }
          ) })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, disabled: !understand, onClick: handleReset, children: t2("reset.title") }) })
      ]
    }
  );
};
const FactoryResetWaitDialog = ({ isConfirming }) => {
  const { t: t2 } = useTranslation();
  if (!isConfirming) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("reset.title"),
      children: t2("bitbox02Interact.followInstructions")
    }
  );
};
const RootFingerprintSetting = ({ rootFingerprint }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: "Root fingerprint",
      secondaryText: t2("deviceSettings.deviceInformation.rootFingerprint.description"),
      displayedValue: rootFingerprint
    }
  );
};
const section = "_section_18i3w_1";
const skeletonWrapper = "_skeletonWrapper_18i3w_9";
const styles$d = {
  section,
  skeletonWrapper
};
const getLink$1 = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/bitbox02/sicherheit/#device-authenticity-check";
    case "es":
      return "https://bitbox.swiss/es/bitbox02/seguridad/#device-authenticity-check";
    default:
      return "https://bitbox.swiss/bitbox02/security-features/#device-authenticity-check";
  }
};
const ManageDeviceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.device.name") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.secure-chip.link.text"),
        url: "https://bitbox.swiss/blog/bitbox-05-2021-masnee-update/#check-your-secure-chip-variant"
      },
      text: t2("guide.device.secure-chip.text"),
      title: t2("guide.device.secure-chip.title")
    } }, "guide.device.secure-chip"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.attestation.link.text"),
        url: getLink$1()
      },
      text: t2("guide.device.attestation.text"),
      title: t2("guide.device.attestation.title")
    } }, "guide.device.attestation")
  ] });
};
const container$a = "_container_1xwzi_1";
const backButton = "_backButton_1xwzi_7";
const headerText = "_headerText_1xwzi_27";
const styles$c = {
  container: container$a,
  backButton,
  headerText
};
const MobileHeader = ({ title: title2, withGuide = false }) => {
  const { t: t2 } = useTranslation();
  const handleClick = () => {
    route("/settings");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$c.container} ${withGuide ? `${styles$c.withGuide}` : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleClick, className: styles$c.backButton, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftDark, {}),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.back") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$c.headerText, children: title2 })
  ] });
};
const StyledSkeleton = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.skeletonWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "var(--item-height-xlarge)" }) });
};
const BB02Settings = ({ deviceID, deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("sidebar.device") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: true,
          hasAccounts,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { deviceID })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDeviceGuide, {})
  ] }) });
};
const Content = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [deviceInfo, setDeviceInfo] = reactExports.useState();
  const versionInfo = useLoad(() => getVersion(deviceID), [deviceID]);
  const rootFingerprintResult = useLoad(() => getRootFingerprint(deviceID), [deviceID]);
  reactExports.useEffect(() => {
    getDeviceInfo(deviceID).then((result) => {
      if (!result.success) {
        alertUser(t2("genericError"));
        return;
      }
      setDeviceInfo(result.deviceInfo);
    }).catch(console.error);
  }, [deviceID, t2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.backups.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ManageBackupSetting, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ShowRecoveryWordsSetting, { deviceID })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.deviceInformation.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeviceNameSetting,
        {
          deviceName: deviceInfo.name,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AttestationCheckSetting, { deviceID }),
      versionInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        FirmwareSetting,
        {
          deviceID,
          versionInfo
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      deviceInfo && deviceInfo.securechipModel !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SecureChipSetting, { secureChipModel: deviceInfo.securechipModel }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      rootFingerprintResult && rootFingerprintResult.success ? /* @__PURE__ */ jsxRuntimeExports.jsx(RootFingerprintSetting, { rootFingerprint: rootFingerprintResult.rootFingerprint }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("settings.expert.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        PassphraseSetting,
        {
          passphraseEnabled: deviceInfo.mnemonicPassphraseEnabled,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(GoToStartupSettings, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetSetting, { deviceID })
    ] })
  ] });
};
const BitBox02 = ({ deviceID, deviceIDs, hasAccounts }) => {
  const status2 = useSync(
    () => getStatus$1(deviceID),
    (cb2) => statusChanged(deviceID, () => {
      getStatus$1(deviceID).then(cb2);
    })
  );
  if (status2 !== "initialized") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BB02Settings, { deviceID, deviceIDs, hasAccounts });
};
const getStatus = (deviceID) => {
  return apiGet(`devices/bitbox02-bootloader/${deviceID}/status`);
};
const syncStatus = (deviceID) => {
  return (cb2) => {
    return subscribeEndpoint(`devices/bitbox02-bootloader/${deviceID}/status`, cb2);
  };
};
const getVersionInfo = (deviceID) => {
  return apiGet(`devices/bitbox02-bootloader/${deviceID}/version-info`);
};
const upgradeFirmware = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/upgrade-firmware`);
};
const reboot = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/reboot`);
};
const screenRotate = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/screen-rotate`);
};
const getShowFirmwareHash = (deviceID) => {
  return () => {
    return apiGet(`devices/bitbox02-bootloader/${deviceID}/show-firmware-hash-enabled`);
  };
};
const setShowFirmwareHash = (deviceID, enabled) => {
  return apiPost(
    `devices/bitbox02-bootloader/${deviceID}/set-firmware-hash-enabled`,
    enabled
  );
};
const container$9 = "_container_18axn_1";
const style$l = {
  container: container$9
};
const CenteredContent = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$l.container, children: children2 }) });
};
const container$8 = "_container_14uup_1";
const slider = "_slider_14uup_16";
const style$k = {
  container: container$8,
  slider
};
const Toggle = ({
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `${style$k.container} ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$k.slider })
  ] });
};
const ToggleShowFirmwareHash = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [enabledState, setEnabledState] = reactExports.useState(false);
  const enabledConfig = useLoad(getShowFirmwareHash(deviceID));
  reactExports.useEffect(() => {
    if (enabledConfig !== void 0) {
      setEnabledState(enabledConfig);
    }
  }, [enabledConfig]);
  const handleToggle = (event2) => {
    const enabled = event2.target.checked;
    setShowFirmwareHash(deviceID, enabled);
    setEnabledState(enabled);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bb02Bootloader.advanced.toggleShowFirmwareHash") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        checked: enabledState,
        id: "togggle-show-firmware-hash",
        onChange: handleToggle
      }
    )
  ] });
};
const BitBox02Bootloader = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const status2 = useSync(
    () => getStatus(deviceID),
    syncStatus(deviceID)
  );
  const versionInfo = useLoad(() => getVersionInfo(deviceID));
  if (versionInfo === void 0) {
    return null;
  }
  let contents;
  if (status2 && status2.upgrading) {
    if (status2.upgradeSuccessful) {
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bb02Bootloader.success", {
        rebootSeconds: status2.rebootSeconds.toString(),
        context: versionInfo.erased ? "install" : ""
      }) }) });
    } else {
      const value = Math.round(status2.progress * 100);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
          value,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bootloader.progress", {
          progress: value.toString(),
          context: versionInfo.erased ? "install" : ""
        }) })
      ] });
    }
  } else {
    contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", style: { minHeight: 390 }, children: [
      versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("welcome.getStarted") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        versionInfo.canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: () => upgradeFirmware(deviceID),
            children: t2("bootloader.button", { context: versionInfo.erased ? "install" : "" })
          }
        ) : null,
        !versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: () => reboot(deviceID),
            children: t2("bb02Bootloader.abort", { context: !versionInfo.canUpgrade ? "noUpgrade" : "" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-center", style: { marginTop: 32 }, children: [
        t2("bb02Bootloader.orientation"),
        "",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            onClick: () => screenRotate(deviceID),
            style: { textDecoration: "underline", cursor: "pointer" },
            children: t2("bb02Bootloader.flipscreen")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { children: t2("bb02Bootloader.advanced.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleShowFirmwareHash, { deviceID })
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredContent, { children: [
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Inverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02$1, {}),
    status2 && status2.errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: status2.errMsg }),
    contents
  ] });
};
const Waiting = () => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$n.waitingText, children: t2("welcome.insertDevice") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$n.waitingDescription, children: t2("welcome.insertBitBox02") })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.welcome"), shown: true }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.getDevice.link.text"),
          url: "https://bitbox.shop/"
        },
        text: t2("guide.waiting.getDevice.text"),
        title: t2("guide.waiting.getDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.lostDevice.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/5-backup/8-wie-kann-ich-ein-bitbox02-wallet-in-ein-drittanbieter-wallet-importieren" : "https://shiftcrypto.support/help/en-us/5-backup/8-how-do-i-restore-my-wallet-if-my-bitbox02-is-lost"
        },
        text: t2("guide.waiting.lostDevice.text"),
        title: t2("guide.waiting.lostDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.internet") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.deviceNotRecognized") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.useWithoutDevice") })
    ] })
  ] });
};
const DeviceSwitch = ({ deviceID, devices, hasAccounts }) => {
  const deviceIDs = Object.keys(devices);
  if (deviceID === null || !deviceIDs.includes(deviceID)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
  switch (devices[deviceID]) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox01, { deviceID });
    case "bitbox02":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitBox02,
        {
          deviceID,
          deviceIDs,
          hasAccounts
        }
      );
    case "bitbox02-bootloader":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Bootloader, { deviceID });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
};
const getBackupList = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/backups/list`);
};
const subscribeBackupList = (deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02/${deviceID}/backups/list`, cb2);
const toast = "_toast_4ztjp_1";
const active$1 = "_active_4ztjp_17";
const shifted = "_shifted_4ztjp_21";
const info = "_info_4ztjp_25";
const success$1 = "_success_4ztjp_29";
const warning$1 = "_warning_4ztjp_33";
const style$j = {
  toast,
  active: active$1,
  shifted,
  info,
  success: success$1,
  warning: warning$1
};
class Toast extends reactExports.Component {
  state = {
    active: false
  };
  componentDidMount() {
    setTimeout(this.show, 5);
  }
  show = () => {
    this.setState({ active: true });
  };
  hide = () => {
    this.setState({ active: false });
    if (this.props.onHide) {
      this.props.onHide();
    }
  };
  render() {
    const {
      theme,
      children: children2,
      withGuide
    } = this.props;
    const { active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: [style$j.toast, style$j[theme], active2 ? style$j.active : "", withGuide ? style$j.shifted : ""].join(" "),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: children2 })
      }
    );
  }
}
const Check2 = ({ deviceID, backups, disabled: disabled2 }) => {
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const [message2, setMessage] = reactExports.useState("");
  const [foundBackup, setFoundBackup] = reactExports.useState();
  const [userVerified, setUserVerified] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const checkBackup$1 = async () => {
    setMessage(t2("backup.check.confirmTitle"));
    try {
      const result = await checkBackup(deviceID, true);
      if (result.success) {
        const { backupID: backupID2 } = result;
        const foundBackup2 = backups.find((backup2) => backup2.id === backupID2);
        if (!foundBackup2) {
          alertUser(t2("unknownError", { errorMessage: "Not found" }));
          return;
        }
        setActiveDialog(true);
        setFoundBackup(foundBackup2);
      }
      const check = await checkBackup(deviceID, false);
      if (!check.success) {
        setActiveDialog(true);
        setMessage(t2("backup.check.notOK"));
        setUserVerified(true);
        return;
      }
      setMessage(t2("backup.check.success"));
      setUserVerified(true);
    } catch (error3) {
      console.error(error3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        disabled: disabled2,
        onClick: checkBackup$1,
        children: t2("button.check")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: activeDialog, title: message2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: (e3) => {
      e3.preventDefault();
      setActiveDialog(false);
      setUserVerified(false);
    }, children: [
      foundBackup !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: foundBackup,
          radio: false
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: userVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          autoFocus: true,
          disabled: !userVerified,
          primary: true,
          type: "submit",
          children: userVerified ? t2("button.ok") : t2("accountInfo.verify")
        }
      ) })
    ] }) })
  ] });
};
const Create2 = ({ deviceID }) => {
  const [creatingBackup, setCreatingBackup] = reactExports.useState(false);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const createBackup$1 = () => {
    setCreatingBackup(true);
    createBackup(deviceID, "sdcard").then((result) => {
      setCreatingBackup(false);
      setDisabled(false);
      if (!result.success) {
        alertUser(t2("backup.create.fail"));
      }
    }).catch(console.error);
  };
  const maybeCreateBackup = async () => {
    setDisabled(true);
    try {
      const check = await checkBackup(deviceID, true);
      if (check.success) {
        confirmation(t2("backup.create.alreadyExists"), (result) => {
          if (result) {
            createBackup$1();
          } else {
            setDisabled(false);
          }
        });
        return;
      }
      createBackup$1();
    } catch (error3) {
      console.error(error3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        disabled: disabled2,
        onClick: maybeCreateBackup,
        children: t2("backup.create.title")
      }
    ),
    creatingBackup && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.create.title"), children: t2("bitbox02Interact.followInstructions") })
  ] });
};
const BackupsV2 = ({
  deviceID,
  showRestore,
  showCreate,
  showRadio,
  onSelectBackup,
  onRestoreBackup,
  children: children2
}) => {
  const { t: t2 } = useTranslation();
  const [selectedBackup, setSelectedBackup] = reactExports.useState();
  const [restoring, setRestoring] = reactExports.useState(false);
  const [errorText2, setErrorText] = reactExports.useState("");
  const backups = useSync(() => getBackupList(deviceID), subscribeBackupList(deviceID));
  const hasBackups = backups && backups.success && backups !== void 0;
  const hasMoreThanOneBackups = hasBackups && backups.backups.length > 1;
  reactExports.useEffect(() => {
    if (!hasBackups || backups.backups.length === 0) {
      return;
    }
    if (backups.backups.length === 1) {
      setSelectedBackup(backups.backups[0].id);
    }
  }, [backups, hasBackups]);
  const restore = () => {
    if (!hasBackups) {
      return;
    }
    if (!selectedBackup) {
      return;
    }
    const backup2 = backups.backups.find((b2) => b2.id === selectedBackup);
    if (!backup2) {
      return;
    }
    setRestoring(true);
    onSelectBackup && onSelectBackup(backup2);
    restoreBackup(deviceID, selectedBackup).then(({ success: success2 }) => {
      setRestoring(false);
      setErrorText(success2 ? "" : t2("backup.restore.error.general"));
      if (onRestoreBackup) {
        onRestoreBackup(success2);
      }
    });
  };
  if (!hasBackups) {
    if (hasBackups === void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Error fetching backups" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.stepContext, children: [
    errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toast, { theme: "warning", children: errorText2 }),
    showRadio && hasMoreThanOneBackups ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none m-bottom-large", children: t2("backup.restore.subtitle") }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, children: backups.backups.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backups.backups.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BackupsListItem,
      {
        disabled: restoring,
        backup: backup2,
        selectedBackup,
        handleChange: (b2) => setSelectedBackup(b2),
        onFocus: () => void 0,
        radio: showRadio
      }
    ) }, backup2.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.noBackups") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupButtons, children: [
      showRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          disabled: !selectedBackup || restoring,
          onClick: restore,
          children: t2("button.restore")
        }
      ),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(Create2, { deviceID }),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Check2,
        {
          deviceID,
          backups: backups.backups ? backups.backups : [],
          disabled: backups.backups.length === 0
        }
      ),
      children2
    ] })
  ] }) });
};
const SDCardCheck = ({ deviceID, children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [sdCardInserted, setSdCardInserted] = reactExports.useState();
  const check = reactExports.useCallback(() => checkSDCard(deviceID).then(setSdCardInserted), [deviceID]);
  reactExports.useEffect(() => {
    check();
  }, [check]);
  if (sdCardInserted === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !sdCardInserted ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !sdCardInserted, title: "Check your device", small: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.insert") }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: check,
          children: t2("button.ok")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ButtonLink,
        {
          secondary: true,
          to: `/settings/device-settings/${deviceID}`,
          children: t2("button.back")
        }
      )
    ] })
  ] }) : children2 });
};
class ManageBackups extends reactExports.Component {
  hasDevice = () => {
    return !!this.props.devices[this.props.deviceID];
  };
  UNSAFE_componentWillMount() {
    if (!this.hasDevice()) {
      route("/", true);
    }
  }
  backButton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ButtonLink,
      {
        secondary: true,
        to: `/settings/device-settings/${this.props.deviceID}`,
        children: this.props.t("button.back")
      }
    );
  };
  listBackups = () => {
    switch (this.props.devices[this.props.deviceID]) {
      case "bitbox":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedBackups,
          {
            deviceID: this.props.deviceID,
            showCreate: true,
            showRestore: false,
            children: this.backButton()
          }
        );
      case "bitbox02":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SDCardCheck, { deviceID: this.props.deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID: this.props.deviceID,
            showCreate: true,
            showRestore: false,
            showRadio: false,
            children: this.backButton()
          }
        ) });
      default:
        return;
    }
  };
  renderGuide = (t2) => {
    switch (this.props.devices[this.props.deviceID]) {
      case "bitbox":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.whatIsABackup") }, "guide.backups.whatIsABackup"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.encrypt") }, "guide.backups.encrypt"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.check") }, "guide.backups.check"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
        ] });
      case "bitbox02":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.whatIsABackup") }, "guide.backupsBB02.whatIsABackup"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.encrypt"), shown: true }, "guide.backupsBB02.encrypt"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.check") }, "guide.backupsBB02.check"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
        ] });
      default:
        return null;
    }
  };
  render() {
    const { t: t2 } = this.props;
    if (!this.hasDevice()) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("backup.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("backup.list") }),
          this.listBackups()
        ] })
      ] }) }),
      this.renderGuide(t2)
    ] });
  }
}
const ManageBackups$1 = withTranslation()(ManageBackups);
const getCoinsLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/coins/";
    case "es":
      return "https://bitbox.swiss/es/monedas/";
    default:
      return "https://bitbox.swiss/coins/";
  }
};
const AccountGuide$1 = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatIsRememberWallet") }, "whatIsRememberWallet"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    !hasOnlyBTCAccounts && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.accounts.supportedCoins.link.text"),
          url: getCoinsLink()
        },
        text: t2("guide.accounts.supportedCoins.text"),
        title: t2("guide.accounts.supportedCoins.title")
      } }, "supportedCoins"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
};
const label$2 = "_label_g3ts4_1";
const labelText = "_labelText_g3ts4_5";
const style$i = {
  label: label$2,
  labelText
};
const WatchonlySetting = ({ keystore: keystore2 }) => {
  const { t: t2 } = useTranslation();
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [watchonly, setWatchonly$1] = reactExports.useState();
  const [warningDialogOpen, setWarningDialogOpen] = reactExports.useState(false);
  const config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      setWatchonly$1(keystore2.watchonly);
    }
  }, [config, keystore2]);
  const toggleWatchonly = async () => {
    if (!watchonly) {
      setDisabled(true);
      const { success: success2 } = await setWatchonly(keystore2.rootFingerprint, !watchonly);
      if (success2) {
        setWatchonly$1(!watchonly);
      }
      setDisabled(false);
      return;
    }
    setWarningDialogOpen(true);
    setDisabled(false);
  };
  const handleCloseDialog = () => {
    setWarningDialogOpen(false);
    setDisabled(false);
  };
  const handleConfirmDisableWatchonly = async () => {
    setDisabled(true);
    await setWatchonly(keystore2.rootFingerprint, false);
    setWatchonly$1(false);
    setDisabled(false);
    setWarningDialogOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("newSettings.appearance.remebmerWallet.warningTitle"), medium: true, onClose: handleCloseDialog, open: warningDialogOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.remebmerWallet.warning") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: handleConfirmDisableWatchonly, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: handleCloseDialog, children: t2("dialog.cancel") })
      ] })
    ] }),
    watchonly !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: style$i.label, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$i.labelText, children: t2("newSettings.appearance.remebmerWallet.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: watchonly,
          disabled: disabled2,
          onChange: toggleWatchonly
        }
      )
    ] }) : null
  ] });
};
const addAccountBtn = "_addAccountBtn_b53x1_2";
const accountNameInactive = "_accountNameInactive_b53x1_6";
const disabledText = "_disabledText_b53x1_10";
const walletHeader = "_walletHeader_b53x1_15";
const walletTitle = "_walletTitle_b53x1_23";
const setting = "_setting_b53x1_34";
const coinLogo = "_coinLogo_b53x1_48";
const acccountLink = "_acccountLink_b53x1_53";
const editBtn = "_editBtn_b53x1_61";
const toggleLabel$1 = "_toggleLabel_b53x1_73";
const toggleLabelText = "_toggleLabelText_b53x1_79";
const toggle$1 = "_toggle_b53x1_73";
const accountActive = "_accountActive_b53x1_96";
const tokenSection = "_tokenSection_b53x1_100";
const tokenContainer = "_tokenContainer_b53x1_109";
const tokenContainerOpen = "_tokenContainerOpen_b53x1_116";
const token$1 = "_token_b53x1_100";
const tokenIcon = "_tokenIcon_b53x1_158";
const tokenName = "_tokenName_b53x1_163";
const tokenInactive = "_tokenInactive_b53x1_169";
const expandBtn = "_expandBtn_b53x1_174";
const expandBtnOpen = "_expandBtnOpen_b53x1_182";
const watchOnlyContainer = "_watchOnlyContainer_b53x1_195";
const watchOnlyNote = "_watchOnlyNote_b53x1_202";
const watchOnlyAccountHidden = "_watchOnlyAccountHidden_b53x1_207";
const style$h = {
  addAccountBtn,
  accountNameInactive,
  disabledText,
  walletHeader,
  walletTitle,
  setting,
  coinLogo,
  acccountLink,
  editBtn,
  toggleLabel: toggleLabel$1,
  toggleLabelText,
  toggle: toggle$1,
  accountActive,
  tokenSection,
  tokenContainer,
  tokenContainerOpen,
  token: token$1,
  tokenIcon,
  tokenName,
  tokenInactive,
  expandBtn,
  expandBtnOpen,
  watchOnlyContainer,
  watchOnlyNote,
  watchOnlyAccountHidden
};
class ManageAccounts extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      editErrorMessage: void 0,
      showTokens: {},
      currentlyEditedAccount: void 0
    };
    this.renderAccounts = (accounts) => {
      const { showTokens } = this.state;
      const { t: t2 } = this.props;
      return accounts.filter((account2) => !account2.isToken).map((account2) => {
        var _a;
        const active2 = account2.active;
        const tokensVisible = showTokens[account2.code];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.setting, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${style$h.acccountLink} ${active2 ? style$h.accountActive : ""}`,
              onClick: () => active2 && route(`/account/${account2.code}`),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: true, active: account2.active, className: `${style$h.coinLogo} m-right-half`, coinCode: account2.coinCode, alt: account2.coinUnit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: !account2.active ? style$h.accountNameInactive : "", children: [
                  account2.name,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "unit", children: [
                    "(",
                    account2.coinUnit,
                    ")"
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-items-center", children: [
            !account2.active ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-small ${style$h.disabledText}`, children: t2("generic.enabled_false") }) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                className: style$h.editBtn,
                onClick: () => this.setState({ currentlyEditedAccount: account2 }),
                transparent: true,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(EditActive, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hide-on-small", children: t2("manageAccounts.editAccount") })
                ]
              }
            )
          ] }),
          active2 && account2.coinCode === "eth" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.tokenSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$h.tokenContainer} ${tokensVisible ? style$h.tokenContainerOpen : ""}`, children: this.renderTokens(account2.code, account2.activeTokens) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: `${style$h.expandBtn} ${tokensVisible ? style$h.expandBtnOpen : ""}`,
                onClick: () => this.toggleShowTokens(account2.code),
                transparent: true,
                children: t2(tokensVisible ? "manageAccounts.settings.hideTokens" : "manageAccounts.settings.showTokens", {
                  activeTokenCount: `${((_a = account2.activeTokens) == null ? void 0 : _a.length) || 0}`
                })
              }
            )
          ] }) : null
        ] }, account2.code);
      });
    };
    this.toggleAccount = (accountCode, active2) => {
      return setAccountActive(accountCode, active2).then(({ success: success2, errorMessage: errorMessage2 }) => {
        if (!success2 && errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.toggleShowTokens = (accountCode) => {
      this.setState(({ showTokens }) => ({
        showTokens: {
          ...showTokens,
          [accountCode]: accountCode in showTokens ? !showTokens[accountCode] : true
        }
      }));
    };
    this.erc20Tokens = [
      { code: "eth-erc20-usdt", name: "Tether USD", unit: "USDT" },
      { code: "eth-erc20-usdc", name: "USD Coin", unit: "USDC" },
      { code: "eth-erc20-link", name: "Chainlink", unit: "LINK" },
      { code: "eth-erc20-bat", name: "Basic Attention Token", unit: "BAT" },
      { code: "eth-erc20-mkr", name: "Maker", unit: "MKR" },
      { code: "eth-erc20-zrx", name: "0x", unit: "ZRX" },
      { code: "eth-erc20-wbtc", name: "Wrapped Bitcoin", unit: "WBTC" },
      { code: "eth-erc20-paxg", name: "Pax Gold", unit: "PAXG" },
      { code: "eth-erc20-dai0x6b17", name: "Dai", unit: "DAI" }
    ];
    this.renderTokens = (ethAccountCode, activeTokens) => {
      return this.erc20Tokens.map((token2) => {
        const activeToken = (activeTokens || []).find((t2) => t2.tokenCode === token2.code);
        const active2 = activeToken !== void 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `${style$h.token} ${!active2 ? style$h.tokenInactive : ""}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `${style$h.acccountLink} ${active2 ? style$h.accountActive : ""}`,
                  onClick: () => activeToken !== void 0 && route(`/account/${activeToken.accountCode}`),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Logo,
                      {
                        active: active2,
                        alt: token2.name,
                        className: style$h.tokenIcon,
                        coinCode: token2.code,
                        stacked: true
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$h.tokenName, children: [
                      token2.name,
                      " (",
                      token2.unit,
                      ")"
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Toggle,
                {
                  checked: active2,
                  className: style$h.toggle,
                  id: token2.code,
                  onChange: () => this.toggleToken(ethAccountCode, token2.code, !active2)
                }
              )
            ]
          },
          token2.code
        );
      });
    };
    this.toggleToken = (ethAccountCode, tokenCode, active2) => {
      setTokenActive(ethAccountCode, tokenCode, active2).then(({ success: success2, errorMessage: errorMessage2 }) => {
        if (!success2 && errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.updateAccount = (event2) => {
      event2.preventDefault();
      const { accounts } = this.props;
      const { currentlyEditedAccount } = this.state;
      if (!currentlyEditedAccount) {
        return;
      }
      renameAccount(currentlyEditedAccount.code, currentlyEditedAccount.name).then((result) => {
        if (!result.success) {
          if (result.errorCode) {
            this.setState({ editErrorMessage: this.props.t(`error.${result.errorCode}`) });
          } else if (result.errorMessage) {
            this.setState({ editErrorMessage: result.errorMessage });
          }
          return;
        }
        const account2 = accounts.find(({ code }) => currentlyEditedAccount.code === code);
        if (currentlyEditedAccount.active !== (account2 == null ? void 0 : account2.active)) {
          this.toggleAccount(currentlyEditedAccount.code, currentlyEditedAccount.active);
        }
        this.setState({
          editErrorMessage: void 0,
          currentlyEditedAccount: void 0
        });
      });
    };
  }
  render() {
    const { t: t2, accounts, deviceIDs, hasAccounts } = this.props;
    const { editErrorMessage, currentlyEditedAccount } = this.state;
    const accountsByKeystore = getAccountsByKeystore(accounts);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Header,
          {
            hideSidebarToggler: true,
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("settings.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("manageAccounts.title") })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { deviceIDs, hideMobileMenu: true, hasAccounts, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: style$h.addAccountBtn,
              primary: true,
              onClick: () => route("/add-account", true),
              children: t2("addAccount.title")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: accountsByKeystore.map((keystore2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Column,
            {
              asCard: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.walletHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: style$h.walletTitle, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                      keystore2.keystore.name,
                      isAmbiguiousName(keystore2.keystore.name, accountsByKeystore) ? (
                        // Disambiguate accounts group by adding the fingerprint.
                        // The most common case where this would happen is when adding accounts from the
                        // same seed using different passphrases.
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                          " ",
                          keystore2.keystore.rootFingerprint
                        ] })
                      ) : null
                    ] }),
                    keystore2.keystore.connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Badge,
                      {
                        className: "m-right-quarter",
                        icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                        type: "success",
                        children: t2("device.keystoreConnected")
                      }
                    ) : null
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(WatchonlySetting, { keystore: keystore2.keystore })
                ] }),
                this.renderAccounts(keystore2.accounts)
              ]
            },
            keystore2.keystore.rootFingerprint
          )) }),
          currentlyEditedAccount && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: !!currentlyEditedAccount,
              onClose: () => this.setState({ currentlyEditedAccount: void 0 }),
              title: t2("manageAccounts.editAccountNameTitle"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.updateAccount, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", hidden: !editErrorMessage, children: editErrorMessage }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$2,
                  {
                    onInput: (e3) => this.setState({ currentlyEditedAccount: { ...currentlyEditedAccount, name: e3.target.value } }),
                    value: currentlyEditedAccount.name
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    className: style$h.toggleLabel,
                    htmlFor: currentlyEditedAccount.code,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$h.toggleLabelText, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpenedDark, {}),
                        t2("newSettings.appearance.enableAccount.title")
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Toggle,
                        {
                          checked: currentlyEditedAccount.active,
                          className: style$h.toggle,
                          id: currentlyEditedAccount.code,
                          onChange: (event2) => {
                            event2.target.disabled = true;
                            this.setState({
                              currentlyEditedAccount: {
                                ...currentlyEditedAccount,
                                active: event2.target.checked
                              }
                            }, () => event2.target.disabled = false);
                          }
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.enableAccount.description") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    disabled: !currentlyEditedAccount.name,
                    primary: true,
                    type: "submit",
                    children: t2("button.update")
                  }
                ) })
              ] })
            }
          )
        ] }) }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AccountGuide$1, { accounts })
    ] });
  }
}
const HOC$1 = translate()(ManageAccounts);
const title$2 = "_title_ahh86_1";
const resetLink = "_resetLink_ahh86_7";
const serversContainer = "_serversContainer_ahh86_11";
const servers = "_servers_ahh86_11";
const server = "_server_ahh86_11";
const serverLabel = "_serverLabel_ahh86_32";
const primary = "_primary_ahh86_82";
const warning = "_warning_ahh86_93";
const textarea$1 = "_textarea_ahh86_104";
const block = "_block_ahh86_112";
const addServer = "_addServer_ahh86_116";
const badge$1 = "_badge_ahh86_140";
const miniSpinnerContainer = "_miniSpinnerContainer_ahh86_152";
const miniSpinner = "_miniSpinner_ahh86_152";
const changeContent$1 = "_changeContent_ahh86_1";
const style$g = {
  title: title$2,
  resetLink,
  serversContainer,
  servers,
  server,
  serverLabel,
  primary,
  warning,
  textarea: textarea$1,
  block,
  addServer,
  badge: badge$1,
  miniSpinnerContainer,
  miniSpinner,
  changeContent: changeContent$1
};
const ElectrumAddServer = ({
  onAdd
}) => {
  const { t: t2 } = useTranslation();
  const [valid, setValid] = reactExports.useState();
  const [electrumServer, setElectrumServer] = reactExports.useState("");
  const [electrumCert, setElectrumCert] = reactExports.useState("");
  const [loadingCheck, setLoadingCheck] = reactExports.useState(false);
  const [loadingCert, setLoadingCert] = reactExports.useState(false);
  const getServer = () => {
    return {
      server: electrumServer.trim(),
      pemCert: electrumCert,
      tls: electrumCert !== ""
    };
  };
  const add = () => {
    onAdd(getServer());
    setElectrumServer("");
    setElectrumCert("");
  };
  const downloadCert = async () => {
    setLoadingCert(true);
    const data = await apiPost("certs/download", electrumServer.trim());
    if (data.success) {
      setElectrumCert(data.pemCert);
    } else {
      alertUser(data.errorMessage);
    }
    setLoadingCert(false);
  };
  const check = async () => {
    setLoadingCheck(true);
    const { success: success2, errorMessage: errorMessage2 } = await apiPost("electrum/check", getServer());
    if (success2) {
      alertUser(t2("settings.electrum.checkSuccess", { host: electrumServer }));
    } else {
      alertUser(t2("settings.electrum.checkFailed") + ":\n" + errorMessage2);
    }
    setValid(success2);
    setLoadingCheck(false);
  };
  const downloadCertButtonDisabled = electrumServer.trim().length === 0 || electrumCert.trim().length > 0 || loadingCert;
  const checkConnectionButtonDisabled = electrumServer.trim().length === 0 || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.addServer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step1-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        name: "electrumServer",
        onInput: (event2) => setElectrumServer(event2.target.value),
        value: electrumServer,
        placeholder: "host:port"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text-tcp") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: style$g.textarea,
        rows: 10,
        cols: 80,
        name: "electrumCert",
        onInput: (event2) => setElectrumCert(event2.target.value),
        value: electrumCert,
        placeholder: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$g.block, "flex flex-row flex-end"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: true, disabled: downloadCertButtonDisabled, onClick: downloadCert, children: [
      loadingCert && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
      t2("settings.electrum.download-cert")
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step3-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-end spaced", style$g.block].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: true, disabled: checkConnectionButtonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
        loadingCheck ? t2("settings.electrum.checking") : t2("settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, disabled: !valid, onClick: add, children: t2("settings.electrum.add-server") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step4-text") }) })
    ] })
  ] });
};
const ElectrumServer = ({
  onRemove,
  server: server2
}) => {
  const { t: t2 } = useTranslation();
  const [loadingCheck, setLoadingCheck] = reactExports.useState(false);
  const check = async () => {
    setLoadingCheck(true);
    const { success: success2, errorMessage: errorMessage2 } = await apiPost("electrum/check", {
      server: server2.server.trim(),
      pemCert: server2.pemCert,
      tls: server2.tls
    });
    if (success2) {
      alertUser(t2("settings.electrum.checkSuccess", { host: server2.server }));
    } else {
      alertUser(t2("settings.electrum.checkFailed") + ":\n" + errorMessage2);
    }
    setLoadingCheck(false);
  };
  const buttonDisabled = server2.server === "" || server2.tls && server2.pemCert === "" || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.server, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.serverLabel, children: [
      server2.server,
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: server2.tls ? "TLS" : "TCP" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$g.primary, disabled: buttonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
        loadingCheck ? t2("settings.electrum.checking") : t2("settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$g.warning, onClick: onRemove, children: t2("settings.electrum.remove-server") })
    ] })
  ] }) });
};
const ElectrumServers = ({
  coin
}) => {
  const { t: t2 } = useTranslation();
  const [config, setConfigState] = reactExports.useState();
  const loadConfig = () => {
    getConfig().then(setConfigState);
  };
  reactExports.useEffect(loadConfig, []);
  if (config === void 0) {
    return null;
  }
  const electrumServers = config.backend[coin].electrumServers;
  const save = async (newElectrumServers) => {
    const currentConfig = await getConfig();
    currentConfig.backend[coin].electrumServers = newElectrumServers;
    await setConfig(currentConfig);
    setConfigState(currentConfig);
  };
  const onAdd = (server2) => {
    let newElectrumServers = [...electrumServers, server2];
    save(newElectrumServers);
  };
  const onRemove = (index2) => {
    let newElectrumServers = [...electrumServers];
    newElectrumServers.splice(index2, 1);
    save(newElectrumServers);
  };
  const resetToDefault = () => {
    confirmation(t2("settings.electrum.resetConfirm"), (response) => {
      if (response) {
        getDefaultConfig().then((config2) => {
          save(config2.backend[coin].electrumServers);
        });
      }
    });
  };
  const onRemoveCb = (server2, index2) => () => {
    confirmation(t2("settings.electrum.removeConfirm", { server: server2.server }), (confirmed) => {
      if (confirmed) {
        onRemove(index2);
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.serversContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.servers") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            transparent: true,
            className: style$g.resetLink,
            onClick: resetToDefault,
            children: t2("settings.electrum.reset")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$g.servers, children: electrumServers.map((server2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ElectrumServer,
        {
          server: server2,
          onRemove: onRemoveCb(server2, index2)
        },
        server2.server + server2.tls.toString() + "-" + index2.toString()
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.add") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumAddServer, { onAdd })
    ] })
  ] });
};
const ElectrumSettings = () => {
  const { t: t2 } = useTranslation();
  const [activeTab, setActiveTab] = reactExports.useState("btc");
  const testing = useLoad(() => getTesting());
  const handleTab = (e3) => {
    const selectedTab = e3.currentTarget.getAttribute("data-tab");
    if (selectedTab !== "btc" && selectedTab !== "ltc") {
      console.error("Unrecognized tab ID");
      return;
    }
    setActiveTab(selectedTab);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.expert.electrum.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center tabs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "btc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "btc", children: t2(`settings.electrum.title-${testing ? "tbtc" : "btc"}`) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "ltc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "ltc", children: t2(`settings.electrum.title-${testing ? "tltc" : "ltc"}`) }) })
        ] }),
        activeTab === "btc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tbtc" : "btc"
          },
          testing ? "tbtc" : "btc"
        ),
        activeTab === "ltc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tltc" : "ltc"
          },
          testing ? "tltc" : "ltc"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonLink,
          {
            secondary: true,
            to: "/settings",
            children: t2("button.back")
          }
        ) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.what") }, "guide.settings-electrum.what"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.options") }, "guide.settings-electrum.options"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.connection") }, "guide.settings-electrum.connection"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.settings-electrum.instructions.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/14-privatsphare/29-verbindung-der-bitboxapp-zu-meinem-bitcoin-full-node" : "https://shiftcrypto.support/help/en-us/14-privacy/29-how-to-connect-the-bitboxapp-to-my-own-full-node"
        },
        text: t2("guide.settings-electrum.instructions.text"),
        title: t2("guide.settings-electrum.instructions.title")
      } }, "guide.settings-electrum.instructions")
    ] })
  ] });
};
const INFO_STEPS_ENABLE = 5;
const INFO_STEPS_DISABLE = 0;
const CONTENT_MIN_HEIGHT = "38em";
class Passphrase extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      infoStep: 0,
      status: "info",
      understood: false
    };
    this.togglePassphrase = async () => {
      const { deviceID, t: t2 } = this.props;
      const enable = !this.state.passphraseEnabled;
      this.setState({ status: "progress" });
      try {
        const result = await setMnemonicPassphraseEnabled(deviceID, enable);
        if (!result.success) {
          route(`/settings/device-settings/${deviceID}`);
          alertUser(t2(`passphrase.error.e${result.code}`, {
            defaultValue: result.message || t2("genericError")
          }));
          return;
        }
        const deviceInfoResult = await getDeviceInfo(deviceID);
        if (deviceInfoResult.success) {
          this.setState({
            passphraseEnabled: deviceInfoResult.deviceInfo.mnemonicPassphraseEnabled,
            status: "success"
          });
        }
      } catch (error3) {
        console.error(error3);
      }
    };
    this.stopInfo = () => route(`/settings/device-settings/${this.props.deviceID}`);
    this.continueInfo = () => {
      if (this.state.infoStep === 0) {
        this.togglePassphrase();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep - 1 }));
    };
    this.backInfo = () => {
      if (this.state.infoStep === void 0) {
        return;
      }
      const enabled = this.state.passphraseEnabled;
      if (!enabled && this.state.infoStep >= INFO_STEPS_ENABLE || enabled && this.state.infoStep >= INFO_STEPS_DISABLE) {
        this.stopInfo();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep + 1 }));
    };
    this.renderEnableInfo = () => {
      const { infoStep, understood } = this.state;
      const { t: t2 } = this.props;
      switch (infoStep) {
        case 5:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.intro.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.intro.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.what.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-intro"
          );
        case 4:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.what.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.what.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.why.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-what"
          );
        case 3:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.why.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.why.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.considerations.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-why"
          );
        case 2:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.considerations.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.considerations.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.how.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-considerations"
          );
        case 1:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.how.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.how.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.summary.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-how"
          );
        case 0:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.summary.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.0") }, "info-1"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.1") }, "info-2"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.2") }, "info-3"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.3") }, "info-4")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: understood ? "success" : "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      onChange: (e3) => {
                        var _a;
                        return this.setState({ understood: (_a = e3.target) == null ? void 0 : _a.checked });
                      },
                      id: "understood",
                      checked: understood,
                      label: t2("passphrase.summary.understand"),
                      checkboxStyle: understood ? "success" : "warning"
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, disabled: !understood, children: t2("passphrase.enable") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-summary"
          );
        default:
          console.error(`invalid infoStep ${infoStep}`);
          return;
      }
    };
    this.renderDisableInfo = () => {
      const { t: t2 } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          minHeight: CONTENT_MIN_HEIGHT,
          onClose: this.stopInfo,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.disable") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.disableInfo.message") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.disableInfo.button") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
            ] })
          ]
        },
        "step-disable-info1"
      );
    };
  }
  componentDidMount() {
    getDeviceInfo(this.props.deviceID).then((result) => {
      if (!result.success) {
        console.error(result.message);
        alertUser(this.props.t("genericError"));
        return;
      }
      const { mnemonicPassphraseEnabled } = result.deviceInfo;
      this.setState({
        // before enabling/disabling we show 1 or more pages to inform about the feature
        // each page has a continue button that jumps to the next or finally toggles passphrase
        // infoStep counts down in decreasing order
        infoStep: mnemonicPassphraseEnabled ? INFO_STEPS_DISABLE : INFO_STEPS_ENABLE,
        passphraseEnabled: mnemonicPassphraseEnabled
      });
    }).catch(console.error);
  }
  render() {
    const { t: t2 } = this.props;
    const { passphraseEnabled, status: status2 } = this.state;
    if (passphraseEnabled === void 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "info" && (passphraseEnabled ? this.renderDisableInfo() : this.renderEnableInfo()),
      status2 === "progress" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          minHeight: CONTENT_MIN_HEIGHT,
          textCenter: true,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                title: t2(passphraseEnabled ? "passphrase.progressDisable.title" : "passphrase.progressEnable.title"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SimpleMarkup,
                  {
                    tagName: "p",
                    markup: t2(passphraseEnabled ? "passphrase.progressDisable.message" : "passphrase.progressEnable.message")
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
          ]
        },
        "progress"
      ),
      status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                small: true,
                title: t2(passphraseEnabled ? "passphrase.successDisabled.title" : "passphrase.successEnabled.title")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2(passphraseEnabled ? "passphrase.successDisabled.message" : "passphrase.successEnabled.message") }),
              passphraseEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { paddingLeft: "var(--space-default)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.0") }, "tip-1"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.1") }, "tip-2")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2(
                passphraseEnabled ? "passphrase.successDisabled.messageEnd" : "passphrase.successEnabled.messageEnd"
              ) })
            ] })
          ]
        },
        "progress"
      )
    ] });
  }
}
const HOC = translate()(Passphrase);
const getBitsuranceURL = () => {
  return apiGet("bitsurance/url");
};
const bitsuranceLookup = (code = "") => {
  return apiPost("bitsurance/lookup", { code });
};
const syncContainer = "_syncContainer_nrzbt_1";
const progressBar = "_progressBar_nrzbt_8";
const progressValue = "_progressValue_nrzbt_14";
const syncMessage = "_syncMessage_nrzbt_21";
const syncText = "_syncText_nrzbt_33";
const spinnerContainer = "_spinnerContainer_nrzbt_39";
const spinner = "_spinner_nrzbt_39";
const changeContent = "_changeContent_nrzbt_1";
const style$f = {
  syncContainer,
  progressBar,
  progressValue,
  syncMessage,
  syncText,
  spinnerContainer,
  spinner,
  changeContent
};
const HeadersSync = ({ coinCode }) => {
  const { i18n, t: t2 } = useTranslation();
  const status2 = useSubscribe(subscribeCoinHeaders(coinCode));
  const [hidden, setHidden] = reactExports.useState(false);
  const mounted = useMountedRef();
  reactExports.useEffect(() => {
    if (mounted.current && status2 && status2.tip === status2.targetHeight) {
      setTimeout(() => setHidden(true), 4e3);
    }
  }, [mounted, status2]);
  if (!status2 || hidden) {
    return null;
  }
  const total2 = status2.targetHeight - status2.tipAtInitTime;
  const value = 100 * (status2.tip - status2.tipAtInitTime) / total2;
  const loaded = !total2 || value >= 100;
  const formatted = new Intl.NumberFormat(i18n.language).format(status2.tip);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncMessage, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncText, children: [
        t2("headerssync.blocksSynced", { blocks: formatted }),
        " ",
        !loaded && `(${Math.ceil(value)}%)`
      ] }),
      !loaded ? /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {}) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "progress-bar", className: style$f.progressBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$f.progressValue, style: { width: `${value}%` } }) })
  ] });
};
const container$7 = "_container_13974_1";
const background = "_background_13974_6";
const foreground = "_foreground_13974_7";
const complete = "_complete_13974_19";
const pending = "_pending_13974_23";
const generic = "_generic_13974_24";
const error2 = "_error_13974_28";
const style$e = {
  container: container$7,
  background,
  foreground,
  complete,
  pending,
  generic,
  error: error2
};
const ProgressRing = ({
  className,
  generic: generic2,
  isComplete,
  isError,
  value,
  width
}) => {
  const radius = (width - 3) / 2;
  const circumference = radius * 2 * Math.PI;
  const progress = isError ? 100 : value / 100;
  const offset = circumference * (1 - progress);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: [style$e.container, className ? className : ""].join(" "),
      width,
      height: width,
      style: { minWidth: width },
      viewBox: `0 0 ${width} ${width}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: style$e.background,
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: [
              style$e.foreground,
              !generic2 && isComplete ? style$e.complete : style$e.pending,
              generic2 && style$e.generic,
              isError && style$e.error
            ].join(" "),
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3,
            strokeDashoffset: offset,
            strokeDasharray: circumference
          }
        )
      ]
    }
  );
};
const txArrowType = "_txArrowType_m24u9_1";
const txArrowTypeIn = "_txArrowTypeIn_m24u9_6";
const txArrowTypeOut = "_txArrowTypeOut_m24u9_10";
const txArrowTypeSelf = "_txArrowTypeSelf_m24u9_14";
const style$d = {
  txArrowType,
  txArrowTypeIn,
  txArrowTypeOut,
  txArrowTypeSelf
};
const ArrowIn = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeIn}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
);
const ArrowOut = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeOut}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
);
const ArrowSelf = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeSelf}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 5 19 12 12 19" })
    ]
  }
);
const container$6 = "_container_j1azs_1";
const row$1 = "_row_j1azs_5";
const date$1 = "_date_j1azs_15";
const address$1 = "_address_j1azs_19";
const badge = "_badge_j1azs_24";
const statusIndicator = "_statusIndicator_j1azs_29";
const statusIndicatorComplete = "_statusIndicatorComplete_j1azs_37";
const statusIndicatorPending = "_statusIndicatorPending_j1azs_41";
const statusIndicatorFailed = "_statusIndicatorFailed_j1azs_45";
const status$1 = "_status_j1azs_29";
const fiat$1 = "_fiat_j1azs_53";
const amount = "_amount_j1azs_57";
const amountOverflow = "_amountOverflow_j1azs_62";
const send$1 = "_send_j1azs_74";
const receive$1 = "_receive_j1azs_78";
const failed$1 = "_failed_j1azs_82";
const currency$1 = "_currency_j1azs_86";
const currencyUnit = "_currencyUnit_j1azs_90";
const action$1 = "_action_j1azs_101";
const label$1 = "_label_j1azs_112";
const columnLabel = "_columnLabel_j1azs_117";
const inlineLabel = "_inlineLabel_j1azs_118";
const inlineValue = "_inlineValue_j1azs_132";
const fee = "_fee_j1azs_136";
const transactionId = "_transactionId_j1azs_140";
const detail = "_detail_j1azs_145";
const detailInput = "_detailInput_j1azs_146";
const textOnlyInput = "_textOnlyInput_j1azs_163";
const editButton = "_editButton_j1azs_171";
const addresses = "_addresses_j1azs_211";
const detailAddresses = "_detailAddresses_j1azs_222";
const detailAddress = "_detailAddress_j1azs_222";
const first = "_first_j1azs_235";
const style$c = {
  container: container$6,
  row: row$1,
  date: date$1,
  address: address$1,
  badge,
  statusIndicator,
  statusIndicatorComplete,
  statusIndicatorPending,
  statusIndicatorFailed,
  status: status$1,
  fiat: fiat$1,
  amount,
  amountOverflow,
  send: send$1,
  receive: receive$1,
  failed: failed$1,
  currency: currency$1,
  currencyUnit,
  action: action$1,
  label: label$1,
  columnLabel,
  inlineLabel,
  inlineValue,
  fee,
  transactionId,
  detail,
  detailInput,
  textOnlyInput,
  editButton,
  addresses,
  detailAddresses,
  detailAddress,
  first
};
function Note({ accountCode, note: note2, internalID }) {
  const { isDarkMode } = useDarkmode();
  const { t: t2 } = useTranslation();
  const [newNote, setNewNote] = reactExports.useState(note2);
  const [editMode, setEditMode] = reactExports.useState(!note2);
  const inputRef = reactExports.useRef(null);
  const editButtonRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (editMode && inputRef.current) {
      inputRef.current.focus();
    }
  }, [editMode]);
  const handleNoteInput = (e3) => {
    const target = e3.target;
    setNewNote(target.value);
  };
  const handleEdit = (e3) => {
    e3.preventDefault();
    if (editMode && note2 !== newNote) {
      postNotesTx(accountCode, {
        internalTxID: internalID,
        note: newNote
      }).catch(console.error);
    }
    setEditMode(!editMode);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleEdit, className: style$c.detailInput, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "note", children: t2("note.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        align: "right",
        autoFocus: editMode,
        className: style$c.textOnlyInput,
        readOnly: !editMode,
        type: "text",
        id: "note",
        transparent: true,
        placeholder: t2("note.input.placeholder"),
        value: newNote,
        maxLength: 256,
        onInput: handleNoteInput,
        ref: inputRef
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: style$c.editButton,
        onClick: handleEdit,
        title: t2(`transaction.note.${editMode ? "save" : "edit"}`),
        type: "button",
        ref: editButtonRef,
        children: editMode ? isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaveLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {}) : isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(EditLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Edit, {})
      }
    )
  ] });
}
const container$5 = "_container_1x5wu_1";
const header$2 = "_header_1x5wu_6";
const columns = "_columns_1x5wu_18";
const headers = "_headers_1x5wu_28";
const columnGroup = "_columnGroup_1x5wu_34";
const type = "_type_1x5wu_47";
const date = "_date_1x5wu_53";
const activity = "_activity_1x5wu_58";
const status = "_status_1x5wu_64";
const fiat = "_fiat_1x5wu_69";
const currency = "_currency_1x5wu_75";
const action = "_action_1x5wu_81";
const empty = "_empty_1x5wu_88";
const hideOnMedium = "_hideOnMedium_1x5wu_104";
const showOnMedium = "_showOnMedium_1x5wu_114";
const style$b = {
  container: container$5,
  header: header$2,
  columns,
  headers,
  columnGroup,
  type,
  date,
  activity,
  status,
  fiat,
  currency,
  action,
  empty,
  hideOnMedium,
  showOnMedium
};
const Transaction = ({
  accountCode,
  index: index2,
  internalID,
  explorerURL,
  type: type2,
  amount: amount2,
  feeRatePerKb,
  numConfirmations,
  numConfirmationsComplete,
  time: time2,
  addresses: addresses2,
  status: status2,
  note: note2 = ""
}) => {
  const { i18n, t: t2 } = useTranslation();
  const [transactionDialog, setTransactionDialog] = reactExports.useState(false);
  const [transactionInfo, setTransactionInfo] = reactExports.useState();
  const parseTimeShort = (time22) => {
    const options2 = {
      year: "numeric",
      month: "numeric",
      day: "numeric"
    };
    return new Date(Date.parse(time22)).toLocaleString(i18n.language, options2);
  };
  const showDetails = () => {
    getTransaction(accountCode, internalID).then((transaction2) => {
      if (!transaction2) {
        console.error("Unable to retrieve transaction " + internalID);
        return null;
      }
      setTransactionInfo(transaction2);
      setTransactionDialog(true);
    }).catch(console.error);
  };
  const arrow2 = status2 === "failed" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { maxWidth: "18px" } }) : type2 === "receive" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIn, {}) : type2 === "send" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowOut, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSelf, {});
  const sign = type2 === "send" && "" || type2 === "receive" && "+" || "";
  const typeClassName = status2 === "failed" && style$c.failed || type2 === "send" && style$c.send || type2 === "receive" && style$c.receive || "";
  const sDate = time2 ? parseTimeShort(time2) : "---";
  const statusText = t2(`transaction.status.${status2}`);
  const progress = numConfirmations < numConfirmationsComplete ? numConfirmations / numConfirmationsComplete * 100 : 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.container, index2 === 0 ? style$c.first : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$b.columns, style$c.row].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.columnGroup, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.type, children: arrow2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.date, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.columnLabel, children: [
            t2("transaction.details.date"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.date, children: sDate })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.activity, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.address, children: note2 }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.activity, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.label, children: t2(type2 === "receive" ? "transaction.tx.received" : "transaction.tx.sent") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.address, children: [
            addresses2[0],
            addresses2.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.badge, children: [
              "(+",
              addresses2.length - 1,
              ")"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$b.action, style$b.hideOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$c.action, onClick: showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.columnGroup, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.status, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.columnLabel, children: [
            t2("transaction.details.status"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ProgressRing,
            {
              className: "m-right-quarter",
              width: 14,
              value: progress,
              isComplete: numConfirmations >= numConfirmationsComplete
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.status, children: statusText })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.fiat, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: true }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$b.currency} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: `${style$c.amount} ${style$c.amountOverflow}`,
            "data-unit": ` ${amount2.unit}`,
            children: [
              sign,
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.currencyUnit, children: [
                "",
                amount2.unit
              ] })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$b.action, style$b.showOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$c.action, onClick: showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: transactionDialog,
        title: t2("transaction.details.title"),
        onClose: () => setTransactionDialog(false),
        slim: true,
        medium: true,
        children: transactionInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Note,
            {
              accountCode,
              internalID,
              note: note2
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: arrow2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.confirmation") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: numConfirmations })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.status") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "flex flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ProgressRing,
                {
                  className: "m-right-quarter",
                  width: 14,
                  value: progress,
                  isComplete: numConfirmations >= numConfirmationsComplete
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.status, children: [
                statusText,
                " ",
                status2 === "pending" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "(",
                  numConfirmations,
                  "/",
                  numConfirmationsComplete,
                  ")"
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.date") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: sDate })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiat") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: true }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiatAtTime") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: transactionInfo.amountAtTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: transactionInfo.amountAtTime, sign, noAction: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { noAction: true }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.amount") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: typeClassName, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.amount, children: [
                sign,
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit })
              ] }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: transactionInfo.amount.unit })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.fee") }),
            transactionInfo.fee && transactionInfo.fee.amount ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { title: feeRatePerKb.amount ? feeRatePerKb.amount + " " + feeRatePerKb.unit + "/Kb" : "", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: transactionInfo.fee.amount, unit: transactionInfo.fee.unit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: transactionInfo.fee.unit })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "---" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.detail, style$c.addresses].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.address") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.detailAddresses, children: transactionInfo.addresses.map((address2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyableInput,
              {
                alignRight: true,
                borderLess: true,
                flexibleHeight: true,
                className: style$c.detailAddress,
                value: address2
              },
              address2
            )) })
          ] }),
          transactionInfo.gas ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.gas") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.gas })
          ] }) : null,
          transactionInfo.nonce !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Nonce" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.nonce })
          ] }) : null,
          transactionInfo.weight ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.weight") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.weight,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "WU" })
            ] })
          ] }) : null,
          transactionInfo.vsize ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.vsize") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.vsize,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "b" })
            ] })
          ] }) : null,
          transactionInfo.size ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.size") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.size,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "b" })
            ] })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.detail, style$c.addresses].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.explorer") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.detailAddresses, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyableInput,
              {
                alignRight: true,
                borderLess: true,
                flexibleHeight: true,
                className: style$c.detailAddress,
                value: transactionInfo.txID
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$c.detail, "flex-center"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            A$3,
            {
              href: explorerURL + transactionInfo.txID,
              title: `${t2("transaction.explorerTitle")}
${explorerURL}${transactionInfo.txID}`,
              children: t2("transaction.explorerTitle")
            }
          ) })
        ] })
      }
    )
  ] });
};
const Transactions = ({
  accountCode,
  explorerURL,
  transactions: transactions2,
  handleExport
}) => {
  const { t: t2 } = useTranslation();
  const csvExportDisabled = runningInAndroid();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("accountSummary.transactionHistory") }),
      !csvExportDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          transparent: true,
          onClick: handleExport,
          title: t2("account.exportTransactions"),
          children: t2("account.export")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$b.columns, style$b.headers, style$b.showOnMedium].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.type, children: t2("transaction.details.type") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.date, children: t2("transaction.details.date") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.activity, children: t2("transaction.details.activity") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.status, children: t2("transaction.details.status") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.fiat, children: t2("transaction.details.fiatAmount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.currency, children: t2("transaction.details.amount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.action, children: "" })
    ] }),
    transactions2 && transactions2.success && transactions2.list.length > 0 ? transactions2.list.map((props, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Transaction,
      {
        accountCode,
        explorerURL,
        index: index2,
        ...props
      },
      props.internalID
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-row flex-center ${style$b.empty}`, children: transactions2 && !transactions2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.errorLoadTransactions") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.placeholder") }) })
  ] });
};
const container$4 = "_container_1x7yq_1";
const header$1 = "_header_1x7yq_12";
const actionsContainer = "_actionsContainer_1x7yq_23";
const buy = "_buy_1x7yq_30";
const receive = "_receive_1x7yq_31";
const walletConnect = "_walletConnect_1x7yq_32";
const send = "_send_1x7yq_33";
const withWalletConnect = "_withWalletConnect_1x7yq_56";
const disabled = "_disabled_1x7yq_68";
const accountIcon = "_accountIcon_1x7yq_77";
const style$a = {
  container: container$4,
  header: header$1,
  actionsContainer,
  buy,
  receive,
  walletConnect,
  send,
  withWalletConnect,
  disabled,
  accountIcon
};
const ActionButtons = ({ canSend, code, coinCode, exchangeBuySupported, account: account2 }) => {
  const { t: t2 } = useTranslation();
  const navigate2 = useNavigate();
  const walletConnectEnabled = isEthereumBased(account2.coinCode) && !account2.isToken;
  const isLargeTablet = useMediaQuery("(max-width: 830px)");
  const sendLink = `/account/${code}/send`;
  const maybeRouteSend = async (e3) => {
    e3.preventDefault();
    const connectResult = await connectKeystore(code);
    if (connectResult.success) {
      navigate2(sendLink);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$a.actionsContainer} ${walletConnectEnabled ? style$a.withWalletConnect : ""}`, children: [
    canSend ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: sendLink, className: style$a.send, onClick: isEthereumBased(coinCode) ? maybeRouteSend : void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.send") }) }, "sendLink") : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$a.send} ${style$a.disabled}`, children: t2("button.send") }, "sendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/account/${code}/receive`, className: style$a.receive, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.receive") }) }, "receive"),
    exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/buy/info/${code}`, className: style$a.buy, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.buy") }) }, "buy"),
    walletConnectEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/wallet-connect/dashboard`, className: style$a.walletConnect, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 24 }),
      " ",
      !isLargeTablet && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
    ] }, "wallet-connect")
  ] });
};
function AccountGuide({
  account: account2,
  unit: unit2,
  hasNoBalance,
  hasIncomingBalance,
  hasTransactions
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountDescription") }, "accountDescription"),
    hasNoBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSendDisabled", {
      unit: unit2
    }) }, "accountSendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountReload") }, "accountReload"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionLabel") }, "accountTransactionLabel"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionTime") }, "accountTransactionTime"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesGeneric") }, "accountTransactionAttributesGeneric"),
    hasTransactions && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesBTC") }, "accountTransactionAttributesBTC"),
    hasIncomingBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountIncomingBalance") }, "accountIncomingBalance"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionConfirmation") }, "accountTransactionConfirmation"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountFiat") }, "accountFiat"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "accountRates"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "CoinTracking",
        url: "https://cointracking.info/import/bitbox/?ref=BITBOX"
      },
      text: t2("guide.cointracking.text"),
      title: t2("guide.cointracking.title")
    } }, "cointracking")
  ] });
}
function Account({
  accounts,
  code,
  devices
}) {
  const { t: t2 } = useTranslation();
  const [balance2, setBalance] = reactExports.useState();
  const [status2, setStatus] = reactExports.useState();
  const [syncedAddressesCount, setSyncedAddressesCount] = reactExports.useState();
  const [transactions2, setTransactions] = reactExports.useState();
  const [usesProxy, setUsesProxy] = reactExports.useState();
  const [insured2, setInsured] = reactExports.useState(false);
  const [uncoveredFunds, setUncoveredFunds] = reactExports.useState([]);
  const [stateCode, setStateCode] = reactExports.useState();
  const supportedExchanges = useLoad(getExchangeBuySupported(code), [code]);
  const account2 = accounts && accounts.find((acct) => acct.code === code);
  const getBitsuranceGuideLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://bitbox.swiss/redirects/bitsurance-segwit-migration-guide-de/";
      default:
        return "https://bitbox.swiss/redirects/bitsurance-segwit-migration-guide-en/";
    }
  };
  const checkUncoveredUTXOs = reactExports.useCallback(async () => {
    const uncoveredScripts = [];
    const utxos = await getUTXOs(code);
    utxos.forEach((utxo2) => {
      if (utxo2.scriptType !== "p2wpkh" && !uncoveredScripts.includes(utxo2.scriptType)) {
        uncoveredScripts.push(utxo2.scriptType);
      }
    });
    setUncoveredFunds(uncoveredScripts.map(getScriptName));
  }, [code]);
  const maybeCheckBitsuranceStatus = reactExports.useCallback(async () => {
    if (account2 == null ? void 0 : account2.bitsuranceStatus) {
      const insuredAccounts = await bitsuranceLookup(code);
      if (!insuredAccounts.success) {
        alertUser(insuredAccounts.errorMessage || t2("genericError"));
        return;
      }
      const config = await getConfig();
      let cancelledAccounts = config.frontend.bitsuranceNotifyCancellation;
      if (cancelledAccounts == null ? void 0 : cancelledAccounts.some((accountCode) => accountCode === code)) {
        alertUser(t2("account.insuranceExpired"));
        config.frontend.bitsuranceNotifyCancellation = cancelledAccounts.filter((accountCode) => accountCode !== code);
        setConfig(config);
      }
      let bitsuranceAccount2 = insuredAccounts.bitsuranceAccounts[0];
      if (bitsuranceAccount2.status === "active") {
        setInsured(true);
        checkUncoveredUTXOs();
        return;
      }
    }
    setInsured(false);
  }, [t2, account2, code, checkUncoveredUTXOs]);
  reactExports.useEffect(() => {
    maybeCheckBitsuranceStatus();
    getConfig().then(({ backend }) => setUsesProxy(backend.proxy.useProxy));
  }, [maybeCheckBitsuranceStatus]);
  const hasCard = useSDCard(devices, [code]);
  const onAccountChanged = reactExports.useCallback((code2, status22) => {
    if (!code2 || status22 === void 0 || status22.fatalError) {
      return;
    }
    if (status22.synced && status22.offlineError === null) {
      const currentCode = code2;
      Promise.all([
        getBalance(currentCode).then((newBalance) => {
          if (currentCode !== code2) {
            return;
          }
          setBalance(newBalance);
        }),
        getTransactionList(code2).then((newTransactions) => {
          if (currentCode !== code2) {
            return;
          }
          setTransactions(newTransactions);
        })
      ]).catch(console.error);
    } else {
      setBalance(void 0);
      setTransactions(void 0);
    }
  }, []);
  const onStatusChanged = reactExports.useCallback(() => {
    const currentCode = code;
    if (!currentCode) {
      return;
    }
    getStatus$2(currentCode).then(async (status22) => {
      if (currentCode !== code) {
        return;
      }
      setStatus(status22);
      if (!status22.disabled && !status22.synced) {
        await init(currentCode).catch(console.error);
      }
      onAccountChanged(code, status22);
    }).catch(console.error);
  }, [onAccountChanged, code]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      syncAddressesCount(code)(setSyncedAddressesCount),
      statusChanged$1((eventCode) => eventCode === code && onStatusChanged()),
      syncdone((eventCode) => eventCode === code && onAccountChanged(code, status2))
    ];
    return () => unsubscribe(subscriptions2);
  }, [code, onAccountChanged, onStatusChanged, status2]);
  function exportAccount$1() {
    if (status2 === void 0 || status2.fatalError) {
      return;
    }
    exportAccount(code).then((result) => {
      if (result !== null && !result.success) {
        alertUser(result.errorMessage);
      }
    }).catch(console.error);
  }
  reactExports.useEffect(() => {
    setStateCode(code);
    setBalance(void 0);
    setStatus(void 0);
    setSyncedAddressesCount(0);
    setTransactions(void 0);
    onStatusChanged();
  }, [code, onStatusChanged]);
  const hasDataLoaded = balance2 !== void 0 && transactions2 !== void 0;
  if (stateCode !== code) {
    return null;
  }
  if (!account2 || status2 === void 0) {
    return null;
  }
  if (status2.fatalError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("account.fatalError") });
  }
  if (status2.offlineError !== null) {
    const offlineErrorTextLines = [];
    offlineErrorTextLines.push(t2("account.reconnecting"));
    offlineErrorTextLines.push(status2.offlineError);
    if (usesProxy) {
      offlineErrorTextLines.push(t2("account.maybeProxyError"));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: offlineErrorTextLines.join("\n") });
  }
  if (!status2.synced) {
    const text2 = syncedAddressesCount !== void 0 && syncedAddressesCount > 1 ? "\n" + t2("account.syncedAddressesCount", {
      count: syncedAddressesCount.toString(),
      defaultValue: 0
    }) : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("account.initializing") + text2 });
  }
  if (!hasDataLoaded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: "" });
  }
  const exchangeBuySupported = supportedExchanges && supportedExchanges.exchanges.length > 0;
  const isAccountEmpty = balance2 && !balance2.hasAvailable && !balance2.hasIncoming && transactions2 && transactions2.success && transactions2.list.length === 0;
  const actionButtonsProps = {
    code,
    coinCode: account2.coinCode,
    canSend: balance2 && balance2.hasAvailable,
    exchangeBuySupported,
    account: account2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: insured2 && uncoveredFunds.length !== 0, medium: true, title: t2("account.warning"), onClose: () => setUncoveredFunds([]), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("account.uncoveredFunds", {
          name: account2.name,
          uncovered: uncoveredFunds
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: getBitsuranceGuideLink(), children: t2("account.uncoveredFundsLink") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Header,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name }),
            insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Insured, {})
          ] }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/info`, title: t2("accountInfo.title"), className: "flex flex-row flex-items-center m-left-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$a.accountIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("accountInfo.label") })
            ] })
          ]
        }
      ),
      status2.synced && hasDataLoaded && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(HeadersSync, { coinCode: account2.coinCode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer scrollableContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-reverse-mobile", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile hide-on-small", children: t2("accountSummary.availableBalance") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-item-center flex-column-mobile flex-reverse-mobile", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile show-on-small", children: t2("accountSummary.availableBalance") }),
            !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtons, { ...actionButtonsProps })
          ] })
        ] }),
        isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          BuyReceiveCTA,
          {
            account: account2,
            code,
            exchangeBuySupported,
            unit: balance2.available.unit,
            balanceList: [balance2]
          }
        ),
        !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Transactions,
          {
            accountCode: code,
            handleExport: exportAccount$1,
            explorerURL: account2.blockExplorerTxPrefix,
            transactions: transactions2
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccountGuide,
      {
        account: account2,
        unit: balance2 == null ? void 0 : balance2.available.unit,
        hasIncomingBalance: balance2 && balance2.hasIncoming,
        hasTransactions: transactions2 !== void 0 && transactions2.success && transactions2.list.length > 0,
        hasNoBalance: balance2 && balance2.available.amount === "0"
      }
    )
  ] });
}
const ReceiveAccountsSelector = ({ activeAccounts }) => {
  const [code, setCode] = reactExports.useState("");
  const { t: t2 } = useTranslation();
  const handleProceed = () => {
    route(`/account/${code}/receive`);
  };
  const hasOnlyBTCAccounts = activeAccounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const title2 = t2("receive.title", { accountName: hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto") });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: activeAccounts && activeAccounts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      GroupedAccountSelector,
      {
        title: t2("receive.selectAccount"),
        accounts: activeAccounts,
        selected: code,
        onChange: setCode,
        onProceed: handleProceed
      }
    ) }) })
  ] });
};
const DarkmodeToggleSetting = () => {
  const { t: t2 } = useTranslation();
  const { toggleDarkmode, isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("darkmode.toggle"),
      secondaryText: t2("newSettings.appearance.darkmode.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { checked: isDarkMode, onChange: () => toggleDarkmode(!isDarkMode) })
    }
  );
};
const dropdown = "_dropdown_1uw27_1";
const select$2 = "_select_1uw27_10";
const dropdownStyles = {
  dropdown,
  select: select$2
};
const DropdownIndicator2 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) });
};
const Option2 = (props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
};
const SingleValue2 = (props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
};
const SingleDropdown = ({ options: options2, handleChange, defaultValue }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: dropdownStyles.select,
      classNamePrefix: "react-select",
      isSearchable: true,
      defaultValue,
      components: { IndicatorSeparator: () => null, DropdownIndicator: DropdownIndicator2, SingleValue: SingleValue2, Option: Option2 },
      onChange: (selected2) => {
        if (selected2) {
          const value = (selected2 == null ? void 0 : selected2.value) || "";
          handleChange(value);
        }
      },
      options: options2
    }
  );
};
const DefaultCurrencyDropdownSetting = () => {
  var _a;
  const { t: t2 } = useTranslation();
  const { selectFiat, updateDefaultFiat, defaultCurrency: defaultCurrency2, activeCurrencies } = reactExports.useContext(RatesContext);
  const valueLabel = (_a = currenciesWithDisplayName.find((fiat2) => fiat2.currency === defaultCurrency2)) == null ? void 0 : _a.displayName;
  const defaultValueLabel = valueLabel ? `${valueLabel} (${defaultCurrency2})` : defaultCurrency2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.defaultCurrency.title"),
      secondaryText: t2("newSettings.appearance.defaultCurrency.description"),
      collapseOnSmall: true,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedCurrencies,
          handleChange: async (fiat2) => {
            updateDefaultFiat(fiat2);
            if (!activeCurrencies.includes(fiat2)) {
              await selectFiat(fiat2);
            }
          },
          defaultValue: {
            label: defaultValueLabel,
            value: defaultCurrency2
          }
        }
      )
    }
  );
};
const DisplaySatsToggleSetting = () => {
  const { t: t2 } = useTranslation();
  const fetchedConfig = useLoad(getConfig);
  const [displayAsSAT, setDisplayAsSAT] = reactExports.useState();
  const { updateRatesConfig } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (fetchedConfig) {
      setDisplayAsSAT(fetchedConfig.backend.btcUnit === "sat");
    }
  }, [fetchedConfig]);
  const handleToggleSatsUnit = async () => {
    const toggleDdisplayAsSAT = !displayAsSAT;
    const unit2 = toggleDdisplayAsSAT ? "sat" : "default";
    setDisplayAsSAT(toggleDdisplayAsSAT);
    await setConfig({
      backend: { btcUnit: unit2 }
    });
    updateRatesConfig();
    const result = await setBtcUnit(unit2);
    if (!result.success) {
      alertUser(t2("genericError"));
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.useSats"),
      secondaryText: t2("newSettings.appearance.toggleSats.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: displayAsSAT !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: displayAsSAT,
          onChange: handleToggleSatsUnit
        }
      ) : null })
    }
  ) });
};
const LanguageDropdownSetting = () => {
  const { i18n, t: t2 } = useTranslation();
  const selectedLanguage = defaultLanguages[getSelectedIndex(defaultLanguages, i18n)];
  const formattedLanguages = defaultLanguages.map((lang) => ({ label: lang.display, value: lang.code }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.language.title"),
      secondaryText: t2("newSettings.appearance.language.description"),
      collapseOnSmall: true,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedLanguages,
          handleChange: i18n.changeLanguage,
          defaultValue: { label: selectedLanguage.display, value: selectedLanguage.code }
        }
      )
    }
  );
};
const select$1 = "_select_1j2fm_1";
const hideMultiSelect = "_hideMultiSelect_1j2fm_30";
const defaultCurrency = "_defaultCurrency_1j2fm_51";
const defaultLabel = "_defaultLabel_1j2fm_55";
const activeCurrenciesDropdownStyle = {
  select: select$1,
  hideMultiSelect,
  defaultCurrency,
  defaultLabel
};
const ActiveCurrenciesDropdown = ({
  options: options2,
  defaultCurrency: defaultCurrency2,
  activeCurrencies
}) => {
  const [formattedActiveCurrencies, setFormattedActiveCurrencies] = reactExports.useState([]);
  const [search, setSearch] = reactExports.useState("");
  const { t: t2 } = useTranslation();
  const { unselectFiat, selectFiat } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (activeCurrencies.length > 0) {
      const formattedSelectedCurrencies = activeCurrencies.map((currency2) => ({ label: currency2, value: currency2 }));
      setFormattedActiveCurrencies(formattedSelectedCurrencies);
    }
  }, [activeCurrencies]);
  const DropdownIndicator3 = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) });
  };
  const Option3 = (props) => {
    const { label: label2, value } = props.data;
    const selected2 = formattedActiveCurrencies.findIndex((currency2) => currency2.value === value) >= 0;
    const isDefaultCurrency = defaultCurrency2 === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(components.Option, { ...props, className: `${isDefaultCurrency ? activeCurrenciesDropdownStyle.defaultCurrency : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }),
      isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: activeCurrenciesDropdownStyle.defaultLabel, children: t2("fiat.default") }) : null,
      selected2 && !isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedCheckLight, {}) : null
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: `
         ${dropdownStyles.select}
         ${activeCurrenciesDropdownStyle.select}
         ${search.length > 0 ? activeCurrenciesDropdownStyle.hideMultiSelect : ""}
         `,
      classNamePrefix: "react-select",
      isSearchable: true,
      isClearable: false,
      components: { DropdownIndicator: DropdownIndicator3, IndicatorSeparator: () => null, MultiValueRemove: () => null, Option: Option3 },
      isMulti: true,
      closeMenuOnSelect: false,
      hideSelectedOptions: false,
      value: [...formattedActiveCurrencies].reverse(),
      onInputChange: (newValue) => setSearch(newValue),
      onChange: async (_24, meta) => {
        switch (meta.action) {
          case "select-option":
            if (meta.option) {
              await selectFiat(meta.option.value);
            }
            break;
          case "deselect-option":
            if (meta.option && meta.option.value !== defaultCurrency2) {
              await unselectFiat(meta.option.value);
            }
        }
      },
      options: options2
    }
  );
};
const ActiveCurrenciesDropdownSetting = () => {
  const { t: t2 } = useTranslation();
  const { activeCurrencies, defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      collapseOnSmall: true,
      settingName: t2("newSettings.appearance.activeCurrencies.title"),
      secondaryText: t2("newSettings.appearance.activeCurrencies.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActiveCurrenciesDropdown,
        {
          options: formattedCurrencies,
          defaultCurrency: defaultCurrency2,
          activeCurrencies
        }
      )
    }
  );
};
const HideAmountsSetting = () => {
  const { t: t2 } = useTranslation();
  const { setHideAmounts } = reactExports.useContext(AppContext);
  const [allowHideAmounts, setAllowHideAmounts] = reactExports.useState();
  const config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      if (config.frontend.allowHideAmounts === void 0) {
        setAllowHideAmounts(false);
        return;
      }
      setAllowHideAmounts(config.frontend.allowHideAmounts);
    }
  }, [config]);
  const toggleAllowHideAmounts = async () => {
    if (allowHideAmounts) {
      setHideAmounts(false);
      await setConfig({
        frontend: { hideAmounts: false }
      });
    }
    setAllowHideAmounts(!allowHideAmounts);
    await setConfig({
      frontend: { allowHideAmounts: !allowHideAmounts }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.hideAmounts.title"),
      secondaryText: t2("newSettings.appearance.hideAmounts.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: allowHideAmounts !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: allowHideAmounts,
          onChange: toggleAllowHideAmounts
        }
      ) : null })
    }
  );
};
const Appearance = ({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.appearance") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { hasAccounts, hideMobileMenu: true, deviceIDs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultCurrencyDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActiveCurrenciesDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DarkmodeToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySatsToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsSetting, {})
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppearanceGuide, {})
  ] });
};
const AppearanceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.sats") }, "guide.settings.sats"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "guide.accountRates")
  ] });
};
const MobileSettings = ({ deviceIDs, hasAccounts }) => {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (!isMobile) {
      route("/settings/appearance");
    }
  }, [isMobile]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { deviceIDs, hasAccounts }) }) })
  ] });
};
const AppVersion = () => {
  const { t: t2 } = useTranslation();
  const version = useLoad(getVersion$1);
  const update = useLoad(getUpdate);
  const secondaryText2 = !!update ? t2("settings.info.out-of-date") : t2("settings.info.up-to-date");
  const icon2 = !!update ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {});
  const versionNumber = !!version ? version : "-";
  if (update === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.about.appVersion.title"),
      secondaryText: secondaryText2,
      displayedValue: versionNumber,
      extraComponent: icon2,
      onClick: update ? () => open(downloadLinkByLanguage()) : void 0
    }
  );
};
const About = ({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.about") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WithSettingsTabs, { deviceIDs, hideMobileMenu: true, hasAccounts, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppVersion, {}) }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AboutGuide, {})
  ] });
};
const AboutGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Guide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.servers") }, "guide.settings.servers") });
};
const EnableCustomFeesToggleSetting = ({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleFee = async (e3) => {
    const config = await setConfig({
      frontend: {
        "expertFee": e3.target.checked
      }
    });
    onChangeConfig(config);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.fee"),
      secondaryText: t2("newSettings.advancedSettings.customFees.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.expertFee) || false,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
};
const EnableCoinControlSetting = ({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleFee = async (e3) => {
    const config = await setConfig({
      frontend: {
        "coinControl": e3.target.checked
      }
    });
    onChangeConfig(config);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.coinControl"),
      secondaryText: t2("newSettings.advancedSettings.coinControl.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.coinControl) || false,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
};
const ConnectFullNodeSetting = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.electrum.title"),
      onClick: () => route("/settings/electrum"),
      secondaryText: t2("settings.expert.electrum.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChevronRightDark,
        {
          width: 24,
          height: 24
        }
      )
    }
  );
};
const TorProxyDialog = ({ open: open2, proxyConfig, onCloseDialog, onChangeConfig, handleShowRestartMessage }) => {
  const [proxyAddress, setProxyAddress] = reactExports.useState();
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (proxyConfig) {
      setProxyAddress(proxyConfig.proxyAddress);
    }
  }, [proxyConfig]);
  const handleSetProxyButton = async () => {
    if (!proxyConfig || proxyAddress === void 0) {
      return;
    }
    const proxy = proxyConfig;
    proxy.proxyAddress = proxyAddress.trim();
    const result = await socksProxyCheck(proxy.proxyAddress);
    const { success: success2, errorMessage: errorMessage2 } = result;
    if (success2) {
      await setProxyConfig(proxy);
    } else {
      alertUser(errorMessage2 || t2("account.fatalError"));
    }
  };
  const setProxyConfig = async (proxyConfig2) => {
    const config = await setConfig({
      backend: { proxy: proxyConfig2 }
    });
    setProxyAddress(proxyConfig2.proxyAddress);
    onChangeConfig(config);
    handleShowRestartMessage(true);
  };
  const handleToggleProxy = async (e3) => {
    if (!proxyConfig) {
      return;
    }
    const proxy = { ...proxyConfig, useProxy: e3.target.checked };
    await setProxyConfig(proxy);
  };
  const handleInputChange = (e3) => {
    setProxyAddress(e3.target.value);
    handleShowRestartMessage(false);
  };
  if (!proxyConfig || proxyConfig === void 0 || proxyAddress === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, onClose: onCloseDialog, title: t2("settings.expert.setProxyAddress"), small: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("settings.expert.useProxy") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          id: "useProxy",
          checked: proxyConfig.useProxy,
          onChange: handleToggleProxy
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          name: "proxyAddress",
          onInput: handleInputChange,
          value: proxyAddress,
          placeholder: "127.0.0.1:9050",
          disabled: !proxyConfig.useProxy
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: handleSetProxyButton,
          disabled: !proxyConfig.useProxy || proxyAddress === proxyConfig.proxyAddress,
          children: t2("settings.expert.setProxyAddress")
        }
      ) })
    ] })
  ] });
};
const inlineMessage = "_inlineMessage_gi9x3_1";
const success = "_success_gi9x3_7";
const left = "_left_gi9x3_12";
const close = "_close_gi9x3_16";
const style$9 = {
  inlineMessage,
  success,
  left,
  close
};
class InlineMessage extends reactExports.Component {
  deactivate = () => {
    this.props.onEnd();
  };
  render() {
    const {
      type: type2,
      message: message2,
      align
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.inlineMessage, style$9[type2], align ? style$9[align] : ""].join(" "), children: [
      message2,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.close, onClick: this.deactivate, children: "" })
    ] });
  }
}
const settingItem = "_settingItem_6ge6v_3";
const styles$b = {
  settingItem
};
const EnableTorProxySetting = ({ proxyConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const [showTorProxyDialog, setShowTorProxyDialog] = reactExports.useState(false);
  const [showRestartMessage, setShowRestartMessage] = reactExports.useState(false);
  const proxyEnabled = proxyConfig ? proxyConfig.useProxy : false;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showRestartMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineMessage,
      {
        type: "success",
        align: "left",
        message: t2("settings.restart"),
        onEnd: () => setShowRestartMessage(false)
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        className: styles$b.settingItem,
        settingName: t2("settings.expert.useProxy"),
        onClick: () => setShowTorProxyDialog(true),
        secondaryText: t2("newSettings.advancedSettings.torProxy.description"),
        displayedValue: proxyEnabled ? t2("generic.enabled_true") : t2("generic.enabled_false"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, { width: 24, height: 24 })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TorProxyDialog,
      {
        open: showTorProxyDialog,
        proxyConfig,
        onCloseDialog: () => setShowTorProxyDialog(false),
        onChangeConfig,
        handleShowRestartMessage: setShowRestartMessage
      }
    )
  ] });
};
const EnableAuthSetting = ({ backendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleAuth = async (e3) => {
    const unsubscribe2 = subscribeAuth((data) => {
      if (data.typ === "auth-ok") {
        updateConfig(!e3.target.checked);
        unsubscribe2();
      }
      if (data.typ === "auth-canceled") {
        unsubscribe2();
      }
    });
    forceAuth();
  };
  const updateConfig = async (auth2) => {
    const config = await setConfig({
      backend: { authentication: auth2 }
    });
    onAuthSettingChanged();
    onChangeConfig(config);
  };
  if (!runningInAndroid()) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.advancedSettings.authentication.title"),
      secondaryText: t2("newSettings.advancedSettings.authentication.description"),
      extraComponent: backendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (backendConfig == null ? void 0 : backendConfig.authentication) || false,
          onChange: handleToggleAuth
        }
      ) : null
    }
  );
};
const AdvancedSettings = ({ deviceIDs, hasAccounts }) => {
  var _a;
  const { t: t2 } = useTranslation();
  const fetchedConfig = useLoad(getConfig);
  const [config, setConfig2] = reactExports.useState();
  const frontendConfig = config == null ? void 0 : config.frontend;
  const backendConfig = config == null ? void 0 : config.backend;
  const proxyConfig = (_a = config == null ? void 0 : config.backend) == null ? void 0 : _a.proxy;
  reactExports.useEffect(() => {
    setConfig2(fetchedConfig);
  }, [fetchedConfig]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.advancedSettings") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: true,
          hasAccounts,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCustomFeesToggleSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCoinControlSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableAuthSetting, { backendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableTorProxySetting, { proxyConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectFullNodeSetting, {})
          ]
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSettingsGuide, {})
  ] });
};
const AdvancedSettingsGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor")
  ] });
};
const getLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://www.bitsurance.eu/de/bitbox/";
    default:
      return "https://www.bitsurance.eu/en/bitbox/";
  }
};
const getPrivacyPolicyLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://www.bitsurance.eu/datenschutz/";
    default:
      return "https://www.bitsurance.eu/en/dataprotection/";
  }
};
const BitsuranceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.why"), shown: true }, "guide.bitsurance.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.who") }, "guide.bitsurance.who"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.what") }, "guide.bitsurance.what"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.status") }, "guide.bitsurance.status"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.renew") }, "guide.bitsurance.renew"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.bitsurance.privacy.link.text"),
        url: getPrivacyPolicyLink()
      },
      text: t2("guide.bitsurance.privacy.text"),
      title: t2("guide.bitsurance.privacy.title")
    } }, "guide.bitsurance.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.bitsurance.faq.link.text"),
        url: getLink()
      },
      text: t2("guide.bitsurance.faq.text"),
      title: t2("guide.bitsurance.faq.title")
    } }, "guide.bitsurance.faq")
  ] });
};
const cardBody = "_cardBody_16ttw_1";
const cardBody2 = "_cardBody2_16ttw_6";
const clean = "_clean_16ttw_11";
const ctaButton = "_ctaButton_16ttw_21";
const errorMessage = "_errorMessage_16ttw_37";
const gridContainer = "_gridContainer_16ttw_41";
const noVspace = "_noVspace_16ttw_45";
const title$1 = "_title_16ttw_51";
const style$8 = {
  cardBody,
  cardBody2,
  clean,
  ctaButton,
  errorMessage,
  gridContainer,
  noVspace,
  title: title$1
};
const Bitsurance = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const [insuredAccounts, setInsuredAccounts] = reactExports.useState([]);
  const [redirecting, setRedirecting] = reactExports.useState(true);
  const [scanDone, setScanDone] = reactExports.useState(false);
  const [scanLoading, setScanLoading] = reactExports.useState(false);
  const amount2 = "100.000";
  reactExports.useEffect(() => {
    if (accounts.some(({ bitsuranceStatus }) => bitsuranceStatus)) {
      route("bitsurance/dashboard");
    } else {
      setRedirecting(false);
    }
    return () => setInsuredAccounts([]);
  }, [accounts]);
  const detect2 = async (redirectToDashboard) => {
    setScanLoading(true);
    setScanDone(false);
    setInsuredAccounts([]);
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    const insuredAccountsCodes = response.bitsuranceAccounts.map((account2) => account2.status ? account2.code : null);
    const insured2 = accounts.filter(({ code }) => insuredAccountsCodes.includes(code));
    setInsuredAccounts(insured2);
    setScanDone(true);
    setScanLoading(false);
    if (insured2.length && redirectToDashboard) {
      route("bitsurance/dashboard");
    }
  };
  const getBitsurancePageLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://www.bitsurance.eu/de/bitbox/";
      default:
        return "https://www.bitsurance.eu/en/bitbox/";
    }
  };
  const maybeProceed = async () => {
    await detect2(false);
    route("bitsurance/account");
  };
  if (redirecting) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("sidebar.insurance") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.noVspace, children: t2("bitsurance.intro.text1", { amount: amount2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.gridContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { col: "2", textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$8.title, children: t2("bitsurance.insure.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody, children: t2("bitsurance.insure.text") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$8.clean, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem1") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem2") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem3") })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$8.cardBody2, children: [
              t2("bitsurance.insure.text2"),
              " ",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: getBitsurancePageLink(), children: t2("bitsurance.intro.link") }),
              "."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody2, children: t2("bitsurance.insure.text3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnButtons, { className: style$8.ctaButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: maybeProceed, primary: true, children: t2("bitsurance.insure.button") }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$8.title, children: t2("bitsurance.detect.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody, children: t2("bitsurance.detect.text") }),
            !insuredAccounts.length && scanDone && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$8.cardBody2} ${style$8.errorMessage}`, children: t2("bitsurance.detect.notInsured") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnButtons, { className: style$8.ctaButton, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                onClick: () => detect2(true),
                disabled: scanLoading,
                secondary: true,
                children: [
                  isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SyncLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Sync, {}),
                  t2("bitsurance.detect.button")
                ]
              }
            ) })
          ] })
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] }) });
};
const BitsuranceAccount = ({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [btcAccounts, setBtcAccounts] = reactExports.useState();
  const { t: t2 } = useTranslation();
  const handleChangeAccount = (selected22) => {
    setSelected(selected22);
  };
  const detect2 = reactExports.useCallback(async () => {
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    const insurableAccounts = accounts.filter((account2) => account2.coinCode === "btc" && (!account2.bitsuranceStatus || account2.bitsuranceStatus === "canceled" || account2.bitsuranceStatus === "refused"));
    setBtcAccounts(insurableAccounts);
  }, [accounts]);
  reactExports.useEffect(() => {
    detect2();
  }, [detect2]);
  reactExports.useEffect(() => {
    if (btcAccounts !== void 0 && btcAccounts.length === 1) {
      connectKeystore(btcAccounts[0].code).then((connectResult) => {
        if (!connectResult.success) {
          return;
        }
        route(`/bitsurance/widget/${btcAccounts[0].code}`);
      });
    }
  }, [btcAccounts]);
  const handleProceed = async () => {
    setDisabled(true);
    try {
      const connectResult = await connectKeystore(selected2);
      if (!connectResult.success) {
        return;
      }
    } finally {
      setDisabled(false);
    }
    route(`/bitsurance/widget/${selected2}`);
  };
  if (btcAccounts === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("bitsuranceAccount.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: btcAccounts.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("bitsuranceAccount.noAccount") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        GroupedAccountSelector,
        {
          title: t2("bitsuranceAccount.select"),
          disabled: disabled2,
          accounts: btcAccounts,
          selected: selected2,
          onChange: handleChangeAccount,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] }) });
};
const BitsuranceTerms = ({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipBitsuranceDisclaimer: e3.target.checked } });
  };
  const getPrivacyLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://www.bitsurance.eu/datenschutz";
      default:
        return "https://www.bitsurance.eu/en/dataprotection/";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        t2("bitsurance.terms.text5"),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsxs(A$3, { href: getPrivacyLink(), children: [
          t2("bitsurance.terms.link"),
          "."
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const container$3 = "_container_yg57j_1";
const iframe = "_iframe_yg57j_12";
const header = "_header_yg57j_18";
const style$7 = {
  container: container$3,
  iframe,
  header
};
const BitsuranceWidget = ({ code }) => {
  const { t: t2 } = useTranslation();
  const [height, setHeight] = reactExports.useState(0);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const iframeURL = useLoad(getBitsuranceURL);
  const config = useLoad(getConfig);
  const accountInfo2 = useLoad(getInfo(code));
  const ref = reactExports.createRef();
  const iframeRef = reactExports.createRef();
  let signing = false;
  let resizeTimerID = void 0;
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipBitsuranceDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    window.addEventListener("message", onMessage);
    return () => {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("message", onMessage);
    };
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  const sendAddressWithXPub = (address2, sig, xpub) => {
    var _a;
    const { current } = iframeRef;
    if (!current) {
      return;
    }
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      extendedPublicKey: xpub,
      signature: sig
    });
    (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
  };
  const getXPub = (wantedScriptType) => {
    var _a;
    let xpubConfig = accountInfo2 == null ? void 0 : accountInfo2.signingConfigurations.find(
      (config2) => {
        var _a2;
        return ((_a2 = config2.bitcoinSimple) == null ? void 0 : _a2.scriptType) === wantedScriptType;
      }
    );
    return (_a = xpubConfig == null ? void 0 : xpubConfig.bitcoinSimple) == null ? void 0 : _a.keyInfo.xpub;
  };
  const handleRequestAddress = (message2) => {
    signing = true;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "p2wpkh";
    const withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    const withExtendedPublicKey = !!message2.withExtendedPublicKey;
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = false;
      if (response.success) {
        if (withExtendedPublicKey) {
          const xpub = getXPub(addressType);
          if (xpub) {
            sendAddressWithXPub(response.address, response.signature, xpub);
          } else {
            alertUser(t2("bitsuranceAccount.errorNoXpub"));
          }
        } else {
          sendAddressWithXPub(response.address, response.signature, "");
        }
      } else {
        if (!["userAbort", "wrongKeystore"].includes(response.errorCode || "")) {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const onMessage = (m2) => {
    if (!iframeURL || !code) {
      return;
    }
    if (m2.origin !== new URL(iframeURL).origin) {
      return;
    }
    try {
      let message2 = JSON.parse(m2.data);
      if ((message2 == null ? void 0 : message2.type) === "showInsuranceDashboard") {
        route("bitsurance/dashboard");
        return;
      }
      message2 = dist.parseMessage(m2.data);
      switch (message2.type) {
        case dist.V0MessageType.RequestAddress:
          if (!signing) {
            handleRequestAddress(message2);
          }
          break;
      }
    } catch (e3) {
      console.log(e3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$7.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("bitsuranceAccount.title") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$7.container, children: !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitsuranceTerms,
        {
          onAgreedTerms: () => setAgreedTerms(true)
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(true);
            },
            ref: iframeRef,
            title: "Bitsurance",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$7.iframe,
            allow: "camera; payment",
            src: iframeURL
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] });
};
const text$1 = "_text_1dsup_1";
const accountName$3 = "_accountName_1dsup_6";
const accountsContainer = "_accountsContainer_1dsup_11";
const button = "_button_1dsup_17";
const coverageContainer = "_coverageContainer_1dsup_29";
const headerContainer$2 = "_headerContainer_1dsup_33";
const link$2 = "_link_1dsup_39";
const row = "_row_1dsup_43";
const statusContainer = "_statusContainer_1dsup_49";
const subtle = "_subtle_1dsup_53";
const title = "_title_1dsup_57";
const keystore = "_keystore_1dsup_63";
const style$6 = {
  text: text$1,
  accountName: accountName$3,
  accountsContainer,
  button,
  coverageContainer,
  headerContainer: headerContainer$2,
  link: link$2,
  row,
  statusContainer,
  subtle,
  title,
  keystore
};
const AccountStatusIcon = ({ status: status2 }) => {
  switch (status2) {
    case "active":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GreenDot, { width: 14, height: 20 });
    case "processing":
    case "waitpayment":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(YellowDot, { width: 14, height: 20 });
    case "refused":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 14, height: 20 });
    case "inactive":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(OrangeDot, { width: 14, height: 20 });
    case "canceled":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 14, height: 20 });
  }
};
const BitsuranceDashboard = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const mounted = useMountedRef();
  const [balances, setBalances] = reactExports.useState();
  const [insurances, setInsurances] = reactExports.useState();
  const [accountsByKeystore, setAccountsByKeystore] = reactExports.useState();
  const anyAccountInsured = (keystore2) => {
    var _a;
    return (_a = keystore2.accounts) == null ? void 0 : _a.some((account2) => !!account2.bitsuranceStatus);
  };
  const fetchInsurances = reactExports.useCallback(async () => {
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    let accountsInsurance = {};
    response.bitsuranceAccounts.forEach((insurance) => {
      accountsInsurance[insurance.code] = insurance;
    });
    setInsurances(accountsInsurance);
  }, []);
  reactExports.useEffect(() => {
    setAccountsByKeystore(getAccountsByKeystore(accounts));
    fetchInsurances();
  }, [fetchInsurances, accounts]);
  reactExports.useEffect(() => {
    accountsByKeystore == null ? void 0 : accountsByKeystore.forEach((keystore2) => {
      keystore2.accounts.filter((account2) => !!account2.bitsuranceStatus).forEach((account2) => {
        getBalance(account2.code).then((balance2) => {
          if (!mounted.current) {
            return;
          }
          setBalances((prevBalances) => ({
            ...prevBalances,
            [account2.code]: balance2
          }));
        });
      });
    });
    return () => {
      setBalances(void 0);
    };
  }, [accountsByKeystore, mounted]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("sidebar.insurance") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$6.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$6.title, children: t2("bitsurance.dashboard.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              className: style$6.button,
              primary: true,
              onClick: () => route("bitsurance/account"),
              title: t2("account.exportTransactions"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "+" }),
                t2("bitsurance.dashboard.button")
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$6.accountsContainer, children: (accountsByKeystore == null ? void 0 : accountsByKeystore.length) && insurances ? accountsByKeystore.map(({ accounts: accounts2, keystore: keystore2 }) => anyAccountInsured({ accounts: accounts2, keystore: keystore2 }) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$6.keystore, children: [
            keystore2.name,
            isAmbiguiousName(keystore2.name, accountsByKeystore) ? (
              // Disambiguate accounts group by adding the fingerprint.
              // The most common case where this would happen is when adding accounts from the
              // same seed using different passphrases.
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$6.subtle, children: [
                " (",
                keystore2.rootFingerprint,
                ")"
              ] })
            ) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (accounts2 == null ? void 0 : accounts2.length) ? accounts2.map((account2) => insurances && insurances[account2.code] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$6.row, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} ${style$6.accountName}`, children: accounts2.filter((ac2) => ac2.code === account2.code).map((ac2) => ac2.name) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$6.text} ${style$6.subtle}`, children: balances && balances[account2.code] ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Amount,
                  {
                    amount: balances[account2.code].available.amount,
                    unit: balances[account2.code].available.unit,
                    removeBtcTrailingZeroes: true
                  }
                ),
                ` ${balances[account2.code].available.unit}`
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half m-bottom-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} ${style$6.subtle} m-bottom-quarter`, children: t2("bitsurance.dashboard.coverage") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$6.text, children: [
                insurances[account2.code].details.maxCoverageFormatted,
                " ",
                insurances[account2.code].details.currency
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column-mobile", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(AccountStatusIcon, { status: insurances[account2.code].status }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} m-left-quarter m-right-half`, children: t2("bitsurance.dashboard." + insurances[account2.code].status) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: `${style$6.text} ${style$6.link} m-top-quarter-on-small`,
                  href: insurances[account2.code].details.support,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { width: 16 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "m-left-quarter", children: t2("bitsurance.dashboard.supportLink") })
                  ] })
                }
              )
            ] })
          ] }, account2.code) : null) : /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) })
        ] }, keystore2.rootFingerprint)) : /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] });
};
const WCWeb3WalletContext = reactExports.createContext({});
const WCGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.whatIsWalletConnect")
      },
      "guide.walletConnect.whatIsWalletConnect"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.supportedNetworks")
      },
      "guide.walletConnect.supportedNetworks"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.noPreviousConnections")
      },
      "guide.walletConnect.noPreviousConnections"
    )
  ] });
};
const SUPPORTED_CHAINS = {
  "eip155:1": {
    name: "Etherum mainnet",
    icon: reactExports.createElement(ETHLogo)
  },
  "eip155:5": {
    name: "Ethereum goerli",
    icon: reactExports.createElement(ETHLogo)
  }
};
const EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  /**
     * Many dapps will request an 'eth_signTypedData' but in reality expect 'eth_signTypedData_v4'
     * because that's basically the standard. V4 is assumed, but not necessarily asked for specifically.
     * There aren't many uses of V3 in the wild, but leaving in just in case and returning a v4 signature instead,
     * the dapp can validate this anyway
     */
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction"
};
const getAddressFromEIPString = (address2) => {
  const parts = address2.split(":");
  return parts.length > 2 ? parts[2] : "";
};
const truncateAddress = (address2) => {
  if (!address2) {
    return "";
  }
  return `${address2.substring(0, 6)}...${address2.substring(address2.length - 6)}`;
};
const getTopicFromURI = (wcURI) => {
  try {
    return wcURI.split(":")[1].split("@")[0];
  } catch {
    return "";
  }
};
const pairingHasEverBeenRejected = (topic, web3wallet) => {
  return web3wallet.core.history.values.findIndex((history) => history.topic === topic && history.response && "error" in history.response) >= 0;
};
const rejectMessage = (id2) => {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: {
      code: 5e3,
      message: "User rejected."
    }
  };
};
const decodeEthMessage = (hex) => {
  hex = hex.trim();
  if (hex.startsWith("0x")) {
    hex = hex.substring(2);
  }
  if (hex.length % 2 !== 0 || !/^[0-9a-fA-F]*$/.test(hex)) {
    console.error("Invalid hex string");
    return null;
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const byte = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
    if (isNaN(byte)) {
      console.error("Invalid byte in hex string");
      return null;
    }
    bytes[i] = byte;
  }
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(bytes);
};
const headerContainer$1 = "_headerContainer_j3vgp_1";
const accountName$2 = "_accountName_j3vgp_28";
const receiveAddress$3 = "_receiveAddress_j3vgp_32";
const styles$a = {
  headerContainer: headerContainer$1,
  accountName: accountName$2,
  receiveAddress: receiveAddress$3
};
const WCHeader = ({ receiveAddress: receiveAddress2, accountName: accountName2 }) => {
  const displayedReceiveAddress = truncateAddress(receiveAddress2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.headerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDefaultLogo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "WalletConnect" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.receiveAddress, children: displayedReceiveAddress })
  ] });
};
const formContainer = "_formContainer_redt2_1";
const formButtonsContainer = "_formButtonsContainer_redt2_6";
const inputWithIcon = "_inputWithIcon_redt2_12";
const mobileQRScanner = "_mobileQRScanner_redt2_30";
const styles$9 = {
  formContainer,
  formButtonsContainer,
  inputWithIcon,
  mobileQRScanner
};
const MobileQRScanner = ({ onQRScanned }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$9.mobileQRScanner, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRVideo, { onResult: onQRScanned }) });
};
const WCConnectForm = ({
  code,
  uri,
  onInputChange,
  onSubmit,
  connectLoading
}) => {
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [activeScanQR, setActiveScanQR] = reactExports.useState(isMobile);
  const showMobileQRReader = isMobile;
  const showQRButton = !isMobile;
  const toggleScanQR = () => {
    if (activeScanQR) {
      setActiveScanQR(false);
      return;
    }
    setActiveScanQR(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.formContainer, children: [
    showMobileQRReader && /* @__PURE__ */ jsxRuntimeExports.jsx(MobileQRScanner, { onQRScanned: onSubmit }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        onSubmit: (e3) => {
          e3.preventDefault();
          onSubmit(uri);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              label: t2("walletConnect.connect.dappLabel"),
              className: showQRButton ? styles$9.inputWithIcon : "",
              value: uri,
              readOnly: connectLoading,
              onInput: (e3) => onInputChange(e3.target.value.replace(/\s/g, "")),
              children: showQRButton && !connectLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
            }
          ),
          activeScanQR && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ScanQRDialog,
            {
              toggleScanQR,
              onChangeActiveScanQR: setActiveScanQR,
              parseQRResult: (uri2) => onSubmit(uri2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.formButtonsContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading,
                secondary: true,
                onClick: () => route(`/account/${code}/wallet-connect/dashboard`),
                children: t2("dialog.cancel")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading || !uri,
                type: "submit",
                primary: true,
                children: t2("walletConnect.connect.button")
              }
            )
          ] })
        ]
      }
    )
  ] });
};
var chacha20poly1305 = {};
var chacha = {};
var binary = {};
var int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function imulShim(a2, b2) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535;
    var bh2 = b2 >>> 16 & 65535, bl2 = b2 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  exports.mul = Math.imul || imulShim;
  function add(a2, b2) {
    return a2 + b2 | 0;
  }
  exports.add = add;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  exports.sub = sub;
  function rotl(x2, n2) {
    return x2 << n2 | x2 >>> 32 - n2;
  }
  exports.rotl = rotl;
  function rotr(x2, n2) {
    return x2 << 32 - n2 | x2 >>> n2;
  }
  exports.rotr = rotr;
  function isIntegerShim(n2) {
    return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2;
  }
  exports.isInteger = Number.isInteger || isIntegerShim;
  exports.MAX_SAFE_INTEGER = 9007199254740991;
  exports.isSafeInteger = function(n2) {
    return exports.isInteger(n2) && (n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    result += array[i] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    result += array[i] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i = 0; i < array.length; i++) {
    array[i] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
Object.defineProperty(chacha, "__esModule", { value: true });
var binary_1 = binary;
var wipe_1$3 = wipe$1;
var ROUNDS = 20;
function core(out, input2, key) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
  var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
  var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
  var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
  var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
  var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
  var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
  var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
  var j12 = input2[3] << 24 | input2[2] << 16 | input2[1] << 8 | input2[0];
  var j13 = input2[7] << 24 | input2[6] << 16 | input2[5] << 8 | input2[4];
  var j14 = input2[11] << 24 | input2[10] << 16 | input2[9] << 8 | input2[8];
  var j15 = input2[15] << 24 | input2[14] << 16 | input2[13] << 8 | input2[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i = 0; i < ROUNDS; i += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc2;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc2 = new Uint8Array(16);
    counterLength = nc2.length - nonce.length;
    nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc2 = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block2 = new Uint8Array(64);
  for (var i = 0; i < src2.length; i += 64) {
    core(block2, nc2, key);
    for (var j2 = i; j2 < i + 64 && j2 < src2.length; j2++) {
      dst[j2] = src2[j2] ^ block2[j2 - i];
    }
    incrementCounter(nc2, 0, counterLength);
  }
  wipe_1$3.wipe(block2);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$3.wipe(nc2);
  }
  return dst;
}
chacha.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$3.wipe(dst);
  return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
chacha.stream = stream;
function incrementCounter(counter, pos, len) {
  var carry = 1;
  while (len--) {
    carry = carry + (counter[pos] & 255) | 0;
    counter[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
var poly1305 = {};
var constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
constantTime.select = select;
function lessOrEqual(a2, b2) {
  return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(a2, b2) {
  if (a2.length !== b2.length) {
    return 0;
  }
  var result = 0;
  for (var i = 0; i < a2.length; i++) {
    result |= a2[i] ^ b2[i];
  }
  return 1 & result - 1 >>> 8;
}
constantTime.compare = compare;
function equal$1(a2, b2) {
  if (a2.length === 0 || b2.length === 0) {
    return false;
  }
  return compare(a2, b2) !== 0;
}
constantTime.equal = equal$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constant_time_12 = constantTime;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m2, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g2 = new Uint16Array(10);
        var c2;
        var mask;
        var f2;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c2;
          c2 = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g2[0] = this._h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g2[i] = this._h[i] + c2;
          c2 = g2[i] >>> 13;
          g2[i] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g2[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g2[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f2 = this._h[0] + this._pad[0];
        this._h[0] = f2 & 65535;
        for (i = 1; i < 8; i++) {
          f2 = (this._h[i] + this._pad[i] | 0) + (f2 >>> 16) | 0;
          this._h[i] = f2 & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m2) {
        var mpos = 0;
        var bytes = m2.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes) {
            want = bytes;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m2[mpos + i];
          }
          bytes -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this._blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (var i = 0; i < bytes; i++) {
            this._buffer[this._leftover + i] = m2[mpos + i];
          }
          this._leftover += bytes;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._r);
        wipe_12.wipe(this._h);
        wipe_12.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data) {
    var h2 = new Poly1305(key);
    h2.update(data);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b2) {
    if (a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a2, b2);
  }
  exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chacha_1 = chacha;
  var poly1305_1 = poly1305;
  var wipe_12 = wipe$1;
  var binary_12 = binary;
  var constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32;
  exports.NONCE_LENGTH = 12;
  exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16);
  var ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h2 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h2.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h2.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h2.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h2.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_12.writeUint64LE(associatedData.length, length2);
        }
        h2.update(length2);
        binary_12.writeUint64LE(ciphertext.length, length2);
        h2.update(length2);
        var tag = h2.digest();
        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        }
        h2.clean();
        wipe_12.wipe(tag);
        wipe_12.wipe(length2);
      };
      return ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {};
var hmac$1 = {};
var hash = {};
Object.defineProperty(hash, "__esModule", { value: true });
function isSerializableHash(h2) {
  return typeof h2.saveState !== "undefined" && typeof h2.restoreState !== "undefined" && typeof h2.cleanSavedState !== "undefined";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: true });
var hash_1 = hash;
var constant_time_1 = constantTime;
var wipe_1$2 = wipe$1;
var HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key) {
      this._finished = false;
      this._inner = new hash2();
      this._outer = new hash2();
      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength;
      var pad = new Uint8Array(this.blockSize);
      if (key.length > this.blockSize) {
        this._inner.update(key).finish(pad).clean();
      } else {
        pad.set(key);
      }
      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 54;
      }
      this._inner.update(pad);
      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 54 ^ 92;
      }
      this._outer.update(pad);
      if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      }
      wipe_1$2.wipe(pad);
    }
    HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      }
      this._inner.restoreState(this._innerKeyedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.clean = function() {
      if (hash_1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }
      if (hash_1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }
      this._inner.clean();
      this._outer.clean();
    };
    HMAC2.prototype.update = function(data) {
      this._inner.update(data);
      return this;
    };
    HMAC2.prototype.finish = function(out) {
      if (this._finished) {
        this._outer.finish(out);
        return this;
      }
      this._inner.finish(out);
      this._outer.update(out.subarray(0, this.digestLength)).finish(out);
      this._finished = true;
      return this;
    };
    HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }
      return this._inner.saveState();
    };
    HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }
      this._inner.restoreState(savedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }
      this._inner.cleanSavedState(savedState);
    };
    return HMAC2;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(hash2, key, data) {
  var h2 = new HMAC(hash2, key);
  h2.update(data);
  var digest = h2.digest();
  h2.clean();
  return digest;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = hmac$1;
var wipe_1$1 = wipe$1;
var HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key, salt, info2) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }
      this._counter = new Uint8Array(1);
      this._hash = hash2;
      this._info = info2;
      var okm = hmac_1.hmac(this._hash, salt, key);
      this._hmac = new hmac_1.HMAC(hash2, okm);
      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    }
    HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      this._hmac.reset();
      if (ctr > 1) {
        this._hmac.update(this._buffer);
      }
      if (this._info) {
        this._hmac.update(this._info);
      }
      this._hmac.update(this._counter);
      this._hmac.finish(this._buffer);
      this._bufpos = 0;
    };
    HKDF2.prototype.expand = function(length2) {
      var out = new Uint8Array(length2);
      for (var i = 0; i < out.length; i++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }
        out[i] = this._buffer[this._bufpos++];
      }
      return out;
    };
    HKDF2.prototype.clean = function() {
      this._hmac.clean();
      wipe_1$1.wipe(this._buffer);
      wipe_1$1.wipe(this._counter);
      this._bufpos = 0;
    };
    return HKDF2;
  }()
);
var HKDF_1 = hkdf.HKDF = HKDF;
var random = {};
var system = {};
var browser = {};
Object.defineProperty(browser, "__esModule", { value: true });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
    }
    return out;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", { value: true });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto = require$$0$1;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer = this._crypto.randomBytes(length2);
    if (buffer.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i++) {
      out[i] = buffer[i];
    }
    (0, wipe_1.wipe)(buffer);
    return out;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
system.SystemRandomSource = void 0;
const browser_1 = browser;
const node_1 = node;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  }
}
system.SystemRandomSource = SystemRandomSource;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system;
  const binary_12 = binary;
  const wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  exports.randomBytes = randomBytes;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf = randomBytes(4, prng);
    const result = (0, binary_12.readUint32LE)(buf);
    (0, wipe_12.wipe)(buf);
    return result;
  }
  exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i = 0; i < buf.length && length2 > 0; i++) {
        const randomByte = buf[i];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32;
  exports.BLOCK_SIZE = 64;
  var SHA256 = (
    /** @class */
    function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left2 = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left2] = 128;
          for (var i = left2 + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_12.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }()
  );
  exports.SHA256 = SHA256;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len) {
    while (len >= 64) {
      var a2 = v2[0];
      var b2 = v2[1];
      var c2 = v2[2];
      var d2 = v2[3];
      var e3 = v2[4];
      var f2 = v2[5];
      var g2 = v2[6];
      var h2 = v2[7];
      for (var i = 0; i < 16; i++) {
        var j2 = pos + i * 4;
        w2[i] = binary_12.readUint32BE(p2, j2);
      }
      for (var i = 16; i < 64; i++) {
        var u2 = w2[i - 2];
        var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i] = (t1 + w2[i - 7] | 0) + (t2 + w2[i - 16] | 0);
      }
      for (var i = 0; i < 64; i++) {
        var t1 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f2 ^ ~e3 & g2) | 0) + (h2 + (K2[i] + w2[i] | 0) | 0) | 0;
        var t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
        h2 = g2;
        g2 = f2;
        f2 = e3;
        e3 = d2 + t1 | 0;
        d2 = c2;
        c2 = b2;
        b2 = a2;
        a2 = t1 + t2 | 0;
      }
      v2[0] += a2;
      v2[1] += b2;
      v2[2] += c2;
      v2[3] += d2;
      v2[4] += e3;
      v2[5] += f2;
      v2[6] += g2;
      v2[7] += h2;
      pos += 64;
      len -= 64;
    }
    return pos;
  }
  function hash2(data) {
    var h2 = new SHA256();
    h2.update(data);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.hash = hash2;
})(sha256);
var x25519 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random;
  const wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32;
  exports.SECRET_KEY_LENGTH = 32;
  exports.SHARED_KEY_LENGTH = 32;
  function gf(init2) {
    const r2 = new Float64Array(16);
    if (init2) {
      for (let i = 0; i < init2.length; i++) {
        r2[i] = init2[i];
      }
    }
    return r2;
  }
  const _92 = new Uint8Array(32);
  _92[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i = 0; i < 16; i++) {
      let v2 = o2[i] + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      o2[i] = v2 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p2, q2, b2) {
    const c2 = ~(b2 - 1);
    for (let i = 0; i < 16; i++) {
      const t2 = c2 & (p2[i] ^ q2[i]);
      p2[i] ^= t2;
      q2[i] ^= t2;
    }
  }
  function pack25519(o2, n2) {
    const m2 = gf();
    const t2 = gf();
    for (let i = 0; i < 16; i++) {
      t2[i] = n2[i];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i = 1; i < 15; i++) {
        m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
        m2[i - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b2);
    }
    for (let i = 0; i < 16; i++) {
      o2[2 * i] = t2[i] & 255;
      o2[2 * i + 1] = t2[i] >> 8;
    }
  }
  function unpack25519(o2, n2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
    }
    o2[15] &= 32767;
  }
  function add(o2, a2, b2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = a2[i] + b2[i];
    }
  }
  function sub(o2, a2, b2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = a2[i] - b2[i];
    }
  }
  function mul(o2, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0];
    t0 += v2 * b0;
    t1 += v2 * b1;
    t2 += v2 * b22;
    t3 += v2 * b3;
    t4 += v2 * b4;
    t5 += v2 * b5;
    t6 += v2 * b6;
    t7 += v2 * b7;
    t8 += v2 * b8;
    t9 += v2 * b9;
    t10 += v2 * b10;
    t11 += v2 * b11;
    t12 += v2 * b12;
    t13 += v2 * b13;
    t14 += v2 * b14;
    t15 += v2 * b15;
    v2 = a2[1];
    t1 += v2 * b0;
    t2 += v2 * b1;
    t3 += v2 * b22;
    t4 += v2 * b3;
    t5 += v2 * b4;
    t6 += v2 * b5;
    t7 += v2 * b6;
    t8 += v2 * b7;
    t9 += v2 * b8;
    t10 += v2 * b9;
    t11 += v2 * b10;
    t12 += v2 * b11;
    t13 += v2 * b12;
    t14 += v2 * b13;
    t15 += v2 * b14;
    t16 += v2 * b15;
    v2 = a2[2];
    t2 += v2 * b0;
    t3 += v2 * b1;
    t4 += v2 * b22;
    t5 += v2 * b3;
    t6 += v2 * b4;
    t7 += v2 * b5;
    t8 += v2 * b6;
    t9 += v2 * b7;
    t10 += v2 * b8;
    t11 += v2 * b9;
    t12 += v2 * b10;
    t13 += v2 * b11;
    t14 += v2 * b12;
    t15 += v2 * b13;
    t16 += v2 * b14;
    t17 += v2 * b15;
    v2 = a2[3];
    t3 += v2 * b0;
    t4 += v2 * b1;
    t5 += v2 * b22;
    t6 += v2 * b3;
    t7 += v2 * b4;
    t8 += v2 * b5;
    t9 += v2 * b6;
    t10 += v2 * b7;
    t11 += v2 * b8;
    t12 += v2 * b9;
    t13 += v2 * b10;
    t14 += v2 * b11;
    t15 += v2 * b12;
    t16 += v2 * b13;
    t17 += v2 * b14;
    t18 += v2 * b15;
    v2 = a2[4];
    t4 += v2 * b0;
    t5 += v2 * b1;
    t6 += v2 * b22;
    t7 += v2 * b3;
    t8 += v2 * b4;
    t9 += v2 * b5;
    t10 += v2 * b6;
    t11 += v2 * b7;
    t12 += v2 * b8;
    t13 += v2 * b9;
    t14 += v2 * b10;
    t15 += v2 * b11;
    t16 += v2 * b12;
    t17 += v2 * b13;
    t18 += v2 * b14;
    t19 += v2 * b15;
    v2 = a2[5];
    t5 += v2 * b0;
    t6 += v2 * b1;
    t7 += v2 * b22;
    t8 += v2 * b3;
    t9 += v2 * b4;
    t10 += v2 * b5;
    t11 += v2 * b6;
    t12 += v2 * b7;
    t13 += v2 * b8;
    t14 += v2 * b9;
    t15 += v2 * b10;
    t16 += v2 * b11;
    t17 += v2 * b12;
    t18 += v2 * b13;
    t19 += v2 * b14;
    t20 += v2 * b15;
    v2 = a2[6];
    t6 += v2 * b0;
    t7 += v2 * b1;
    t8 += v2 * b22;
    t9 += v2 * b3;
    t10 += v2 * b4;
    t11 += v2 * b5;
    t12 += v2 * b6;
    t13 += v2 * b7;
    t14 += v2 * b8;
    t15 += v2 * b9;
    t16 += v2 * b10;
    t17 += v2 * b11;
    t18 += v2 * b12;
    t19 += v2 * b13;
    t20 += v2 * b14;
    t21 += v2 * b15;
    v2 = a2[7];
    t7 += v2 * b0;
    t8 += v2 * b1;
    t9 += v2 * b22;
    t10 += v2 * b3;
    t11 += v2 * b4;
    t12 += v2 * b5;
    t13 += v2 * b6;
    t14 += v2 * b7;
    t15 += v2 * b8;
    t16 += v2 * b9;
    t17 += v2 * b10;
    t18 += v2 * b11;
    t19 += v2 * b12;
    t20 += v2 * b13;
    t21 += v2 * b14;
    t22 += v2 * b15;
    v2 = a2[8];
    t8 += v2 * b0;
    t9 += v2 * b1;
    t10 += v2 * b22;
    t11 += v2 * b3;
    t12 += v2 * b4;
    t13 += v2 * b5;
    t14 += v2 * b6;
    t15 += v2 * b7;
    t16 += v2 * b8;
    t17 += v2 * b9;
    t18 += v2 * b10;
    t19 += v2 * b11;
    t20 += v2 * b12;
    t21 += v2 * b13;
    t22 += v2 * b14;
    t23 += v2 * b15;
    v2 = a2[9];
    t9 += v2 * b0;
    t10 += v2 * b1;
    t11 += v2 * b22;
    t12 += v2 * b3;
    t13 += v2 * b4;
    t14 += v2 * b5;
    t15 += v2 * b6;
    t16 += v2 * b7;
    t17 += v2 * b8;
    t18 += v2 * b9;
    t19 += v2 * b10;
    t20 += v2 * b11;
    t21 += v2 * b12;
    t22 += v2 * b13;
    t23 += v2 * b14;
    t24 += v2 * b15;
    v2 = a2[10];
    t10 += v2 * b0;
    t11 += v2 * b1;
    t12 += v2 * b22;
    t13 += v2 * b3;
    t14 += v2 * b4;
    t15 += v2 * b5;
    t16 += v2 * b6;
    t17 += v2 * b7;
    t18 += v2 * b8;
    t19 += v2 * b9;
    t20 += v2 * b10;
    t21 += v2 * b11;
    t22 += v2 * b12;
    t23 += v2 * b13;
    t24 += v2 * b14;
    t25 += v2 * b15;
    v2 = a2[11];
    t11 += v2 * b0;
    t12 += v2 * b1;
    t13 += v2 * b22;
    t14 += v2 * b3;
    t15 += v2 * b4;
    t16 += v2 * b5;
    t17 += v2 * b6;
    t18 += v2 * b7;
    t19 += v2 * b8;
    t20 += v2 * b9;
    t21 += v2 * b10;
    t22 += v2 * b11;
    t23 += v2 * b12;
    t24 += v2 * b13;
    t25 += v2 * b14;
    t26 += v2 * b15;
    v2 = a2[12];
    t12 += v2 * b0;
    t13 += v2 * b1;
    t14 += v2 * b22;
    t15 += v2 * b3;
    t16 += v2 * b4;
    t17 += v2 * b5;
    t18 += v2 * b6;
    t19 += v2 * b7;
    t20 += v2 * b8;
    t21 += v2 * b9;
    t22 += v2 * b10;
    t23 += v2 * b11;
    t24 += v2 * b12;
    t25 += v2 * b13;
    t26 += v2 * b14;
    t27 += v2 * b15;
    v2 = a2[13];
    t13 += v2 * b0;
    t14 += v2 * b1;
    t15 += v2 * b22;
    t16 += v2 * b3;
    t17 += v2 * b4;
    t18 += v2 * b5;
    t19 += v2 * b6;
    t20 += v2 * b7;
    t21 += v2 * b8;
    t22 += v2 * b9;
    t23 += v2 * b10;
    t24 += v2 * b11;
    t25 += v2 * b12;
    t26 += v2 * b13;
    t27 += v2 * b14;
    t28 += v2 * b15;
    v2 = a2[14];
    t14 += v2 * b0;
    t15 += v2 * b1;
    t16 += v2 * b22;
    t17 += v2 * b3;
    t18 += v2 * b4;
    t19 += v2 * b5;
    t20 += v2 * b6;
    t21 += v2 * b7;
    t22 += v2 * b8;
    t23 += v2 * b9;
    t24 += v2 * b10;
    t25 += v2 * b11;
    t26 += v2 * b12;
    t27 += v2 * b13;
    t28 += v2 * b14;
    t29 += v2 * b15;
    v2 = a2[15];
    t15 += v2 * b0;
    t16 += v2 * b1;
    t17 += v2 * b22;
    t18 += v2 * b3;
    t19 += v2 * b4;
    t20 += v2 * b5;
    t21 += v2 * b6;
    t22 += v2 * b7;
    t23 += v2 * b8;
    t24 += v2 * b9;
    t25 += v2 * b10;
    t26 += v2 * b11;
    t27 += v2 * b12;
    t28 += v2 * b13;
    t29 += v2 * b14;
    t30 += v2 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o2[0] = t0;
    o2[1] = t1;
    o2[2] = t2;
    o2[3] = t3;
    o2[4] = t4;
    o2[5] = t5;
    o2[6] = t6;
    o2[7] = t7;
    o2[8] = t8;
    o2[9] = t9;
    o2[10] = t10;
    o2[11] = t11;
    o2[12] = t12;
    o2[13] = t13;
    o2[14] = t14;
    o2[15] = t15;
  }
  function square(o2, a2) {
    mul(o2, a2, a2);
  }
  function inv25519(o2, inp) {
    const c2 = gf();
    for (let i = 0; i < 16; i++) {
      c2[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
      square(c2, c2);
      if (i !== 2 && i !== 4) {
        mul(c2, c2, inp);
      }
    }
    for (let i = 0; i < 16; i++) {
      o2[i] = c2[i];
    }
  }
  function scalarMult(n2, p2) {
    const z2 = new Uint8Array(32);
    const x2 = new Float64Array(80);
    const a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf();
    for (let i = 0; i < 31; i++) {
      z2[i] = n2[i];
    }
    z2[31] = n2[31] & 127 | 64;
    z2[0] &= 248;
    unpack25519(x2, p2);
    for (let i = 0; i < 16; i++) {
      b2[i] = x2[i];
    }
    a2[0] = d2[0] = 1;
    for (let i = 254; i >= 0; --i) {
      const r2 = z2[i >>> 3] >>> (i & 7) & 1;
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
      add(e3, a2, c2);
      sub(a2, a2, c2);
      add(c2, b2, d2);
      sub(b2, b2, d2);
      square(d2, e3);
      square(f2, a2);
      mul(a2, c2, a2);
      mul(c2, b2, e3);
      add(e3, a2, c2);
      sub(a2, a2, c2);
      square(b2, a2);
      sub(c2, d2, f2);
      mul(a2, c2, _121665);
      add(a2, a2, d2);
      mul(c2, c2, a2);
      mul(a2, d2, f2);
      mul(d2, b2, x2);
      square(b2, e3);
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
    }
    for (let i = 0; i < 16; i++) {
      x2[i + 16] = a2[i];
      x2[i + 32] = c2[i];
      x2[i + 48] = b2[i];
      x2[i + 64] = d2[i];
    }
    const x32 = x2.subarray(32);
    const x16 = x2.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q2 = new Uint8Array(32);
    pack25519(q2, x16);
    return q2;
  }
  exports.scalarMult = scalarMult;
  function scalarMultBase(n2) {
    return scalarMult(n2, _92);
  }
  exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed2) {
    if (seed2.length !== exports.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed2);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed2 = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed2);
    (0, wipe_12.wipe)(seed2);
    return result;
  }
  exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i = 0; i < result.length; i++) {
        zeros |= result[i];
      }
      if (zeros === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x2 = ALPHABET.charAt(i);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$1 = (b2) => new TextDecoder().decode(b2);
class Encoder {
  constructor(name, prefix2, baseEncode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name, prefix2, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    if (prefix2.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix2.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text2) {
    if (typeof text2 === "string") {
      if (text2.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text2.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input2) {
    const prefix2 = input2[0];
    const decoder = this.decoders[prefix2];
    if (decoder) {
      return decoder.decode(input2);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left2, right) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name, prefix2, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix2, baseEncode);
    this.decoder = new Decoder(name, prefix2, baseDecode);
  }
  encode(input2) {
    return this.encoder.encode(input2);
  }
  decode(input2) {
    return this.decoder.decode(input2);
  }
}
const from = ({ name, prefix: prefix2, encode: encode2, decode: decode2 }) => new Codec(name, prefix2, encode2, decode2);
const baseX = ({ prefix: prefix2, name, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix: prefix2,
    name,
    encode: encode2,
    decode: (text2) => coerce(decode2(text2))
  });
};
const decode$2 = (string2, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end2; ++i) {
    const value = codes[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$1 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix: prefix2,
    name,
    encode(input2) {
      return encode$1(input2, alphabet2, bitsPerChar);
    },
    decode(input2) {
      return decode$2(input2, alphabet2, bitsPerChar, name);
    }
  });
};
const identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i) => {
  p2[i] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i) => {
  p2[c2.codePointAt(0)] = i;
  return p2;
}, []);
function encode(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$1(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char2}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from({
  prefix: "",
  name: "base256emoji",
  encode,
  decode: decode$1
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name, prefix2, encode2, decode2) {
  return {
    name,
    prefix: prefix2,
    encoder: {
      name,
      prefix: prefix2,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++) {
    string2 += String.fromCharCode(buf[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version, os2) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version, os2, bot) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os2);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a = operatingSystemRules[ii2], os2 = _a[0], regex = _a[1];
    var match2 = regex.exec(ua2);
    if (match2) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output2.push("0");
  }
  return output2;
}
var cjs$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e3) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject2(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject2(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_24)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t2 = _24.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2];
              _24.ops.push(op);
              break;
            }
            if (t2[2])
              _24.ops.pop();
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values(o2) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step2(g2[n2](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step2(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject2) {
        v2 = o2[n2](v2), settle(resolve, reject2, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject2, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject2);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (Object.hasOwnProperty.call(mod, k2))
        result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return time;
  hasRequiredTime = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireMisc(), exports);
    tslib_1.__exportStar(requireTime(), exports);
  })(constants);
  return constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireDelay(), exports);
    tslib_1.__exportStar(requireConvert(), exports);
  })(utils);
  return utils;
}
var watch$1 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label2) {
      if (this.timestamps.has(label2)) {
        throw new Error(`Watch already started for label: ${label2}`);
      }
      this.timestamps.set(label2, { started: Date.now() });
    }
    stop(label2) {
      const timestamp = this.get(label2);
      if (typeof timestamp.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label2}`);
      }
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label2, { started: timestamp.started, elapsed });
    }
    get(label2) {
      const timestamp = this.timestamps.get(label2);
      if (typeof timestamp === "undefined") {
        throw new Error(`No timestamp found for label: ${label2}`);
      }
      return timestamp;
    }
    elapsed(label2) {
      const timestamp = this.get(label2);
      const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
      return elapsed;
    }
  }
  watch$1.Watch = Watch;
  watch$1.default = Watch;
  return watch$1;
}
var types = {};
var watch = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1;
  Object.defineProperty(watch, "__esModule", { value: true });
  watch.IWatch = void 0;
  class IWatch {
  }
  watch.IWatch = IWatch;
  return watch;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireWatch(), exports);
  })(types);
  return types;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require$$0;
  tslib_1.__exportStar(requireUtils(), exports);
  tslib_1.__exportStar(requireWatch$1(), exports);
  tslib_1.__exportStar(requireTypes(), exports);
  tslib_1.__exportStar(requireConstants(), exports);
})(cjs$2);
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: true });
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0;
function getFromWindow(name) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
    res = window[name];
  }
  return res;
}
cjs$1.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
  const res = getFromWindow(name);
  if (!res) {
    throw new Error(`${name} is not defined in Window`);
  }
  return res;
}
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$1.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$1.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$1.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: true });
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e3) {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i = 0; i < links.length; i++) {
      const link2 = links[i];
      const rel = link2.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link2.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i = 0; i < metaTags.length; i++) {
      const tag = metaTags[i];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content2 = tag.getAttribute("content");
        if (content2) {
          return content2;
        }
      }
    }
    return "";
  }
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name2) {
      name2 = doc.title;
    }
    return name2;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name = getName();
  const description2 = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description: description2,
    url,
    icons,
    name
  };
  return meta;
}
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components2, split) {
  try {
    return [decodeURIComponent(components2.join(""))];
  } catch (err) {
  }
  if (components2.length === 1) {
    return components2;
  }
  split = split || 1;
  var left2 = components2.slice(0, split);
  var right = components2.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right));
}
function decode(input2) {
  try {
    return decodeURIComponent(input2);
  } catch (err) {
    var tokens = input2.match(singleMatcher) || [];
    for (var i = 1; i < tokens.length; i++) {
      input2 = decodeComponents(tokens, i).join("");
      tokens = input2.match(singleMatcher) || [];
    }
    return input2;
  }
}
function customDecodeURIComponent(input2) {
  var replaceMap = {
    "%FE%FF": "",
    "%FF%FE": ""
  };
  var match2 = multiMatcher.exec(input2);
  while (match2) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch (err) {
      var result = decode(match2[0]);
      if (result !== match2[0]) {
        replaceMap[match2[0]] = result;
      }
    }
    match2 = multiMatcher.exec(input2);
  }
  replaceMap["%C2"] = "";
  var entries = Object.keys(replaceMap);
  for (var i = 0; i < entries.length; i++) {
    var key = entries[i];
    input2 = input2.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input2;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator2) => {
  if (!(typeof string2 === "string" && typeof separator2 === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator2 === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator2);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator2.length)
  ];
};
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];
    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }
  return ret;
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options2) {
    switch (options2.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode2(key, options2), "[", encode2(index2, options2), "]=", encode2(value, options2)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[]"].join("")];
          }
          return [...result, [encode2(key, options2), "[]=", encode2(value, options2)].join("")];
        };
      case "colon-list-separator":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), ":list="].join("")];
          }
          return [...result, [encode2(key, options2), ":list=", encode2(value, options2)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode2(key, options2), keyValueSep, encode2(value, options2)].join("")];
          }
          return [[result, encode2(value, options2)].join(options2.arrayFormatSeparator)];
        };
      }
      default:
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode2(key, options2)];
          }
          return [...result, [encode2(key, options2), "=", encode2(value, options2)].join("")];
        };
    }
  }
  function parserForArrayFormat(options2) {
    let result;
    switch (options2.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options2.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options2).includes(options2.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options2) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2)) : value === null ? value : decode2(value, options2);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key] = value ? decode2(value, options2) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode2(value, options2) {
    if (options2.encode) {
      return options2.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options2) {
    if (options2.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input2) {
    if (Array.isArray(input2)) {
      return input2.sort();
    }
    if (typeof input2 === "object") {
      return keysSorter(Object.keys(input2)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input2[key]);
    }
    return input2;
  }
  function removeHash(input2) {
    const hashStart = input2.indexOf("#");
    if (hashStart !== -1) {
      input2 = input2.slice(0, hashStart);
    }
    return input2;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input2) {
    input2 = removeHash(input2);
    const queryStart = input2.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input2.slice(queryStart + 1);
  }
  function parseValue(value, options2) {
    if (options2.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options2) {
    options2 = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options2);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key, value] = splitOnFirst$1(options2.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode2(value, options2);
      formatter(decode2(key, options2), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === "object" && value !== null) {
        for (const k2 of Object.keys(value)) {
          value[k2] = parseValue(value[k2], options2);
        }
      } else {
        ret[key] = parseValue(value, options2);
      }
    }
    if (options2.sort === false) {
      return ret;
    }
    return (options2.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse2;
  exports.stringify = (object, options2) => {
    if (!object) {
      return "";
    }
    options2 = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const shouldFilter = (key) => options2.skipNull && isNullOrUndefined(object[key]) || options2.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options2);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options2.sort !== false) {
      keys.sort(options2.sort);
    }
    return keys.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode2(key, options2);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options2.arrayFormat === "bracket-separator") {
          return encode2(key, options2) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode2(key, options2) + "=" + encode2(value, options2);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (url, options2) => {
    options2 = Object.assign({
      decode: true
    }, options2);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options2)
      },
      options2 && options2.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options2) } : {}
    );
  };
  exports.stringifyUrl = (object, options2) => {
    options2 = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options2);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options2);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash2 = `#${options2[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports.pick = (input2, filter, options2) => {
    options2 = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options2);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input2, options2);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options2);
  };
  exports.exclude = (input2, filter, options2) => {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input2, exclusionFilter, options2);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function L(e3, n2) {
  return e3.includes(":") ? [e3] : n2.chains || [];
}
const J = "base10", p = "base16", F2 = "base64pad", H2 = "utf8", Q = 0, _23 = 1, Dn2 = 0, Ie = 1, Z = 12, X2 = 32;
function kn2() {
  const e3 = x25519.generateKeyPair();
  return { privateKey: toString(e3.secretKey, p), publicKey: toString(e3.publicKey, p) };
}
function Vn() {
  const e3 = random.randomBytes(X2);
  return toString(e3, p);
}
function Mn2(e3, n2) {
  const t2 = x25519.sharedKey(fromString(e3, p), fromString(n2, p), true), r2 = new HKDF_1(sha256.SHA256, t2).expand(X2);
  return toString(r2, p);
}
function Kn(e3) {
  const n2 = sha256.hash(fromString(e3, p));
  return toString(n2, p);
}
function Ln(e3) {
  const n2 = sha256.hash(fromString(e3, H2));
  return toString(n2, p);
}
function Pe(e3) {
  return fromString(`${e3}`, J);
}
function $(e3) {
  return Number(toString(e3, J));
}
function xn2(e3) {
  const n2 = Pe(typeof e3.type < "u" ? e3.type : Q);
  if ($(n2) === _23 && typeof e3.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e3.senderPublicKey < "u" ? fromString(e3.senderPublicKey, p) : void 0, r2 = typeof e3.iv < "u" ? fromString(e3.iv, p) : random.randomBytes(Z), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e3.symKey, p)).seal(r2, fromString(e3.message, H2));
  return Re({ type: n2, sealed: o2, iv: r2, senderPublicKey: t2 });
}
function Fn(e3) {
  const n2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e3.symKey, p)), { sealed: t2, iv: r2 } = ee(e3.encoded), o2 = n2.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, H2);
}
function Re(e3) {
  if ($(e3.type) === _23) {
    if (typeof e3.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e3.type, e3.senderPublicKey, e3.iv, e3.sealed]), F2);
  }
  return toString(concat([e3.type, e3.iv, e3.sealed]), F2);
}
function ee(e3) {
  const n2 = fromString(e3, F2), t2 = n2.slice(Dn2, Ie), r2 = Ie;
  if ($(t2) === _23) {
    const d2 = r2 + X2, l2 = d2 + Z, c2 = n2.slice(r2, d2), u2 = n2.slice(d2, l2), a2 = n2.slice(l2);
    return { type: t2, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o2 = r2 + Z, s = n2.slice(r2, o2), i = n2.slice(o2);
  return { type: t2, sealed: i, iv: s };
}
function Hn(e3, n2) {
  const t2 = ee(e3);
  return Te({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Te(e3) {
  const n2 = (e3 == null ? void 0 : e3.type) || Q;
  if (n2 === _23) {
    if (typeof (e3 == null ? void 0 : e3.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e3 == null ? void 0 : e3.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e3 == null ? void 0 : e3.senderPublicKey, receiverPublicKey: e3 == null ? void 0 : e3.receiverPublicKey };
}
function qn(e3) {
  return e3.type === _23 && typeof e3.senderPublicKey == "string" && typeof e3.receiverPublicKey == "string";
}
var Bn = Object.defineProperty, Ae = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn2 = Object.prototype.propertyIsEnumerable, Ue = (e3, n2, t2) => n2 in e3 ? Bn(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, _e = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Gn.call(n2, t2) && Ue(e3, t2, n2[t2]);
  if (Ae)
    for (var t2 of Ae(n2))
      Wn2.call(n2, t2) && Ue(e3, t2, n2[t2]);
  return e3;
};
const Ce = "ReactNative", m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, $e = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function C() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce;
}
function D() {
  return !te() && !!getNavigator_1();
}
function T() {
  return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
function Jn() {
  var e3;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e3 = global.Application) == null ? void 0 : e3.applicationId : void 0;
  } catch {
    return;
  }
}
function De(e3, n2) {
  let t2 = queryString.parse(e3);
  return t2 = _e(_e({}, t2), n2), e3 = queryString.stringify(t2), e3;
}
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function ke2() {
  if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e3 = detect();
  if (e3 === null)
    return "unknown";
  const n2 = e3.os ? e3.os.replace(" ", "").toLowerCase() : "unknown";
  return e3.type === "browser" ? [n2, e3.name, e3.version].join("-") : [n2, e3.version].join("-");
}
function Ve() {
  var e3;
  const n2 = T();
  return n2 === m.browser ? [n2, ((e3 = getLocation_1()) == null ? void 0 : e3.host) || "unknown"].join(":") : n2;
}
function Me2(e3, n2, t2) {
  const r2 = ke2(), o2 = Ve();
  return [[e3, n2].join("-"), [$e, t2].join("-"), r2, o2].join("/");
}
function Xn({ protocol: e3, version: n2, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i, bundleId: d2 }) {
  const l2 = t2.split("?"), c2 = Me2(e3, n2, r2), u2 = { auth: o2, ua: c2, projectId: s, useOnCloseEvent: i || void 0, origin: d2 || void 0 }, a2 = De(l2[1] || "", u2);
  return l2[0] + "?" + a2;
}
function O(e3, n2) {
  return e3.filter((t2) => n2.includes(t2)).length === e3.length;
}
function rt(e3) {
  return Object.fromEntries(e3.entries());
}
function ot(e3) {
  return new Map(Object.entries(e3));
}
function at2(e3 = cjs$2.FIVE_MINUTES, n2) {
  const t2 = cjs$2.toMiliseconds(e3 || cjs$2.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i) => {
    s && r2 && (clearTimeout(s), r2(i));
  }, reject: (i) => {
    s && o2 && (clearTimeout(s), o2(i));
  }, done: () => new Promise((i, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t2), r2 = i, o2 = d2;
  }) };
}
function ut(e3, n2, t2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(t2)), n2);
    try {
      const i = await e3;
      r2(i);
    } catch (i) {
      o2(i);
    }
    clearTimeout(s);
  });
}
function re(e3, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e3}:`))
    return n2;
  if (e3.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e3.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e3}`);
}
function lt2(e3) {
  return re("topic", e3);
}
function dt(e3) {
  return re("id", e3);
}
function ft(e3) {
  const [n2, t2] = e3.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
function pt2(e3, n2) {
  return cjs$2.fromMiliseconds((n2 || Date.now()) + cjs$2.toMiliseconds(e3));
}
function mt2(e3) {
  return Date.now() >= cjs$2.toMiliseconds(e3);
}
function yt(e3, n2) {
  return `${e3}${n2 ? `:${n2}` : ""}`;
}
function S(e3 = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e3, ...n2])];
}
async function ht2({ id: e3, topic: n2, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2 == null ? void 0 : r2.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e3}&sessionTopic=${n2}`, i = T();
    i === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r2) {
    console.error(r2);
  }
}
async function gt(e3, n2) {
  try {
    return await e3.getItem(n2) || (D() ? localStorage.getItem(n2) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
const Fe = "irn";
function vt2(e3) {
  return (e3 == null ? void 0 : e3.relay) || { protocol: Fe };
}
function Et(e3) {
  const n2 = RELAY_JSONRPC[e3];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e3}`);
  return n2;
}
var bt = Object.defineProperty, He = Object.getOwnPropertySymbols, Nt2 = Object.prototype.hasOwnProperty, Ot2 = Object.prototype.propertyIsEnumerable, qe = (e3, n2, t2) => n2 in e3 ? bt(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, St = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Nt2.call(n2, t2) && qe(e3, t2, n2[t2]);
  if (He)
    for (var t2 of He(n2))
      Ot2.call(n2, t2) && qe(e3, t2, n2[t2]);
  return e3;
};
function Be(e3, n2 = "-") {
  const t2 = {}, r2 = "relay" + n2;
  return Object.keys(e3).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i = e3[o2];
      t2[s] = i;
    }
  }), t2;
}
function wt(e3) {
  e3 = e3.includes("wc://") ? e3.replace("wc://", "") : e3, e3 = e3.includes("wc:") ? e3.replace("wc:", "") : e3;
  const n2 = e3.indexOf(":"), t2 = e3.indexOf("?") !== -1 ? e3.indexOf("?") : void 0, r2 = e3.substring(0, n2), o2 = e3.substring(n2 + 1, t2).split("@"), s = typeof t2 < "u" ? e3.substring(t2) : "", i = queryString.parse(s);
  return { protocol: r2, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i.symKey, relay: Be(i) };
}
function Ge(e3) {
  return e3.startsWith("//") ? e3.substring(2) : e3;
}
function We(e3, n2 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e3).forEach((o2) => {
    const s = t2 + n2 + o2;
    e3[o2] && (r2[s] = e3[o2]);
  }), r2;
}
function It(e3) {
  return `${e3.protocol}:${e3.topic}@${e3.version}?` + queryString.stringify(St({ symKey: e3.symKey }, We(e3.relay)));
}
var Pt2 = Object.defineProperty, Rt2 = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, ze = Object.getOwnPropertySymbols, At2 = Object.prototype.hasOwnProperty, Ut2 = Object.prototype.propertyIsEnumerable, Ye = (e3, n2, t2) => n2 in e3 ? Pt2(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, _t2 = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    At2.call(n2, t2) && Ye(e3, t2, n2[t2]);
  if (ze)
    for (var t2 of ze(n2))
      Ut2.call(n2, t2) && Ye(e3, t2, n2[t2]);
  return e3;
}, Ct = (e3, n2) => Rt2(e3, Tt(n2));
function A(e3) {
  const n2 = [];
  return e3.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n2.push(`${r2}:${o2}`);
  }), n2;
}
function Je(e3) {
  const n2 = [];
  return Object.values(e3).forEach((t2) => {
    n2.push(...A(t2.accounts));
  }), n2;
}
function Qe(e3, n2) {
  const t2 = [];
  return Object.values(e3).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.methods);
  }), t2;
}
function Ze(e3, n2) {
  const t2 = [];
  return Object.values(e3).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.events);
  }), t2;
}
function jt2(e3, n2) {
  const t2 = un(e3, n2);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s] of Object.entries(e3))
    r2[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i) => `${i.split(":")[0]}:${i.split(":")[1]}`) };
  return r2;
}
function $t2(e3) {
  const { proposal: { requiredNamespaces: n2, optionalNamespaces: t2 = {} }, supportedNamespaces: r2 } = e3, o2 = se(n2), s = se(t2), i = {};
  Object.keys(r2).forEach((c2) => {
    const u2 = r2[c2].chains, a2 = r2[c2].methods, b2 = r2[c2].events, I2 = r2[c2].accounts;
    u2.forEach((y2) => {
      if (!I2.some((f2) => f2.includes(y2)))
        throw new Error(`No accounts provided for chain ${y2} in namespace ${c2}`);
    }), i[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  });
  const d2 = dn2(n2, i, "approve()");
  if (d2)
    throw new Error(d2.message);
  const l2 = {};
  return !Object.keys(n2).length && !Object.keys(t2).length ? i : (Object.keys(o2).forEach((c2) => {
    const u2 = r2[c2].chains.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.chains) == null ? void 0 : g2.includes(y2);
    }), a2 = r2[c2].methods.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.methods) == null ? void 0 : g2.includes(y2);
    }), b2 = r2[c2].events.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.events) == null ? void 0 : g2.includes(y2);
    }), I2 = u2.map((y2) => r2[c2].accounts.filter((f2) => f2.includes(`${y2}:`))).flat();
    l2[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  }), Object.keys(s).forEach((c2) => {
    var u2, a2, b2, I2, y2, f2;
    if (!r2[c2])
      return;
    const g2 = (a2 = (u2 = s[c2]) == null ? void 0 : u2.chains) == null ? void 0 : a2.filter((P2) => r2[c2].chains.includes(P2)), vn2 = r2[c2].methods.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.methods) == null ? void 0 : j2.includes(P2);
    }), En2 = r2[c2].events.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.events) == null ? void 0 : j2.includes(P2);
    }), bn2 = g2 == null ? void 0 : g2.map((P2) => r2[c2].accounts.filter((R2) => R2.includes(`${P2}:`))).flat();
    l2[c2] = { chains: S((b2 = l2[c2]) == null ? void 0 : b2.chains, g2), methods: S((I2 = l2[c2]) == null ? void 0 : I2.methods, vn2), events: S((y2 = l2[c2]) == null ? void 0 : y2.events, En2), accounts: S((f2 = l2[c2]) == null ? void 0 : f2.accounts, bn2) };
  }), l2);
}
function oe(e3) {
  return e3.includes(":");
}
function Xe(e3) {
  return oe(e3) ? e3.split(":")[0] : e3;
}
function se(e3) {
  var n2, t2, r2;
  const o2 = {};
  if (!B(e3))
    return o2;
  for (const [s, i] of Object.entries(e3)) {
    const d2 = oe(s) ? [s] : i.chains, l2 = i.methods || [], c2 = i.events || [], u2 = Xe(s);
    o2[u2] = Ct(_t2({}, o2[u2]), { chains: S(d2, (n2 = o2[u2]) == null ? void 0 : n2.chains), methods: S(l2, (t2 = o2[u2]) == null ? void 0 : t2.methods), events: S(c2, (r2 = o2[u2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
const en = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, nn2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e3, n2) {
  const { message: t2, code: r2 } = nn2[e3];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function U(e3, n2) {
  const { message: t2, code: r2 } = en[e3];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function k(e3, n2) {
  return Array.isArray(e3) ? typeof n2 < "u" && e3.length ? e3.every(n2) : true : false;
}
function B(e3) {
  return Object.getPrototypeOf(e3) === Object.prototype && Object.keys(e3).length;
}
function w(e3) {
  return typeof e3 > "u";
}
function h(e3, n2) {
  return n2 && w(e3) ? true : typeof e3 == "string" && !!e3.trim().length;
}
function G(e3, n2) {
  return n2 && w(e3) ? true : typeof e3 == "number" && !isNaN(e3);
}
function Dt(e3, n2) {
  const { requiredNamespaces: t2 } = n2, r2 = Object.keys(e3.namespaces), o2 = Object.keys(t2);
  let s = true;
  return O(o2, r2) ? (r2.forEach((i) => {
    const { accounts: d2, methods: l2, events: c2 } = e3.namespaces[i], u2 = A(d2), a2 = t2[i];
    (!O(L(i, a2), u2) || !O(a2.methods, l2) || !O(a2.events, c2)) && (s = false);
  }), s) : false;
}
function V(e3) {
  return h(e3, false) && e3.includes(":") ? e3.split(":").length === 2 : false;
}
function tn2(e3) {
  if (h(e3, false) && e3.includes(":")) {
    const n2 = e3.split(":");
    if (n2.length === 3) {
      const t2 = n2[0] + ":" + n2[1];
      return !!n2[2] && V(t2);
    }
  }
  return false;
}
function kt$1(e3) {
  if (h(e3, false))
    try {
      return typeof new URL(e3) < "u";
    } catch {
      return false;
    }
  return false;
}
function Vt(e3) {
  var n2;
  return (n2 = e3 == null ? void 0 : e3.proposer) == null ? void 0 : n2.publicKey;
}
function Mt$1(e3) {
  return e3 == null ? void 0 : e3.topic;
}
function Kt2(e3, n2) {
  let t2 = null;
  return h(e3 == null ? void 0 : e3.publicKey, false) || (t2 = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t2;
}
function ie(e3) {
  let n2 = true;
  return k(e3) ? e3.length && (n2 = e3.every((t2) => h(t2, false))) : n2 = false, n2;
}
function rn(e3, n2, t2) {
  let r2 = null;
  return k(n2) && n2.length ? n2.forEach((o2) => {
    r2 || V(o2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V(e3) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function on(e3, n2, t2) {
  let r2 = null;
  return Object.entries(e3).forEach(([o2, s]) => {
    if (r2)
      return;
    const i = rn(o2, L(o2, s), `${n2} ${t2}`);
    i && (r2 = i);
  }), r2;
}
function sn(e3, n2) {
  let t2 = null;
  return k(e3) ? e3.forEach((r2) => {
    t2 || tn2(r2) || (t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
function cn(e3, n2) {
  let t2 = null;
  return Object.values(e3).forEach((r2) => {
    if (t2)
      return;
    const o2 = sn(r2 == null ? void 0 : r2.accounts, `${n2} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function an(e3, n2) {
  let t2 = null;
  return ie(e3 == null ? void 0 : e3.methods) ? ie(e3 == null ? void 0 : e3.events) || (t2 = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t2 = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t2;
}
function ce(e3, n2) {
  let t2 = null;
  return Object.values(e3).forEach((r2) => {
    if (t2)
      return;
    const o2 = an(r2, `${n2}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function Lt(e3, n2, t2) {
  let r2 = null;
  if (e3 && B(e3)) {
    const o2 = ce(e3, n2);
    o2 && (r2 = o2);
    const s = on(e3, n2, t2);
    s && (r2 = s);
  } else
    r2 = N("MISSING_OR_INVALID", `${n2}, ${t2} should be an object with data`);
  return r2;
}
function un(e3, n2) {
  let t2 = null;
  if (e3 && B(e3)) {
    const r2 = ce(e3, n2);
    r2 && (t2 = r2);
    const o2 = cn(e3, n2);
    o2 && (t2 = o2);
  } else
    t2 = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t2;
}
function ln(e3) {
  return h(e3.protocol, true);
}
function xt(e3, n2) {
  let t2 = false;
  return n2 && !e3 ? t2 = true : e3 && k(e3) && e3.length && e3.forEach((r2) => {
    t2 = ln(r2);
  }), t2;
}
function Ft2(e3) {
  return typeof e3 == "number";
}
function Ht2(e3) {
  return typeof e3 < "u" && typeof e3 !== null;
}
function qt2(e3) {
  return !(!e3 || typeof e3 != "object" || !e3.code || !G(e3.code, false) || !e3.message || !h(e3.message, false));
}
function Bt(e3) {
  return !(w(e3) || !h(e3.method, false));
}
function Gt2(e3) {
  return !(w(e3) || w(e3.result) && w(e3.error) || !G(e3.id, false) || !h(e3.jsonrpc, false));
}
function Wt2(e3) {
  return !(w(e3) || !h(e3.name, false));
}
function zt(e3, n2) {
  return !(!V(n2) || !Je(e3).includes(n2));
}
function Yt2(e3, n2, t2) {
  return h(t2, false) ? Qe(e3, n2).includes(t2) : false;
}
function Jt(e3, n2, t2) {
  return h(t2, false) ? Ze(e3, n2).includes(t2) : false;
}
function dn2(e3, n2, t2) {
  let r2 = null;
  const o2 = Qt2(e3), s = Zt2(n2), i = Object.keys(o2), d2 = Object.keys(s), l2 = fn2(Object.keys(e3)), c2 = fn2(Object.keys(n2)), u2 = l2.filter((a2) => !c2.includes(a2));
  return u2.length && (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i, d2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b2 = A(n2[a2].accounts);
    b2.includes(a2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b2.toString()}`));
  }), i.forEach((a2) => {
    r2 || (O(o2[a2].methods, s[a2].methods) ? O(o2[a2].events, s[a2].events) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
function Qt2(e3) {
  const n2 = {};
  return Object.keys(e3).forEach((t2) => {
    var r2;
    t2.includes(":") ? n2[t2] = e3[t2] : (r2 = e3[t2].chains) == null || r2.forEach((o2) => {
      n2[o2] = { methods: e3[t2].methods, events: e3[t2].events };
    });
  }), n2;
}
function fn2(e3) {
  return [...new Set(e3.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Zt2(e3) {
  const n2 = {};
  return Object.keys(e3).forEach((t2) => {
    if (t2.includes(":"))
      n2[t2] = e3[t2];
    else {
      const r2 = A(e3[t2].accounts);
      r2 == null ? void 0 : r2.forEach((o2) => {
        n2[o2] = { accounts: e3[t2].accounts.filter((s) => s.includes(`${o2}:`)), methods: e3[t2].methods, events: e3[t2].events };
      });
    }
  }), n2;
}
function Xt2(e3, n2) {
  return G(e3, false) && e3 <= n2.max && e3 >= n2.min;
}
function er() {
  const e3 = T();
  return new Promise((n2) => {
    switch (e3) {
      case m.browser:
        n2(pn());
        break;
      case m.reactNative:
        n2(mn());
        break;
      case m.node:
        n2(yn2());
        break;
      default:
        n2(true);
    }
  });
}
function pn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
async function mn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e3 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e3 == null ? void 0 : e3.isConnected;
  }
  return true;
}
function yn2() {
  return true;
}
function nr(e3) {
  switch (T()) {
    case m.browser:
      hn(e3);
      break;
    case m.reactNative:
      gn2(e3);
      break;
  }
}
function hn(e3) {
  !C() && D() && (window.addEventListener("online", () => e3(true)), window.addEventListener("offline", () => e3(false)));
}
function gn2(e3) {
  C() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n2) => e3(n2 == null ? void 0 : n2.isConnected)));
}
const ae = {};
class tr {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t2) {
    ae[n2] = t2;
  }
  static delete(n2) {
    delete ae[n2];
  }
}
const buttonsContainer = "_buttonsContainer_yg3s8_1";
const container$2 = "_container_yg3s8_7";
const connectionRequest = "_connectionRequest_yg3s8_12";
const receiveAddress$2 = "_receiveAddress_yg3s8_16";
const pairingDetailContainer = "_pairingDetailContainer_yg3s8_21";
const metadata = "_metadata_yg3s8_32";
const styles$8 = {
  buttonsContainer,
  container: container$2,
  connectionRequest,
  receiveAddress: receiveAddress$2,
  pairingDetailContainer,
  metadata
};
const PairingContainer = ({ pairingMetadata }) => {
  const { name, description: description2, url, icons } = pairingMetadata;
  const hasIcon = icons && icons.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.pairingDetailContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: description2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: url })
    ] }),
    hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icons[0], alt: "logo" })
  ] });
};
const WCIncomingPairing = ({
  currentProposal,
  pairingMetadata,
  receiveAddress: receiveAddress2,
  onReject,
  onApprove
}) => {
  const [pairingLoading, setPairingLoading] = reactExports.useState(false);
  const { web3wallet } = reactExports.useContext(WCWeb3WalletContext);
  const { t: t2 } = useTranslation();
  const handleApprovePairing = async () => {
    setPairingLoading(true);
    try {
      const { id: id2, params } = currentProposal;
      const { requiredNamespaces } = params;
      const eipList = Object.values(requiredNamespaces);
      const accounts = eipList.flatMap((eip) => {
        var _a;
        return ((_a = eip.chains) == null ? void 0 : _a.map((chain) => `${chain}:${receiveAddress2}`)) || [];
      });
      const chains = eipList.flatMap(
        (proposal) => proposal.chains ? proposal.chains.filter((chain) => Object.keys(SUPPORTED_CHAINS).includes(chain)) : []
      );
      const namespaces = $t2({
        proposal: params,
        supportedNamespaces: {
          eip155: {
            chains,
            methods: ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "personal_sign", "eth_signTypedData", "eth_signTypedData_v4"],
            events: ["accountsChanged", "chainChanged"],
            accounts
          }
        }
      });
      await (web3wallet == null ? void 0 : web3wallet.approveSession({
        id: id2,
        namespaces
      }));
      onApprove();
    } catch (e3) {
      console.error(`Wallet connect approve pairing error ${e3}`);
      console.error(e3);
      if (e3.message.includes("Non conforming namespaces")) {
        alertUser(t2(
          "walletConnect.invalidPairingChain",
          {
            chains: "\nEthereum \nEthereum (Goerli)"
          }
        ));
      } else {
        alertUser(e3.messsage);
      }
      await handleRejectPairing();
    } finally {
      setPairingLoading(false);
    }
  };
  const handleRejectPairing = async () => {
    setPairingLoading(true);
    await (web3wallet == null ? void 0 : web3wallet.rejectSession({
      id: currentProposal.id,
      reason: U("USER_REJECTED_METHODS")
    }));
    onReject();
    setPairingLoading(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$8.connectionRequest, children: [
      t2("walletConnect.pairingRequest.title"),
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PairingContainer, { pairingMetadata }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$8.receiveAddress, children: [
      t2("accountInfo.address"),
      ": ",
      receiveAddress2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.buttonsContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, secondary: true, onClick: handleRejectPairing, children: t2("walletConnect.pairingRequest.reject") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, primary: true, onClick: handleApprovePairing, children: t2("walletConnect.pairingRequest.approve") })
    ] })
  ] });
};
const container$1 = "_container_1h5wj_1";
const successIcon$1 = "_successIcon_1h5wj_7";
const successText$1 = "_successText_1h5wj_12";
const styles$7 = {
  container: container$1,
  successIcon: successIcon$1,
  successText: successText$1
};
const WCSuccessPairing = ({ accountCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles$7.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$7.successText, children: t2("walletConnect.pairingSuccess") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: () => route(`/account/${accountCode}/wallet-connect/dashboard`), children: t2("button.done") })
  ] });
};
const ConnectScreenWalletConnect = ({
  code,
  accounts
}) => {
  var _a;
  const [uri, setUri] = reactExports.useState("");
  const [status2, setStatus] = reactExports.useState("connect");
  const [loading2, setLoading] = reactExports.useState(false);
  const { web3wallet, isWalletInitialized, pair } = reactExports.useContext(WCWeb3WalletContext);
  const [currentProposal, setCurrentProposal] = reactExports.useState();
  const { t: t2 } = useTranslation();
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const onSessionProposal = reactExports.useCallback(
    (proposal) => {
      setUri("");
      setLoading(false);
      setStatus("incoming_pairing");
      setCurrentProposal(proposal);
    },
    []
  );
  reactExports.useEffect(() => {
    if (isWalletInitialized) {
      web3wallet == null ? void 0 : web3wallet.on("session_proposal", onSessionProposal);
      return () => {
        web3wallet == null ? void 0 : web3wallet.off("session_proposal", onSessionProposal);
      };
    }
  }, [onSessionProposal, isWalletInitialized, web3wallet]);
  const handleApprovePairingStates = () => {
    setStatus("success");
    setUri("");
    setCurrentProposal(void 0);
  };
  const handleRejectPairingStates = () => {
    setStatus("connect");
    setUri("");
    setCurrentProposal(void 0);
  };
  const handleConnect = async (uri2) => {
    if (!uri2) {
      return;
    }
    setLoading(true);
    try {
      await pair({ uri: uri2 });
    } catch (err) {
      if (err.message.includes("Missing or invalid. pair()")) {
        alertUser(`${t2("walletConnect.connect.invalidPairingUri")}: ${uri2}`);
      } else {
        alertUser(err.message);
      }
      setUri("");
      setLoading(false);
    }
  };
  if (!receiveAddresses || !isWalletInitialized) {
    return null;
  }
  const accountName2 = ((_a = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a.name) || "";
  const receiveAddress2 = receiveAddresses[0].addresses[0].address;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fitContent: true,
          verticallyCentered: true,
          width: "620px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCHeader,
              {
                accountName: accountName2,
                receiveAddress: receiveAddress2
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              status2 === "connect" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                WCConnectForm,
                {
                  connectLoading: loading2,
                  code,
                  uri,
                  onInputChange: setUri,
                  onSubmit: async (uri2) => {
                    await handleConnect(uri2);
                  }
                }
              ),
              status2 === "incoming_pairing" && currentProposal && /* @__PURE__ */ jsxRuntimeExports.jsx(
                WCIncomingPairing,
                {
                  currentProposal,
                  pairingMetadata: currentProposal.params.proposer.metadata,
                  receiveAddress: receiveAddress2,
                  onApprove: handleApprovePairingStates,
                  onReject: handleRejectPairingStates
                }
              ),
              status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(WCSuccessPairing, { accountCode: code })
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
};
const container = "_container_1jggi_1";
const textDataContainer = "_textDataContainer_1jggi_16";
const receiveAddress$1 = "_receiveAddress_1jggi_21";
const accountName$1 = "_accountName_1jggi_26";
const dAppMetadataAndIconContainer = "_dAppMetadataAndIconContainer_1jggi_33";
const dAppNameAndUrlContainer = "_dAppNameAndUrlContainer_1jggi_48";
const dappUrl = "_dappUrl_1jggi_54";
const accountNameAndWalletContainer = "_accountNameAndWalletContainer_1jggi_58";
const buttonAndIconContainer = "_buttonAndIconContainer_1jggi_63";
const buttonDisconnect = "_buttonDisconnect_1jggi_69";
const styles$6 = {
  container,
  textDataContainer,
  receiveAddress: receiveAddress$1,
  accountName: accountName$1,
  dAppMetadataAndIconContainer,
  dAppNameAndUrlContainer,
  dappUrl,
  accountNameAndWalletContainer,
  buttonAndIconContainer,
  buttonDisconnect
};
const TextData = ({ accountName: accountName2, receiveAddress: receiveAddress2, dAppName, dAppUrl, iconUrl }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.textDataContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.accountNameAndWalletContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.accountName, children: accountName2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} hide-on-small`, children: receiveAddress2 })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} show-on-small`, children: receiveAddress2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppMetadataAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppNameAndUrlContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: dAppName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.dappUrl, children: dAppUrl })
      ] }),
      iconUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "hide-on-small", src: iconUrl, alt: "dApp icon" })
    ] })
  ] });
};
const WCSessionCard = ({ metadata: metadata2, receiveAddress: receiveAddress2, onDisconnect }) => {
  const { t: t2 } = useTranslation();
  const { name, url, icons } = metadata2;
  const accountDetail = useLoad(() => getEthAccountCodeAndNameByAddress(receiveAddress2), []);
  const truncatedAddress = truncateAddress(receiveAddress2);
  const accountName2 = accountDetail && accountDetail.success ? accountDetail.name : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextData,
      {
        accountName: accountName2,
        receiveAddress: truncatedAddress,
        dAppName: name,
        dAppUrl: url,
        iconUrl: icons[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.buttonAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "show-on-small", src: icons[0], alt: "logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$6.buttonDisconnect, onClick: onDisconnect, danger: true, children: t2("settings.electrum.remove-server") })
    ] })
  ] });
};
const buttonNewConnection = "_buttonNewConnection_13so1_1";
const headerContainer = "_headerContainer_13so1_5";
const receiveAddress = "_receiveAddress_13so1_16";
const noConnectedSessions = "_noConnectedSessions_13so1_22";
const separator = "_separator_13so1_30";
const sessionCardsContainer = "_sessionCardsContainer_13so1_37";
const allSessionsHeading = "_allSessionsHeading_13so1_42";
const styles$5 = {
  buttonNewConnection,
  headerContainer,
  receiveAddress,
  noConnectedSessions,
  separator,
  sessionCardsContainer,
  allSessionsHeading
};
const DashboardWalletConnect = ({ code, accounts }) => {
  var _a;
  const { t: t2 } = useTranslation();
  const { web3wallet, isWalletInitialized, initializeWeb3Wallet } = reactExports.useContext(WCWeb3WalletContext);
  const [sessions, setSessions] = reactExports.useState();
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const updateSessions = reactExports.useCallback(() => {
    const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || []);
    setSessions(activeSessions);
  }, [web3wallet]);
  reactExports.useEffect(() => {
    if (!web3wallet) {
      initializeWeb3Wallet();
      return;
    }
    updateSessions();
  }, [initializeWeb3Wallet, updateSessions, web3wallet]);
  reactExports.useEffect(() => {
    if (isWalletInitialized) {
      web3wallet == null ? void 0 : web3wallet.on("session_delete", updateSessions);
      return () => {
        web3wallet == null ? void 0 : web3wallet.off("session_delete", updateSessions);
      };
    }
  }, [isWalletInitialized, updateSessions, web3wallet]);
  const handleDisconnectSession = async (topic) => {
    await (web3wallet == null ? void 0 : web3wallet.disconnectSession({
      topic,
      reason: U("USER_DISCONNECTED")
    }));
    updateSessions();
  };
  if (!receiveAddresses || !isWalletInitialized) {
    return null;
  }
  const receiveAddress2 = truncateAddress(receiveAddresses[0].addresses[0].address);
  const accountName2 = ((_a = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a.name) || "";
  const hasSession = sessions && sessions.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Status,
        {
          type: "info",
          dismissible: "walletConnectDisclaimerDismissed",
          children: t2("walletConnect.dashboard.disclaimer")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("walletConnect.walletConnect") })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: accountName2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.receiveAddress, children: receiveAddress2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$5.buttonNewConnection, onClick: () => route(`/account/${code}/wallet-connect/connect`), primary: true, children: t2("walletConnect.dashboard.newConnection") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: styles$5.separator }),
        hasSession && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.sessionCardsContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.allSessionsHeading, children: t2("walletConnect.dashboard.allSessions") }),
          sessions.map(
            (session) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCSessionCard,
              {
                receiveAddress: getAddressFromEIPString(session.namespaces["eip155"].accounts[0]),
                metadata: session.peer.metadata,
                onDisconnect: () => handleDisconnectSession(session.topic)
              },
              session.topic
            )
          )
        ] }),
        !hasSession && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.noConnectedSessions, children: t2("walletConnect.dashboard.noConnectedSessions") })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
};
const InjectParams = ({ children: children2 }) => {
  const params = useParams();
  return React.cloneElement(children2, params);
};
const AppRouter = ({ devices, deviceIDs, devicesKey, accounts, activeAccounts }) => {
  const hasAccounts = accounts.length > 0;
  const Homepage = /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch-default")
  );
  const Device2 = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch")
  ) });
  const Acc = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Account,
    {
      code: "",
      devices,
      accounts: activeAccounts
    }
  ) });
  const AccountsSummaryEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AccountsSummary,
    {
      devices,
      accounts: activeAccounts
    }
  ) });
  const AccSend = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SendWrapper,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) });
  const AccReceive = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Receive,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) });
  const AccInfo = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Info,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BitsuranceAccountEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BitsuranceAccount,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BitsuranceWidgetEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BitsuranceWidget,
    {
      code: ""
    }
  ) });
  const AccDashboardWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DashboardWalletConnect,
    {
      accounts: activeAccounts,
      code: ""
    }
  ) });
  const AccConnectScreenWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ConnectScreenWalletConnect,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BuyInfoEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BuyInfo,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const MoonpayEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Moonpay,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const ExchangeEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Exchange,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const PocketEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Pocket,
    {
      code: ""
    }
  ) });
  const PassphraseEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC, { deviceID: "" }) });
  const ManageBackupsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ManageBackups$1,
    {
      devices
    },
    devicesKey("manage-backups")
  ) });
  const MobileSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MobileSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AppearanceEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Appearance,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AboutEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    About,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AdvancedSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdvancedSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const ReceiveAccountsSelectorEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReceiveAccountsSelector, { activeAccounts }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: Homepage }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account/:code", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: Acc }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "send", element: AccSend }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "receive", element: AccReceive }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "info", element: AccInfo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/connect", element: AccConnectScreenWC }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/dashboard", element: AccDashboardWC })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "add-account", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccount, { accounts }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account-summary", element: AccountsSummaryEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "buy", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "info", element: BuyInfoEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BuyInfoEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BuyInfoEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "moonpay/:code", element: MoonpayEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pocket/:code", element: PocketEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "exchange/:code", element: ExchangeEl })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-backups/:deviceID", element: ManageBackupsEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "accounts/select-receive", element: ReceiveAccountsSelectorEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "bitsurance", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "bitsurance", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Bitsurance, { accounts: activeAccounts }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account", element: BitsuranceAccountEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BitsuranceAccountEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BitsuranceAccountEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "widget", element: BitsuranceWidgetEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BitsuranceWidgetEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BitsuranceWidgetEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceDashboard, { accounts: activeAccounts }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "settings", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: MobileSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appearance", element: AppearanceEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "about", element: AboutEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/:deviceID", element: Device2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/passphrase/:deviceID", element: PassphraseEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "advanced-settings", element: AdvancedSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "electrum", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumSettings, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-accounts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(
        HOC$1,
        {
          accounts,
          deviceIDs,
          hasAccounts
        },
        "manage-accounts"
      ) })
    ] })
  ] }) });
};
const FirmwareUpgradeRequired = ({
  deviceID,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        verticallyCentered: true,
        textCenter: true,
        width: "840px",
        withBottomBar: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("upgradeFirmware.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FirmwareSetting,
            {
              asButton: true,
              deviceID,
              versionInfo
            }
          ) }) })
        ]
      }
    )
  ] });
};
const PasswordGestureVideo = "" + new URL("password-gestures.webm", import.meta.url).href;
const passwordGesturesWrapper = "_passwordGesturesWrapper_mvckk_1";
const passwordGestures = "_passwordGestures_mvckk_1";
const styles$4 = {
  passwordGesturesWrapper,
  passwordGestures
};
function isVideoPlaying(video) {
  return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
}
function replayVideo(ref) {
  if (ref && !isVideoPlaying(ref)) {
    ref.muted = true;
    ref.play();
  }
}
const PasswordEntry = () => {
  let ref = reactExports.createRef();
  reactExports.useEffect(() => {
    if (ref.current) {
      replayVideo(ref.current);
    }
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.passwordGesturesWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      autoPlay: true,
      ref,
      className: styles$4.passwordGestures,
      loop: true,
      muted: true,
      height: "338",
      width: "600",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: PasswordGestureVideo, type: "video/webm" })
    }
  ) });
};
const Unlock2 = ({ attestation }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "690px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("button.unlock"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepConnected.unlock") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: attestation === false ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { children: t2("bitbox02Wizard.attestationFailed") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
};
const Pairing = ({
  attestation,
  deviceID,
  pairingFailed
}) => {
  const { t: t2 } = useTranslation();
  const [hash2, setHash] = reactExports.useState("");
  const [deviceVerified, setDeviceVerified] = reactExports.useState(false);
  const onChannelHashChanged = reactExports.useCallback(() => {
    getChannelHash(deviceID).then(({ hash: hash22, deviceVerified: deviceVerified2 }) => {
      setHash(hash22);
      setDeviceVerified(deviceVerified2);
    });
  }, [deviceID]);
  reactExports.useEffect(onChannelHashChanged, [deviceID, onChannelHashChanged]);
  reactExports.useEffect(() => {
    return channelHashChanged(deviceID, onChannelHashChanged);
  }, [deviceID, onChannelHashChanged]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "670px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.pairing.title"), children: pairingFailed ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: t2("bitbox02Wizard.pairing.failed") }, "pairingFailed") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: deviceVerified ? t2("bitbox02Wizard.pairing.paired") : t2("bitbox02Wizard.pairing.unpaired") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { fullWidth: true, children: [
          attestation === false && !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", className: "m-bottom-half", children: t2("bitbox02Wizard.attestationFailed") }),
          !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: hash2 }),
            !deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: !pairingFailed && deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: () => verifyChannelHash(deviceID, true),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  );
};
const toggle = "_toggle_1t1vc_1";
const toggleLabel = "_toggleLabel_1t1vc_7";
const textIcon = "_textIcon_1t1vc_14";
const cardHeight = "_cardHeight_1t1vc_21";
const style$5 = {
  toggle,
  toggleLabel,
  textIcon,
  cardHeight
};
const SetupOptions = ({
  onSelectSetup,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  const [advanced, setAdvanced] = reactExports.useState(false);
  const [withMnemonic, setWithMnemonic] = reactExports.useState(false);
  const [with12Words, setWith12Words] = reactExports.useState(false);
  if (advanced) {
    const {
      canBackupWithRecoveryWords,
      // supported with firmware v9.13.0
      canCreate12Words
      // supported with firmware v9.6.0
    } = versionInfo;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        textCenter: true,
        verticallyCentered: true,
        withBottomBar: true,
        width: "1100px",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("seed.create") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", textAlign: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("bitbox02Wizard.advanced.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-mnemonic",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canBackupWithRecoveryWords && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.skipSDCardLabel") }),
                      " ",
                      !canBackupWithRecoveryWords && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: withMnemonic,
                    disabled: !canBackupWithRecoveryWords,
                    id: "with-mnemonic",
                    onChange: () => setWithMnemonic(!withMnemonic)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.skipSDCardText") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-12words",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canCreate12Words && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.seed12WordLabel") }),
                      " ",
                      !canCreate12Words && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: with12Words,
                    disabled: !canCreate12Words,
                    id: "with-12words",
                    onChange: () => setWith12Words(!with12Words)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.seed12WordText") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
                t2("bitbox02Wizard.advanced.seed12WordInfo")
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { inline: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic,
                    with12Words
                  }),
                  primary: true,
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setWithMnemonic(false);
                    setWith12Words(false);
                    setAdvanced(false);
                  },
                  secondary: true,
                  children: t2("button.back")
                }
              )
            ] })
          ] }) }) })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "1100px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("bitbox02Wizard.stepUninitialized.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
          t2("bitbox02Wizard.initialize.tip")
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, className: style$5.cardHeight, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic: false,
                    with12Words: false
                  }),
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => setAdvanced(true),
                  transparent: true,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.button") })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, className: style$5.cardHeight, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-sdcard"),
                  secondary: true,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMicroSD")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-mnemonic"),
                  secondary: true,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMnemonic")
                }
              )
            ] })
          ] })
        ] }) })
      ]
    }
  );
};
const Wait = ({ title: title2, text: text2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      width: "720px",
      verticallyCentered: true,
      textCenter: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: title2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text2 ? text2 : t2("bitbox02Interact.followInstructions") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
      ]
    }
  );
};
const wizardCheckbox = "_wizardCheckbox_1shxj_2";
const style$4 = {
  wizardCheckbox
};
const ChecklistWalletCreate = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  const [agree1, setAgree1] = reactExports.useState(false);
  const [agree2, setAgree2] = reactExports.useState(false);
  const [agree3, setAgree3] = reactExports.useState(false);
  const [agree4, setAgree4] = reactExports.useState(false);
  const [agree5, setAgree5] = reactExports.useState(false);
  const handleContinue = () => {
    setAgree1(false);
    setAgree2(false);
    setAgree3(false);
    setAgree4(false);
    setAgree5(false);
    onContinue();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackup") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
};
const ChecklistWalletCreateMnemonic = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  const [agree1, setAgree1] = reactExports.useState(false);
  const [agree2, setAgree2] = reactExports.useState(false);
  const [agree3, setAgree3] = reactExports.useState(false);
  const [agree4, setAgree4] = reactExports.useState(false);
  const [agree5, setAgree5] = reactExports.useState(false);
  const handleContinue = () => {
    setAgree1(false);
    setAgree2(false);
    setAgree3(false);
    setAgree4(false);
    setAgree5(false);
    onContinue();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackupMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5mnemonic")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
};
const SetPassword = ({ errorText: errorText2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "600px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepPassword.title"), children: [
          errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorText2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
};
const SetPasswordWithBackup = ({
  forBackup
}) => {
  const { i18n, t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle"), children: forBackup ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "div", markup: t2("backup.restore.selectedBackup", {
            backupName: forBackup.name,
            createdDateTime: convertDateToLocaleString(forBackup.date, i18n.language)
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-small text-ellipsis", children: [
            "ID:",
            " ",
            forBackup.id
          ] })
        ] }) : null }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {})
        ] })
      ]
    }
  );
};
const WithSDCard = ({
  children: children2,
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const [hasSDCard, setSDCard] = reactExports.useState();
  const ensureSDCard = reactExports.useCallback(async () => {
    try {
      const sdCardInserted = await checkSDCard(deviceID);
      setSDCard(sdCardInserted);
      if (sdCardInserted) {
        return;
      }
      const result = await insertSDCard(deviceID);
      setSDCard(result.success);
      if (result.success) {
        return;
      }
      if (result.message) {
        alertUser(result.message, { asDialog: false });
      }
    } catch (error3) {
      console.error(error3);
    }
  }, [deviceID]);
  reactExports.useEffect(() => {
    ensureSDCard();
  }, [ensureSDCard]);
  if (hasSDCard) {
    return children2;
  }
  if (hasSDCard === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: true, textCenter: true, verticallyCentered: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: "Checking microSD card" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Wizard.stepInsertSD.insertSDcardTitle"),
      text: t2("bitbox02Wizard.stepInsertSD.insertSDCard")
    }
  );
};
const CreateWallet = ({
  backupType,
  backupSeedLength,
  deviceID,
  isSeeded,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  const isMounted = useMountedRef();
  const [status2, setStatus] = reactExports.useState("intro");
  const [errorText2, setErrorText] = reactExports.useState("");
  const ensurePassword = async () => {
    setStatus("setPassword");
    try {
      const result = await setPassword(deviceID, backupSeedLength);
      if (!result.success) {
        if (result.code === errUserAbort) {
          alertUser(t2("bitbox02Wizard.stepPassword.e104"), {
            asDialog: false,
            callback: () => onAbort()
          });
          setErrorText("");
        } else {
          setErrorText(t2("bitbox02Wizard.noPasswordMatch"));
          if (isMounted.current) {
            ensurePassword();
          }
        }
        return;
      }
      setErrorText("");
      setStatus("showDisclaimer");
    } catch (error3) {
      console.error(error3);
    }
  };
  const setDeviceName$1 = async (deviceName) => {
    setStatus("setName");
    try {
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText22 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText22 || t2("genericError"), {
          asDialog: false,
          callback: () => onAbort()
        });
        return;
      }
      ensurePassword();
    } catch (error3) {
      console.error(error3);
    }
  };
  const createBackup$1 = async () => {
    setStatus("createBackup");
    try {
      const result = await createBackup(
        deviceID,
        backupType === "mnemonic" ? "recovery-words" : "sdcard"
      );
      if (!result.success) {
        if (result.code === errUserAbort) {
          alertUser(t2("bitbox02Wizard.createBackupAborted"), {
            asDialog: false,
            callback: () => onAbort()
          });
        } else {
          alertUser(t2("bitbox02Wizard.createBackupFailed"), { asDialog: false });
        }
      }
    } catch (error3) {
      console.error(error3);
    }
  };
  if (isSeeded) {
    if (status2 === "showDisclaimer") {
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreate, { onContinue: createBackup$1 }) });
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreateMnemonic, { onContinue: createBackup$1 });
      }
    }
    if (status2 === "createBackup") {
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmDate"),
              text: t2("bitbox02Interact.confirmDateText")
            }
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmWords", {
                amount: backupSeedLength === 16 ? "12" : "24"
              }),
              text: t2("bitbox02Interact.confirmWordsText")
            }
          );
      }
    }
  }
  switch (status2) {
    case "intro":
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceNameWithSDCard,
            {
              deviceID,
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-sdcard"
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceName,
            {
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-mnemonic"
          );
      }
      break;
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetPassword,
        {
          errorText: errorText2
        }
      );
    default:
      return null;
  }
};
const RestoreFromSDCardBackup = ({
  deviceID,
  onSelectBackup,
  onRestoreBackup,
  onBack
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID,
            showRestore: true,
            showRadio: true,
            onSelectBackup,
            onRestoreBackup,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: onBack,
                children: t2("button.back")
              }
            )
          }
        ) })
      ]
    }
  );
};
const RestoreFromSDCard = ({
  deviceID,
  onAbort
}) => {
  const [status2, setStatus] = reactExports.useState("restore");
  const [backup2, setBackup] = reactExports.useState();
  const onSelectBackup = (backup22) => {
    setStatus("setPassword");
    setBackup(backup22);
  };
  const onRestoreBackup = (success2) => {
    if (!success2) {
      onAbort();
      return;
    }
    setBackup(void 0);
  };
  switch (status2) {
    case "restore":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCardBackup,
        {
          deviceID,
          onSelectBackup,
          onRestoreBackup,
          onBack: onAbort
        }
      ) });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SetPasswordWithBackup, { forBackup: backup2 });
  }
};
const RestoreFromMnemonic = ({
  deviceID,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  const [status2, setStatus] = reactExports.useState("intro");
  const restoreMnemonic = () => {
    restoreFromMnemonic(deviceID).then((result) => {
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Wizard.restoreFromMnemonic.e104") : t2("bitbox02Wizard.restoreFromMnemonic.failed");
        alertUser(errorText2, {
          asDialog: false,
          callback: () => onAbort()
        });
      }
    }).catch(console.error);
  };
  const setDeviceName$1 = async (deviceName) => {
    try {
      setStatus("setName");
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText2 || t2("genericError"), {
          asDialog: false,
          callback: () => onAbort()
        });
        return;
      }
      setStatus("restoreMnemonic");
      restoreMnemonic();
    } catch (error3) {
      console.error(error3);
    }
  };
  switch (status2) {
    case "intro":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetDeviceName,
        {
          missingSDCardWarning: false,
          onDeviceName: setDeviceName$1,
          onBack: onAbort
        }
      );
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "restoreMnemonic":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Wait,
        {
          title: t2("bitbox02Interact.followInstructionsMnemonicTitle"),
          text: t2("bitbox02Interact.followInstructionsMnemonic")
        }
      );
  }
};
const CreateWalletSuccess = ({
  backupType,
  onContinue
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: true,
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.success.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.success") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { withIcon: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: backupType === "sdcard" ? t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") : t2("bitbox02Wizard.stepCreateSuccess.storeMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const RestoreFromSDCardSuccess = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const RestoreFromMnemonicSuccess = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5mnemonic") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const Wizard = ({ deviceID }) => {
  const navigate2 = useNavigate();
  const versionInfo = useLoad(() => getVersion(deviceID));
  const attestation = useSync(
    () => verifyAttestation(deviceID),
    (cb2) => attestationCheckDone(deviceID, () => {
      verifyAttestation(deviceID).then(cb2);
    })
  );
  const [appStatus, setAppStatus] = reactExports.useState("");
  const [createOptions, setCreateOptions] = reactExports.useState();
  const [showWizard, setShowWizard] = reactExports.useState(false);
  const [unlockOnly, setUnlockOnly] = reactExports.useState(true);
  const status2 = useSync(
    () => getStatus$1(deviceID),
    (cb2) => statusChanged(deviceID, () => {
      getStatus$1(deviceID).then(cb2);
    })
  );
  const handleGetStarted = () => {
    setShowWizard(false);
    navigate2("/account-summary");
  };
  reactExports.useEffect(() => {
    if (status2 === void 0) {
      return;
    }
    if (!showWizard && ["connected", "unpaired", "pairingFailed", "uninitialized", "seeded"].includes(status2)) {
      setShowWizard(true);
    }
    if (unlockOnly && ["uninitialized", "seeded"].includes(status2)) {
      setUnlockOnly(false);
    }
  }, [status2, showWizard, unlockOnly]);
  const handleAbort = () => {
    setAppStatus("");
    setCreateOptions(void 0);
  };
  if (status2 === void 0) {
    return null;
  }
  if (!versionInfo) {
    return null;
  }
  if (status2 === "require_firmware_upgrade") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FirmwareUpgradeRequired,
      {
        deviceID,
        versionInfo
      }
    );
  }
  if (status2 === "require_app_upgrade") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
  }
  if (!showWizard) {
    return null;
  }
  if (appStatus === "" && status2 === "initialized") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    status2 === "connected" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Unlock2,
      {
        attestation
      },
      "unlock"
    ) : null,
    (status2 === "unpaired" || status2 === "pairingFailed") && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Pairing,
      {
        deviceID,
        attestation,
        pairingFailed: status2 === "pairingFailed"
      },
      "pairing"
    ),
    !unlockOnly && appStatus === "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetupOptions,
      {
        versionInfo,
        onSelectSetup: (type2, createOptions2) => {
          setAppStatus(type2);
          setCreateOptions(createOptions2);
        }
      },
      "choose-setup"
    ),
    !unlockOnly && appStatus === "create-wallet" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateWallet,
      {
        backupType: (createOptions == null ? void 0 : createOptions.withMnemonic) ? "mnemonic" : "sdcard",
        backupSeedLength: (createOptions == null ? void 0 : createOptions.with12Words) ? 16 : 32,
        deviceID,
        isSeeded: status2 === "seeded",
        onAbort: handleAbort
      }
    ),
    !unlockOnly && appStatus === "restore-sdcard" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RestoreFromSDCard,
      {
        deviceID,
        onAbort: handleAbort
      },
      "restore-sdcard"
    ),
    !unlockOnly && appStatus === "restore-mnemonic" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RestoreFromMnemonic,
      {
        deviceID,
        onAbort: handleAbort
      },
      "restore-mnemonic"
    ),
    appStatus === "create-wallet" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateWalletSuccess,
      {
        backupType: (createOptions == null ? void 0 : createOptions.withMnemonic) ? "mnemonic" : "sdcard",
        onContinue: handleGetStarted
      },
      "success"
    ),
    appStatus === "restore-sdcard" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromSDCardSuccess, { onContinue: handleGetStarted }, "backup-success"),
    appStatus === "restore-mnemonic" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromMnemonicSuccess, { onContinue: handleGetStarted }, "backup-mnemonic-success")
  ] });
};
const syncNewTxs = (cb2) => {
  return subscribe("newTxs", (event2) => {
    if (event2.type === "backend") {
      cb2(event2.meta);
    }
  });
};
class ConnectedApp extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      connected: true
    };
  }
  componentDidMount() {
    this.unsubscribe = backendConnected((connected) => this.setState({ connected }));
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  render() {
    const { children: children2 } = this.props;
    const { connected } = this.state;
    if (!connected) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", style: { padding: 40 }, children: "The WebSocket closed. Please restart the backend and reload this page." });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: children2 });
  }
}
const cancel = () => {
  return apiPost("aopp/cancel");
};
const approve = () => {
  return apiPost("aopp/approve");
};
const chooseAccount = (accountCode) => {
  return apiPost("aopp/choose-account", { accountCode });
};
const getAOPP = () => {
  return apiGet("aopp");
};
const subscribeAOPP = (cb2) => {
  return subscribeEndpoint("aopp", cb2);
};
const isArray = Array.isArray;
const keyList = Object.keys;
const hasProp = Object.prototype.hasOwnProperty;
function equal(a2, b2) {
  if (Object.is(a2, b2)) {
    return true;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    let arrA = isArray(a2), arrB = isArray(b2), i, length2, key;
    if (arrA && arrB) {
      length2 = a2.length;
      if (length2 !== b2.length) {
        return false;
      }
      for (i = 0; i < length2; i++) {
        if (!equal(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    if (arrA !== arrB) {
      return false;
    }
    let keys = keyList(a2);
    length2 = keys.length;
    if (length2 !== keyList(b2).length) {
      return false;
    }
    for (i = 0; i < length2; i++) {
      if (!hasProp.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = 0; i < length2; i++) {
      key = keys[i];
      if (!equal(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
const VerifyAddress = ({ accountCode, address: address2, addressID }) => {
  const [verifying, setVerifying] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const verifyAddress2 = async () => {
    setVerifying(true);
    await verifyAddress$1(accountCode, addressID);
    setVerifying(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: verifyAddress2, children: t2("receive.verifyBitBox02") }),
    verifying ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("receive.verifyBitBox02"), children: address2 }) : null
  ] });
};
const logo = "_logo_rqpye_1";
const prominent = "_prominent_rqpye_9";
const hostname = "_hostname_rqpye_22";
const capitalized = "_capitalized_rqpye_31";
const styles$3 = {
  logo,
  prominent,
  hostname,
  capitalized
};
const AOPPGroupLogo = "" + new URL("aoppgroup.svg", import.meta.url).href;
const BitcoinSuisseLogo = "" + new URL("bitcoin_suisse.png", import.meta.url).href;
const BittrLogo = "" + new URL("bittr.png", import.meta.url).href;
const BityLogo = "" + new URL("bity.png", import.meta.url).href;
const PocketBitcoinLogo = "" + new URL("pocketbitcoin.svg", import.meta.url).href;
const VASPLogoMap = {
  "demo.aopp.group": AOPPGroupLogo,
  "testing.aopp.group": AOPPGroupLogo,
  "bitcoinsuisse.com": BitcoinSuisseLogo,
  "bity.com": BityLogo,
  "getbittr.com": BittrLogo,
  "pocketbitcoin.com": PocketBitcoinLogo
};
const VASPHostnameMap = {
  "demo.aopp.group": "AOPP.group",
  "testing.aopp.group": "AOPP.group"
};
const Vasp = ({
  fallback,
  hostname: hostname2,
  prominent: prominent2,
  withLogoText
}) => {
  const hasLogo = hostname2 in VASPLogoMap;
  if (!hasLogo) {
    return fallback || /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$3.hostname, children: hostname2 });
  }
  const logoClasses = prominent2 ? `${styles$3.logo} ${styles$3.prominent}` : styles$3.logo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: logoClasses, src: VASPLogoMap[hostname2], alt: hostname2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$3.hostname} ${styles$3.capitalized}`, children: hostname2 in VASPHostnameMap ? VASPHostnameMap[hostname2] : hostname2 }),
    withLogoText ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: withLogoText }) : null
  ] });
};
const banner = "_banner_yebbr_1";
const smallIcon = "_smallIcon_yebbr_10";
const successText = "_successText_yebbr_15";
const proceed = "_proceed_yebbr_28";
const message = "_message_yebbr_33";
const styles$2 = {
  banner,
  smallIcon,
  successText,
  proceed,
  message
};
const Banner$1 = ({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.banner, children: children2 });
const domain = (callback2) => new URL(callback2).host;
class Aopp extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      accountCode: "",
      aopp: void 0
    };
    this.chooseAccount = (e3) => {
      if (this.state.accountCode) {
        chooseAccount(this.state.accountCode);
      }
      e3.preventDefault();
    };
  }
  componentDidMount() {
    this.setAccountCodeDefault();
    this.unsubscribe = subscribeAOPP((aopp2) => this.updateAOPP(aopp2));
    getAOPP().then((aopp2) => this.setState({ aopp: aopp2 }));
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  updateAOPP(aopp2) {
    let shouldUpdateAccountCodeDefault = false;
    this.setState((currentState) => {
      var _a, _b;
      if ((aopp2 == null ? void 0 : aopp2.state) === "choosing-account" && (((_a = currentState.aopp) == null ? void 0 : _a.state) !== "choosing-account" || !equal(aopp2.accounts, (_b = currentState.aopp) == null ? void 0 : _b.accounts))) {
        shouldUpdateAccountCodeDefault = true;
      }
      return { aopp: aopp2 };
    }, () => {
      if (shouldUpdateAccountCodeDefault) {
        this.setAccountCodeDefault();
      }
    });
  }
  setAccountCodeDefault() {
    const { aopp: aopp2 } = this.state;
    if (aopp2 === void 0 || aopp2.state !== "choosing-account") {
      return;
    }
    if (aopp2.accounts.length) {
      this.setState({ accountCode: aopp2.accounts[0].code });
    }
  }
  render() {
    const { t: t2 } = this.props;
    const { accountCode, aopp: aopp2 } = this.state;
    if (!aopp2) {
      return null;
    }
    switch (aopp2.state) {
      case "error":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.errorTitle"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "error", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$2.smallIcon }),
                t2(`error.${aopp2.errorCode}`, { host: domain(aopp2.callback) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, onClick: cancel, children: t2("button.dismiss") }) })
            ]
          }
        );
      case "inactive":
        return null;
      case "user-approval":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), withAppLogo: true }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Vasp,
                {
                  prominent: true,
                  hostname: domain(aopp2.callback),
                  fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("aopp.addressRequest", {
                    host: `<strong>${domain(aopp2.callback)}</strong>`
                  }) }),
                  withLogoText: t2("aopp.addressRequestWithLogo")
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: approve, children: t2("button.continue") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        );
      case "awaiting-keystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Banner$1, { children: t2("aopp.banner") });
      case "choosing-account": {
        const options2 = aopp2.accounts.map((account2) => {
          return {
            text: account2.name,
            value: account2.code
          };
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: this.chooseAccount, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  label: t2("buy.info.selectLabel"),
                  options: options2,
                  value: accountCode,
                  onChange: (e3) => {
                    var _a;
                    return this.setState({ accountCode: (_a = e3.target) == null ? void 0 : _a.value });
                  },
                  id: "account"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.next") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        ) });
      }
      case "syncing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.syncing") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") }) })
            ]
          }
        );
      case "signing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.signing") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: true, flexibleHeight: true, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
              ] })
            ]
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fitContent: true,
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { withIcon: "success", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.successText, children: t2("aopp.success.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.proceed, children: t2("aopp.success.message", { host: domain(aopp2.callback) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: true, flexibleHeight: true, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { style: { marginBottom: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: cancel, children: t2("button.done") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VerifyAddress,
                  {
                    accountCode: aopp2.accountCode,
                    address: aopp2.address,
                    addressID: aopp2.addressID
                  }
                )
              ] })
            ]
          }
        );
    }
  }
}
const translateHOC = translate()(Aopp);
const getBanner = (msgKey) => {
  return apiGet(`banners/${msgKey}`);
};
const syncBanner = (msgKey, cb2) => {
  return subscribeEndpoint(`banners/${msgKey}`, cb2);
};
const link$1 = "_link_4u2en_1";
const style$3 = {
  link: link$1
};
const Banner = ({ msgKey }) => {
  const { i18n, t: t2 } = useTranslation();
  const [banner2, setBanner] = reactExports.useState();
  reactExports.useEffect(() => {
    getBanner(msgKey).then(setBanner);
    syncBanner(msgKey, setBanner);
  }, [msgKey]);
  if (!banner2 || !i18n.options.fallbackLng) {
    return null;
  }
  const { message: message2, link: link2 } = banner2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Status,
    {
      dismissible: banner2.dismissible ? `banner-${msgKey}-${banner2.id}` : "",
      type: banner2.type ? banner2.type : "warning",
      children: [
        message2[i18n.resolvedLanguage] || message2[i18n.options.fallbackLng[0]],
        "",
        link2 && /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: link2.href, className: style$3.link, children: link2.text || t2("clickHere") })
      ]
    }
  );
};
const SkipForTesting = () => {
  const [dialog2, setDialog] = reactExports.useState(false);
  const show2 = useLoad(() => Promise.resolve(false));
  const [testPIN, setTestPIN] = reactExports.useState("");
  const registerTestingDevice = async (e3) => {
    e3.preventDefault();
    await testRegister(testPIN);
    setDialog(false);
  };
  if (!show2) {
    return null;
  }
  const title2 = "Unlock software keystore";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setDialog(true), children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: dialog2, title: title2, onClose: () => setDialog(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: registerTestingDevice, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordSingleInput,
        {
          type: "password",
          autoFocus: true,
          label: "Test Password",
          onValidPassword: setTestPIN,
          value: testPIN
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: "Unlock" }) })
    ] }) })
  ] });
};
const bitboxContainer = "_bitboxContainer_1nxo8_1";
const failed = "_failed_1nxo8_18";
const bitboxImage = "_bitboxImage_1nxo8_24";
const cancelIcon = "_cancelIcon_1nxo8_29";
const text = "_text_1nxo8_35";
const styles$1 = {
  bitboxContainer,
  failed,
  bitboxImage,
  cancelIcon,
  text
};
function KeystoreConnectPrompt() {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const [data, reset2] = useSubscribeReset(syncConnectKeystore());
  const cancelAndReset = () => {
    reset2();
    cancelConnectKeystore();
  };
  const errorMessage2 = (errorCode) => {
    switch (errorCode) {
      case "wrongKeystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t2("error.wrongKeystore"),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          t2("error.wrongKeystore2")
        ] });
      case "timeout":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t2("error.keystoreTimeout") });
      default:
        return null;
    }
  };
  if (!data) {
    return null;
  }
  switch (data.typ) {
    case "connect":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: true, open: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$1.text, children: [
          data.keystoreName === "" ? t2("connectKeystore.promptNoName") : t2("connectKeystore.promptWithName", { name: data.keystoreName }),
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.bitboxContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancelConnectKeystore, children: t2("dialog.cancel") }) })
      ] });
    case "error":
      const err = errorMessage2(data.errorCode);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: true, open: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$1.text, children: err ? err : data.errorMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$1.bitboxContainer} ${styles$1.failed}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$1.cancelIcon }),
          isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: styles$1.bitboxImage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: styles$1.bitboxImage }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancelAndReset, children: t2("dialog.cancel") }) })
      ] });
    default:
      return null;
  }
}
const getUsingMobileData = () => {
  return apiGet("using-mobile-data");
};
const subscribeUsingMobileData = (cb2) => subscribeEndpoint("using-mobile-data", cb2);
const MobileDataWarning = () => {
  const { t: t2 } = useTranslation();
  const isUsingMobileData = useSync(getUsingMobileData, subscribeUsingMobileData);
  if (isUsingMobileData === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Status,
    {
      dismissible: "mobile-data-warning",
      type: "warning",
      hidden: !isUsingMobileData,
      children: t2("mobile.usingMobileDataWarning")
    }
  );
};
const coins = "" + new URL("coins.svg", import.meta.url).href;
const shieldIcon = "" + new URL("shield_grey.svg", import.meta.url).href;
const linechart = "" + new URL("linechart.svg", import.meta.url).href;
const settings = "" + new URL("settings-alt.svg", import.meta.url).href;
const settingsGrey = "" + new URL("settings-alt_disabled.svg", import.meta.url).href;
const closeButton = "_closeButton_1xwfn_1";
const sidebarOverlay = "_sidebarOverlay_1xwfn_13";
const active = "_active_1xwfn_26";
const sidebar = "_sidebar_1xwfn_13";
const end = "_end_1xwfn_47";
const forceShow = "_forceShow_1xwfn_52";
const sidebarLogoContainer = "_sidebarLogoContainer_1xwfn_56";
const sidebarHeaderContainer = "_sidebarHeaderContainer_1xwfn_75";
const sidebarPortfolio = "_sidebarPortfolio_1xwfn_85";
const sidebarHeader = "_sidebarHeader_1xwfn_75";
const sidebarIconVisible = "_sidebarIconVisible_1xwfn_95";
const sidebarIconHidden = "_sidebarIconHidden_1xwfn_99";
const sidebarItem = "_sidebarItem_1xwfn_103";
const sidebarArrow = "_sidebarArrow_1xwfn_121";
const sidebarActive = "_sidebarActive_1xwfn_125";
const activeGroup = "_activeGroup_1xwfn_130";
const single = "_single_1xwfn_136";
const sidebarLabel = "_sidebarLabel_1xwfn_141";
const sidebarSubmenu = "_sidebarSubmenu_1xwfn_197";
const sidebarContainer = "_sidebarContainer_1xwfn_216";
const forceHide = "_forceHide_1xwfn_216";
const style$2 = {
  closeButton,
  sidebarOverlay,
  active,
  sidebar,
  end,
  forceShow,
  sidebarLogoContainer,
  sidebarHeaderContainer,
  sidebarPortfolio,
  sidebarHeader,
  sidebarIconVisible,
  sidebarIconHidden,
  sidebarItem,
  sidebarArrow,
  sidebarActive,
  activeGroup,
  single,
  sidebarLabel,
  sidebarSubmenu,
  sidebarContainer,
  forceHide
};
const GetAccountLink = ({
  coinCode,
  code,
  name,
  handleSidebarItemClick
}) => {
  const { pathname } = useLocation();
  const active2 = pathname === `/account/${code}` || pathname.startsWith(`/account/${code}/`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Link,
    {
      className: active2 ? style$2.sidebarActive : "",
      to: `/account/${code}`,
      onClick: handleSidebarItemClick,
      title: name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: true, coinCode, alt: name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: name })
      ]
    }
  ) });
};
const Sidebar = ({
  deviceIDs,
  accounts
}) => {
  const { t: t2 } = useTranslation();
  const { pathname } = useLocation();
  const { activeSidebar, sidebarStatus, toggleSidebar } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => {
    const swipe = {
      active: false,
      x: 0,
      y: 0
    };
    const handleTouchStart = (event2) => {
      const touch = event2.touches[0];
      swipe.x = touch.clientX;
      swipe.y = touch.clientY;
    };
    const handleTouchMove = (event2) => {
      if (sidebarStatus !== "forceHidden" && event2.changedTouches && event2.changedTouches.length) {
        swipe.active = true;
      }
    };
    const handleTouchEnd = (event2) => {
      if (sidebarStatus !== "forceHidden") {
        const touch = event2.changedTouches[0];
        const travelX = Math.abs(touch.clientX - swipe.x);
        const travelY = Math.abs(touch.clientY - swipe.y);
        const validSwipe = window.innerWidth <= 901 && swipe.active && travelY < 100 && travelX > 70;
        if (!activeSidebar && validSwipe && swipe.x < 60 || activeSidebar && validSwipe && swipe.x > 230) {
          toggleSidebar();
        }
        swipe.x = 0;
        swipe.y = 0;
        swipe.active = false;
      }
    };
    document.addEventListener("touchstart", handleTouchStart);
    document.addEventListener("touchmove", handleTouchMove);
    document.addEventListener("touchend", handleTouchEnd);
    return () => {
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("touchend", handleTouchEnd);
    };
  }, [activeSidebar, sidebarStatus, toggleSidebar]);
  const [keystores, setKeystores] = reactExports.useState();
  reactExports.useEffect(() => {
    getKeystores().then((keystores2) => {
      setKeystores(keystores2);
    });
    return subscribeKeystores(setKeystores);
  }, []);
  const handleSidebarItemClick = (event2) => {
    const el2 = event2.target.closest("a");
    if (el2.classList.contains("sidebarActive") && window.innerWidth <= 901) {
      toggleSidebar();
    }
  };
  const hidden = sidebarStatus === "forceHidden";
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const accountsByKeystore = getAccountsByKeystore(accounts);
  const userInSpecificAccountBuyPage = pathname.startsWith("/buy");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$2.sidebarContainer, hidden ? style$2.forceHide : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$2.sidebarOverlay, activeSidebar ? style$2.active : ""].join(" "), onClick: toggleSidebar }, "overlay"),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: [style$2.sidebar, activeSidebar ? style$2.forceShow : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$2.sidebarLogoContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: accounts.length ? "/account-summary" : "/",
            onClick: handleSidebarItemClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, { className: style$2.sidebarLogo })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$2.closeButton, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {}) })
      ] }, "app-logo"),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$2.sidebarItem} ${style$2.sidebarPortfolio}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
          to: "/account-summary",
          title: t2("accountSummary.title"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: linechart }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("accountSummary.title") })
          ]
        }
      ) }, "account-summary") : null,
      accountsByKeystore.map((keystore2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarHeaderContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: style$2.sidebarHeader,
            hidden: !keystore2.accounts.length,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                `${keystore2.keystore.name} `,
                isAmbiguiousName(keystore2.keystore.name, accountsByKeystore) ? (
                  // Disambiguate accounts group by adding the fingerprint.
                  // The most common case where this would happen is when adding accounts from the
                  // same seed using different passphrases.
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    " (",
                    keystore2.keystore.rootFingerprint,
                    ")"
                  ] })
                ) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Badge,
                {
                  className: keystore2.keystore.connected ? style$2.sidebarIconVisible : style$2.sidebarIconHidden,
                  icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                  type: "success",
                  title: t2("device.keystoreConnected")
                }
              )
            ]
          }
        ) }),
        keystore2.accounts.map((acc) => /* @__PURE__ */ jsxRuntimeExports.jsx(GetAccountLink, { ...acc, handleSidebarItemClick }, `account-${acc.code}`))
      ] }, `keystore-${keystore2.keystore.rootFingerprint}`)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$2.sidebarHeaderContainer, style$2.end].join(" ") }, "services"),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          NavLink,
          {
            className: ({ isActive }) => isActive || userInSpecificAccountBuyPage ? style$2.sidebarActive : "",
            to: "/buy/info",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: coins, alt: t2("sidebar.exchanges") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: hasOnlyBTCAccounts ? t2("accountInfo.buyCTA.buy", { unit: "Bitcoin" }) : t2("sidebar.buy") })
            ]
          }
        ) }, "buy"),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          NavLink,
          {
            className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
            to: "/bitsurance/bitsurance",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: shieldIcon, alt: t2("sidebar.insurance") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("sidebar.insurance") })
            ]
          }
        ) }, "insurance")
      ] }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
          to: "/settings",
          title: t2("sidebar.settings"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: settingsGrey, alt: t2("sidebar.settings") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: settings, alt: t2("sidebar.settings") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("sidebar.settings") })
          ]
        }
      ) }, "settings"),
      !keystores || keystores.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {}) : null,
      debug
    ] })
  ] });
};
const link = "_link_13in7_1";
const style$1 = {
  link
};
const Update = () => {
  const { t: t2 } = useTranslation();
  const file = useLoad(getUpdate);
  if (!file) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Status, { dismissible: `update-${file.version}`, type: "info", children: [
    t2("app.upgrade", {
      current: file.current,
      version: file.version
    }),
    file.description,
    " ",
    !runningInAndroid() && /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadLink, { className: style$1.link })
  ] });
};
const auth = "_auth_xdrxz_1";
const style = {
  auth
};
const AuthRequired = () => {
  const { t: t2 } = useTranslation();
  const [authRequired, setAuthRequired] = reactExports.useState(false);
  const [authenticating, setAuthenticating] = reactExports.useState(false);
  const authForced = reactExports.useRef(false);
  const newAuthentication = () => {
    setAuthenticating(true);
    authenticate(authForced.current);
  };
  reactExports.useEffect(() => {
    const unsubscribe2 = subscribeAuth((data) => {
      switch (data.typ) {
        case "auth-forced":
          authForced.current = true;
          break;
        case "auth-required":
          setAuthRequired((prevAuthRequired) => {
            if (!prevAuthRequired) {
              newAuthentication();
            }
            return true;
          });
          break;
        case "auth-err":
          setAuthenticating(false);
          break;
        case "auth-canceled":
          if (authForced.current) {
            setAuthRequired(false);
            authForced.current = false;
          } else {
            setAuthenticating(false);
          }
          break;
        case "auth-ok":
          setAuthRequired(false);
          authForced.current = false;
      }
    });
    setAuthRequired(true);
    newAuthentication();
    return unsubscribe2;
  }, []);
  if (!authRequired) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style.auth, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("auth.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: void 0, minHeight: "0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: true,
            primary: true,
            hidden: authForced.current,
            disabled: authenticating,
            onClick: newAuthentication,
            children: t2("auth.authButton")
          }
        ) })
      ]
    }
  ) });
};
const fetchAccountNameAndAddress = async (address2) => {
  const accountDetail = await getEthAccountCodeAndNameByAddress(address2);
  if (!accountDetail.success) {
    console.log("Failed in fetching account name and code");
    return { accountName: "", accountCode: "" };
  }
  const { code, name } = accountDetail;
  return { accountName: name, accountCode: code };
};
async function handleWcEthSignRequest(method, args) {
  switch (method) {
    case EIP155_SIGNING_METHODS.ETH_SIGN:
    case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      await ethSignHandler(args, method);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      await ethSignTypedDataHandler(args);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
    case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      await ethSignOrSendTransactionHandler(args, method);
      break;
    default:
      console.log(`${method} is unsupported`);
  }
}
async function ethSignHandler({ params, launchSignDialog, topic, id: id2, currentSession }, method) {
  const isPersonalSign = method === EIP155_SIGNING_METHODS.PERSONAL_SIGN;
  const requestParams = params.request.params;
  const accountAddress = isPersonalSign ? requestParams[1] : requestParams[0];
  const signingData = isPersonalSign ? requestParams[0] : requestParams[1];
  const decoded = decodeEthMessage(signingData);
  if (decoded === null) {
    alertUser(t$1("walletConnect.signingRequest.decodeError"));
    return;
  }
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  const apiCaller = async () => {
    const result = await ethSignMessage(accountCode, signingData);
    if (!result.success) {
      return { success: false, error: result };
    }
    return {
      response: { id: id2, jsonrpc: "2.0", result: result.signature },
      success: true
    };
  };
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: decoded,
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signMessage")
    }
  });
}
async function ethSignTypedDataHandler({ params, launchSignDialog, topic, id: id2, currentSession }) {
  const requestParams = params.request.params;
  const accountAddress = requestParams[0];
  const data = requestParams[1];
  let typedData;
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  try {
    typedData = JSON.parse(data);
  } catch (e3) {
    console.error("Failed to parse JSON", e3);
    alertUser(t$1("walletConnect.signingRequest.dataParsingError"));
    return;
  }
  const apiCaller = async () => {
    var _a;
    const chainId = ((_a = typedData == null ? void 0 : typedData.domain) == null ? void 0 : _a.chainId) ? Number(typedData.domain.chainId) : Number(params.chainId.replace(/^eip155:/, ""));
    const result = await ethSignTypedMessage(accountCode, chainId, data);
    if (result.success) {
      const response = { id: id2, jsonrpc: "2.0", result: result.signature };
      return { response, success: true };
    }
    return { success: false, error: result };
  };
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(typedData, null, 2),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signTypedData")
    }
  });
}
async function ethSignOrSendTransactionHandler(args, method) {
  const isSendAndSign = method === EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION;
  const { params, launchSignDialog, topic, id: id2, currentSession } = args;
  const requestParams = params.request.params;
  const accountAddress = requestParams[0].from;
  const data = requestParams[0];
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  const apiCaller = async () => {
    const chainId = Number(params.chainId.replace(/^eip155:/, ""));
    const result = await ethSignWalletConnectTx(accountCode, isSendAndSign, chainId, data);
    if (result.success) {
      const response = { id: id2, jsonrpc: "2.0", result: isSendAndSign ? result.txHash : result.rawTx };
      return { response, success: true };
    }
    return { success: false, error: result };
  };
  const formattedMethod = isSendAndSign ? t$1("walletConnect.signingRequest.method.sendTransaction") : t$1("walletConnect.signingRequest.method.signTransaction");
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(data),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: formattedMethod
    }
  });
}
const accountName = "_accountName_gsa52_1";
const accountNameAndAddress = "_accountNameAndAddress_gsa52_6";
const address = "_address_gsa52_10";
const animationAndTextContainer = "_animationAndTextContainer_gsa52_16";
const chainContainer = "_chainContainer_gsa52_28";
const itemText = "_itemText_gsa52_33";
const dappIcon = "_dappIcon_gsa52_42";
const item = "_item_gsa52_33";
const label = "_label_gsa52_62";
const listContainer = "_listContainer_gsa52_68";
const outerContainer = "_outerContainer_gsa52_77";
const successIcon = "_successIcon_gsa52_84";
const textarea = "_textarea_gsa52_89";
const titleContainer = "_titleContainer_gsa52_97";
const styles = {
  accountName,
  accountNameAndAddress,
  address,
  animationAndTextContainer,
  chainContainer,
  itemText,
  dappIcon,
  item,
  label,
  listContainer,
  outerContainer,
  successIcon,
  textarea,
  titleContainer
};
const ConfirmOnBB02 = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("confirmOnDevice") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
  ] });
};
const RequestSuccessfullySigned = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("walletConnect.signingRequest.successfullySigned") })
  ] });
};
const WCIncomingSignRequestDialog = ({
  open: open2,
  onAccept,
  onReject,
  content: content2,
  stage
}) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const { accountAddress, accountName: accountName2, signingData, chain, method, currentSession } = content2;
  const formattedChain = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].name : chain;
  const chainIcon = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].icon : null;
  const metadata2 = currentSession.peer.metadata;
  const maxTextAreaRows = 20;
  const signingDataHeight = signingData.toString().split("\n").length + 3;
  const textAreaRows = signingDataHeight > maxTextAreaRows ? maxTextAreaRows : signingDataHeight;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, large: true, onClose: onReject, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titleContainer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { height: 32, width: 32 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDark, { height: 40, width: 40 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("walletConnect.signingRequest.walletConnectRequest") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.outerContainer, children: [
      stage !== "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: styles.listContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.account") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles.accountNameAndAddress, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.accountName, children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: accountName2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.address, children: truncateAddress(accountAddress) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.chain") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.chainContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: formattedChain }),
              chainIcon
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.dapp") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: metadata2.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: method })
          ] }),
          signingData && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.data") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { rows: textAreaRows, className: styles.textarea, readOnly: true, value: signingData.toString() })
          ] })
        ] }),
        stage === "confirming" && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmOnBB02, {}),
        stage === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onAccept, primary: true, type: "submit", children: t2("button.continue") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onReject, secondary: true, type: "submit", children: t2("dialog.cancel") })
        ] })
      ] }),
      stage === "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsx(RequestSuccessfullySigned, {})
    ] })
  ] });
};
const WCSigningRequest = () => {
  const { web3wallet, isWalletInitialized } = reactExports.useContext(WCWeb3WalletContext);
  const [dialogOpen, setDialogOpen] = reactExports.useState(false);
  const [dialogContent, setDialogContent] = reactExports.useState();
  const [stage, setStage] = reactExports.useState("initial");
  const signMessageApiCallerRef = reactExports.useRef();
  const requestDataRef = reactExports.useRef();
  const launchSignDialog = ({ topic, id: id2, apiCaller, dialogContent: dialogContent2 }) => {
    const { signingData, currentSession, accountAddress, accountName: accountName2, chain, method } = dialogContent2;
    requestDataRef.current = { topic, id: id2 };
    signMessageApiCallerRef.current = apiCaller;
    setDialogContent({
      accountAddress,
      accountName: accountName2,
      signingData,
      chain,
      currentSession,
      method
    });
    setDialogOpen(true);
  };
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized) {
      return;
    }
    const onSessionRequest = async (requestEvent) => {
      const { topic, params, id: id2 } = requestEvent;
      const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || {});
      const currentSession = activeSessions.find((session) => session.topic === topic);
      if (currentSession) {
        const handlerArgs = {
          topic,
          id: id2,
          params,
          currentSession,
          launchSignDialog
        };
        await handleWcEthSignRequest(params.request.method, handlerArgs);
      }
    };
    web3wallet == null ? void 0 : web3wallet.on("session_request", onSessionRequest);
    return () => {
      web3wallet == null ? void 0 : web3wallet.off("session_request", onSessionRequest);
    };
  }, [isWalletInitialized, web3wallet]);
  const handleRejectBtn = async () => {
    setDialogOpen(false);
    const requestData = requestDataRef.current;
    if (requestData) {
      const { topic, id: id2 } = requestData;
      await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
    }
  };
  const handleAcceptBtn = async () => {
    const apiCaller = signMessageApiCallerRef.current;
    const requestData = requestDataRef.current;
    if (apiCaller && requestData) {
      setStage("confirming");
      const { topic, id: id2 } = requestData;
      const { response, success: success2, error: error3 } = await apiCaller();
      if (success2) {
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response }));
        setStage("accepted");
        setTimeout(() => {
          setDialogOpen(false);
          setStage("initial");
        }, 5e3);
      } else if (error3.aborted) {
        setStage("initial");
        setDialogOpen(false);
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
      } else {
        setStage("initial");
        const { errorMessage: errorMessage2 } = error3;
        alertUser(errorMessage2 ? errorMessage2 : t$1("pairing.error.text"));
      }
    }
  };
  if (!dialogContent || !dialogOpen) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCIncomingSignRequestDialog,
    {
      content: dialogContent,
      open: dialogOpen,
      stage,
      onAccept: handleAcceptBtn,
      onReject: handleRejectBtn
    }
  );
};
const setDarkTheme = (isDark) => {
  return apiPost("set-dark-theme", isDark);
};
const detectDarkTheme = () => {
  return apiGet("detect-dark-theme");
};
const DarkModeProvider = ({ children: children2 }) => {
  const [isDarkMode, setIsDarkMode] = reactExports.useState(false);
  const androidPrefersDarkMode = useMediaQuery("(prefers-color-scheme: dark)");
  const setAppTheme = reactExports.useCallback(() => {
    setDarkTheme(isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  }, [isDarkMode]);
  reactExports.useEffect(() => {
    getConfig().then((config) => {
      if (!!config.frontend && "darkmode" in config.frontend) {
        setIsDarkMode(config.frontend.darkmode);
        return;
      }
      if (runningInAndroid()) {
        setIsDarkMode(androidPrefersDarkMode);
      } else {
        detectDarkTheme().then(setIsDarkMode);
      }
    }).catch(console.error);
  }, [androidPrefersDarkMode]);
  reactExports.useEffect(() => {
    setAppTheme();
  }, [isDarkMode, setAppTheme]);
  const toggleDarkmode = (darkmode2) => {
    setIsDarkMode(darkmode2);
    getConfig().then(async (config) => {
      let preferredDarkMode;
      if (runningInAndroid()) {
        preferredDarkMode = androidPrefersDarkMode;
      } else {
        preferredDarkMode = await detectDarkTheme();
      }
      if (preferredDarkMode === darkmode2) {
        const { darkmode: darkmode22, ...frontend } = config.frontend;
        setConfig({
          frontend: {
            ...frontend,
            darkmode: void 0
          }
        });
      } else {
        setConfig({
          frontend: {
            ...config.frontend,
            darkmode: darkmode2
          }
        });
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeContext.Provider, { value: { isDarkMode, toggleDarkmode }, children: children2 });
};
const AppProvider = ({ children: children2 }) => {
  const [guideShown, setGuideShown] = reactExports.useState(false);
  const [guideExists, setGuideExists] = reactExports.useState(false);
  const [hideAmounts, setHideAmounts] = reactExports.useState(false);
  const [activeSidebar, setActiveSidebar] = reactExports.useState(false);
  const [sidebarStatus, setSidebarStatus] = reactExports.useState("");
  const toggleGuide = () => {
    setConfig({ frontend: { guideShown: !guideShown } });
    setGuideShown((prev2) => !prev2);
  };
  const toggleHideAmounts = () => {
    setConfig({ frontend: { hideAmounts: !hideAmounts } });
    setHideAmounts((prev2) => !prev2);
  };
  const toggleSidebar = () => {
    setActiveSidebar((prev2) => !prev2);
  };
  reactExports.useEffect(() => {
    getConfig().then(({ frontend }) => {
      if (frontend) {
        if (frontend.guideShown !== void 0) {
          setGuideShown(frontend.guideShown);
        }
        if (frontend.hideAmounts !== void 0) {
          setHideAmounts(frontend.hideAmounts);
        }
      } else {
        setGuideShown(true);
      }
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppContext.Provider,
    {
      value: {
        activeSidebar,
        toggleGuide,
        guideShown,
        guideExists,
        hideAmounts,
        sidebarStatus,
        setActiveSidebar,
        setGuideShown,
        setGuideExists,
        setSidebarStatus,
        setHideAmounts,
        toggleHideAmounts,
        toggleSidebar
      },
      children: children2
    }
  );
};
const WCWeb3WalletProvider = ({ children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [web3wallet, setWeb3wallet] = reactExports.useState();
  const [isWalletInitialized, setIsWalletInitialized] = reactExports.useState(false);
  const config = useLoad(getConfig);
  const hasUsedWC = config && config.frontend && config.frontend.hasUsedWalletConnect;
  const initializeWeb3Wallet = async () => {
    try {
      const { Core } = await __vitePreload(() => import("./index.es.js").then((n2) => n2.l), true ? [] : void 0, import.meta.url);
      const { Web3Wallet } = await __vitePreload(() => import("./index.es2.js"), true ? [] : void 0, import.meta.url);
      const core2 = new Core({
        projectId: "89733df088867a1a1bf644013addd6cc"
      });
      const wallet = await Web3Wallet.init({
        core: core2,
        metadata: {
          name: "BitBox",
          description: "BitBox02 hardware wallet",
          url: "https://bitbox.swiss",
          icons: ["https://bitbox.swiss/assets/images/logos/dbb-logo.png"]
        }
      });
      setWeb3wallet(wallet);
      setIsWalletInitialized(true);
    } catch (err) {
      console.log("Error for initializing", err);
    }
  };
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized && hasUsedWC) {
      initializeWeb3Wallet();
    }
  }, [isWalletInitialized, web3wallet, hasUsedWC]);
  const pair = async (params) => {
    if (!web3wallet) {
      return;
    }
    try {
      const { uri } = params;
      const topic = getTopicFromURI(uri);
      const hasEverBeenRejected = pairingHasEverBeenRejected(topic, web3wallet);
      if (hasEverBeenRejected) {
        throw new Error(t2("walletConnect.useNewUri"));
      }
      await (web3wallet == null ? void 0 : web3wallet.core.pairing.pair({ uri }));
      setConfig({ frontend: { hasUsedWalletConnect: true } });
    } catch (e3) {
      console.error(`Wallet connect attempt to pair error ${e3}`);
      if (e3.message.includes("Pairing already exists")) {
        throw new Error(t2("walletConnect.useNewUri"));
      }
      throw new Error(e3.message);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCWeb3WalletContext.Provider,
    {
      value: {
        initializeWeb3Wallet,
        isWalletInitialized,
        web3wallet,
        pair
      },
      children: children2
    }
  );
};
const RatesProvider = ({ children: children2 }) => {
  const [defaultCurrency2, setDefaultCurrency] = reactExports.useState("USD");
  const [activeCurrencies, setActiveCurrencies] = reactExports.useState(["USD", "EUR", "CHF"]);
  const [btcUnit, setBtcUnit2] = reactExports.useState("default");
  reactExports.useEffect(() => {
    updateRatesConfig();
  }, []);
  const updateRatesConfig = async () => {
    var _a, _b, _c;
    const appConf = await getConfig();
    if ((_a = appConf.backend) == null ? void 0 : _a.mainFiat) {
      setDefaultCurrency(appConf.backend.mainFiat);
    }
    if (((_b = appConf.backend) == null ? void 0 : _b.fiatList) && ((_c = appConf.backend) == null ? void 0 : _c.btcUnit)) {
      setActiveCurrencies(appConf.backend.fiatList);
      setBtcUnit2(appConf.backend.btcUnit);
    }
  };
  const rotateFiat = () => {
    const index2 = activeCurrencies.indexOf(defaultCurrency2);
    const fiat2 = activeCurrencies[(index2 + 1) % activeCurrencies.length];
    updateDefaultFiat(fiat2);
  };
  const updateDefaultFiat = (fiat2) => {
    if (!activeCurrencies.includes(fiat2)) {
      selectFiat(fiat2);
    }
    setDefaultCurrency(fiat2);
    setConfig({ backend: { mainFiat: fiat2 } });
  };
  const selectFiat = async (fiat2) => {
    const selected2 = [...activeCurrencies, fiat2];
    await setConfig({ backend: { fiatList: selected2 } });
    handleChangeSelectedFiat(selected2);
  };
  const unselectFiat = async (fiat2) => {
    const selected2 = activeCurrencies.filter((item2) => !equal(item2, fiat2));
    await setConfig({ backend: { fiatList: selected2 } });
    handleChangeSelectedFiat(selected2);
  };
  const handleChangeSelectedFiat = (selected2) => {
    setActiveCurrencies(selected2);
    reinitializeAccounts();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RatesContext.Provider,
    {
      value: {
        defaultCurrency: defaultCurrency2,
        activeCurrencies,
        btcUnit,
        rotateFiat,
        selectFiat,
        updateDefaultFiat,
        updateRatesConfig,
        unselectFiat
      },
      children: children2
    }
  );
};
const Providers = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RatesProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WCWeb3WalletProvider, { children: children2 }) }) }) });
};
const App = () => {
  const { t: t2 } = useTranslation();
  const navigate2 = useNavigate();
  const accounts = useDefault(useSync(getAccounts, syncAccountsList), []);
  const devices = useDefault(useSync(getDeviceList, syncDeviceList), {});
  const prevDevices = usePrevious(devices);
  reactExports.useEffect(() => {
    return syncNewTxs((meta) => {
      notifyUser(t2("notification.newTxs", {
        count: meta.count,
        accountName: meta.accountName
      }));
    });
  }, [t2]);
  const maybeRoute = reactExports.useCallback(() => {
    const currentURL = window.location.pathname;
    const isIndex = currentURL === "/" || currentURL === "/index.html" || currentURL === "/android_asset/web/index.html";
    const inAccounts = currentURL.startsWith("/account/");
    if (isIndex && currentURL !== "/" && (!accounts || accounts.length === 0)) {
      navigate2("/");
      return;
    }
    if (accounts.length === 0 && (currentURL.startsWith("/account-summary") || currentURL.startsWith("/add-account") || currentURL.startsWith("/settings/manage-accounts"))) {
      navigate2("/");
      return;
    }
    if (Object.keys(devices).length === 0 && currentURL.startsWith("/settings/device-settings/")) {
      navigate2("/");
      return;
    }
    if (inAccounts && !accounts.some((account2) => currentURL.startsWith("/account/" + account2.code))) {
      navigate2("/");
      return;
    }
    if (isIndex && accounts.length) {
      navigate2("/account-summary");
      return;
    }
    if (accounts.length === 0 && currentURL.startsWith("/buy/")) {
      navigate2("/");
      return;
    }
    if (accounts.length === 0 && currentURL.startsWith("/bitsurance/")) {
      navigate2("/");
      return;
    }
  }, [accounts, devices, navigate2]);
  reactExports.useEffect(() => {
    const oldDeviceIDList = Object.keys(prevDevices || {});
    const newDeviceIDList = Object.keys(devices);
    if (newDeviceIDList.length > 0 && newDeviceIDList[0] !== oldDeviceIDList[0]) {
      const productName = devices[newDeviceIDList[0]];
      if (productName === "bitbox" || productName === "bitbox02-bootloader") {
        navigate2(`settings/device-settings/${newDeviceIDList[0]}`);
        return;
      }
    }
    maybeRoute();
  }, [devices, maybeRoute, navigate2, prevDevices]);
  const devicesKey = (prefix2) => {
    return prefix2 + ":" + JSON.stringify(devices, Object.keys(devices).sort());
  };
  const deviceIDs = Object.keys(devices);
  const activeAccounts = accounts.filter((acct) => acct.active);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedApp, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Providers, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Darkmode, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRequired, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Sidebar,
        {
          accounts: activeAccounts,
          deviceIDs
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "appContent flex flex-column flex-1", style: { minWidth: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Update, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox01" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox02" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDataWarning, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(WCSigningRequest, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(translateHOC, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KeystoreConnectPrompt, {}),
        Object.entries(devices).map(([deviceID, productName]) => {
          if (productName === "bitbox02") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Wizard,
              {
                deviceID
              }
            ) }, deviceID);
          }
          return null;
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AppRouter,
          {
            accounts,
            activeAccounts,
            deviceIDs,
            devices,
            devicesKey
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(RouterWatcher, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Confirm, {})
    ] })
  ] }) });
};
const index = "";
const rootEl = document.getElementById("root");
const root = createRoot(rootEl);
root.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nextProvider, { i18n: instance, children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) }) }) })
);
export {
  Vn as $,
  Bt as A,
  B,
  ft as C,
  D,
  require$$0 as E,
  Ft2 as F,
  Gt2 as G,
  Ht2 as H,
  binary as I,
  Jt as J,
  Kn as K,
  Ln as L,
  wipe$1 as M,
  N,
  random as O,
  fromString as P,
  Qn as Q,
  toString as R,
  concat as S,
  rt as T,
  U,
  ot as V,
  Wt2 as W,
  Xt2 as X,
  Yt2 as Y,
  kn2 as Z,
  _23 as _,
  getAugmentedNamespace as a,
  Mn2 as a0,
  Te as a1,
  qn as a2,
  xn2 as a3,
  Hn as a4,
  Fn as a5,
  ee as a6,
  $ as a7,
  vt2 as a8,
  Et as a9,
  ut as aa,
  k as ab,
  Jn as ac,
  er as ad,
  Xn as ae,
  nr as af,
  Vt as ag,
  Mt$1 as ah,
  It as ai,
  wt as aj,
  lt2 as ak,
  dt as al,
  C as am,
  te as an,
  p as ao,
  cjs$2 as b,
  commonjsGlobal as c,
  at2 as d,
  gt as e,
  Dt as f,
  getDefaultExportFromCjs as g,
  ht2 as h,
  Lt as i,
  jt2 as j,
  kt$1 as k,
  dn2 as l,
  mt2 as m,
  h as n,
  ln as o,
  pt2 as p,
  qt2 as q,
  require$$0$1 as r,
  sha256 as s,
  tr as t,
  un as u,
  Kt2 as v,
  w,
  xt as x,
  yt as y,
  zt as z
};
