var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: !0, configurable: !0, writable: !0, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: !0 });
var __publicField = (obj, key, value) => (__defNormalProp(obj, typeof key != "symbol" ? key + "" : key, value), value);
function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e2 = m2[i];
    if (typeof e2 != "string" && !Array.isArray(e2)) {
      for (const k2 in e2)
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          d2 && Object.defineProperty(n2, k2, d2.get ? d2 : {
            enumerable: !0,
            get: () => e2[k2]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
__name(_mergeNamespaces, "_mergeNamespaces");
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = /* @__PURE__ */ __name(function a3() {
      return this instanceof a3 ? Reflect.construct(f2, arguments, this.constructor) : f2.apply(this, arguments);
    }, "a");
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  return Object.defineProperty(a2, "__esModule", { value: !0 }), Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: !0,
      get: function() {
        return n2[k2];
      }
    });
  }), a2;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var jsxRuntime = { exports: {} }, reactJsxRuntime_production_min = {}, react = { exports: {} }, react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$5(a2) {
  return a2 === null || typeof a2 != "object" ? null : (a2 = z$3 && a2[z$3] || a2["@@iterator"], typeof a2 == "function" ? a2 : null);
}
__name(A$5, "A$5");
var B$3 = { isMounted: function() {
  return !1;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$2(a2, b2, e2) {
  this.props = a2, this.context = b2, this.refs = D$3, this.updater = e2 || B$3;
}
__name(E$2, "E$2");
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if (typeof a2 != "object" && typeof a2 != "function" && a2 != null)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
__name(F$2, "F$2");
F$2.prototype = E$2.prototype;
function G$3(a2, b2, e2) {
  this.props = a2, this.context = b2, this.refs = D$3, this.updater = e2 || B$3;
}
__name(G$3, "G$3");
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$3(H$3, E$2.prototype);
H$3.isPureReactComponent = !0;
var I$2 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: !0, ref: !0, __self: !0, __source: !0 };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (b2 != null)
    for (d2 in b2.ref !== void 0 && (h2 = b2.ref), b2.key !== void 0 && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (g2 === 1)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      c2[d2] === void 0 && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
__name(M$2, "M$2");
function N$3(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
__name(N$3, "N$3");
function O$3(a2) {
  return typeof a2 == "object" && a2 !== null && a2.$$typeof === l$3;
}
__name(O$3, "O$3");
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
__name(escape$1, "escape$1");
var P$2 = /\/+/g;
function Q$3(a2, b2) {
  return typeof a2 == "object" && a2 !== null && a2.key != null ? escape$1("" + a2.key) : b2.toString(36);
}
__name(Q$3, "Q$3");
function R$2(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  (k2 === "undefined" || k2 === "boolean") && (a2 = null);
  var h2 = !1;
  if (a2 === null)
    h2 = !0;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = !0;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$3:
          case n$2:
            h2 = !0;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = d2 === "" ? "." + Q$3(h2, 0) : d2, I$2(c2) ? (e2 = "", a2 != null && (e2 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
      return a3;
    })) : c2 != null && (O$3(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  if (h2 = 0, d2 = d2 === "" ? "." : d2 + ":", I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$2(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$5(a2), typeof f2 == "function")
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if (k2 === "object")
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + (b2 === "[object Object]" ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
__name(R$2, "R$2");
function S$3(a2, b2, e2) {
  if (a2 == null)
    return a2;
  var d2 = [], c2 = 0;
  return R$2(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  }), d2;
}
__name(S$3, "S$3");
function T$3(a2) {
  if (a2._status === -1) {
    var b2 = a2._result;
    b2 = b2(), b2.then(function(b3) {
      (a2._status === 0 || a2._status === -1) && (a2._status = 1, a2._result = b3);
    }, function(b3) {
      (a2._status === 0 || a2._status === -1) && (a2._status = 2, a2._result = b3);
    }), a2._status === -1 && (a2._status = 0, a2._result = b2);
  }
  if (a2._status === 1)
    return a2._result.default;
  throw a2._result;
}
__name(T$3, "T$3");
var U$3 = { current: null }, V$3 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e2) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  return S$3(a2, function() {
    b2++;
  }), b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (a2 == null)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (b2 != null) {
    if (b2.ref !== void 0 && (k2 = b2.ref, h2 = K$2.current), b2.key !== void 0 && (c2 = "" + b2.key), a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = b2[f2] === void 0 && g2 !== void 0 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (f2 === 1)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  return a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, a2.Provider = { $$typeof: t$2, _context: a2 }, a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  return b2.type = a2, b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$3 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: b2 === void 0 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$3.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$3.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$3.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
react.exports = react_production_min;
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports), React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: !0, ref: !0, __self: !0, __source: !0 };
function q$2(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  g2 !== void 0 && (e2 = "" + g2), a2.key !== void 0 && (e2 = "" + a2.key), a2.ref !== void 0 && (h2 = a2.ref);
  for (b2 in a2)
    m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      d2[b2] === void 0 && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
}
__name(q$2, "q$2");
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports, reactDom = { exports: {} }, reactDom_production_min = {}, scheduler = { exports: {} }, scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  __name(f2, "f");
  function h2(a2) {
    return a2.length === 0 ? null : a2[0];
  }
  __name(h2, "h");
  function k2(a2) {
    if (a2.length === 0)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  __name(k2, "k");
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return c2 !== 0 ? c2 : a2.id - b2.id;
  }
  if (__name(g2, "g"), typeof performance == "object" && typeof performance.now == "function") {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = !1, A2 = !1, B2 = !1, D2 = typeof setTimeout == "function" ? setTimeout : null, E2 = typeof clearTimeout == "function" ? clearTimeout : null, F2 = typeof setImmediate < "u" ? setImmediate : null;
  typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); b2 !== null; ) {
      if (b2.callback === null)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  __name(G2, "G");
  function H2(a2) {
    if (B2 = !1, G2(a2), !A2)
      if (h2(r2) !== null)
        A2 = !0, I2(J2);
      else {
        var b2 = h2(t2);
        b2 !== null && K2(H2, b2.startTime - a2);
      }
  }
  __name(H2, "H");
  function J2(a2, b2) {
    A2 = !1, B2 && (B2 = !1, E2(L2), L2 = -1), z2 = !0;
    var c2 = y2;
    try {
      for (G2(b2), v2 = h2(r2); v2 !== null && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if (typeof d2 == "function") {
          v2.callback = null, y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now(), typeof e2 == "function" ? v2.callback = e2 : v2 === h2(r2) && k2(r2), G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (v2 !== null)
        var w2 = !0;
      else {
        var m2 = h2(t2);
        m2 !== null && K2(H2, m2.startTime - b2), w2 = !1;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = !1;
    }
  }
  __name(J2, "J");
  var N2 = !1, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return !(exports.unstable_now() - Q2 < P2);
  }
  __name(M2, "M");
  function R2() {
    if (O2 !== null) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = !0;
      try {
        b2 = O2(!0, a2);
      } finally {
        b2 ? S2() : (N2 = !1, O2 = null);
      }
    } else
      N2 = !1;
  }
  __name(R2, "R");
  var S2;
  if (typeof F2 == "function")
    S2 = /* @__PURE__ */ __name(function() {
      F2(R2);
    }, "S");
  else if (typeof MessageChannel < "u") {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2, S2 = /* @__PURE__ */ __name(function() {
      U2.postMessage(null);
    }, "S");
  } else
    S2 = /* @__PURE__ */ __name(function() {
      D2(R2, 0);
    }, "S");
  function I2(a2) {
    O2 = a2, N2 || (N2 = !0, S2());
  }
  __name(I2, "I");
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  __name(K2, "K"), exports.unstable_IdlePriority = 5, exports.unstable_ImmediatePriority = 1, exports.unstable_LowPriority = 4, exports.unstable_NormalPriority = 3, exports.unstable_Profiling = null, exports.unstable_UserBlockingPriority = 2, exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  }, exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = !0, I2(J2));
  }, exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  }, exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  }, exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  }, exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  }, exports.unstable_pauseExecution = function() {
  }, exports.unstable_requestPaint = function() {
  }, exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  }, exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    switch (typeof c2 == "object" && c2 !== null ? (c2 = c2.delay, c2 = typeof c2 == "number" && 0 < c2 ? d2 + c2 : d2) : c2 = d2, a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    return e2 = c2 + e2, a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 }, c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), h2(r2) === null && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = !0, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = !0, I2(J2))), a2;
  }, exports.unstable_shouldYield = M2, exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
__name(p$3, "p$3");
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2), ha(a2 + "Capture", b2);
}
__name(fa, "fa");
function ha(a2, b2) {
  for (ea[a2] = b2, a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
__name(ha, "ha");
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  return ja.call(ma, a2) ? !0 : ja.call(la, a2) ? !1 : ka.test(a2) ? ma[a2] = !0 : (la[a2] = !0, !1);
}
__name(oa, "oa");
function pa(a2, b2, c2, d2) {
  if (c2 !== null && c2.type === 0)
    return !1;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return !0;
    case "boolean":
      return d2 ? !1 : c2 !== null ? !c2.acceptsBooleans : (a2 = a2.toLowerCase().slice(0, 5), a2 !== "data-" && a2 !== "aria-");
    default:
      return !1;
  }
}
__name(pa, "pa");
function qa(a2, b2, c2, d2) {
  if (b2 === null || typeof b2 > "u" || pa(a2, b2, c2, d2))
    return !0;
  if (d2)
    return !1;
  if (c2 !== null)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return b2 === !1;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return !1;
}
__name(qa, "qa");
function v$2(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = b2 === 2 || b2 === 3 || b2 === 4, this.attributeName = d2, this.attributeNamespace = e2, this.mustUseProperty = c2, this.propertyName = a2, this.type = b2, this.sanitizeURL = f2, this.removeEmptyString = g2;
}
__name(v$2, "v$2");
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 0, !1, a2, null, !1, !1);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$2(b2, 1, !1, a2[1], null, !1, !1);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, !1, a2.toLowerCase(), null, !1, !1);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, !1, a2, null, !1, !1);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, !1, a2.toLowerCase(), null, !1, !1);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, !0, a2, null, !1, !1);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 4, !1, a2, null, !1, !1);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 6, !1, a2, null, !1, !1);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 5, !1, a2.toLowerCase(), null, !1, !1);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
__name(sa, "sa");
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$2[b2] = new v$2(b2, 1, !1, a2, null, !1, !1);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, !1, a2, "http://www.w3.org/1999/xlink", !1, !1);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, !1, a2, "http://www.w3.org/XML/1998/namespace", !1, !1);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, !1, a2.toLowerCase(), null, !1, !1);
});
z$2.xlinkHref = new v$2("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, !1, a2.toLowerCase(), null, !0, !0);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  (e2 !== null ? e2.type !== 0 : d2 || !(2 < b2.length) || b2[0] !== "o" && b2[0] !== "O" || b2[1] !== "n" && b2[1] !== "N") && (qa(b2, c2, e2, d2) && (c2 = null), d2 || e2 === null ? oa(b2) && (c2 === null ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = c2 === null ? e2.type === 3 ? !1 : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, c2 === null ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = e2 === 3 || e2 === 4 && c2 === !0 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2))));
}
__name(ta, "ta");
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy"), Ia = Symbol.for("react.offscreen"), Ja = Symbol.iterator;
function Ka(a2) {
  return a2 === null || typeof a2 != "object" ? null : (a2 = Ja && a2[Ja] || a2["@@iterator"], typeof a2 == "function" ? a2 : null);
}
__name(Ka, "Ka");
var A$4 = Object.assign, La;
function Ma(a2) {
  if (La === void 0)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return `
` + La + a2;
}
__name(Ma, "Ma");
var Na = !1;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = !0;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = /* @__PURE__ */ __name(function() {
        throw Error();
      }, "b"), Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && typeof l2.stack == "string") {
      for (var e2 = l2.stack.split(`
`), f2 = d2.stack.split(`
`), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1)
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = `
` + e2[g2].replace(" at new ", " at ");
                return a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName)), k2;
              }
            while (1 <= g2 && 0 <= h2);
          break;
        }
    }
  } finally {
    Na = !1, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
__name(Oa, "Oa");
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, !1), a2;
    case 11:
      return a2 = Oa(a2.type.render, !1), a2;
    case 1:
      return a2 = Oa(a2.type, !0), a2;
    default:
      return "";
  }
}
__name(Pa, "Pa");
function Qa(a2) {
  if (a2 == null)
    return null;
  if (typeof a2 == "function")
    return a2.displayName || a2.name || null;
  if (typeof a2 == "string")
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if (typeof a2 == "object")
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        return a2 = a2.displayName, a2 || (a2 = b2.displayName || b2.name || "", a2 = a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef"), a2;
      case Ga:
        return b2 = a2.displayName || null, b2 !== null ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload, a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch {
        }
    }
  return null;
}
__name(Qa, "Qa");
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || (a2 !== "" ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if (typeof b2 == "function")
        return b2.displayName || b2.name || null;
      if (typeof b2 == "string")
        return b2;
  }
  return null;
}
__name(Ra, "Ra");
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
__name(Sa, "Sa");
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && a2.toLowerCase() === "input" && (b2 === "checkbox" || b2 === "radio");
}
__name(Ta, "Ta");
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && typeof c2 < "u" && typeof c2.get == "function" && typeof c2.set == "function") {
    var e2 = c2.get, f2 = c2.set;
    return Object.defineProperty(a2, b2, { configurable: !0, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3, f2.call(this, a3);
    } }), Object.defineProperty(a2, b2, { enumerable: c2.enumerable }), { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null, delete a2[b2];
    } };
  }
}
__name(Ua, "Ua");
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
__name(Va, "Va");
function Wa(a2) {
  if (!a2)
    return !1;
  var b2 = a2._valueTracker;
  if (!b2)
    return !0;
  var c2 = b2.getValue(), d2 = "";
  return a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value), a2 = d2, a2 !== c2 ? (b2.setValue(a2), !0) : !1;
}
__name(Wa, "Wa");
function Xa(a2) {
  if (a2 = a2 || (typeof document < "u" ? document : void 0), typeof a2 > "u")
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch {
    return a2.body;
  }
}
__name(Xa, "Xa");
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c2 ?? a2._wrapperState.initialChecked });
}
__name(Ya, "Ya");
function Za(a2, b2) {
  var c2 = b2.defaultValue == null ? "" : b2.defaultValue, d2 = b2.checked != null ? b2.checked : b2.defaultChecked;
  c2 = Sa(b2.value != null ? b2.value : c2), a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: b2.type === "checkbox" || b2.type === "radio" ? b2.checked != null : b2.value != null };
}
__name(Za, "Za");
function ab(a2, b2) {
  b2 = b2.checked, b2 != null && ta(a2, "checked", b2, !1);
}
__name(ab, "ab");
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (c2 != null)
    d2 === "number" ? (c2 === 0 && a2.value === "" || a2.value != c2) && (a2.value = "" + c2) : a2.value !== "" + c2 && (a2.value = "" + c2);
  else if (d2 === "submit" || d2 === "reset") {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue)), b2.checked == null && b2.defaultChecked != null && (a2.defaultChecked = !!b2.defaultChecked);
}
__name(bb, "bb");
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!(d2 !== "submit" && d2 !== "reset" || b2.value !== void 0 && b2.value !== null))
      return;
    b2 = "" + a2._wrapperState.initialValue, c2 || b2 === a2.value || (a2.value = b2), a2.defaultValue = b2;
  }
  c2 = a2.name, c2 !== "" && (a2.name = ""), a2.defaultChecked = !!a2._wrapperState.initialChecked, c2 !== "" && (a2.name = c2);
}
__name(db, "db");
function cb(a2, b2, c2) {
  (b2 !== "number" || Xa(a2.ownerDocument) !== a2) && (c2 == null ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2));
}
__name(cb, "cb");
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  if (a2 = a2.options, b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = !0;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = !0);
  } else {
    for (c2 = "" + Sa(c2), b2 = null, e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = !0, d2 && (a2[e2].defaultSelected = !0);
        return;
      }
      b2 !== null || a2[e2].disabled || (b2 = a2[e2]);
    }
    b2 !== null && (b2.selected = !0);
  }
}
__name(fb, "fb");
function gb(a2, b2) {
  if (b2.dangerouslySetInnerHTML != null)
    throw Error(p$3(91));
  return A$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
__name(gb, "gb");
function hb(a2, b2) {
  var c2 = b2.value;
  if (c2 == null) {
    if (c2 = b2.children, b2 = b2.defaultValue, c2 != null) {
      if (b2 != null)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    b2 == null && (b2 = ""), c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
__name(hb, "hb");
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  c2 != null && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), b2.defaultValue == null && a2.defaultValue !== c2 && (a2.defaultValue = c2)), d2 != null && (a2.defaultValue = "" + d2);
}
__name(ib, "ib");
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && b2 !== "" && b2 !== null && (a2.value = b2);
}
__name(jb, "jb");
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
__name(kb, "kb");
function lb(a2, b2) {
  return a2 == null || a2 === "http://www.w3.org/1999/xhtml" ? kb(b2) : a2 === "http://www.w3.org/2000/svg" && b2 === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a2;
}
__name(lb, "lb");
var mb, nb = function(a2) {
  return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if (a2.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>", b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && c2.nodeType === 3) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
__name(ob, "ob");
var pb = {
  animationIterationCount: !0,
  aspectRatio: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridArea: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1), pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return b2 == null || typeof b2 == "boolean" || b2 === "" ? "" : c2 || typeof b2 != "number" || b2 === 0 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
__name(rb, "rb");
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = c2.indexOf("--") === 0, e2 = rb(c2, b2[c2], d2);
      c2 === "float" && (c2 = "cssFloat"), d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
__name(sb, "sb");
var tb = A$4({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (b2.children != null || b2.dangerouslySetInnerHTML != null))
      throw Error(p$3(137, a2));
    if (b2.dangerouslySetInnerHTML != null) {
      if (b2.children != null)
        throw Error(p$3(60));
      if (typeof b2.dangerouslySetInnerHTML != "object" || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (b2.style != null && typeof b2.style != "object")
      throw Error(p$3(62));
  }
}
__name(ub, "ub");
function vb(a2, b2) {
  if (a2.indexOf("-") === -1)
    return typeof b2.is == "string";
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;
    default:
      return !0;
  }
}
__name(vb, "vb");
var wb = null;
function xb(a2) {
  return a2 = a2.target || a2.srcElement || window, a2.correspondingUseElement && (a2 = a2.correspondingUseElement), a2.nodeType === 3 ? a2.parentNode : a2;
}
__name(xb, "xb");
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if (typeof yb != "function")
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
__name(Bb, "Bb");
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
__name(Eb, "Eb");
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    if (Ab = zb = null, Bb(a2), b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
__name(Fb, "Fb");
function Gb(a2, b2) {
  return a2(b2);
}
__name(Gb, "Gb");
function Hb() {
}
__name(Hb, "Hb");
var Ib = !1;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = !0;
  try {
    return Gb(a2, b2, c2);
  } finally {
    Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb());
  }
}
__name(Jb, "Jb");
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (c2 === null)
    return null;
  var d2 = Db(c2);
  if (d2 === null)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !(a2 === "button" || a2 === "input" || a2 === "select" || a2 === "textarea")), a2 = !d2;
        break a;
      default:
        a2 = !1;
    }
  if (a2)
    return null;
  if (c2 && typeof c2 != "function")
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
__name(Kb, "Kb");
var Lb = !1;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = !0;
    } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
  } catch {
    Lb = !1;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
__name(Nb, "Nb");
var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function(a2) {
  Ob = !0, Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = !1, Pb = null, Nb.apply(Sb, arguments);
}
__name(Tb, "Tb");
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  if (Tb.apply(this, arguments), Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = !1, Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = !0, Rb = l2);
  }
}
__name(Ub, "Ub");
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, b2.flags & 4098 && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return b2.tag === 3 ? c2 : null;
}
__name(Vb, "Vb");
function Wb(a2) {
  if (a2.tag === 13) {
    var b2 = a2.memoizedState;
    if (b2 === null && (a2 = a2.alternate, a2 !== null && (b2 = a2.memoizedState)), b2 !== null)
      return b2.dehydrated;
  }
  return null;
}
__name(Wb, "Wb");
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
__name(Xb, "Xb");
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    if (b2 = Vb(a2), b2 === null)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (e2 === null)
      break;
    var f2 = e2.alternate;
    if (f2 === null) {
      if (d2 = e2.return, d2 !== null) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = !1, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = !0, c2 = e2, d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = !0, d2 = e2, c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = !0, c2 = f2, d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = !0, d2 = f2, c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (c2.tag !== 3)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
__name(Yb, "Yb");
function Zb(a2) {
  return a2 = Yb(a2), a2 !== null ? $b(a2) : null;
}
__name(Zb, "Zb");
function $b(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2;
  for (a2 = a2.child; a2 !== null; ) {
    var b2 = $b(a2);
    if (b2 !== null)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
__name($b, "$b");
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && typeof lc.onCommitFiberRoot == "function")
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, (a2.current.flags & 128) === 128);
    } catch {
    }
}
__name(mc, "mc");
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  return a2 >>>= 0, a2 === 0 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
__name(nc, "nc");
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
__name(tc, "tc");
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (c2 === 0)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (g2 !== 0) {
    var h2 = g2 & ~e2;
    h2 !== 0 ? d2 = tc(h2) : (f2 &= g2, f2 !== 0 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, g2 !== 0 ? d2 = tc(g2) : f2 !== 0 && (d2 = tc(f2));
  if (d2 === 0)
    return 0;
  if (b2 !== 0 && b2 !== d2 && !(b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || e2 === 16 && (f2 & 4194240) !== 0))
    return b2;
  if (d2 & 4 && (d2 |= c2 & 16), b2 = a2.entangledLanes, b2 !== 0)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
__name(uc, "uc");
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
__name(vc, "vc");
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    k2 === -1 ? (!(h2 & c2) || h2 & d2) && (e2[g2] = vc(h2, b2)) : k2 <= b2 && (a2.expiredLanes |= h2), f2 &= ~h2;
  }
}
__name(wc, "wc");
function xc(a2) {
  return a2 = a2.pendingLanes & -1073741825, a2 !== 0 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
__name(xc, "xc");
function yc() {
  var a2 = rc;
  return rc <<= 1, !(rc & 4194240) && (rc = 64), a2;
}
__name(yc, "yc");
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
__name(zc, "zc");
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2, b2 !== 536870912 && (a2.suspendedLanes = 0, a2.pingedLanes = 0), a2 = a2.eventTimes, b2 = 31 - oc(b2), a2[b2] = c2;
}
__name(Ac, "Ac");
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2, a2.suspendedLanes = 0, a2.pingedLanes = 0, a2.expiredLanes &= b2, a2.mutableReadLanes &= b2, a2.entangledLanes &= b2, b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0, d2[e2] = -1, a2[e2] = -1, c2 &= ~f2;
  }
}
__name(Bc, "Bc");
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2), c2 &= ~e2;
  }
}
__name(Cc, "Cc");
var C$2 = 0;
function Dc(a2) {
  return a2 &= -a2, 1 < a2 ? 4 < a2 ? a2 & 268435455 ? 16 : 536870912 : 4 : 1;
}
__name(Dc, "Dc");
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
__name(Sc, "Sc");
function Tc(a2, b2, c2, d2, e2, f2) {
  return a2 === null || a2.nativeEvent !== f2 ? (a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, b2 !== null && (b2 = Cb(b2), b2 !== null && Fc(b2)), a2) : (a2.eventSystemFlags |= d2, b2 = a2.targetContainers, e2 !== null && b2.indexOf(e2) === -1 && b2.push(e2), a2);
}
__name(Tc, "Tc");
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), !0;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), !0;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), !0;
    case "pointerover":
      var f2 = e2.pointerId;
      return Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2)), !0;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), !0;
  }
  return !1;
}
__name(Uc, "Uc");
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (b2 !== null) {
    var c2 = Vb(b2);
    if (c2 !== null) {
      if (b2 = c2.tag, b2 === 13) {
        if (b2 = Wb(c2), b2 !== null) {
          a2.blockedOn = b2, Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (b2 === 3 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = c2.tag === 3 ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
__name(Vc, "Vc");
function Xc(a2) {
  if (a2.blockedOn !== null)
    return !1;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (c2 === null) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2, c2.target.dispatchEvent(d2), wb = null;
    } else
      return b2 = Cb(c2), b2 !== null && Fc(b2), a2.blockedOn = c2, !1;
    b2.shift();
  }
  return !0;
}
__name(Xc, "Xc");
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
__name(Zc, "Zc");
function $c() {
  Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
}
__name($c, "$c");
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
__name(ad, "ad");
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (__name(b2, "b"), 0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  for (Lc !== null && ad(Lc, a2), Mc !== null && ad(Mc, a2), Nc !== null && ad(Nc, a2), Oc.forEach(b2), Pc.forEach(b2), c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], c2.blockedOn === null); )
    Vc(c2), c2.blockedOn === null && Qc.shift();
}
__name(bd, "bd");
var cd = ua.ReactCurrentBatchConfig, dd = !0;
function ed(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
__name(ed, "ed");
function gd(a2, b2, c2, d2) {
  var e2 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e2, cd.transition = f2;
  }
}
__name(gd, "gd");
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (e2 === null)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; e2 !== null; ) {
        var f2 = Cb(e2);
        if (f2 !== null && Ec(f2), f2 = Yc(a2, b2, c2, d2), f2 === null && hd(a2, b2, d2, id, c2), f2 === e2)
          break;
        e2 = f2;
      }
      e2 !== null && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
__name(fd, "fd");
var id = null;
function Yc(a2, b2, c2, d2) {
  if (id = null, a2 = xb(d2), a2 = Wc(a2), a2 !== null)
    if (b2 = Vb(a2), b2 === null)
      a2 = null;
    else if (c2 = b2.tag, c2 === 13) {
      if (a2 = Wb(b2), a2 !== null)
        return a2;
      a2 = null;
    } else if (c2 === 3) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return b2.tag === 3 ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  return id = a2, null;
}
__name(Yc, "Yc");
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
__name(jd, "jd");
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
__name(nd, "nd");
function od(a2) {
  var b2 = a2.keyCode;
  return "charCode" in a2 ? (a2 = a2.charCode, a2 === 0 && b2 === 13 && (a2 = 13)) : a2 = b2, a2 === 10 && (a2 = 13), 32 <= a2 || a2 === 13 ? a2 : 0;
}
__name(od, "od");
function pd() {
  return !0;
}
__name(pd, "pd");
function qd() {
  return !1;
}
__name(qd, "qd");
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3, this._targetInst = e2, this.type = d2, this.nativeEvent = f2, this.target = g2, this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    return this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this;
  }
  return __name(b2, "b"), A$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = !0;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : typeof a3.returnValue != "unknown" && (a3.returnValue = !1), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : typeof a3.cancelBubble != "unknown" && (a3.cancelBubble = !0), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd }), b2;
}
__name(rd, "rd");
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return a2.relatedTarget === void 0 ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  return "movementX" in a2 ? a2.movementX : (a2 !== yd && (yd && a2.type === "mousemove" ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2), wd);
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : !1;
}
__name(Pd, "Pd");
function zd() {
  return Pd;
}
__name(zd, "zd");
var Qd = A$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if (b2 !== "Unidentified")
      return b2;
  }
  return a2.type === "keypress" ? (a2 = od(a2), a2 === 13 ? "Enter" : String.fromCharCode(a2)) : a2.type === "keydown" || a2.type === "keyup" ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return a2.type === "keypress" ? od(a2) : 0;
}, keyCode: function(a2) {
  return a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
}, which: function(a2) {
  return a2.type === "keypress" ? od(a2) : a2.type === "keydown" || a2.type === "keyup" ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$2 || be$1 && 8 < be$1 && 11 >= be$1), ee$2 = String.fromCharCode(32), fe$1 = !1;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return $d.indexOf(b2.keyCode) !== -1;
    case "keydown":
      return b2.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
      return !0;
    default:
      return !1;
  }
}
__name(ge$1, "ge$1");
function he$1(a2) {
  return a2 = a2.detail, typeof a2 == "object" && "data" in a2 ? a2.data : null;
}
__name(he$1, "he$1");
var ie$2 = !1;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      return b2.which !== 32 ? null : (fe$1 = !0, ee$2);
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$1 ? null : a2;
    default:
      return null;
  }
}
__name(je, "je");
function ke$2(a2, b2) {
  if (ie$2)
    return a2 === "compositionend" || !ae$2 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = !1, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && b2.locale !== "ko" ? null : b2.data;
    default:
      return null;
  }
}
__name(ke$2, "ke$2");
var le$1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 === "input" ? !!le$1[a2.type] : b2 === "textarea";
}
__name(me$1, "me$1");
function ne$1(a2, b2, c2, d2) {
  Eb(d2), b2 = oe$2(b2, "onChange"), 0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
__name(ne$1, "ne$1");
var pe$1 = null, qe$1 = null;
function re$2(a2) {
  se$2(a2, 0);
}
__name(re$2, "re$2");
function te$2(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
__name(te$2, "te$2");
function ve$1(a2, b2) {
  if (a2 === "change")
    return b2;
}
__name(ve$1, "ve$1");
var we$1 = !1;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;"), ye$1 = typeof ze$1.oninput == "function";
    }
    xe$1 = ye$1;
  } else
    xe$1 = !1;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
__name(Ae$1, "Ae$1");
function Be$1(a2) {
  if (a2.propertyName === "value" && te$2(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2)), Jb(re$2, b2);
  }
}
__name(Be$1, "Be$1");
function Ce$2(a2, b2, c2) {
  a2 === "focusin" ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : a2 === "focusout" && Ae$1();
}
__name(Ce$2, "Ce$2");
function De$1(a2) {
  if (a2 === "selectionchange" || a2 === "keyup" || a2 === "keydown")
    return te$2(qe$1);
}
__name(De$1, "De$1");
function Ee(a2, b2) {
  if (a2 === "click")
    return te$2(b2);
}
__name(Ee, "Ee");
function Fe$1(a2, b2) {
  if (a2 === "input" || a2 === "change")
    return te$2(b2);
}
__name(Fe$1, "Fe$1");
function Ge$1(a2, b2) {
  return a2 === b2 && (a2 !== 0 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
__name(Ge$1, "Ge$1");
var He$1 = typeof Object.is == "function" ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return !0;
  if (typeof a2 != "object" || a2 === null || typeof b2 != "object" || b2 === null)
    return !1;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return !1;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$1(a2[e2], b2[e2]))
      return !1;
  }
  return !0;
}
__name(Ie$1, "Ie$1");
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
__name(Je$1, "Je$1");
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (c2.nodeType === 3) {
      if (d2 = a2 + c2.textContent.length, a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
__name(Ke, "Ke");
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? !0 : a2 && a2.nodeType === 3 ? !1 : b2 && b2.nodeType === 3 ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : !1 : !1;
}
__name(Le, "Le");
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = typeof b2.contentWindow.location.href == "string";
    } catch {
      c2 = !1;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
__name(Me$2, "Me$2");
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && (b2 === "input" && (a2.type === "text" || a2.type === "search" || a2.type === "tel" || a2.type === "url" || a2.type === "password") || b2 === "textarea" || a2.contentEditable === "true");
}
__name(Ne, "Ne");
function Oe(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (d2 !== null && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, a2 === void 0 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = d2.end === void 0 ? f2 : Math.min(d2.end, e2), !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2), e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (a2.rangeCount !== 1 || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    for (b2 = [], a2 = c2; a2 = a2.parentNode; )
      a2.nodeType === 1 && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    for (typeof c2.focus == "function" && c2.focus(), c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
__name(Oe, "Oe");
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = !1;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : c2.nodeType === 9 ? c2 : c2.ownerDocument;
  Te$1 || Qe$1 == null || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$2(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
__name(Ue$1, "Ue$1");
function Ve$1(a2, b2) {
  var c2 = {};
  return c2[a2.toLowerCase()] = b2.toLowerCase(), c2["Webkit" + a2] = "webkit" + b2, c2["Moz" + a2] = "moz" + b2, c2;
}
__name(Ve$1, "Ve$1");
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
__name(Ze$1, "Ze$1");
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2), fa(b2, [a2]);
}
__name(ff, "ff");
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2, Ub(d2, b2, void 0, a2), a2.currentTarget = null;
}
__name(nf, "nf");
function se$2(a2, b2) {
  b2 = (b2 & 4) !== 0;
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          if (h2 = h2.listener, k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2), f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          if (h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget, h2 = h2.listener, k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2), f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = !1, Rb = null, a2;
}
__name(se$2, "se$2");
function D$2(a2, b2) {
  var c2 = b2[of];
  c2 === void 0 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, !1), c2.add(d2));
}
__name(D$2, "D$2");
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4), pf(c2, a2, d2, b2);
}
__name(qf, "qf");
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = !0, da.forEach(function(b3) {
      b3 !== "selectionchange" && (mf.has(b3) || qf(b3, !1, a2), qf(b3, !0, a2));
    });
    var b2 = a2.nodeType === 9 ? a2 : a2.ownerDocument;
    b2 === null || b2[rf] || (b2[rf] = !0, qf("selectionchange", !1, b2));
  }
}
__name(sf, "sf");
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2), e2 = void 0, !Lb || b2 !== "touchstart" && b2 !== "touchmove" && b2 !== "wheel" || (e2 = !0), d2 ? e2 !== void 0 ? a2.addEventListener(b2, c2, { capture: !0, passive: e2 }) : a2.addEventListener(b2, c2, !0) : e2 !== void 0 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, !1);
}
__name(pf, "pf");
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (!(b2 & 1) && !(b2 & 2) && d2 !== null)
    a:
      for (; ; ) {
        if (d2 === null)
          return;
        var g2 = d2.tag;
        if (g2 === 3 || g2 === 4) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || h2.nodeType === 8 && h2.parentNode === e2)
            break;
          if (g2 === 4)
            for (g2 = d2.return; g2 !== null; ) {
              var k2 = g2.tag;
              if ((k2 === 3 || k2 === 4) && (k2 = g2.stateNode.containerInfo, k2 === e2 || k2.nodeType === 8 && k2.parentNode === e2))
                return;
              g2 = g2.return;
            }
          for (; h2 !== null; ) {
            if (g2 = Wc(h2), g2 === null)
              return;
            if (k2 = g2.tag, k2 === 5 || k2 === 6) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (h3 !== void 0) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (od(c2) === 0)
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus", k3 = Fd;
            break;
          case "focusout":
            n2 = "blur", k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (c2.button === 2)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = (b2 & 4) !== 0, J2 = !t2 && a2 === "scroll", x2 = t2 ? h3 !== null ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; w2 !== null; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          if (u2.tag === 5 && F2 !== null && (u2 = F2, x2 !== null && (F2 = Kb(w2, x2), F2 != null && t2.push(tf(w2, F2, u2)))), J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (!(b2 & 7)) {
      a: {
        if (h3 = a2 === "mouseover" || a2 === "pointerover", k3 = a2 === "mouseout" || a2 === "pointerout", h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if ((k3 || h3) && (h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window, k3 ? (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, n2 !== null && (J2 = Vb(n2), n2 !== J2 || n2.tag !== 5 && n2.tag !== 6) && (n2 = null)) : (k3 = null, n2 = d3), k3 !== n2)) {
          if (t2 = Bd, F2 = "onMouseLeave", x2 = "onMouseEnter", w2 = "mouse", (a2 === "pointerout" || a2 === "pointerover") && (t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer"), J2 = k3 == null ? h3 : ue$1(k3), u2 = n2 == null ? h3 : ue$1(n2), h3 = new t2(F2, w2 + "leave", k3, c2, e3), h3.target = J2, h3.relatedTarget = u2, F2 = null, Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2), J2 = F2, k3 && n2)
            b: {
              for (t2 = k3, x2 = n2, w2 = 0, u2 = t2; u2; u2 = vf(u2))
                w2++;
              for (u2 = 0, F2 = x2; F2; F2 = vf(F2))
                u2++;
              for (; 0 < w2 - u2; )
                t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; )
                x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || x2 !== null && t2 === x2.alternate)
                  break b;
                t2 = vf(t2), x2 = vf(x2);
              }
              t2 = null;
            }
          else
            t2 = null;
          k3 !== null && wf(g3, h3, k3, t2, !1), n2 !== null && J2 !== null && wf(g3, J2, n2, t2, !0);
        }
      }
      a: {
        if (h3 = d3 ? ue$1(d3) : window, k3 = h3.nodeName && h3.nodeName.toLowerCase(), k3 === "select" || k3 === "input" && h3.type === "file")
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$2;
          }
        else
          (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3), a2 === "focusout" && (xa = h3._wrapperState) && xa.controlled && h3.type === "number" && cb(h3, "number", h3.value);
      }
      switch (xa = d3 ? ue$1(d3) : window, a2) {
        case "focusin":
          (me$1(xa) || xa.contentEditable === "true") && (Qe$1 = xa, Re$1 = d3, Se$1 = null);
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = !1, Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$2)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : a2 === "keydown" && c2.keyCode === 229 && (ba = "onCompositionStart");
      ba && (de$1 && c2.locale !== "ko" && (ie$2 || ba !== "onCompositionStart" ? ba === "onCompositionEnd" && ie$2 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = !0)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), $a !== null && (ba.data = $a)))), ($a = ce$2 ? je(a2, c2) : ke$2(a2, c2)) && (d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a));
    }
    se$2(g3, b2);
  });
}
__name(hd, "hd");
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
__name(tf, "tf");
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; a2 !== null; ) {
    var e2 = a2, f2 = e2.stateNode;
    e2.tag === 5 && f2 !== null && (e2 = f2, f2 = Kb(a2, c2), f2 != null && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), f2 != null && d2.push(tf(a2, f2, e2))), a2 = a2.return;
  }
  return d2;
}
__name(oe$2, "oe$2");
function vf(a2) {
  if (a2 === null)
    return null;
  do
    a2 = a2.return;
  while (a2 && a2.tag !== 5);
  return a2 || null;
}
__name(vf, "vf");
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; c2 !== null && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (k2 !== null && k2 === d2)
      break;
    h2.tag === 5 && l2 !== null && (h2 = l2, e2 ? (k2 = Kb(c2, f2), k2 != null && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), k2 != null && g2.push(tf(c2, k2, h2)))), c2 = c2.return;
  }
  g2.length !== 0 && a2.push({ event: b2, listeners: g2 });
}
__name(wf, "wf");
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return (typeof a2 == "string" ? a2 : "" + a2).replace(xf, `
`).replace(yf, "");
}
__name(zf, "zf");
function Af(a2, b2, c2) {
  if (b2 = zf(b2), zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
__name(Af, "Af");
function Bf() {
}
__name(Bf, "Bf");
var Cf = null, Df = null;
function Ef(a2, b2) {
  return a2 === "textarea" || a2 === "noscript" || typeof b2.children == "string" || typeof b2.children == "number" || typeof b2.dangerouslySetInnerHTML == "object" && b2.dangerouslySetInnerHTML !== null && b2.dangerouslySetInnerHTML.__html != null;
}
__name(Ef, "Ef");
var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
__name(If, "If");
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    if (a2.removeChild(c2), e2 && e2.nodeType === 8)
      if (c2 = e2.data, c2 === "/$") {
        if (d2 === 0) {
          a2.removeChild(e2), bd(b2);
          return;
        }
        d2--;
      } else
        c2 !== "$" && c2 !== "$?" && c2 !== "$!" || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
__name(Kf, "Kf");
function Lf(a2) {
  for (; a2 != null; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (b2 === 1 || b2 === 3)
      break;
    if (b2 === 8) {
      if (b2 = a2.data, b2 === "$" || b2 === "$!" || b2 === "$?")
        break;
      if (b2 === "/$")
        return null;
    }
  }
  return a2;
}
__name(Lf, "Lf");
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (a2.nodeType === 8) {
      var c2 = a2.data;
      if (c2 === "$" || c2 === "$!" || c2 === "$?") {
        if (b2 === 0)
          return a2;
        b2--;
      } else
        c2 === "/$" && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
__name(Mf, "Mf");
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      if (c2 = b2.alternate, b2.child !== null || c2 !== null && c2.child !== null)
        for (a2 = Mf(a2); a2 !== null; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2, c2 = a2.parentNode;
  }
  return null;
}
__name(Wc, "Wc");
function Cb(a2) {
  return a2 = a2[Of] || a2[uf], !a2 || a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 13 && a2.tag !== 3 ? null : a2;
}
__name(Cb, "Cb");
function ue$1(a2) {
  if (a2.tag === 5 || a2.tag === 6)
    return a2.stateNode;
  throw Error(p$3(33));
}
__name(ue$1, "ue$1");
function Db(a2) {
  return a2[Pf] || null;
}
__name(Db, "Db");
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
__name(Uf, "Uf");
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
__name(E$1, "E$1");
function G$2(a2, b2) {
  Tf++, Sf[Tf] = a2.current, a2.current = b2;
}
__name(G$2, "G$2");
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(!1), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  return d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2), e2;
}
__name(Yf, "Yf");
function Zf(a2) {
  return a2 = a2.childContextTypes, a2 != null;
}
__name(Zf, "Zf");
function $f() {
  E$1(Wf), E$1(H$2);
}
__name($f, "$f");
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$3(168));
  G$2(H$2, b2), G$2(Wf, c2);
}
__name(ag, "ag");
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (b2 = b2.childContextTypes, typeof d2.getChildContext != "function")
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A$4({}, c2, d2);
}
__name(bg, "bg");
function cg(a2) {
  return a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf, Xf = H$2.current, G$2(H$2, a2), G$2(Wf, Wf.current), !0;
}
__name(cg, "cg");
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$2(H$2, a2)) : E$1(Wf), G$2(Wf, c2);
}
__name(dg, "dg");
var eg = null, fg = !1, gg = !1;
function hg(a2) {
  eg === null ? eg = [a2] : eg.push(a2);
}
__name(hg, "hg");
function ig(a2) {
  fg = !0, hg(a2);
}
__name(ig, "ig");
function jg() {
  if (!gg && eg !== null) {
    gg = !0;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(!0);
        while (d2 !== null);
      }
      eg = null, fg = !1;
    } catch (e2) {
      throw eg !== null && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$2 = b2, gg = !1;
    }
  }
  return null;
}
__name(jg, "jg");
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng, kg[lg++] = mg, mg = a2, ng = b2;
}
__name(tg, "tg");
function ug(a2, b2, c2) {
  og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2), c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32), d2 >>= g2, e2 -= g2, rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2, sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
__name(ug, "ug");
function vg(a2) {
  a2.return !== null && (tg(a2, 1), ug(a2, 1, 0));
}
__name(vg, "vg");
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
__name(wg, "wg");
var xg = null, yg = null, I$1 = !1, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED", c2.stateNode = b2, c2.return = a2, b2 = a2.deletions, b2 === null ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
__name(Ag, "Ag");
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      return b2 = b2.nodeType !== 1 || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2, b2 !== null ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), !0) : !1;
    case 6:
      return b2 = a2.pendingProps === "" || b2.nodeType !== 3 ? null : b2, b2 !== null ? (a2.stateNode = b2, xg = a2, yg = null, !0) : !1;
    case 13:
      return b2 = b2.nodeType !== 8 ? null : b2, b2 !== null ? (c2 = qg !== null ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, !0) : !1;
    default:
      return !1;
  }
}
__name(Cg, "Cg");
function Dg(a2) {
  return (a2.mode & 1) !== 0 && (a2.flags & 128) === 0;
}
__name(Dg, "Dg");
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = !1, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2, I$1 = !1, xg = a2;
    }
  }
}
__name(Eg, "Eg");
function Fg(a2) {
  for (a2 = a2.return; a2 !== null && a2.tag !== 5 && a2.tag !== 3 && a2.tag !== 13; )
    a2 = a2.return;
  xg = a2;
}
__name(Fg, "Fg");
function Gg(a2) {
  if (a2 !== xg)
    return !1;
  if (!I$1)
    return Fg(a2), I$1 = !0, !1;
  var b2;
  if ((b2 = a2.tag !== 3) && !(b2 = a2.tag !== 5) && (b2 = a2.type, b2 = b2 !== "head" && b2 !== "body" && !Ef(a2.type, a2.memoizedProps)), b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  if (Fg(a2), a2.tag === 13) {
    if (a2 = a2.memoizedState, a2 = a2 !== null ? a2.dehydrated : null, !a2)
      throw Error(p$3(317));
    a: {
      for (a2 = a2.nextSibling, b2 = 0; a2; ) {
        if (a2.nodeType === 8) {
          var c2 = a2.data;
          if (c2 === "/$") {
            if (b2 === 0) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            c2 !== "$" && c2 !== "$!" && c2 !== "$?" || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return !0;
}
__name(Gg, "Gg");
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
__name(Hg, "Hg");
function Ig() {
  yg = xg = null, I$1 = !1;
}
__name(Ig, "Ig");
function Jg(a2) {
  zg === null ? zg = [a2] : zg.push(a2);
}
__name(Jg, "Jg");
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$4({}, b2), a2 = a2.defaultProps;
    for (var c2 in a2)
      b2[c2] === void 0 && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
__name(Lg, "Lg");
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
__name(Qg, "Qg");
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg), a2._currentValue = b2;
}
__name(Rg, "Rg");
function Sg(a2, b2, c2) {
  for (; a2 !== null; ) {
    var d2 = a2.alternate;
    if ((a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, d2 !== null && (d2.childLanes |= b2)) : d2 !== null && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2), a2 === c2)
      break;
    a2 = a2.return;
  }
}
__name(Sg, "Sg");
function Tg(a2, b2) {
  Ng = a2, Pg = Og = null, a2 = a2.dependencies, a2 !== null && a2.firstContext !== null && (a2.lanes & b2 && (Ug = !0), a2.firstContext = null);
}
__name(Tg, "Tg");
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, Og === null) {
      if (Ng === null)
        throw Error(p$3(308));
      Og = a2, Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
__name(Vg, "Vg");
var Wg = null;
function Xg(a2) {
  Wg === null ? Wg = [a2] : Wg.push(a2);
}
__name(Xg, "Xg");
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  return e2 === null ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2), b2.interleaved = c2, Zg(a2, d2);
}
__name(Yg, "Yg");
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  for (c2 !== null && (c2.lanes |= b2), c2 = a2, a2 = a2.return; a2 !== null; )
    a2.childLanes |= b2, c2 = a2.alternate, c2 !== null && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return c2.tag === 3 ? c2.stateNode : null;
}
__name(Zg, "Zg");
var $g = !1;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
__name(ah, "ah");
function bh(a2, b2) {
  a2 = a2.updateQueue, b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
__name(bh, "bh");
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
__name(ch, "ch");
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (d2 === null)
    return null;
  if (d2 = d2.shared, K$1 & 2) {
    var e2 = d2.pending;
    return e2 === null ? b2.next = b2 : (b2.next = e2.next, e2.next = b2), d2.pending = b2, Zg(a2, c2);
  }
  return e2 = d2.interleaved, e2 === null ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2), d2.interleaved = b2, Zg(a2, c2);
}
__name(dh, "dh");
function eh(a2, b2, c2) {
  if (b2 = b2.updateQueue, b2 !== null && (b2 = b2.shared, (c2 & 4194240) !== 0)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes, c2 |= d2, b2.lanes = c2, Cc(a2, c2);
  }
}
__name(eh, "eh");
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (d2 !== null && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    if (c2 = c2.firstBaseUpdate, c2 !== null) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        f2 === null ? e2 = f2 = g2 : f2 = f2.next = g2, c2 = c2.next;
      } while (c2 !== null);
      f2 === null ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects }, a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate, a2 === null ? c2.firstBaseUpdate = b2 : a2.next = b2, c2.lastBaseUpdate = b2;
}
__name(fh, "fh");
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = !1;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (h2 !== null) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null, g2 === null ? f2 = l2 : g2.next = l2, g2 = k2;
    var m2 = a2.alternate;
    m2 !== null && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (h2 === null ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (f2 !== null) {
    var q2 = e2.baseState;
    g2 = 0, m2 = l2 = k2 = null, h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        m2 !== null && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          switch (r2 = b2, y2 = c2, t2.tag) {
            case 1:
              if (n2 = t2.payload, typeof n2 == "function") {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              if (n2 = t2.payload, r2 = typeof n2 == "function" ? n2.call(y2, q2, r2) : n2, r2 == null)
                break a;
              q2 = A$4({}, q2, r2);
              break a;
            case 2:
              $g = !0;
          }
        }
        h2.callback !== null && h2.lane !== 0 && (a2.flags |= 64, r2 = e2.effects, r2 === null ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, m2 === null ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      if (h2 = h2.next, h2 === null) {
        if (h2 = e2.shared.pending, h2 === null)
          break;
        r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
      }
    } while (1);
    if (m2 === null && (k2 = q2), e2.baseState = k2, e2.firstBaseUpdate = l2, e2.lastBaseUpdate = m2, b2 = e2.shared.interleaved, b2 !== null) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      f2 === null && (e2.shared.lanes = 0);
    hh |= g2, a2.lanes = g2, a2.memoizedState = q2;
  }
}
__name(gh, "gh");
function ih(a2, b2, c2) {
  if (a2 = b2.effects, b2.effects = null, a2 !== null)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (e2 !== null) {
        if (d2.callback = null, d2 = c2, typeof e2 != "function")
          throw Error(p$3(191, e2));
        e2.call(d2);
      }
    }
}
__name(ih, "ih");
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState, c2 = c2(d2, b2), c2 = c2 == null ? b2 : A$4({}, b2, c2), a2.memoizedState = c2, a2.lanes === 0 && (a2.updateQueue.baseState = c2);
}
__name(kh, "kh");
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : !1;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2, c2 != null && (f2.callback = c2), b2 = dh(a2, f2, e2), b2 !== null && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1, f2.payload = b2, c2 != null && (f2.callback = c2), b2 = dh(a2, f2, e2), b2 !== null && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2, b2 != null && (e2.callback = b2), b2 = dh(a2, e2, d2), b2 !== null && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  return a2 = a2.stateNode, typeof a2.shouldComponentUpdate == "function" ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e2, f2) : !0;
}
__name(oh, "oh");
function ph(a2, b2, c2) {
  var d2 = !1, e2 = Vf, f2 = b2.contextType;
  return typeof f2 == "object" && f2 !== null ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = d2 != null) ? Yf(a2, e2) : Vf), b2 = new b2(c2, f2), a2.memoizedState = b2.state !== null && b2.state !== void 0 ? b2.state : null, b2.updater = nh, a2.stateNode = b2, b2._reactInternals = a2, d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2), b2;
}
__name(ph, "ph");
function qh(a2, b2, c2, d2) {
  a2 = b2.state, typeof b2.componentWillReceiveProps == "function" && b2.componentWillReceiveProps(c2, d2), typeof b2.UNSAFE_componentWillReceiveProps == "function" && b2.UNSAFE_componentWillReceiveProps(c2, d2), b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
__name(qh, "qh");
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2, e2.state = a2.memoizedState, e2.refs = jh, ah(a2);
  var f2 = b2.contextType;
  typeof f2 == "object" && f2 !== null ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2)), e2.state = a2.memoizedState, f2 = b2.getDerivedStateFromProps, typeof f2 == "function" && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState), typeof b2.getDerivedStateFromProps == "function" || typeof e2.getSnapshotBeforeUpdate == "function" || typeof e2.UNSAFE_componentWillMount != "function" && typeof e2.componentWillMount != "function" || (b2 = e2.state, typeof e2.componentWillMount == "function" && e2.componentWillMount(), typeof e2.UNSAFE_componentWillMount == "function" && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState), typeof e2.componentDidMount == "function" && (a2.flags |= 4194308);
}
__name(rh, "rh");
function sh(a2, b2, c2) {
  if (a2 = c2.ref, a2 !== null && typeof a2 != "function" && typeof a2 != "object") {
    if (c2._owner) {
      if (c2 = c2._owner, c2) {
        if (c2.tag !== 1)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      return b2 !== null && b2.ref !== null && typeof b2.ref == "function" && b2.ref._stringRef === f2 ? b2.ref : (b2 = /* @__PURE__ */ __name(function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {}), a3 === null ? delete b3[f2] : b3[f2] = a3;
      }, "b"), b2._stringRef = f2, b2);
    }
    if (typeof a2 != "string")
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
__name(sh, "sh");
function th(a2, b2) {
  throw a2 = Object.prototype.toString.call(b2), Error(p$3(31, a2 === "[object Object]" ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
__name(th, "th");
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
__name(uh, "uh");
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      d3 === null ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  __name(b2, "b");
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; d3 !== null; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  __name(c2, "c");
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); b3 !== null; )
      b3.key !== null ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  __name(d2, "d");
  function e2(a3, b3) {
    return a3 = wh(a3, b3), a3.index = 0, a3.sibling = null, a3;
  }
  __name(e2, "e");
  function f2(b3, c3, d3) {
    return b3.index = d3, a2 ? (d3 = b3.alternate, d3 !== null ? (d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3) : (b3.flags |= 2, c3)) : (b3.flags |= 1048576, c3);
  }
  __name(f2, "f");
  function g2(b3) {
    return a2 && b3.alternate === null && (b3.flags |= 2), b3;
  }
  __name(g2, "g");
  function h2(a3, b3, c3, d3) {
    return b3 === null || b3.tag !== 6 ? (b3 = xh(c3, a3.mode, d3), b3.return = a3, b3) : (b3 = e2(b3, c3), b3.return = a3, b3);
  }
  __name(h2, "h");
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    return f3 === ya ? m2(a3, b3, c3.props.children, d3, c3.key) : b3 !== null && (b3.elementType === f3 || typeof f3 == "object" && f3 !== null && f3.$$typeof === Ha && uh(f3) === b3.type) ? (d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3) : (d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3), d3.ref = sh(a3, b3, c3), d3.return = a3, d3);
  }
  __name(k2, "k");
  function l2(a3, b3, c3, d3) {
    return b3 === null || b3.tag !== 4 || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation ? (b3 = zh(c3, a3.mode, d3), b3.return = a3, b3) : (b3 = e2(b3, c3.children || []), b3.return = a3, b3);
  }
  __name(l2, "l");
  function m2(a3, b3, c3, d3, f3) {
    return b3 === null || b3.tag !== 7 ? (b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3) : (b3 = e2(b3, c3), b3.return = a3, b3);
  }
  __name(m2, "m");
  function q2(a3, b3, c3) {
    if (typeof b3 == "string" && b3 !== "" || typeof b3 == "number")
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if (typeof b3 == "object" && b3 !== null) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  __name(q2, "q");
  function r2(a3, b3, c3, d3) {
    var e3 = b3 !== null ? b3.key : null;
    if (typeof c3 == "string" && c3 !== "" || typeof c3 == "number")
      return e3 !== null ? null : h2(a3, b3, "" + c3, d3);
    if (typeof c3 == "object" && c3 !== null) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return e3 !== null ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  __name(r2, "r");
  function y2(a3, b3, c3, d3, e3) {
    if (typeof d3 == "string" && d3 !== "" || typeof d3 == "number")
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if (typeof d3 == "object" && d3 !== null) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(d3.key === null ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  __name(y2, "y");
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; u2 !== null && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (n3 === null) {
        u2 === null && (u2 = x2);
        break;
      }
      a2 && u2 && n3.alternate === null && b2(e3, u2), g3 = f2(n3, g3, w2), m3 === null ? l3 = n3 : m3.sibling = n3, m3 = n3, u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$1 && tg(e3, w2), l3;
    if (u2 === null) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), u2 !== null && (g3 = f2(u2, g3, w2), m3 === null ? l3 = u2 : m3.sibling = u2, m3 = u2);
      return I$1 && tg(e3, w2), l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), x2 !== null && (a2 && x2.alternate !== null && u2.delete(x2.key === null ? w2 : x2.key), g3 = f2(x2, g3, w2), m3 === null ? l3 = x2 : m3.sibling = x2, m3 = x2);
    return a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    }), I$1 && tg(e3, w2), l3;
  }
  __name(n2, "n");
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if (typeof l3 != "function")
      throw Error(p$3(150));
    if (h3 = l3.call(h3), h3 == null)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); m3 !== null && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (t3 === null) {
        m3 === null && (m3 = x2);
        break;
      }
      a2 && m3 && t3.alternate === null && b2(e3, m3), g3 = f2(t3, g3, w2), u2 === null ? l3 = t3 : u2.sibling = t3, u2 = t3, m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$1 && tg(e3, w2), l3;
    if (m3 === null) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), n3 !== null && (g3 = f2(n3, g3, w2), u2 === null ? l3 = n3 : u2.sibling = n3, u2 = n3);
      return I$1 && tg(e3, w2), l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), n3 !== null && (a2 && n3.alternate !== null && m3.delete(n3.key === null ? w2 : n3.key), g3 = f2(n3, g3, w2), u2 === null ? l3 = n3 : u2.sibling = n3, u2 = n3);
    return a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    }), I$1 && tg(e3, w2), l3;
  }
  __name(t2, "t");
  function J2(a3, d3, f3, h3) {
    if (typeof f3 == "object" && f3 !== null && f3.type === ya && f3.key === null && (f3 = f3.props.children), typeof f3 == "object" && f3 !== null) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; l3 !== null; ) {
              if (l3.key === k3) {
                if (k3 = f3.type, k3 === ya) {
                  if (l3.tag === 7) {
                    c2(a3, l3.sibling), d3 = e2(l3, f3.props.children), d3.return = a3, a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || typeof k3 == "object" && k3 !== null && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling), d3 = e2(l3, f3.props), d3.ref = sh(a3, l3, f3), d3.return = a3, a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; d3 !== null; ) {
              if (d3.key === l3)
                if (d3.tag === 4 && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling), d3 = e2(d3, f3.children || []), d3.return = a3, a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3), d3.return = a3, a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return typeof f3 == "string" && f3 !== "" || typeof f3 == "number" ? (f3 = "" + f3, d3 !== null && d3.tag === 6 ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return __name(J2, "J"), J2;
}
__name(vh, "vh");
var Bh = vh(!0), Ch = vh(!1), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$3(174));
  return a2;
}
__name(Hh, "Hh");
function Ih(a2, b2) {
  switch (G$2(Gh, b2), G$2(Fh, a2), G$2(Eh, Dh), a2 = b2.nodeType, a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = a2 === 8 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh), G$2(Eh, b2);
}
__name(Ih, "Ih");
function Jh() {
  E$1(Eh), E$1(Fh), E$1(Gh);
}
__name(Jh, "Jh");
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current), c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
__name(Kh, "Kh");
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
__name(Lh, "Lh");
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; b2 !== null; ) {
    if (b2.tag === 13) {
      var c2 = b2.memoizedState;
      if (c2 !== null && (c2 = c2.dehydrated, c2 === null || c2.data === "$?" || c2.data === "$!"))
        return b2;
    } else if (b2.tag === 19 && b2.memoizedProps.revealOrder !== void 0) {
      if (b2.flags & 128)
        return b2;
    } else if (b2.child !== null) {
      b2.child.return = b2, b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; b2.sibling === null; ) {
      if (b2.return === null || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return, b2 = b2.sibling;
  }
  return null;
}
__name(Mh, "Mh");
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
__name(Oh, "Oh");
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$1 = null, Sh = !1, Th = !1, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$3(321));
}
__name(Q$2, "Q$2");
function Wh(a2, b2) {
  if (b2 === null)
    return !1;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return !1;
  return !0;
}
__name(Wh, "Wh");
function Xh(a2, b2, c2, d2, e2, f2) {
  if (Rh = f2, N$2 = b2, b2.memoizedState = null, b2.updateQueue = null, b2.lanes = 0, Ph.current = a2 === null || a2.memoizedState === null ? Yh : Zh, a2 = c2(d2, e2), Th) {
    f2 = 0;
    do {
      if (Th = !1, Uh = 0, 25 <= f2)
        throw Error(p$3(301));
      f2 += 1, P$1 = O$2 = null, b2.updateQueue = null, Ph.current = $h, a2 = c2(d2, e2);
    } while (Th);
  }
  if (Ph.current = ai$1, b2 = O$2 !== null && O$2.next !== null, Rh = 0, P$1 = O$2 = N$2 = null, Sh = !1, b2)
    throw Error(p$3(300));
  return a2;
}
__name(Xh, "Xh");
function bi$1() {
  var a2 = Uh !== 0;
  return Uh = 0, a2;
}
__name(bi$1, "bi$1");
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  return P$1 === null ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2, P$1;
}
__name(ci$1, "ci$1");
function di$1() {
  if (O$2 === null) {
    var a2 = N$2.alternate;
    a2 = a2 !== null ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = P$1 === null ? N$2.memoizedState : P$1.next;
  if (b2 !== null)
    P$1 = b2, O$2 = a2;
  else {
    if (a2 === null)
      throw Error(p$3(310));
    O$2 = a2, a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null }, P$1 === null ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
__name(di$1, "di$1");
function ei$1(a2, b2) {
  return typeof b2 == "function" ? b2(a2) : b2;
}
__name(ei$1, "ei$1");
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (f2 !== null) {
    if (e2 !== null) {
      var g2 = e2.next;
      e2.next = f2.next, f2.next = g2;
    }
    d2.baseQueue = e2 = f2, c2.pending = null;
  }
  if (e2 !== null) {
    f2 = e2.next, d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        k2 !== null && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        k2 === null ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2, N$2.lanes |= m2, hh |= m2;
      }
      l2 = l2.next;
    } while (l2 !== null && l2 !== f2);
    k2 === null ? g2 = d2 : k2.next = h2, He$1(d2, b2.memoizedState) || (Ug = !0), b2.memoizedState = d2, b2.baseState = g2, b2.baseQueue = k2, c2.lastRenderedState = d2;
  }
  if (a2 = c2.interleaved, a2 !== null) {
    e2 = a2;
    do
      f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    e2 === null && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
__name(fi$1, "fi$1");
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (c2 === null)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (e2 !== null) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$1(f2, b2.memoizedState) || (Ug = !0), b2.memoizedState = f2, b2.baseQueue === null && (b2.baseState = f2), c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
__name(gi$1, "gi$1");
function hi$1() {
}
__name(hi$1, "hi$1");
function ii$1(a2, b2) {
  var c2 = N$2, d2 = di$1(), e2 = b2(), f2 = !He$1(d2.memoizedState, e2);
  if (f2 && (d2.memoizedState = e2, Ug = !0), d2 = d2.queue, ji$1(ki$1.bind(null, c2, d2, a2), [a2]), d2.getSnapshot !== b2 || f2 || P$1 !== null && P$1.memoizedState.tag & 1) {
    if (c2.flags |= 2048, li$1(9, mi$1.bind(null, c2, d2, e2, b2), void 0, null), R$1 === null)
      throw Error(p$3(349));
    Rh & 30 || ni$1(c2, b2, e2);
  }
  return e2;
}
__name(ii$1, "ii$1");
function ni$1(a2, b2, c2) {
  a2.flags |= 16384, a2 = { getSnapshot: b2, value: c2 }, b2 = N$2.updateQueue, b2 === null ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, c2 === null ? b2.stores = [a2] : c2.push(a2));
}
__name(ni$1, "ni$1");
function mi$1(a2, b2, c2, d2) {
  b2.value = c2, b2.getSnapshot = d2, oi$1(b2) && pi$1(a2);
}
__name(mi$1, "mi$1");
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
__name(ki$1, "ki$1");
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch {
    return !0;
  }
}
__name(oi$1, "oi$1");
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  b2 !== null && mh(b2, a2, 1, -1);
}
__name(pi$1, "pi$1");
function qi$1(a2) {
  var b2 = ci$1();
  return typeof a2 == "function" && (a2 = a2()), b2.memoizedState = b2.baseState = a2, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 }, b2.queue = a2, a2 = a2.dispatch = ri$1.bind(null, N$2, a2), [b2.memoizedState, a2];
}
__name(qi$1, "qi$1");
function li$1(a2, b2, c2, d2) {
  return a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null }, b2 = N$2.updateQueue, b2 === null ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, c2 === null ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2)), a2;
}
__name(li$1, "li$1");
function si$1() {
  return di$1().memoizedState;
}
__name(si$1, "si$1");
function ti$1(a2, b2, c2, d2) {
  var e2 = ci$1();
  N$2.flags |= a2, e2.memoizedState = li$1(1 | b2, c2, void 0, d2 === void 0 ? null : d2);
}
__name(ti$1, "ti$1");
function ui$1(a2, b2, c2, d2) {
  var e2 = di$1();
  d2 = d2 === void 0 ? null : d2;
  var f2 = void 0;
  if (O$2 !== null) {
    var g2 = O$2.memoizedState;
    if (f2 = g2.destroy, d2 !== null && Wh(d2, g2.deps)) {
      e2.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2, e2.memoizedState = li$1(1 | b2, c2, f2, d2);
}
__name(ui$1, "ui$1");
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
__name(vi$1, "vi$1");
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
__name(ji$1, "ji$1");
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
__name(wi$1, "wi$1");
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
__name(xi$1, "xi$1");
function yi$1(a2, b2) {
  if (typeof b2 == "function")
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (b2 != null)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
__name(yi$1, "yi$1");
function zi$1(a2, b2, c2) {
  return c2 = c2 != null ? c2.concat([a2]) : null, ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
__name(zi$1, "zi$1");
function Ai$1() {
}
__name(Ai$1, "Ai$1");
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  return d2 !== null && b2 !== null && Wh(b2, d2[1]) ? d2[0] : (c2.memoizedState = [a2, b2], a2);
}
__name(Bi$1, "Bi$1");
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = b2 === void 0 ? null : b2;
  var d2 = c2.memoizedState;
  return d2 !== null && b2 !== null && Wh(b2, d2[1]) ? d2[0] : (a2 = a2(), c2.memoizedState = [a2, b2], a2);
}
__name(Ci$1, "Ci$1");
function Di$1(a2, b2, c2) {
  return Rh & 21 ? (He$1(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = !0), b2) : (a2.baseState && (a2.baseState = !1, Ug = !0), a2.memoizedState = c2);
}
__name(Di$1, "Di$1");
function Ei$1(a2, b2) {
  var c2 = C$2;
  C$2 = c2 !== 0 && 4 > c2 ? c2 : 4, a2(!0);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(!1), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
__name(Ei$1, "Ei$1");
function Fi$1() {
  return di$1().memoizedState;
}
__name(Fi$1, "Fi$1");
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  if (c2 = { lane: d2, action: c2, hasEagerState: !1, eagerState: null, next: null }, Hi$1(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), c2 !== null) {
    var e2 = L$2();
    mh(c2, a2, d2, e2), Ji$1(c2, b2, d2);
  }
}
__name(Gi$1, "Gi$1");
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: !1, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, e2);
  else {
    var f2 = a2.alternate;
    if (a2.lanes === 0 && (f2 === null || f2.lanes === 0) && (f2 = b2.lastRenderedReducer, f2 !== null))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        if (e2.hasEagerState = !0, e2.eagerState = h2, He$1(h2, g2)) {
          var k2 = b2.interleaved;
          k2 === null ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2), b2.interleaved = e2;
          return;
        }
      } catch {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2), c2 !== null && (e2 = L$2(), mh(c2, a2, d2, e2), Ji$1(c2, b2, d2));
  }
}
__name(ri$1, "ri$1");
function Hi$1(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || b2 !== null && b2 === N$2;
}
__name(Hi$1, "Hi$1");
function Ii$1(a2, b2) {
  Th = Sh = !0;
  var c2 = a2.pending;
  c2 === null ? b2.next = b2 : (b2.next = c2.next, c2.next = b2), a2.pending = b2;
}
__name(Ii$1, "Ii$1");
function Ji$1(a2, b2, c2) {
  if (c2 & 4194240) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes, c2 |= d2, b2.lanes = c2, Cc(a2, c2);
  }
}
__name(Ji$1, "Ji$1");
var ai$1 = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: !1 }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  return ci$1().memoizedState = [a2, b2 === void 0 ? null : b2], a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  return c2 = c2 != null ? c2.concat([a2]) : null, ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  return b2 = b2 === void 0 ? null : b2, a2 = a2(), c2.memoizedState = [a2, b2], a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  return b2 = c2 !== void 0 ? c2(b2) : b2, d2.memoizedState = d2.baseState = b2, a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 }, d2.queue = a2, a2 = a2.dispatch = Gi$1.bind(null, N$2, a2), [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  return a2 = { current: a2 }, b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(!1), b2 = a2[0];
  return a2 = Ei$1.bind(null, a2[1]), ci$1().memoizedState = a2, [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e2 = ci$1();
  if (I$1) {
    if (c2 === void 0)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    if (c2 = b2(), R$1 === null)
      throw Error(p$3(349));
    Rh & 30 || ni$1(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  return e2.queue = f2, vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]), d2.flags |= 2048, li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null), c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg, d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2, b2 = ":" + b2 + "R" + c2, c2 = Uh++, 0 < c2 && (b2 += "H" + c2.toString(32)), b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: !1 }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi$1,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: !1
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi$1, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return O$2 === null ? b2.memoizedState = a2 : Di$1(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: !1 };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = `
Error generating stack: ` + f2.message + `
` + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
__name(Ki$1, "Ki$1");
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: c2 ?? null, digest: b2 ?? null };
}
__name(Li$1, "Li$1");
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
__name(Mi$1, "Mi$1");
var Ni$1 = typeof WeakMap == "function" ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2), c2.tag = 3, c2.payload = { element: null };
  var d2 = b2.value;
  return c2.callback = function() {
    Pi$1 || (Pi$1 = !0, Qi$1 = d2), Mi$1(a2, b2);
  }, c2;
}
__name(Oi$1, "Oi$1");
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2), c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if (typeof d2 == "function") {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    }, c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  return f2 !== null && typeof f2.componentDidCatch == "function" && (c2.callback = function() {
    Mi$1(a2, b2), typeof d2 != "function" && (Si$1 === null ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: c3 !== null ? c3 : "" });
  }), c2;
}
__name(Ri$1, "Ri$1");
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (d2 === null) {
    d2 = a2.pingCache = new Ni$1();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), e2 === void 0 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui$1.bind(null, a2, b2, c2), b2.then(a2, a2));
}
__name(Ti$1, "Ti$1");
function Vi$1(a2) {
  do {
    var b2;
    if ((b2 = a2.tag === 13) && (b2 = a2.memoizedState, b2 = b2 !== null ? b2.dehydrated !== null : !0), b2)
      return a2;
    a2 = a2.return;
  } while (a2 !== null);
  return null;
}
__name(Vi$1, "Vi$1");
function Wi$1(a2, b2, c2, d2, e2) {
  return a2.mode & 1 ? (a2.flags |= 65536, a2.lanes = e2, a2) : (a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, c2.tag === 1 && (c2.alternate === null ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2);
}
__name(Wi$1, "Wi$1");
var Xi$1 = ua.ReactCurrentOwner, Ug = !1;
function Yi$1(a2, b2, c2, d2) {
  b2.child = a2 === null ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
__name(Yi$1, "Yi$1");
function Zi$1(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  return Tg(b2, e2), d2 = Xh(a2, b2, c2, d2, f2, e2), c2 = bi$1(), a2 !== null && !Ug ? (b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2)) : (I$1 && c2 && vg(b2), b2.flags |= 1, Yi$1(a2, b2, d2, e2), b2.child);
}
__name(Zi$1, "Zi$1");
function aj(a2, b2, c2, d2, e2) {
  if (a2 === null) {
    var f2 = c2.type;
    return typeof f2 == "function" && !bj(f2) && f2.defaultProps === void 0 && c2.compare === null && c2.defaultProps === void 0 ? (b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2)) : (a2 = yh(c2.type, null, d2, b2, b2.mode, e2), a2.ref = b2.ref, a2.return = b2, b2.child = a2);
  }
  if (f2 = a2.child, !(a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    if (c2 = c2.compare, c2 = c2 !== null ? c2 : Ie$1, c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e2);
  }
  return b2.flags |= 1, a2 = wh(f2, d2), a2.ref = b2.ref, a2.return = b2, b2.child = a2;
}
__name(aj, "aj");
function cj(a2, b2, c2, d2, e2) {
  if (a2 !== null) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = !1, b2.pendingProps = d2 = f2, (a2.lanes & e2) !== 0)
        a2.flags & 131072 && (Ug = !0);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
__name(cj, "cj");
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = a2 !== null ? a2.memoizedState : null;
  if (d2.mode === "hidden")
    if (!(b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (!(c2 & 1073741824))
        return a2 = f2 !== null ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d2 = f2 !== null ? f2.baseLanes : c2, G$2(fj, gj), gj |= d2;
    }
  else
    f2 !== null ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$2(fj, gj), gj |= d2;
  return Yi$1(a2, b2, e2, c2), b2.child;
}
__name(ej, "ej");
function hj(a2, b2) {
  var c2 = b2.ref;
  (a2 === null && c2 !== null || a2 !== null && a2.ref !== c2) && (b2.flags |= 512, b2.flags |= 2097152);
}
__name(hj, "hj");
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  return f2 = Yf(b2, f2), Tg(b2, e2), c2 = Xh(a2, b2, c2, d2, f2, e2), d2 = bi$1(), a2 !== null && !Ug ? (b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i$1(a2, b2, e2)) : (I$1 && d2 && vg(b2), b2.flags |= 1, Yi$1(a2, b2, c2, e2), b2.child);
}
__name(dj, "dj");
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = !0;
    cg(b2);
  } else
    f2 = !1;
  if (Tg(b2, e2), b2.stateNode === null)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = !0;
  else if (a2 === null) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    typeof l2 == "object" && l2 !== null ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = typeof m2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function";
    q2 || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2), $g = !1;
    var r2 = b2.memoizedState;
    g2.state = r2, gh(b2, d2, g2, e2), k2 = b2.memoizedState, h2 !== d2 || r2 !== k2 || Wf.current || $g ? (typeof m2 == "function" && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || typeof g2.UNSAFE_componentWillMount != "function" && typeof g2.componentWillMount != "function" || (typeof g2.componentWillMount == "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount == "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount == "function" && (b2.flags |= 4194308)) : (typeof g2.componentDidMount == "function" && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : (typeof g2.componentDidMount == "function" && (b2.flags |= 4194308), d2 = !1);
  } else {
    g2 = b2.stateNode, bh(a2, b2), h2 = b2.memoizedProps, l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2), g2.props = l2, q2 = b2.pendingProps, r2 = g2.context, k2 = c2.contextType, typeof k2 == "object" && k2 !== null ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = typeof y2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function") || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2), $g = !1, r2 = b2.memoizedState, g2.state = r2, gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? (typeof y2 == "function" && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || !1) ? (m2 || typeof g2.UNSAFE_componentWillUpdate != "function" && typeof g2.componentWillUpdate != "function" || (typeof g2.componentWillUpdate == "function" && g2.componentWillUpdate(d2, n2, k2), typeof g2.UNSAFE_componentWillUpdate == "function" && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), typeof g2.componentDidUpdate == "function" && (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate == "function" && (b2.flags |= 1024)) : (typeof g2.componentDidUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : (typeof g2.componentDidUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = !1);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
__name(ij, "ij");
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = (b2.flags & 128) !== 0;
  if (!d2 && !g2)
    return e2 && dg(b2, c2, !1), $i$1(a2, b2, f2);
  d2 = b2.stateNode, Xi$1.current = b2;
  var h2 = g2 && typeof c2.getDerivedStateFromError != "function" ? null : d2.render();
  return b2.flags |= 1, a2 !== null && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi$1(a2, b2, h2, f2), b2.memoizedState = d2.state, e2 && dg(b2, c2, !0), b2.child;
}
__name(kj, "kj");
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, !1), Ih(a2, b2.containerInfo);
}
__name(lj, "lj");
function mj(a2, b2, c2, d2, e2) {
  return Ig(), Jg(e2), b2.flags |= 256, Yi$1(a2, b2, c2, d2), b2.child;
}
__name(mj, "mj");
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
__name(oj, "oj");
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$1.current, f2 = !1, g2 = (b2.flags & 128) !== 0, h2;
  if ((h2 = g2) || (h2 = a2 !== null && a2.memoizedState === null ? !1 : (e2 & 2) !== 0), h2 ? (f2 = !0, b2.flags &= -129) : (a2 === null || a2.memoizedState !== null) && (e2 |= 1), G$2(M$1, e2 & 1), a2 === null)
    return Eg(b2), a2 = b2.memoizedState, a2 !== null && (a2 = a2.dehydrated, a2 !== null) ? (b2.mode & 1 ? a2.data === "$!" ? b2.lanes = 8 : b2.lanes = 1073741824 : b2.lanes = 1, null) : (g2 = d2.children, a2 = d2.fallback, f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, !(d2 & 1) && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2));
  if (e2 = a2.memoizedState, e2 !== null && (h2 = e2.dehydrated, h2 !== null))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback, g2 = b2.mode, e2 = a2.child, h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    return !(g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064), h2 !== null ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2), f2.return = b2, d2.return = b2, d2.sibling = f2, b2.child = d2, d2 = f2, f2 = b2.child, g2 = a2.child.memoizedState, g2 = g2 === null ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions }, f2.memoizedState = g2, f2.childLanes = a2.childLanes & ~c2, b2.memoizedState = nj, d2;
  }
  return f2 = a2.child, a2 = f2.sibling, d2 = wh(f2, { mode: "visible", children: d2.children }), !(b2.mode & 1) && (d2.lanes = c2), d2.return = b2, d2.sibling = null, a2 !== null && (c2 = b2.deletions, c2 === null ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2)), b2.child = d2, b2.memoizedState = null, d2;
}
__name(pj, "pj");
function rj(a2, b2) {
  return b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null), b2.return = a2, a2.child = b2;
}
__name(rj, "rj");
function tj(a2, b2, c2, d2) {
  return d2 !== null && Jg(d2), Bh(b2, a2.child, null, c2), a2 = rj(b2, b2.pendingProps.children), a2.flags |= 2, b2.memoizedState = null, a2;
}
__name(tj, "tj");
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2)
    return b2.flags & 256 ? (b2.flags &= -257, d2 = Li$1(Error(p$3(422))), tj(a2, b2, g2, d2)) : b2.memoizedState !== null ? (b2.child = a2.child, b2.flags |= 128, null) : (f2 = d2.fallback, e2 = b2.mode, d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null), f2 = Ah(f2, e2, g2, null), f2.flags |= 2, d2.return = b2, f2.return = b2, d2.sibling = f2, b2.child = d2, b2.mode & 1 && Bh(b2, a2.child, null, g2), b2.child.memoizedState = oj(g2), b2.memoizedState = nj, f2);
  if (!(b2.mode & 1))
    return tj(a2, b2, g2, null);
  if (e2.data === "$!") {
    if (d2 = e2.nextSibling && e2.nextSibling.dataset, d2)
      var h2 = d2.dgst;
    return d2 = h2, f2 = Error(p$3(419)), d2 = Li$1(f2, d2, void 0), tj(a2, b2, g2, d2);
  }
  if (h2 = (g2 & a2.childLanes) !== 0, Ug || h2) {
    if (d2 = R$1, d2 !== null) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = e2 & (d2.suspendedLanes | g2) ? 0 : e2, e2 !== 0 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    return uj(), d2 = Li$1(Error(p$3(421))), tj(a2, b2, g2, d2);
  }
  return e2.data === "$?" ? (b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null) : (a2 = f2.treeContext, yg = Lf(e2.nextSibling), xg = b2, I$1 = !0, zg = null, a2 !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2), b2 = rj(b2, d2.children), b2.flags |= 4096, b2);
}
__name(sj, "sj");
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  d2 !== null && (d2.lanes |= b2), Sg(a2.return, b2, c2);
}
__name(wj, "wj");
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  f2 === null ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
__name(xj, "xj");
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  if (Yi$1(a2, b2, d2.children, c2), d2 = M$1.current, d2 & 2)
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (a2 !== null && a2.flags & 128)
      a:
        for (a2 = b2.child; a2 !== null; ) {
          if (a2.tag === 13)
            a2.memoizedState !== null && wj(a2, c2, b2);
          else if (a2.tag === 19)
            wj(a2, c2, b2);
          else if (a2.child !== null) {
            a2.child.return = a2, a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; a2.sibling === null; ) {
            if (a2.return === null || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return, a2 = a2.sibling;
        }
    d2 &= 1;
  }
  if (G$2(M$1, d2), !(b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        for (c2 = b2.child, e2 = null; c2 !== null; )
          a2 = c2.alternate, a2 !== null && Mh(a2) === null && (e2 = c2), c2 = c2.sibling;
        c2 = e2, c2 === null ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null), xj(b2, !1, e2, c2, f2);
        break;
      case "backwards":
        for (c2 = null, e2 = b2.child, b2.child = null; e2 !== null; ) {
          if (a2 = e2.alternate, a2 !== null && Mh(a2) === null) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling, e2.sibling = c2, c2 = e2, e2 = a2;
        }
        xj(b2, !0, c2, null, f2);
        break;
      case "together":
        xj(b2, !1, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
__name(yj, "yj");
function jj(a2, b2) {
  !(b2.mode & 1) && a2 !== null && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
__name(jj, "jj");
function $i$1(a2, b2, c2) {
  if (a2 !== null && (b2.dependencies = a2.dependencies), hh |= b2.lanes, !(c2 & b2.childLanes))
    return null;
  if (a2 !== null && b2.child !== a2.child)
    throw Error(p$3(153));
  if (b2.child !== null) {
    for (a2 = b2.child, c2 = wh(a2, a2.pendingProps), b2.child = c2, c2.return = b2; a2.sibling !== null; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
__name($i$1, "$i$1");
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2), Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$2(Mg, d2._currentValue), d2._currentValue = e2;
      break;
    case 13:
      if (d2 = b2.memoizedState, d2 !== null)
        return d2.dehydrated !== null ? (G$2(M$1, M$1.current & 1), b2.flags |= 128, null) : c2 & b2.child.childLanes ? pj(a2, b2, c2) : (G$2(M$1, M$1.current & 1), a2 = $i$1(a2, b2, c2), a2 !== null ? a2.sibling : null);
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      if (d2 = (c2 & b2.childLanes) !== 0, a2.flags & 128) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      if (e2 = b2.memoizedState, e2 !== null && (e2.rendering = null, e2.tail = null, e2.lastEffect = null), G$2(M$1, M$1.current), d2)
        break;
      return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
__name(zj, "zj");
var Aj, Bj, Cj, Dj;
Aj = /* @__PURE__ */ __name(function(a2, b2) {
  for (var c2 = b2.child; c2 !== null; ) {
    if (c2.tag === 5 || c2.tag === 6)
      a2.appendChild(c2.stateNode);
    else if (c2.tag !== 4 && c2.child !== null) {
      c2.child.return = c2, c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; c2.sibling === null; ) {
      if (c2.return === null || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return, c2 = c2.sibling;
  }
}, "Aj");
Bj = /* @__PURE__ */ __name(function() {
}, "Bj");
Cj = /* @__PURE__ */ __name(function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode, Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2), d2 = Ya(a2, d2), f2 = [];
        break;
      case "select":
        e2 = A$4({}, e2, { value: void 0 }), d2 = A$4({}, d2, { value: void 0 }), f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2), d2 = gb(a2, d2), f2 = [];
        break;
      default:
        typeof e2.onClick != "function" && typeof d2.onClick == "function" && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && e2[l2] != null)
        if (l2 === "style") {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      if (h2 = e2 != null ? e2[l2] : void 0, d2.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null))
        if (l2 === "style")
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 != "string" && typeof k2 != "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ea.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    (b2.updateQueue = l2) && (b2.flags |= 4);
  }
}, "Cj");
Dj = /* @__PURE__ */ __name(function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
}, "Dj");
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; b2 !== null; )
          b2.alternate !== null && (c2 = b2), b2 = b2.sibling;
        c2 === null ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; c2 !== null; )
          c2.alternate !== null && (d2 = c2), c2 = c2.sibling;
        d2 === null ? b2 || a2.tail === null ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
__name(Ej, "Ej");
function S$2(a2) {
  var b2 = a2.alternate !== null && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; e2 !== null; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  return a2.subtreeFlags |= d2, a2.childLanes = c2, b2;
}
__name(S$2, "S$2");
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  switch (wg(b2), b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 3:
      return d2 = b2.stateNode, Jh(), E$1(Wf), E$1(H$2), Oh(), d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null), (a2 === null || a2.child === null) && (Gg(b2) ? b2.flags |= 4 : a2 === null || a2.memoizedState.isDehydrated && !(b2.flags & 256) || (b2.flags |= 1024, zg !== null && (Gj(zg), zg = null))), Bj(a2, b2), S$2(b2), null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      if (c2 = b2.type, a2 !== null && b2.stateNode != null)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (b2.stateNode === null)
            throw Error(p$3(166));
          return S$2(b2), null;
        }
        if (a2 = Hh(Eh.current), Gg(b2)) {
          d2 = b2.stateNode, c2 = b2.type;
          var f2 = b2.memoizedProps;
          switch (d2[Of] = b2, d2[Pf] = f2, a2 = (b2.mode & 1) !== 0, c2) {
            case "dialog":
              D$2("cancel", d2), D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$2(lf[e2], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              ), D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2), D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple }, D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2), e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              g2 === "children" ? typeof h2 == "string" ? d2.textContent !== h2 && (f2.suppressHydrationWarning !== !0 && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : typeof h2 == "number" && d2.textContent !== "" + h2 && (f2.suppressHydrationWarning !== !0 && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && h2 != null && g2 === "onScroll" && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2), db(d2, f2, !0);
              break;
            case "textarea":
              Va(d2), jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              typeof f2.onClick == "function" && (d2.onclick = Bf);
          }
          d2 = e2, b2.updateQueue = d2, d2 !== null && (b2.flags |= 4);
        } else {
          g2 = e2.nodeType === 9 ? e2 : e2.ownerDocument, a2 === "http://www.w3.org/1999/xhtml" && (a2 = kb(c2)), a2 === "http://www.w3.org/1999/xhtml" ? c2 === "script" ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : typeof d2.is == "string" ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), c2 === "select" && (g2 = a2, d2.multiple ? g2.multiple = !0 : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2), a2[Of] = b2, a2[Pf] = d2, Aj(a2, b2, !1, !1), b2.stateNode = a2;
          a: {
            switch (g2 = vb(c2, d2), c2) {
              case "dialog":
                D$2("cancel", a2), D$2("close", a2), e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2), e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$2(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$2("error", a2), e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                ), D$2("load", a2), e2 = d2;
                break;
              case "details":
                D$2("toggle", a2), e2 = d2;
                break;
              case "input":
                Za(a2, d2), e2 = Ya(a2, d2), D$2("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple }, e2 = A$4({}, d2, { value: void 0 }), D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2), e2 = gb(a2, d2), D$2("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2), h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                f2 === "style" ? sb(a2, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && nb(a2, k2)) : f2 === "children" ? typeof k2 == "string" ? (c2 !== "textarea" || k2 !== "") && ob(a2, k2) : typeof k2 == "number" && ob(a2, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (ea.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && D$2("scroll", a2) : k2 != null && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2), db(a2, d2, !1);
                break;
              case "textarea":
                Va(a2), jb(a2);
                break;
              case "option":
                d2.value != null && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple, f2 = d2.value, f2 != null ? fb(a2, !!d2.multiple, f2, !1) : d2.defaultValue != null && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  !0
                );
                break;
              default:
                typeof e2.onClick == "function" && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = !0;
                break a;
              default:
                d2 = !1;
            }
          }
          d2 && (b2.flags |= 4);
        }
        b2.ref !== null && (b2.flags |= 512, b2.flags |= 2097152);
      }
      return S$2(b2), null;
    case 6:
      if (a2 && b2.stateNode != null)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if (typeof d2 != "string" && b2.stateNode === null)
          throw Error(p$3(166));
        if (c2 = Hh(Gh.current), Hh(Eh.current), Gg(b2)) {
          if (d2 = b2.stateNode, c2 = b2.memoizedProps, d2[Of] = b2, (f2 = d2.nodeValue !== c2) && (a2 = xg, a2 !== null))
            switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, (a2.mode & 1) !== 0);
                break;
              case 5:
                a2.memoizedProps.suppressHydrationWarning !== !0 && Af(d2.nodeValue, c2, (a2.mode & 1) !== 0);
            }
          f2 && (b2.flags |= 4);
        } else
          d2 = (c2.nodeType === 9 ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      return S$2(b2), null;
    case 13:
      if (E$1(M$1), d2 = b2.memoizedState, a2 === null || a2.memoizedState !== null && a2.memoizedState.dehydrated !== null) {
        if (I$1 && yg !== null && b2.mode & 1 && !(b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = !1;
        else if (f2 = Gg(b2), d2 !== null && d2.dehydrated !== null) {
          if (a2 === null) {
            if (!f2)
              throw Error(p$3(318));
            if (f2 = b2.memoizedState, f2 = f2 !== null ? f2.dehydrated : null, !f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), !(b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$2(b2), f2 = !1;
        } else
          zg !== null && (Gj(zg), zg = null), f2 = !0;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      return b2.flags & 128 ? (b2.lanes = c2, b2) : (d2 = d2 !== null, d2 !== (a2 !== null && a2.memoizedState !== null) && d2 && (b2.child.flags |= 8192, b2.mode & 1 && (a2 === null || M$1.current & 1 ? T$2 === 0 && (T$2 = 3) : uj())), b2.updateQueue !== null && (b2.flags |= 4), S$2(b2), null);
    case 4:
      return Jh(), Bj(a2, b2), a2 === null && sf(b2.stateNode.containerInfo), S$2(b2), null;
    case 10:
      return Rg(b2.type._context), S$2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 19:
      if (E$1(M$1), f2 = b2.memoizedState, f2 === null)
        return S$2(b2), null;
      if (d2 = (b2.flags & 128) !== 0, g2 = f2.rendering, g2 === null)
        if (d2)
          Ej(f2, !1);
        else {
          if (T$2 !== 0 || a2 !== null && a2.flags & 128)
            for (a2 = b2.child; a2 !== null; ) {
              if (g2 = Mh(a2), g2 !== null) {
                for (b2.flags |= 128, Ej(f2, !1), d2 = g2.updateQueue, d2 !== null && (b2.updateQueue = d2, b2.flags |= 4), b2.subtreeFlags = 0, d2 = c2, c2 = b2.child; c2 !== null; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = a2 === null ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                return G$2(M$1, M$1.current & 1 | 2), b2.child;
              }
              a2 = a2.sibling;
            }
          f2.tail !== null && B$2() > Hj && (b2.flags |= 128, d2 = !0, Ej(f2, !1), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), a2 !== null) {
            if (b2.flags |= 128, d2 = !0, c2 = a2.updateQueue, c2 !== null && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, !0), f2.tail === null && f2.tailMode === "hidden" && !g2.alternate && !I$1)
              return S$2(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && c2 !== 1073741824 && (b2.flags |= 128, d2 = !0, Ej(f2, !1), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, c2 !== null ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      return f2.tail !== null ? (b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2) : (S$2(b2), null);
    case 22:
    case 23:
      return Ij(), d2 = b2.memoizedState !== null, a2 !== null && a2.memoizedState !== null !== d2 && (b2.flags |= 8192), d2 && b2.mode & 1 ? gj & 1073741824 && (S$2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
__name(Fj, "Fj");
function Jj(a2, b2) {
  switch (wg(b2), b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a2 = b2.flags, a2 & 65536 && !(a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      if (E$1(M$1), a2 = b2.memoizedState, a2 !== null && a2.dehydrated !== null) {
        if (b2.alternate === null)
          throw Error(p$3(340));
        Ig();
      }
      return a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
__name(Jj, "Jj");
var Kj = !1, U$2 = !1, Lj = typeof WeakSet == "function" ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (c2 !== null)
    if (typeof c2 == "function")
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
__name(Mj, "Mj");
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
__name(Nj, "Nj");
var Oj = !1;
function Pj(a2, b2) {
  if (Cf = dd, a2 = Me$2(), Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && d2.rangeCount !== 0) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; q2 !== c2 || e2 !== 0 && q2.nodeType !== 3 || (h2 = g2 + e2), q2 !== f2 || d2 !== 0 && q2.nodeType !== 3 || (k2 = g2 + d2), q2.nodeType === 3 && (g2 += q2.nodeValue.length), (y2 = q2.firstChild) !== null; )
                r2 = q2, q2 = y2;
              for (; ; ) {
                if (q2 === a2)
                  break b;
                if (r2 === c2 && ++l2 === e2 && (h2 = g2), r2 === f2 && ++m2 === d2 && (k2 = g2), (y2 = q2.nextSibling) !== null)
                  break;
                q2 = r2, r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = h2 === -1 || k2 === -1 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  for (Df = { focusedElem: a2, selectionRange: c2 }, dd = !1, V$2 = b2; V$2 !== null; )
    if (b2 = V$2, a2 = b2.child, (b2.subtreeFlags & 1028) !== 0 && a2 !== null)
      a2.return = b2, V$2 = a2;
    else
      for (; V$2 !== null; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (b2.flags & 1024)
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (n2 !== null) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                u2.nodeType === 1 ? u2.textContent = "" : u2.nodeType === 9 && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F2) {
          W$1(b2, b2.return, F2);
        }
        if (a2 = b2.sibling, a2 !== null) {
          a2.return = b2.return, V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  return n2 = Oj, Oj = !1, n2;
}
__name(Pj, "Pj");
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  if (d2 = d2 !== null ? d2.lastEffect : null, d2 !== null) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0, f2 !== void 0 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
__name(Qj, "Qj");
function Rj(a2, b2) {
  if (b2 = b2.updateQueue, b2 = b2 !== null ? b2.lastEffect : null, b2 !== null) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
__name(Rj, "Rj");
function Sj(a2) {
  var b2 = a2.ref;
  if (b2 !== null) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    typeof b2 == "function" ? b2(a2) : b2.current = a2;
  }
}
__name(Sj, "Sj");
function Tj(a2) {
  var b2 = a2.alternate;
  b2 !== null && (a2.alternate = null, Tj(b2)), a2.child = null, a2.deletions = null, a2.sibling = null, a2.tag === 5 && (b2 = a2.stateNode, b2 !== null && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf])), a2.stateNode = null, a2.return = null, a2.dependencies = null, a2.memoizedProps = null, a2.memoizedState = null, a2.pendingProps = null, a2.stateNode = null, a2.updateQueue = null;
}
__name(Tj, "Tj");
function Uj(a2) {
  return a2.tag === 5 || a2.tag === 3 || a2.tag === 4;
}
__name(Uj, "Uj");
function Vj(a2) {
  a:
    for (; ; ) {
      for (; a2.sibling === null; ) {
        if (a2.return === null || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      for (a2.sibling.return = a2.return, a2 = a2.sibling; a2.tag !== 5 && a2.tag !== 6 && a2.tag !== 18; ) {
        if (a2.flags & 2 || a2.child === null || a2.tag === 4)
          continue a;
        a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
__name(Vj, "Vj");
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.nodeType === 8 ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (c2.nodeType === 8 ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, c2 != null || b2.onclick !== null || (b2.onclick = Bf));
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Wj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
__name(Wj, "Wj");
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (d2 === 5 || d2 === 6)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (d2 !== 4 && (a2 = a2.child, a2 !== null))
    for (Xj(a2, b2, c2), a2 = a2.sibling; a2 !== null; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
__name(Xj, "Xj");
var X$2 = null, Yj = !1;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; c2 !== null; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
__name(Zj, "Zj");
function ak(a2, b2, c2) {
  if (lc && typeof lc.onCommitFiberUnmount == "function")
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e2 = Yj;
      X$2 = null, Zj(a2, b2, c2), X$2 = d2, Yj = e2, X$2 !== null && (Yj ? (a2 = X$2, c2 = c2.stateNode, a2.nodeType === 8 ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      X$2 !== null && (Yj ? (a2 = X$2, c2 = c2.stateNode, a2.nodeType === 8 ? Kf(a2.parentNode, c2) : a2.nodeType === 1 && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2, e2 = Yj, X$2 = c2.stateNode.containerInfo, Yj = !0, Zj(a2, b2, c2), X$2 = d2, Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, d2 !== null && (d2 = d2.lastEffect, d2 !== null))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag, g2 !== void 0 && (f2 & 2 || f2 & 4) && Nj(c2, b2, g2), e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, typeof d2.componentWillUnmount == "function"))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || c2.memoizedState !== null, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
__name(ak, "ak");
function bk(a2) {
  var b2 = a2.updateQueue;
  if (b2 !== null) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    c2 === null && (c2 = a2.stateNode = new Lj()), b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
__name(bk, "bk");
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (c2 !== null)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; h2 !== null; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode, Yj = !1;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo, Yj = !0;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo, Yj = !0;
                break a;
            }
            h2 = h2.return;
          }
        if (X$2 === null)
          throw Error(p$3(160));
        ak(f2, g2, e2), X$2 = null, Yj = !1;
        var k2 = e2.alternate;
        k2 !== null && (k2.return = null), e2.return = null;
      } catch (l2) {
        W$1(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; b2 !== null; )
      ek(b2, a2), b2 = b2.sibling;
}
__name(dk, "dk");
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      if (dk(b2, a2), fk(a2), d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2), fk(a2), d2 & 512 && c2 !== null && Mj(c2, c2.return);
      break;
    case 5:
      if (dk(b2, a2), fk(a2), d2 & 512 && c2 !== null && Mj(c2, c2.return), a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, e2 != null)) {
        var f2 = a2.memoizedProps, g2 = c2 !== null ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        if (a2.updateQueue = null, k2 !== null)
          try {
            h2 === "input" && f2.type === "radio" && f2.name != null && ab(e2, f2), vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              m2 === "style" ? sb(e2, q2) : m2 === "dangerouslySetInnerHTML" ? nb(e2, q2) : m2 === "children" ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                y2 != null ? fb(e2, !!f2.multiple, y2, !1) : r2 !== !!f2.multiple && (f2.defaultValue != null ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  !0
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", !1));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      if (dk(b2, a2), fk(a2), d2 & 4) {
        if (a2.stateNode === null)
          throw Error(p$3(162));
        e2 = a2.stateNode, f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      if (dk(b2, a2), fk(a2), d2 & 4 && c2 !== null && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2), fk(a2);
      break;
    case 13:
      dk(b2, a2), fk(a2), e2 = a2.child, e2.flags & 8192 && (f2 = e2.memoizedState !== null, e2.stateNode.isHidden = f2, !f2 || e2.alternate !== null && e2.alternate.memoizedState !== null || (gk = B$2())), d2 & 4 && bk(a2);
      break;
    case 22:
      if (m2 = c2 !== null && c2.memoizedState !== null, a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2), fk(a2), d2 & 8192) {
        if (l2 = a2.memoizedState !== null, (a2.stateNode.isHidden = l2) && !m2 && a2.mode & 1)
          for (V$2 = a2, m2 = a2.child; m2 !== null; ) {
            for (q2 = V$2 = m2; V$2 !== null; ) {
              switch (r2 = V$2, y2 = r2.child, r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if (typeof n2.componentWillUnmount == "function") {
                    d2 = r2, c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (r2.memoizedState !== null) {
                    hk(q2);
                    continue;
                  }
              }
              y2 !== null ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (q2.tag === 5) {
              if (m2 === null) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, typeof f2.setProperty == "function" ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = k2 != null && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (q2.tag === 6) {
              if (m2 === null)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((q2.tag !== 22 && q2.tag !== 23 || q2.memoizedState === null || q2 === a2) && q2.child !== null) {
              q2.child.return = q2, q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; q2.sibling === null; ) {
              if (q2.return === null || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null), q2 = q2.return;
            }
            m2 === q2 && (m2 = null), q2.sibling.return = q2.return, q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2), fk(a2), d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
__name(ek, "ek");
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; c2 !== null; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
__name(fk, "fk");
function ik(a2, b2, c2) {
  V$2 = a2, jk(a2);
}
__name(ik, "ik");
function jk(a2, b2, c2) {
  for (var d2 = (a2.mode & 1) !== 0; V$2 !== null; ) {
    var e2 = V$2, f2 = e2.child;
    if (e2.tag === 22 && d2) {
      var g2 = e2.memoizedState !== null || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = h2 !== null && h2.memoizedState !== null || U$2;
        h2 = Kj;
        var l2 = U$2;
        if (Kj = g2, (U$2 = k2) && !l2)
          for (V$2 = e2; V$2 !== null; )
            g2 = V$2, k2 = g2.child, g2.tag === 22 && g2.memoizedState !== null ? kk(e2) : k2 !== null ? (k2.return = g2, V$2 = k2) : kk(e2);
        for (; f2 !== null; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e2, Kj = h2, U$2 = l2;
      }
      lk(a2);
    } else
      e2.subtreeFlags & 8772 && f2 !== null ? (f2.return = e2, V$2 = f2) : lk(a2);
  }
}
__name(jk, "jk");
function lk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    if (b2.flags & 8772) {
      var c2 = b2.alternate;
      try {
        if (b2.flags & 8772)
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (c2 === null)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              f2 !== null && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (g2 !== null) {
                if (c2 = null, b2.child !== null)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (c2 === null && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (b2.memoizedState === null) {
                var l2 = b2.alternate;
                if (l2 !== null) {
                  var m2 = l2.memoizedState;
                  if (m2 !== null) {
                    var q2 = m2.dehydrated;
                    q2 !== null && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    if (c2 = b2.sibling, c2 !== null) {
      c2.return = b2.return, V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(lk, "lk");
function hk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (c2 !== null) {
      c2.return = b2.return, V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(hk, "hk");
function kk(a2) {
  for (; V$2 !== null; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if (typeof d2.componentDidMount == "function") {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (h2 !== null) {
      h2.return = b2.return, V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
__name(kk, "kk");
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$2 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = 1 / 0, vk = null, Pi$1 = !1, Qi$1 = null, Si$1 = null, wk = !1, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return K$1 & 6 ? B$2() : Bk !== -1 ? Bk : Bk = B$2();
}
__name(L$2, "L$2");
function lh(a2) {
  return a2.mode & 1 ? K$1 & 2 && Z$2 !== 0 ? Z$2 & -Z$2 : Kg.transition !== null ? (Ck === 0 && (Ck = yc()), Ck) : (a2 = C$2, a2 !== 0 || (a2 = window.event, a2 = a2 === void 0 ? 16 : jd(a2.type)), a2) : 1;
}
__name(lh, "lh");
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$3(185));
  Ac(a2, c2, d2), (!(K$1 & 2) || a2 !== R$1) && (a2 === R$1 && (!(K$1 & 2) && (rk |= c2), T$2 === 4 && Dk(a2, Z$2)), Ek(a2, d2), c2 === 1 && K$1 === 0 && !(b2.mode & 1) && (Hj = B$2() + 500, fg && jg()));
}
__name(mh, "mh");
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (d2 === 0)
    c2 !== null && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    if (c2 != null && bc(c2), b2 === 1)
      a2.tag === 0 ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        !(K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2, a2.callbackNode = c2;
  }
}
__name(Ek, "Ek");
function Hk(a2, b2) {
  if (Bk = -1, Ck = 0, K$1 & 6)
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (d2 === 0)
    return null;
  if (d2 & 30 || d2 & a2.expiredLanes || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    (R$1 !== a2 || Z$2 !== b2) && (vk = null, Hj = B$2() + 500, Lk(a2, b2));
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg(), nk.current = f2, K$1 = e2, Y$1 !== null ? b2 = 0 : (R$1 = null, Z$2 = 0, b2 = T$2);
  }
  if (b2 !== 0) {
    if (b2 === 2 && (e2 = xc(a2), e2 !== 0 && (d2 = e2, b2 = Ok(a2, e2))), b2 === 1)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (b2 === 6)
      Dk(a2, d2);
    else {
      if (e2 = a2.current.alternate, !(d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), b2 === 2 && (f2 = xc(a2), f2 !== 0 && (d2 = f2, b2 = Ok(a2, f2))), b2 === 1))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      switch (a2.finishedWork = e2, a2.finishedLanes = d2, b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          if (Dk(a2, d2), (d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (uc(a2, 0) !== 0)
              break;
            if (e2 = a2.suspendedLanes, (e2 & d2) !== d2) {
              L$2(), a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          if (Dk(a2, d2), (d2 & 4194240) === d2)
            break;
          for (b2 = a2.eventTimes, e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2, g2 = b2[g2], g2 > e2 && (e2 = g2), d2 &= ~f2;
          }
          if (d2 = e2, d2 = B$2() - d2, d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2, 10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  return Ek(a2, B$2()), a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
__name(Hk, "Hk");
function Ok(a2, b2) {
  var c2 = tk;
  return a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256), a2 = Jk(a2, b2), a2 !== 2 && (b2 = uk, uk = c2, b2 !== null && Gj(b2)), a2;
}
__name(Ok, "Ok");
function Gj(a2) {
  uk === null ? uk = a2 : uk.push.apply(uk, a2);
}
__name(Gj, "Gj");
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (c2 !== null && (c2 = c2.stores, c2 !== null))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$1(f2(), e2))
              return !1;
          } catch {
            return !1;
          }
        }
    }
    if (c2 = b2.child, b2.subtreeFlags & 16384 && c2 !== null)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; b2.sibling === null; ) {
        if (b2.return === null || b2.return === a2)
          return !0;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return, b2 = b2.sibling;
    }
  }
  return !0;
}
__name(Pk, "Pk");
function Dk(a2, b2) {
  for (b2 &= ~sk, b2 &= ~rk, a2.suspendedLanes |= b2, a2.pingedLanes &= ~b2, a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1, b2 &= ~d2;
  }
}
__name(Dk, "Dk");
function Fk(a2) {
  if (K$1 & 6)
    throw Error(p$3(327));
  Ik();
  var b2 = uc(a2, 0);
  if (!(b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (a2.tag !== 0 && c2 === 2) {
    var d2 = xc(a2);
    d2 !== 0 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (c2 === 1)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (c2 === 6)
    throw Error(p$3(345));
  return a2.finishedWork = a2.current.alternate, a2.finishedLanes = b2, Qk(a2, uk, vk), Ek(a2, B$2()), null;
}
__name(Fk, "Fk");
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, K$1 === 0 && (Hj = B$2() + 500, fg && jg());
  }
}
__name(Rk, "Rk");
function Sk(a2) {
  xk !== null && xk.tag === 0 && !(K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, !(K$1 & 6) && jg();
  }
}
__name(Sk, "Sk");
function Ij() {
  gj = fj.current, E$1(fj);
}
__name(Ij, "Ij");
function Lk(a2, b2) {
  a2.finishedWork = null, a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  if (c2 !== -1 && (a2.timeoutHandle = -1, Gf(c2)), Y$1 !== null)
    for (c2 = Y$1.return; c2 !== null; ) {
      var d2 = c2;
      switch (wg(d2), d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes, d2 != null && $f();
          break;
        case 3:
          Jh(), E$1(Wf), E$1(H$2), Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  if (R$1 = a2, Y$1 = a2 = wh(a2.current, null), Z$2 = gj = b2, T$2 = 0, qk = null, sk = rk = hh = 0, uk = tk = null, Wg !== null) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, d2 !== null) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (f2 !== null) {
          var g2 = f2.next;
          f2.next = e2, d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
__name(Lk, "Lk");
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      if (Qg(), Ph.current = ai$1, Sh) {
        for (var d2 = N$2.memoizedState; d2 !== null; ) {
          var e2 = d2.queue;
          e2 !== null && (e2.pending = null), d2 = d2.next;
        }
        Sh = !1;
      }
      if (Rh = 0, P$1 = O$2 = N$2 = null, Th = !1, Uh = 0, ok.current = null, c2 === null || c2.return === null) {
        T$2 = 1, qk = b2, Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        if (b2 = Z$2, h2.flags |= 32768, k2 !== null && typeof k2 == "object" && typeof k2.then == "function") {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (!(m2.mode & 1) && (q2 === 0 || q2 === 11 || q2 === 15)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (y2 !== null) {
            y2.flags &= -257, Wi$1(y2, g2, h2, f2, b2), y2.mode & 1 && Ti$1(f2, l2, b2), b2 = y2, k2 = l2;
            var n2 = b2.updateQueue;
            if (n2 === null) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2), b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (!(b2 & 1)) {
              Ti$1(f2, l2, b2), uj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (J2 !== null) {
            !(J2.flags & 65536) && (J2.flags |= 256), Wi$1(J2, g2, h2, f2, b2), Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2), T$2 !== 4 && (T$2 = 2), tk === null ? tk = [f2] : tk.push(f2), f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536, b2 &= -b2, f2.lanes |= b2;
              var x2 = Oi$1(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (!(f2.flags & 128) && (typeof w2.getDerivedStateFromError == "function" || u2 !== null && typeof u2.componentDidCatch == "function" && (Si$1 === null || !Si$1.has(u2)))) {
                f2.flags |= 65536, b2 &= -b2, f2.lanes |= b2;
                var F2 = Ri$1(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (f2 !== null);
      }
      Tk(c2);
    } catch (na) {
      b2 = na, Y$1 === c2 && c2 !== null && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
__name(Nk, "Nk");
function Kk() {
  var a2 = nk.current;
  return nk.current = ai$1, a2 === null ? ai$1 : a2;
}
__name(Kk, "Kk");
function uj() {
  (T$2 === 0 || T$2 === 3 || T$2 === 2) && (T$2 = 4), R$1 === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R$1, Z$2);
}
__name(uj, "uj");
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  (R$1 !== a2 || Z$2 !== b2) && (vk = null, Lk(a2, b2));
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  if (Qg(), K$1 = c2, nk.current = d2, Y$1 !== null)
    throw Error(p$3(261));
  return R$1 = null, Z$2 = 0, T$2;
}
__name(Jk, "Jk");
function Uk() {
  for (; Y$1 !== null; )
    Vk(Y$1);
}
__name(Uk, "Uk");
function Mk() {
  for (; Y$1 !== null && !cc(); )
    Vk(Y$1);
}
__name(Mk, "Mk");
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps, b2 === null ? Tk(a2) : Y$1 = b2, ok.current = null;
}
__name(Vk, "Vk");
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    if (a2 = b2.return, b2.flags & 32768) {
      if (c2 = Jj(c2, b2), c2 !== null) {
        c2.flags &= 32767, Y$1 = c2;
        return;
      }
      if (a2 !== null)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$2 = 6, Y$1 = null;
        return;
      }
    } else if (c2 = Fj(c2, b2, gj), c2 !== null) {
      Y$1 = c2;
      return;
    }
    if (b2 = b2.sibling, b2 !== null) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (b2 !== null);
  T$2 === 0 && (T$2 = 5);
}
__name(Tk, "Tk");
function Qk(a2, b2, c2) {
  var d2 = C$2, e2 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$2 = d2;
  }
  return null;
}
__name(Qk, "Qk");
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (xk !== null);
  if (K$1 & 6)
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (c2 === null)
    return null;
  if (a2.finishedWork = null, a2.finishedLanes = 0, c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null, a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  if (Bc(a2, f2), a2 === R$1 && (Y$1 = R$1 = null, Z$2 = 0), !(c2.subtreeFlags & 2064) && !(c2.flags & 2064) || wk || (wk = !0, Gk(hc, function() {
    return Ik(), null;
  })), f2 = (c2.flags & 15990) !== 0, c2.subtreeFlags & 15990 || f2) {
    f2 = pk.transition, pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4, ok.current = null, Pj(a2, c2), ek(c2, a2), Oe(Df), dd = !!Cf, Df = Cf = null, a2.current = c2, ik(c2), dc(), K$1 = h2, C$2 = g2, pk.transition = f2;
  } else
    a2.current = c2;
  if (wk && (wk = !1, xk = a2, yk = e2), f2 = a2.pendingLanes, f2 === 0 && (Si$1 = null), mc(c2.stateNode), Ek(a2, B$2()), b2 !== null)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi$1)
    throw Pi$1 = !1, a2 = Qi$1, Qi$1 = null, a2;
  return yk & 1 && a2.tag !== 0 && Ik(), f2 = a2.pendingLanes, f2 & 1 ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0, jg(), null;
}
__name(Xk, "Xk");
function Ik() {
  if (xk !== null) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      if (pk.transition = null, C$2 = 16 > a2 ? 16 : a2, xk === null)
        var d2 = !1;
      else {
        if (a2 = xk, xk = null, yk = 0, K$1 & 6)
          throw Error(p$3(331));
        var e2 = K$1;
        for (K$1 |= 4, V$2 = a2.current; V$2 !== null; ) {
          var f2 = V$2, g2 = f2.child;
          if (V$2.flags & 16) {
            var h2 = f2.deletions;
            if (h2 !== null) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; V$2 !== null; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (q2 !== null)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; V$2 !== null; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      if (Tj(m2), m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (r2 !== null) {
                        r2.return = y2, V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (n2 !== null) {
                var t2 = n2.child;
                if (t2 !== null) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null, t2 = J2;
                  } while (t2 !== null);
                }
              }
              V$2 = f2;
            }
          }
          if (f2.subtreeFlags & 2064 && g2 !== null)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; V$2 !== null; ) {
                if (f2 = V$2, f2.flags & 2048)
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (x2 !== null) {
                  x2.return = f2.return, V$2 = x2;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; V$2 !== null; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (g2.subtreeFlags & 2064 && u2 !== null)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; V$2 !== null; ) {
                if (h2 = V$2, h2.flags & 2048)
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (F2 !== null) {
                  F2.return = h2.return, V$2 = F2;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        if (K$1 = e2, jg(), lc && typeof lc.onPostCommitFiberRoot == "function")
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch {
          }
        d2 = !0;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return !1;
}
__name(Ik, "Ik");
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2), b2 = Oi$1(a2, b2, 1), a2 = dh(a2, b2, 1), b2 = L$2(), a2 !== null && (Ac(a2, 1, b2), Ek(a2, b2));
}
__name(Yk, "Yk");
function W$1(a2, b2, c2) {
  if (a2.tag === 3)
    Yk(a2, a2, c2);
  else
    for (; b2 !== null; ) {
      if (b2.tag === 3) {
        Yk(b2, a2, c2);
        break;
      } else if (b2.tag === 1) {
        var d2 = b2.stateNode;
        if (typeof b2.type.getDerivedStateFromError == "function" || typeof d2.componentDidCatch == "function" && (Si$1 === null || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2), a2 = Ri$1(b2, a2, 1), b2 = dh(b2, a2, 1), a2 = L$2(), b2 !== null && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
__name(W$1, "W$1");
function Ui$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  d2 !== null && d2.delete(b2), b2 = L$2(), a2.pingedLanes |= a2.suspendedLanes & c2, R$1 === a2 && (Z$2 & c2) === c2 && (T$2 === 4 || T$2 === 3 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2), Ek(a2, b2);
}
__name(Ui$1, "Ui$1");
function Zk(a2, b2) {
  b2 === 0 && (a2.mode & 1 ? (b2 = sc, sc <<= 1, !(sc & 130023424) && (sc = 4194304)) : b2 = 1);
  var c2 = L$2();
  a2 = Zg(a2, b2), a2 !== null && (Ac(a2, b2, c2), Ek(a2, c2));
}
__name(Zk, "Zk");
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  b2 !== null && (c2 = b2.retryLane), Zk(a2, c2);
}
__name(vj, "vj");
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode, e2 = a2.memoizedState;
      e2 !== null && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  d2 !== null && d2.delete(b2), Zk(a2, c2);
}
__name(ck, "ck");
var Wk;
Wk = /* @__PURE__ */ __name(function(a2, b2, c2) {
  if (a2 !== null)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = !0;
    else {
      if (!(a2.lanes & c2) && !(b2.flags & 128))
        return Ug = !1, zj(a2, b2, c2);
      Ug = !!(a2.flags & 131072);
    }
  else
    Ug = !1, I$1 && b2.flags & 1048576 && ug(b2, ng, b2.index);
  switch (b2.lanes = 0, b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2), a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2), e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi$1();
      return b2.flags |= 1, typeof e2 == "object" && e2 !== null && typeof e2.render == "function" && e2.$$typeof === void 0 ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = !0, cg(b2)) : f2 = !1, b2.memoizedState = e2.state !== null && e2.state !== void 0 ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, !0, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi$1(null, b2, e2, c2), b2 = b2.child), b2;
    case 16:
      d2 = b2.elementType;
      a: {
        switch (jj(a2, b2), a2 = b2.pendingProps, e2 = d2._init, d2 = e2(d2._payload), b2.type = d2, e2 = b2.tag = $k(d2), a2 = Lg(d2, a2), e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        if (lj(b2), a2 === null)
          throw Error(p$3(387));
        d2 = b2.pendingProps, f2 = b2.memoizedState, e2 = f2.element, bh(a2, b2), gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        if (d2 = g2.element, f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: !1, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki$1(Error(p$3(423)), b2), b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki$1(Error(p$3(424)), b2), b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = !0, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          if (Ig(), d2 === e2) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi$1(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), a2 === null && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = a2 !== null ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : f2 !== null && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi$1(a2, b2, g2, c2), b2.child;
    case 6:
      return a2 === null && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, a2 === null ? b2.child = Bh(b2, null, d2, c2) : Yi$1(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi$1(a2, b2, d2, e2, c2);
    case 7:
      return Yi$1(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        if (d2 = b2.type._context, e2 = b2.pendingProps, f2 = b2.memoizedProps, g2 = e2.value, G$2(Mg, d2._currentValue), d2._currentValue = g2, f2 !== null)
          if (He$1(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, f2 !== null && (f2.return = b2); f2 !== null; ) {
              var h2 = f2.dependencies;
              if (h2 !== null) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; k2 !== null; ) {
                  if (k2.context === d2) {
                    if (f2.tag === 1) {
                      k2 = ch(-1, c2 & -c2), k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (l2 !== null) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        m2 === null ? k2.next = k2 : (k2.next = m2.next, m2.next = k2), l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2, k2 = f2.alternate, k2 !== null && (k2.lanes |= c2), Sg(
                      f2.return,
                      c2,
                      b2
                    ), h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (f2.tag === 10)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (f2.tag === 18) {
                if (g2 = f2.return, g2 === null)
                  throw Error(p$3(341));
                g2.lanes |= c2, h2 = g2.alternate, h2 !== null && (h2.lanes |= c2), Sg(g2, c2, b2), g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (g2 !== null)
                g2.return = f2;
              else
                for (g2 = f2; g2 !== null; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  if (f2 = g2.sibling, f2 !== null) {
                    f2.return = g2.return, g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi$1(a2, b2, e2.children, c2), b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi$1(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = !0, cg(b2)) : a2 = !1, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, !0, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
}, "Wk");
function Gk(a2, b2) {
  return ac(a2, b2);
}
__name(Gk, "Gk");
function al(a2, b2, c2, d2) {
  this.tag = a2, this.key = c2, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b2, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d2, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
}
__name(al, "al");
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
__name(Bg, "Bg");
function bj(a2) {
  return a2 = a2.prototype, !(!a2 || !a2.isReactComponent);
}
__name(bj, "bj");
function $k(a2) {
  if (typeof a2 == "function")
    return bj(a2) ? 1 : 0;
  if (a2 != null) {
    if (a2 = a2.$$typeof, a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
__name($k, "$k");
function wh(a2, b2) {
  var c2 = a2.alternate;
  return c2 === null ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null), c2.flags = a2.flags & 14680064, c2.childLanes = a2.childLanes, c2.lanes = a2.lanes, c2.child = a2.child, c2.memoizedProps = a2.memoizedProps, c2.memoizedState = a2.memoizedState, c2.updateQueue = a2.updateQueue, b2 = a2.dependencies, c2.dependencies = b2 === null ? null : { lanes: b2.lanes, firstContext: b2.firstContext }, c2.sibling = a2.sibling, c2.index = a2.index, c2.ref = a2.ref, c2;
}
__name(wh, "wh");
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  if (d2 = a2, typeof a2 == "function")
    bj(a2) && (g2 = 1);
  else if (typeof a2 == "string")
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8, e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if (typeof a2 == "object" && a2 !== null)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16, d2 = null;
                break a;
            }
          throw Error(p$3(130, a2 == null ? a2 : typeof a2, ""));
      }
  return b2 = Bg(g2, c2, b2, e2), b2.elementType = a2, b2.type = d2, b2.lanes = f2, b2;
}
__name(yh, "yh");
function Ah(a2, b2, c2, d2) {
  return a2 = Bg(7, a2, d2, b2), a2.lanes = c2, a2;
}
__name(Ah, "Ah");
function qj(a2, b2, c2, d2) {
  return a2 = Bg(22, a2, d2, b2), a2.elementType = Ia, a2.lanes = c2, a2.stateNode = { isHidden: !1 }, a2;
}
__name(qj, "qj");
function xh(a2, b2, c2) {
  return a2 = Bg(6, a2, null, b2), a2.lanes = c2, a2;
}
__name(xh, "xh");
function zh(a2, b2, c2) {
  return b2 = Bg(4, a2.children !== null ? a2.children : [], a2.key, b2), b2.lanes = c2, b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation }, b2;
}
__name(zh, "zh");
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2, this.containerInfo = a2, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d2, this.onRecoverableError = e2, this.mutableSourceEagerHydrationData = null;
}
__name(bl, "bl");
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  return a2 = new bl(a2, b2, c2, h2, k2), b2 === 1 ? (b2 = 1, f2 === !0 && (b2 |= 8)) : b2 = 0, f2 = Bg(3, null, null, b2), a2.current = f2, f2.stateNode = a2, f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null }, ah(f2), a2;
}
__name(cl, "cl");
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
  return { $$typeof: wa, key: d2 == null ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
__name(dl, "dl");
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || a2.tag !== 1)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (b2 !== null);
    throw Error(p$3(171));
  }
  if (a2.tag === 1) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
__name(el, "el");
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  return a2 = cl(c2, d2, !0, a2, e2, f2, g2, h2, k2), a2.context = el(null), c2 = a2.current, d2 = L$2(), e2 = lh(c2), f2 = ch(d2, e2), f2.callback = b2 ?? null, dh(c2, f2, e2), a2.current.lanes = e2, Ac(a2, e2, d2), Ek(a2, d2), a2;
}
__name(fl, "fl");
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$2(), g2 = lh(e2);
  return c2 = el(c2), b2.context === null ? b2.context = c2 : b2.pendingContext = c2, b2 = ch(f2, g2), b2.payload = { element: a2 }, d2 = d2 === void 0 ? null : d2, d2 !== null && (b2.callback = d2), a2 = dh(e2, b2, g2), a2 !== null && (mh(a2, e2, g2, f2), eh(a2, e2, g2)), g2;
}
__name(gl, "gl");
function hl(a2) {
  if (a2 = a2.current, !a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
__name(hl, "hl");
function il(a2, b2) {
  if (a2 = a2.memoizedState, a2 !== null && a2.dehydrated !== null) {
    var c2 = a2.retryLane;
    a2.retryLane = c2 !== 0 && c2 < b2 ? c2 : b2;
  }
}
__name(il, "il");
function jl(a2, b2) {
  il(a2, b2), (a2 = a2.alternate) && il(a2, b2);
}
__name(jl, "jl");
function kl() {
  return null;
}
__name(kl, "kl");
var ll = typeof reportError == "function" ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
__name(ml, "ml");
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (b2 === null)
    throw Error(p$3(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (a2 !== null) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    }), b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
__name(nl, "nl");
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && b2 !== 0 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2), c2 === 0 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11);
}
__name(ol, "ol");
function pl(a2) {
  return !(!a2 || a2.nodeType !== 1 && a2.nodeType !== 9 && a2.nodeType !== 11 && (a2.nodeType !== 8 || a2.nodeValue !== " react-mount-point-unstable "));
}
__name(pl, "pl");
function ql() {
}
__name(ql, "ql");
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if (typeof d2 == "function") {
      var f2 = d2;
      d2 = /* @__PURE__ */ __name(function() {
        var a3 = hl(g2);
        f2.call(a3);
      }, "d");
    }
    var g2 = fl(b2, d2, a2, 0, null, !1, !1, "", ql);
    return a2._reactRootContainer = g2, a2[uf] = g2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), Sk(), g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if (typeof d2 == "function") {
    var h2 = d2;
    d2 = /* @__PURE__ */ __name(function() {
      var a3 = hl(k2);
      h2.call(a3);
    }, "d");
  }
  var k2 = cl(a2, 0, !1, null, null, !1, !1, "", ql);
  return a2._reactRootContainer = k2, a2[uf] = k2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), Sk(function() {
    gl(b2, k2, c2, d2);
  }), k2;
}
__name(rl, "rl");
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if (typeof e2 == "function") {
      var h2 = e2;
      e2 = /* @__PURE__ */ __name(function() {
        var a3 = hl(g2);
        h2.call(a3);
      }, "e");
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
__name(sl, "sl");
Ec = /* @__PURE__ */ __name(function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        c2 !== 0 && (Cc(b2, c2 | 1), Ek(b2, B$2()), !(K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (b3 !== null) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
}, "Ec");
Fc = /* @__PURE__ */ __name(function(a2) {
  if (a2.tag === 13) {
    var b2 = Zg(a2, 134217728);
    if (b2 !== null) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
}, "Fc");
Gc = /* @__PURE__ */ __name(function(a2) {
  if (a2.tag === 13) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (c2 !== null) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
}, "Gc");
Hc = /* @__PURE__ */ __name(function() {
  return C$2;
}, "Hc");
Ic = /* @__PURE__ */ __name(function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
}, "Ic");
yb = /* @__PURE__ */ __name(function(a2, b2, c2) {
  switch (b2) {
    case "input":
      if (bb(a2, c2), b2 = c2.name, c2.type === "radio" && b2 != null) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        for (c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]'), b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$3(90));
            Wa(d2), bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, b2 != null && fb(a2, !!c2.multiple, b2, !1);
  }
}, "yb");
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: !1, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" }, vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  return a2 = Zb(a2), a2 === null ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$3(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$3(299));
  var c2 = !1, d2 = "", e2 = ll;
  return b2 != null && (b2.unstable_strictMode === !0 && (c2 = !0), b2.identifierPrefix !== void 0 && (d2 = b2.identifierPrefix), b2.onRecoverableError !== void 0 && (e2 = b2.onRecoverableError)), b2 = cl(a2, 1, !1, null, null, c2, !1, d2, e2), a2[uf] = b2.current, sf(a2.nodeType === 8 ? a2.parentNode : a2), new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (a2 == null)
    return null;
  if (a2.nodeType === 1)
    return a2;
  var b2 = a2._reactInternals;
  if (b2 === void 0)
    throw typeof a2.render == "function" ? Error(p$3(188)) : (a2 = Object.keys(a2).join(","), Error(p$3(268, a2)));
  return a2 = Zb(b2), a2 = a2 === null ? null : a2.stateNode, a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, !0, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$3(405));
  var d2 = c2 != null && c2.hydratedSources || null, e2 = !1, f2 = "", g2 = ll;
  if (c2 != null && (c2.unstable_strictMode === !0 && (e2 = !0), c2.identifierPrefix !== void 0 && (f2 = c2.identifierPrefix), c2.onRecoverableError !== void 0 && (g2 = c2.onRecoverableError)), b2 = fl(b2, null, a2, 1, c2 ?? null, e2, !1, f2, g2), a2[uf] = b2.current, sf(a2), d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), b2.mutableSourceEagerHydrationData == null ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, !1, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, !1, function() {
      a2._reactRootContainer = null, a2[uf] = null;
    });
  }), !0) : !1;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$3(200));
  if (a2 == null || a2._reactInternals === void 0)
    throw Error(p$3(38));
  return sl(a2, b2, c2, !1, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
}
__name(checkDCE, "checkDCE");
checkDCE(), reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports, createRoot, m$3 = reactDomExports;
createRoot = m$3.createRoot, m$3.hydrateRoot;
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
__name(_objectWithoutPropertiesLoose$1, "_objectWithoutPropertiesLoose$1");
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded), key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++)
      key = sourceSymbolKeys[i], !(excluded.indexOf(key) >= 0) && Object.prototype.propertyIsEnumerable.call(source, key) && (target[key] = source[key]);
  }
  return target;
}
__name(_objectWithoutProperties, "_objectWithoutProperties");
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && typeof Symbol == "function" && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
__name(_typeof, "_typeof");
function toPrimitive(t2, r2) {
  if (_typeof(t2) != "object" || !t2)
    return t2;
  var e2 = t2[Symbol.toPrimitive];
  if (e2 !== void 0) {
    var i = e2.call(t2, r2 || "default");
    if (_typeof(i) != "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (r2 === "string" ? String : Number)(t2);
}
__name(toPrimitive, "toPrimitive");
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return _typeof(i) == "symbol" ? i : String(i);
}
__name(toPropertyKey, "toPropertyKey");
function _defineProperty(obj, key, value) {
  return key = toPropertyKey(key), key in obj ? Object.defineProperty(obj, key, {
    value,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : obj[key] = value, obj;
}
__name(_defineProperty, "_defineProperty");
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor))
    throw new TypeError("Cannot call a class as a function");
}
__name(_classCallCheck, "_classCallCheck");
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
__name(_defineProperties, "_defineProperties");
function _createClass(Constructor, protoProps, staticProps) {
  return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), Object.defineProperty(Constructor, "prototype", {
    writable: !1
  }), Constructor;
}
__name(_createClass, "_createClass");
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: !0,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: !0
}, i18nInstance, I18nContext = React.createContext();
function getDefaults() {
  return defaultOptions;
}
__name(getDefaults, "getDefaults");
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2), this.usedNamespaces = {};
  }
  return __name(ReportNamespaces2, "ReportNamespaces"), _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: /* @__PURE__ */ __name(function(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns2) {
        _this.usedNamespaces[ns2] || (_this.usedNamespaces[ns2] = !0);
      });
    }, "addUsedNamespaces")
  }, {
    key: "getUsedNamespaces",
    value: /* @__PURE__ */ __name(function() {
      return Object.keys(this.usedNamespaces);
    }, "getUsedNamespaces")
  }]), ReportNamespaces2;
}();
function getI18n() {
  return i18nInstance;
}
__name(getI18n, "getI18n");
function warn() {
  if (console && console.warn) {
    for (var _console, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
      args[_key] = arguments[_key];
    typeof args[0] == "string" && (args[0] = "react-i18next:: ".concat(args[0])), (_console = console).warn.apply(_console, args);
  }
}
__name(warn, "warn");
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
    args[_key2] = arguments[_key2];
  typeof args[0] == "string" && alreadyWarned[args[0]] || (typeof args[0] == "string" && (alreadyWarned[args[0]] = /* @__PURE__ */ new Date()), warn.apply(void 0, args));
}
__name(warnOnce, "warnOnce");
function loadNamespaces(i18n, ns2, cb2) {
  i18n.loadNamespaces(ns2, function() {
    if (i18n.isInitialized)
      cb2();
    else {
      var initialized = /* @__PURE__ */ __name(function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0), cb2();
      }, "initialized");
      i18n.on("initialized", initialized);
    }
  });
}
__name(loadNamespaces, "loadNamespaces");
function oldI18nextHasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, lng = i18n.languages[0], fallbackLng = i18n.options ? i18n.options.fallbackLng : !1, lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return !0;
  var loadNotPending = /* @__PURE__ */ __name(function(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  }, "loadNotPending");
  return options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns2) ? !1 : !!(i18n.hasResourceBundle(lng, ns2) || !i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages || loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)));
}
__name(oldI18nextHasLoadedNamespace, "oldI18nextHasLoadedNamespace");
function hasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length)
    return warnOnce("i18n.languages were undefined or empty", i18n.languages), !0;
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  return isNewerI18next ? i18n.hasLoadedNamespace(ns2, {
    precheck: /* @__PURE__ */ __name(function(i18nInstance2, loadNotPending) {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns2))
        return !1;
    }, "precheck")
  }) : oldI18nextHasLoadedNamespace(ns2, i18n, options2);
}
__name(hasLoadedNamespace, "hasLoadedNamespace");
function getDisplayName$1(Component) {
  return Component.displayName || Component.name || (typeof Component == "string" && Component.length > 0 ? Component : "Unknown");
}
__name(getDisplayName$1, "getDisplayName$1");
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
__name(_arrayWithHoles, "_arrayWithHoles");
function _iterableToArrayLimit(r2, l2) {
  var t2 = r2 == null ? null : typeof Symbol < "u" && r2[Symbol.iterator] || r2["@@iterator"];
  if (t2 != null) {
    var e2, n2, i, u2, a2 = [], f2 = !0, o2 = !1;
    try {
      if (i = (t2 = t2.call(r2)).next, l2 === 0) {
        if (Object(t2) !== t2)
          return;
        f2 = !1;
      } else
        for (; !(f2 = (e2 = i.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = !0)
          ;
    } catch (r3) {
      o2 = !0, n2 = r3;
    } finally {
      try {
        if (!f2 && t2.return != null && (u2 = t2.return(), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
__name(_iterableToArrayLimit, "_iterableToArrayLimit");
function _arrayLikeToArray(arr, len) {
  (len == null || len > arr.length) && (len = arr.length);
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _unsupportedIterableToArray(o2, minLen) {
  if (o2) {
    if (typeof o2 == "string")
      return _arrayLikeToArray(o2, minLen);
    var n2 = Object.prototype.toString.call(o2).slice(8, -1);
    if (n2 === "Object" && o2.constructor && (n2 = o2.constructor.name), n2 === "Map" || n2 === "Set")
      return Array.from(o2);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o2, minLen);
  }
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _nonIterableRest() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableRest, "_nonIterableRest");
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
__name(_slicedToArray, "_slicedToArray");
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$8, "ownKeys$8");
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$8, "_objectSpread$8");
function useTranslation(ns2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, i18nFromProps = props.i18n, _ref3 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref3.i18n, defaultNSFromContext = _ref3.defaultNS, i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces && (i18n.reportNamespaces = new ReportNamespaces()), !i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = /* @__PURE__ */ __name(function(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    }, "notReadyT"), retNotReady = [notReadyT, {}, !1];
    return retNotReady.t = notReadyT, retNotReady.i18n = {}, retNotReady.ready = !1, retNotReady;
  }
  i18n.options.react && i18n.options.react.wait !== void 0 && warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, getDefaults()), i18n.options.react), props), useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix, namespaces = ns2 || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces == "string" ? [namespaces] : namespaces || ["translation"], i18n.reportNamespaces.addUsedNamespaces && i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  __name(getT, "getT");
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1], isMounted = reactExports.useRef(!0);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = !0, !ready && !useSuspense && loadNamespaces(i18n, namespaces, function() {
      isMounted.current && setT(getT);
    });
    function boundReset() {
      isMounted.current && setT(getT);
    }
    return __name(boundReset, "boundReset"), bindI18n && i18n && i18n.on(bindI18n, boundReset), bindI18nStore && i18n && i18n.store.on(bindI18nStore, boundReset), function() {
      isMounted.current = !1, bindI18n && i18n && bindI18n.split(" ").forEach(function(e2) {
        return i18n.off(e2, boundReset);
      }), bindI18nStore && i18n && bindI18nStore.split(" ").forEach(function(e2) {
        return i18n.store.off(e2, boundReset);
      });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = reactExports.useRef(!0);
  reactExports.useEffect(function() {
    isMounted.current && !isInitial.current && setT(getT), isInitial.current = !1;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  if (ret.t = t2, ret.i18n = i18n, ret.ready = ready, ready || !ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces, function() {
      resolve();
    });
  });
}
__name(useTranslation, "useTranslation");
var _excluded$8 = ["forwardedRef"];
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$7, "ownKeys$7");
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$7, "_objectSpread$7");
function withTranslation(ns2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    function I18nextWithTranslation(_ref3) {
      var forwardedRef = _ref3.forwardedRef, rest = _objectWithoutProperties(_ref3, _excluded$8), _useTranslation = useTranslation(ns2, rest), _useTranslation2 = _slicedToArray(_useTranslation, 3), t2 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2], passDownProps = _objectSpread$7(_objectSpread$7({}, rest), {}, {
        t: t2,
        i18n,
        tReady: ready
      });
      return options2.withRef && forwardedRef ? passDownProps.ref = forwardedRef : !options2.withRef && forwardedRef && (passDownProps.forwardedRef = forwardedRef), React.createElement(WrappedComponent, passDownProps);
    }
    __name(I18nextWithTranslation, "I18nextWithTranslation"), I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName$1(WrappedComponent), ")"), I18nextWithTranslation.WrappedComponent = WrappedComponent;
    var forwardRef = /* @__PURE__ */ __name(function(props, ref) {
      return React.createElement(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    }, "forwardRef");
    return options2.withRef ? React.forwardRef(forwardRef) : I18nextWithTranslation;
  }, "Extend");
}
__name(withTranslation, "withTranslation");
function I18nextProvider(_ref3) {
  var i18n = _ref3.i18n, defaultNS = _ref3.defaultNS, children2 = _ref3.children, value = reactExports.useMemo(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return reactExports.createElement(I18nContext.Provider, {
    value
  }, children2);
}
__name(I18nextProvider, "I18nextProvider");
/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$3.apply(this, arguments);
}
__name(_extends$3, "_extends$3");
var Action;
(function(Action2) {
  Action2.Pop = "POP", Action2.Push = "PUSH", Action2.Replace = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  options2 === void 0 && (options2 = {});
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  __name(createBrowserLocation, "createBrowserLocation");
  function createBrowserHref(window2, to) {
    return typeof to == "string" ? to : createPath(to);
  }
  return __name(createBrowserHref, "createBrowserHref"), getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
__name(createBrowserHistory, "createBrowserHistory");
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
__name(createKey, "createKey");
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
__name(getHistoryState, "getHistoryState");
function createLocation(current, to, state, key) {
  return state === void 0 && (state = null), _extends$3({
    pathname: typeof current == "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to == "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
}
__name(createLocation, "createLocation");
function createPath(_ref3) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref3;
  return search && search !== "?" && (pathname += search.charAt(0) === "?" ? search : "?" + search), hash2 && hash2 !== "#" && (pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2), pathname;
}
__name(createPath, "createPath");
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    hashIndex >= 0 && (parsedPath.hash = path.substr(hashIndex), path = path.substr(0, hashIndex));
    let searchIndex = path.indexOf("?");
    searchIndex >= 0 && (parsedPath.search = path.substr(searchIndex), path = path.substr(0, searchIndex)), path && (parsedPath.pathname = path);
  }
  return parsedPath;
}
__name(parsePath, "parsePath");
function createURL(location) {
  let base3 = typeof window < "u" && typeof window.location < "u" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown", href = typeof location == "string" ? location : createPath(location);
  return new URL(href, base3);
}
__name(createURL, "createURL");
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options2) {
  options2 === void 0 && (options2 = {});
  let {
    window: window2 = document.defaultView,
    v5Compat = !1
  } = options2, globalHistory = window2.history, action2 = Action.Pop, listener = null;
  function handlePop() {
    action2 = Action.Pop, listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(handlePop, "handlePop");
  function push(to, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to);
    let historyState = getHistoryState(location), url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch {
      window2.location.assign(url);
    }
    v5Compat && listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(push, "push");
  function replace2(to, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to, state);
    validateLocation && validateLocation(location, to);
    let historyState = getHistoryState(location), url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url), v5Compat && listener && listener({
      action: action2,
      location: history.location
    });
  }
  __name(replace2, "replace");
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn2) {
      if (listener)
        throw new Error("A history only accepts one active listener");
      return window2.addEventListener(PopStateEventType, handlePop), listener = fn2, () => {
        window2.removeEventListener(PopStateEventType, handlePop), listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(location) {
      let url = createURL(createPath(location));
      return _extends$3({}, location, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
__name(getUrlBasedHistory, "getUrlBasedHistory");
var ResultType;
(function(ResultType2) {
  ResultType2.data = "data", ResultType2.deferred = "deferred", ResultType2.redirect = "redirect", ResultType2.error = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  basename === void 0 && (basename = "/");
  let location = typeof locationArg == "string" ? parsePath(locationArg) : locationArg, pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null)
    return null;
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i)
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  return matches;
}
__name(matchRoutes, "matchRoutes");
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  return branches === void 0 && (branches = []), parentsMeta === void 0 && (parentsMeta = []), parentPath === void 0 && (parentPath = ""), routes.forEach((route2, index) => {
    let meta = {
      relativePath: route2.path || "",
      caseSensitive: route2.caseSensitive === !0,
      childrenIndex: index,
      route: route2
    };
    meta.relativePath.startsWith("/") && (invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), meta.relativePath = meta.relativePath.slice(parentPath.length));
    let path = joinPaths([parentPath, meta.relativePath]), routesMeta = parentsMeta.concat(meta);
    route2.children && route2.children.length > 0 && (invariant(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      route2.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
    ), flattenRoutes(route2.children, branches, routesMeta, path)), !(route2.path == null && !route2.index) && branches.push({
      path,
      score: computeScore(path, route2.index),
      routesMeta
    });
  }), branches;
}
__name(flattenRoutes, "flattenRoutes");
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
__name(rankRouteBranches, "rankRouteBranches");
const paramRe = /^:\w+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = /* @__PURE__ */ __name((s) => s === "*", "isSplat");
function computeScore(path, index) {
  let segments = path.split("/"), initialScore = segments.length;
  return segments.some(isSplat) && (initialScore += splatPenalty), index && (initialScore += indexRouteValue), segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
__name(computeScore, "computeScore");
function compareIndexes(a2, b2) {
  return a2.length === b2.length && a2.slice(0, -1).every((n2, i) => n2 === b2[i]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
__name(compareIndexes, "compareIndexes");
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch, matchedParams = {}, matchedPathname = "/", matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i], end2 = i === routesMeta.length - 1, remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/", match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route2 = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route: route2
    }), match2.pathnameBase !== "/" && (matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]));
  }
  return matches;
}
__name(matchRouteBranch, "matchRouteBranch");
function matchPath(pattern, pathname) {
  typeof pattern == "string" && (pattern = {
    path: pattern,
    caseSensitive: !1,
    end: !0
  });
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end), match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0], pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1"), captureGroups = match2.slice(1);
  return {
    params: paramNames.reduce((memo, paramName, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      return memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName), memo;
    }, {}),
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
__name(matchPath, "matchPath");
function compilePath(path, caseSensitive, end2) {
  caseSensitive === void 0 && (caseSensitive = !1), end2 === void 0 && (end2 = !0), warning$p(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [], regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_24, paramName) => (paramNames.push(paramName), "([^\\/]+)"));
  return path.endsWith("*") ? (paramNames.push("*"), regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : end2 ? regexpSource += "\\/*$" : path !== "" && path !== "/" && (regexpSource += "(?:(?=\\/|$))"), [new RegExp(regexpSource, caseSensitive ? void 0 : "i"), paramNames];
}
__name(compilePath, "compilePath");
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error3) {
    return warning$p(!1, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error3 + ").")), value;
  }
}
__name(safelyDecodeURI, "safelyDecodeURI");
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error3) {
    return warning$p(!1, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error3 + ").")), value;
  }
}
__name(safelyDecodeURIComponent, "safelyDecodeURIComponent");
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase()))
    return null;
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length, nextChar = pathname.charAt(startIndex);
  return nextChar && nextChar !== "/" ? null : pathname.slice(startIndex) || "/";
}
__name(stripBasename, "stripBasename");
function invariant(value, message2) {
  if (value === !1 || value === null || typeof value > "u")
    throw new Error(message2);
}
__name(invariant, "invariant");
function warning$p(cond, message2) {
  if (!cond) {
    typeof console < "u" && console.warn(message2);
    try {
      throw new Error(message2);
    } catch {
    }
  }
}
__name(warning$p, "warning$p");
function resolvePath(to, fromPathname) {
  fromPathname === void 0 && (fromPathname = "/");
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to == "string" ? parsePath(to) : to;
  return {
    pathname: toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
__name(resolvePath, "resolvePath");
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  return relativePath.split("/").forEach((segment) => {
    segment === ".." ? segments.length > 1 && segments.pop() : segment !== "." && segments.push(segment);
  }), segments.length > 1 ? segments.join("/") : "/";
}
__name(resolvePathname, "resolvePathname");
function getInvalidPathError(char2, field2, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field2 + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
__name(getInvalidPathError, "getInvalidPathError");
function getPathContributingMatches(matches) {
  return matches.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
}
__name(getPathContributingMatches, "getPathContributingMatches");
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  isPathRelative === void 0 && (isPathRelative = !1);
  let to;
  typeof toArg == "string" ? to = parsePath(toArg) : (to = _extends$3({}, toArg), invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to)), invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to)), invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to)));
  let isEmptyPath = toArg === "" || to.pathname === "", toPathname = isEmptyPath ? "/" : to.pathname, from2;
  if (isPathRelative || toPathname == null)
    from2 = locationPathname;
  else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      for (; toSegments[0] === ".."; )
        toSegments.shift(), routePathnameIndex -= 1;
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2), hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/"), hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  return !path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash) && (path.pathname += "/"), path;
}
__name(resolveTo, "resolveTo");
const joinPaths = /* @__PURE__ */ __name((paths) => paths.join("/").replace(/\/\/+/g, "/"), "joinPaths"), normalizePathname = /* @__PURE__ */ __name((pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/"), "normalizePathname"), normalizeSearch = /* @__PURE__ */ __name((search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search, "normalizeSearch"), normalizeHash = /* @__PURE__ */ __name((hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2, "normalizeHash"), _ErrorResponse = class _ErrorResponse {
  constructor(status2, statusText, data) {
    this.status = status2, this.statusText = statusText || "", this.data = data;
  }
};
__name(_ErrorResponse, "ErrorResponse");
let ErrorResponse = _ErrorResponse;
function isRouteErrorResponse(e2) {
  return e2 instanceof ErrorResponse;
}
__name(isRouteErrorResponse, "isRouteErrorResponse");
const validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
[...validActionMethods];
/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$2.apply(this, arguments);
}
__name(_extends$2, "_extends$2");
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
__name(isPolyfill, "isPolyfill");
const is$1 = typeof Object.is == "function" ? Object.is : isPolyfill, {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe2, getSnapshot, getServerSnapshot) {
  const value = getSnapshot(), [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  return useLayoutEffect(() => {
    inst.value = value, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  }, [subscribe2, value, getSnapshot]), useEffect(() => (checkIfSnapshotChanged(inst) && forceUpdate({
    inst
  }), subscribe2(/* @__PURE__ */ __name(() => {
    checkIfSnapshotChanged(inst) && forceUpdate({
      inst
    });
  }, "handleStoreChange"))), [subscribe2]), useDebugValue(value), value;
}
__name(useSyncExternalStore$2, "useSyncExternalStore$2");
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is$1(prevValue, nextValue);
  } catch {
    return !0;
  }
}
__name(checkIfSnapshotChanged, "checkIfSnapshotChanged");
function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
__name(useSyncExternalStore$1, "useSyncExternalStore$1");
const canUseDOM$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", isServerEnvironment = !canUseDOM$1, shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 && ((module) => module.useSyncExternalStore)(React$1);
const DataStaticRouterContext = /* @__PURE__ */ reactExports.createContext(null), DataRouterContext = /* @__PURE__ */ reactExports.createContext(null), DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null), NavigationContext = /* @__PURE__ */ reactExports.createContext(null), LocationContext = /* @__PURE__ */ reactExports.createContext(null), RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
}), RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  useInRouterContext() || invariant(!1);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext), {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  }), joinedPathname = pathname;
  return basename !== "/" && (joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname])), navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
__name(useHref, "useHref");
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
__name(useInRouterContext, "useInRouterContext");
function useLocation() {
  return useInRouterContext() || invariant(!1), reactExports.useContext(LocationContext).location;
}
__name(useLocation, "useLocation");
function useNavigate() {
  useInRouterContext() || invariant(!1);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext), {
    matches
  } = reactExports.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase)), activeRef = reactExports.useRef(!1);
  return reactExports.useEffect(() => {
    activeRef.current = !0;
  }), reactExports.useCallback(function(to, options2) {
    if (options2 === void 0 && (options2 = {}), !activeRef.current)
      return;
    if (typeof to == "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    basename !== "/" && (path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname])), (options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
}
__name(useNavigate, "useNavigate");
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext), routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
__name(useParams, "useParams");
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2, {
    matches
  } = reactExports.useContext(RouteContext), {
    pathname: locationPathname
  } = useLocation(), routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
__name(useResolvedPath, "useResolvedPath");
function useRoutes(routes, locationArg) {
  useInRouterContext() || invariant(!1);
  let dataRouterStateContext = reactExports.useContext(DataRouterStateContext), {
    matches: parentMatches
  } = reactExports.useContext(RouteContext), routeMatch = parentMatches[parentMatches.length - 1], parentParams = routeMatch ? routeMatch.params : {};
  routeMatch && routeMatch.pathname;
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation(), location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg == "string" ? parsePath(locationArg) : locationArg;
    parentPathnameBase === "/" || (_parsedLocationArg$pa = parsedLocationArg.pathname) != null && _parsedLocationArg$pa.startsWith(parentPathnameBase) || invariant(!1), location = parsedLocationArg;
  } else
    location = locationFromContext;
  let pathname = location.pathname || "/", remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/", matches = matchRoutes(routes, {
    pathname: remainingPathname
  }), renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  return locationArg && renderedMatches ? /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    value: {
      location: _extends$2({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, location),
      navigationType: Action.Pop
    }
  }, renderedMatches) : renderedMatches;
}
__name(useRoutes, "useRoutes");
function DefaultErrorElement() {
  let error3 = useRouteError(), message2 = isRouteErrorResponse(error3) ? error3.status + " " + error3.statusText : error3 instanceof Error ? error3.message : JSON.stringify(error3), stack = error3 instanceof Error ? error3.stack : null, lightgrey = "rgba(200,200,200, 0.5)", preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  }, codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ reactExports.createElement("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on ", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
__name(DefaultErrorElement, "DefaultErrorElement");
const _RenderErrorBoundary = class _RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props), this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error3) {
    return {
      error: error3
    };
  }
  static getDerivedStateFromProps(props, state) {
    return state.location !== props.location ? {
      error: props.error,
      location: props.location
    } : {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error3, errorInfo) {
    console.error("React Router caught the following error during render", error3, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
};
__name(_RenderErrorBoundary, "RenderErrorBoundary");
let RenderErrorBoundary = _RenderErrorBoundary;
function RenderedRoute(_ref3) {
  let {
    routeContext,
    match: match2,
    children: children2
  } = _ref3, dataStaticRouterContext = reactExports.useContext(DataStaticRouterContext);
  return dataStaticRouterContext && match2.route.errorElement && (dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id), /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children2);
}
__name(RenderedRoute, "RenderedRoute");
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0 && (parentMatches = []), matches == null)
    if (dataRouterState != null && dataRouterState.errors)
      matches = dataRouterState.matches;
    else
      return null;
  let renderedMatches = matches, errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    errorIndex >= 0 || invariant(!1), renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error3 = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null, errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ reactExports.createElement(DefaultErrorElement, null) : null, getChildren = /* @__PURE__ */ __name(() => /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index + 1))
      }
    }, error3 ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet), "getChildren");
    return dataRouterState && (match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error3,
      children: getChildren()
    }) : getChildren();
  }, null);
}
__name(_renderMatches, "_renderMatches");
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2.UseRevalidator = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2.UseLoaderData = "useLoaderData", DataRouterStateHook2.UseActionData = "useActionData", DataRouterStateHook2.UseRouteError = "useRouteError", DataRouterStateHook2.UseNavigation = "useNavigation", DataRouterStateHook2.UseRouteLoaderData = "useRouteLoaderData", DataRouterStateHook2.UseMatches = "useMatches", DataRouterStateHook2.UseRevalidator = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  return state || invariant(!1), state;
}
__name(useDataRouterState, "useDataRouterState");
function useRouteError() {
  var _state$errors;
  let error3 = reactExports.useContext(RouteErrorContext), state = useDataRouterState(DataRouterStateHook$1.UseRouteError), route2 = reactExports.useContext(RouteContext), thisRoute = route2.matches[route2.matches.length - 1];
  return error3 || (route2 || invariant(!1), thisRoute.route.id || invariant(!1), (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id]);
}
__name(useRouteError, "useRouteError");
function Route(_props) {
  invariant(!1);
}
__name(Route, "Route");
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children: children2 = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = !1
  } = _ref4;
  useInRouterContext() && invariant(!1);
  let basename = basenameProp.replace(/^\/*/, "/"), navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  typeof locationProp == "string" && (locationProp = parsePath(locationProp));
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp, location = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    return trailingPathname == null ? null : {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search, hash2, state, key]);
  return location == null ? null : /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children: children2,
    value: {
      location,
      navigationType
    }
  }));
}
__name(Router, "Router");
function Routes(_ref5) {
  let {
    children: children2,
    location
  } = _ref5, dataRouterContext = reactExports.useContext(DataRouterContext), routes = dataRouterContext && !children2 ? dataRouterContext.router.routes : createRoutesFromChildren(children2);
  return useRoutes(routes, location);
}
__name(Routes, "Routes");
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2.pending = 0] = "pending", AwaitRenderStatus2[AwaitRenderStatus2.success = 1] = "success", AwaitRenderStatus2[AwaitRenderStatus2.error = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children2, parentPath) {
  parentPath === void 0 && (parentPath = []);
  let routes = [];
  return reactExports.Children.forEach(children2, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element))
      return;
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    element.type !== Route && invariant(!1), !element.props.index || !element.props.children || invariant(!1);
    let treePath = [...parentPath, index], route2 = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    element.props.children && (route2.children = createRoutesFromChildren(element.props.children, treePath)), routes.push(route2);
  }), routes;
}
__name(createRoutesFromChildren, "createRoutesFromChildren");
/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends$1.apply(this, arguments);
}
__name(_extends$1, "_extends$1");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {}, sourceKeys = Object.keys(source), key, i;
  for (i = 0; i < sourceKeys.length; i++)
    key = sourceKeys[i], !(excluded.indexOf(key) >= 0) && (target[key] = source[key]);
  return target;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function isModifiedEvent(event2) {
  return !!(event2.metaKey || event2.altKey || event2.ctrlKey || event2.shiftKey);
}
__name(isModifiedEvent, "isModifiedEvent");
function shouldProcessLinkClick(event2, target) {
  return event2.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event2);
}
__name(shouldProcessLinkClick, "shouldProcessLinkClick");
const _excluded$7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref3) {
  let {
    basename,
    children: children2,
    window: window2
  } = _ref3, historyRef = reactExports.useRef();
  historyRef.current == null && (historyRef.current = createBrowserHistory({
    window: window2,
    v5Compat: !0
  }));
  let history = historyRef.current, [state, setState] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  return reactExports.useLayoutEffect(() => history.listen(setState), [history]), /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children: children2,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
__name(BrowserRouter, "BrowserRouter");
const Link = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded$7), href = useHref(to, {
    relative
  }), internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event2) {
    onClick && onClick(event2), event2.defaultPrevented || internalOnClick(event2);
  }
  return __name(handleClick, "handleClick"), // eslint-disable-next-line jsx-a11y/anchor-has-content
  /* @__PURE__ */ reactExports.createElement("a", _extends$1({}, rest, {
    href,
    onClick: reloadDocument ? onClick : handleClick,
    ref,
    target
  }));
}, "LinkWithRef")), NavLink = /* @__PURE__ */ reactExports.forwardRef(/* @__PURE__ */ __name(function(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = !1,
    className: classNameProp = "",
    end: end2 = !1,
    style: styleProp,
    to,
    children: children2
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2$2), path = useResolvedPath(to, {
    relative: rest.relative
  }), location = useLocation(), routerState = reactExports.useContext(DataRouterStateContext), toPathname = path.pathname, locationPathname = location.pathname, nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  caseSensitive || (locationPathname = locationPathname.toLowerCase(), nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null, toPathname = toPathname.toLowerCase());
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/", isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/"), ariaCurrent = isActive ? ariaCurrentProp : void 0, className;
  typeof classNameProp == "function" ? className = classNameProp({
    isActive,
    isPending
  }) : className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  let style2 = typeof styleProp == "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$1({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to
  }), typeof children2 == "function" ? children2({
    isActive,
    isPending
  }) : children2);
}, "NavLinkWithRef"));
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2.UseScrollRestoration = "useScrollRestoration", DataRouterHook2.UseSubmitImpl = "useSubmitImpl", DataRouterHook2.UseFetcher = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2.UseFetchers = "useFetchers", DataRouterStateHook2.UseScrollRestoration = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp, navigate2 = useNavigate(), location = useLocation(), path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event2) => {
    if (shouldProcessLinkClick(event2, target)) {
      event2.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate2(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate2, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
__name(useLinkClickHandler, "useLinkClickHandler");
function _assertThisInitialized(self2) {
  if (self2 === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return self2;
}
__name(_assertThisInitialized, "_assertThisInitialized");
function _setPrototypeOf(o2, p2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function(o3, p3) {
    return o3.__proto__ = p3, o3;
  }, "_setPrototypeOf"), _setPrototypeOf(o2, p2);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _inherits(subClass, superClass) {
  if (typeof superClass != "function" && superClass !== null)
    throw new TypeError("Super expression must either be null or a function");
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(subClass, "prototype", {
    writable: !1
  }), superClass && _setPrototypeOf(subClass, superClass);
}
__name(_inherits, "_inherits");
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 == "function"))
    return call2;
  if (call2 !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(self2);
}
__name(_possibleConstructorReturn, "_possibleConstructorReturn");
function _getPrototypeOf(o2) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : /* @__PURE__ */ __name(function(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  }, "_getPrototypeOf"), _getPrototypeOf(o2);
}
__name(_getPrototypeOf, "_getPrototypeOf");
function _iterableToArray(iter) {
  if (typeof Symbol < "u" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
__name(_iterableToArray, "_iterableToArray");
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
__name(_toArray, "_toArray");
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$1, "ownKeys$1");
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread, "_objectSpread");
var consoleLogger = {
  type: "logger",
  log: /* @__PURE__ */ __name(function(args) {
    this.output("log", args);
  }, "log"),
  warn: /* @__PURE__ */ __name(function(args) {
    this.output("warn", args);
  }, "warn"),
  error: /* @__PURE__ */ __name(function(args) {
    this.output("error", args);
  }, "error"),
  output: /* @__PURE__ */ __name(function(type2, args) {
    console && console[type2] && console[type2].apply(console, args);
  }, "output")
}, Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2), this.init(concreteLogger, options2);
  }
  return __name(Logger2, "Logger"), _createClass(Logger2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:", this.logger = concreteLogger || consoleLogger, this.options = options2, this.debug = options2.debug;
    }, "init")
  }, {
    key: "setDebug",
    value: /* @__PURE__ */ __name(function(bool) {
      this.debug = bool;
    }, "setDebug")
  }, {
    key: "log",
    value: /* @__PURE__ */ __name(function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return this.forward(args, "log", "", !0);
    }, "log")
  }, {
    key: "warn",
    value: /* @__PURE__ */ __name(function() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)
        args[_key2] = arguments[_key2];
      return this.forward(args, "warn", "", !0);
    }, "warn")
  }, {
    key: "error",
    value: /* @__PURE__ */ __name(function() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)
        args[_key3] = arguments[_key3];
      return this.forward(args, "error", "");
    }, "error")
  }, {
    key: "deprecate",
    value: /* @__PURE__ */ __name(function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++)
        args[_key4] = arguments[_key4];
      return this.forward(args, "warn", "WARNING DEPRECATED: ", !0);
    }, "deprecate")
  }, {
    key: "forward",
    value: /* @__PURE__ */ __name(function(args, lvl, prefix2, debugOnly) {
      return debugOnly && !this.debug ? null : (typeof args[0] == "string" && (args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0])), this.logger[lvl](args));
    }, "forward")
  }, {
    key: "create",
    value: /* @__PURE__ */ __name(function(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }, "create")
  }]), Logger2;
}(), baseLogger = new Logger(), EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2), this.observers = {};
  }
  return __name(EventEmitter2, "EventEmitter"), _createClass(EventEmitter2, [{
    key: "on",
    value: /* @__PURE__ */ __name(function(events, listener) {
      var _this = this;
      return events.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [], _this.observers[event2].push(listener);
      }), this;
    }, "on")
  }, {
    key: "off",
    value: /* @__PURE__ */ __name(function(event2, listener) {
      if (this.observers[event2]) {
        if (!listener) {
          delete this.observers[event2];
          return;
        }
        this.observers[event2] = this.observers[event2].filter(function(l2) {
          return l2 !== listener;
        });
      }
    }, "off")
  }, {
    key: "emit",
    value: /* @__PURE__ */ __name(function(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
        args[_key - 1] = arguments[_key];
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }, "emit")
  }]), EventEmitter2;
}();
function defer() {
  var res, rej, promise = new Promise(function(resolve, reject2) {
    res = resolve, rej = reject2;
  });
  return promise.resolve = res, promise.reject = rej, promise;
}
__name(defer, "defer");
function makeString(object) {
  return object == null ? "" : "" + object;
}
__name(makeString, "makeString");
function copy$1(a2, s, t2) {
  a2.forEach(function(m2) {
    s[m2] && (t2[m2] = s[m2]);
  });
}
__name(copy$1, "copy$1");
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  __name(cleanKey, "cleanKey");
  function canNotTraverseDeeper() {
    return !object || typeof object == "string";
  }
  __name(canNotTraverseDeeper, "canNotTraverseDeeper");
  for (var stack = typeof path != "string" ? [].concat(path) : path.split("."); stack.length > 1; ) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    !object[key] && Empty && (object[key] = new Empty()), Object.prototype.hasOwnProperty.call(object, key) ? object = object[key] : object = {};
  }
  return canNotTraverseDeeper() ? {} : {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
__name(getLastOfPath, "getLastOfPath");
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
__name(setPath, "setPath");
function pushPath(object, path, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [], concat2 && (obj[k2] = obj[k2].concat(newValue)), concat2 || obj[k2].push(newValue);
}
__name(pushPath, "pushPath");
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (obj)
    return obj[k2];
}
__name(getPath, "getPath");
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  return value !== void 0 ? value : getPath(defaultData, key);
}
__name(getPathWithDefaults, "getPathWithDefaults");
function deepExtend(target, source, overwrite) {
  for (var prop in source)
    prop !== "__proto__" && prop !== "constructor" && (prop in target ? typeof target[prop] == "string" || target[prop] instanceof String || typeof source[prop] == "string" || source[prop] instanceof String ? overwrite && (target[prop] = source[prop]) : deepExtend(target[prop], source[prop], overwrite) : target[prop] = source[prop]);
  return target;
}
__name(deepExtend, "deepExtend");
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
__name(regexEscape, "regexEscape");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  return typeof data == "string" ? data.replace(/[&<>"'\/]/g, function(s) {
    return _entityMap[s];
  }) : data;
}
__name(escape, "escape");
var isIE10 = typeof window < "u" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1, chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "", keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return !0;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")")), matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    ki2 > 0 && !r2.test(key.substring(0, ki2)) && (matched = !0);
  }
  return matched;
}
__name(looksLikeObjectPath, "looksLikeObjectPath");
function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$1$1, "ownKeys$1$1");
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$1$1(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$1, "_objectSpread$1");
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$1, "_createSuper$1");
function _isNativeReflectConstruct$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$1, "_isNativeReflectConstruct$1");
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (obj) {
    if (obj[path])
      return obj[path];
    for (var paths = path.split(keySeparator), current = obj, i = 0; i < paths.length; ++i) {
      if (!current || typeof current[paths[i]] == "string" && i + 1 < paths.length)
        return;
      if (current[paths[i]] === void 0) {
        for (var j2 = 2, p2 = paths.slice(i, i + j2).join(keySeparator), mix = current[p2]; mix === void 0 && paths.length > i + j2; )
          j2++, p2 = paths.slice(i, i + j2).join(keySeparator), mix = current[p2];
        if (mix === void 0)
          return;
        if (path.endsWith(p2)) {
          if (typeof mix == "string")
            return mix;
          if (p2 && typeof mix[p2] == "string")
            return mix[p2];
        }
        var joinedPath = paths.slice(i + j2).join(keySeparator);
        return joinedPath ? deepFind(mix, joinedPath, keySeparator) : void 0;
      }
      current = current[paths[i]];
    }
    return current;
  }
}
__name(deepFind, "deepFind");
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$1(ResourceStore2);
  function ResourceStore2(data) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    return _classCallCheck(this, ResourceStore2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.data = data || {}, _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.options.ignoreJSONStructure === void 0 && (_this.options.ignoreJSONStructure = !0), _this;
  }
  return __name(ResourceStore2, "ResourceStore"), _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: /* @__PURE__ */ __name(function(ns2) {
      this.options.ns.indexOf(ns2) < 0 && this.options.ns.push(ns2);
    }, "addNamespaces")
  }, {
    key: "removeNamespaces",
    value: /* @__PURE__ */ __name(function(ns2) {
      var index = this.options.ns.indexOf(ns2);
      index > -1 && this.options.ns.splice(index, 1);
    }, "removeNamespaces")
  }, {
    key: "getResource",
    value: /* @__PURE__ */ __name(function(lng, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure, path = [lng, ns2];
      key && typeof key != "string" && (path = path.concat(key)), key && typeof key == "string" && (path = path.concat(keySeparator ? key.split(keySeparator) : key)), lng.indexOf(".") > -1 && (path = lng.split("."));
      var result = getPath(this.data, path);
      return result || !ignoreJSONStructure || typeof key != "string" ? result : deepFind(this.data && this.data[lng] && this.data[lng][ns2], key, keySeparator);
    }, "getResource")
  }, {
    key: "addResource",
    value: /* @__PURE__ */ __name(function(lng, ns2, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: !1
      }, keySeparator = this.options.keySeparator;
      keySeparator === void 0 && (keySeparator = ".");
      var path = [lng, ns2];
      key && (path = path.concat(keySeparator ? key.split(keySeparator) : key)), lng.indexOf(".") > -1 && (path = lng.split("."), value = ns2, ns2 = path[1]), this.addNamespaces(ns2), setPath(this.data, path, value), options2.silent || this.emit("added", lng, ns2, key, value);
    }, "addResource")
  }, {
    key: "addResources",
    value: /* @__PURE__ */ __name(function(lng, ns2, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: !1
      };
      for (var m2 in resources)
        (typeof resources[m2] == "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]") && this.addResource(lng, ns2, m2, resources[m2], {
          silent: !0
        });
      options2.silent || this.emit("added", lng, ns2, resources);
    }, "addResources")
  }, {
    key: "addResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: !1
      }, path = [lng, ns2];
      lng.indexOf(".") > -1 && (path = lng.split("."), deep = resources, resources = ns2, ns2 = path[1]), this.addNamespaces(ns2);
      var pack = getPath(this.data, path) || {};
      deep ? deepExtend(pack, resources, overwrite) : pack = _objectSpread$1(_objectSpread$1({}, pack), resources), setPath(this.data, path, pack), options2.silent || this.emit("added", lng, ns2, resources);
    }, "addResourceBundle")
  }, {
    key: "removeResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      this.hasResourceBundle(lng, ns2) && delete this.data[lng][ns2], this.removeNamespaces(ns2), this.emit("removed", lng, ns2);
    }, "removeResourceBundle")
  }, {
    key: "hasResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      return this.getResource(lng, ns2) !== void 0;
    }, "hasResourceBundle")
  }, {
    key: "getResourceBundle",
    value: /* @__PURE__ */ __name(function(lng, ns2) {
      return ns2 || (ns2 = this.options.defaultNS), this.options.compatibilityAPI === "v1" ? _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns2)) : this.getResource(lng, ns2);
    }, "getResourceBundle")
  }, {
    key: "getDataByLanguage",
    value: /* @__PURE__ */ __name(function(lng) {
      return this.data[lng];
    }, "getDataByLanguage")
  }, {
    key: "hasLanguageSomeTranslations",
    value: /* @__PURE__ */ __name(function(lng) {
      var data = this.getDataByLanguage(lng), n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }, "hasLanguageSomeTranslations")
  }, {
    key: "toJSON",
    value: /* @__PURE__ */ __name(function() {
      return this.data;
    }, "toJSON")
  }]), ResourceStore2;
}(EventEmitter), postProcessor = {
  processors: {},
  addPostProcessor: /* @__PURE__ */ __name(function(module) {
    this.processors[module.name] = module;
  }, "addPostProcessor"),
  handle: /* @__PURE__ */ __name(function(processors, value, key, options2, translator) {
    var _this = this;
    return processors.forEach(function(processor) {
      _this.processors[processor] && (value = _this.processors[processor].process(value, key, options2, translator));
    }), value;
  }, "handle")
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$2, "ownKeys$2");
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$2, "_objectSpread$2");
function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$1$1, "_createSuper$1$1");
function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$1$1, "_isNativeReflectConstruct$1$1");
var checkedLoadedFor = {}, Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1$1(Translator2);
  function Translator2(services) {
    var _this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return _classCallCheck(this, Translator2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), copy$1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this)), _this.options = options2, _this.options.keySeparator === void 0 && (_this.options.keySeparator = "."), _this.logger = baseLogger.create("translator"), _this;
  }
  return __name(Translator2, "Translator"), _createClass(Translator2, [{
    key: "changeLanguage",
    value: /* @__PURE__ */ __name(function(lng) {
      lng && (this.language = lng);
    }, "changeLanguage")
  }, {
    key: "exists",
    value: /* @__PURE__ */ __name(function(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key == null)
        return !1;
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }, "exists")
  }, {
    key: "extractFromKey",
    value: /* @__PURE__ */ __name(function(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      nsSeparator === void 0 && (nsSeparator = ":");
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, namespaces = options2.ns || this.options.defaultNS || [], wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1, seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0)
          return {
            key,
            namespaces
          };
        var parts = key.split(nsSeparator);
        (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) && (namespaces = parts.shift()), key = parts.join(keySeparator);
      }
      return typeof namespaces == "string" && (namespaces = [namespaces]), {
        key,
        namespaces
      };
    }, "extractFromKey")
  }, {
    key: "translate",
    value: /* @__PURE__ */ __name(function(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler && (options2 = this.options.overloadTranslationOptionHandler(arguments)), options2 || (options2 = {}), keys == null)
        return "";
      Array.isArray(keys) || (keys = [String(keys)]);
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator, _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces, namespace = namespaces[namespaces.length - 1], lng = options2.lng || this.language, appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2), res = resolved && resolved.res, resUsedKey = resolved && resolved.usedKey || key, resExactUsedKey = resolved && resolved.exactUsedKey || key, resType = Object.prototype.toString.apply(res), noObject = ["[object Number]", "[object Function]", "[object RegExp]"], joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays, handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject, handleAsObject = typeof res != "string" && typeof res != "boolean" && typeof res != "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays == "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects)
          return this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"), this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]", copy2 = resTypeIsArray ? [] : {}, newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res)
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: !1,
                ns: namespaces
              })), copy2[m2] === deepKey && (copy2[m2] = res[m2]);
            }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays == "string" && resType === "[object Array]")
        res = res.join(joinArrays), res && (res = this.extendTranslation(res, keys, options2, lastKey));
      else {
        var usedDefault = !1, usedKey = !1, needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", hasDefaultValue = Translator2.hasDefaultValue(options2), defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count, options2) : "", defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        !this.isValidLookup(res) && hasDefaultValue && (usedDefault = !0, res = defaultValue), this.isValidLookup(res) || (usedKey = !0, res = key);
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey, resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res, updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          if (this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res), keySeparator) {
            var fk2 = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: !1
            }));
            fk2 && fk2.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [], fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0])
            for (var i = 0; i < fallbackLngs.length; i++)
              lngs.push(fallbackLngs[i]);
          else
            this.options.saveMissingTo === "all" ? lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language) : lngs.push(options2.lng || this.language);
          var send2 = /* @__PURE__ */ __name(function(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            _this2.options.missingKeyHandler ? _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2) : _this2.backendConnector && _this2.backendConnector.saveMissing && _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2), _this2.emit("missingKey", l2, namespace, k2, res);
          }, "send");
          this.options.saveMissing && (this.options.saveMissingPlurals && needsPluralHandling ? lngs.forEach(function(language2) {
            _this2.pluralResolver.getSuffixes(language2, options2).forEach(function(suffix) {
              send2([language2], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
            });
          }) : send2(lngs, key, defaultValue));
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey), usedKey && res === key && this.options.appendNamespaceToMissingKey && (res = "".concat(namespace, ":").concat(key)), (usedKey || usedDefault) && this.options.parseMissingKeyHandler && (this.options.compatibilityAPI !== "v1" ? res = this.options.parseMissingKeyHandler(key, usedDefault ? res : void 0) : res = this.options.parseMissingKeyHandler(res));
      }
      return res;
    }, "translate")
  }, {
    key: "extendTranslation",
    value: /* @__PURE__ */ __name(function(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse)
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      else if (!options2.skipInterpolation) {
        options2.interpolation && this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
          interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
        }));
        var skipOnVariables = typeof res == "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables), nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data = options2.replace && typeof options2.replace != "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables && (data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data)), res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2), skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp), nestAft = na && na.length;
          nestBef < nestAft && (options2.nest = !1);
        }
        options2.nest !== !1 && (res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
            args[_key] = arguments[_key];
          return lastKey && lastKey[0] === args[0] && !options2.context ? (_this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0])), null) : _this3.translate.apply(_this3, args.concat([key]));
        }, options2)), options2.interpolation && this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess, postProcessorNames = typeof postProcess == "string" ? [postProcess] : postProcess;
      return res != null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== !1 && (res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
        i18nResolved: resolved
      }, options2) : options2, this)), res;
    }, "extendTranslation")
  }, {
    key: "resolve",
    value: /* @__PURE__ */ __name(function(keys) {
      var _this4 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, found, usedKey, exactUsedKey, usedLng, usedNS;
      return typeof keys == "string" && (keys = [keys]), keys.forEach(function(k2) {
        if (!_this4.isValidLookup(found)) {
          var extracted = _this4.extractFromKey(k2, options2), key = extracted.key;
          usedKey = key;
          var namespaces = extracted.namespaces;
          _this4.options.fallbackNS && (namespaces = namespaces.concat(_this4.options.fallbackNS));
          var needsPluralHandling = options2.count !== void 0 && typeof options2.count != "string", needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi(), needsContextHandling = options2.context !== void 0 && (typeof options2.context == "string" || typeof options2.context == "number") && options2.context !== "", codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
          namespaces.forEach(function(ns2) {
            _this4.isValidLookup(found) || (usedNS = ns2, !checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS) && (checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] = !0, _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), codes.forEach(function(code) {
              if (!_this4.isValidLookup(found)) {
                usedLng = code;
                var finalKeys = [key];
                if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys)
                  _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, options2);
                else {
                  var pluralSuffix;
                  needsPluralHandling && (pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2));
                  var zeroSuffix = "_zero";
                  if (needsPluralHandling && (finalKeys.push(key + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(key + zeroSuffix)), needsContextHandling) {
                    var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options2.context);
                    finalKeys.push(contextKey), needsPluralHandling && (finalKeys.push(contextKey + pluralSuffix), needsZeroSuffixLookup && finalKeys.push(contextKey + zeroSuffix));
                  }
                }
                for (var possibleKey; possibleKey = finalKeys.pop(); )
                  _this4.isValidLookup(found) || (exactUsedKey = possibleKey, found = _this4.getResource(code, ns2, possibleKey, options2));
              }
            }));
          });
        }
      }), {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }, "resolve")
  }, {
    key: "isValidLookup",
    value: /* @__PURE__ */ __name(function(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }, "isValidLookup")
  }, {
    key: "getResource",
    value: /* @__PURE__ */ __name(function(code, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      return this.i18nFormat && this.i18nFormat.getResource ? this.i18nFormat.getResource(code, ns2, key, options2) : this.resourceStore.getResource(code, ns2, key, options2);
    }, "getResource")
  }], [{
    key: "hasDefaultValue",
    value: /* @__PURE__ */ __name(function(options2) {
      var prefix2 = "defaultValue";
      for (var option in options2)
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && options2[option] !== void 0)
          return !0;
      return !1;
    }, "hasDefaultValue")
  }]), Translator2;
}(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
__name(capitalize, "capitalize");
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2), this.options = options2, this.supportedLngs = this.options.supportedLngs || !1, this.logger = baseLogger.create("languageUtils");
  }
  return __name(LanguageUtil2, "LanguageUtil"), _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      return p2.length === 2 || (p2.pop(), p2[p2.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(p2.join("-"));
    }, "getScriptPartFromCode")
  }, {
    key: "getLanguagePartFromCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }, "getLanguagePartFromCode")
  }, {
    key: "formatLanguageCode",
    value: /* @__PURE__ */ __name(function(code) {
      if (typeof code == "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"], p2 = code.split("-");
        return this.options.lowerCaseLng ? p2 = p2.map(function(part) {
          return part.toLowerCase();
        }) : p2.length === 2 ? (p2[0] = p2[0].toLowerCase(), p2[1] = p2[1].toUpperCase(), specialCases.indexOf(p2[1].toLowerCase()) > -1 && (p2[1] = capitalize(p2[1].toLowerCase()))) : p2.length === 3 && (p2[0] = p2[0].toLowerCase(), p2[1].length === 2 && (p2[1] = p2[1].toUpperCase()), p2[0] !== "sgn" && p2[2].length === 2 && (p2[2] = p2[2].toUpperCase()), specialCases.indexOf(p2[1].toLowerCase()) > -1 && (p2[1] = capitalize(p2[1].toLowerCase())), specialCases.indexOf(p2[2].toLowerCase()) > -1 && (p2[2] = capitalize(p2[2].toLowerCase()))), p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }, "formatLanguageCode")
  }, {
    key: "isSupportedCode",
    value: /* @__PURE__ */ __name(function(code) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (code = this.getLanguagePartFromCode(code)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }, "isSupportedCode")
  }, {
    key: "getBestMatchFromCodes",
    value: /* @__PURE__ */ __name(function(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      return codes.forEach(function(code) {
        if (!found) {
          var cleanedLng = _this.formatLanguageCode(code);
          (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) && (found = cleanedLng);
        }
      }), !found && this.options.supportedLngs && codes.forEach(function(code) {
        if (!found) {
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        }
      }), found || (found = this.getFallbackCodes(this.options.fallbackLng)[0]), found;
    }, "getBestMatchFromCodes")
  }, {
    key: "getFallbackCodes",
    value: /* @__PURE__ */ __name(function(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks == "function" && (fallbacks = fallbacks(code)), typeof fallbacks == "string" && (fallbacks = [fallbacks]), Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks.default || [];
      var found = fallbacks[code];
      return found || (found = fallbacks[this.getScriptPartFromCode(code)]), found || (found = fallbacks[this.formatLanguageCode(code)]), found || (found = fallbacks[this.getLanguagePartFromCode(code)]), found || (found = fallbacks.default), found || [];
    }, "getFallbackCodes")
  }, {
    key: "toResolveHierarchy",
    value: /* @__PURE__ */ __name(function(code, fallbackCode) {
      var _this2 = this, fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code), codes = [], addCode = /* @__PURE__ */ __name(function(c2) {
        c2 && (_this2.isSupportedCode(c2) ? codes.push(c2) : _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2)));
      }, "addCode");
      return typeof code == "string" && code.indexOf("-") > -1 ? (this.options.load !== "languageOnly" && addCode(this.formatLanguageCode(code)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && addCode(this.getScriptPartFromCode(code)), this.options.load !== "currentOnly" && addCode(this.getLanguagePartFromCode(code))) : typeof code == "string" && addCode(this.formatLanguageCode(code)), fallbackCodes.forEach(function(fc2) {
        codes.indexOf(fc2) < 0 && addCode(_this2.formatLanguageCode(fc2));
      }), codes;
    }, "toResolveHierarchy")
  }]), LanguageUtil2;
}(), sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}], _rulesPluralsTypes = {
  1: /* @__PURE__ */ __name(function(n2) {
    return +(n2 > 1);
  }, "_"),
  2: /* @__PURE__ */ __name(function(n2) {
    return +(n2 != 1);
  }, "_"),
  3: /* @__PURE__ */ __name(function(n2) {
    return 0;
  }, "_"),
  4: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  5: /* @__PURE__ */ __name(function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5;
  }, "_"),
  6: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2;
  }, "_"),
  7: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  8: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3;
  }, "_"),
  9: /* @__PURE__ */ __name(function(n2) {
    return +(n2 >= 2);
  }, "_"),
  10: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4;
  }, "_"),
  11: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3;
  }, "_"),
  12: /* @__PURE__ */ __name(function(n2) {
    return +(n2 % 10 != 1 || n2 % 100 == 11);
  }, "_"),
  13: /* @__PURE__ */ __name(function(n2) {
    return +(n2 !== 0);
  }, "_"),
  14: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3;
  }, "_"),
  15: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2;
  }, "_"),
  16: /* @__PURE__ */ __name(function(n2) {
    return n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2;
  }, "_"),
  17: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1;
  }, "_"),
  18: /* @__PURE__ */ __name(function(n2) {
    return n2 == 0 ? 0 : n2 == 1 ? 1 : 2;
  }, "_"),
  19: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3;
  }, "_"),
  20: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2;
  }, "_"),
  21: /* @__PURE__ */ __name(function(n2) {
    return n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0;
  }, "_"),
  22: /* @__PURE__ */ __name(function(n2) {
    return n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3;
  }, "_")
}, deprecatedJsonVersions = ["v1", "v2", "v3"], suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  return sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  }), rules;
}
__name(createRules, "createRules");
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2), this.languageUtils = languageUtils, this.options = options2, this.logger = baseLogger.create("pluralResolver"), (!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl > "u" || !Intl.PluralRules) && (this.options.compatibilityJSON = "v3", this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.")), this.rules = createRules();
  }
  return __name(PluralResolver2, "PluralResolver"), _createClass(PluralResolver2, [{
    key: "addRule",
    value: /* @__PURE__ */ __name(function(lng, obj) {
      this.rules[lng] = obj;
    }, "addRule")
  }, {
    key: "getRule",
    value: /* @__PURE__ */ __name(function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi())
        try {
          return new Intl.PluralRules(code, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch {
          return;
        }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }, "getRule")
  }, {
    key: "needsPlural",
    value: /* @__PURE__ */ __name(function(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return this.shouldUseIntlApi() ? rule && rule.resolvedOptions().pluralCategories.length > 1 : rule && rule.numbers.length > 1;
    }, "needsPlural")
  }, {
    key: "getPluralFormsOfKey",
    value: /* @__PURE__ */ __name(function(code, key) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options2).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }, "getPluralFormsOfKey")
  }, {
    key: "getSuffixes",
    value: /* @__PURE__ */ __name(function(code) {
      var _this = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
        return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
      }).map(function(pluralCategory) {
        return "".concat(_this.options.prepend).concat(pluralCategory);
      }) : rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options2);
      }) : [];
    }, "getSuffixes")
  }, {
    key: "getSuffix",
    value: /* @__PURE__ */ __name(function(code, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, rule = this.getRule(code, options2);
      return rule ? this.shouldUseIntlApi() ? "".concat(this.options.prepend).concat(rule.select(count)) : this.getSuffixRetroCompatible(rule, count) : (this.logger.warn("no plural rule found for: ".concat(code)), "");
    }, "getSuffix")
  }, {
    key: "getSuffixRetroCompatible",
    value: /* @__PURE__ */ __name(function(rule, count) {
      var _this2 = this, idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count)), suffix = rule.numbers[idx];
      this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 && (suffix === 2 ? suffix = "plural" : suffix === 1 && (suffix = ""));
      var returnSuffix = /* @__PURE__ */ __name(function() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      }, "returnSuffix");
      return this.options.compatibilityJSON === "v1" ? suffix === 1 ? "" : typeof suffix == "number" ? "_plural_".concat(suffix.toString()) : returnSuffix() : this.options.compatibilityJSON === "v2" || this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1 ? returnSuffix() : this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }, "getSuffixRetroCompatible")
  }, {
    key: "shouldUseIntlApi",
    value: /* @__PURE__ */ __name(function() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }, "shouldUseIntlApi")
  }]), PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$3, "ownKeys$3");
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$3, "_objectSpread$3");
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2), this.logger = baseLogger.create("interpolator"), this.options = options2, this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    }, this.init(options2);
  }
  return __name(Interpolator2, "Interpolator"), _createClass(Interpolator2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      options2.interpolation || (options2.interpolation = {
        escapeValue: !0
      });
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape, this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : !0, this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : !1, this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{", this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}", this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",", this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-", this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "", this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t("), this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")"), this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",", this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3, this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : !1, this.resetRegExp();
    }, "init")
  }, {
    key: "reset",
    value: /* @__PURE__ */ __name(function() {
      this.options && this.init(this.options);
    }, "reset")
  }, {
    key: "resetRegExp",
    value: /* @__PURE__ */ __name(function() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }, "resetRegExp")
  }, {
    key: "interpolate",
    value: /* @__PURE__ */ __name(function(str, data, lng, options2) {
      var _this = this, match2, value, replaces, defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      __name(regexSafe, "regexSafe");
      var handleFormat = /* @__PURE__ */ __name(function(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator), k2 = p2.shift().trim(), f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
          interpolationkey: k2
        }));
      }, "handleFormat");
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler, skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables, todos = [{
        regex: this.regexpUnescape,
        safeValue: /* @__PURE__ */ __name(function(val) {
          return regexSafe(val);
        }, "safeValue")
      }, {
        regex: this.regexp,
        safeValue: /* @__PURE__ */ __name(function(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }, "safeValue")
      }];
      return todos.forEach(function(todo) {
        for (replaces = 0; match2 = todo.regex.exec(str); ) {
          var matchedVar = match2[1].trim();
          if (value = handleFormat(matchedVar), value === void 0)
            if (typeof missingInterpolationHandler == "function") {
              var temp = missingInterpolationHandler(str, match2, options2);
              value = typeof temp == "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar))
              value = "";
            else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str)), value = "";
          else
            typeof value != "string" && !_this.useRawValueToEscape && (value = makeString(value));
          var safeValue = todo.safeValue(value);
          if (str = str.replace(match2[0], safeValue), skipOnVariables ? (todo.regex.lastIndex += safeValue.length, todo.regex.lastIndex -= match2[0].length) : todo.regex.lastIndex = 0, replaces++, replaces >= _this.maxReplaces)
            break;
        }
      }), str;
    }, "interpolate")
  }, {
    key: "nest",
    value: /* @__PURE__ */ __name(function(str, fc2) {
      var _this2 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, match2, value, clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = !1, delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{"))), optionsString = "{".concat(c2[1]);
        key = c2[0], optionsString = this.interpolate(optionsString, clonedOptions), optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString), inheritedOptions && (clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions));
        } catch (e2) {
          return this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2), "".concat(key).concat(sep).concat(optionsString);
        }
        return delete clonedOptions.defaultValue, key;
      }
      for (__name(handleHasOptions, "handleHasOptions"); match2 = this.nestingRegexp.exec(str); ) {
        var formatters = [], doReduce = !1;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift(), formatters = r2, doReduce = !0;
        }
        if (value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions), value && match2[0] === str && typeof value != "string")
          return value;
        typeof value != "string" && (value = makeString(value)), value || (this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str)), value = ""), doReduce && (value = formatters.reduce(function(v2, f2) {
          return _this2.format(v2, f2, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
            interpolationkey: match2[1].trim()
          }));
        }, value.trim())), str = str.replace(match2[0], value), this.regexp.lastIndex = 0;
      }
      return str;
    }, "nest")
  }]), Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$4, "ownKeys$4");
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$4, "_objectSpread$4");
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim(), formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0)
      formatOptions.currency || (formatOptions.currency = optStr.trim());
    else if (formatName === "relativetime" && optStr.indexOf(":") < 0)
      formatOptions.range || (formatOptions.range = optStr.trim());
    else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (opt) {
          var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1), val = rest.join(":");
          formatOptions[key.trim()] || (formatOptions[key.trim()] = val.trim()), val.trim() === "false" && (formatOptions[key.trim()] = !1), val.trim() === "true" && (formatOptions[key.trim()] = !0), isNaN(val.trim()) || (formatOptions[key.trim()] = parseInt(val.trim(), 10));
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
__name(parseFormatStr, "parseFormatStr");
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2), this.logger = baseLogger.create("formatter"), this.options = options2, this.formats = {
      number: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.NumberFormat(lng, options3).format(val);
      }, "number"),
      currency: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        })).format(val);
      }, "currency"),
      datetime: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options3)).format(val);
      }, "datetime"),
      relativetime: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options3)).format(val, options3.range || "day");
      }, "relativetime"),
      list: /* @__PURE__ */ __name(function(val, lng, options3) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options3)).format(val);
      }, "list")
    }, this.init(options2);
  }
  return __name(Formatter2, "Formatter"), _createClass(Formatter2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      }, iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }, "init")
  }, {
    key: "add",
    value: /* @__PURE__ */ __name(function(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }, "add")
  }, {
    key: "format",
    value: /* @__PURE__ */ __name(function(value, _format, lng, options2) {
      var _this = this, formats = _format.split(this.formatSeparator), result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {}, l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else
          _this.logger.warn("there was no format function for ".concat(formatName));
        return mem;
      }, value);
      return result;
    }, "format")
  }]), Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$5, "ownKeys$5");
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$5, "_objectSpread$5");
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$2, "_createSuper$2");
function _isNativeReflectConstruct$2() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$2, "_isNativeReflectConstruct$2");
function remove(arr, what) {
  for (var found = arr.indexOf(what); found !== -1; )
    arr.splice(found, 1), found = arr.indexOf(what);
}
__name(remove, "remove");
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this, options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return _classCallCheck(this, Connector2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.backend = backend, _this.store = store, _this.services = services, _this.languageUtils = services.languageUtils, _this.options = options2, _this.logger = baseLogger.create("backendConnector"), _this.state = {}, _this.queue = [], _this.backend && _this.backend.init && _this.backend.init(services, options2.backend, options2), _this;
  }
  return __name(Connector2, "Connector"), _createClass(Connector2, [{
    key: "queueLoad",
    value: /* @__PURE__ */ __name(function(languages, namespaces, options2, callback2) {
      var _this2 = this, toLoad = [], pending2 = [], toLoadLanguages = [], toLoadNamespaces = [];
      return languages.forEach(function(lng) {
        var hasAllNamespaces = !0;
        namespaces.forEach(function(ns2) {
          var name = "".concat(lng, "|").concat(ns2);
          !options2.reload && _this2.store.hasResourceBundle(lng, ns2) ? _this2.state[name] = 2 : _this2.state[name] < 0 || (_this2.state[name] === 1 ? pending2.indexOf(name) < 0 && pending2.push(name) : (_this2.state[name] = 1, hasAllNamespaces = !1, pending2.indexOf(name) < 0 && pending2.push(name), toLoad.indexOf(name) < 0 && toLoad.push(name), toLoadNamespaces.indexOf(ns2) < 0 && toLoadNamespaces.push(ns2)));
        }), hasAllNamespaces || toLoadLanguages.push(lng);
      }), (toLoad.length || pending2.length) && this.queue.push({
        pending: pending2,
        loaded: {},
        errors: [],
        callback: callback2
      }), {
        toLoad,
        pending: pending2,
        toLoadLanguages,
        toLoadNamespaces
      };
    }, "queueLoad")
  }, {
    key: "loaded",
    value: /* @__PURE__ */ __name(function(name, err, data) {
      var s = name.split("|"), lng = s[0], ns2 = s[1];
      err && this.emit("failedLoading", lng, ns2, err), data && this.store.addResourceBundle(lng, ns2, data), this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns2), remove(q2.pending, name), err && q2.errors.push(err), q2.pending.length === 0 && !q2.done && (Object.keys(q2.loaded).forEach(function(l2) {
          loaded2[l2] || (loaded2[l2] = []), q2.loaded[l2].length && q2.loaded[l2].forEach(function(ns3) {
            loaded2[l2].indexOf(ns3) < 0 && loaded2[l2].push(ns3);
          });
        }), q2.done = !0, q2.errors.length ? q2.callback(q2.errors) : q2.callback());
      }), this.emit("loaded", loaded2), this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }, "loaded")
  }, {
    key: "read",
    value: /* @__PURE__ */ __name(function(lng, ns2, fcName) {
      var _this3 = this, tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350, callback2 = arguments.length > 5 ? arguments[5] : void 0;
      return lng.length ? this.backend[fcName](lng, ns2, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns2, fcName, tried + 1, wait2 * 2, callback2);
          }, wait2);
          return;
        }
        callback2(err, data);
      }) : callback2(null, {});
    }, "read")
  }, {
    key: "prepareLoading",
    value: /* @__PURE__ */ __name(function(languages, namespaces) {
      var _this4 = this, options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, callback2 = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend)
        return this.logger.warn("No backend was added via i18next.use. Will not load resources."), callback2 && callback2();
      typeof languages == "string" && (languages = this.languageUtils.toResolveHierarchy(languages)), typeof namespaces == "string" && (namespaces = [namespaces]);
      var toLoad = this.queueLoad(languages, namespaces, options2, callback2);
      if (!toLoad.toLoad.length)
        return toLoad.pending.length || callback2(), null;
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }, "prepareLoading")
  }, {
    key: "load",
    value: /* @__PURE__ */ __name(function(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {}, callback2);
    }, "load")
  }, {
    key: "reload",
    value: /* @__PURE__ */ __name(function(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {
        reload: !0
      }, callback2);
    }, "reload")
  }, {
    key: "loadOne",
    value: /* @__PURE__ */ __name(function(name) {
      var _this5 = this, prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "", s = name.split("|"), lng = s[0], ns2 = s[1];
      this.read(lng, ns2, "read", void 0, void 0, function(err, data) {
        err && _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns2, " for language ").concat(lng, " failed"), err), !err && data && _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns2, " for language ").concat(lng), data), _this5.loaded(name, err, data);
      });
    }, "loadOne")
  }, {
    key: "saveMissing",
    value: /* @__PURE__ */ __name(function(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      key == null || key === "" || (this.backend && this.backend.create && this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
        isUpdate
      })), !(!languages || !languages[0]) && this.store.addResource(languages[0], namespace, key, fallbackValue));
    }, "saveMissing")
  }]), Connector2;
}(EventEmitter);
function get() {
  return {
    debug: !1,
    initImmediate: !0,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: !1,
    supportedLngs: !1,
    nonExplicitSupportedLngs: !1,
    load: "all",
    preload: !1,
    simplifyPluralSuffix: !0,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: !1,
    saveMissing: !1,
    updateMissing: !1,
    saveMissingTo: "fallback",
    saveMissingPlurals: !0,
    missingKeyHandler: !1,
    missingInterpolationHandler: !1,
    postProcess: !1,
    postProcessPassResolved: !1,
    returnNull: !0,
    returnEmptyString: !0,
    returnObjects: !1,
    joinArrays: !1,
    returnedObjectHandler: !1,
    parseMissingKeyHandler: !1,
    appendNamespaceToMissingKey: !1,
    appendNamespaceToCIMode: !1,
    overloadTranslationOptionHandler: /* @__PURE__ */ __name(function(args) {
      var ret = {};
      if (_typeof(args[1]) === "object" && (ret = args[1]), typeof args[1] == "string" && (ret.defaultValue = args[1]), typeof args[2] == "string" && (ret.tDescription = args[2]), _typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    }, "handle"),
    interpolation: {
      escapeValue: !0,
      format: /* @__PURE__ */ __name(function(value, _format, lng, options2) {
        return value;
      }, "format"),
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: !0
    }
  };
}
__name(get, "get");
function transformOptions(options2) {
  return typeof options2.ns == "string" && (options2.ns = [options2.ns]), typeof options2.fallbackLng == "string" && (options2.fallbackLng = [options2.fallbackLng]), typeof options2.fallbackNS == "string" && (options2.fallbackNS = [options2.fallbackNS]), options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0 && (options2.supportedLngs = options2.supportedLngs.concat(["cimode"])), options2;
}
__name(transformOptions, "transformOptions");
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }
  return keys;
}
__name(ownKeys$6, "ownKeys$6");
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), !0).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
__name(_objectSpread$6, "_objectSpread$6");
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper$3, "_createSuper$3");
function _isNativeReflectConstruct$3() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct$3, "_isNativeReflectConstruct$3");
function noop$1() {
}
__name(noop$1, "noop$1");
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    typeof inst[mem] == "function" && (inst[mem] = inst[mem].bind(inst));
  });
}
__name(bindMemberFunctions, "bindMemberFunctions");
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
    if (_classCallCheck(this, I18n2), _this = _super.call(this), isIE10 && EventEmitter.call(_assertThisInitialized(_this)), _this.options = transformOptions(options2), _this.services = {}, _this.logger = baseLogger, _this.modules = {
      external: []
    }, bindMemberFunctions(_assertThisInitialized(_this)), callback2 && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate)
        return _this.init(options2, callback2), _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      setTimeout(function() {
        _this.init(options2, callback2);
      }, 0);
    }
    return _this;
  }
  return __name(I18n2, "I18n"), _createClass(I18n2, [{
    key: "init",
    value: /* @__PURE__ */ __name(function() {
      var _this2 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
      typeof options2 == "function" && (callback2 = options2, options2 = {}), !options2.defaultNS && options2.ns && (typeof options2.ns == "string" ? options2.defaultNS = options2.ns : options2.ns.indexOf("translation") < 0 && (options2.defaultNS = options2.ns[0]));
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2)), this.options.compatibilityAPI !== "v1" && (this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation)), options2.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = options2.keySeparator), options2.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = options2.nsSeparator);
      function createClassOnDemand(ClassOrObject) {
        return ClassOrObject ? typeof ClassOrObject == "function" ? new ClassOrObject() : ClassOrObject : null;
      }
      if (__name(createClassOnDemand, "createClassOnDemand"), !this.options.isClone) {
        this.modules.logger ? baseLogger.init(createClassOnDemand(this.modules.logger), this.options) : baseLogger.init(null, this.options);
        var formatter;
        this.modules.formatter ? formatter = this.modules.formatter : typeof Intl < "u" && (formatter = Formatter);
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger, s.resourceStore = this.store, s.languageUtils = lu, s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        }), formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format) && (s.formatter = createClassOnDemand(formatter), s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new Interpolator(this.options), s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        }, s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
            args[_key - 1] = arguments[_key];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.languageDetector && (s.languageDetector = createClassOnDemand(this.modules.languageDetector), s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = createClassOnDemand(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new Translator(this.services, this.options), this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
            args[_key2 - 1] = arguments[_key2];
          _this2.emit.apply(_this2, [event2].concat(args));
        }), this.modules.external.forEach(function(m2) {
          m2.init && m2.init(_this2);
        });
      }
      if (this.format = this.options.interpolation.format, callback2 || (callback2 = noop$1), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        codes.length > 0 && codes[0] !== "dev" && (this.options.lng = codes[0]);
      }
      !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined");
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          return (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments), _this2;
        };
      });
      var deferred = defer(), load2 = /* @__PURE__ */ __name(function() {
        var finish2 = /* @__PURE__ */ __name(function(err, t2) {
          _this2.isInitialized && !_this2.initializedStoreOnce && _this2.logger.warn("init: i18next is already initialized. You should call init just once!"), _this2.isInitialized = !0, _this2.options.isClone || _this2.logger.log("initialized", _this2.options), _this2.emit("initialized", _this2.options), deferred.resolve(t2), callback2(err, t2);
        }, "finish");
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish2(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish2);
      }, "load");
      return this.options.resources || !this.options.initImmediate ? load2() : setTimeout(load2, 0), deferred;
    }, "init")
  }, {
    key: "loadResources",
    value: /* @__PURE__ */ __name(function(language2) {
      var _this3 = this, callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1, usedCallback = callback2, usedLng = typeof language2 == "string" ? language2 : this.language;
      if (typeof language2 == "function" && (usedCallback = language2), !this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [], append2 = /* @__PURE__ */ __name(function(lng) {
          if (lng) {
            var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
            lngs.forEach(function(l2) {
              toLoad.indexOf(l2) < 0 && toLoad.push(l2);
            });
          }
        }, "append");
        if (usedLng)
          append2(usedLng);
        else {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.options.preload && this.options.preload.forEach(function(l2) {
          return append2(l2);
        }), this.services.backendConnector.load(toLoad, this.options.ns, function(e2) {
          !e2 && !_this3.resolvedLanguage && _this3.language && _this3.setResolvedLanguage(_this3.language), usedCallback(e2);
        });
      } else
        usedCallback(null);
    }, "loadResources")
  }, {
    key: "reloadResources",
    value: /* @__PURE__ */ __name(function(lngs, ns2, callback2) {
      var deferred = defer();
      return lngs || (lngs = this.languages), ns2 || (ns2 = this.options.ns), callback2 || (callback2 = noop$1), this.services.backendConnector.reload(lngs, ns2, function(err) {
        deferred.resolve(), callback2(err);
      }), deferred;
    }, "reloadResources")
  }, {
    key: "use",
    value: /* @__PURE__ */ __name(function(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return module.type === "backend" && (this.modules.backend = module), (module.type === "logger" || module.log && module.warn && module.error) && (this.modules.logger = module), module.type === "languageDetector" && (this.modules.languageDetector = module), module.type === "i18nFormat" && (this.modules.i18nFormat = module), module.type === "postProcessor" && postProcessor.addPostProcessor(module), module.type === "formatter" && (this.modules.formatter = module), module.type === "3rdParty" && this.modules.external.push(module), this;
    }, "use")
  }, {
    key: "setResolvedLanguage",
    value: /* @__PURE__ */ __name(function(l2) {
      if (!(!l2 || !this.languages) && !(["cimode", "dev"].indexOf(l2) > -1))
        for (var li2 = 0; li2 < this.languages.length; li2++) {
          var lngInLngs = this.languages[li2];
          if (!(["cimode", "dev"].indexOf(lngInLngs) > -1) && this.store.hasLanguageSomeTranslations(lngInLngs)) {
            this.resolvedLanguage = lngInLngs;
            break;
          }
        }
    }, "setResolvedLanguage")
  }, {
    key: "changeLanguage",
    value: /* @__PURE__ */ __name(function(lng, callback2) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = /* @__PURE__ */ __name(function(l2) {
        _this4.language = l2, _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2), _this4.resolvedLanguage = void 0, _this4.setResolvedLanguage(l2);
      }, "setLngProps"), done = /* @__PURE__ */ __name(function(err, l2) {
        l2 ? (setLngProps(l2), _this4.translator.changeLanguage(l2), _this4.isLanguageChangingTo = void 0, _this4.emit("languageChanged", l2), _this4.logger.log("languageChanged", l2)) : _this4.isLanguageChangingTo = void 0, deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        }), callback2 && callback2(err, function() {
          return _this4.t.apply(_this4, arguments);
        });
      }, "done"), setLng = /* @__PURE__ */ __name(function(lngs) {
        !lng && !lngs && _this4.services.languageDetector && (lngs = []);
        var l2 = typeof lngs == "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        l2 && (_this4.language || setLngProps(l2), _this4.translator.language || _this4.translator.changeLanguage(l2), _this4.services.languageDetector && _this4.services.languageDetector.cacheUserLanguage(l2)), _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      }, "setLng");
      return !lng && this.services.languageDetector && !this.services.languageDetector.async ? setLng(this.services.languageDetector.detect()) : !lng && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect(setLng) : setLng(lng), deferred;
    }, "changeLanguage")
  }, {
    key: "getFixedT",
    value: /* @__PURE__ */ __name(function(lng, ns2, keyPrefix) {
      var _this5 = this, fixedT = /* @__PURE__ */ __name(function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++)
            rest[_key3 - 2] = arguments[_key3];
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else
          options2 = _objectSpread$6({}, opts);
        options2.lng = options2.lng || fixedT2.lng, options2.lngs = options2.lngs || fixedT2.lngs, options2.ns = options2.ns || fixedT2.ns;
        var keySeparator = _this5.options.keySeparator || ".", resultKey = keyPrefix ? "".concat(keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options2);
      }, "fixedT");
      return typeof lng == "string" ? fixedT.lng = lng : fixedT.lngs = lng, fixedT.ns = ns2, fixedT.keyPrefix = keyPrefix, fixedT;
    }, "getFixedT")
  }, {
    key: "t",
    value: /* @__PURE__ */ __name(function() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }, "t")
  }, {
    key: "exists",
    value: /* @__PURE__ */ __name(function() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }, "exists")
  }, {
    key: "setDefaultNamespace",
    value: /* @__PURE__ */ __name(function(ns2) {
      this.options.defaultNS = ns2;
    }, "setDefaultNamespace")
  }, {
    key: "hasLoadedNamespace",
    value: /* @__PURE__ */ __name(function(ns2) {
      var _this6 = this, options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized)
        return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length)
        return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      var lng = this.resolvedLanguage || this.languages[0], fallbackLng = this.options ? this.options.fallbackLng : !1, lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return !0;
      var loadNotPending = /* @__PURE__ */ __name(function(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      }, "loadNotPending");
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      return !!(this.hasResourceBundle(lng, ns2) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)));
    }, "hasLoadedNamespace")
  }, {
    key: "loadNamespaces",
    value: /* @__PURE__ */ __name(function(ns2, callback2) {
      var _this7 = this, deferred = defer();
      return this.options.ns ? (typeof ns2 == "string" && (ns2 = [ns2]), ns2.forEach(function(n2) {
        _this7.options.ns.indexOf(n2) < 0 && _this7.options.ns.push(n2);
      }), this.loadResources(function(err) {
        deferred.resolve(), callback2 && callback2(err);
      }), deferred) : (callback2 && callback2(), Promise.resolve());
    }, "loadNamespaces")
  }, {
    key: "loadLanguages",
    value: /* @__PURE__ */ __name(function(lngs, callback2) {
      var deferred = defer();
      typeof lngs == "string" && (lngs = [lngs]);
      var preloaded = this.options.preload || [], newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      return newLngs.length ? (this.options.preload = preloaded.concat(newLngs), this.loadResources(function(err) {
        deferred.resolve(), callback2 && callback2(err);
      }), deferred) : (callback2 && callback2(), Promise.resolve());
    }, "loadLanguages")
  }, {
    key: "dir",
    value: /* @__PURE__ */ __name(function(lng) {
      if (lng || (lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language)), !lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }, "dir")
  }, {
    key: "cloneInstance",
    value: /* @__PURE__ */ __name(function() {
      var _this8 = this, options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1, mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: !0
      }), clone = new I18n2(mergedOptions), membersToCopy = ["store", "services", "language"];
      return membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      }), clone.services = _objectSpread$6({}, this.services), clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone.translator = new Translator(clone.services, clone.options), clone.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)
          args[_key4 - 1] = arguments[_key4];
        clone.emit.apply(clone, [event2].concat(args));
      }), clone.init(mergedOptions, callback2), clone.translator.options = clone.options, clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      }, clone;
    }, "cloneInstance")
  }, {
    key: "toJSON",
    value: /* @__PURE__ */ __name(function() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }, "toJSON")
  }]), I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, callback2 = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback2);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
var t$1 = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const getNativeLocale = /* @__PURE__ */ __name(() => apiGet("native-locale"), "getNativeLocale"), account$i = {
  disconnect: "انقطع الاتصال. جاري اعادة المحاولة...",
  export: "تصدير",
  exportTransactions: "تصدير التداولات الى مجلد الداونلود على شكل ملف CSV",
  fatalError: "حدث خطأ غير متوقع",
  incoming: "قادمة الآن",
  initializing: "جلب البيانات من البلوكشين...",
  maybeProxyError: "تم تفعيل بروكسي تور. يرجى التأكد من ان بروكسي تور يعمل بشكل صحيح او قم بايقاف اعدادات البروكسي",
  reconnecting: "انقطع الاتصال, جاري محاولة اعادة الاتصال...",
  syncedAddressesCount: "تم فحص {{count}} عنوان"
}, accountInfo$i = {
  address: "عنوان",
  buyCTA: {
    buy: "شراء {{unit}}",
    buyCrypto: "شراء كريبتو",
    information: {
      looksEmpty: "يبدو ان هذه المحفظة فارغة",
      start: "إبدأ عن طريق ايداع بعض العملات في المحفظة او شراء العملات مباشرةً في تطبيق BitBoxApp"
    }
  },
  extendedPublicKey: "المفتاح العام المتشعب",
  label: "معلومات الحساب",
  scriptType: "نوع النص البرمجي",
  title: "معلومات الحساب",
  verify: "قم بالتأكيد عن طريق الجهاز",
  xpubTypeChangeBtn: {
    p2pkh: "عرض المفتاح العام المتشعب عن طريق P2PKH القديم",
    p2tr: "عرض تابروت",
    p2wpkh: "عرض Segwit الاصلي",
    "p2wpkh-p2sh": "عرض المفتاح العام المتشعب عن طريق Segwit القديم"
  },
  xpubTypeInfo: "الآن يتم عرض {{scriptType}} للمفتاح العلني المتشعب ({{current}} من {{numberOfXPubs}})"
}, accountSummary$i = {
  availableBalance: "الرصيد المتبقي",
  balance: "الرصيد",
  exportSummary: "قم بتصدير خلاصة الحسابات الى مجلد الداونلود على شكل ملف CSV",
  fiatBalance: "رصيد العملة النقدية",
  name: "اسم الحساب",
  noAccount: "لا توجد حسابات للعرض",
  subtotalWithCoinName: "مجموع ({{coinName}})",
  title: "بورتفوليو حسابي",
  total: "المجموع",
  transactionHistory: "تاريخ التداولات"
}, addAccount$j = {
  chooseName: {
    nextButton: "اضافة حساب",
    step: "تسمية الحساب",
    title: "قم بتسمية الحساب"
  },
  selectCoin: {
    nextButton: "التالي",
    step: "اختر عملة",
    title: "اختر عملة كريبتو"
  },
  success: {
    message: "تمت اضافة <strong>{{accountName}}</strong> الى حساباتك",
    nextButton: "اكتمل",
    step: "انتهى",
    title: "تم اضافة الحساب"
  },
  title: "اضافة حساب"
}, aopp$c = {
  addressRequest: "الـ{{host}} يطلب عنوان استلام",
  addressRequestWithLogo: "يطلب عنوان استلام",
  banner: "جاري طلب عنوان",
  errorTitle: "حدث خطأ اثناء عملية طلب العنوان",
  labelAddress: "عنوان",
  labelMessage: "رسالة",
  reverifyInfoText: "تأكيد العنوان",
  signing: "للاستمرار, قم بتوقيع الرسالة على جهاز BitBox02",
  success: {
    message: "استمر على {{host}}",
    title: "تم ارسال العنوان بنجاح"
  },
  syncing: "يتم الآن عمل مزامنة للحساب, يرجى الانتظار",
  title: "طلب عنوان"
}, app$i = {
  upgrade: "تتوفر الآن نسخة جديدة لهذا التطبيق. يرجى التحديث من {{current}} الى {{version}}"
}, backup$i = {
  check: {
    checking: "التحقق من النسخة الاحتياطية...",
    confirmTitle: "قم بالتحقق من النسخة الاحتياطية",
    notOK: "النسخة الاحتياطية لا تطابق المحفظة",
    ok: "النسخة الاحتياطية تطابق المحفظة",
    password: {
      label: "استعادة كلمة المرور",
      placeholder: "استعادة كلمة المرور",
      showLabel: "استعادة كلمة المرور"
    },
    success: "تم التأكد بنجاح من النسخة الاحتياطية",
    title: "قم بالتحقق من النسخة الاحتياطية"
  },
  create: {
    alreadyExists: "يوجد لديك نسخة احتياطية صالحة, هل تريد انشاء نسخة جديدة؟",
    fail: "فشلت عملية انشاء نسخة احتياطية",
    info: "يرجى ادخال كلمة استعادة المرور لهذه المحفظة من اجل التحقق",
    name: {
      label: "اسم النسخة الاحتياطية",
      placeholder: "يرجى تسمية النسخة الاحتياطية"
    },
    password: {
      label: "استعادة كلمة المرور",
      placeholder: "يرجى ادخال كلمة استعادة المرور"
    },
    title: "قم بانشاء نسخة الاحتياطية",
    verificationFailed: "كلمة استعادة المرور لا تطابق هذه المحفظة. تم انشاء النسخة الاحتياطية. يرجى استخدام ‘التحقق من النسخة الاحتياطية‘ لتأكيد كلمة استعادة المرور مرة ثانية"
  },
  description: "اختر<strong>ملف النسخة الاحتياطية للمحفظة</strong>",
  insert: "قم بادخال شريحة microSD لإدارة النسخ الاحتياطية",
  insertButton: "لقد قمت بإدخال شريحة microSD",
  list: "هذه النسخ الاحتياطية في شريحة microSD الخاصة بك",
  noBackups: "لا توجد نسخ احتياطية في هذه الشريحة microSD",
  restore: {
    confirmTitle: "استرجاع النسخة الاحتياطية",
    error: {
      e200: "لا توجد شريحة microSD",
      general: "حدث خطأ عند عملية استرجاع النسخة الاحتياطية"
    },
    password: {
      label: "كلمة استعادة المرور او كلمة استعادة المرور المخفية",
      placeholder: "كلمة استعادة المرور",
      repeatPlaceholder: "تكرار كلمة استعادة المرور",
      showLabel: "كلمة استعادة المرور"
    },
    restoring: "استرجاع النسخة الاحتياطية...",
    selectedBackup: "<strong>{{backupName}}</strong> تم انشاءها في {{createdDateTime}} سيتم استرجاعها",
    title: "استرجاع",
    understand: "انا افهم ان ادخال كلمة استعادة مرور خاطئة يعني انشاء محفظة مختلفة"
  },
  showMnemonic: {
    description: `سيتم إظهار ٢٤ كلمة استرجاع لك, و هذه الكلمات تمثل النسخة الاحتياطية لمحفظتك. قم بكتابة هذه الكلمات على الورق
<strong> لا تقم بخزن الكلمات بشكل رقمي و لا تأخذ صورة للكلمات</strong>
<strong> لا تقم بالنطق الشفوي بصوت مسموع للكلمات</strong>
<strong>هذه النسخة الاحتياطية ليست محمية بكلمة مرور</strong>
بعد ذلك سيتم سؤالك لتأكيد كل كلمة`,
    title: "اظهار كلمات الاسترجاع"
  },
  title: "ادارة النسخ الاحتياطية"
}, bb02Bootloader$i = {
  abort: "لا تقم بالتحديث - اود الرجوع",
  abort_noUpgrade: "اريد الرجوع",
  advanced: {
    label: "اعدادات متقدمة",
    toggleShowFirmwareHash: `قم بإظهار هاش البرنامج المثبت عند كل تشغيل للتطبيق
`
  },
  flipscreen: "قلب الشاشة",
  orientation: "هل تم وضع الجهاز في الاتجاه الخاطئ؟",
  success: "التحديث تم بنجاح! سيتم الاستمرار خلال {{rebootSeconds}} ثانية...",
  success_install: "التثبيت تم بنجاح! سيتم الاستمرار خلال {{rebootSeconds}} ثانية..."
}, bitbox$i = {
  error: {
    e10000: "كلمة المرور الحالية للجهاز خاطئة",
    e10001: "فشلت محاولة استبدال كلمة المرور للجهاز",
    e102: "يجب ان تحتوي كلمة المرور على ٤ رموز على الاقل",
    e112: "لا يمكن لكلمة المرور المخفية للجهاز ان تكون نفس كلمة المرور الرئيسية للجهاز"
  }
}, bitbox02Interact$i = {
  confirmDate: "قم بتأكيد تاريخ اليوم في جهازك BitBox02",
  confirmDateText: "سيتم استخدام هذا التاريخ لإنشاء النسخة الاحتياطية",
  confirmName: "قم بتأكيد الاسم في جهاز BitBox02",
  followInstructions: "يرجى اتباع التعليمات في جهاز BitBox02",
  followInstructionsMnemonic: "قم بإتباع التعليمات في جهازك BitBox02 من اجل ادخال كلمات الاسترجاع من النسخة الاحتياطية و استعادة محفظتك",
  followInstructionsMnemonicTitle: "قم بالاستعادة من خلال كلمات الاسترجاع"
}, bitbox02Settings$i = {
  deviceName: {
    current: "اسم الجهاز الحالي",
    input: "اسم الـBitBox02",
    placeholder: "اسم جهاز جديد",
    title: "قم باختيار اسم BitBox02"
  },
  gotoStartupSettings: {
    description: "هذا الشي سيقوم بإعادة تشغيل جهاز BitBox02 و الدخول الى اعدادات بدء التشغيل",
    title: "إذهب الى اعدادات بدء التشغيل"
  }
}, bitbox02Wizard$i = {
  attestationFailed: "التحقق الاصلي قد فشل, مما قد يكون بسبب اعادة تشغيل التطبيق اثناء انتظار الجهاز لإدخال البيانات من المستخدم. يرجى اعادة الربط و المحاولة مجدداً. يرجى الاتصال عن طريق support@shiftcrypto.ch اذا تكررت المشكلة باستمرار",
  backup: {
    point1: "قم باختيار نسخة احتياطية من شريحة microSD",
    point2: "قم باختيار كلمة مرور لجهازك",
    restoreText: "حسناً لنبدأ باستعادة نسخة احتياطية",
    text1: "ممتاز, تم تثبيت كلمة المرور لجهازك BitBox02 و صنع المحفظة. الآن حان وقت انشاء اول نسخة احتياطية. يرجى التأكد من ادخال شريحة microSD في جهازك BitBox02 و الاستمرار",
    text2: "يرجى اتباع التعليمات التي تظهر على الشاشة على جهازك لإنشاء نسخة احتياطية",
    text3: "بعد إنشاء النسخة الاحتياطية، يرجى إزالة شريحة microSD خزنها في <strong>مكان آمن</strong>. محتويات شريحة microSD ليست محمية بكلمة مرور. لا تقم ابداً بإدخال الشريحة في اي جهاز آخر غير BitBox02 الخاص بك.",
    userConfirmation1: "يجب أن أقوم بتخزين النسخة الاحتياطية الخاصة بي في مكان آمن",
    userConfirmation2: "النسخة الاحتياطية الخاصة بي ليست محمية بكلمة مرور. يمكن لأي شخص قادر على الحصول على النسخة الاحتياطية من الدخول الى محفظتي",
    userConfirmation3: "إذا اضعت أو أتلفت جهاز BitBox02 فإن الطريقة الوحيدة لاسترداد أموالي هي عن طريق الاستعادة من النسخة الاحتياطية الخاصة بي",
    userConfirmation4: "إذا اضعت أو أتلفت كلاً من النسخة الاحتياطية و جهاز BitBox02 الخاصة بي فسأفقد أموالي",
    userConfirmation5: "يجب أن لا أقوم بإدخال النسخة الاحتياطية لشريحة microSD في جهاز كمبيوتر أو هاتف أو طابعة أو أي جهاز آخر غير BitBox02"
  },
  create: {
    button: "قم بتسمية الجهاز ثم الاستمرار",
    info: "فيما يلي الخطوات الأساسية التي ستتبعها من اجل إعداد BitBox الخاص بك: ",
    inputTitle: "اسم المحفظة",
    point1: "قم بتسمية جهازك",
    point2: "قم بتعيين كلمة مرور لجهازك",
    point3: "قم بإنشاء نسخة احتياطية",
    text: "حسنًا ، لنقم بإنشاء محفظة جديدة"
  },
  createBackupFailed: "فشل إنشاء نسخة احتياطية ، حاول مرة أخرى",
  initialize: {
    passwordText: "لنقم الآن بتعيين كلمة مرور لجهازك. استخدم ازرار التحكم في BitBox لإدخال كلمة مرور",
    passwordTitle: "قم بتعيين كلمة مرور لـ BitBox الخاص بك",
    text: "تم بنجاح ربط جهازك BitBox02 الخاص بك! لنبدأ الآن في تهيئة جهازك. ابدأ باختيار إنشاء محفظة جديدة، أو استعادة محفظة من نسخة احتياطية موجودة. <strong>يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك</strong>",
    tip: "نوصي بالاستمرار في مكان آمن",
    title: "قم بتهيئة BitBox الخاص بك"
  },
  insertSDCard: "<strong>يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك.</strong>",
  noPasswordMatch: "كلمات المرور غير متطابقة. حاول مرة اخرى",
  pairing: {
    failed: "لم يتم تأكيد الربط. يرجى إعادة توصيل BitBox02 الخاص بك",
    paired: "لقد قمت بالتأكيد على جهازك أن الرمز مطابق. إذا كان هذا صحيحًا يمكنك المتابعة بالكبس على الزر أدناه",
    title: "قم بتأكيد رمز الربط",
    unpaired: "تم اكتشاف BitBox02 جديد. يرجى التحقق من أن الكود التالي يطابق ما هو معروض على شاشة جهازك. قم بالكبس باللمس أسفل علامة الاختيار الموجودة على BitBox02 الخاص بك إذا تطابق الرمز، ثم اكبس فوق الزر أدناه للاستمرار"
  },
  restoreFromMnemonic: {
    failed: "فشلت الاستعادة من كلمات الاسترداد ، يرجى المحاولة مرة أخرى"
  },
  stepBackup: {
    beforeProceed: "قبل الاستمرار، يرجى قراءة هذه الاعتبارات الأمنية الهامة:",
    createBackup: "ستقوم الآن بإنشاء نسخة احتياطية على شريحة microSD الخاصة بك"
  },
  stepBackupSuccess: {
    fundsSafe: "للحفاظ على أموالك آمنة، يجب التذكير بما يلي:",
    title: "تمت استعادة النسخة الاحتياطية بنجاح"
  },
  stepConnected: {
    unlock: "أدخل كلمة مرور BitBox02 من اجل الدخول"
  },
  stepCreate: {
    description: "يتم استخدام هذا الاسم للجهاز و ايضاً للنسخة الاحتياطية",
    nameLabel: "اسم جهاز الـBitBox02",
    namePlaceholder: "جهازي الـBitBox02",
    title: "قم باختيار اسم لجهاز BitBox02",
    toastMicroSD: "يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك"
  },
  stepCreateSuccess: {
    removeMicroSD: "يرجى إزالة شريحة microSD من BitBox02 وتخزينها في مكان آمن",
    success: "لقد نجحت في إنشاء نسختك الاحتياطية"
  },
  stepInsertSD: {
    insertSDCard: "الرجاء إدخال شريحة microSD في BitBox02 للاستمرار",
    insertSDcardTitle: "قم بإدخال شريحة microSD"
  },
  stepPassword: {
    title: "قم باختيار كلمة مرور BitBox02",
    useControls: "استخدم ازرار التحكم في جهاز BitBox02 لاختيار كلمة مرور"
  },
  stepUninitialized: {
    create: "أرغب في إعداد BitBox02 جديد",
    restore: "أريد استعادة محفظتي من نسخة احتياطية",
    restoreMicroSD: "الاستعادة من شريحة microSD",
    restoreMnemonic: "استعادة من كلمات الاسترجاع",
    title: "قم بإعداد BitBox02 الخاص بك"
  },
  success: {
    text: `ممتاز! أصبح BitBox02 جاهزًا للاستخدام الآن

لمزيد من المعلومات حول كيفية استخدام تطبيق BitBox ، يرجى استخدام دليل التطبيق عن طريق الكبس فوق علامة الاستفهام في الزاوية اليمنى في الاعلى`,
    title: "انت جاهز الآن"
  }
}, blink$i = {
  button: "رمش"
}, bootloader$i = {
  button: "قم بتحديث البرنامج الثابت الآن",
  button_install: "قم بتثبيت البرنامج الثابت الآن",
  progress: "التحديث: {{progress}}٪",
  progress_install: "التثبيت: {{progress}}٪",
  success: "تم التحديث بنجاح! يرجى إعادة توصيل الجهاز. و هذه المرة، لا تلمس الزر"
}, button$m = {
  abort: "الايقاف",
  back: "العودة",
  buy: "الشراء",
  changepin: "قم بتغيير كلمة مرور الجهاز",
  check: "قم بالتحقق من النسخة الاحتياطية",
  continue: "الاستمرار",
  copy: "النسخ",
  create: "الانشاء",
  dismiss: "رفض",
  done: "اكتمل",
  download: "تحميل",
  hiddenwallet: "إنشاء محفظة مخفية",
  next: "التالي",
  ok: "حسناً",
  previous: "سابق",
  receive: "استلام",
  restore: "استرجاع",
  select: "اختر",
  send: "إرسال",
  unlock: "فتح القفل",
  update: "تحديث",
  upgrade: "تحديث النسخة"
}, buy$e = {
  info: {
    continue: "الموافقة و الاستمرار",
    crypto: "كريبتو",
    disclaimer: {
      intro: [
        "لدينا شراكة مع MoonPay لنقدم لك طريقة سلسة لشراء {{name}} مباشرة داخل تطبيق BitBox. العملية تستغرق خطوات قليلة",
        "منصة MoonPay  تجعل شراء {{name}} سهلاً وسريعًا في أكثر من 160 دولة"
      ],
      payment: {
        details: "يمكنك شراء {{name}} على الفور عبر MoonPay باستخدام طرق الدفع التالية.  بطاقات الائتمان فورية و سهلة، ولكنها أكثر تكلفة بسبب زيادة مخاطر رد المبالغ المدفوعة. نوصي باستخدام خيار التحويل المصرفي لمبالغ أكبر. الحد الأدنى للرسوم هو 4 دولارات أمريكية / او يورو بما يعادلها",
        footnote: "يرجى ملاحظة أن أسعار صرف MoonPay يمكن أن تختلف عن تلك المستخدمة في BitBoxApp ، مما ينتج عنه مبالغ مختلفة قليلاً",
        table: {
          "1_description": "الرسوم الارخص تستغرق مدة قد تصل الى 3 أيام عمل",
          "1_method": "التحويلات المصرفية (SEPA)",
          "2_description": "رسوم أعلى ولكن سريعة وفورية",
          "2_method": "بطاقات الائتمان والخصم",
          description: "الوصف",
          fee: "العمولة",
          method: "طريقة"
        },
        title: "طرق الدفع والرسوم"
      },
      privacyPolicy: "سياسة الخصوصية لـ MoonPay",
      protection: {
        description: "لا يقوم BitBoxApp بجمع أي بيانات عند شراء {{name}} و يتم التعامل مع الأموال الواردة معاملة عادية. يحتاج MoonPay إلى جمع بعض البيانات الشخصية للعمل. توضح سياسة الخصوصية الخاصة بهم بالتفصيل كيفية التعامل مع هذه البيانات",
        title: "حماية البيانات"
      },
      security: {
        description: "عند شراء {{name}} عبر MoonPay ، أنت تستخدم خدمة خارجية. هذه الخدمة خارج نطاق نظام حماية التهديد الامني في BitBox02 وتعتمد على سلامة وأمن البيئة التي يعمل بها برنامج BitBoxApp",
        link: "نظام الحماية للتهديد الأمني",
        title: "نظام الامن"
      },
      title: "مرحبًا بكم في متجرك الوحيد لشراء {{name}}"
    },
    next: "التالي",
    selectLabel: "اختر حسابك",
    selectPlaceholder: "اختر عملة",
    skip: "لا تظهر مرة أخرى",
    title: "شراء {{name}}"
  },
  title: "شراء {{name}}"
}, changePin$i = {
  newTitle: "كلمة مرور جديدة للجهاز",
  oldLabel: "كلمة مرور الجهاز الحالية"
}, chart$e = {
  dataMissing: "جمع البيانات التاريخية ... يرجى الانتظار",
  dataUpdating: "تحديث البيانات...",
  filter: {
    all: "الكل",
    month: "شهر",
    week: "أسبوع",
    year: "سنة"
  }
}, checkSDcard$i = "التحقق من شريحة microSD", clickHere$i = "اكبس هنا", confirm$k = {
  abortInfo: "اضغط من اجل",
  abortInfoRedText: "الغاء",
  approveInfo: "استمر في الضغط لمدة 4 ثواني من اجل ",
  approveInfoGreenText: "التأكيد",
  info: "استمر في جهاز BitBox الخاص بك",
  infoWhenPaired: "أولاً على الهاتف المحمول المربوط ثم جهاز BitBox الخاص بك"
}, confirmOnDevice$i = "يرجى التأكيد على جهازك", device$i = {
  appUpradeRequired: "جهاز BitBox الخاص بك غير متوافق مع تطبيق الكومبيوتر هذا. يرجى تنزيل وتثبيت أحدث إصدار"
}, deviceLock$i = {
  button: "تمكين المصادقة الثنائية (2FA)",
  condition1: "هل لديك نسخة احتياطية؟",
  condition2: "هل تعمل آلية التحقق من تطبيق الجوال؟",
  condition3: "المصادقة الثنائية 2FA تعطل النسخ الاحتياطية و الربط بتطبيقات الهاتف المحمول. يجب إعادة ضبط الجهاز للخروج من خاصية 2FA!",
  confirm: "تفعيل خاصية المصادقة الثنائية (2FA)",
  title: "تفعيل خاصية المصادقة الثنائية (2FA)"
}, deviceSettings$i = {
  firmware: {
    newVersion: {
      label: "الإصدار المتوفر"
    },
    title: "البرنامج الثابت",
    upToDate: "تم تحديث جهازك",
    version: {
      label: "إصدار"
    }
  },
  hardware: {
    attestation: {
      false: "فشل التحقق من التصديق",
      label: "التحقق من التصديق",
      true: "جهاز BitBox02 الخاص بك موثوق"
    },
    sdcard: {
      false: "لم يتم الادخال",
      label: "شريحة microSD",
      true: "تم إدخالها"
    },
    securechip: "شريحة آمنة",
    title: "المعدات"
  },
  loading: "جاري استلام معلومات الجهاز ...",
  pairing: {
    lock: {
      false: "عاطل",
      label: "نظام المصادقة الثنائية (2FA)",
      true: "مفعلة"
    },
    mobile: {
      false: "مغلق",
      label: "تطبيق موبايل",
      true: "مفتوح"
    },
    status: {
      false: "غير مرتبط",
      label: "الحالة",
      true: "مرتبط"
    },
    title: "جاري الارتباط"
  },
  secrets: {
    manageBackups: "ادارة النسخ الاحتياطية",
    title: "أسرار"
  }
}, deviceTampered$i = "هل تم تزويد BitBox الخاص بك بكلمة مرور للاسترداد؟ إذا كان الأمر كذلك، فأوقف عملية الإعداد واتصل بالدعم على الفور. لن تمنحك شركة Shift أبدًا محفظة باعدادات جاهزة و لن تقدم لك توصيات بكلمة مرور", dialog$j = {
  cancel: "الغاء",
  confirm: "تأكيد",
  confirmTitle: "تأكيد"
}, error$e = {
  accountAlreadyExists: "الحساب موجود مسبقاً",
  accountLimitReached: "لا يمكن إضافة حساب. تم الوصول إلى الحد الأقصى لعدد الحسابات لهذه العملة",
  aoppCallback: "حدث خطأ في ايصال العنوان إلى {{host}}",
  aoppInvalidRequest: "طلب غير صالح",
  aoppNoAccounts: "لا توجد حسابات متاحة",
  aoppSigningAborted: "تم إلغاء طلب ملكية العنوان",
  aoppUnknown: "حدث خطأ غير معروف",
  aoppUnsupportedAsset: "العملة غير مدعومة",
  aoppUnsupportedFormat: "لا توجد حسابات متوفرة تدعم صياغة العنوان المطلوب",
  aoppUnsupportedKeystore: "لا يمكن للجهاز المتصل توقيع رسائل لهذه العملة",
  aoppVersion: "نسخة غير معروفة"
}, fiat$k = {
  default: "الخيار الاصلي",
  setDefault: "تعيين {{code}} كخيار اصلي",
  title: "العملات"
}, footer$k = {
  appVersion: "نسخة التطبيق:"
}, generic$e = {
  enabled_false: "عاطل",
  enabled_true: "مفعلة"
}, genericError$i = "حدث خطأ. إذا لاحظت حصول أي مشاكل فيرجى إعادة تشغيل التطبيق", goal$i = {
  buttons: {
    create: "أنشئ محفظة جديدة",
    restore: "استعادة محفظة من نسخة احتياطية"
  },
  paragraph: "الرجاء اختيار واحد من الخيارات التالية:",
  step: {
    1: {
      title: "حماية المعلومات"
    },
    2: {
      description: "قم بتعيين كلمة مرور للجهاز",
      title: "جهاز"
    },
    "3-create": {
      description: "أنشئ محفظة جديدة",
      title: "محفظة"
    },
    "3-restore": {
      description: "من نسخة احتياطية",
      title: "استرجاع"
    },
    "4-create": {
      title: "خلاصة"
    },
    "4-restore": {
      title: "خلاصة"
    }
  }
}, guide$j = {
  accountDescription: {
    text: 'خاصية النظرة العامة لحسابك ستظهر رصيدك وكذلك المعاملات الواردة والصادرة. يحتوي دليلنا في "الإعدادات" على مزيد من المعلومات حول كل نوع من الحسابات',
    title: "ما الذي يظهر لي في هذه الصفحة؟"
  },
  accountFiat: {
    text: "نعم. اكبس فوق أي شريط للاختيار من قائمة العملات التقليدية. يمكنك تغيير قائمة العملات في الإعدادات",
    title: "هل يمكنني عرض أسعار التحويل الأخرى؟"
  },
  accountIncomingBalance: {
    text: "مبلغ الوارد هو مجموع المبالغ المرسلة لحسابك ولكن لم يتم تأكيدها على الشبكة بعد",
    title: "ماذا يعني المبلغ الوارد؟"
  },
  accountInfo: {
    multipleXPubs: {
      text: `يرتبط كل ملف xpub بـ"النوع" المعروض: إما "Segwit (bech32) على الجهاز" أو "Segwit مبطن" أو "Taproot" (للبتكوين فقط). هذه هي أنواع البرامج النصية المستخدمة من قبل {{coinName}}. يقوم BitBoxApp بدمجها ، و ايضاً دعم أنواع نصوص متعددة في نفس الحساب. نظرًا لأن كل نوع نص برمجي يعطي xpub مختلف، فهناك عدة xpub لكل حساب.

إذا كنت تستلم تحويلات مستمرة على العنوان الافتراضي (Native Segwit) ، فأنت تحتاج فقط إلى xpub "bech32". ومع ذلك ، إذا استلمت أيضًا أموالًا إلى "Wrapped Segwit" أو "Taproot" ، فستحتاج أيضًا إلى استخدام المفتاحين العلنيين الموسعين "Wrapped Segwit" و "Taproot" `,
      title: "لماذا يوجد العديد من ملفات xpub؟"
    },
    privacy: {
      text: `يكشف المفتاح العلني الموسع لهذا الحساب بالتحديد التاريخ المالي بالكامل ورصيد حسابك وجميع المعاملات المستقبلية. لكن xpub لا يسمح لأي شخص بإنفاق عملاتك

إذا أعطيت xpub لشخص ما ، فيجب أن تدرك أن هذا الشخص أو الشركة يمكنها رؤية جميع المعاملات الأخرى لنفس الحساب. لذلك، ننصح باستخدام هذا الحساب لهذا الغرض فقط والاحتفاظ بأموال أخرى في حسابات مختلفة`,
      title: "هل أحتاج إلى الاحتفاظ بسرية xpub؟"
    },
    verify: {
      text: "نعم ، من الأفضل دائمًا إعادة التحقق من xpub الخاص بك. فهذا مهم بشكل خاص إذا قام شخص آخر بإنشاء عناوين استلام من xpub هذا لإرسال الأموال إليك. تحتاج إلى التحقق من ذلك على الجهاز للتأكد من أن xpub هذا ملك لك. خلاف ذلك فيمكن أن تذهب جميع الأموال إلى عناوين خاطئة.",
      title: "هل أحتاج إلى التحقق من xpub على الجهاز؟"
    },
    xpub: {
      text: `المفتاح العلني الموسع (xpub) هو مفتاح جذر تُشتق منه جميع عناوين الاستلام الخاصة بالحساب.

يتم توفيرها هنا للاستخدام المتقدم وقابلية التشغيل البيني مع محفظات المراقبة فقط ، مثل Electrum أو Sentinel. إذا تلقيت أنواع عناوين مختلفة ، فيرجى استيراد جميع تنسيقات xpub المختلفة إلى محفظة المراقبة فقط لمتابعة جميع عملاتك.

يرجى ملاحظة أن محافظ الطرف الثالث قد لا دعم Taproot xpubs حتى الآن`,
      title: "ما هو المفتاح العلني الموسع؟"
    }
  },
  accountRates: {
    text: "نقوم بتحديث أسعار الصرف كل دقيقة من CoinGecko",
    title: "ما هي أسعار الصرف المعتمدة؟"
  },
  accountReload: {
    text: "ليس هناك حاجة. يتم تحديث معلومات معاملاتك تلقائيًا",
    title: "هل يمكنني إعادة تحميل سجل المعاملات؟"
  },
  accountSendDisabled: {
    text: 'يتم تنشيط الزر "إرسال" عندما يكون رصيدك أكثر من صفر',
    title: "لماذا لا يمكنني إرسال أي {{unit}}؟"
  },
  accountSummaryAmount: {
    text: `المبلغ الإجمالي هو مجموع جميع حسابات الكريبتو الخاصة بك. يتم الحصول على أسعار الصرف من موقع coingecko.com

ملاحظة: إذا كنت تستخدم محفظة MyEtherWallet للتوكينات الغير مدعومة في BitBoxApp ، فلن يتم تضمينها في المبلغ المعروض`,
    title: "كيف يتم حساب المبلغ الإجمالي؟"
  },
  accountSummaryDescription: {
    text: "هنا يمكنك مشاهدة أداء محفظتك مع مرور الوقت. يتم عرض ملخص لحساباتك الكريبتو تحت الشارت",
    title: "ما الذي يظهر لي في هذه الصفحة؟"
  },
  accountTransactionAttributesBTC: {
    text: `الحجم الافتراضي: يحدد رسوم الشبكة. لقد نجحت في التوفير اذا كانت الرسوم اقل من حجم المعاملة.
الحجم: الحجم الفعلي للمعاملة بالبايت عند إجراء تسلسل وفقًا للبلوكشين الأساسية.
الوزن: مقياس جديد تم تقديمه مع Segwit لتقييم أحجام المعاملات والكتل. يتم احتساب كل بايت في Segwit كواحد ، وكل شيء آخر كأربع وحدات وزن. بدلاً من واحد ميغا بايت بالحجم الفعلي ، أصبح حد حجم الكتلة الآن أربعة ملايين وحدة وزن`,
    title: "ماذا عن تفاصيل المعاملات الخاصة ببيتكوين؟"
  },
  accountTransactionAttributesGeneric: {
    text: `التأكيدات: لا يتم تأكيد بث معاملتك حتى يقوم احد المعدنين بإدراجه عشوائياً في كتلة، وبعد ذلك يحصل تأكيد واحد للمعاملة. تضيف كل كتلة يتم بثها على الشبكة تأكيدًا آخر لمعاملتك. بشكل عام ، يقوم المتداولون والجهات الفاعلة الأخرى في الشبكة بتسوية المعاملات خلال ما بين ثلاثة إلى ستة تأكيدات فقط.
معرف المعاملة: رقم تعريف فريد يسمح لك بالبحث عن معاملة في مستكشف البلوكشين.
الرسوم: يتم دفع رسوم للمعدنين على المعاملات كحافز لتضمين المعاملات في الكتل التي يقومون بتعدينها. لمعرفة المزيد ، اكبس على زر الإرسال.`,
    title: "ما هي المعلومات الواردة في تفاصيل المعاملة؟"
  },
  accountTransactionConfirmation: {
    text: "تم بث معاملة على الشبكة ولكن لم يتم تأكيدها بعد",
    title: "ما هي المعاملة المعلقة؟"
  },
  accountTransactionLabel: {
    text: "إنه العنوان الذي تلقيت منه عملات أو أرسلت إليه عملات",
    title: "ما هو العنوان الذي يتم عرضه لكل معاملة؟"
  },
  accountTransactionTime: {
    text: "وقت تأكيد المعاملة على البلوكشين",
    title: "ما هو الوقت المعروض؟"
  },
  accounts: {
    howManyAccounts: {
      text: "يمكن أن يكون لكل عملة خمسة حسابات بحد أقصى",
      title: "كم عدد الحسابات التي يمكنني إنشاؤها؟"
    },
    howtoAddTokens: {
      text: 'ترتبط العملات التي تستخدم بروتوكول ERC20 مرتبطة بحساب Ethereum معين. لتمكين أو تعطيل عملة معينة، افتح شاشة "إدارة الحسابات" ، وقم بتوسيع حساب Ethereum الخاص بك وقم بتشغيل العملة المطلوبة أو إيقاف تشغيلها',
      title: "كيف يمكنني إضافة عملات إضافية؟"
    },
    moveFunds: {
      text: "نعم. ولكن نظرًا لأن الحسابات مستقلة، فأنت بحاجة إلى إرسال أموالك باستخدام معاملة عادية",
      title: "هل يمكنني نقل الأموال بين الحسابات؟"
    },
    recoverAccounts: {
      text: "نعم. يقوم تطبيق BitBoxApp بإنشاء حسابات باستخدام معايير راسخة متوافقة مع معظم محافظ التشفير الأخرى",
      title: "هل يمكنني استعادة حساباتي بمحفظات أخرى؟"
    },
    whatAreAccounts: {
      text: "يمكن لمحفظتك إدارة حسابات متعددة لنفس العملة. الحسابات مفيدة عندما تريد فصل الاحتفاظ بالأموال عن بعضها",
      title: "ما هي الحسابات؟"
    },
    whyIsThisUseful: {
      text: 'الحسابات ممتازة لإدارة الأموال لأشخاص أو أغراض مختلفة لأنها منفصلة. يمكنك أيضًا مشاركة "المفتاح العلني الموسع" لحساب ما دون الكشف عن أي شيء عن حساباتك الأخرى. يتيح لك ذلك تلقي الأموال بشكل متكرر دون إعادة استخدام العناوين، مثل تلقي راتبك أو شراء العملات المشفرة بانتظام',
      title: "لماذا هذا مفيد؟"
    }
  },
  appendix: {
    link: "اتصل بنا!",
    text: "سؤال آخر؟"
  },
  backups: {
    check: {
      text: 'يسمح لك "التحقق من النسخة الاحتياطية" بالتحقق من أن لديك نسخة احتياطية صالحة للعمل تتوافق مع محفظتك الحالية. يمكن استخدامها أيضًا للتحقق من أنه لا يزال لديك كلمة مرور الاسترداد الصحيحة. يمكنك التحقق من كلمة مرور الاسترداد الرئيسية أو كلمة مرور الاسترداد المخفية',
      title: 'ما هو "فحص النسخة الاحتياطية"؟'
    },
    encrypt: {
      text: "لا ، ولكن كلمة مرور الاسترداد مطلوبة لاشتقاق المحفظة من المفاتيح السرية المخزنة",
      title: "هل يمكنني تشفير النسخة الاحتياطية؟"
    },
    howOften: {
      text: `يتم إنشاء النسخة الاحتياطية تلقائيًا عند إنشاء محفظة جديدة. ما عليك سوى عمل نسخة احتياطية جديدة في حالة فقدان شريحة microSD أو تلفها ، أو إذا كنت تريد استخدام عدة شرائح microSD كنسخ احتياطية.
لا تحتاج إلى إنشاء نسخة احتياطية جديدة بعد اكتمال المعاملة. يمكن إعادة إنشاء جميع بيانات المعاملات الخاصة بك عن طريق النسخة الاحتياطية الفردية التي تم إنشاؤها تلقائيًا لك`,
      title: "كم مرة يجب علي عمل نسخة احتياطية؟"
    },
    whatIsABackup: {
      text: "إنها نسخة من المفاتيح السرية الموجودة على شريحة microSD. تنشئ المفاتيح مع كلمة مرور الاسترداد محفظتك",
      title: "ما هي النسخة الاحتياطية؟"
    }
  },
  backupsBB02: {
    check: {
      text: 'يسمح لك "التحقق من النسخة الاحتياطية" بالتحقق من أن لديك نسخة احتياطية صالحة للعمل تتوافق مع محفظتك الحالية',
      title: 'ما هو "فحص النسخة الاحتياطية"؟'
    },
    encrypt: {
      text: 'لا. يرجى الحفاظ على شريحة microSD في مكان آمن ، لأنها تحتوي على المفاتيح غير المشفرة لاستعادة محفظتك. إذا كنت ترغب في حماية المفاتيح بكلمة مرور ، فيمكنك تمكين عبارة مرور اختيارية في الإعدادات المتقدمة ضمن "إدارة الجهاز"',
      title: "هل يمكنني تشفير النسخة الاحتياطية؟"
    },
    whatIsABackup: {
      text: "إنها نسخة من المفاتيح السرية الموجودة على شريحة microSD",
      title: "ما هي النسخة الاحتياطية؟"
    }
  },
  bitbox: {
    "2FA": {
      text: `عند تمكين المصادقة الثنائية (2FA) ، يجب الموافقة على جميع المعاملات على الهاتف المحمول المقترن من أجل إنفاق العملات. عند التعمق اكثر، يتم إرسال رقم مشفر للاستخدام الفردي إلى تطبيق الهاتف المحمول ، ويتم فك تشفيره هناك ، وإعادته إلى BitBox عند الضغط على زر القبول. يتم إجراء هذا الاتصال بالجهاز عبر القناة بين الهاتف المحمول وتطبيق سطح المكتب هذا الذي تم إنشاؤه أثناء الاقتران

تأكد من عمل نسخة احتياطية من محفظتك وإقران تطبيق الهاتف المحمول قبل تمكين 2FA. بمجرد التمكين ، يتم تعطيل فتحة microSD وإقران تطبيق الهاتف المحمول. يمكن إعادة تمكينها عن طريق إعادة تعيين BitBox ، مما يمحي الجهاز`,
      title: "كيف يعمل المصادقة الثنائية (2FA)؟"
    },
    disable2FA: {
      text: 'لتعطيل المصادقة الثنائية (2FA) ، تحتاج إلى إعادة تعيين BitBox الخاص بك ثم استعادة المحفظة من النسخة الاحتياطية الخاصة بها. تأكد من أنه لا يزال لديك شريحة microSD مع النسخة الاحتياطية وأنك ما زلت تتذكر كلمة مرور الاسترداد. ثم اضغط على "إعادة تعيين الجهاز". قم بتعيين كلمة مرور جديدة للجهاز واختر "أو استعادة نسخة احتياطية". حدد النسخة الاحتياطية التي قمت بإنشائها من المحفظة ، وانقر فوق "استعادة" وأدخل كلمة مرور الاسترداد التي استخدمتها عند إنشاء المحفظة',
      title: "كيف يمكنني تعطيل المصادقة الثنائية (2FA)؟"
    },
    ejectBitbox: {
      text: "يمكنك فصل BitBox في أي وقت دون الحاجة إلى ازالتها أولاً",
      title: "كيف يمكنني ازالة BitBox؟"
    },
    ejectSD: {
      text: "يمكنك إزالة بطاقة microSD من BitBox في أي وقت طالما أنك لست بصدد إنشاء نسخة احتياطية أو استعادتها",
      title: "كيف يمكنني إخراج شريحة microSD؟"
    },
    hiddenWallet: {
      text: "إنها محفظة ثانية على نفس الجهاز محمية بكلمة مرور مختلفة للجهاز وكلمة مرور استرداد ، والتي يمكنك استخدامها للإنكار القانوني المقبول. يتم استخدام نفس المفاتيح الاحتياطية لكل من محفظتك العادية والمخفية ، لذلك لا يلزم نسخة احتياطية إضافية",
      title: "ما هي المحفظة المخفية؟"
    },
    legacyHiddenWallet: {
      text: "أولاً ، إكبس فوق الزر أدناه (متاح إذا تم إلغاء تأمين BitBox باستخدام كلمة مرور الجهاز الرئيسية وتعطيل 2FA) ، ثم أعد توصيل Bitbox الخاص بك وقم بإلغاء قفله بكلمة مرور جهازك المخفية",
      title: "كيف يمكنني الوصول إلى المحفظة المخفية القديمة؟"
    },
    pairing: {
      text: "بعد تنزيل تطبيق الهاتف المحمول الخاص بنا لنظام التشغيل iOS أو Android ، تقوم بمسح رمز الاستجابة السريعة المعروض ، والذي ينشئ قناة آمنة بين تطبيق الهاتف المحمول وهذا التطبيق. بمجرد المسح ، اتبع التعليمات الموجودة في تطبيق الهاتف",
      title: "كيفية الربط بأمان مع هاتفك"
    }
  },
  cointracking: {
    text: 'اكبس فوق الزر "تصدير" وافتح مجلد التنزيلات حيث ستجد تصدير ملف CSV. ثم اكبس فوق الرابط أدناه ، وقم بتحميل ملف BitBox CSV الخاص بك واستورد البيانات من أجل استخدامها لإدارة بورتفوليو خاص بك في CoinTracking ولإنشاء تقاريرك الضريبية',
    title: "كيف أستورد معاملاتي إلى CoinTracking؟"
  },
  device: {
    attestation: {
      link: {
        text: "اقرأ المزيد عن مسألة التحقق من المصداقية"
      },
      text: "يقوم تطبيق BitBoxApp بإجراء فحص المصادقة على جهاز BitBox02 للتحقق مما إذا كان الجهاز أصليًا. يتم الفحص محليًا ولا يتصل بأي سيرفيرات",
      title: "كيف يعمل نظام التحقق من المصداقية؟"
    },
    name: {
      text: "هذا هو اسم محفظتك والنسخة الاحتياطية. يستخدم الاسم للنسخة الاحتياطية المستقبلية ويمكن استخدامه للمساعدة في التمييز بين المحفظات المختلفة. يمكن تغييره في أي وقت ولكن لاحظ أن النسخة الاحتياطية التي تم إجراؤها قبل التغيير ستظل تستخدم الاسم السابق",
      title: "ما هو اسم جهاز BitBox02 المستخدم؟"
    },
    "secure-chip": {
      link: {
        text: "اقرأ المزيد عن الشريحة الآمنة"
      },
      text: "توضح هذه المعلومات رقم طراز الشريحة الآمنة. والشريحة الأحدث هي ATECC608B مع ميزات أمان محسّنة مقارنة بالطرازات القديمة",
      title: "لماذا يظهر نموذج الشريحة الآمنة؟"
    }
  },
  receive: {
    address: {
      text: "يمكنك إعطاء العنوان للآخرين لإرسال بعض العملات إليك. فقط تأكد من أنك ترسل إلى العنوان الصحيح",
      title: "ماذا أفعل بالعنوان؟"
    },
    addressChange: {
      text: "بمجرد إجراء المعاملة ، يتم إضافة عنوان جديد تلقائيًا إلى القائمة، لذلك هناك دائمًا 20 عنوان جديد متاح لم تستلم أي عملات مطلقًا",
      title: "متى تتغير العناوين؟"
    },
    addressFormats: {
      text: "في الاعدادت الاساسية، يكون نوع العنوان هو Native Segwit. يتم اعتماد هذا النوع من العناوين على نطاق واسع من قبل مختلف المحفظات و المنصات الاخرى ويمنحك أفضل معدلات الرسوم للمعاملات اليومية. ومع ذلك ، يمكنك أيضًا اختيار الإرسال إلى عنوان نوع Taproot (للبتكوين فقط) ، وهو أحدث نوع من العناوين، ولكن قد لا يكون مدعومًا على نطاق واسع حتى الآن. بدلاً من ذلك ، إذا كنت تواجه مشكلات في الإرسال إلى Native Segwit (النوع الاساسي) ، فيمكنك محاولة التبديل إلى نوع عنوان Segwit مبطن و هو النوع الأقدم الذي قد يكون متوافقًا مع اغلبية انواع المحفظات و المنصات.",
      title: 'متى يجب ان أستخدم خاصية "تغيير نوع العنوان"؟'
    },
    howVerify: {
      text: `بالنسبة إلى جهاز BitBox01 ، اكبس فوق رمز BitBox في الشريط الجانبي على اليسار و سترى قسم الاقتران (الربط). سيتم تحديث الدليل ويمكنك الاستمرار في متابعة التعليمات من هناك.
بالنسبة إلى جهاز BitBox02 ، يمكنك التحقق من العناوين مباشرة على الجهاز أثناء عملية الإرسال و الاستلام`,
      title: "كيف يمكنني التحقق من العنوان بأمان؟"
    },
    plugout: {
      text: "لا ، بمجرد إرسال العملات إلى عنوان BitBox الخاص بك ، لن تحتاج إلى ترك BitBox الخاص بك متصلاً. أنت حر في فصل جهاز BitBox الخاص بك",
      title: "هل أحتاج إلى ترك جهاز BitBox الخاص بي متصلاً أثناء الاستلام؟"
    },
    why20: {
      text: 'أثناء بدء التشغيل ، يُنشئ التطبيق عناوين مشتقة من مفاتيحك (١٢ او ٢٤ كلمة) لمعرفة ما إذا كانوا قد تلقوا أموالاً في الماضي. نظرًا لأن التطبيق يمكنه إنشاء عدد لا نهائي تقريبًا من العناوين ، فقد يقضي سنوات في تحديد الرصيد. للحد من هذا البحث ، يتوقف هذا البحث بعد أن يرى 20 عنوانًا لم تتلق أموالًا مطلقًا. هذا هو "حد الفجوة" و 20 هو معيار واقعي على الرغم من أن الرقم عشوائي. هذه هي 20 عنوانًا يمكنك الاختيار من بينها',
      title: "لماذا يوجد 20 عنوان فقط؟"
    },
    whyMany: {
      text: "للحفاظ على الخصوصية والأمان ، لا تقم أبدًا بإعطاء نفس العنوان مرتين. إذا كنت قد استخدمت عنوانًا ، فقم بالكبس فوق السهم الأيمن للحصول على عنوان جديد. يمكنك إنشاء ما يصل إلى 20 عنوانًا في المرة الواحدة. فكر في العناوين مثل أرقام الوصولات. جميع العناوين مشتقة من المفاتيح نسخة احتياطية واحدة.",
      title: "لماذا توجد الكثير من العناوين؟"
    },
    whyVerify: {
      text: "يجب أن لا تثق في جهاز الكمبيوتر الخاص بك لإنشاء وعرض عناوين أصلية. الكومبيوتر ساحة هجوم كبيرة و مستهدفة و يجعلها أكثر عرضة للخطر بشكل ملحوظ و هي اضعف من اجهزة المحفظات الباردة. بالنسبة لجهاز BitBox01 ، يرسل الزر للتحقق من العنوان بشكل آمن العنوان إلى هاتف محمول مقترن بالمحفظة ، حيث يمكنك أيضًا مسح رمز الاستجابة السريعة والتحقق منه. بالنسبة لـ BitBox02 ، يمكن التحقق من العنوان مباشرة على شاشة BitBox02 نفسها",
      title: "لماذا يجب علي التحقق من العنوان بأمان؟"
    }
  },
  send: {
    change: {
      text: "سيتم إرجاع التغيير إلى عنوان Taproot إذا كان لديك Taproot UTXO واحدة على الأقل. إذا كنت تستخدم خاصية التحكم في العملة Coin Control، فسيتم إرجاع التغيير إلى عنوان Taproot إذا كان هناك على الأقل  Taproot UTXO واحدة بين UTXOs المحددة. في جميع الحالات الأخرى ، يتم إرجاع التغيير إلى عنوان Segwit الأصلي.",
      title: "كيف يتم تحديد ناتج التغيير؟"
    },
    fee: {
      text: `تعتمد الرسوم على حجم بيانات المعاملة وليس قيمتها. يتم حساب أهداف الرسوم بواسطة خوارزمية تقدير الرسوم في كود او برمجة Bitcoin Core لكل أولوية شبكة انت تختارها. يتم عرضها إذا كانت لها قيمة مختلفة عن الهدف أدناه.
الخيار التوفيري: التأكيد خلال 24 كتلة (حوالي 4 ساعات للبيتكوين ، وساعة واحدة للايتكوين)
منخفض: التأكيد خلال 12 كتلة (حوالي ساعتين للبيتكوين ، و 30 دقيقة للايتكوين)
عادي: التأكيد خلال 6 كتل (حوالي ساعة واحدة للبيتكوين ، و 15 دقيقة للايتكوين)
مرتفع: التأكيد خلال كتلتان (حوالي 20 دقيقة للبيتكوين ، و 5 دقائق للايتكوين)
(تستغرق الكتلة في المتوسط عشر دقائق للبيتكوين (2.5 دقيقة في للايتكوين) وقد يختلف الزخم على الشبكة بشكل كبير في الفترات المذكورة أعلاه)`,
      title: "كيف يتم تحديد الرسوم؟"
    },
    plugout: {
      text: "لا ، بمجرد إجراء معاملة ، لن تحتاج إلى ترك BitBox الخاص بك متصلاً. ولك مطلق الحرية في فصل BitBox الخاص بك",
      title: "هل أحتاج إلى ترك BitBox الخاص بي متصلاً أثناء الإرسال؟"
    },
    priority: {
      text: "كلما زادت الرسوم التي ترغب في دفعها ، زادت سرعة تأكيد معاملتك على الشبكة",
      title: "ما هي أولوية الشبكة؟"
    },
    revert: {
      text: `بمجرد توقيع المعاملة وإرسالها (أي بثها إلى الشبكة) ، لم يعد من الممكن التراجع عنها. تحقق من المعاملات (بما في ذلك الرسوم) بشكل صحيح قبل التوقيع!
إذا كنت تعرف المستلم وكان مستعدًا لإرسال نفس المبلغ (مطروحًا منه رسوم المعاملة) إليك ، فيمكنك إرسال عنوان استلام جديد له`,
      title: "هل يمكنني التراجع عن معاملة (ارسال او تداول)؟"
    },
    whyFee: {
      text: `تتنافس المعاملات على أن يؤكدها المعدنين. يختار المعدنون المعاملات ليتم تضمينها في البلوكشين بناءً على رسومهم.
يصوت المعدنين على تاريخ المعاملات. نظرًا لعدم وجود طرف ثالث موثوق به لفرض صوت واحد لكل شخص (وهذا هو الهدف الكامل من تقنية البلوكشين) ، يصوت المعدنون على المعاملات من خلال التضحية بمورد مكلف مثل قوة الحوسبة (صعوبة التعدين). كمكافأة على عملهم (اثبات الجهد)، يمكنهم المطالبة بالعملات التي تم إنشاؤها حديثًا ورسوم جميع المعاملات التي تضمنتها`,
      title: "لماذا توجد رسوم على الشبكة؟"
    }
  },
  "settings-electrum": {
    connection: {
      text: `إذا كنت تنوي الاتصال بالنود الخاصة بك فقط عندما تكون على نفس الشبكة (على سبيل المثال على انرنت wifi المنزلي الخاص بك) ، فإن استخدام اتصال الشبكة المنتظم كافي.
في هذه الحالة ، من المستحسن أن يوفر سيرفير Electrum الخاص بك شهادة TLS لتشفير الاتصال.
إذا كنت تنوي الاتصال بالنود الخاصة بك من أي مكان آخر، فإن استخدام Tor هو الخيار الأفضل. لا يلزم وجود شهادة TLS في هذه الحالة.`,
      title: "هل يجب أن أستخدم انترنت مفتوح TCP أو TLS أو Tor؟"
    },
    instructions: {
      link: {
        text: "الدليل لتوصيل النود الخاصة بك"
      },
      text: "للحصول على برنامج تعليمي كامل، يرجى زيارة دليلنا:",
      title: "كيف أقوم بتوصيل تطبيق BitBox الخاص بي بالنود الخاصة بي؟"
    },
    options: {
      text: `هناك العديد من الخيارات لتشغيل النود الخاصة بك ، مثل شراء جهاز مكتمل ، أو بناء Bitcoin Core الخاص بك أو تشغيله.
إذا كنت ترغب في توصيل تطبيق BitBoxApp بالنود الخاصة بك ، فتأكد من انها تشغل سيرفير Electrum و هو  برنامج مخصص يسمح لتطبيق المحفظة بالاتصال بالنود الكاملة.
تشمل الخيارات المدعومة Electrs أو Electrum Personal Server (EPS) أو Bitcoin Wallet Tracker (BTW).`,
      title: "ما هي الخيارات المتاحة لتشغيل النود؟"
    },
    tor: {
      text: `يرمز Tor إلى "The Onion Router" ، وهو برنامج مجاني ومفتوح المصدر يوفر الكثير من مزايا الخصوصية وهو مفيد بشكل خاص عند استخدام Bitcoin.
إذا كنت تنوي الاتصال بالنود الخاصة بك عبر Tor ، فتأكد من تثبيت Tor على جهاز الكمبيوتر الخاص بك ثم قم بتمكين Tor Proxy في إعدادات BitBoxApp.
في معظم أنظمة التشغيل ، توجد طريقتان لتشغيل Tor:
1. عن طريق متصفح Tor: قم بتنزيل متصفح Tor من الانترنت وافتحه. سيسمح هذا لتطبيق BitBoxApp بالاتصال بشبكة Tor عن طريق ضبط المنفذ الالكتروني رقم 9150 في إعدادات Tor Proxy .
2. خدمة Tor التي تعمل في الخلفية: قم بتثبيت Tor daemon ، والتي تعمل دائمًا في الخلفية. يمكن لتطبيق BitBoxApp الاتصال عن طريق ضبط المنفذ الالكتروني رقم 9050 في إعدادات Tor Proxy.`,
      title: "ما هو Tor و Tor proxy وأي منفذ الكتروني يجب أن أستخدمه؟"
    },
    what: {
      text: "من الممكن تشغيل محفظتك عن طريق النود الخاصة بك بدلاً من استخدام سيرفيرات شركة Shift",
      title: "ما هذا؟"
    },
    why: {
      text: `تشغيل النود الخاصة بك ليس ضروريًا ولكنه يرفع درجة الخصوصية ويقلل من الحاجة إلى الثقة بالآخرين.
أولاً ، هذا يعني أنك تستخدم Bitcoin بشكل أكثر خصوصية لأن تطبيق BitBox لن يتصل بالسيرفرات لجلب سجل معاملاتك ؛ بدلاً من ذلك ، سيتم جلب هذه المعلومات من النود الخاصة بك.
ثانيًا ، تشغيل النود الخاصة بك يعني أن النود الخاصة بك تتحقق من جميع المعاملات نفسها ، مع التأكد من تطبيق قواعد الإجماع.`,
      title: "لماذا يجب علي تشغيل النود الخاصة بي؟"
    }
  },
  settings: {
    sats: {
      text: "ساتوشي ('sat' للاختصار) هي أصغر وحدة من البيتكوين. ساتوشي واحد يعادل مائة مليون من البيتكوين (0.00000001 BTC). تم تسميته على اسم مبتكر البيتكوين، ساتوشي ناكاموتو",
      title: "ما هو الساتوشي؟"
    },
    servers: {
      text: `يتواصل هذا التطبيق مع سيرفيرات Shift Crypto للتحقق من التحديثات وتحميل المعاملات وإرسال المعلومات إلى تطبيقات الهواتف المحمولة المقترنة.
يسترجع التطبيق أيضًا أحدث أسعار الصرف من CoinGecko. يتم حساب جميع التحويلات محليًا مما يعني أنه لا يتم إرسال أي بيانات حول حجم معاملتك على الإطلاق.
ملاحظة: بالنسبة لرموز Ethereum و توكينات ERC20 ، نستخدم واجهات برمجة تطبيقات من Etherscan.io.`,
      title: "مع أي سيرفيرات يتحدث هذا التطبيق؟"
    }
  },
  title: "الدليل",
  toggle: {
    close: "اغلاق الدليل",
    open: "الدليل"
  },
  trackingModePortfolioChart: {
    text: "على كومبيوتر سطح المكتب، مرر سهم الماوس فوق الشارت. على الهاتف المحمول، ضع إصبعك على الشارت واسحب أفقيًا",
    title: "كيف يمكنني ان ارى القيم التاريخية على الشارت؟"
  },
  unlock: {
    forgotDevicePassword: {
      text: "يجب عليك إعادة ضبط الجهاز واستعادة المحفظة من نسخة احتياطية باستخدام كلمة مرور الاسترداد",
      title: "ماذا أفعل إذا نسيت كلمة مرور الجهاز؟"
    },
    reset: {
      text: "أدخل كلمة مرور خاطئة للجهاز 15 مرة. تتطلب المحاولات القليلة الأخيرة لمسة طويلة على الجهاز",
      title: "كيف يمكنني إعادة ضبط الجهاز؟"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `يجب أن يومض الجهاز مرة واحدة عند إدخاله. تأكد من إدخاله بالطريقة الصحيحة. إذا كنت تواجه مشكلة ، يرجى الاتصال بنا من خلال الرابط أدناه.

BitBox01 غير مدعوم على الهاتف المحمول. يرجى استخدام تطبيق BitBox على سطح المكتب لتوصيل BitBox01 الخاص بك`,
      title: "لم يتم التعرف على جهاز BitBox01 الخاص بي"
    },
    getDevice: {
      link: {
        text: "شراء BitBox"
      },
      text: "يمكنك شراء جهاز BitBox من متجرنا على موقعنا في الإنترنت:",
      title: "كيف يمكنني الحصول على جهاز؟"
    },
    internet: {
      text: "نعم ، يلزم الاتصال بالإنترنت لمزامنة المحفظة وإرسال المعاملات واسترداد أحدث أسعار الصرف",
      title: "هل يحتاج هذا التطبيق اتصالاً بالإنترنت؟"
    },
    lostDevice: {
      link: {
        text: "مركز النسخة الاحتياطية"
      },
      text: "يمكنك استرداد حساباتك على جهاز BitBox جديد أو من خلال مركز النسخة الاحتياطية الخاص بنا",
      title: "لقد فقدت جهازي. ماذا افعل الآن؟"
    },
    useWithoutDevice: {
      text: "للأسف هذا غير ممكن في الوقت الحالي",
      title: "هل يمكنني استخدام التطبيق بدون جهاز؟"
    },
    welcome: {
      text: "شكرًا لاستخدام هذا التطبيق الذي صممته شركة Shift Crypto في سويسرا. نحن نقدر أي اقتراح لديك لمشاركته معنا. يرجى تقديم الملاحظات باستخدام الرابط في الأسفل",
      title: "مرحبًا بك في تطبيق BitBoxApp!"
    }
  }
}, headerssync$i = {
  blocksSynced: "{{blocks}} عدد البلوكات التي تم مطابقتها"
}, hiddenWallet$i = {
  info1HTML: "لأغراض الإنكار القانوني ، يمكن إنشاء محفظة مخفية بناءاً على <strong>اختلاف</strong> كلمة مرور الجهاز +  كلمة مرور الاسترداد",
  info2HTML: "حدد كلمة مرور الجهاز وكلمة مرور الاسترداد التي تريد ربطها بمحفظتك المخفية أدناه. يجب أن تكون كلمة مرور الجهاز وكلمة مرور الاسترداد <strong>مختلفة</strong> من تلك التي حددتها لمحفظتك الأساسية",
  passwordLabel: "كلمة مرور استرداد المحفظة المخفية",
  passwordPlaceholder: "يرجى تأكيد كلمة مرور استرداد المحفظة المخفية",
  pinLabel: "كلمة مرور جهاز المحفظة المخفية",
  pinRepeatLabel: "كرر كلمة مرور جهاز المحفظة المخفية",
  pinRepeatPlaceholder: "يرجى تأكيد كلمة مرور جهاز المحفظة المخفية",
  success: "تم إنشاء المحفظة المخفية بنجاح. أعد توصيل BitBox للدخول للمحفظة"
}, initialize$i = {
  create: "تعيين كلمة مرور الجهاز",
  creating: "جاري تعيين كلمة مرور الجهاز ...",
  error: {
    e102: "يجب أن تتكون كلمة مرور الجهاز من 4 أحرف على الأقل"
  },
  info: {
    description1: "اختر كلمة مرور جهازك. سيتم استخدامها للدخول الى جهاز BitBox الخاص بك",
    description2: "يمكنك استخدام الأرقام والحروف والرموز. توفر كلمات المرور الأطول مستوى أمن أعلى",
    description3: "إذا فقدت كلمة مرور الجهاز ، فسيتعين عليك إعادة ضبط جهازك واستعادة النسخة الاحتياطية من محفظتك",
    subtitle: "الآن ستقوم بتعيين كلمة مرور جهازك",
    title: "جاري تهيئة جهازك"
  },
  input: {
    label: "كلمه مرور الجهاز",
    labelRepeat: "كرر كلمة مرور الجهاز",
    placeholderRepeat: "يرجى تأكيد كلمة مرور الجهاز"
  }
}, invalidFormat$i = "صيغة غير صالحة", language$j = {
  title: "اختر اللغة"
}, legacyhiddenwallet$i = {
  disable: "تعطيل خاصية المحفظة القديمة المخفية ",
  enable: "تفعيل خاصية المحفظة القديمة المخفية ",
  successDisable: "تم تعطيل خاصية المحفظة القديمة المخفية",
  successEnable: "تم تفعيل المحفظة القديمة المخفية. أعد توصيل BitBox وأدخل كلمة مرور الجهاز المخفية للوصول إلى المحفظة المخفية القديمة"
}, loading$i = "جاري التحميل…", manageAccounts$c = {
  editAccount: "تعديل",
  editAccountNameTitle: "تعديل اسم الحساب",
  noAccounts: "لم يتم العثور على حسابات",
  settings: {
    hideTokens: "إخفاء العملات",
    showTokens: "إظهار العملات ({{activeTokenCount}})"
  },
  settingsButtonDescription: "إضافة وإظهار او إخفاء الحسابات",
  title: "إدارة الحسابات"
}, mobile$d = {
  usingMobileDataWarning: "استخدام بيانات الهاتف المحمول: قد يقوم هذا التطبيق بتنزيل ما يصل إلى بضع مئات من الميجابايت من بيانات تعريفية للبلوكشين بعد فتح الحساب. يرجى الاتصال بالانترنت Wi-Fi لتجنب الضغط على  انترنت الجوال. لن تظهر هذه الرسالة لك مرة أخرى بعد هذه المرة"
}, note$e = {
  input: {
    description: "(اختياري)",
    placeholder: "اضف ملاحظة…"
  },
  title: "ملاحظة"
}, notification$i = {
  newTxs_one: "معاملة جديدة في: {{accountName}}",
  newTxs_other: "{{count}} معاملات جديدة في: {{accountName}}"
}, pairing$i = {
  aborted: {
    text: "تم إلغاء الاقتران من تطبيق الهاتف المحمول",
    title: "تم الايقاف"
  },
  button: "إقران تطبيق الهاتف المحمول",
  confirm: "هل أنت متأكد أنك تريد إقران BitBox الخاص بك؟ يرجى ملاحظة انك ستحتاج الهاتف المحمول لتنفيذ اي تداول بعد إقران الهاتف",
  connectOnly: {
    button: "ربط تطبيق الهاتف المحمول",
    title: 'امسح باستخدام تطبيق الهاتف المحمول الخاص بالجهاز عن طريق تحديد الخيار من القائمة "الاتصال بتطبيق سطح المكتب الجديد"'
  },
  error: {
    text: "حدث خطأ ما. يرجى البدء مرة أخرى",
    title: "خطأ"
  },
  pullFailed: {
    text: "فشلت محاولة جلب الرسالة من هاتفك المحمول عبر سيرفير التوصيل. قد يكون سيرفير التوصيل غير متصل بالإنترنت، يرجى الاتصال بالدعم",
    title: "فشل الجلب"
  },
  reconnectOnly: {
    button: "أعد توصيل تطبيق الهاتف المحمول"
  },
  scanningFailed: {
    text: "لم يستطع الهاتف المحمول من مسح الرسالة بنجاح. حاول مرة اخرى",
    title: "فشل المسح"
  },
  start: {
    hideAppQRCode: "إخفاء رمز الاستجابة السريعة QR",
    revealAppQRCode: "إظهار رمز الاستجابة السريعة QR",
    step1: "إذا لم يكن لديك تطبيق الهاتف المحمول، فيمكنك مسح رمز الاستجابة السريعة QR لـ Apple App Store أو Google Play Store اعتمادًا على نوع الهاتف الذي لديك",
    step2: 'قم بالمسح باستخدام تطبيق الهاتف المحمول الخاص بنا، والذي يمكنك العثور عليه تحت اسم "Digital Bitbox 2FA" في متاجر التطبيقات لنظامي التشغيل iOS و Android:'
  },
  started: {
    text: "الآن يرجى اتباع التعليمات الموجودة في تطبيق الهاتف المحمول",
    title: "رائع"
  },
  success: {
    text: "مبروك، لقد نجحت في إقران (ربط) جهاز BitBox الخاص بك بتطبيق الهاتف المحمول!",
    title: "نجاح"
  },
  timeout: {
    text: "انتهت مهلة الاقتران (الربط) بعد دقيقتين. ابدأ مرة أخرى إذا كنت لا تزال تريد إقران تطبيق الهاتف المحمول",
    title: "نفاذ الوقت"
  },
  title: "ربط الهاتف المحمول"
}, passphrase$c = {
  considerations: {
    button: "اعتبارات النسخة الاحتياطية",
    message: `تضيف كلمة المرور طبقة من الحماية إلى النسخة الاحتياطية من محفظتك (شريحة microSD أو 24 كلمة). إذا كان لدى شخص ما حق الوصول إلى نسختك الاحتياطية ، فسيحتاج أيضًا إلى كلمة المرور للوصول إلى محفظتك.

ومع ذلك ، هذا يعني أنك ستحتاج <strong>كلا من عبارة المرور + النسخة الاحتياطية للمحفظة</strong> لاستعادة محفظتك التي تدعم كلمة المرور ، في حالة فقدان او عطل BitBox02. إذا نسيت أو فقدت كلمة مرورك ، فستفقد إمكانية الوصول إلى جميع العملات الموجودة في تلك المحفظة.

عند تخزين كلمة مرورك ، ضع في اعتبارك وضعها في مكان منفصل عن النسخة الاحتياطية. بهذه الطريقة ، إذا وجد شخص ما النسخة الاحتياطية الخاصة بك ، فلن يجد كلمة مرورك أيضًا.`,
    title: "اعتبارات النسخة الاحتياطية"
  },
  disable: "تعطيل كلمة المرور",
  disableInfo: {
    button: "تعطيل",
    message: `بعد تعطيل خاصية طلب كلمة المرور ، لن يتم الطلب منك لإدخال كلمة مرور بعد إلغاء القفل BitBox02. لذلك ، سوف تدخل محفظتك الافتراضية.

ستظل جميع العملات في المحفظة ذات كلمة المرور كما هي في المحفظة ، ولكن لن تتمكن من الوصول إليها لأنه بعد فتح BitBox02 ، ستفتح محفظتك الاساسية الاولى.

للوصول إلى المحفظة ذات كلمة المرور الخاصة بك مرة أخرى ، ما عليك سوى إعادة تمكين ميزة كلمة المرور وإدخال كلمة المرور الخاصة بها بعد إلغاء قفل BitBox02.

<strong>نصيحة:</strong> لا يزال بإمكانك دخول محفظتك الأصلية عن طريق ترك كلمة المرور فارغة.`
  },
  enable: "تفعيل كلمة المرور",
  error: {
    e104: "تم إيقاف تغيير إعداد كلمة المرور"
  },
  how: {
    button: "كيف تظهر",
    message: `لا تعمل كلمة المرور مثل كلمة المرور التي اعتدت عليها. إذا أخطأت في كتابة كلمة مرورك ، فلن يتم تنبيهك. هذا بسبب <strong>كل كلمة مرور تنشئ محفظة مختلفة ولكنها صالحة</strong>. هذا يعني أنه يمكنك استخدام كلمات مرور متعددة لأي عدد تريده من المحفظات. ولكن لا يمكن الوصول إلى كل محفظة إلا عند كتابة كلمة المرور المقابلة.

عند توصيل BitBox02 ، ستتم مطالبتك بكلمة مرور الجهاز كالمعتاد. بعد ذلك ، سيُطلب منك إدخال كلمة مرور على الجهاز.

بعد إدخال كلمة المرور ، ستظهر لك كلمة المرور التي أدخلتها. هذا حتى تتمكن من تأكيد أنك أدخلته بشكل صحيح.`,
    title: "كيف تعمل"
  },
  intro: {
    message: `توفر كلمة المرور طبقة إضافية من الأمان على محفظتك.
دعونا نتعلم كيف تعمل`,
    title: "إعداد كلمة المرور"
  },
  progressDisable: {
    message: "قم بتأكيد الاختيار على جهاز المحفظة <strong>لايقاف تفعيل</strong> كلمة المرور الاختيارية",
    title: "قم بالتأكيد على الجهاز"
  },
  progressEnable: {
    message: "قم بتأكيد الاختيار على جهاز المحفظة <strong>لتفعيل</strong> كلمة المرور الاختيارية",
    title: "قم بالتأكيد على الجهاز"
  },
  successDisabled: {
    message: `<strong>تم التفعيل بنجاح</strong> لكلمة المرور الاختيارية!
سيبدأ طلب كلمة مرور منك من الآن فصاعدًا.`,
    messageEnd: "يرجى إعادة توصيل BitBox02 الآن",
    title: "تم تفعيل خاصية كلمة المرور"
  },
  successEnabled: {
    message: `<strong>تم ايقاف التفعيل بنجاح</strong> لكلمة المرور الاختيارية!

لن يتم طلب كلمة مرور منك بعد الآن.`,
    messageEnd: "يرجى إعادة توصيل BitBox02 الخاص بك الآن",
    tips: "نصائح",
    tipsList: [
      "نقترح إرسال مبلغ صغير إلى المحفظة التي فيها كلمة المرور أولاً. ثم افصل جهاز BitBox02 وأعد توصيله وأدخل كلمة السر وكلمة المرور الخاصة بك. إذا أدخلت كلمة المرور بشكل صحيح فستجد العملات في محفظتك",
      "إذا كنت تريد الدخول الى محفظتك الأصلية بدون كلمة مرور ، فلا يزال بإمكانك القيام بذلك عن طريق عدم إدخال أي شيء عند مطالبتك بإدخال كلمة المرور. أو يمكنك تعطيل ميزة كلمة المرور"
    ],
    title: "الغاء تفعيل كلمة المرور"
  },
  summary: {
    button: "تفعيل كلمة المرور",
    title: "خلاصة",
    understand: "انا أفهم كيف تعمل كلمة المرور والمخاطر المرتبطة بها",
    understandList: [
      "كلمة المرور هي طبقة أمان إضافةً الى النسخة الاحتياطية",
      "سيؤدي إدخال كلمة مرور مختلفة إلى إنشاء محفظة مختلفة",
      "لاستعادة محفظتك تحتاج <strong>كل من كلمة المرور والنسخة الاحتياطية</strong>",
      "إذا نسيت كلمة مرورك ، فلن يكون بإمكانك الوصول إلى عملاتك"
    ]
  },
  what: {
    button: "تعلم كيف يعمل هذا الشي",
    message: `يتم إنشاء (اشتقاق) المحفظة من رقم عشوائي كبير جدًا ، يُعرف أيضًا باسم المفاتيح. يتم إنشاء هذه المفاتيح عند إعداد BitBox02 لأول مرة ويتم نسخها احتياطيًا باستخدام شريحة microSD أو 24 كلمة. أي شخص لديه حق الوصول إلى البذور لديه سيطرة كاملة على الأموال الموجودة في تلك المحفظة.

عبارة المرور هي ملف <strong>سر اختياري</strong>، يضاف إلى المفاتيح (الكلمات السرية). عند استخدام كلمة مرور ، تُنشئ كل كلمة مرور محفظة جديدة بناءاً على المفاتيح + كلمة المرور (سر اختياري). يمكن أن تكون كلمة المرور أي شيء: أحرف أو كلمات أو أحرف خاصة أو يمكن أن تكون فارغة. المحفظة الاصلية مشتقة في الواقع من المفاتيح + كلمة مرور فارغة.

تعد كلمة المرور جزءًا من معيار BIP39 ، مما يعني أنها متوافقة مع جميع المحفظات التي تدعم نفس المعيار`,
    title: "ما هي كلمة المرور؟"
  },
  why: {
    button: "لماذا استخدام كلمة المرور",
    message: `يحمي BitBox02 المفاتيح من الاستخراج من الجهاز نفسه ، لكن النسخة الاحتياطية (شريحة microSD أو 24 كلمة) تتيح الوصول الكامل إلى المحفظة. لهذا يجب تخزينها في مكان آمن!

نظرًا لأن كلمة المرور تنشئ محفظة جديدة باستخدام مفاتيحك الحالية ، فإن محفظة كلمة المرور تتطلب كلاً من ملف <strong>النسخة الاحتياطية و كلمة المرور للاستعادة</strong>. وتتمثل فائدة ذلك في أنه إذا وجد شخص ما النسخة الاحتياطية الخاصة بك ، فسيظل بحاجة إلى كلمة المرور للوصول إلى المحفظة المحمية بكلمة المرور.

بالإضافة إلى ذلك ، تتيح لك ميزة كلمة المرور إنشاء محفظات متعددة على نفس الجهاز ، أو "محفظات مخفية" بالإضافة إلى المحفظة الافتراضية.`,
    title: "لماذا استخدام كلمة المرور؟"
  }
}, password$i = {
  show: "عرض {{label}}",
  warning: {
    caps: "تحذير: تم تمكين caps lock (⇪)",
    paste: 'للصق النص، قم بتمكين "إظهار {{label}}"'
  }
}, random$j = {
  button: "صناعة رقم عشوائي",
  description: "أنشأ BitBox الخاص بك الرقم العشوائي {{bits}}-بت التالي:"
}, receive$k = {
  changeScriptType: "تغيير نوع العنوان",
  label: "عنوانك",
  onlyThisCoin: {
    description: "لتلقي العملات الأخرى ، قم بتمكينها في الإعدادات. إذا قمت بإيداع عملات مختلفة ، فقد يتعذر الوصول إليها",
    warning: "تأكد من أنك تستلم {{coinName}} فقط على هذا العنوان"
  },
  scriptType: {
    p2tr: "Taproot (أحدث صيغة)",
    p2wpkh: "Native Segwit (اصلي)",
    "p2wpkh-p2sh": "الـ Segwit المبطن (صيغة متوافقة)"
  },
  showFull: "إظهار العنوان الكامل على الجهاز والتحقق منه",
  taprootWarning: "ملاحظة: Taproot هي ميزة بروتوكول جديدة من بتكوين ولم يتم اعتمادها على نطاق واسع بعد. قد لا تظهر الأموال المستلمة على عناوين Taproot في محفظات المراقبة فقط التابعة لجهات خارجية. العديد من المحفظات والتبادلات ليست قادرة بعد على الإرسال إلى عناوين Taproot",
  title: "استلم {{accountName}}",
  verify: "تحقق من العنوان بشكل آمن",
  verifyBitBox01: "تحقق من العنوان على تطبيق الهاتف المحمول",
  verifyBitBox02: "تحقق من العنوان على BitBox02",
  verifyInstruction: "يرجى التحقق من أن العنوان التالي يطابق العنوان المعروض على جهازك",
  warning: {
    secureOutput: 'يرجى إقران BitBox بجهازك المحمول لتمكين التحقق من العنوان الآمن. انتقل إلى "إدارة الجهاز" في الشريط الجانبي'
  }
}, reset$i = {
  description: "سيتم حذف جميع البيانات الموجودة على الجهاز. بما يتضمن مفتاحك الخاص!",
  notReset: "لم يتم إعادة ضبط الجهاز",
  title: "جهاز إعادة ضبط المصنع",
  understand: "لدي نسخة احتياطية وأعرف كلمة مرور الاسترداد الخاصة بي",
  understandBB02: "لدي نسخة احتياطية صالحة"
}, securityInformation$i = {
  create: {
    description1: "نوصيك بإعداد جهازك في مكان آمن، مما يعني أنك بعيد عن الأشخاص الآخرين الذين يمكنهم رؤية كلمة المرور التي تختارها",
    description2: "سيُطلب منك إنشاء كلمتين من كلمات المرور",
    description3: "الأول هو <strong>كلمه مرور الجهاز</strong> الذي يفتح جهاز BitBox الخاص بك ويمكن تغييره لاحقاً",
    description4: "والثاني هو <strong>استعادة كلمة المرور</strong> الذي يفتح محفظتك. لا يمكن تغيير كلمة المرور هذه لاحقاً",
    description5: "سيتم نسخ المحفظة التي تقوم بإنشائها احتياطيًا في ملف موجود على شريحة microSD المتوفرة. يمكن استخدام هذا في حالات الطوارئ لاسترداد أموالك باستخدام <strong>استعادة كلمة المرور</strong>.",
    title: "بيانات امنية"
  },
  restore: {
    description1: "سيُطلب منك إدخال شريحة microSD التي استخدمتها لتخزين النسخة الاحتياطية",
    description2: "لاستعادة جهازك ، ستحتاج إلى كلمة مرور الاسترداد الخاصة بك",
    description3: "يرجى توخي الحذر عند إدخال كلمة مرور الاسترداد. أي كلمة مرور تدخلها ستنشئ محفظة صالحة. إذا أدخلت كلمة مرور خاطئة ، فقد يظهر لك رصيد خاطئ في المحفظة",
    title: "بيانات امنية"
  }
}, seed$i = {
  agreements: {
    "funds-access": "لن أتمكن من الوصول إلى أموالي إذا نسيت كلمة مرور الاسترداد الخاصة بي",
    "password-change": "لا يمكنني تغيير كلمة مرور الاسترداد لاحقاً",
    "password-required": "كلمة مرور الاسترداد مطلوبة لاستعادة المحفظة من نسخة احتياطية"
  },
  create: "صنع المحفظة",
  creating: "إنشاء المحفظة",
  description: "انا افهم التالي:",
  error: {
    e102: "يجب ان تحتوي كلمة المرور على 4 رموز على الاقل",
    e200: "تحتاج إلى إدخال شريحة microSD في BitBox الخاص بك من أجل إنشاء محفظة، بحيث يمكن إنشاء نسخة احتياطية تلقائيًا"
  },
  info: {
    button: "قم بتعيين كلمة مرور الاسترداد الآن",
    description1: "أدخل شريحة microSD في BitBox",
    description2: 'اختر كلمة مرور استرداد للمحفظة و حدد "تعيين كلمة مرور الاسترداد الآن"',
    description3: "النسخة الاحتياطة لشريحة microSD وكلمة مرور الاسترداد هي الطريقة الوحيدة لاسترداد أموالك في حالة فقدان جهاز BitBox أو سرقته",
    description4: "لا يمكنك تغيير كلمة مرور الاسترداد الخاصة بك لاحقًا دون تحويل أموالك",
    title: "أنشئ محفظة جديدة"
  },
  password: {
    label: "استعادة كلمة المرور",
    repeatPlaceholder: "تكرار كلمة استعادة المرور"
  },
  walletName: {
    label: "اسم المحفظة"
  }
}, seedRestore$i = {
  error: {
    e200: "تتطلب عملية استعادة محفظة من نسخة احتياطية وجود شريحة microSD"
  },
  info: {
    description1: 'أدخل شريحة microSD في BitBox و اكبس على "استمرار"',
    description2: 'اختر نسخة احتياطية و اكبس على "استعادة"',
    description3: "أدخل كلمة مرور الاسترداد",
    description4: "تحتاج إلى التأكيد لفهم أن كلمة المرور غير الصحيحة ستؤدي إلى إنشاء محفظة مختلفة",
    title: "كيفية استعادة محفظة من نسخة احتياطية"
  }
}, send$k = {
  abort: "تم إيقاف المعاملة",
  address: {
    label: "عنوان المستلم",
    placeholder: "أدخل العنوان"
  },
  amount: {
    label: "المبلغ",
    placeholder: "أدخل المبلغ"
  },
  availableBalance: "الرصيد المتبقي",
  button: "إعادة التدقيق",
  coincontrol: {
    address: "عنوان",
    outpoint: "نقطة الخروج",
    title: "أرسل من الإخراج"
  },
  confirm: {
    "selected-coins": "عملات مختارة",
    title: "تأكيد و إرسال المعاملة",
    total: "المجموع"
  },
  error: {
    erc20InsufficientGasFunds: "يبدو أنه ليس لديك ما يكفي من الاثيريوم للدفع مقابل معاملة ERC20 هذه. يرجى التأكد من أن لديك ما يكفي من الاثيريوم في محفظتك",
    feeTooLow: "رسوم منخفضة للغاية",
    feesNotAvailable: "لا يمكن تقييم الرسوم",
    insufficientFunds: "رصيد غير كافي",
    invalidAddress: "عنوان خاطئ",
    invalidAmount: "مبلغ غير صحيح",
    invalidData: "بيانات غير صالحة"
  },
  fee: {
    customPlaceholder: "أدخل المبلغ",
    label: "رسوم الشبكة",
    placeholder: "غير متوفر"
  },
  feeTarget: {
    customLabel: "معدل الرسوم",
    customLabel_eth: "سعر عمولة الجاز",
    description: {
      economy: "4 ساعات (24 بلوك)",
      economy_eth: "30 دقيقة أو أقل",
      economy_ltc: "ساعة واحدة (24 بلوك)",
      high: "20 دقيقة (بلوكين)",
      high_eth: "30 ثانية أو أقل",
      high_ltc: "5 دقائق (بلوكين)",
      low: "ساعتان (12 بلوك)",
      low_eth: "5 دقائق أو أقل",
      low_ltc: "30 دقيقة (12 بلوك)",
      normal: "1 ساعة (6 بلوكات)",
      normal_eth: "دقيقتان أو أقل",
      normal_ltc: "15 دقيقة (6 بلوكات)"
    },
    estimate: "تقدير مدة التأكيد:",
    label: {
      custom: "معدلة",
      economy: "توفيري",
      high: "عالية",
      low: "منخفضة",
      normal: "عادي"
    },
    placeholder: "جاري حساب الرسوم ..."
  },
  maximum: "أرسل كل شيء",
  maximumSelectedCoins: "أرسل العملات المختارة",
  priority: "أولوية",
  scanQR: "مسح رمز الاستجابة السريعة QR",
  signprogress: {
    description: "هذه معاملة تحتوي على الكثير من البيانات. لتوقيع المعاملة بالكامل ، سيُطلب منك التأكيد {{steps}} مرات",
    label: "تقدم"
  },
  success: "تم توقيع المعاملة وإرسالها",
  title: "إرسال {{accountName}}",
  toggleCoinControl: "تبديل خاصية التحكم في العملة coin control",
  transactionDetails: "تفاصيل المعاملة"
}, settings$j = {
  electrum: {
    add: "أضف السيرفير",
    "add-server": "اضافة",
    check: "تأكد",
    checkFailed: "فشلت المحاولة",
    checkSuccess: "تم بنجاح إنشاء اتصال بـ {{host}}",
    checking: "التأكد",
    "download-cert": "قم بتنزيل الشهادة عن بعد",
    "remove-server": "حذف",
    removeConfirm: "حذف {{server}}؟",
    reset: "إعادة الحالة إلى الحالة الاصلية",
    resetConfirm: "هل تريد إزالة جميع السيرفيرات وتثبيت السيرفيرات الافتراضية؟",
    servers: "سيرفيرات",
    step1: "1",
    "step1-text": "قم بإدخال نقطة النهاية",
    step2: "2",
    "step2-text": "أدخل شهادة من سلسلة شهادات السيرفير. أو بدلاً من ذلك ، قم بتنزيل الشهادة عن بُعد ومقارنتها بصريًا",
    "step2-text-tcp": "يمكنك تخطي هذه الخطوة إذا كنت لا تريد استخدام TLS",
    step3: "3",
    "step3-text": "تحقق من الاتصال وأضف السيرفير",
    step4: "4",
    "step4-text": "أعد تشغيل المحفظة. إذا لم تقم بإزالة السيرفيرات الاولية، فستتم إضافة النود الخاصة بك كاحتياط",
    "title-btc": "سيرفيرات Electrum لعملة بتكوين ",
    "title-ltc": "سيرفيرات Electrum لعملة لايتكوين ",
    "title-tbtc": "سيرفيرات Electrum للشبكة التجريبية لعملة بتكوين ",
    "title-tltc": "سيرفيرات Electrum للشبكة التجريبية لعملة لايتكوين "
  },
  expert: {
    coinControl: "تفعيل خاصية التحكم في العملة coin control",
    electrum: {
      title: "قم بتوصيل النود الخاصة بك"
    },
    fee: "تفعيل الرسوم القابلة للتعديل",
    setProxyAddress: "تعيين عنوان بروكسي",
    title: "الإعدادات المتقدمة",
    useProxy: "تفعيل tor proxy",
    useSats: "عرض قيم البتكوين بوحدة Satoshi"
  },
  header: {
    home: "الواجهة الرئيسية"
  },
  info: {
    "out-of-date": "هنالك تحديث جديد",
    title: "معلومات",
    "up-to-date": "تطبيقك فيه آخر تحديث",
    version: "نسخة التطبيق"
  },
  restart: "يرجى إعادة تشغيل تطبيق BitBox من اجل تفعيل التغييرات",
  services: {
    title: "الخدمات"
  },
  success: "يرجى فصل BitBox وإعادة توصيله من اجل تفعيل التغييرات",
  title: "الإعدادات"
}, setup$i = "إعداد الجهاز", sidebar$j = {
  buy: "شراء العملات المشفرة",
  device: "إدارة الجهاز",
  leave: "الخروج",
  settings: "إعدادات"
}, success$p = {
  create: {
    info1: "تم نسخ محفظتك احتياطيًا بشكل آمن إلى شريحة microSD. قم بإزالته واحتفظ به بشكل آمن في مكان آمن",
    info2: "لقد أنشأت كلمة مرور آمنة للجهاز لفتح قفل BitBox",
    info3: "لقد أنشأت كلمة مرور آمنة لاسترداد محفظتك و الدخول الى أموالك و استعادة نسختك الاحتياطية",
    summary: "هنا ملخص لما قمت به",
    title: "نجاح"
  },
  getstarted: "البدء",
  restore: {
    summary: "لقد نجحت في استعادة محفظة من نسختك الاحتياطية",
    title: "النجاح"
  }
}, transaction$j = {
  confirmation: "التأكيدات",
  details: {
    activity: "النشاط",
    address: "عنوان",
    amount: "المبلغ",
    date: "التاريخ",
    fiat: "العملة التقليدية (فيات)",
    fiatAmount: "كمية مبلغ العملة التقليدية",
    fiatAtTime: "العملة التقليدية في وقت التداول",
    status: "الحالة",
    type: "النوع"
  },
  explorer: "رقم المعاملة",
  explorerTitle: "فتح في مستكشف البلوكشين",
  fee: "العمولة",
  fiatHistorical: "تاريخي",
  gas: "عمولة الجاز",
  note: {
    edit: "تعديل مذكرة",
    save: "احفظ المذكرة"
  },
  pending: "عملية تداول معلقة",
  size: "حجم",
  status: {
    complete: "اكتملت",
    failed: "فشلت المحاولة",
    pending: "قيد الانتظار"
  },
  tx: {
    received: "تم الاستلام الى",
    sent: "تم الارسال الى"
  },
  vsize: "الحجم الافتراضي",
  weight: "وزن"
}, transactions$i = {
  placeholder: "لا توجد معاملات حتى الآن"
}, unknownError$i = "حدث خطأ غير معروف: {{errorMessage}}", unlock$i = {
  description: "أدخل كلمة مرور جهازك لفتح قفل جهازك",
  error: {
    e109_normal: "كلمة مرور الجهاز خاطئة. {{remainingAttempts}} محاولات متبقية قبل إعادة ضبط الجهاز",
    e109_touch: "$t(unlock.error.e109_normal) يتطلب تسجيل الدخول التالي الضغط على زر اللمس",
    e113: "نظرًا لمحاولات تسجيل الدخول العديدة ، يتطلب في محاولة تسجيل الدخول التالية ان تضغط على زر اللمس لمدة 4 ثواني"
  },
  input: {
    label: "كلمه مرور الجهاز",
    placeholder: "أدخل كلمة مرور جهازك لفتح قفل الجهاز"
  },
  unlocking: "جاري فتح القفل ..."
}, upgradeFirmware$j = {
  button: "تحديث البرنامج الثابت",
  description: "هل تريد ترقية البرنامج الثابت من الإصدار {{currentVersion}} إلى {{newVersion}}؟",
  label: "يتطلب جهازك BitBox تحديث البرنامج الثابت",
  locked: "للتحديث من {{currentVersion}} إلى {{newVersion}}، من فضلك قم بلمسة طويلة",
  title: "تحديث البرنامج الثابت",
  unlocked: "محمل التشغيل للبرنامج مفتوح. للاستمرار، يرجى:",
  unlocked1: "افصل وأعد توصيل Bitbox",
  unlocked2: "سيضيء LED عند توصيل BitBox مرة أخرى",
  unlocked3: "اضغط على زر اللمس عندما يضيء ضوء LED"
}, warning$o = {
  receivePairing: 'يرجى ربط BitBox لتمكين التحقق من العنوان الآمن. انتقل إلى "إدارة الجهاز" في الشريط الجانبي',
  sdcard: "احتفظ بشريحة microSD المخزونة منفصلة عن BitBox ، إلا إذا كنت تريد إدارة النسخة الاحتياطية",
  sendPairing: "يرجى ربط جهاز BitBox من اجل التأكد من تفاصيل التداولات بشكل آمن. إذهب الى ‘لتحكم بالجهاز‘ في القائمة الجانبية"
}, welcome$i = {
  getStarted: "لنبدأ بتثبيت نظام تشغيل جهاز محفظة BitBox02",
  insertBitBox02: "يرجى الكبس على جهاز المحفظة للاستمرار في محفظة BitBox02 ",
  insertDevice: "يرجى ربط جهازك للبدء",
  title: "مرحباً"
}, appTranslationsAR = {
  account: account$i,
  accountInfo: accountInfo$i,
  accountSummary: accountSummary$i,
  addAccount: addAccount$j,
  aopp: aopp$c,
  app: app$i,
  backup: backup$i,
  bb02Bootloader: bb02Bootloader$i,
  bitbox: bitbox$i,
  bitbox02Interact: bitbox02Interact$i,
  bitbox02Settings: bitbox02Settings$i,
  bitbox02Wizard: bitbox02Wizard$i,
  blink: blink$i,
  bootloader: bootloader$i,
  button: button$m,
  buy: buy$e,
  changePin: changePin$i,
  chart: chart$e,
  checkSDcard: checkSDcard$i,
  clickHere: clickHere$i,
  confirm: confirm$k,
  confirmOnDevice: confirmOnDevice$i,
  device: device$i,
  deviceLock: deviceLock$i,
  deviceSettings: deviceSettings$i,
  deviceTampered: deviceTampered$i,
  dialog: dialog$j,
  error: error$e,
  fiat: fiat$k,
  footer: footer$k,
  generic: generic$e,
  genericError: genericError$i,
  goal: goal$i,
  guide: guide$j,
  headerssync: headerssync$i,
  hiddenWallet: hiddenWallet$i,
  initialize: initialize$i,
  invalidFormat: invalidFormat$i,
  language: language$j,
  legacyhiddenwallet: legacyhiddenwallet$i,
  loading: loading$i,
  manageAccounts: manageAccounts$c,
  mobile: mobile$d,
  note: note$e,
  notification: notification$i,
  pairing: pairing$i,
  passphrase: passphrase$c,
  password: password$i,
  random: random$j,
  receive: receive$k,
  reset: reset$i,
  securityInformation: securityInformation$i,
  seed: seed$i,
  seedRestore: seedRestore$i,
  send: send$k,
  settings: settings$j,
  setup: setup$i,
  sidebar: sidebar$j,
  success: success$p,
  transaction: transaction$j,
  transactions: transactions$i,
  unknownError: unknownError$i,
  unlock: unlock$i,
  upgradeFirmware: upgradeFirmware$j,
  warning: warning$o,
  welcome: welcome$i
}, account$h = {
  disconnect: "Ztráta spojení. Pokus o opětovné připojení...",
  export: "Export",
  exportTransactions: "Export transakcí do složky ke stažení jako soubor CSV",
  fatalError: "Došlo k neočekávané chybě.",
  incoming: "Přicházející",
  initializing: "Získávání informací z blockchainu...",
  maybeProxyError: "Tor proxy aktivní. Ujistěte se, že proxy server Tor běží správně, nebo nastavení proxy serveru deaktivujte.",
  reconnecting: "Ztráta spojení. Pokus o opětovné připojení...",
  syncedAddressesCount: "Naskenováno {{count}} adres"
}, accountInfo$h = {
  address: "Adresa",
  buyCTA: {
    buy: "Koupit  {{unit}}",
    buyCrypto: "Koupit Krypto",
    information: {
      looksEmpty: "Zdá se, že tato peněženka je prázdná.",
      start: "Začněte vkladem do peněženky, nebo nákupem přímo v BitBoxApp."
    }
  },
  extendedPublicKey: "Veřejný klíč",
  label: "Detaily účtu",
  scriptType: "Typ účtu",
  title: "Detaily účtu",
  verify: "Ověřte na zařízení",
  xpubTypeChangeBtn: {
    p2pkh: "Zobrazit legacy P2PKH veřejný klíč",
    p2tr: "Zobrazit Taproot",
    p2wpkh: "Zobrazit nativní Segwit",
    "p2wpkh-p2sh": "Zobrazit starší Segwit veřejný klíč"
  },
  xpubTypeInfo: "Aktuálně se zobrazuje {{scriptType}} veřejný klíč ({{current}} z {{numberOfXPubs}})"
}, accountSummary$h = {
  availableBalance: "Dostupný zůstatek",
  balance: "Zůstatek",
  exportSummary: "Exportovat přehled účtů do složky ke stažení jako soubor CSV",
  fiatBalance: "Fiat zůstatek",
  name: "Název účtu",
  noAccount: "Žádné účty k zobrazení.",
  subtotalWithCoinName: "Celkem ({{coinName}})",
  title: "Moje portfolio",
  total: "Celkem",
  transactionHistory: "Transakční historie"
}, addAccount$i = {
  chooseName: {
    nextButton: "Přidat účet",
    step: "Pojmenujte účet",
    title: "Pojmenujte svůj účet"
  },
  selectCoin: {
    nextButton: "Další",
    step: "Vybrat kryptoměnu",
    title: "Vybrat kryptoměnu"
  },
  success: {
    addAnotherAccount: "Přidat další účet",
    message: "<strong>{{accountName}}</strong> byl nyní přidán k vašim účtům.",
    nextButton: "Hotovo",
    step: "Dokončeno",
    title: "Účet přidán"
  },
  title: "Přidat účet"
}, aopp$b = {
  addressRequest: "{{host}} požaduje přijímací adresu.",
  addressRequestWithLogo: "požaduje přijímací adresu.",
  banner: "Probíhá žádost o adresu.",
  errorTitle: "Chyba při požadavku na adresu ",
  labelAddress: "Adresa",
  labelMessage: "Zpráva",
  reverifyInfoText: "Ověřit adresu",
  signing: "Chcete-li pokračovat, podepište zprávu na svém BitBoxu",
  success: {
    message: "Pokračovat na {{host}}",
    title: "Adresa byla úspěšně odeslána"
  },
  syncing: "Synchronizace účtu, vyčkejte prosím.",
  title: "Požadavek na adresu"
}, app$h = {
  upgrade: "K dispozici je nová verze této aplikace! Aktualizuje prosím z {{current}} na {{version}}."
}, auth$a = {
  authButton: "Ověřit",
  title: "Chcete-li pokračovat, proveďte ověření"
}, backup$h = {
  check: {
    checking: "Kontrola zálohy...",
    confirmTitle: "Zkontrolovat zálohu",
    notOK: "Záloha NEODPOVÍDÁ peněžence.",
    ok: "Záloha odpovídá peněžence.",
    password: {
      label: "Heslo pro obnovení",
      placeholder: "Heslo pro obnovení",
      showLabel: "heslo pro obnovení"
    },
    success: "Záloha byla úspěšně ověřena:",
    title: "Zkontrolovat zálohu"
  },
  create: {
    alreadyExists: "Již máte platnou zálohu. Chcete ji znovu vytvořit?",
    fail: "Vytvoření zálohy SELHALO!",
    info: "Pro ověření zadejte heslo pro obnovení aktuální peněženky.",
    name: {
      label: "Název zálohy",
      placeholder: "Pojmenujte prosím zálohu"
    },
    password: {
      label: "Heslo pro obnovení",
      placeholder: "Zadejte prosím heslo pro obnovení"
    },
    title: "Vytvořit zálohu",
    verificationFailed: 'Heslo pro obnovení se NESHODUJE s aktuální peněženkou. Záloha byla vytvořena. Pro opětovné ověření hesla pro obnovení použijte funkci "Zkontrolovat zálohu".'
  },
  description: "Vyberte <strong>soubor zálohy peněženky</strong>",
  insert: "Pro správu záloh prosím vložte microSD kartu.",
  insertButton: "Vložil jsem microSD kartu.",
  list: "Vaše zálohy na microSD kartě",
  noBackups: "Na této microSD kartě nejsou žádné zálohy.",
  restore: {
    confirmTitle: "Obnovit ze zálohy",
    error: {
      e200: "Karta microSD nenalezena",
      general: "Chyba při obnově ze zálohy"
    },
    password: {
      label: "Heslo pro obnovení nebo skryté heslo pro obnovení",
      placeholder: "Heslo pro obnovení",
      repeatPlaceholder: "Zopakujte heslo pro obnovení",
      showLabel: "Heslo pro obnovení"
    },
    restoring: "Obnova ze zálohy...",
    selectedBackup: "<strong>{{backupName}}</strong> vytvořena {{createdDateTime}} bude obnovena.",
    title: "Obnovit",
    understand: "Rozumím, že nesprávné heslo pro obnovení vytvoří jinou peněženku."
  },
  showMnemonic: {
    description: `Zobrazí se vám slova pro obnovení - obnovovací seed, ten tvoří zálohu vaší peněženky. Napište si je na papír.

<strong>Neukládejte je digitálně ani je nefoťte.</strong>

<strong>Neříkejte tato slova nahlas.</strong>

<strong>Tato záloha není chráněna heslem.</strong>

Poté budete vyzváni k potvrzení každého slova.
`,
    title: "Zobrazit slova pro obnovení",
    warning: "<strong> Nikdy nikomu nesdělujte svá slova pro obnovení.</strong> Vaše slova pro obnovení poskytují plný přístup k vaší peněžence. Pokud vás někdo žádá o vaše slova pro obnovení, jedná se o podvodníka, nesdílejte je!"
  },
  title: "Spravovat zálohy"
}, bb02Bootloader$h = {
  abort: "Neaktualizovat - zpět",
  abort_noUpgrade: "Zpět",
  advanced: {
    label: "Rozšířená nastavení",
    toggleShowFirmwareHash: "Zobrazit hash firmwaru při každém spuštění"
  },
  flipscreen: "Otoč obrazovku",
  orientation: "Špatná orientace zařízení?",
  success: "Aktualizace úspěšná! Pokračování za {{rebootSeconds}} sekund...",
  success_install: "Instalace proběhla úspěšně! Pokračování za {{rebootSeconds}} sekund..."
}, bitbox$h = {
  error: {
    e10000: "Heslo pro aktuální zařízení není správné.",
    e10001: "Nepodařilo se nahradit heslo zařízení",
    e102: "Heslo musí obsahovat alespoň 4 znaky.",
    e112: "Skryté heslo zařízení nemůže být stejné jako heslo hlavního zařízení."
  }
}, bitbox02Interact$h = {
  confirmDate: "Potvrďte dnešní datum na svém BitBox02",
  confirmDateText: "Toto datum se použije pro vytvoření zálohy.",
  confirmName: "Potvrďte název na BitBox02",
  confirmWords: "Zapište si {{amount}} slov pro obnovení z vašeho BitBox02",
  confirmWordsText: "Poté vás BitBox02 požádá o potvrzení každého slova, aby se ověřilo, že záloha je správná.",
  followInstructions: "Postupujte podle pokynů na vašem BitBox02.",
  followInstructionsMnemonic: "Postupujte dle pokynů na Vašem BitBox02 – zadejte slova pro obnovení z vaší zálohy a obnovte peněženku.",
  followInstructionsMnemonicTitle: "Obnovit ze slov pro obnovení"
}, bitbox02Settings$h = {
  deviceName: {
    current: "Aktuální název zařízení",
    error: "Název zařízení se nepodařilo nastavit",
    error_104: "Potvrzení názvu zařízení bylo na zařízení zrušeno.",
    input: "Název BitBox02",
    placeholder: "Nový název zařízení",
    title: "Nastavit název pro BitBox02"
  },
  gotoStartupSettings: {
    description: "Tím se zařízení BitBox02 restartuje a vstoupí do nastavení při spuštění.",
    title: "Přejít do nastavení při spuštění"
  }
}, bitbox02Wizard$h = {
  advanced: {
    button: "Pokročilé nastavení",
    outOfDate: "Firmware je pro tuto funkci zastaralý",
    seed12WordInfo: "Upozorňujeme, že počet slov nelze po vytvoření peněženky změnit.",
    seed12WordLabel: "Vytvořit 12slovný namísto 24slovného seed",
    seed12WordText: "Ve výchozím nastavení používá BitBox02 seed s 24 slovy. Obě délky seedů jsou v praxi bezpečné proti brute force útoku. Někteří uživatelé mohou místo toho upřednostnit 12slovný seed.",
    skipSDCardLabel: "Přeskočte zálohování na microSD kartu a místo toho si zapište slova pro obnovení.",
    skipSDCardText: "Po nastavení máte vždy možnost vytvořit zálohu karty microSD nebo zapsat slova pro obnovení. To lze provést z nastavení.",
    title: "Pokročilé možnosti zálohování"
  },
  attestationFailed: "Kontrola originality selhala, což mohlo být způsobeno restartováním aplikace v době, kdy zařízení čekalo na vstup uživatele. Znovu se připojte a zkuste to znovu. Pokud tento problém přetrvává, obraťte se prosím na support@bitbox.swiss.",
  backup: {
    point1: "Vyberte zálohu na microSD kartě",
    point2: "Nastavit heslo pro zařízení",
    restoreText: "Ok, obnovíme ze zálohy!",
    text1: "Skvělé, vaše heslo pro BitBox02 je nyní nastaveno a peněženka vytvořena. Nyní je čas vytvořit první zálohu. Ujistěte se, že je vaše microSD karta vložena do vašeho BitBox02 a pokračujte.",
    text2: "Vytvořte zálohu podle pokynů na obrazovce zařízení.",
    text3: "Po vytvoření zálohy vyjměte microSD kartu a uložte ji na <strong>bezpečné místo</strong>. Obsah microSD karty není chráněn heslem. Nikdy jej nevkládejte do jiného zařízení než do vašeho BitBox02.",
    userConfirmation1: "Zálohu bych měl uložit na bezpečném místě.",
    userConfirmation2: "Moje záloha není chráněna heslem. Kdokoli, kdo k ní má přístup, má přístup k mé peněžence.",
    userConfirmation3: "Pokud ztratím nebo poškodím svůj BitBox02, jediný způsob, jak získat zpět své prostředky, je obnovit peněženku ze zálohy.",
    userConfirmation4: "Pokud ztratím nebo poškodím zálohu i BitBox02, přijdu o své prostředky.",
    userConfirmation5: "MicroSD kartu s mou zálohou bych neměl vkládat do počítače, telefonu, tiskárny nebo jiného zařízení než BitBox02.",
    userConfirmation5mnemonic: "Neměl bych vkládat slova pro obnovení do počítače, telefonu, tiskárny nebo jiného zařízení, než je BitBox02."
  },
  create: {
    button: "Pojmenujte zařízení a pokračujte",
    info: "Zde jsou základní kroky, které je třeba udělat pro nastavení vašeho BitBoxu: ",
    inputTitle: "Název peněženky",
    point1: "Pojmenujte své zařízení",
    point2: "Nastavte heslo pro své zařízení",
    point3: "Vytvořit zálohu",
    text: "Ok, pojďme vytvořit novou peněženku!"
  },
  createBackupAborted: "Vytváření zálohy bylo zrušeno.",
  createBackupFailed: "Vytvoření zálohy se nezdařilo, zkuste to znovu.",
  initialize: {
    passwordText: "Nyní nastavíme heslo pro vaše zařízení. K zadání a výběru hesla použijte ovládací prvky na BitBoxu.",
    passwordTitle: "Nastavte heslo pro svůj BitBox",
    text: "Váš BitBox02 byl úspěšně spárován! Nyní inicializujeme vaše zařízení. Začněte výběrem vytvořit novou peněženku nebo obnovit peněženku ze zálohy. <strong>Ujistěte se, že je v Bitboxu vložena microSD karta</strong>",
    tip: "Doporučujeme, abyste pokračovali na bezpečném místě.",
    title: "Inicializujte svůj BitBox"
  },
  insertSDCard: "<strong>Ujistěte se, že je ve vašem BitBoxu vložena microSD karta.</strong>",
  noPasswordMatch: "Hesla se neshodují, zkuste to prosím znovu.",
  pairing: {
    failed: "Spárování nepotvrzeno. Znovu připojte svůj BitBox02.",
    paired: "Na svém zařízení jste potvrdili následující kód. Prosím pokračujte.",
    title: "Ověřte párovací kód",
    unpaired: "Byl zjištěn nespárovaný BitBox02. Prosím ověřte, že párovací kód odpovídá tomu, co je zobrazeno na vašem BitBoxu."
  },
  restoreFromMnemonic: {
    e104: "Obnovení ze slov pro obnovení bylo zrušeno.",
    failed: "Obnovení ze slov pro obnovení se nezdařilo, zkuste to prosím znovu."
  },
  stepBackup: {
    beforeProceed: "Než budete pokračovat, přečtěte si tato důležitá bezpečnostní opatření:",
    createBackup: "Nyní vytvoříte zálohu na microSD kartě.",
    createBackupMnemonic: "Nyní si zapíšete slova pro obnovení."
  },
  stepBackupSuccess: {
    fundsSafe: "Aby byly vaše prostředky v bezpečí, mějte na paměti následující:",
    title: "Záloha obnovena!"
  },
  stepConnected: {
    unlock: "Pro odemknutí zadejte heslo."
  },
  stepCreate: {
    description: "Tento název se používá jako název zařízení a pro zálohu.",
    nameLabel: "Název BitBox02",
    namePlaceholder: "Můj BitBox02",
    title: "Vyberte název pro BitBox02",
    toastMicroSD: "Vložte prosím svou microSD kartu do vašeho BitBox02, která bude použita k uložení zálohy peněženky."
  },
  stepCreateSuccess: {
    removeMicroSD: "Vyjměte microSD kartu z vašeho BitBox02 a uložte ji na bezpečné místo.",
    storeMnemonic: "Uložte svá slova pro obnovení na bezpečném místě",
    success: "Vaše záloha byla úspěšně vytvořena."
  },
  stepInsertSD: {
    insertSDCard: "Chcete-li pokračovat, vložte do svého BitBox02 microSD kartu.",
    insertSDcardTitle: "Vložte microSD kartu"
  },
  stepPassword: {
    e104: "Nastavení hesla bylo zrušeno.",
    title: "Nastavte heslo pro váš Bitbox02",
    useControls: "K nastavení hesla použijte ovládací prvky na vašem BitBox02."
  },
  stepUninitialized: {
    create: "Chci nastavit nový BitBox02.",
    restore: "Chci obnovit svou peněženku ze zálohy.",
    restoreMicroSD: "Obnovit z microSD karty",
    restoreMnemonic: "Obnovit ze slov pro obnovení",
    title: "Nastavte svůj BitBox02"
  },
  success: {
    text: `Hurá! Váš BitBox02 je nyní připraven k použití.

Chcete-li získat další informace o tom, jak používat BitBoxApp, použijte průvodce v aplikaci kliknutím na otazník v pravém horním rohu.`,
    title: "Jste připraveni!"
  }
}, blink$h = {
  button: "Blik"
}, bootloader$h = {
  button: "Nyní aktualizujte firmware",
  button_install: "Nyní nainstalujte firmware",
  progress: "Aktualizace: {{progress}}%",
  progress_install: "Instalace: {{progress}}%",
  success: "Aktualizace proběhla úspěšně! Zařízení znovu zapojte. Tentokrát se tlačítka nedotýkejte."
}, button$l = {
  abort: "Zrušit",
  back: "Zpět",
  buy: "Koupit",
  changepin: "Změňit heslo zařízení",
  check: "Zkontrolovat zálohu",
  continue: "Pokračovat",
  copy: "Kopírovat",
  create: "Vytvořit",
  dismiss: "Odmítnout",
  done: "Hotovo",
  download: "Stáhnout",
  hiddenwallet: "Vytvořit skrytou peněženku",
  next: "Další",
  ok: "OK",
  previous: "Předchozí",
  receive: "Přijmout",
  restore: "Obnovit",
  select: "Vybrat",
  send: "Poslat",
  unlock: "Odemknout",
  update: "Aktualizovat",
  upgrade: "Aktualizovat"
}, buy$d = {
  exchange: {
    bankTransfer: "Bankovní převod",
    bestDeal: "Nejvýhodnější nabídka",
    creditCard: "Kreditní karta",
    fast: "Rychle",
    fee: "poplatek",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankovní převod: {{fee}}%",
          creditDebitCard: "Kreditní / Debetní karta: {{fee}}%",
          learnMore: "Zjistěte více o Moonpay",
          title: "Poplatky"
        },
        fullCurrenciesList: "Kompletní seznam měn naleznete zde",
        payment: {
          asteriskText: "* Není k dispozici pro rezidenty USA",
          bankTransfer: "Bankovní převod*",
          bankTransferDetails: {
            pix: "PIX (transakce BR pouze v Brazílii)",
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemích SEPA)",
            uk: "Faster Payments - Spojené království (transakce v GBP pouze ve Spojeném království)"
          },
          creditDebitCard: "Kreditní / Debetní karta",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa a Maestro"
          },
          learnMore: "Další podrobnosti o způsobech platby",
          title: "Platební metody"
        },
        supportedCurrencies: "Podpora všech hlavních fiat měn: USD, EUR, CHF a další."
      },
      pocket: {
        fees: {
          info: "Bankovní převod: {{fee}}%",
          title: "Poplatky"
        },
        learnMore: "Zjistěte více o službě Pocket",
        payment: {
          bankTransfer: "Bankovní převod",
          bankTransferDetails: {
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemích SEPA)",
            sic: "Swiss Interbank Clearing (transakce v CHF pouze v CH/LI)",
            uk: "Faster Payments - Spojené království (transakce v GBP pouze ve Spojeném království)"
          },
          bankTransferReccuring: "Jak nastavit opakované nákupy pomocí trvalého příkazu?",
          title: "Platební metody"
        },
        supportedCurrencies: "Podpora evropských měn: EUR, GBP a CHF.",
        verification: {
          info: "Vyžaduje ověření identity pouze pokud jsou překročeny denní a roční limity.",
          link: "Aktuální limity zde",
          title: "Ověření identity"
        }
      },
      region: {
        title: "Vyberte oblast, ve které je váš bankovní účet registrován, a zjistěte, které možnosti máte k dispozici."
      }
    },
    noExchanges: "Je nám líto, ale v této oblasti nejsou k dispozici žádné burzy.",
    region: "Oblast",
    selectRegion: "Není uvedeno",
    title: "Koupit {{name}}"
  },
  info: {
    continue: "Souhlasím, pokračovat",
    crypto: "krypto",
    disclaimer: {
      intro: [
        "Spolupracujeme s MoonPay, abychom vám nabídli bezproblémový způsob nákupu {{name}} přímo v BitBoxApp. Je to jen pár kliknutí.",
        "MoonPay je platforma, která usnadňuje a urychluje nákup {{name}} ve více než 160 zemích."
      ],
      payment: {
        details: "{{name}} si můžete okamžitě zakoupit přes MoonPay pomocí následujících platebních metod. Nákupy kreditní nebo debetní kartou jsou okamžité a pohodlné, ale dražší kvůli zvýšenému riziku chargebacku. Pro větší částky doporučujeme použít možnost bankovního převodu. Minimální poplatek je 4 USD/EUR nebo ekvivalentní částka.",
        footnote: "Vezměte prosím na vědomí, že směnné kurzy MoonPay se mohou lišit od kurzů používaných v BitBoxApp, což vede k mírně odlišným částkám.",
        table: {
          "1_description": "Nejnižší poplatky, může trvat až tři pracovní dny",
          "1_method": "Bankovní převody (SEPA)",
          "2_description": "Vyšší poplatky, ale rychlé a okamžité",
          "2_method": "Kreditní a debetní karty",
          description: "Popis",
          fee: "Poplatek",
          method: "Metoda"
        },
        title: "Platební metody a poplatky"
      },
      privacyPolicy: "Zásady ochrany osobních údajů MoonPay",
      protection: {
        description: "BitBoxApp při nákupu {{name}} neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. MoonPay potřebuje ke své činnosti shromažďovat některé osobní údaje. Jejich Zásady ochrany osobních údajů podrobně vysvětlují, jak je s těmito údaji nakládáno.",
        descriptionGeneric: "BitBoxApp při nákupu {{name}} neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. Partnerské burzy však ke svému fungování potřebují shromažďovat určité informace. Podrobnější informace o tom, jak je s daty nakládáno, naleznete v jejich zásadách ochrany osobních údajů.",
        title: "Ochrana dat"
      },
      security: {
        description: "Při nákupu {{name}} přes MoonPay využíváte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštena BitBoxApp.",
        descriptionGeneric: "Při nákupu {{name}} prostřednictvím partnerské burzy využíváte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštena BitBoxApp.",
        link: "Model bezpečnostních hrozeb",
        title: "Bezpečnostní model"
      },
      title: "Vítejte ve vašem obchodě pro nákup {{name}}"
    },
    next: "Další",
    selectLabel: "Vyberte svůj účet",
    selectPlaceholder: "Vyberte měnu",
    skip: "Znovu nezobrazovat",
    title: "Koupit {{name}}"
  },
  pocket: {
    data: {
      link: "Zásady ochrany osobních údajů Pocket",
      p1: "BitBoxApp při nákupu bitcoinů neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. Pocket potřebuje ke svému fungování shromažďovat některé osobní údaje. Jejich zásady ochrany osobních údajů podrobně vysvětlují, jak se s těmito údaji nakládá.",
      title: "Ochrana dat"
    },
    kyc: {
      link: "Přečtěte si Pocket FAQ",
      p1: "Pocket se snaží omezit KYC na minimum. U nákupů do 950 EUR (1000 CHF) denně nejsou vyžadovány žádné další dokumenty. Při nákupech nad tuto částku si budete muset s Pocket domluvit hovor, abyste mohli dokončit potřebný proces KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin si můžete koupit okamžitě pomocí služby Pocket bankovním převodem SEPA. Poplatek činí 1,5 % a bitcoiny jsou poslány do vašeho BitBoxu ihned poté, co Pocket obdrží bankovní převod (obvykle během téhož dne).",
      p2: "Upozorňujeme, že směnné kurzy v aplikaci Pocket se mohou lišit od kurzů používaných v aplikaci BitBoxApp, což vede k mírně odlišným částkám.",
      title: "Platební metody a poplatky"
    },
    previousTransactions: "Historie transakcí tohoto účtu není prázdná. Sdílením tohoto účtu se všechny jeho minulé a budoucí transakce stanou viditelnými pro Pocket. Pokračovat?",
    security: {
      link: "Model bezpečnostních hrozeb BitBox02",
      p1: "Při nákupu bitcoinů přes Pocket používáte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštěn BitBoxApp. Společně pracujeme na zvýšení bezpečnosti pomocí dvoufaktorového ověřovacího mechanismu, který ověřuje adresu, na kterou přijímáte.",
      title: "Bezpečnostní model"
    },
    usedAddress: "Adresa {{address}} již byla použita, začněte prosím znovu s novou adresou.",
    verifyBitBox02: "Zkontrolujte, zda adresa, kterou jste obdrželi e-mailem, odpovídá adrese zobrazené na vašem Bitboxu. Pokud je to možné, měli byste e-mail otevřít na druhém zařízení kvůli lepšímu zabezpečení.",
    welcome: {
      p1: "Spolupracujeme se společností Pocket, abychom vám nabídli bezproblémový způsob nákupu bitcoinů přímo v BitBoxApp. Je to jen pár kliknutí.",
      p2: "Pocket je švýcarská platforma, která umožňuje rychlý a snadný nákup bitcoinů ve většině Evropy (kdekoli, kde jsou podporovány bankovní převody SEPA).",
      p3: "S Pocket můžete také provádět pravidelné nákupy prostřednictvím trvalých bankovních příkazů, takže můžete snadno zprůměrovat své náklady (DCA - dollar-cost averaging).",
      title: "Vítejte ve svém obchodě pro nákup bitcoinů"
    }
  },
  title: "Koupit {{name}}"
}, changePin$h = {
  newTitle: "Nové heslo zařízení",
  oldLabel: "Aktuální heslo zařízení"
}, chart$d = {
  dataMissing: "Sbíráme historická data... zůstaňte s námi.",
  dataOldTimestamp: "Aktualizace historických směnných kurzů. V grafu se nezobrazují data po {{time}}.",
  dataUpdating: "aktualizace dat...",
  filter: {
    all: "Všechny",
    month: "Měsíc",
    week: "Týden",
    year: "Rok"
  }
}, checkSDcard$h = "kontrola microSD karty", clickHere$h = "Klikněte zde.", confirm$j = {
  abortInfo: "Klepněte na ",
  abortInfoRedText: "zrušit",
  approveInfo: "Podržte 4 a více sekund ",
  approveInfoGreenText: "potvrdit",
  info: "Pokračujte na svém BitBoxu. ",
  infoWhenPaired: "Nejprve na spárovaném mobilu a poté na vašem BitBoxu"
}, confirmOnDevice$h = "Potvrďte na svém zařízení.", connectKeystore$a = {
  promptNoName: "Chcete-li pokračovat, připojte svůj BitBox02",
  promptWithName: 'Chcete-li pokračovat, připojte prosím svůj BitBox02 s názvem "{{name}}" '
}, darkmode$b = {
  toggle: "Tmavý režim"
}, device$h = {
  appUpradeRequired: "Váš BitBox není kompatibilní s touto aplikací. Stáhněte si a nainstalujte nejnovější verzi."
}, deviceLock$h = {
  button: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  condition1: "Máte zálohu?",
  condition2: "Funguje ověření mobilní aplikace?",
  condition3: "2FA ZABRÁNÍ zálohování a párování s mobilní aplikaci. Pro ukončení 2FA je nutné zařízení RESETOVAT!",
  confirm: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  title: "Aktivovat dvoufaktorovou autorizaci (2FA)"
}, deviceSettings$h = {
  backups: {
    manageBackups: {
      description: "Vytvořte nebo ověřte zálohu na microSD kartě."
    },
    showRecoveryWords: {
      description: "Zobrazit a ověřit slova pro obnovení."
    },
    title: "Zálohy"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp kontroluje, zda je vaše zařízení pravé."
    },
    deviceName: {
      description: "Změňte název zařízení."
    },
    rootFingerprint: {
      description: "Otisk je jedinečný identifikátor právě používané peněženky. Může vám pomoci rozlišit různé peněženky, pokud používáte přístupové fráze."
    },
    securechip: {
      description: "Model bezpečného čipu."
    },
    title: "Informace o zařízení"
  },
  expert: {
    factoryReset: {
      description: "Obnovte zařízení do továrního nastavení. Tím se smaže peněženka z vašeho BitBox02!",
      title: "Obnovit do továrního nastavení"
    },
    goToStartupSettings: {
      description: "Vstoupit do bootloaderu BitBox02. Zde můžete povolit hash firmwaru."
    },
    passphrase: {
      description: "Aktivovat nebo deaktivovat funkci přístupové fráze.",
      title: "Přístupová fráze"
    }
  },
  firmware: {
    firmwareVersion: "Verze firmwaru",
    newVersion: {
      label: "Dostupná verze"
    },
    title: "Firmware",
    upToDate: "Vaše zařízení je aktuální",
    upgradeAvailable: "K dispozici je nová aktualizace",
    version: {
      label: "Verze"
    }
  },
  hardware: {
    attestation: {
      false: "Kontrola pravosti se nezdařila",
      label: "Kontrola pravosti",
      true: "Váš BitBox02 je autentický"
    },
    sdcard: {
      false: "Není vložena",
      label: "microSD karta",
      true: "Vložena"
    },
    securechip: "Bezpečný čip",
    title: "Hardware"
  },
  loading: "Načítání informací o zařízení…",
  pairing: {
    lock: {
      false: "Vypnuto",
      label: "Dvoufaktorová autorizace (2FA)",
      true: "Zapnuto"
    },
    mobile: {
      false: "Zavřeno",
      label: "Mobilní aplikace",
      true: "Otevřeno"
    },
    status: {
      false: "Nespárováno",
      label: "Stav",
      true: "Spárováno"
    },
    title: "Párování"
  },
  secrets: {
    manageBackups: "Spravovat zálohy",
    title: "Secrets"
  }
}, deviceTampered$h = "Bylo k vašemu BitBoxu dodáno heslo pro obnovení? Pokud ano, zastavte proces nastavení a okamžitě kontaktujte podporu. Společnost Shift vám nikdy neposkytne hotovou peněženku ani vám nedá doporučení ohledně hesla.", dialog$i = {
  cancel: "Zrušit",
  confirm: "Potvrdit",
  confirmTitle: "Potvrzení"
}, error$d = {
  accountAlreadyExists: "Účet již existuje.",
  accountLimitReached: "Nelze přidat účet. Maximální počet účtů pro tuto měnu byl dosažen.",
  aoppCallback: "Při doručování adresy na {{host}} došlo k chybě.",
  aoppInvalidRequest: "Neplatný požadavek.",
  aoppNoAccounts: "Nejsou k dispozici žádné účty.",
  aoppSigningAborted: "Žádost o potvrzení vlastnictví adresy zrušena.",
  aoppUnknown: "Nastala neznámá chyba.",
  aoppUnsupportedAsset: "Toto aktivum není podporováno.",
  aoppUnsupportedFormat: "Nejsou k dispozici žádné účty, které by podporovaly požadovaný formát adresy.",
  aoppUnsupportedKeystore: "Připojené zařízení nemůže podepisovat zprávy pro toto aktivum.",
  aoppVersion: "Neznámá verze.",
  wrongKeystore: "Byla připojena špatná peněženka. Ujistěte se, že jste vložili správné zařízení odpovídající tomuto účtu.",
  wrongKeystore2: " Pokud používáte přístupovou frázi, zkontrolujte, zda jste zadali správnou přístupovou frázi pro tento účet."
}, fiat$j = {
  default: "výchozí",
  setDefault: "Nastavit {{code}} jako výchozí",
  title: "Měny"
}, footer$j = {
  appVersion: "Verze aplikace:"
}, generic$d = {
  enabled_false: "Vypnuto",
  enabled_true: "Zapnuto"
}, genericError$h = "Došlo k chybě. Pokud zaznamenáte nějaké problémy, restartujte prosím aplikaci.", goal$h = {
  buttons: {
    create: "Vytvořit novou peněženku",
    restore: "Obnovte peněženku ze zálohy"
  },
  paragraph: "Vyberte prosím jednu z následujících možností:",
  step: {
    1: {
      title: "Informace o zabezpečení"
    },
    2: {
      description: "Nastavit heslo zařízení",
      title: "Zařízení"
    },
    "3-create": {
      description: "Vytvořit novou peněženku",
      title: "Peněženka"
    },
    "3-restore": {
      description: "ze zálohy",
      title: "Obnovit"
    },
    "4-create": {
      title: "Přehled"
    },
    "4-restore": {
      title: "Přehled"
    }
  }
}, guide$i = {
  accountDescription: {
    text: 'V přehledu účtu se zobrazuje disponibilní zůstatek a příchozí a odchozí transakce. Více informací o jednotlivých typech účtů najdete v našem průvodci v části "Nastavení". ',
    title: "Co se mi na této stránce zobrazuje?"
  },
  accountFiat: {
    text: "Ano. Kliknutím na libovolný ticker můžete volit mezi fiat měnami. Seznam měn můžete změnit v nastavení.",
    title: "Mohu zobrazit jiné směnné kurzy?"
  },
  accountIncomingBalance: {
    text: "Přicházející transakce zahrnují částky, které vám byly převedeny, ale ještě nebyly potvrzeny sítí.",
    title: "Co znamená přicházející transakce?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Každý xpub je svázán se zobrazeným typem: buď "Native Segwit (bech32)", "Wrapped Segwit" nebo "Taproot" (pouze u Bitcoinu). Jedná se o typy skriptů, které používá {{coinName}}. BitBoxApp je kombinuje a podporuje více typů skriptů v rámci jednoho účtu. Protože každý typ skriptu dává jiný xpub, existuje více xpubů pro jeden účet.

Pokud soustavně přijímáte na výchozí adrese (Native Segwit), potřebujete pouze "bech32" xpub. Pokud však přijímáte prostředky také na "Wrapped Segwit" nebo "Taproot", musíte používat také další veřejné klíče "Wrapped Segwit", xpub respektive "Taproot" xpub.`,
      title: "Proč existuje více xpubů?"
    },
    privacy: {
      text: `U tohoto konkrétního účtu odhaluje xpub veřejný klíč celou finanční historii, zůstatek na účtu a všechny budoucí transakce. Xpub však nikomu neumožňuje utrácet vaše prostředky.

Pokud xpub někomu předáte, měli byste si být vědomi toho, že tato osoba nebo společnost může vidět všechny ostatní transakce tohoto účtu. Proto je dobré používat tento účet pouze k tomuto účelu a ostatní prostředky držet na jiných účtech.`,
      title: "Musím svůj xpub držet v tajnosti?"
    },
    verify: {
      text: "Ano, vždy je dobré si xpub překontrolovat. Pokud z tohoto xpubu bude někdo jiný generovat adresy a posílat vám peníze, je to obzvlášť důležité. Musíte ho ověřit na zařízení, abyste se ujistili, že tento xpub patří vám; jinak by všechny prostředky mohly jít na nesprávné adresy.",
      title: "Musím ověřit xpub na zařízení?"
    },
    xpub: {
      text: `Veřejný klíč (xpub) je základní klíč, z něhož jsou odvozeny všechny adresy účtu.

Je zde uveden pro pokročilé používání a interoperabilitu s peněženkami určenými pouze pro sledování (watch-only wallets), jako je Electrum nebo Sentinel. Pokud jste přijímali na různé typy adres, importujte prosím všechny různé formáty xpubů do watch-only peněženky, abyste viděli všechny své prostředky.

Upozorňujeme, že peněženky třetích stran nemusí zatím podporovat Taproot xpub.`,
      title: "Co je veřejný klíč (xpub)?"
    }
  },
  accountRates: {
    text: "Směnné kurzy aktualizujeme každou minutu z CoinGecko.",
    title: "Jaké směnné kurzy platí?"
  },
  accountReload: {
    text: "To není potřeba. Informace o transakci se aktualizují automaticky.",
    title: "Mohu znovu načíst historii transakcí?"
  },
  accountSendDisabled: {
    text: "Tlačítko „Odeslat“ se aktivuje, když je váš zůstatek vyšší než nula.",
    title: "Proč nemůžu poslat žádný {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Celková částka je součtem všech vašich účtů. Směnné kurzy jsou získávány z coingecko.com.

Poznámka: Pokud používáte MyEtherWallet pro tokeny, které nejsou podporovány v aplikaci BitBoxApp, nebudou do zobrazené částky zahrnuty.`,
    title: "Jak se vypočítá celková částka?"
  },
  accountSummaryDescription: {
    text: "Zde můžete sledovat výkonnost svého portfolia v průběhu času. Pod grafem se zobrazuje přehled vašich jednotlivých účtů.",
    title: "Co se mi na této stránce zobrazuje?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtuální velikost: Určuje síťový poplatek. Úspěšně jste ušetřili na poplatcích, pokud je menší než velikost transakce.
Velikost: Skutečná velikost transakce v bajtech při serializaci podle příslušného blockchainu.
Váha: Nová metrika zavedená se Segwitem pro vyhodnocování velikosti transakcí a bloků. Každý byte segregovaného svědka {segregated witness) se počítá jako jedna, vše ostatní jako čtyři jednotky váhy. Místo jednoho megabajtu ve skutečné velikosti je nyní limit velikosti bloku čtyři miliony váhových jednotek.`,
    title: "A co podrobnosti transakce specifické pro bitcoiny?"
  },
  accountTransactionAttributesGeneric: {
    text: `Potvrzení: Vaše první transakce je nepotvrzená, dokud ji těžař nezařadí do bloku, poté má jedno potvrzení. Každý další blok v síti přidává k vaší transakci další potvrzení. Obecně platí, že obchodníci a další účastníci sítě akceptují transakce jako vypořádané s minimem tří až šesti potvrzení.
ID transakce: Jedinečné identifikační číslo, které umožňuje vyhledat transakci v blok exploreru.
Poplatek: Těžařům se platí transakční poplatek jako pobídka k zahrnutí transakcí do bloků, které vytěží. Chcete-li se dozvědět více, klikněte na tlačítko odeslat.`,
    title: "Jaké jsou informace v detailech transakce?"
  },
  accountTransactionConfirmation: {
    text: "Transakce odeslaná do sítě, ale dosud nepotvrzená.",
    title: "Co je to čekající transakce?"
  },
  accountTransactionLabel: {
    text: "Je to adresa, ze které jste obdrželi prostředky nebo na kterou jste je odeslali.",
    title: "Jaká adresa se zobrazuje u každé transakce?"
  },
  accountTransactionTime: {
    text: "Doba potvrzení transakce v blockchainu.",
    title: "Jaký čas se zobrazuje?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin a Litecoin mohou mít libovolné množství účtů. Po pěti účtech můžete přidat další účet pouze v případě, že předchozí účet byl použit. 
Ostatní měny mohou mít maximálně pět účtů.`,
      title: "Kolik účtů mohu vytvořit?"
    },
    howtoAddTokens: {
      text: 'Tokeny využívající standard ERC20 jsou vázány na konkrétní účet Etherea. Chcete-li aktivovat nebo deaktivovat konkrétní token, otevřete obrazovku "Správa účtů", rozbalte svůj účet Ethereum a zapněte nebo vypněte požadovaný token.',
      title: "Jak mohu přidat další tokeny?"
    },
    moveFunds: {
      text: "Ano, ale protože jsou účty nezávislé, musíte své prostředky poslat pomocí běžné transakce.",
      title: "Mohu přesouvat prostředky mezi účty?"
    },
    recoverAccounts: {
      text: "Ano, BitBoxApp vytváří účty pomocí zavedených standardů kompatibilních s většinou ostatních kryptopeněženek.",
      title: "Mohu obnovit své účty v jiných peněženkách?"
    },
    whatAreAccounts: {
      text: "Vaše peněženka umí spravovat více účtů jedné měny. Účty jsou užitečné, když chcete mít prostředky oddělené.",
      title: "Co jsou účty?"
    },
    whyIsThisUseful: {
      text: "Účty jsou skvělé pro správu prostředků pro různé osoby nebo účely, protože jsou oddělené. Můžete také sdílet veřejný klíč (xpub) účtu, aniž byste prozradili cokoli o svých ostatních účtech. To vám umožňuje opakovaně přijímat finanční prostředky bez opakovaného používání adres, například při pobírání mzdy nebo pravidelném nákupu kryptoměn.",
      title: "Proč je to užitečné?"
    }
  },
  appendix: {
    link: "Kontaktujte nás!",
    text: "Další otázka?"
  },
  backups: {
    check: {
      text: '"Zkontrolovat zálohu" umožňuje ověřit, zda máte funkční zálohu odpovídající vaší aktuální peněžence. Lze ji také použít k ověření, zda máte stále správné heslo pro obnovení. Můžete zkontrolovat hlavní heslo pro obnovení nebo skryté heslo pro obnovení.',
      title: "Co je to „Zkontrolovat zálohu“?"
    },
    encrypt: {
      text: "Ne, ale k získání peněženky z uloženého seedu {slov pro obnovení) je nutné vaše heslo pro obnovení.",
      title: "Mohu zálohu zaheslovat?"
    },
    howOften: {
      text: `Záloha se generuje automaticky při vytvoření nové peněženky. Novou zálohu musíte vytvořit pouze v případě, že microSD kartu ztratíte nebo poškodíte, nebo pokud chcete jako zálohu použít více microSD karet.
Po uskutečnění transakcí nemusíte vytvářet nové zálohy. Všechna data transakcí lze znovu vytvořit pomocí jediné zálohy, která byla pro vás automaticky vytvořena.`,
      title: "Jak často musím vytvářet zálohu?"
    },
    whatIsABackup: {
      text: "Jedná se o kopii obnovovacího seedu na microSD kartě. Seed {slova pro obnovení) spolu s heslem pro obnovení vytváří vaši peněženku.",
      title: "Co je záloha?"
    }
  },
  backupsBB02: {
    check: {
      text: "„Zkontrolovat zálohu“ vám umožňuje ověřit, že máte funkční zálohu odpovídající vaší aktuální peněžence.",
      title: "Co je to „Zkontrolovat zálohu“?"
    },
    encrypt: {
      text: 'Ne. microSD kartu uchovávejte v bezpečí, protože obsahuje nezašifrovaný obnovovací seed k obnovení peněženky. Pokud si přejete chránit seed heslem, můžete aktivovat volitelnou přístupovou frázi v expertním nastavení v části "Správa zařízení".',
      title: "Mohu zálohu zašifrovat?"
    },
    whatIsABackup: {
      text: "Jedná se o kopii obnovovacího seedu na microSD kartě.",
      title: "Co je záloha?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Když je aktivní funkce 2FA, musí být všechny transakce schváleny na spárovaném mobilním telefonu, aby bylo možné utrácet prostředky. Do mobilní aplikace je odesláno zašifrované jednorázové číslo, které je tam dešifrováno a po stisknutí tlačítka Přijmout je odesláno zpět do BitBoxu. Tato komunikace se zařízením probíhá prostřednictvím kanálu mezi mobilním telefonem a touto desktopovou aplikací vytvořeného během párování.

Před zapnutím funkce 2FA nezapomeňte zálohovat peněženku a spárovat mobilní aplikaci. Po aktivování jsou microSD slot a párování s mobilní aplikací vypnuty. Lze je znovu aktivovat resetováním BitBoxu, čímž se zařízení vymaže.`,
      title: "Jak funguje dvoufaktorová autorizace (2FA)?"
    },
    disable2FA: {
      text: `Chcete-li 2FA deaktivovat, musíte resetovat BitBox a poté obnovit peněženku ze zálohy. Ujistěte se, že stále máte microSD kartu se zálohou a že si stále pamatujete heslo pro obnovení. Poté stiskněte tlačítko "Resetovat zařízení". Nastavte nové heslo zařízení a zvolte 'Nebo obnovit ze zálohy'. Vyberte zálohu peněženky, klikněte na 'Obnovit' a zadejte heslo pro obnovení, které jste použili při vytváření peněženky.`,
      title: "Jak mohu deaktivovat dvoufaktorovou autorizaci (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox můžete kdykoli odpojit, aniž byste jej museli nejprve vysunout.",
      title: "Jak mohu vysunout BitBox?"
    },
    ejectSD: {
      text: "MicroSD kartu můžete z BitBoxu kdykoli vyjmout, pokud právě nevytváříte nebo neobnovujete zálohu.",
      title: "Jak mohu microSD kartu vysunout?"
    },
    hiddenWallet: {
      text: "Jedná se o druhou peněženku na stejném zařízení chráněnou jiným heslem zařízení a heslem pro obnovení, které můžete použít pro hodnověrné popření (plausible deniability). Pro normální i skrytou peněženku se používá stejný seed, takže není třeba žádné další zálohování.",
      title: "Co je to skrytá peněženka?"
    },
    legacyHiddenWallet: {
      text: "Nejprve klikněte na níže uvedené tlačítko (je k dispozici, pokud je BitBox odemčen hlavním heslem zařízení a funkce 2FA je vypnutá), poté Bitbox znovu připojte a odemkněte jej skrytým heslem.",
      title: "Jak se dostanu k legacy skryté peněžence?"
    },
    pairing: {
      text: "Po stažení naší mobilní aplikace pro iOS nebo Android naskenujete zobrazený QR kód, čímž se vytvoří zabezpečený kanál mezi mobilní aplikací a touto aplikací. Po naskenování postupujte podle pokynů v mobilní aplikaci.",
      title: "Jak bezpečně spárovat s telefonem"
    }
  },
  cointracking: {
    text: 'Klikněte na tlačítko "Export" a otevřete složku se staženými soubory, kde najdete export CSV. Poté klikněte na níže uvedený odkaz, nahrajte svůj BitBox CSV soubor a importujte data, abyste je mohli použít pro správce portfolia CoinTracking a pro vytváření daňových výkazů.',
    title: "Jak importovat mé transakce do služby CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Přečtěte si více o kontrole pravosti"
      },
      text: "BitBoxApp provede atestační kontrolu BitBox02, aby ověřila, zda je zařízení pravé. Kontrola se provádí lokálně a nepřipojuje se k žádným serverům.",
      title: "Jak probíhá kontrola pravosti?"
    },
    name: {
      text: "Jedná se o název vaší peněženky a zálohy. Název se používá pro budoucí zálohy a může sloužit k rozlišení různých peněženek. Lze jej kdykoli změnit, ale mějte na paměti, že zálohy vytvořené před změnou budou stále používat předchozí název.",
      title: "K čemu slouží název BitBoxu?"
    },
    "secure-chip": {
      link: {
        text: "Další informace o bezpečném čipu"
      },
      text: "Tato informace zobrazuje číslo modelu zabezpečeného čipu, nejnovější čip je ATECC608B s vylepšenými bezpečnostními funkcemi ve srovnání se staršími modely.",
      title: "Proč zobrazovat model bezpečného čipu?"
    }
  },
  receive: {
    address: {
      text: "Adresu můžete dát ostatním, aby vám poslali nějaké prostředky. Jen se ujistěte, že je posílají na správnou adresu.",
      title: "Co mohu dělat s adresou?"
    },
    addressChange: {
      text: "Jakmile provedete transakci, do seznamu se automaticky přidá nová adresa, takže je vždy k dispozici 20 adres, které nikdy neobdržely žádné prostředky.",
      title: "Kdy se adresy mění?"
    },
    addressFormats: {
      text: "Ve výchozím nastavení je typ adresy Native Segwit. Tento typ adresy je široce rozšířený mezi ostatními peněženkami/burzami poskytuje nejlepší sazby poplatků za každodenní transakce. Můžete si však také zvolit odesílání na Taproot (jen pro Bitcoin), což je nejnovější typ adresy, který však ještě nemusí být všude podporován. Případně, pokud máte problémy s odesíláním na Native Segwit (výchozí typ), můžete zkusit přejít na starší typ adresy Wrapped Segwit, který může být kompatibilní s více peněženkami/burzami.",
      title: 'Kdy mám použít "Změnit typ adresy"?'
    },
    howVerify: {
      text: `V případě BitBox01 klikněte na ikonu BitBox v postranním panelu vlevo a podívejte se do části Párování. Průvodce se aktualizuje a vy můžete pokračovat podle pokynů odtud.
U BitBox02 můžete adresy ověřit přímo v zařízení během procesu odesílání/přijímání.`,
      title: "Jak mohu bezpečně ověřit adresu?"
    },
    plugout: {
      text: "Ne, po odeslání prostředků na adresu BitBoxu nemusíte nechávat BitBox připojený. Svůj BitBox můžete kdykoli odpojit.",
      title: "Musím nechat svůj BitBox během přijímání zapojený?"
    },
    why20: {
      text: 'Během spuštění aplikace generuje adresy odvozené z vašeho seedu a zjišťuje, zda obdržely prostředky. Protože aplikace může generovat téměř nekonečné množství adres, mohla by zjišťováním zůstatku strávit roky. Aby se toto hledání omezilo, zastaví se, jakmile uvidí 20 adres, které nikdy neobdržely žádné prostředky. To je "gap limit" a 20 je de facto standard, i když toto číslo je libovolné. Z těchto 20 adres si můžete vybrat.',
      title: "Proč jenom 20 adres?"
    },
    whyMany: {
      text: "V zájmu zachování soukromí a bezpečnosti nikdy pro přijímaní nepoužívejte stejnou adresu dvakrát. Pokud jste adresu použili, klikněte na šipku vpravo pro novou adresu. Najednou můžete vygenerovat až 20 adres. Představte si adresy jako čísla faktur. Všechny adresy jsou odvozeny z vašeho jediného obnovovacího seedu.",
      title: "Proč tolik adres?"
    },
    whyVerify: {
      text: "Neměli byste věřit, že váš počítač generuje a zobrazuje autentické adresy. Jeho útočná plocha (attack surface) jej činí podstatně zranitelnějším než hardwarovou peněženku. U BitBox01 Tlačítko pro ověření adresy bezpečně odešle adresu do spárovaného mobilního telefonu, ze kterého můžete také naskenovat a ověřit kód QR. U BitBox02 lze adresu ověřit přímo na displeji BitBoxu.",
      title: "Proč bych měl adresu bezpečně ověřit?"
    }
  },
  send: {
    change: {
      text: "Zůstatek bude vrácen na adresu Taproot, pokud máte alespoň jedno  Taproot UTXO. Pokud použijete coin control, bude zůstatek vrácen na adresu Taproot, pokud je mezi vybranými UTXO alespoň jedno Taproot UTXO. Ve všech ostatních případech se změna vrátí na nativní adresu Segwit.",
      title: "Jak se určuje change output (hodnota zůstatku)?"
    },
    fee: {
      text: `Poplatek se odvíjí od velikosti dat transakce, nikoli od její výše. Cílové hodnoty poplatků jsou vypočítávány algoritmem pro odhad poplatků v Bitcoin Core pro každou vámi zvolenou prioritu sítě. Jsou zobrazeny, pokud mají jinou hodnotu než cíl uvedený níže.
Úsporné: 24 bloků (přibližně 4 hodiny u Bitcoinu, 1 hodina u Litecoinu).
Nízké: 12 bloků (přibližně 2 hodiny pro Bitcoin, 30 minut pro Litecoin).
Normální: 6 bloků (přibližně 1 hodina pro Bitcoin, 15 minut pro Litecoin).
Vysoké: 2 bloky (přibližně 20 minut pro Bitcoin, 5 minut pro Litecoin)
(Vytěžení jednoho bloku trvá u Bitcoinu v průměru deset minut (u Litecoinu 2,5 minuty) a zatížení sítě se může ve výše uvedených obdobích značně lišit).`,
      title: "Jak se určuje poplatek?"
    },
    plugout: {
      text: "Ne, jakmile provedete transakci, nemusíte nechávat svůj BitBox připojený. Můžete svůj BitBox kdykoli odpojit.",
      title: "Musím nechat svůj BitBox během odesílání připojený?"
    },
    priority: {
      text: "Čím vyšší poplatek jste ochotni zaplatit, tím rychleji je obvykle vaše transakce potvrzena sítí.",
      title: "Co je to priorita sítě (network priority)?"
    },
    revert: {
      text: `Jakmile je transakce podepsána a odeslána (tj. vyslána do sítě), nelze ji již vrátit zpět. Před podpisem transakce (včetně poplatku) ji pořádně ověřte!
Pokud příjemce znáte a je ochoten vám poslat stejnou částku (po odečtení transakčních poplatků) zpět, můžete mu poslat novou přijímací adresu.`,
      title: "Mohu transakci vrátit zpět?"
    },
    whyFee: {
      text: `Transakce soutěží o jejich potvrzení těžařem. Těžaři vybírají transakce, které mají být zařazeny do blockchainu, na základě jejich poplatků.
Těžaři hlasují o historii transakcí. Protože neexistuje důvěryhodná třetí strana, která by vynucovala jeden hlas na osobu (což je celý smysl blockchainů), hlasují těžaři o transakcích tak, že obětují nákladný zdroj, jako je výpočetní výkon. Jako odměnu za svou práci si mohou nárokovat nově vytvořené mince a poplatek za všechny zahrnuté transakce.`,
      title: "Proč se platí síťový poplatek?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Pokud se k uzlu hodláte připojit pouze tehdy, když jste ve stejné síti (např. domácí wifi), pak vám postačí běžná síťová komunikace.
V takovém případě je vhodné, aby váš Electrum server poskytoval certifikát TLS pro šifrování komunikace.
Pokud se hodláte k uzlu připojit odkudkoli, je lepší volbou použití sítě Tor. V takovém případě není certifikát TLS nutný.`,
      title: "Mám použít clearnet TCP, TLS nebo Tor?"
    },
    instructions: {
      link: {
        text: "Průvodce pro připojení uzlu"
      },
      text: "Úplný návod naleznete v našem průvodci:",
      title: "Jak připojím BitBoxApp k vlastnímu uzlu?"
    },
    options: {
      text: `Existuje více možností, jak provozovat vlastní uzel, například zakoupit hotové zařízení, postavit si vlastní nebo používat Bitcoin Core.
Pokud chcete k uzlu připojit BitBoxApp, ujistěte se, že na něm běží server Electrum. Jedná se o specializovaný program, který umožňuje  peněžence komunikovat s vaším uzlem.
Mezi podporované možnosti patří Electrs, Electrum Personal Server (EPS) nebo Bitcoin Wallet Tracker (BTW).`,
      title: "Jaké jsou možnosti provozování uzlu?"
    },
    tor: {
      text: `Tor je zkratka pro "The Onion Router", což je bezplatný software s open source kódem, který nabízí mnoho výhod v oblasti ochrany soukromí a je užitečný zejména při používání Bitcoinu.
Pokud se hodláte připojit k uzlu prostřednictvím Toru, ujistěte se, že je Tor na vašem počítači nainstalován, a poté aktivujte Tor Proxy v nastavení BitBoxApp.
U většiny operačních systémů existují dva způsoby, jak Tor spustit:
1. Prohlížeč Tor: Stáhněte si a otevřete prohlížeč Tor Browser. To umožní aplikaci BitBoxApp připojit se k síti Tor nastavením portu 9150 v nastavení proxy serveru Tor.
2. Služba Tor na pozadí: nainstalujte Tor daemon, který vždy běží na pozadí. BitBoxApp se pak může připojit nastavením portu 9050 v nastavení proxy serveru Tor.`,
      title: "Co je Tor, Tor proxy a jaký port mám použít?"
    },
    what: {
      text: "Peněženku je možné provozovat s vlastním uzlem namísto serverů Shift.",
      title: "Co to je?"
    },
    why: {
      text: `Provozování vlastního uzlu není nutné, ale zlepšuje soukromí a snižuje potřebu důvěřovat někomu jinému.
Zaprvé to znamená, že používáte Bitcoin soukroměji, protože BitBoxApp se nebude připojovat k našim serverům, aby získala historii vašich transakcí; místo toho bude tyto informace získávat z vašeho vlastního uzlu.
Za druhé, spuštění vlastního uzlu znamená, že váš uzel sám ověřuje všechny transakce a zajišťuje tak dodržování pravidel konsensu (consensus rules).`,
      title: "Proč bych měl provozovat vlastní uzel?"
    }
  },
  settings: {
    sats: {
      text: 'Satoshi (zkráceně "sat") je nejmenší jednotka bitcoinu. Jeden satoshi je jedna stamiliontina bitcoinu (0,00000001 BTC). Je pojmenována po tvůrci bitcoinu Satoshi Nakamotovi.',
      title: "Co je to Satoshi?"
    },
    servers: {
      text: `Tato aplikace komunikuje se servery Shift Crypto a kontroluje aktualizace, načítá transakce a odesílá informace spárovaným mobilním aplikacím.
Aplikace také načítá nejnovější směnné kurzy z CoinGecko. Všechny konverze se počítají lokálně, což znamená, že se nikdy neodesílají žádné údaje o výši vaší transakce.
Poznámka: Pro tokeny Ethereum a ERC20 používáme Etherscan.io API.`,
      title: "S kterými servery tato aplikace komunikuje?"
    }
  },
  title: "Průvodce",
  toggle: {
    close: "Zavřít průvodce",
    open: "Průvodce"
  },
  trackingModePortfolioChart: {
    text: "Na počítači najeďte kurzorem na graf. Na mobilním telefonu podržte prst na grafu a potáhněte vodorovně.",
    title: "Jak zobrazit historické hodnoty na grafu?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Musíte zařízení resetovat a obnovit peněženku ze zálohy pomocí hesla pro obnovení.",
      title: "Co mám dělat, když jsem zapomněl heslo k zařízení?"
    },
    reset: {
      text: "Zadejte 15krát špatné heslo zařízení. Několik posledních pokusů vyžaduje dlouhý dotyk na zařízení.",
      title: "Jak resetuji zařízení?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Zařízení by mělo po připojení jednou bliknout. Ujistěte se, že je zapojeno správnou stranou. Pokud máte potíže, kontaktujte nás prostřednictvím níže uvedeného odkazu.

Zařízení BitBox01 není podporováno v mobilních zařízeních. K připojení zařízení BitBox01 použijte aplikaci BitBoxApp na stolním počítači.`,
      title: "Můj BitBox01 nebyl rozpoznán"
    },
    getDevice: {
      link: {
        text: "Objednejte si BitBox"
      },
      text: "BitBox si můžete zakoupit v našem internetovém obchodě:",
      title: "Jak si mohu zařízení pořídit?"
    },
    internet: {
      text: "Ano, k synchronizaci peněženky, odesílání transakcí a načítání nejnovějších směnných kurzů je nutné připojení k internetu.",
      title: "Vyžaduje tato aplikace připojení k internetu?"
    },
    lostDevice: {
      link: {
        text: "Centrum zálohování"
      },
      text: "Své účty můžete obnovit na novém BitBoxu nebo v našem centru zálohování.",
      title: "Ztratil jsem zařízení. Co teď?"
    },
    useWithoutDevice: {
      text: "V současné době to bohužel není možné.",
      title: "Mohu aplikaci používat i bez zařízení?"
    },
    welcome: {
      text: "Děkujeme za používání této aplikace vytvořené společností Shift Crypto ve Švýcarsku. Jsme rádi za jakýkoli příspěvek, o který se s námi podělíte. Poskytněte prosím zpětnou vazbu pomocí odkazu v dolní části.",
      title: "Vítejte v BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Pokud používáte nový telefon/počítač s BitBoxApp, budete se muset k dapps připojit znovu. Poté opět uvidíte své prostředky v dapp jako obvykle.",
      title: "Nevidím svá předchozí spojení."
    },
    supportedNetworks: {
      text: "V současné době je pomocí WalletConnect v BitBoxApp podporován pouze Ethereum mainnet . Chcete-li používat jiné sítě kompatibilní s EVM, použijte prosím peněženku z rozšíření prohlížeče Rabby.",
      title: "Které sítě jsou podporovány?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikační protokol pro aplikace web3. Umožňuje pohodlné připojení k DApps a webovým peněženkám založeným na Ethereu bez použití aplikace třetí strany, což je užitečné zejména pro uživatele BitBoxApp pro Android.",
      title: "Co je WalletConnect?"
    }
  }
}, headerssync$h = {
  blocksSynced: "{{blocks}} bloků zesynchronizováno"
}, hiddenWallet$h = {
  info1HTML: "Pro účely hodnověrného popření (plausible deniability) lze skrytou peněženku vytvořit na základě kombinace <strong>odlišného</strong> hesla zařízení + hesla pro obnovení.",
  info2HTML: "Níže definujte heslo zařízení a heslo pro obnovení, které chcete přiřadit ke své skryté peněžence. Heslo zařízení a heslo pro obnovení musí být <strong>odlišné</strong> od těch, které jste definovali pro svou primární peněženku.",
  passwordLabel: "Skryté heslo pro obnovení",
  passwordPlaceholder: "Potvrďte prosím skryté heslo pro obnovení",
  pinLabel: "Heslo pro skryté zařízení",
  pinRepeatLabel: "Zopakujte heslo pro skryté zařízení",
  pinRepeatPlaceholder: "Potvrďte prosím heslo pro skryté zařízení",
  success: "Skrytá peněženka byla úspěšně vytvořena. Znovu připojte svůj BitBox, abyste jej odemkli."
}, initialize$h = {
  create: "Nastavit heslo zařízení",
  creating: "Nastavování hesla zařízení…",
  error: {
    e102: "Heslo zařízení musí obsahovat alespoň 4 znaky."
  },
  info: {
    description1: "Zvolte heslo zařízení. To bude použito k odemknutí vašeho BitBoxu.",
    description2: "Můžete používat čísla, písmena a symboly. Delší hesla poskytují vyšší bezpečnost.",
    description3: "Pokud heslo k zařízení ztratíte, budete muset zařízení resetovat a obnovit ze zálohy.",
    subtitle: "Nyní nastavíte heslo svého zařízení",
    title: "Inicializace zařízení"
  },
  input: {
    label: "Heslo zařízení",
    labelRepeat: "Opakujte heslo zařízení",
    placeholderRepeat: "Potvrďte heslo zařízení"
  }
}, invalidFormat$h = "Nesprávný formát", language$i = {
  title: "Zvolte jazyk"
}, legacyhiddenwallet$h = {
  disable: "Deaktivovat legacy skrytou peněženku",
  enable: "Aktivovat legacy skrytou peněženku",
  successDisable: "Úspěšně deaktivována legacy skrytá peněženka.",
  successEnable: "Starší legacy peněženka byla úspěšně aktivována. Znovu zapojte svůj BitBox a zadejte heslo skrytého zařízení pro přístup k legacy skryté peněžence."
}, loading$h = "načítání…", manageAccounts$b = {
  accountHidden: "Tento účet byl skryt z vašich watch-only účtů. Chcete-li jej znovu zobrazit, připojte prosím svůj BitBox02.",
  editAccount: "Upravit",
  editAccountNameTitle: "Upravit název účtu",
  noAccounts: "nebyly nalezeny žádné účty",
  settings: {
    hideTokens: "Skrýt tokeny",
    showTokens: "Zobrazit tokeny ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Přidat a zobrazit/skrýt účty",
  title: "Spravovat účty",
  watchAccount: "Sledovat účet",
  watchAccountDescription: "Tento účet je součástí watch-only účtů. Můžete jej skrýt ze svých watch-only účtů pomocí přepínače."
}, mobile$c = {
  usingMobileDataWarning: "Využití mobilních dat: tato aplikace může po odemčení účtu stáhnout až několik set megabajtů dat z blockchainu. Abyste se vyhnuli používání mobilních dat, připojte se k Wi-Fi. Po jejím zavření se tato zpráva již nebude zobrazovat."
}, newSettings$a = {
  about: {
    appVersion: {
      title: "Verze aplikace"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Uzamčení přístupu k aplikaci pomocí zámku obrazovky/otisku prstu.",
      title: "Uzamčení obrazovky"
    },
    coinControl: {
      description: "Vyberte, které UTXO jsou součástí transakce, abyste zlepšili soukromí."
    },
    customFees: {
      description: "Umožňuje zadat vlastní poplatek při odesílání."
    },
    torProxy: {
      description: "Připojte se přes Tor pro lepší soukromí."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Tyto další měny můžete přepínat na stránce svého účtu.",
      title: "Aktivní měny"
    },
    darkmode: {
      description: "Podívejte se na BitBoxApp v tmavém režimu."
    },
    defaultCurrency: {
      description: "Vyberte výchozí měnu",
      title: "Výchozí měna"
    },
    hideAmounts: {
      description: "Zobrazuje přepínač pro skrytí zůstatku a částek pro ochranu soukromí při používání aplikace na veřejnosti.",
      hideAmounts: "Skrýt částky",
      showAmounts: "Zobrazit částky",
      title: "Povolit skrytí částek"
    },
    language: {
      description: "Jaký jazyk chcete v BitBoxApp používat.",
      title: "Jazyk"
    },
    toggleSats: {
      description: "Aktivovat nebo deaktivovat Satoshi."
    }
  }
}, note$d = {
  input: {
    description: "(volitelný)",
    placeholder: "Přidat poznámku…"
  },
  title: "Poznámka"
}, notification$h = {
  newTxs_one: "Nová transakce v: {{accountName}}",
  newTxs_other: "{{count}} nové transakce v: {{accountName}}"
}, pairing$h = {
  aborted: {
    text: "Párování bylo z mobilní aplikace zrušeno.",
    title: "Zrušeno"
  },
  button: "Spárovat mobilní aplikaci",
  confirm: "Jste si jisti, že chcete spárovat svůj BitBox? Pamatujte, že poté je k provedení transakce vyžadován mobilní telefon.",
  connectOnly: {
    button: "Připojte mobilní aplikaci",
    title: 'Naskenujte pomocí naší mobilní aplikace výběrem položky "Připojit k nové aplikaci".'
  },
  error: {
    text: "Něco se pokazilo. Začněte prosím znovu.",
    title: "Chyba"
  },
  pullFailed: {
    text: "Nepodařilo se stáhnout zprávu z mobilního telefonu prostřednictvím serveru. Server může být offline, kontaktujte prosím podporu.",
    title: "Vytažení se nezdařilo"
  },
  reconnectOnly: {
    button: "Znovu připojte mobilní aplikaci"
  },
  scanningFailed: {
    text: "Mobilní telefon nebyl schopen zprávu úspěšně naskenovat. Zkuste to prosím znovu.",
    title: "Skenování se nezdařilo "
  },
  start: {
    hideAppQRCode: "Skrýt QR kód",
    revealAppQRCode: "Zobrazit QR kód",
    step1: "Pokud mobilní aplikaci nemáte, můžete naskenovat QR kód pro Apple App Store nebo Google Play Store podle toho, který telefon máte.",
    step2: 'Naskenujte pomocí naší mobilní aplikace, kterou najdete pod názvem "Digital Bitbox 2FA" v obchodech s aplikacemi pro iOS a Android:'
  },
  started: {
    text: "Nyní postupujte podle pokynů v mobilní aplikaci.",
    title: "Skvělý"
  },
  success: {
    text: "Gratulujeme, úspěšně jste spárovali svůj BitBox s mobilní aplikací!",
    title: "Hotovo"
  },
  timeout: {
    text: "Párování se po dvou minutách přerušilo. Pokud chcete ještě spárovat mobilní aplikaci, spusťte ji znovu.",
    title: "Timeout"
  },
  title: "Párování mobilního telefonu"
}, passphrase$b = {
  considerations: {
    button: "Úvahy ohledně zálohování",
    message: `Přístupová fráze přidává vrstvu ochrany k vaší záloze peněženky (záloha na microSD kartě nebo obnovovací slova). Pokud má někdo přístup k vaší záloze, bude k přístupu do peněženky potřebovat také přístupovou frázi.

To však znamená, že v případě ztráty nebo rozbití vašeho BitBoxu budete potřebovat <strong>i přístupovou frázi i zálohu peněženky</strong> pro obnovení vaší peněženky s přístupovou frází. Pokud zapomenete nebo ztratíte svou přístupovou frázi, ztratíte přístup ke všem prostředkům v této peněžence.

Při ukládání přístupové fráze zvažte její umístění na jiné místo než kde máte zálohu. Pokud někdo najde vaši zálohu, nenajde tak vaši přístupovou frázi.`,
    title: "Úvahy ohledně zálohování"
  },
  disable: "Deaktivovat přístupovou frázi",
  disableInfo: {
    button: "Deaktivovat",
    message: `Po vypnutí přístupové fráze již nebudete po odemknutí BitBoxu vyzváni k zadání přístupové fráze. Proto vstoupíte do své výchozí peněženky.

Veškeré prostředky ve vaší peněžence s přístupovou frází budou stále v této peněžence, avšak nebudete k nim mít přístup, protože po odemknutí vašeho BitBoxu otevřete svou výchozí peněženku.

Pro opětovný přístup k vašim peněženkám s přístupovou frází jednoduše znovu zapněte funkci přístupové fráze a po odemknutí BitBoxu zadejte příslušnou přístupovou frázi.

<strong>Tip:</strong> Do své výchozí peněženky můžete přistoupit i ponecháním prázdné přístupové fráze, když ji máte aktivovanou.`
  },
  enable: "Aktivovat přístupovou frázi",
  error: {
    e104: "Změna nastavení přístupové fráze byla zrušena."
  },
  how: {
    button: "Jak to vypadá",
    message: `A přístupová fráze nefunguje jako heslo, na které jste zvyklí. Pokud heslo zadáte chybně, nebudete na to upozorněni. Je to proto, že <strong>každá přístupová fráze vytváří jinou, avšak platnou peněženku.</strong> To znamená, že můžete používat více přístupových frází pro libovolný počet peněženek. Každá peněženka je však přístupná pouze po zadání příslušné přístupové fráze.

Po připojení BitBoxu budete jako obvykle vyzváni k zadání hesla zařízení. Poté budete vyzváni k zadání přístupové fráze.

Po zadání přístupové fráze se zobrazí vámi zadaná přístupová fráze. To proto, abyste mohli potvrdit, že jste ji zadali správně.`,
    title: "Jak to funguje"
  },
  intro: {
    message: `Přístupová fráze poskytuje další vrstvu zabezpečení nad vaší peněženkou.
Pojďme se naučit, jak to funguje.`,
    title: "Nastavení přístupové fráze"
  },
  progressDisable: {
    message: "Potvrďte na svém BitBoxu, že chcete <strong>deaktivovat</strong> volitelnou přístupovou frázi.",
    title: "Potvrďte na zařízení"
  },
  progressEnable: {
    message: "Potvrďte na svém BitBoxu, že chcete <strong>aktivovat</strong> volitelnou přístupovou frázi.",
    title: "Potvrďte na zařízení"
  },
  successDisabled: {
    message: `Volitelná přístupová fráze <strong>byla úspěšně aktivována</strong>!
Od této chvíle budete vyzváni k zadání přístupové fráze.`,
    messageEnd: "Nyní znovu připojte BitBox02.",
    title: "Přístupová fráze aktivní"
  },
  successEnabled: {
    message: `Volitelná přístupová fráze <strong>byla úspěšně deaktivována</strong>!

Již nebudete vyzváni k zadání přístupové fráze.`,
    messageEnd: "Nyní znovu připojte svůj BitBox02.",
    tips: "Tipy",
    tipsList: [
      "Doporučujeme nejprve odeslat malou částku do peněženky s přístupovou frází. Poté odpojte a znovu zapojte BitBox02 a zadejte heslo a přístupovou frázi. Pokud jste zadali přístupovou frázi správně, měli byste prostředky vidět ve své peněžence.",
      "Pokud chcete vstoupit do své původní peněženky bez přístupové fráze, můžete to provést tak, že po výzvě k zadání přístupové fráze nezadáte nic. Nebo můžete funkci přístupové fráze vypnout."
    ],
    title: "Přístupová fráze deaktivována"
  },
  summary: {
    button: "Aktivovat přístupovou frázi",
    title: "Přehled",
    understand: "Rozumím fungování přístupové fráze a rizikům s tím spojeným.",
    understandList: [
      "Přístupová fráze představuje další vrstvu zabezpečení nad vaší zálohou.",
      "Zadáním jiné přístupové fráze se vždy vygeneruje jiná peněženka.",
      "K obnovení peněženky potřebujete <strong>přístupovou frázi i zálohu</strong>.",
      "Pokud zapomenete přístupovou frázi, <strong>ztratíte přístup ke svým prostředkům</strong>."
    ]
  },
  what: {
    button: "Přečtěte si, jak to funguje",
    message: `Peněženka je vytvořena (odvozena) z velmi velkého náhodného čísla, známého také jako seed. Tento seed, nebo slova pro obnovení, je vytvořen při prvním nastavení BitBoxu a je zálohován pomocí microSD karty anebo prostřednictvím jiné zálohy (papír, steelwallet apod.). Každý, kdo má přístup k seedu, má plnou kontrolu nad prostředky v této peněžence.

Přístupová fráze je <strong>volitelné tajemství</strong>, které se přidává k seedu. Při použití přístupové fráze se při každém použití vytvoří nová peněženka na základě seedu + přístupové fráze (nepovinného tajemství). Passphrase může být jakákoli: písmena, slova, speciální znaky nebo může být i prázdná. Výchozí peněženka je ve skutečnosti odvozena od seedu + prázdné přístupové fráze.

Přístupová fráze je součástí standardu BIP39, což znamená, že je kompatibilní se všemi peněženkami, které tento standard podporují.`,
    title: "Co je přístupová fráze?"
  },
  why: {
    button: "Proč používat přístupovou frázi",
    message: `BitBox02 chrání seed před stažením ze samotného zařízení, ale záloha (uložena na microSD kartě nebo obnovovací slova zapsaná na papíře) umožňuje plný přístup k peněžence. Proto by měla být uložena na bezpečném místě!

Vzhledem k tomu, že přístupová fráze vytváří novou peněženku pomocí vašeho stávajícího seedu, vyžaduje peněženka s přístupovou frází k obnovení <strong>zálohu i přístupovou frázi</strong>. Výhodou je, že pokud někdo najde vaši zálohu, bude k přístupu do peněženky s přístupovou frází stále potřebovat přístupovou frázi.

Funkce přístupové fráze navíc umožňuje vytvořit na stejném zařízení více peněženek nebo "skrytých peněženek" kromě té výchozí.`,
    title: "Proč používat přístupovou frázi?"
  }
}, password$h = {
  show: "Zobrazit {{label}}",
  warning: {
    caps: "VAROVÁNÍ: Caps Lock (⇪) je zapnutý",
    paste: 'pro vložení textu povolte "ZOBRAZIT {{label}}"'
  }
}, random$i = {
  button: "Vygenerujovat náhodné číslo",
  description: "Váš BitBox vygeneroval následující {{bits}}-bit náhodné číslo:"
}, receive$j = {
  changeScriptType: "Změňit typ adresy",
  label: "Vaše adresa",
  onlyThisCoin: {
    description: "Chcete-li přijímat další tokeny, aktivujte je v nastavení. Pokud vložíte jiné tokeny, nemusí být přístupné.",
    warning: "Ujistěte se, že přijímáte pouze {{coinName}} na této adrese."
  },
  scriptType: {
    p2tr: "Taproot (nejnovější formát)",
    p2wpkh: "Nativní Segwit (výchozí)",
    "p2wpkh-p2sh": "Wrapped Segwit (kompatibilní formát)"
  },
  selectAccount: "Vybrat účet",
  showFull: "Zobrazit a ověřit celou adresu na zařízení",
  taprootWarning: "Poznámka: Taproot je nová funkce Bitcoinu a zatím není široce používána. Prostředky přijaté na adresy Taproot nemusí být viditelné v peněženkách třetích stran, které jsou určeny pouze pro sledování (watch-only wallets). Mnoho peněženek a burz zatím není schopno posílat na adresy Taproot.",
  title: "Přijmout {{accountName}}",
  verify: "Bezpečně ověřit adresu",
  verifyBitBox01: "Ověřit adresu v mobilní aplikaci",
  verifyBitBox02: "Ověřit adresu na BitBox02",
  verifyInstruction: "Zkontrolujte, zda se následující adresa shoduje s adresou zobrazenou na vašem zařízení.",
  warning: {
    secureOutput: 'Spárujte prosím svůj BitBox s mobilním zařízením, abyste mohli bezpečně ověřit adresu. Přejděte na "Spravovat zařízení" v postranním panelu.'
  }
}, reset$h = {
  description: "Všechna data v zařízení budou smazána. Včetně vašeho soukromého klíče!",
  notReset: "Zařízení nebylo resetováno",
  title: "Resetovat zařízení do továrního nastavení",
  understand: "Mám zálohu a znám heslo pro obnovení",
  understandBB02: "Mám platnou zálohu"
}, securityInformation$h = {
  create: {
    description1: "Doporučujeme nastavovat zařízení v bezpečném prostředí, to znamená mimo dosah dalších osob, které by mohly vidět vámi zvolené heslo.",
    description2: "Budete vyzváni k vytvoření dvou hesel.",
    description3: "První je <strong>heslo zařízení</strong>, které odemkne váš BitBox a které lze později změnit.",
    description4: "Druhým je <strong>heslo pro obnovení</strong>, které odemkne vaši peněženku. Toto heslo nelze později změnit.",
    description5: "Peněženka, kterou vytvoříte, bude zálohována do souboru na dodané microSD kartě. Ten můžete v případě nouze použít k obnovení svých prostředků pomocí hesla pro obnovení.",
    title: "Informace o zabezpečení"
  },
  restore: {
    description1: "Budete vyzváni k vložení microSD karty, kterou jste použili k uložení zálohy.",
    description2: "K obnovení zařízení budete potřebovat heslo pro obnovení. ",
    description3: "Při zadávání hesla pro obnovení buďte opatrní. Jakékoli zadané heslo vytvoří platnou peněženku. Pokud zadáte špatné heslo, může se vám zobrazit zůstatek peněženky, který neočekáváte.",
    title: "Informace o zabezpečení"
  }
}, seed$h = {
  agreements: {
    "funds-access": "Pokud zapomenu heslo pro obnovení, ZTRATÍM přístup ke svým finančním prostředkům.",
    "password-change": "Heslo pro obnovení NEMŮŽU později změnit",
    "password-required": "Heslo pro obnovení je nutné pro obnovení peněženky ze zálohy."
  },
  create: "Vytvořit peněženku",
  creating: "Vytváření peněženky",
  description: "Rozumím, že:",
  error: {
    e102: "Heslo musí obsahovat alespoň 4 znaky.",
    e200: "Pro vytvoření peněženky je třeba do BitBoxu vložit microSD kartu, aby se mohla automaticky vytvořit záloha."
  },
  info: {
    button: "Nastavit heslo pro obnovení",
    description1: "Vložte microSD kartu do zařízení BitBox",
    description2: 'Zvolte heslo pro obnovení peněženky a vyberte možnost "Nastavit heslo pro obnovení".',
    description3: "Zálohování na microSD kartu a heslo pro obnovení je jedinou metodou, jak obnovit své prostředky v případě ztráty nebo krádeže BitBoxu.",
    description4: "Heslo pro obnovení nelze později změnit bez převodu finančních prostředků.",
    title: "Vytvořit novou peněženku"
  },
  password: {
    label: "Heslo pro obnovení",
    repeatPlaceholder: "Zopakujte heslo pro obnovení"
  },
  walletName: {
    label: "Název peněženky"
  }
}, seedRestore$h = {
  error: {
    e200: "Obnovení peněženky ze zálohy vyžaduje microSD kartu."
  },
  info: {
    description1: 'Vložte microSD kartu do BitBoxu a klikněte na tlačítko "Pokračovat".',
    description2: 'Vyberte zálohu a klikněte na tlačítko "Obnovit".',
    description3: "Zadejte heslo pro obnovení",
    description4: "Je zapotřebí potvrdit, abyste si uvědomili, že nesprávné heslo vytvoří jinou peněženku.",
    title: "Jak obnovit peněženku ze zálohy"
  }
}, send$j = {
  abort: "Transakce byla zrušena.",
  address: {
    label: "Adresa přijemce",
    placeholder: "Zadejte adresu"
  },
  amount: {
    label: "Částka",
    placeholder: "Zadejte částku"
  },
  availableBalance: "Dostupný zůstatek",
  button: "Překontrolování",
  coincontrol: {
    address: "Adresa",
    outpoint: "Outpoint",
    title: "Odeslat z outputu"
  },
  confirm: {
    "selected-coins": "Vybrané mince",
    title: "Potvrďte a odešlete transakci",
    total: "Celkem"
  },
  error: {
    erc20InsufficientGasFunds: "Zdá se, že nemáte dostatek etherů na zaplacení této ERC20 transakce. Ujistěte se prosím, že máte v peněžence dostatek etherů.",
    feeTooLow: "poplatek příliš nízký",
    feesNotAvailable: "Nelze odhadnout poplatky",
    insufficientFunds: "nedostatek finančních prostředků",
    invalidAddress: "neplatná adresa",
    invalidAmount: "neplatná částka",
    invalidData: "neplatná data"
  },
  fee: {
    customPlaceholder: "Zadejte částku",
    label: "Síťový poplatek",
    placeholder: "Není dostupný"
  },
  feeTarget: {
    customLabel: "Výše poplatku",
    customLabel_eth: "Gas cena",
    description: {
      economy: "4 hodiny (24 bloků)",
      economy_eth: "30 minut nebo méně",
      economy_ltc: "1 hodina (24 bloků)",
      high: "20 minut (2 bloky)",
      high_eth: "30 sekund nebo méně",
      high_ltc: "5 minut (2 bloky)",
      low: "2 hodiny (12 bloků)",
      low_eth: "5 minut nebo méně",
      low_ltc: "30 minut (12 bloků)",
      normal: "1 hodina (6 bloků)",
      normal_eth: "2 minuty nebo méně",
      normal_ltc: "15 minut (6 bloků)"
    },
    estimate: "Odhadovaný čas potvrzení:",
    label: {
      custom: "Vlastní",
      economy: "Úsporný",
      high: "Vysoký",
      low: "Nízký",
      normal: "Normální"
    },
    placeholder: "Výpočet poplatku…"
  },
  maximum: "Poslat vše",
  maximumSelectedCoins: "Poslat vybrané mince",
  noFeeTargets: "Odhady výše poplatků nejsou v současné době k dispozici. Zkuste to prosím později nebo zadejte vlastní poplatek.",
  priority: "Priorita",
  scanQR: "Naskenujte QR kód",
  signprogress: {
    description: "Jedná se o transakci obsahující velké množství dat. Chcete-li transakci plně podepsat, budete vyzváni k potvrzení {{steps}}krát.",
    label: "Průběh"
  },
  success: "Transakce byla podepsána a odeslána.",
  title: "Poslat {{accountName}}",
  toggleCoinControl: "Přepnout na coin control",
  transactionDetails: "Detaily transakce"
}, settings$i = {
  about: "O aplikaci",
  accounts: "Účty",
  advancedSettings: "Pokročilé nastavení",
  appearance: "Vzhled",
  electrum: {
    add: "Přidat server",
    "add-server": "Přidat",
    check: "Kontrola",
    checkFailed: "Kontrola selhala",
    checkSuccess: "Úspěšně navázáno spojení s {{host}}",
    checking: "Kontroluji",
    "download-cert": "Stáhnout vzdálený certifikát",
    "remove-server": "Odstranit",
    removeConfirm: "Odstranit {{server}}?",
    reset: "Obnovit do základního nastavení",
    resetConfirm: "Chcete odebrat všechny servery a nainstalovat výchozí servery?",
    servers: "Servery",
    step1: "1",
    "step1-text": "Zadejte endpoint.",
    step2: "2",
    "step2-text": "Zadejte certifikát řetězce certifikátů serveru. Případně stáhněte vzdálený certifikát a vizuálně jej porovnejte.",
    "step2-text-tcp": "Pokud nechcete používat TLS, můžete tento krok přeskočit.",
    step3: "3",
    "step3-text": "Zkontrolujte připojení a přidejte server.",
    step4: "4",
    "step4-text": "Restartujte peněženku. Pokud neodstraníte výchozí servery, bude váš vlastní uzel přidán jako nadbytečný.",
    "title-btc": "Bitcoinové Electrum servery",
    "title-ltc": "Litecoin Electrum servery",
    "title-tbtc": "Bitcoin Testnet Electrum servery",
    "title-tltc": "Litecoin Testnet Electrum servery"
  },
  expert: {
    coinControl: "Aktivovat coin control",
    electrum: {
      description: "Můžete se připojit ke svému vlastnímu Electrum uzlu (full node).",
      title: "Připojte svůj vlastní uzel (full node)"
    },
    fee: "Aktivovat vlastní poplatky",
    setProxyAddress: "Nastavit adresu proxy",
    title: "Expertní nastavení",
    useProxy: "Aktivovat tor proxy",
    useSats: "Zobrazit hodnoty BTC v satoshi"
  },
  header: {
    home: "Domů"
  },
  info: {
    "out-of-date": "K dispozici je nová aktualizace",
    title: "Info",
    "up-to-date": "Vaše aplikace je aktuální",
    version: "Verze aplikace"
  },
  restart: "Restartujte BitBoxApp, aby se změny projevily.",
  services: {
    title: "Služby"
  },
  success: "Aby se změny projevily, odpojte a znovu připojte BitBox.",
  title: "Nastavení"
}, setup$h = "Nastavení zařízení", sidebar$i = {
  buy: "Koupit krypto",
  device: "Spravovat zařízení",
  leave: "Odejít",
  settings: "Nastavení"
}, success$o = {
  create: {
    info1: "Vaše peněženka byla bezpečně zálohována na microSD kartu. Vyjměte ji a uschovejte v bezpečí.",
    info2: "Vytvořili jste bezpečné heslo zařízení, které odemyká BitBox.",
    info3: "Pro svou peněženku jste si vytvořili bezpečné heslo pro obnovení, které odemkne vaše prostředky a obnoví vaše zálohy.",
    summary: "Zde je shrnutí toho, co jste udělali",
    title: "Hotovo"
  },
  getstarted: "Začněte",
  restore: {
    summary: "Úspěšně jste obnovili peněženku ze zálohy.",
    title: "Hotovo"
  }
}, transaction$i = {
  confirmation: "Konfirmace",
  details: {
    activity: "Přehled aktivit",
    address: "Adresa",
    amount: "Částka",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Částka ve fiatu",
    fiatAtTime: "Fiat v době transakce",
    status: "Stav",
    type: "Typ"
  },
  explorer: "ID transakce",
  explorerTitle: "Otevřít v externím block exploreru",
  fee: "Poplatek",
  fiatHistorical: "Historický",
  gas: "Gas",
  note: {
    edit: "Upravit poznámku",
    save: "Uložit poznámku"
  },
  pending: "Čekající transakce",
  size: "Velikost",
  status: {
    complete: "Dokončená",
    failed: "Neúspěšná",
    pending: "Čekající"
  },
  tx: {
    received: "Přijata na",
    sent: "Odeslána na"
  },
  vsize: "Virtuální velikost",
  weight: "Váha"
}, transactions$h = {
  errorLoadTransactions: "Při načítání transakcí došlo k chybě",
  placeholder: "Zatím žádné transakce."
}, unknownError$h = "Nastala neznámá chyba: {{errorMessage}}", unlock$h = {
  description: "Pro odemknutí zadejte heslo zařízení.",
  error: {
    e109_normal: "Nesprávné heslo. Zbývá ještě {{remainingAttempts}} pokusů, než bude zařízení resetováno.",
    e109_touch: "$t(unlock.error.e109_normal) Další přihlášení vyžaduje podržení dotykového tlačítka.",
    e113: "Vzhledem k mnoha pokusům o přihlášení vyžaduje další přihlášení podržení dotykového tlačítka po dobu 4 sekund."
  },
  input: {
    label: "Heslo zařízení",
    placeholder: "Zadejte heslo zařízení pro odemknutí"
  },
  unlocking: "Odemykání..."
}, upgradeFirmware$i = {
  button: "Aktualizovat firmware",
  description: "Chcete aktualizovat firmware z {{currentVersion}} verze na {{newVersion}}?",
  label: "Váš BitBox vyžaduje upgrade firmwaru.",
  locked: "Chcete-li provést upgrade z {{currentVersion}} na {{newVersion}}, proveďte dlouhý dotyk.",
  title: "Upgradovat firmware",
  unlocked: "Bootloader je odemčený. Chcete-li pokračovat, prosím:",
  unlocked1: "Odpojte a znovu zapojte váš Bitbox",
  unlocked2: "Po opětovném zapojení vašeho BitBoxu se rozsvítí LED dioda.",
  unlocked3: "Když se rozsvítí LED dioda, klepněte na dotykové tlačítko"
}, walletConnect$b = {
  connect: {
    button: "Připojit",
    dappLabel: "Zadejte URI adresu dapp",
    invalidPairingUri: "Neplatné párování uri"
  },
  dashboard: {
    allSessions: "Všechny relace",
    disclaimer: "Walletconnect je protokol pro připojení k Dapps založeným na Ethereu. Tyto dapps jsou provozovány službami třetích stran, takže se připojujte pouze k dapps, kterým důvěřujete, a vždy se ujistěte, že víte, co podepisujete při provádění transakce.",
    newConnection: "Nové připojení",
    noConnectedSessions: "V této chvíli nejsou k dapps připojeny žádné účty."
  },
  invalidPairingChain: "Chyba při schvalování párování. Ujistěte se, že používáte jednu z podporovaných sítí: {{chains}}",
  pairingRequest: {
    approve: "Schválit připojení",
    reject: "Odmítnout",
    title: "Nový požadavek na připojení od"
  },
  pairingSuccess: "Dapp se úspěšně připojil. Pokračovat můžete na dapp webu",
  signingRequest: {
    account: "Účet",
    chain: "Síť",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Nepodařilo se zpracovat data",
    decodeError: "Zprávu se nepodařilo dekódova",
    method: {
      sendTransaction: "Podepište a odešlete transakci",
      signMessage: "Podepsat zprávu",
      signTransaction: "Podepsat transakci",
      signTypedData: "Podepište zadaná data"
    },
    successfullySigned: "Žádost byla úspěšně podepsána",
    walletConnectRequest: "Žádost o připojení k WalletConnect"
  },
  useNewUri: "Tento URI již byl použit k pokusu o připojení. Použijte prosím nový URI.",
  walletConnect: "WalletConnect"
}, warning$n = {
  receivePairing: 'Spárujte BitBox, abyste mohli bezpečně ověřit adresu. Přejděte na "Spravovat zařízení" v postranním panelu.',
  sdcard: "MicroSD kartu mějte uloženou odděleně od BitBoxu, pokud ovšem nechcete spravovat zálohy.",
  sendPairing: 'Spárujte prosím BitBox a bezpečně ověřte údaje o transakci. Přejděte na "Spravovat zařízení" v postranním panelu.'
}, welcome$h = {
  connect: "Připojte BitBox02",
  getStarted: "Začněme instalací firmwaru na váš BitBox02.",
  insertBitBox02: "Pro BitBox02 klepněte na zařízení a pokračujte.",
  insertDevice: "Připojte své zařízení a začněte",
  title: "Vítejte"
}, appTranslationsCS = {
  account: account$h,
  accountInfo: accountInfo$h,
  accountSummary: accountSummary$h,
  addAccount: addAccount$i,
  aopp: aopp$b,
  app: app$h,
  auth: auth$a,
  backup: backup$h,
  bb02Bootloader: bb02Bootloader$h,
  bitbox: bitbox$h,
  bitbox02Interact: bitbox02Interact$h,
  bitbox02Settings: bitbox02Settings$h,
  bitbox02Wizard: bitbox02Wizard$h,
  blink: blink$h,
  bootloader: bootloader$h,
  button: button$l,
  buy: buy$d,
  changePin: changePin$h,
  chart: chart$d,
  checkSDcard: checkSDcard$h,
  clickHere: clickHere$h,
  confirm: confirm$j,
  confirmOnDevice: confirmOnDevice$h,
  connectKeystore: connectKeystore$a,
  darkmode: darkmode$b,
  device: device$h,
  deviceLock: deviceLock$h,
  deviceSettings: deviceSettings$h,
  deviceTampered: deviceTampered$h,
  dialog: dialog$i,
  error: error$d,
  fiat: fiat$j,
  footer: footer$j,
  generic: generic$d,
  genericError: genericError$h,
  goal: goal$h,
  guide: guide$i,
  headerssync: headerssync$h,
  hiddenWallet: hiddenWallet$h,
  initialize: initialize$h,
  invalidFormat: invalidFormat$h,
  language: language$i,
  legacyhiddenwallet: legacyhiddenwallet$h,
  loading: loading$h,
  manageAccounts: manageAccounts$b,
  mobile: mobile$c,
  newSettings: newSettings$a,
  note: note$d,
  notification: notification$h,
  pairing: pairing$h,
  passphrase: passphrase$b,
  password: password$h,
  random: random$i,
  receive: receive$j,
  reset: reset$h,
  securityInformation: securityInformation$h,
  seed: seed$h,
  seedRestore: seedRestore$h,
  send: send$j,
  settings: settings$i,
  setup: setup$h,
  sidebar: sidebar$i,
  success: success$o,
  transaction: transaction$i,
  transactions: transactions$h,
  unknownError: unknownError$h,
  unlock: unlock$h,
  upgradeFirmware: upgradeFirmware$i,
  walletConnect: walletConnect$b,
  warning: warning$n,
  welcome: welcome$h
}, account$g = {
  disconnect: "Verbindung unterbrochen. Erneut verbinden... ",
  export: "Export",
  exportTransactions: "Exportiere Transaktionen im Download Ordner als CSV Datei",
  fatalError: "Ein unerwarteter Fehler ist aufgetreten.",
  incoming: "Eingehend",
  initializing: "Informationen werden von der Blockchain geladen…",
  maybeProxyError: "Tor-Proxy aktiviert. Stelle sicher, dass Tor-Proxy ordnungsgemäß ausgeführt wird, oder deaktiviere die Proxy-Einstellung.",
  reconnecting: "Verbindung abgebrochen, neue Verbindung wird aufgebaut…",
  syncedAddressesCount: "{{count}} Adressen gescannt"
}, accountInfo$g = {
  address: "Adresse",
  buyCTA: {
    buy: "{{unit}} kaufen",
    buyCrypto: "Krypto kaufen",
    information: {
      looksEmpty: "Sieht so aus, als wäre dieses Wallet leer.",
      start: "Lege los, indem du einige Coins auf das Wallet einzahlst oder direkt in der BitBoxApp kaufst."
    }
  },
  extendedPublicKey: "Erweiterter Public Key",
  label: "Konto Informationen",
  scriptType: "Script-Typ",
  title: "Konto Informationen",
  verify: "Auf Gerät bestätigen",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy-P2PKH erweiterten Public Key anzeigen",
    p2tr: "Taproot anzeigen",
    p2wpkh: "Native Segwit anzeigen",
    "p2wpkh-p2sh": "Älteren Segwit erweiterten öffentlichen Schlüssel anzeigen"
  },
  xpubTypeInfo: "Derzeit wird der {{scriptType}} erweiterte Public Key angezeigt ({{current}} von {{numberOfXPubs}})"
}, accountSummary$g = {
  availableBalance: "Kontostand",
  balance: "Saldo",
  exportSummary: "Kontozusammenfassung als CSV Datei zum Download Ordner exportieren",
  fiatBalance: "Fiat Kontostand",
  name: "Konto Name",
  noAccount: "Keine Konten verfügbar",
  subtotalWithCoinName: "Summe ({{coinName}})",
  title: "Kontenübersicht",
  total: "Gesamt",
  transactionHistory: "Transaktionsübersicht"
}, addAccount$h = {
  chooseName: {
    nextButton: "Konto hinzufügen",
    step: "Konto benennen",
    title: "Benenne dein Konto"
  },
  selectCoin: {
    nextButton: "Weiter",
    step: "Coin wählen",
    title: "Kryptowährung wählen"
  },
  success: {
    addAnotherAccount: "Neues Konto hinzufügen",
    message: "<strong>{{accountName}}</strong> wurde zu deinen Konten hinzugefügt.",
    nextButton: "Fertig",
    step: "Erledigt",
    title: "Konto hinzugefügt"
  },
  title: "Konto hinzufügen"
}, aopp$a = {
  addressRequest: "{{host}} fordert eine Empfangsadresse an.",
  addressRequestWithLogo: "fordert eine Empfangsadresse an",
  banner: "Adressanfrage in Bearbeitung. Bitte verbinde dein Gerät um fortzufahren.",
  errorTitle: "Fehler während Adressanfrage",
  labelAddress: "Adresse",
  labelMessage: "Nachricht",
  reverifyInfoText: "Adresse überprüfen",
  signing: "Signiere die Nachricht auf deiner BitBox um fortzufahren",
  success: {
    message: "Weiter auf {{host}}",
    title: "Adresse erfolgreich übermittelt"
  },
  syncing: "Konto wird synchronisiert, bitte warten.",
  title: "Adressanfrage"
}, app$g = {
  upgrade: "Eine neue Version der App ist verfügbar! Bitte aktualisiere von {{current}} auf {{version}}."
}, auth$9 = {
  authButton: "Authentifizieren",
  title: "Bitte authentifiziere dich, um fortzufahren"
}, backup$g = {
  check: {
    checking: "Backup wird geprüft…",
    confirmTitle: "Backup überprüfen",
    notOK: "Dein Backup entspricht NICHT deiner aktuellen Wallet.",
    ok: "Erfolg! Dein Backup entspricht deiner aktuellen Wallet.",
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Wiederherstellungspasswort",
      showLabel: "Wiederherstellungspasswort"
    },
    success: "Backup erfolgreich überprüft:",
    title: "Backup überprüfen"
  },
  create: {
    alreadyExists: "Du hast schon ein gültiges Backup. Willst du trotzdem ein weiteres Backup erstellen?",
    fail: "Erstellung des Backups FEHLGESCHLAGEN!",
    info: "Bitte gib dein Wiederherstellungspasswort ein, um deine aktuelle Wallet zu verifizieren.",
    name: {
      label: "Backup Name",
      placeholder: "Bitte benenne dein Backup."
    },
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Bitte gib dein Wiederherstellungspasswort ein."
    },
    title: "Backup erstellen",
    verificationFailed: "Das Wiederherstellungspasswort entspricht NICHT der aktuellen Wallet. Das Backup wurde erstellt. Bitte nutze „Backup prüfen“ um dein Wiederherstellungspasswort erneut zu überprüfen. "
  },
  description: "Wähle eine  <strong>Wallet Backup</strong> Datei aus.",
  insert: "Bitte stecke die Micro-SD-Karte ein um deine Backups zu verwalten.",
  insertButton: "Ich habe die Mikro-SD-Karte eingesteckt.",
  list: "Deine Backups auf der microSD Karte",
  noBackups: "Es befinden sich keine Backups auf der microSD Karte.",
  restore: {
    confirmTitle: "Von Backup wiederherstellen",
    error: {
      e200: "microSD Karte nicht gefunden",
      general: "Fehler beim Wiederherstellen von Backup"
    },
    password: {
      label: "Wiederherstellungspasswort oder verstecktes Wiederherstellungspasswort. ",
      placeholder: "Wiederherstellungspasswort",
      repeatPlaceholder: "Wiederherstellungspasswort erneut eingeben",
      showLabel: "Wiederherstellungspasswort"
    },
    restoring: "Wiederherstellen des Backups…",
    selectedBackup: "<strong>{{backupName}}</strong>, erstellt am {{createdDateTime}}, wird wiederhergestellt.",
    title: "Wiederherstellen",
    understand: "Ich habe verstanden, dass ein falsches Wiederherstellungspasswort eine neue/andere Wallet erstellt."
  },
  showMnemonic: {
    description: `Dir werden Wiederherstellungswörter angezeigt, die ein Backup deiner Wallet sind. Schreibe diese auf ein Stück Papier. 

<strong>Bewahre diese Wörter nicht digital auf und mache kein Foto von ihnen.</strong>

<strong>Sprich die Wörter nicht laut aus.</strong>

<strong>Dieses Backup ist nicht Passwort geschützt.</strong>

Nachdem du die Wörter aufgeschrieben hast wirst du gefragt werden sie nochmals zu bestätigen.
`,
    title: "Recovery-Wörter anzeigen",
    warning: "<strong>Teile deine Wiederherstellungswörter niemals mit irgendjemandem.</strong> Deine Wiederherstellungswörter ermöglichen vollen Zugriff zu deinem Wallet . Wenn dich jemand nach deinen Wiederherstellungswörtern fragt, handelt es sich um einen Betrüger. Gebe diese nicht weiter!"
  },
  title: "Backups verwalten"
}, bb02Bootloader$g = {
  abort: "Nicht upgraden - Zurück!",
  abort_noUpgrade: "Zurück",
  advanced: {
    label: "Erweiterte Einstellungen",
    toggleShowFirmwareHash: "Zeig mir den Hash der Firmware bei jedem Anstecken der BitBox"
  },
  flipscreen: "Bildschirm spiegeln",
  orientation: "Ist der Bildschirm kopfüber?",
  success: "Upgrade erfolgreich. In {{rebootSeconds}}  geht es weiter....",
  success_install: "Installation erfolgreich! Es geht weiter in {{rebootSeconds}} Sekunden..."
}, bitbox$g = {
  error: {
    e10000: "Aktuelles Gerätepasswort ist falsch.",
    e10001: "Fehler beim Ändern des Gerätepassworts",
    e102: "Das Passwort muss aus 4 Zeichen bestehen.",
    e112: "Das versteckte Gerätepasswort und das normale Gerätepasswort können nicht identisch sein."
  }
}, bitbox02Interact$g = {
  confirmDate: "Bestätige das heutige Datum auf deiner BitBox02",
  confirmDateText: "Dieses Datum wird mit deinem Backup gespeichert. ",
  confirmName: "Bestätige den Namen auf deiner BitBox02",
  confirmWords: "Notiere die {{amount}} Wiederherstellungswörter von deiner BitBox02",
  confirmWordsText: "Danach fordert dich die BitBox02 auf, jedes Wort zu bestätigen, um zu überprüfen, ob dein Backup korrekt ist.",
  followInstructions: "Bitte folge den Anweisungen auf deiner BitBox02.",
  followInstructionsMnemonic: "Bitte folge den Anweisungen auf deiner BitBox02 um deine Wallet mit deinen Wiederherstellungswörtern wieder herzustellen.",
  followInstructionsMnemonicTitle: "Mit Wiederherstellungs-Wörtern wiederherstellen"
}, bitbox02Settings$g = {
  deviceName: {
    current: "Aktueller Gerätename",
    error: "Gerätename konnte nicht festgelegt werden",
    error_104: "Die Bestätigung des Gerätenamens wurde auf dem Gerät abgebrochen.",
    input: "BitBox02 Name",
    placeholder: "Neuer Gerätename",
    title: "BitBox02 Namen einstellen"
  },
  gotoStartupSettings: {
    description: "Dadurch wird deine BitBox02 neu gestartet und die Starteinstellungen angezeigt.",
    title: "Gehe zu den Starteinstellungen"
  }
}, bitbox02Wizard$g = {
  advanced: {
    button: "Erweiterte Optionen",
    outOfDate: "Die Firmware ist für diese Funktion zu veraltet",
    seed12WordInfo: "Bitte beachte, dass die Anzahl der Wörter nach dem Erstellen des Wallets nicht mehr geändert werden kann.",
    seed12WordLabel: "Erstelle einen Seed mit 12 Wörtern statt mit 24 Wörtern",
    seed12WordText: "Standardmäßig verwendet die BitBox02 einen 24-Wörter-Seed. Beide Seed-Längen sind in der Praxis sicher gegen Brute-Forcing. Einige Benutzer bevorzugen möglicherweise die Bequemlichkeit eines 12-Wörter-Seeds.",
    skipSDCardLabel: "Überspringe die Sicherung auf der MicroSD-Karte und notiere stattdessen die Wiederherstellungswörter",
    skipSDCardText: "Du hast jederzeit die Möglichkeit, nach der Einrichtung ein Backup auf der MicroSD-Karte zu erstellen und deine Wiederherstellungswörter aufzuschreiben. Dies kannst über die Einstellungen tun.",
    title: "Erweiterte Backup-Optionen"
  },
  attestationFailed: "Echtheitsprüfung fehlgeschlagen. Bitte stecke die BitBox aus und wieder ein.  Bitte kontaktiere support@bitbox.swiss, falls dieses Problem weiterhin besteht.",
  backup: {
    point1: "Wähle ein Backup von der microSD Karte aus",
    point2: "Setze ein Passwort für dein Gerät",
    restoreText: "Ok, lass uns deine Wallet von deinem Backup wiederherstellen!",
    text1: "Perfekt, dein BitBox02 Passwort ist jetzt festgelegt und deine Wallet wurde erstellt. Jetzt ist es Zeit ein Backup der Wallet zu erstellen. Bitte stelle dazu sicher, dass die microSD Karte eingesteckt ist. ",
    text2: 'Sobald du "Backup erstellen" geklickt hast folge bitte den Anweisungen auf deiner BitBox um ein Backup zu erstellen. ',
    text3: "Nachdem das Backup erstellt wurde, bewahre die microSD-Karte bitte an einem <strong>sicheren Ort auf und stecke die microSD-Karte niemals in ein anderes Gerät, das nicht eine BitBox ist. </strong> Das Backup auf der microSD-Karte ist nicht Passwort-geschützt!",
    userConfirmation1: "Ich muss mein Backup an einem sicheren Ort aufbewahren.",
    userConfirmation2: "Mein Backup ist nicht passwortgeschützt. Jeder, der Zugriff darauf hat, kann auf meine Wallet zugreifen.",
    userConfirmation3: "Wenn ich meine BitBox02 verliere oder beschädige, ist die Wiederherstellung von meinem Backup der einzige Weg wieder Zugriff auf mein Guthaben zu bekommen. ",
    userConfirmation4: "Sollte ich sowohl meine BitBox02 als auch mein Backup verlieren oder zerstören ist der Zugang zu meinen Coins für immer verloren. ",
    userConfirmation5: "Ich darf meine microSD Karte nicht in einen Computer, Handy, Drucker oder anderes (nicht BitBox02) Gerät stecken. ",
    userConfirmation5mnemonic: "Ich sollte meine Wiederherstellungswörter nicht in einen Computer, ein Telefon, einen Drucker oder irgendein anderes Gerät als eine BitBox02 stecken."
  },
  create: {
    button: "Gerät bennenen & weiter",
    info: "Hier sind die Schritte, die wir dazu durchlaufen werden:",
    inputTitle: "Wallet Name ",
    point1: "Gerät benennen",
    point2: "Gerätepasswort einstellen",
    point3: "Backup erstellen",
    text: "Ok, lass uns eine neue Wallet erstellen!"
  },
  createBackupAborted: "Backup-Erstellung abgebrochen.",
  createBackupFailed: "Erstellung des Backups fehlgeschlagen, erneut versuchen.",
  initialize: {
    passwordText: "Lass uns nun ein Passwort für deine BitBox festlegen. Schaue dir die Animation unten an und benutze dann die Touch Slider auf den Seiten deiner BitBox, um ein Passwort einzugeben. ",
    passwordTitle: "Setze ein Passwort für deine BitBox",
    text: "BitBox02 erfolgreich gekoppelt. Jetzt initialisieren wir deine BitBox02. Wähle zuerst aus, ob du eine neue Wallet erstellen oder von einem Backup wieder herstellen möchtest.  <strong>Wenn du von einem Backup wieder herstellen möchtest, stelle sicher, dass deine microSD Karte in deiner BitBox02 eingesteckt ist.</strong>",
    tip: "Bitte fahre in einer sichern Umgebung fort. ",
    title: "Initialisiere deine BitBox"
  },
  insertSDCard: "<strong>Bitte stelle sicher, dass du die microSD Karte in der BitBox02 eingesteckt hast.</strong>",
  noPasswordMatch: "Passwörter stimmen nicht überein. Bitte versuche es erneut.",
  pairing: {
    failed: "Kopplungscode nicht bestätigt. Bitte BitBox02 aus und wieder ein stecken.",
    paired: "Kopplungscode bestätigt. Bitte fahre fort.",
    title: "Kopplungscode bestätigen",
    unpaired: "Eine nicht gekoppelte BitBox02 wurde erkannt. Bitte bestätige, dass der Kopplungscode mit dem auf der BitBox02 übereinstimmt. "
  },
  restoreFromMnemonic: {
    e104: "Die Wiederherstellung durch Wiederherstellungswörter wurde abgebrochen.",
    failed: "Wiederherstellung von Wiederherstellungswörtern fehlgeschlagen. Bitte versuche es erneut."
  },
  stepBackup: {
    beforeProceed: "Bevor du fortfährst, lies bitte die folgenden wichtigen Sicherheitsaspekte:",
    createBackup: "Du erstellst jetzt ein Backup auf deiner microSD-Karte.",
    createBackupMnemonic: "Du wirst nun die Wiederherstellungswörter notieren."
  },
  stepBackupSuccess: {
    fundsSafe: "Beachte bitte Folgendes, um deine Coins zu schützen:",
    title: "Backup wiederhergestellt!"
  },
  stepConnected: {
    unlock: "BitBox02 Passwort eingeben "
  },
  stepCreate: {
    description: "Dieser Name wird als Gerätename und für das Backup verwendet.",
    nameLabel: "BitBox02 Name",
    namePlaceholder: "Meine BitBox02",
    title: "Wähle BitBox02 Name",
    toastMicroSD: "Bitte stelle sicher, dass deine microSD Karte in die BitBox02 eingesteckt ist. "
  },
  stepCreateSuccess: {
    removeMicroSD: "Bitte entnehme deine microSD Karte und bewahre diese an einem sicheren Ort auf.",
    storeMnemonic: "Bitte bewahre deine Wiederherstellungs-Wörter an einem sicheren Ort auf.",
    success: "Dein Backup wurde erfolgreich erstellt."
  },
  stepInsertSD: {
    insertSDCard: "Bitte stecke die microSD Karte in deine BitBox02 um fortzufahren",
    insertSDcardTitle: "MicroSD Karte einstecken"
  },
  stepPassword: {
    e104: "Das Festlegen des Passworts wurde abgebrochen.",
    title: "BitBox02 Passwort wählen",
    useControls: "Verwende die Touch Sensoren an den Seiten deiner BitBox02 um ein Passwort zu wählen."
  },
  stepUninitialized: {
    create: "Ich möchte eine neue BitBox02 einrichten.",
    restore: "Ich möchte meine Wallet von einem Backup wiederherstellen.",
    restoreMicroSD: "Von microSD Karte wiederherstellen",
    restoreMnemonic: "Von Wiederherstellungswörtern wiederherstellen",
    title: "BitBox02 einrichten"
  },
  success: {
    text: `Hurra! Deine BitBox02 ist bereit.

Für weitere Informationen klicke auf das Fragezeichen Symbol in der oberen rechten Ecke. `,
    title: "Es kann los gehen!"
  }
}, blink$g = {
  button: "Blinken"
}, bootloader$g = {
  button: "Firmware jetzt aktualisieren",
  button_install: "Firmware jetzt installieren",
  progress: "Aktualisiere: {{progress}}%",
  progress_install: "Installation: {{progress}}%",
  success: "Aktualisierung erfolgreich! Bitte ziehe das Gerät ab und stecke es dann wieder ein. Dieses mal brauchst du den Knopf nicht zu berühren. "
}, button$k = {
  abort: "Abbrechen",
  back: "Zurück",
  buy: "Kaufen",
  changepin: "Gerätepasswort ändern",
  check: "Backup überprüfen",
  continue: "Weiter",
  copy: "Kopieren",
  create: "Erstellen",
  dismiss: "Ausblenden",
  done: "Fertig",
  download: "Herunterladen",
  hiddenwallet: "Versteckte Wallet erstellen",
  next: "Weiter",
  ok: "OK",
  previous: "Zurück",
  receive: "Erhalten",
  restore: "Wiederherstellen",
  select: "Auswählen",
  send: "Senden",
  unlock: "Entsperren",
  update: "Update",
  upgrade: "Aktualisieren"
}, buy$c = {
  exchange: {
    bankTransfer: "Überweisung",
    bestDeal: "Bestes Angebot",
    creditCard: "Kreditkarte",
    fast: "Schnell",
    fee: "Gebühr",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Banküberweisung: {{fee}}%",
          creditDebitCard: "Kredit-/Debitkarte: {{fee}}%",
          learnMore: "Erfahre mehr über Moonpay",
          title: "Gebühren"
        },
        fullCurrenciesList: "Eine vollständige Liste der Währungen findest du hier",
        payment: {
          asteriskText: "* Nicht verfügbar für Einwohner der USA",
          bankTransfer: "Banküberweisung*",
          bankTransferDetails: {
            pix: "PIX (BR-Transaktionen nur in Brasilien)",
            sepa: "SEPA und SEPA Instant (EUR-Transaktionen nur in SEPA-Ländern)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Großbritannien)"
          },
          creditDebitCard: "Kredit-/Debitkarte",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa und Maestro"
          },
          learnMore: "Weitere Details zu den Zahlungsmethoden findest du hier",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Unterstützt alle gängigen Fiat-Währungen: USD, EUR, CHF und mehr."
      },
      pocket: {
        fees: {
          info: "Banküberweisung: {{fee}}%",
          title: "Gebühren"
        },
        learnMore: "Erfahre mehr über Pocket",
        payment: {
          bankTransfer: "Banküberweisung",
          bankTransferDetails: {
            sepa: "SEPA und SEPA Echtzeit (EUR-Transaktionen nur in SEPA-Ländern)",
            sic: "Swiss Interbank Clearing (CHF-Transaktionen nur in CH/LI)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Großbritannien)"
          },
          bankTransferReccuring: "Wie richte ich wiederkehrende Käufe mit einem Dauerauftrag ein?",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Unterstützt europäische Währungen: EUR, GBP und CHF.",
        verification: {
          info: "Identitätsprüfung nur bei Überschreitung der täglichen und jährlichen Schwellenwerte nötig.",
          link: "Aktuelle Schwellenwerte hier einsehen",
          title: "Identitätsprüfung"
        }
      },
      region: {
        title: "Wähle die Region aus, in der dein Bankkonto registriert ist, um zu sehen, welche Optionen dir zur Verfügung stehen."
      }
    },
    noExchanges: "Leider sind in dieser Region keine Börsen verfügbar.",
    region: "Region",
    selectRegion: "Nicht angegeben",
    title: "{{name}} kaufen "
  },
  info: {
    continue: "Zustimmen und fortfahren",
    crypto: "Krypto",
    disclaimer: {
      intro: [
        "Wir arbeiten mit MoonPay zusammen, damit du mit nur ein paar Klicks ganz einfach {{name}} direkt in der BitBoxApp kaufen kannst. ",
        "MoonPay ist eine vollständig regulierte Finanzdienstleistungsplattform, die den Kauf von {{name}} in über 160 Ländern einfach und schnell macht."
      ],
      payment: {
        details: "Du kannst {{name}} über MoonPay mit den folgenden Zahlungsmethoden kaufen. Mit Kredit- oder Debitkarten geht es sofort und bequem, ist aber aufgrund des erhöhten Rückbuchungsrisikos teurer. Wir empfehlen die Verwendung der Überweisungsoption für größere Beträge. Die Mindestgebühr beträgt 4 USD / EUR oder gleichwertig.",
        footnote: "Bitte beachte, dass die Wechselkurse von MoonPay von den in der BitBoxApp verwendeten abweichen können, was zu geringfügig unterschiedlichen Beträgen führen kann.",
        table: {
          "1_description": "Niedrigste Gebühren, kann bis zu 3 Werktage dauern",
          "1_method": "Banküberweisungen (SEPA)",
          "2_description": "Höhere Gebühren, aber schnell und sofort",
          "2_method": "Kredit & Debitkarten",
          description: "Beschreibung",
          fee: "Gebühr",
          method: "Methode"
        },
        title: "Zahlungsmethoden und Gebühren"
      },
      privacyPolicy: "MoonPay-Datenschutzrichtlinie",
      protection: {
        description: "Die BitBoxApp sammelt beim Kauf von {{name}} keine Daten. Die eingehenden Transaktionen werden wie reguläre Transaktion behandelt. MoonPay muss einige persönliche Daten sammeln, um funktionieren zu können. In deren Datenschutzbestimmungen wird ausführlich erläutert, wie mit diesen Daten umgegangen wird.",
        descriptionGeneric: "Die BitBoxApp erhebt beim Kauf von {{name}} keinerlei Daten, die eingehenden Gelder werden wie eine normale Transaktion behandelt. Partnerbörsen müssen jedoch einige Informationen sammeln, um zu funktionieren. Einzelheiten zum Umgang mit Daten kannst du der jeweiligen Datenschutzerklärung entnehmen.",
        title: "Datenschutz"
      },
      security: {
        description: "Wenn du {{name}} über MoonPay kaufst, dann nutzt du einen externen Dienst. Dieser Dienst liegt außerhalb des Anwendungsbereichs des BitBox02 Sicherheitsbedrohungsmodells und verlässt sich auf die Sicherheit des Geräts, auf dem die BitBoxApp Software läuft.",
        descriptionGeneric: "Wenn du {{name}} über eine Partnerbörse kaufst, nutzt du einen externen Dienst. Dieser Dienst liegt außerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hängt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgeführt wird.",
        link: "Sicherheitsbedrohungsmodells",
        title: "Sicherheitsmodell"
      },
      title: "Willkommen in deinem One-Stop-Shop zum Kauf von {{name}}"
    },
    next: "Weiter",
    selectLabel: "Konto wählen",
    selectPlaceholder: "Wähle einen Coin",
    skip: "Nicht mehr anzeigen",
    title: "{{name}} kaufen "
  },
  pocket: {
    data: {
      link: "Pocket-Datenschutzrichtlinie",
      p1: "Die BitBoxApp sammelt beim Kauf von Bitcoin keine Daten. Die eingehenden Gelder werden wie eine reguläre Transaktion behandelt. Pocket muss einige personenbezogene Daten sammeln, um zu agieren. Ihre Datenschutzrichtlinie erklärt im Detail, wie diese Daten verwendet werden.",
      title: "Datenschutz"
    },
    kyc: {
      link: "Pocket-FAQ lesen",
      p1: "Pocket versucht, KYC auf ein Minimum zu beschränken. Für Einkäufe unter 950 EUR (1000 CHF) pro Tag sind keine zusätzlichen Dokumente erforderlich. Für Käufe über diesem Betrag musst du einen Anruf bei Pocket vereinbaren, um den erforderlichen KYC/AML-Prozess abzuschließen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Du kannst Bitcoin sofort mit Pocket per SEPA-Überweisung kaufen. Die Gebühr beträgt 1,5 % und die Bitcoin werden so schnell wie möglich nach Eingang der Banküberweisung bei Pocket (normalerweise am selben Tag) auf deiner BitBox hinterlegt.",
      p2: "Bitte beachte, dass die Wechselkurse von Pocket von denen in der BitBoxApp abweichen können, was zu leicht unterschiedlichen Beträgen führen kann.",
      title: "Zahlungsmethoden und Gebühren"
    },
    previousTransactions: "Der Transaktionsverlauf dieses Kontos ist nicht leer. Durch die gemeinsame Nutzung dieses Kontos werden alle vergangenen und zukünftigen Transaktionen für Pocket sichtbar. Dennoch fortfahren?",
    security: {
      link: "BitBox02 Bedrohungsmodell",
      p1: "Wenn du Bitcoin über Pocket kaufst, verwendest du einen externen Dienst. Dieser Dienst liegt außerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hängt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgeführt wird. Wir arbeiten jedoch zusammen, um die Sicherheit zu verbessern, indem wir einen Zwei-Faktor-Authentifizierungsmechanismus verwenden, um deine Empfangs-Adresse zu überprüfen.",
      title: "Sicherheitsmodell"
    },
    usedAddress: "Die Adresse {{address}} wurde bereits verwendet. Bitte beginne erneut mit einer neuen Adresse.",
    verifyBitBox02: "Bitte vergewissere dich, dass die Adresse, die du per E-Mail erhalten hast, mit der auf deiner Bitbox angezeigten übereinstimmt. Wenn möglich, solltest du die E-Mail zur besseren Sicherheit auf einem zweiten Gerät öffnen.",
    welcome: {
      p1: "Wir arbeiten mit Pocket zusammen, um dir eine nahtlose Möglichkeit zu bieten, Bitcoins direkt in der BitBoxApp zu kaufen. Es sind nur ein paar Klicks.",
      p2: "Pocket ist eine schweizer Plattform, mit der man fast in ganz Europa schnell und einfach Bitcoin kaufen kann (überall dort, wo SEPA-Banküberweisungen unterstützt werden).",
      p3: "Mit Pocket kannst du auch Sparpläne über Daueraufträge betreiben, sodass du mit Leichtigkeit DCA (Dollar-Cost-Average) durchführen kannst.",
      title: "Willkommen in deinem One-Stop-Shop für den Kauf von Bitcoin"
    }
  },
  title: "{{name}} kaufen"
}, changePin$g = {
  newTitle: "Neues Gerätepasswort",
  oldLabel: "Aktuelles Gerätepasswort"
}, chart$c = {
  dataMissing: "Historische Daten werden gesammelt... gleich fertig.",
  dataOldTimestamp: "Historische Wechselkurse werden aktualisiert. Das Diagramm zeigt nach {{time}} keine Daten mehr an.",
  dataUpdating: "Daten aktualisieren…",
  filter: {
    all: "Alles",
    month: "Monat",
    week: "Woche",
    year: "Jahr"
  }
}, checkSDcard$g = "Micro-SD-Karte wird überprüft", clickHere$g = "Hier klicken.", confirm$i = {
  abortInfo: "Tippe zum ",
  abortInfoRedText: "abbrechen",
  approveInfo: "4 Sekunden lang halten um zu ",
  approveInfoGreenText: "bestätigen",
  info: "Fahre auf deiner BitBox fort.",
  infoWhenPaired: "Zuerst auf deinem gepaarten Mobiltelefon und dann auf deiner BitBox"
}, confirmOnDevice$g = "Bitte bestätige auf deinem Gerät.", connectKeystore$9 = {
  promptNoName: "Bitte verbinde deine BitBox02 um fortzufahren",
  promptWithName: 'Bitte verbinde deine BitBox02 mit dem Namen „{{name}}" um fortzufahren'
}, darkmode$a = {
  toggle: "Dark mode"
}, device$g = {
  appUpradeRequired: "Deine BitBox ist mit dieser Desktopanwendung nicht kompatibel. Bitte lade die neueste Version herunter und installiere diese..",
  keystoreConnected: "Verbundenes Wallet"
}, deviceLock$g = {
  button: "Zwei-Faktor-Autorisierung (2FA) aktivieren",
  condition1: "Hast du ein Backup?",
  condition2: "Funktioniert die Verifikation auf deinem Smartphone?",
  condition3: 'Wenn du 2FA aktivierst wird "Backups verwalten", "Versteckte Wallet erstellen" und "Mit Smartphone App" koppeln deaktiviert. Um 2FA zu deaktivieren muss das Gerät auf Werkseinstellungen zurück gesetzt werden.   ',
  confirm: `Zwei-Faktor Authentifizierung (2FA) aktivieren
`,
  title: "Zwei-Faktor-Autorisierung (2FA) aktivieren"
}, deviceSettings$g = {
  backups: {
    manageBackups: {
      description: "Erstelle oder überprüfe das MicroSD-Karten-Backup."
    },
    showRecoveryWords: {
      description: "Zeige und überprüfe die Wiederherstellungswörter."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "Die BitBoxApp prüft, ob dein Gerät authentisch ist."
    },
    deviceName: {
      description: "Ändere den Namen deines Geräts."
    },
    rootFingerprint: {
      description: "Der Root-Fingerabdruck ist eine eindeutige Kennung für das aktuell verwendete Wallet. Es kann dir helfen, zwischen verschiedenen Wallets zu unterscheiden, falls du Passphrasen verwendest."
    },
    securechip: {
      description: "Das Modell des Secure-Chips."
    },
    title: "Geräteinformationen"
  },
  expert: {
    factoryReset: {
      description: "Setze dein Gerät auf die Werkseinstellungen zurück. Dadurch wird das Wallet auf deiner BitBox02 gelöscht!",
      title: "Auf Werkseinstellungen zurücksetzen"
    },
    goToStartupSettings: {
      description: "Den Bootloader der BitBox02 starten. Dort kannst du den Firmware-Hash aktivieren."
    },
    passphrase: {
      description: "Aktiviere oder deaktiviere die Passphrasen-Funktion.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Verfügbare Version"
    },
    title: "Firmware",
    upToDate: "Dein Gerät ist auf dem aktuellen Stand  ",
    upgradeAvailable: "Neues Upgrade verfügbar",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "Echtheitscheck fehlgeschlagen",
      label: "Echtheitsprüfung",
      true: "Deine BitBox02 ist echt"
    },
    sdcard: {
      false: "Nicht eingesteckt",
      label: "microSD Karte",
      true: "Eingesteckt"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: `Geräteinformationen werden abgerufen...

`,
  pairing: {
    lock: {
      false: "Deaktiviert",
      label: "Zwei-Faktor Autorisierung (2FA)",
      true: "Eingeschaltet"
    },
    mobile: {
      false: "Geschlossen",
      label: "Smartphone App",
      true: "Offen"
    },
    status: {
      false: "Nicht gekoppelt",
      label: "Status",
      true: "Gekoppelt"
    },
    title: "Zwei-Faktor Autorisierung (2FA)"
  },
  secrets: {
    manageBackups: "Backups verwalten",
    title: "Sicherheit"
  }
}, deviceTampered$g = `Falls deine BitBox mit einem Wiederherstellungspasswort geliefert wurde, beende das Setup SOFORT und kontaktiere den Support. 
SHIFT versendet niemals BitBoxen, die schon ein Passwort haben und wird nie Passwortempfehlungen aussprechen. 
Benutze diese BitBox auf keinen Fall !`, dialog$h = {
  cancel: "Abbrechen",
  confirm: "Bestätigen",
  confirmTitle: "Bestätigung"
}, error$c = {
  accountAlreadyExists: "Dieses Konto existiert bereits.",
  accountLimitReached: "Konto kann nicht hinzugefügt werden. Die maximale Kontenanzahl für diese Währung wurde erreicht.",
  aoppCallback: "Beim Übermitteln der Adresse an {{host}} ist ein Fehler aufgetreten.",
  aoppInvalidRequest: "Ungültige Anfrage.",
  aoppNoAccounts: "Es sind keine Konten verfügbar.",
  aoppSigningAborted: "Adressinhaberanfrage wurde abgebrochen.",
  aoppUnknown: "Ein unbekannter Fehler ist aufgetreten.",
  aoppUnsupportedAsset: "Diese Kryptowährung wird nicht unterstützt.",
  aoppUnsupportedFormat: "Es sind keine Konten verfügbar, die das angeforderte Adressformat unterstützen.",
  aoppUnsupportedKeystore: "Das verbundene Gerät kann keine Nachrichten für diese Kryptowährung signieren.",
  aoppVersion: "Unbekannte Version.",
  wrongKeystore: "Falsches Wallet verbunden. Bitte verbinde das richtige Gerät, zu dem diese Konto gehört.",
  wrongKeystore2: "Falls du ein optionale Passphrase nutzt, stelle sicher, dass du die richtige Passphrase für dieses Konto eingegeben hast."
}, fiat$i = {
  default: "Standard",
  setDefault: `{{code}} als Standard speichern
`,
  title: "Währungen"
}, footer$i = {
  appVersion: "App Version:"
}, generic$c = {
  enabled_false: "Deaktiviert",
  enabled_true: "Aktiviert"
}, genericError$g = "Ein Fehler ist aufgetreten. Falls du Probleme bemerkst, starte die Applikation bitte neu.", goal$g = {
  buttons: {
    create: "Neue Wallet erstellen",
    restore: "Wallet von Backup wiederherstellen "
  },
  paragraph: "Bitte wähle eine der folgenden Optionen:",
  step: {
    1: {
      title: "Sicherheitsinformationen"
    },
    2: {
      description: "Passwort",
      title: "Gerät"
    },
    "3-create": {
      description: "Neue Wallet erstellen",
      title: "Wallet"
    },
    "3-restore": {
      description: "von einem Backup",
      title: "Wiederherstellen"
    },
    "4-create": {
      title: "Zusammenfassung"
    },
    "4-restore": {
      title: "Zusammenfassung"
    }
  }
}, guide$h = {
  accountDescription: {
    text: "Deine Kontoübersicht zeigt deinen Kontostand und deine Transaktionen an. Stöbere durch diesen Guide um mehr über die verschiedenen Kontoarten zu erfahren. ",
    title: "Was wird mir auf dieser Seite angezeigt?"
  },
  accountFiat: {
    text: "Ja, du kannst auf das Währungssymbol klicken, um zwischen den verschiedenen Währungen zu wechseln. Die verfügbaren Währungen kannst du in den Einstellungen anpassen.",
    title: "Können auch andere Wechselkurse angezeigt werden?"
  },
  accountIncomingBalance: {
    text: "Eingehend summiert alle eingehenden Transaktionen, die noch nicht bestätigt sind. ",
    title: 'Was bedeutet "Eingehend"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: `Jeder xpub ist an den angezeigten "Typ" gebunden: Entweder "Native SegWit (bech32)", "Wrapped segwit" oder "Taproot". Dies sind Skripttypen, die von {{coinName}} verwendet werden. Die BitBoxApp kombiniert sie und unterstützt mehrere Skripttypen im selben Konto. Da jeder Skripttyp einen anderen xpub verwendet, gibt es mehrere xpubs pro Konto.

Wenn du nur auf den Standardadressen empfängst, benötigst du nur den "bech32" xpub. Wenn du jedoch auch Coins auf "kompatible Adresse" erhältst, werden diese auf dem xpub "wrapped SegWit" angezeigt.`,
      title: "Warum gibt es mehrere xpubs?"
    },
    privacy: {
      text: `Für dieses Konto zeigt der erweiterte öffentliche Schlüssel die gesamte Transaktionshistorie, deinen Kontostand und alle zukünftigen Transaktionen an. Aber der xpub erlaubt niemandem, deine Coins auszugeben.

Wenn du jemandem ein xpub gibst, solltest du dir bewusst sein, dass diese Person oder Firma alle anderen Transaktionen desselben Kontos sehen kann. Daher ist es eine gute Idee, dieses Konto nur für diesen Zweck zu verwenden und andere Coins in anderen Konten zu halten.`,
      title: "Muss ich mein xpub geheim halten?"
    },
    verify: {
      text: "Ja, es ist immer eine gute Idee, deinen xpub zu überprüfen. Wenn jemand anderes Empfangsadressen von diesem xpub generiert, um dir Coins zu senden, ist dies besonders wichtig. Du musst ihn auf deiner BitBox überprüfen, um sicherzustellen, dass dieser xpub dir gehört. Andernfalls könnten alle Coins an die falschen Adressen gehen.",
      title: "Muss ich den xpub auf dem Gerät überprüfen?"
    },
    xpub: {
      text: `Ein erweiterter öffentlicher Schlüssel (xpub) ist ein Stammschlüssel, von dem alle Empfängeradressen eines Kontos abgeleitet werden.

Er wird hier für die erweiterte Nutzung und die Interoperabilität mit Watch-Only-Wallets wie Electrum oder Sentinel bereitgestellt. Wenn du auf verschiedene Adresstypen empfängst, importiere bitte alle verschiedenen xpub-Formate in die Watch-only-Wallet, damit du alle deine Coins sehen kannst.

Bitte beachte, dass Wallets von Drittanbietern Taproot xpubs möglicherweise noch nicht unterstützen.
`,
      title: "Was ist ein erweiterter Public Key?"
    }
  },
  accountRates: {
    text: "Die Wechselkurse werden minütlich von CoinGecko aktualisiert.",
    title: "Welche Wechselkurse werden benutzt?"
  },
  accountReload: {
    text: "Das ist nicht nötig. Alle Transaktionsinformationen werden automatisch aktualisiert. ",
    title: "Wie kann ich die Transaktionshistorie erneut laden?"
  },
  accountSendDisabled: {
    text: 'Der "Senden" Knopf wird aktiviert, wenn dein Guthaben größer als Null ist.',
    title: "Warum kann ich keine {{unit}} senden?"
  },
  accountSummaryAmount: {
    text: `Der Gesamtbetrag ist die Summe aller deiner Kryptokonten. Die Wechselkurse werden von coingecko.com abgerufen.

Hinweis: Wenn du MyEtherWallet für Token verwendest, die in der BitBoxApp nicht unterstützt werden, dann sind diese nicht in dem angezeigten Gesamtbetrag einberechnet.`,
    title: "Wie berechnet sich der Gesamtbetrag?"
  },
  accountSummaryDescription: {
    text: "Hier kannst du die Entwicklung deines Portfolios im Laufe der Zeit sehen. Eine Übersicht über deine einzelnen Krypto-Konten wird unter dem Diagramm angezeigt.",
    title: "Was kann ich auf dieser Seite sehen?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtuelle Größe: Wird zur Ermittlung der Netzwerkgebühr verwendet. Du hast erfolgreich Gebühren gespart, wenn sie kleiner als die Transaktion sind.
Größe: Aktuelle Transaktionsgröße in Bytes nach der Serialisierung gemäß der zugrunde liegenden Blockchain.
Gewicht: Mit Segwit eingeführt, ist dies eine neue Metrik zur Bewertung von Transaktions- und Blockgrößen. Jedes Segwit Byte zählt als eins, alles andere als vier "Gewichtseinheiten". Statt eines Megabytes, beträgt die Blockgrößenbegrenzung nun vier Millionen "Gewichtseinheiten".`,
    title: "Was hat es mit den Bitcoin-spezifischen Transaktionsdetails  auf sich?"
  },
  accountTransactionAttributesGeneric: {
    text: `Bestätigungen: Nachdem du deine Transaktion gesendet hast ist diese zuerst unbestätigt. Du musst warten, bis sie von einem Miner in einen Block aufgenommen wird. Dann hat deine Transaktion die erste Bestätigung. Jeder nachfolgende Block fügt deiner Transaktion eine weitere Bestätigung hinzu. Meist sehen Händler und andere Netzwerkakteure Transaktionen erst mit 3 bis 6 Bestätigungen als erledigt.
Transaktions-ID: Eine eindeutige Identifikationsnummer, die zum Nachschlagen einer Transaktion in einem Blockexplorer verwendet werden kann.
Gebühr: Miner erhalten eine Transaktionsgebühr als Anreiz, Transaktionen in die von ihnen erzeugten Blöcke aufzunehmen. Um mehr zu erfahren, klicke auf  "Senden".`,
    title: "Welche Informationen werden in den Transaktionsdetails angezeigt?"
  },
  accountTransactionConfirmation: {
    text: "Dies ist eine Transaktionen die ins Netzwerk geschickt wurde und darauf wartet bestätigt zu werden.",
    title: "Was ist eine ausstehende Transaktion?"
  },
  accountTransactionLabel: {
    text: "Es ist die Adresse an die du Coins erhalten oder geschickt hast.",
    title: "Welche Adresse wird bei jeder Transaktion angezeigt?"
  },
  accountTransactionTime: {
    text: "Der Zeitpunkt, zu dem die Transaktion in der Blockchain bestätigt wurde.",
    title: "Welche Zeit wird angezeigt?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin und Litecoin können eine beliebige Anzahl an Konten haben. Nach fünf Konten kannst du nur dann ein weiteres Konto hinzufügen, wenn das vorherige Konto verwendet wurde.
Andere Coins können maximal fünf Konten haben.`,
      title: "Wie viele Konten kann ich erstellen?"
    },
    howtoAddTokens: {
      text: 'ERC-20 Token sind an ein bestimmtes Ethereum-Konto gebunden. Um einen Token zu aktivieren oder zu deaktivieren, gehe zu "Konten verwalten", klicke auf das Ethereum-Konto und schalte den gewünschten Token ein oder aus.',
      title: "Wie kann ich zusätzliche Token hinzufügen?"
    },
    moveFunds: {
      text: "Ja. Da Konten jedoch eigenständig sind, müssen Coins mit einer reguläre Transaktion zwischen den Konten verschoben werden.",
      title: "Kann ich Geld zwischen Konten verschieben?"
    },
    recoverAccounts: {
      text: "Ja. Die BitBoxApp erstellt Konten nach bewährten Standards, die mit den meisten Krypto-Wallets kompatibel sind.",
      title: "Kann ich meine Konten in anderen Wallets wiederherstellen?"
    },
    whatAreAccounts: {
      text: "Deine Wallet kann mehrere Konten derselben Währung verwalten. Konten machen es einfach, Coins separiert zu halten.",
      title: "Was sind Konten?"
    },
    whatIsRememberWallet: {
      text: `Durch die Aktivierung von „Wallet merken“ kannst du die Konten von diesem Wallet in der BitBoxApp sehen, auch wenn die BitBox02 nicht verbunden ist. So kannst du deinen Kontostand und dein Portfolio jederzeit überprüfen. Zum Senden oder Empfangen von Coins muss die BitBox02 jedoch eingesteckt und entsperrt werden.

Wenn du „Wallet merken“ deaktivierst, musst du die BitBox02 (oder Passphrase-Wallet) verbinden, um diese Konten in der BitBoxApp zu sehen.`,
      title: "Was passiert, wenn ich „Wallet merken“ aktiviere/deaktiviere?"
    },
    whyIsThisUseful: {
      text: 'Separate Konten eignen sich hervorragend für die Verwaltung von Coins für verschiedene Personen oder Zwecke. Du kannst auch den "erweiterten öffentlichen Schlüssel" (extended public key) eines Kontos freigeben, ohne etwas über deine anderen Konten preiszugeben. Auf diese Weise kannst du wiederholt Geld erhalten, ohne Adressen wiederzuverwenden, z. B. um deinen Lohn zu erhalten oder um regelmäßig Krypto zu kaufen.',
      title: "Warum ist das nützlich?"
    }
  },
  appendix: {
    link: "Kontaktiere uns!",
    text: "Du hast Fragen?"
  },
  backups: {
    check: {
      text: 'Mit "Check Backup" kannst du überprüfen, ob du über ein gültiges Backup für deine aktuelle Wallet verfügst. Es kann auch verwendet werden, um zu überprüfen, ob du das korrekte Wiederherstellungspasswort kennst.',
      title: 'Was bedeutet "Check Backup"?'
    },
    encrypt: {
      text: "Nein, aber dein Wiederherstellungspasswort wird benötigt, um deine Wallet aus dem gespeicherten Seed zu erzeugen.",
      title: "Kann ich mein Backup verschlüsseln?"
    },
    howOften: {
      text: `Das Backup wird automatisch erstellt, wenn eine neue Wallet erstellt wird. Du musst nur dann ein neues Backup erstellen, wenn deine microSD-Karte verloren ist, beschädigt wurde oder wenn du dein Backup auf mehreren microSD Karten speichern willst.
Du musst nach der Transaktionsaktivität keine neuen Backups erstellen. Alle deine Transaktionsdaten können durch ein einzelnes Backup, das automatisch für dich erstellt wurde, wiederhergestellt werden.`,
      title: "Wie oft muss ich ein Backup erstellen?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie des Seed auf einer microSD-Karte. Der Seed zusammen mit deinem Wiederherstellungspasswort stellen dein Wallet wieder her.",
      title: "Was ist ein Backup?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Backup überprüfen" checkt, dass sich auf deiner microSD Karte ein gütiges Backup zu deiner aktuell verwendeten Wallet befindet.',
      title: 'Was bedeutet "Backup überprüfen"?'
    },
    encrypt: {
      text: 'Nein. Bitte bewahre deine microSD-Karte sicher auf, da sie den unverschlüsseltes Seed enthält, der zur Wiederherstellung deiner Wallet benötigt wird. Falls du dein Backup mit einem Passwort schützen willst, aktiviere die "Optionale Passphrase" in den Geräteeinstellungen.',
      title: "Kann ich das Backup verschlüsseln?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie deines Seeds auf deiner microSD Karte.",
      title: "Was ist das Backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Wenn 2FA aktiviert ist, müssen alle Transaktionen auf dem gekoppelten Mobiltelefon genehmigt werden, um Coins zu versenden. Unter der Haube: Eine verschlüsselte einmalige Nummer wird an die App gesendet, dort wird sie entschlüsselt und beim Drücken der Schaltfläche "Akzeptieren" zur BitBox zurückgegeben. Diese Kommunikation mit der BitBox erfolgt über den Kanal zwischen dem Mobiltelefon und dieser Desktop-App, der während des Pairings eingerichtet wurde.  

Stelle sicher, dass du ein Backup deiner Wallet erstellst und die App verbindest, bevor du 2FA aktivierst. Nach der Aktivierung werden der Mikro-SD Kartenslot und das Mobile-App-Pairing deaktiviert. Du kannst es nur erneut aktivieren, indem du die BitBox zurücksetzt, wodurch das Gerät gelöscht wird.`,
      title: "Wie funktioniert die Zwei-Faktor-Autorisierung (2FA)?"
    },
    disable2FA: {
      text: `Um 2FA zu deaktivieren, musst du deine BitBox zurücksetzen und anschließend deine Wallet von deinem Backup wiederherstellen. Stelle sicher, dass du deine MicroSD-Karte mit deinem Backup hast und du das Wiederherstellungspasswort kennst. Dann drücke 'Reset Device'. Lege ein neues Gerätekennwort fest und wähle "Backup wiederherstellen". Wähle Backup aus und klicke auf "Wiederherstellen". Dann gib dein Wiederherstellungskennwort ein, das du beim Erstellen der Wallet verwendet hast.`,
      title: "Wie schalte ich die Zwei-Faktor-Autorisierung (2FA) aus?"
    },
    ejectBitbox: {
      text: "Du kannst deine BitBox einfach aus dem Computer ziehen ohne sie vorher auszuwerfen.",
      title: "Wie werfe ich meine BitBox aus?"
    },
    ejectSD: {
      text: "Du kannst die Micro SD Karte jederzeit aus der BitBox entfernen, solange du nicht dabei bist, ein Backup zu erstellen oder zu überprüfen",
      title: "Wie kann ich die Micro-SD-Karte auswerfen?"
    },
    hiddenWallet: {
      text: "Es ist eine sekundäre Wallet, auf der selben BitBox, das mit einem anderen Passwort geschützt ist. Dies erlaubt dir, einem Erpresser ein anderes Wallet zu öffnen, in welchem sich nur eine geringe Menge Coins befindet. Info: Für beide Wallets, normal und versteckt, wird der selbe Seed verwendet, somit muss kein weiteres Backup erzeugt werden",
      title: "Was ist eine versteckte Wallet?"
    },
    legacyHiddenWallet: {
      text: "Klicke zunächst auf den Knopf unten (dazu muss die BitBox mit dem Hauptgerätekennwort entsperrt sein und 2FA deaktiviert sein), schließe dann deine Bitbox an und entsperre diese mit deinem versteckten Gerätekennwort.",
      title: "Wie greife ich auf die versteckte Wallet des Legacy Kontos zu?"
    },
    pairing: {
      text: "Nachdem du unsere mobile App für iOS oder Android heruntergeladen hast, scanne den angezeigten QR-Code. Dadurch wird ein sicherer Kanal zwischen der mobilen App und dieser Anwendung eingerichtet. Befolge nach dem Scannen die Anweisungen in der Smartphone App.",
      title: "So, koppelst du dein Telefon sicher mit der BitBox"
    }
  },
  cointracking: {
    text: 'Klicke auf "Exportieren" und öffne den Download-Ordner. Dort findest du die exportierte CSV Datei. Klicke dann auf den untenstehenden Link, lade deine BitBox-CSV-Datei hoch und importiere die Daten, um sie für deinen CoinTracking-Portfoliomanager zu verwenden und deine Steuerberichte zu erstellen.',
    title: "Wie importiere ich meine Transaktionen in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lese mehr über den Echtheitscheck"
      },
      text: "Die BitBoxApp führt eine Überprüfung der BitBox02 durch, um festzustellen, ob das Gerät echt ist. Die Prüfung wird lokal durchgeführt und stellt keine Verbindung zu unseren Servern her.",
      title: "Wie funktioniert die Echtheitsprüfung?"
    },
    name: {
      text: "Dies ist der Name deiner Wallet und deines Backups. Der Name wird für zukünftige Backups verwendet und kann dazu dienen, verschiedene Wallets zu unterscheiden. Er kann jederzeit geändert werden, aber beachte, dass Backups, die vor der Änderung erstellt wurden, weiterhin den vorherigen Namen verwenden.",
      title: "Wofür wird der BitBox02-Name verwendet?"
    },
    "secure-chip": {
      link: {
        text: "Lese mehr über den Secure-Chip"
      },
      text: "Diese Information zeigt die Modellnummer des Sicherheitschips. Der aktuellste Chip ist der ATECC608B mit verbesserten Sicherheitsfunktionen im Vergleich zu älteren Modellen.",
      title: "Warum das Modell des Secure-Chips anzeigen?"
    }
  },
  receive: {
    address: {
      text: "Du kannst die Adresse an andere weitergeben, damit sie dir Coins schicken können. Achte darauf, dass sie an die richtige Adresse schicken.",
      title: "Was mache ich mit einer Adresse?"
    },
    addressChange: {
      text: "Sobald eine Adresse für eine Transaktion benutzt wurde, wird eine neue Adresse zu der Liste hinzugefügt um die Alte zu ersetzen. Es werden immer 20 ungenutzte Adressen angezeigt. ",
      title: "Wann ändern sich die Adressen?"
    },
    addressFormats: {
      text: "Standardmäßig ist der Adresstyp Native Segwit. Dieser Adresstyp wird von vielen anderen Wallets/Börsen akzeptiert und bietet dir die besten Gebührensätze für alltägliche Transaktionen. Du kannst aber auch an Taproot (nur Bitcoin) senden, den neuesten Adresstyp, der aber noch nicht überall unterstützt wird. Wenn du Probleme hast, an Native Segwit (den Standard-Adresstyp) zu senden, kannst du auch auf den älteren Wrapped Segwit-Adresstyp umsteigen, der möglicherweise mit mehr Wallets/Börsen kompatibel ist.",
      title: "Wann sollte ich den Adresstyp ändern?"
    },
    howVerify: {
      text: `BitBox01: Klicke auf das BitBox-Symbol in der Seitenleiste links und siehe dir den Abschnitt "Zwei-Faktor Autorisierung" an. Die Anleitung wird aktualisiert und du kannst von dort aus den Anweisungen folgen.

BitBox02: Dank des eingebauten Displays kannst du die Adresse direkt auf dem Gerät während des Send-/Empfangsprozesses verifizieren. `,
      title: "Wie kann ich die Adresse sicher verifizieren?"
    },
    plugout: {
      text: "Nein, sobald du die Adresse auf dem Display bestätigt und kopiert hast, musst du deine BitBox nicht mehr eingesteckt haben. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox während des Empfangs eingesteckt lassen?"
    },
    why20: {
      text: 'Die BitBoxApp generiert automatisch eine gewisse Anzahl an Adressen, die von deinem Seed abgeleitet werden. Sie überprüft dann, ob diese Adressen schon Coins erhalten haben. Die App kann theoretisch eine nahezu unbegrenzte Anzahl von Adressen generieren, wodurch es Jahre dauern würde, bis dein Kontostand ermittelt ist. Um diese Suche einzuschränken stoppt die App diesen Prozess, nachdem sie 20 Adressen generiert hat, die noch nie Coins erhalten haben. Dies wird "gap-limit" genannt und 20 ist ein der de-facto-Standard. Deswegen siehst du immer nur 20 Adressen, aus denen du auswählen kannst. ',
      title: "Warum werden nur 20 Adressen angezeigt?"
    },
    whyMany: {
      text: "Aus Gründen des Datenschutzes und der Sicherheit solltest du niemals dieselbe Empfangsadresse zweimal verwenden. Klicke auf 'Weiter', um eine neue Adresse zu erhalten. Du kannst bis zu 20 Adressen gleichzeitig generieren. Alle Adressen werden von deinem Backup abgeleitet. (Stell dir Adressen wie Rechnungsnummern vor.)",
      title: "Warum gibt es mehrere Adressen?"
    },
    whyVerify: {
      text: `Einer der Gründe für den Kauf einer Hardwarewallet, ist dass du deinem Computer aufgrund der großen Angriffsfläche nicht vertrauen solltest. Daher solltest du nicht darauf vertrauen, dass dein Computer authentische Adressen generiert und anzeigt. 
Bitbox01: Mit dem Knopf zur sicheren Überprüfung der Adresse sendet die BitBox01 die Adresse an ein gekoppeltes Mobiltelefon, auf welchem du die Adresse  überprüfen kannst. 
BitBox02: Die BitBox02 hat ein eingebautes Display, auf dem die Adresse sicher angezeigt werden kann. `,
      title: "Warum sollte ich die Adresse verifizieren?"
    }
  },
  send: {
    change: {
      text: "Der Change wird an eine Taproot-Adresse gesendet, wenn du mindestens eine Taproot UTXO besitzt. Wenn du Coin-Control verwendest, wird der Change an eine Taproot-Adresse gesendet, wenn mindestens eine der ausgewählten UTXOs eine Taproot-UTXO ist. In allen anderen Fällen wird der Change an eine Native-Segwit-Adresse gesendet. ",
      title: "Wie wird der Change-Output bestimmt?"
    },
    fee: {
      text: `Die Gebühr basiert auf der Transaktionsdatengröße und nicht auf dem Transaktionsbetrag. Die Gebühren werden durch den Gebührenschätzungsalgorithmus von Bitcoin Core für jede von dir gewählte Netzwerkpriorität berechnet. Sie werden explizit angezeigt, wenn du einen anderen Wert als die unten stehenden Ziele haben.
Economy: 24 Blöcke (ca. 4 Stunden für Bitcoin, 1 Stunde für Litecoin)
Niedrig: 12 Blöcke (etwa 2 Stunden für Bitcoin, 30 Minuten für Litecoin)
Normal: 6 Blöcke (ca. 1 Stunde für Bitcoin, 15 Minuten für Litecoin)
Hoch: 2 Blöcke (ca. 20 Minuten für Bitcoin, 5 Minuten für Litecoin)
(Ein Block benötigt durchschnittlich zehn Minuten für Bitcoin (2,5 Minuten für Litecoin)), und die Netzwerklast kann in den oben genannten Zeiträumen erheblich variieren.)`,
      title: "Wie wird die Gebühr ermittelt?"
    },
    plugout: {
      text: "Nein, nachdem du eine Transaktion durchgeführt hast, musst du deine BitBox nicht eingesteckt lassen. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox beim Senden eingesteckt lassen?"
    },
    priority: {
      text: "Je höher die Gebühr ist, die du bereit bist zu zahlen, desto schneller wird deine Transaktion vom Netzwerk bestätigt. ",
      title: "Was ist Netzwerk Priorität?"
    },
    revert: {
      text: `Sobald eine Transaktion signiert und gesendet (d.h. An das Netzwerk gesendet) wurde, kann sie nicht mehr rückgängig gemacht werden. Überprüfe die Transaktionen (einschließlich der Gebühr) deswegen, bevor du die Transaktion bestätigst!
Wenn du den Empfänger kennst und dieser bereit ist, denselben Betrag (abzüglich der Transaktionsgebühren) an dich zurückzuschicken, kannst du ihm eine neue Empfängeradresse senden.`,
      title: "Kann ich eine Transaktion rückgängig machen?"
    },
    whyFee: {
      text: `Transaktionen stehen im Wettbewerb, um von einem Miner bestätigt zu werden. Die Miner wählen Transaktionen, die in die Blockchain aufgenommen werden sollen, basierend auf ihrer Gebühr aus. Miner bevorzugen Transaktionen mit höheren Gebühren. Deswegen wird eine Transaktion die bereit ist, eine höhere Gebühr zu bezahlen auch schneller in einem Block aufgenommen. 
Da es keinen Mittelsmann gibt, der eine Regelung, wie eine Stimme pro Person erzwingen kann, stimmen die Miner über Transaktionen ab, indem sie eine kostspielige Ressource, wie Rechenleistung opfern. Als Belohnung dafür erhalten sie neu erstellte Coins und die Gebühren der Transaktionen in dem von ihnen "gemineten" Block (english: to mine a Block) .`,
      title: "Warum gibt es eine Netzwerk Gebühr?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Wenn du nur dann eine Verbindung zu deinem Full Node herstellen möchtest, wenn du dich im selben Netzwerk befindest (z. B. in deinem Heim-WLAN), ist die Verwendung einer regulären Netzwerkkommunikation ausreichend.
In diesem Fall ist es ratsam, dass dein Electrum-Server ein TLS-Zertifikat zum Verschlüsseln der Kommunikation bereitstellt.
Wenn du von überall aus eine Verbindung zu deinem Full Node herstellen möchtest, ist die Verwendung von Tor die bessere Option. In diesem Fall ist kein TLS-Zertifikat erforderlich.`,
      title: "Soll ich Clearnet TCP, TLS oder Tor verwenden?"
    },
    instructions: {
      link: {
        text: "Anleitung zum Verbinden deines Full Nodes"
      },
      text: "Für eine vollständiges Anleitung, besuche bitte unseren Guide:",
      title: "Wie verbinde ich meine BitBoxApp mit meinem Full Node?"
    },
    options: {
      text: `Es gibt mehrere Möglichkeiten, einen eigenen Full Node zu betreiben, z. B. ein fertiges Gerät zu kaufen, einen eigenen zu bauen oder Bitcoin Core auszuführen.
Wenn du deine BitBoxApp mit deinem Full Node verbinden möchtest, stelle sicher, dass dieser einen Electrum-Server bereitstellt. Dies ist ein spezielles Programm, mit dem eine Wallet-App mit deinem Full Node kommunizieren kann.
Unterstützte Optionen sind Electrs, Electrum Personal Server (EPS) oder Bitcoin Wallet Tracker (BTW).`,
      title: "Welche Optionen gibt es, um einen Full Node zu betreiben?"
    },
    tor: {
      text: `Tor steht für "The Onion Router", eine kostenlose Open-Source-Software, die viele Datenschutzvorteile bietet und besonders bei der Verwendung von Bitcoin nützlich ist.
Wenn du über Tor eine Verbindung zu deinem Full Node herstellen möchtest, stelle sicher, dass Tor auf deinem Computer installiert ist, und aktiviere dann den Tor-Proxy in den BitBoxApp-Einstellungen.
Auf den meisten Betriebssystemen gibt es zwei Möglichkeiten, Tor auszuführen:
1. Tor Browser: Lade den Tor Browser herunter und öffne ihn. Dadurch kann die BitBoxApp eine Verbindung zum Tor-Netzwerk herstellen, indem Port 9150 in den Tor-Proxy-Einstellungen festgelegt wird.
2. Tor-Hintergrunddienst: Installiere den Tor-Daemon, der immer im Hintergrund ausgeführt wird. Die BitBoxApp kann dann eine Verbindung herstellen, indem Port 9050 in den Tor-Proxy-Einstellungen festgelegt wird.`,
      title: "Was ist Tor, Tor-Proxy und welchen Port soll ich verwenden?"
    },
    what: {
      text: "Es ist möglich, deine Wallet mit einem eigenen Fullnode zu betreiben, anstatt den Shift-Server zu verwenden.",
      title: "Was ist das?"
    },
    why: {
      text: `Einen eigenen Full Node zu betreiben ist nicht erforderlich. Er verbessert jedoch deine Privatsphäre und verringert die Notwendigkeit, anderen Netzwerkteilnehmern zu vertrauen.
Zum einen erlaubt er dir Bitcoin privater verwenden, da die BitBoxApp dann keine Verbindung zu unseren Servern herstellt, um deinen Transaktionsverlauf abzurufen. Stattdessen werden diese Informationen von deinem eigenen Full Node abgerufen.
Des Weiteren, verifiziert dein Full Node alle Transaktionen selbst, wodurch sichergestellt wird, dass die Konsensregeln eingehalten werden. `,
      title: "Warum sollte ich meinen eigenen Full Node betreiben?"
    }
  },
  settings: {
    sats: {
      text: 'Ein Satoshi (kurz "sat") ist die kleinste Einheit eines Bitcoins. Ein Satoshi ist ein Hundertmillionstel eines Bitcoins (0,00000001 BTC). Benannt ist er nach dem Erfinder von Bitcoin, Satoshi Nakamoto.',
      title: "Was ist ein Satoshi?"
    },
    servers: {
      text: `Diese App kommuniziert mit Servern von Shift Crypto, um nach Updates zu suchen, Transaktionen zu laden und Informationen an verbundene Smartphone Apps zu senden.
Außerdem werden die neuesten Wechselkurse von CoinGecko abgerufen. (Die Conversions werden lokal berechnet, es werden keine Beträge von dir übertragen.)
Info: Für Ethereum und ERC-20 tokens verwenden wir die Etherscan.io APIs.`,
      title: "Mit welchen Servern kommuniziert die Applikation?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Guide schließen",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Bewege auf dem Desktop den Mauszeiger über das Diagramm. Halte auf Mobilgeräten deinen Finger auf dem Diagramm und ziehe ihn horizontal.",
    title: "Wie kann man historische Werte auf dem Chart sehen?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Du musst das Gerät zurücksetzen und die Wallet mithilfe des Wiederherstellungskennworts aus deinem Backup wiederherstellen.",
      title: "Was mache ich, wenn ich mein Passwort vergessen habe?"
    },
    reset: {
      text: "Gib 15 Mal ein falsches Gerätekennwort ein. Die letzten Versuche erfordern eine lange Berührung des Geräts.",
      title: "Wie stelle ich mein Gerät wieder her?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Das Gerät sollte beim Einstecken einmal blinken. Stelle sicher, dass es richtig herum eingesetzt ist. Bei Problemen kontaktiere uns bitte über den untenstehenden Link.",
      title: "Meine BitBox01 wurde nicht erkannt"
    },
    getDevice: {
      link: {
        text: "Bestellen einer BitBox"
      },
      text: "Du kannst eine BitBox in unserem Online Shop bestellen:",
      title: "Wie bekomme ich ein Gerät?"
    },
    internet: {
      text: "Ja, eine Internetverbindung ist erforderlich, um die Wallet zu synchronisieren, Transaktionen zu senden und die neuesten Wechselkurse abzurufen.",
      title: "Braucht diese Applikation eine Internet Verbindung?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Du kannst deine Konten auf einer neuen BitBox oder in unserem Backup-center wiederherstellen.",
      title: "Ich habe mein Gerät verloren. Was nun?"
    },
    useWithoutDevice: {
      text: "Leider ist dies zum aktuellen Zeitpunkt nicht möglich. ",
      title: "Kann ich die App auch ohne Gerät benutzen?"
    },
    welcome: {
      text: "Vielen Dank, dass du diese App benutzt. Sie wird von Shift Crypto in der Schweiz entwickelt. Wir freuen uns über Anregungen und Fragen. Zögere nicht, uns zu kontaktieren.",
      title: "Willkommen in der BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Wenn du ein neues Telefon/Computer mit der BitBoxApp verwendest, musst du dich erneut mit den DApps verbinden. Anschließend siehst du deine Coins wieder wie gewohnt auf der DApp.",
      title: "Ich sehe meine vorherigen Verbindungen nicht."
    },
    supportedNetworks: {
      text: "Derzeit wird nur das Ethereum-Mainnet mit WalletConnect in der BitBoxApp unterstützt. Um andere EVM-kompatible Netzwerke zu verwenden, verwende bitte das Rabby Browser-Extension Wallet.",
      title: "Welche Netzwerke werden unterstützt?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ist ein Kommunikationsprotokoll für Web3-Anwendungen. Damit kannst du bequem eine Verbindung zu Ethereum basierten DApps und Web-Wallets herstellen, ohne eine Drittanbieter-App zu verwenden. Dies ist besonders nützlich für Android Nutzer der BitBoxApp.",
      title: "Was ist WalletConnect?"
    }
  }
}, headerssync$g = {
  blocksSynced: `{{blocks}} Blöcke synchronisiert
`
}, hiddenWallet$g = {
  info1HTML: "Zur glaubhaften Abstreitbarkeit kann eine versteckte Wallet erstellt werden, das auf einer <strong> anderen </strong> Geräte- und Wiederherstellungspasswort Kombination basiert.",
  info2HTML: "Gib das Gerätepasswort und das Wiederherstellungspasswort ein, die du für deine versteckte Wallet verwenden möchtest. Das Gerätepasswort und das Wiederherstellungspasswort müssen sich von <strong> denen unterscheiden </strong> , die du für dein primäres Wallet verwendest.",
  passwordLabel: "Versteckte Wallet Passwort",
  passwordPlaceholder: "Bitte bestätige das versteckte Wiederherstellungspasswort",
  pinLabel: "Verstecktes Gerätepasswort",
  pinRepeatLabel: "Wiederhole das versteckte Gerätepasswort",
  pinRepeatPlaceholder: "Bitte bestätige das versteckte Gerätepasswort",
  success: "Versteckte Wallet erfolgreich erstellt. Stecke die BitBox erneut ein und gib das versteckete Gerätepasswort ein, um diese zu entsperren."
}, initialize$g = {
  create: "Gerätepasswort speichern",
  creating: "Gerätekennwort wird eingestellt...",
  error: {
    e102: "Das Gerätekennwort muss aus mindestens 4 Zeichen bestehen."
  },
  info: {
    description1: "Wähle dein Gerätekennwort. Dieses wird zum Entsperren deiner BitBox verwendet.",
    description2: "Du kannst Zahlen und Buchstaben verwenden. Längere Passwörter sind in der Regel sicherer.",
    description3: "Wenn du das Gerätepasswort vergisst, musst du dein Gerät zurücksetzen und deine Wallet von deinem Backup wiederherstellen.",
    subtitle: "Jetzt legst du dein Gerätepasswort fest",
    title: "Initialisierung deines Gerätes"
  },
  input: {
    label: "Gerätepasswort",
    labelRepeat: "Wiederhole das Gerätepasswort",
    placeholderRepeat: "Bitte bestätige das Gerätepasswort"
  }
}, invalidFormat$g = "Ungültiges Format", language$h = {
  title: "Sprache auswählen"
}, legacyhiddenwallet$g = {
  disable: "Versteckte Legacy Wallet deaktivieren",
  enable: "Versteckte Legacy Wallet aktivieren",
  successDisable: "Versteckte Legacy Wallet erfolgreich deaktiviert",
  successEnable: "Die versteckte legacy Wallet wurde erfolgreich aktiviert. Stecke deine BitBox erneut ein und gib das versteckte Gerätepasswort ein, um auf die versteckte Wallet zuzugreifen."
}, loading$g = "laden...", manageAccounts$a = {
  accountHidden: "Dieses Konto wurde aus deinen watch-only Konten ausgeblendet. Verbinde deine BitBox02 um es wieder anzuzeigen.",
  editAccount: "Bearbeiten",
  editAccountNameTitle: "Kontonamen bearbeiten",
  noAccounts: "Keine Konten gefunden",
  settings: {
    hideTokens: "Token ausblenden",
    showTokens: "Token anzeigen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Konten hinzufügen und aktivieren / deaktivieren",
  title: "Konten verwalten",
  watchAccount: "Konto merken",
  watchAccountDescription: "Dieses Konto ist Teil deines watch-only Kontos. Du kannst es mit diesem Schalter vor den watch-only Konten verstecken."
}, mobile$b = {
  usingMobileDataWarning: "Mobile Datennutzung: Diese App downloaded ein paar hundert Megabytes an Blockchain Daten nachdem ein Konto geöffnet wurde. Bitte verbinde dein Handy für diesen einmaligen Download mit deinem Wifi. "
}, newSettings$9 = {
  about: {
    appVersion: {
      title: "App-Version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Sperre den Zugriff zur App mit Displaysperre/Fingerabdruck.",
      title: "Displaysperre"
    },
    coinControl: {
      description: "Wähle aus, welche UTXOs Teil einer Transaktion sind, um die Privatsphäre zu verbessern."
    },
    customFees: {
      description: "Ermöglicht es dir, beim Senden deine eigene Gebühr festzulegen."
    },
    torProxy: {
      description: "Stelle für mehr Privatsphäre eine Verbindung über Tor her."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Diese zusätzlichen Währungen können auf Ihrer Kontoseite eingeschaltet werden.",
      title: "Aktive Währungen"
    },
    darkmode: {
      description: "Aktiviere den dunklen Modus der BitBoxApp."
    },
    defaultCurrency: {
      description: "Wähle deine Standardwährung aus",
      title: "Standardwährung"
    },
    enableWallet: {
      description: "Wenn du dein Konto deaktivierst, wird es weder in der Seitenleiste noch im Portfolio angezeigt. Du kannst es hier jederzeit wieder aktivieren. Coins auf diesem Konto werden nicht beeinflusst und bleiben sicher.",
      title: "Wallet aktivieren/deaktivieren"
    },
    hideAmounts: {
      description: "Zeigt einen Schalter zum Ausblenden deines Guthabens und Beträgen an, um deine Privatsphäre zu verbessern, wenn du die App in der Öffentlichkeit nutzt.",
      hideAmounts: "Beträge ausblenden",
      showAmounts: "Beträge anzeigen",
      title: "Ausblenden von Beträgen zulassen"
    },
    language: {
      description: "Welche Sprache die BitBoxApp verwenden soll.",
      title: "Sprache"
    },
    remebmerWallet: {
      name: "Wallet merken",
      warning: "Dies wird dein gemerktes Wallet entfernen. Um es wieder zu sehen musst du die BitBox02 für dieses Wallet verbinden. Alle Coins auf diesem Wallet werden nicht beeinflusst. Möchtest du fortfahren?",
      warningTitle: 'Deaktiviere "Wallet merken"'
    },
    toggleSats: {
      description: "Aktiviere oder deaktiviere Satoshis."
    }
  }
}, note$c = {
  input: {
    description: "(optional)",
    placeholder: "Notiz hinzufügen..."
  },
  title: "Notiz"
}, notification$g = {
  newTxs_one: "Neue Transaktion in: {{accountName}}",
  newTxs_other: "{{count}} neue Transaktionen in: {{accountName}}"
}, pairing$g = {
  aborted: {
    text: "Der Kopplungsprozess wurde von der Smartphone App abgebrochen.",
    title: "Abgebrochen"
  },
  button: "Mit Smartphone App koppeln",
  confirm: "Möchtest du deine BitBox wirklich koppeln? Danach wird dein Mobiltelefon zur Durchführung einer Transaktion unbedingt erforderlich sein.",
  connectOnly: {
    button: "Smartphone App verbinden",
    title: "Scanne den Code mit der Smartphone App. "
  },
  error: {
    text: "Etwas ist schief gelaufen. Bitte fang erneut an.",
    title: "Fehler"
  },
  pullFailed: {
    text: "Fehler beim Abrufen einer Nachricht von deinem Mobiltelefon über den Relay-Server. Der Relay-Server ist möglicherweise offline. Wende dich an den Support.",
    title: "Laden fehlgeschlagen"
  },
  reconnectOnly: {
    button: "Smartphone App erneut verbinden"
  },
  scanningFailed: {
    text: "Das Handy konnte die Nachricht nicht scannen. Bitte versuche es erneut.",
    title: "Scannen fehlgeschlagen"
  },
  start: {
    hideAppQRCode: "QR Code ausblenden",
    revealAppQRCode: "QR Code anzeigen",
    step1: "Wenn du nicht über die Smartphone App verfügst, kannst du den QR-Code für den Apple App Store oder den Google Play Store scannen.",
    step2: "Scanne den Code mit der Smartphone App, die du im App Stores für iOS und Android findst, wenn du nach 'Digital Bitbox 2FA' suchst."
  },
  started: {
    text: "Folge nun den Anweisungen in der mobilen App.",
    title: "Gut gemacht!"
  },
  success: {
    text: "Herzlichen Glückwunsch, du hast deine BitBox erfolgreich mit der mobilen App gekoppelt!",
    title: "Erfolg"
  },
  timeout: {
    text: "Der Kopplungsprozess ist nach 2 Minuten abgelaufen. Bitte versuche es erneut.",
    title: "Zeitüberschreitung"
  },
  title: "Smartphone Kopplung"
}, passphrase$a = {
  considerations: {
    button: "Backup-Hinweise",
    message: `Die Passphrase bietet zusätzlichen Schutz für dein Wallet-Backup (MicroSD oder 24 Wörter). Falls jemand Zugriff auf dein Backup hat, benötigt er zusätzlich die Passphrase, um auf dein Wallet zuzugreifen. 

Dies bedeutet jedoch, dass du <strong>sowohl die Passphrase als auch das Wallet Backup</strong> benötigst, um dein Passphrase-Wallet wiederherzustellen, falls deine BitBox02 verloren oder kaputt geht. Falls du die Passphrase verlierst, verlierst du auch Zugriff auf alle Coins in diesem Wallet.

Erwäge, deine Passphrase an einem anderen Ort als dein Backup zu sichern. Falls jemand dein Backup findet, fehlt ihm immer noch die Passphrase. `,
    title: "Backup-Hinweise"
  },
  disable: "Passphrase deaktivieren",
  disableInfo: {
    button: "Deaktivieren",
    message: `Nachdem du die Passphrase deaktiviert hast, wirst du nach dem Entsperren deiner BitBox02 nicht mehr aufgefordert, eine Passphrase einzugeben. Daher wirst du deine Standard-Wallet aufrufen.

Alle Coins in deiner Passphrase-Wallet befinden sich weiterhin in dieser Wallet, aber du kannst nicht darauf zugreifen, weil du nach dem Entsperren deiner BitBox02 deine Standard-Wallet öffnest.

Um wieder auf deine Passphrase-Wallet zuzugreifen, aktiviere einfach wieder die Passphrase-Funktion und gib die entsprechende Passphrase ein, nachdem du die BitBox02 entsperrt hast.

<strong>Tipp:</strong> Du kannst deine ursprüngliche Wallet immer noch öffnen, indem du die Passphrase leer lässt.`
  },
  enable: "Passphrase aktivieren",
  error: {
    e104: "Änderung der Passphrase-Einstellung wurde abgebrochen. "
  },
  how: {
    button: "So sieht es aus",
    message: `Eine Passphrase funktioniert nicht wie ein Passwort, wie du es kennst. Wenn du deine Passphrase falsch eingibst, wirst du nicht benachrichtigt. Das liegt daran, dass <strong>jede Passphrase eine andere, aber gültige Wallet</strong> erstellt. Das heißt, du kannst mehrere Passphrasen für so viele Wallets verwenden, wie du willst. Auf jede Wallet kannst du aber nur zugreifen, wenn du die entsprechende Passphrase eingibst.

Wenn du deine BitBox02 einsteckst, wirst du wie üblich nach dem Gerätepasswort gefragt. Danach wirst du aufgefordert, eine Passphrase auf dem Gerät einzugeben.

Nachdem du die Passphrase eingegeben hast, wird dir die eingegebene Passphrase angezeigt. So kannst du bestätigen, dass du sie richtig eingegeben hast.`,
    title: "Wie funktioniert die Passphrase?"
  },
  intro: {
    message: `Eine Passphrase bietet zusätzliche Sicherheit für deine Wallet.
Hier erfährst du, wie sie funktioniert.`,
    title: "Passphrase einrichten"
  },
  progressDisable: {
    message: "Bestätige auf deiner BitBox, dass du die optionale Passphrase <strong>deaktivieren</strong> möchtest.",
    title: "Bestätige am Gerät"
  },
  progressEnable: {
    message: "Bestätige auf deiner BitBox, dass du die optionale Passphrase <strong>aktivieren</strong> möchtest.",
    title: "Bestätige am Gerät"
  },
  successDisabled: {
    message: `Optionale Passphrase <strong>erfolgreich aktiviert</strong>!
Von nun an wirst du dazu aufgefordert, eine Passphrase anzugeben.`,
    messageEnd: "Bitte stecke die BitBox02 jetzt wieder ein.",
    title: "Passphrase aktiviert"
  },
  successEnabled: {
    message: `Optionale Passphrase <strong>erfolgreich deaktiviert</strong>!
Von nun an wirst du nicht mehr dazu aufgefordert, eine Passphrase anzugeben.`,
    messageEnd: "Bitte stecke deine BitBox02 jetzt wieder ein.",
    tips: "Tipps",
    tipsList: [
      "Wir empfehlen, zuerst einen kleinen Betrag in die Passphrase-Wallet zu senden. Dann musst du die BitBox02 aus- und wieder einstecken und dein Passwort und deine Passphrase eingeben. Wenn du die Passphrase richtig eingegeben hast, solltest du die Coins in deinem Wallet sehen.",
      "Wenn du deine ursprüngliche Wallet ohne Passphrase betreten willst, kannst du das immer noch tun, indem du nichts eingibst, wenn du zur Eingabe der Passphrase aufgefordert wirst. Oder du kannst die Passphrase-Funktion deaktivieren."
    ],
    title: "Passphrase deaktiviert"
  },
  summary: {
    button: "Passphrase aktivieren",
    title: "Übersicht",
    understand: "Ich verstehe, wie die Passphrase funktioniert und welche Risiken damit verbunden sind.",
    understandList: [
      "Die Passphrase ist eine zusätzliche Sicherheitsmaßnahme für mein Backup.",
      "Wenn ich eine andere Passphrase eingebe, wird immer ein anderes Wallet erstellt.",
      "Um mein Wallet wiederherzustellen benötige ich <strong>sowohl die Passphrase als auch das Backup</strong>.",
      "Wenn ich meine Passphrase vergesse, habe ich <strong>keinen Zugriff mehr auf meine Coins</strong>."
    ]
  },
  what: {
    button: "Verstehe, wie es funktioniert",
    message: `Eine Wallet wird aus einer sehr großen Zufallszahl erstellt (abgeleitet), die auch als Seed bezeichnet wird. Dieser Seed wird erstellt, wenn du deine BitBox02 zum ersten Mal einrichtest, und mit der microSD-Karte oder 24 Wörtern gesichert. Jeder, der Zugriff auf den Seed hat, hat die volle Kontrolle über das Geld auf dieser Wallet.

Eine Passphrase ist ein <strong>optionales Geheimnis</strong>, das zum Seed hinzugefügt wird. Wenn du eine Passphrase verwendest, erstellt jede Passphrase eine neue Wallet, die auf dem Seed + Passphrase (optionales Geheimnis) basiert. Eine Passphrase kann alles sein: Buchstaben, Wörter, Sonderzeichen oder auch leer. Die Standard-Wallet wird aus dem Seed und der leeren Passphrase erstellt.

Die Passphrase ist Teil des BIP39-Standards, was bedeutet, dass sie mit allen Wallets kompatibel ist, die denselben Standard unterstützen.`,
    title: "Was ist eine Passphrase?"
  },
  why: {
    button: "Warum sollte man eine Passphrase benutzen?",
    message: `Die BitBox02 schützt den Seed vor der Extraktion aus dem Gerät selbst, doch das Backup (microSD-Karte oder 24 Wörter) gibt vollen Zugriff auf die Wallet. Deshalb sollte es an einem sicheren Ort aufbewahrt werden!

Da eine Passphrase eine neue Wallet mit deinem bestehenden Seed erstellt, benötigt die Passphrase-Wallet <strong>sowohl dein Backup als auch deine Passphrase zur Wiederherstellung</strong>. Das hat den Vorteil, dass jemand, der dein Backup findet, trotzdem die Passphrase braucht, um auf die Passphrase-Wallet zuzugreifen.

Außerdem kannst du mit der Passphrase-Funktion mehrere Wallets auf demselben Gerät erstellen, also "versteckte Wallets" zusätzlich zur Standard-Wallet.`,
    title: "Warum sollte man eine Passphrase benutzen?"
  }
}, password$g = {
  show: "{{label}} anzeigen",
  warning: {
    caps: "WARNUNG: Feststelltaste  (⇪) ist aktiviert",
    paste: 'Um Text einzufügen, aktiviere "Anzeigen" {{label}}".'
  }
}, random$h = {
  button: "Zufallszahl generieren",
  description: "Deine BitBox hat die folgende {{bits}}-Bit-Zufallszahl generiert:"
}, receive$i = {
  changeScriptType: "Adresstyp ändern",
  label: "Meine Adresse",
  onlyThisCoin: {
    description: "Um andere Token empfangen zu können, aktiviere diese in den Einstellungen. Solltest du Token empfangen, welche die BitBoxApp nicht unterstützt, hast du möglicherweise keinen Zugang mehr zu diesen. ",
    warning: "Stelle sicher, dass du nur {{coinName}} auf diese Adresse sendest."
  },
  scriptType: {
    p2tr: "Taproot (neuestes Format)",
    p2wpkh: "Native-Segwit (standard)",
    "p2wpkh-p2sh": "Wrapped-Segwit (kompatibles Format)"
  },
  selectAccount: "Konto auswählen",
  showFull: "Adresse auf BitBox bestätigen",
  taprootWarning: "Hinweis: Taproot ist ein neues Adressformat und noch nicht weit verbreitet. Gelder, die über Taproot-Adressen eingehen, sind möglicherweise nicht in Watch-Only-Wallets von Drittanbietern sichtbar. Viele Wallets und Börsen sind noch nicht in der Lage, an Taproot-Adressen zu senden.",
  title: "{{accountName}} empfangen",
  verify: "Adresse sicher verifizieren",
  verifyBitBox01: "Adresse auf Smartphone überprüfen",
  verifyBitBox02: "Adresse auf BitBox02 überprüfen",
  verifyInstruction: "Bitte bestätige, dass die folgende Adresse mit der Adresse auf deinem Gerät übereinstimmt.",
  warning: {
    secureOutput: 'Bitte koppele deine BitBox mit deinem Smartphone, um eine sichere Adressüberprüfung zu ermöglichen. Klicke in der Seitenleiste auf "Gerät verwalten".'
  }
}, reset$g = {
  description: "Alle Daten auf dem Gerät werden gelöscht. Inklusive deiner Private-Keys!",
  notReset: "Gerät NICHT zurück gesetzt.",
  title: "Gerät in Werkszustand zurücksetzen",
  understand: "Ich habe ein Backup und kenne mein Wiederherstellungskennwort",
  understandBB02: "Ich habe ein valides Backup"
}, securityInformation$g = {
  create: {
    description1: "Bitte richte dein Gerät in einer sicheren Umgebung ein, sodass niemand sehen kann, welches Passwort du wählst.",
    description2: "Während der Einrichtung wirst du aufgefordert, zwei verschiendene Passworter zu erstellen. ",
    description3: "Das erste Passwort ist das <strong> Gerätepasswort </strong>, welches deine BitBox entsperrt und später geändert werden kann.",
    description4: "Das zweite ist das <strong> Wiederherstellungspasswort </strong>, mit dem dein Wallet gesichert wird. Dieses Passwort kann später nicht geändert werden",
    description5: "Die von dir erstellte Wallet wird in einer Datei auf der mitgelieferten microSD Karte gespeichert. Dieses Backup kann im Notfall verwendet werden, um den Zugriff auf deine Coins mithilfe deines <strong> Wiederherstellungskennworts </strong> wieder herzustellen.",
    title: "Sicherheitsinformationen"
  },
  restore: {
    description1: "Du wirst aufgefordert, die Micro-SD-Karte einzustecken, die du zum Speichern deines Backups verwendet hast.",
    description2: "Um dein Gerät wiederherzustellen, benötigst du dein Wiederherstellungskennwort.",
    description3: "Bitte sei bei der Eingabe des Wiederherstellungskennworts aufmerksam. Jedes von dir eingegebene Passwort erstellt eine gültige Wallet, welche dann aber leer sind. Gibst du also ein falsches Kennwort ein, wird dir nicht die erwartete Wallet, sondern eine andere Wallet angezeigt.",
    title: "Sicherheitsinformationen"
  }
}, seed$g = {
  agreements: {
    "funds-access": "Ich kann NICHT auf mein Geld zugreifen, wenn ich mein Wiederherstellungspasswort vergessen habe.",
    "password-change": "Ich kann das Wiederherstellungspasswort später NICHT ändern.",
    "password-required": "Ich brauche mein Wiederherstellungspasswort, um meine Wallet von meinem Backup wiederherzustellen."
  },
  create: "Neue Wallet erstellen",
  creating: "Wallet wird erstellt",
  description: "Ich bestätige, dass ich folgendes zu Kenntnis genommen habe:",
  error: {
    e102: "Das Passwort muss aus mindestens 4 Zeichen bestehen.",
    e200: "Du musst eine microSD Karte in deine BitBox einsetzen, damit ein Backup deiner Wallet erstellt und auf der Micro-SD Karte gespeichert werden kann."
  },
  info: {
    button: " Wiederherstellungspasswort festlegen",
    description1: "Steck die microSD Karte in die BitBox ein.",
    description2: 'Wähle ein Wiederherstellungspasswort für die Wallet und klicke "Wiederherstellungspasswort speichern".',
    description3: "Das Backup auf der microSD Karte, zusammen mit deinem Wiederherstellungspasswort, ist die einzige Methode, wie deine Wallet (= der Zugang zu deinen Coins) wieder hergestellt werden kann, falls deine BitBox gestohlen wird oder du dein Gerätepasswort vergisst!",
    description4: "Das Wiederherstellungspasswort lässt sich später nicht ohne Weiteres ändern. Dazu müsstest du dein Coins auf ein neues Konto transferieren. Deswegen solltest du von Anfang an ein gutes Passwort wählen.",
    title: "Neue Wallet erstellen "
  },
  password: {
    label: "Wiederherstellungspasswort",
    repeatPlaceholder: "Wiederhestellungspasswort wiederholen"
  },
  walletName: {
    label: "Wallet Name"
  }
}, seedRestore$g = {
  error: {
    e200: "Um eine Wallet von einem Backup wieder herzustellen wird deine microSD Karte benötigt."
  },
  info: {
    description1: 'Stecke die microSD-Karte in die BitBox ein und klicke auf "Weiter".',
    description2: 'Wähle ein Backup aus und klicke "Wiederherstellen"',
    description3: "Gib das Wiederherstellungspasswort ein",
    description4: "Du musst bestätigen, dass du zu Kenntnis genommen hast, dass ein falsches Passwort eine andere Wallet erstellt/öffnet.",
    title: "Wie wird eine Wallet von einem Backup wieder hergestellt?"
  }
}, send$i = {
  abort: "Die Transaktion wurde abgebrochen",
  address: {
    label: "Empfangsadresse",
    placeholder: "Adresse eingeben oder scannen"
  },
  amount: {
    label: "Betrag",
    placeholder: "Betrag eingeben"
  },
  availableBalance: "Kontostand",
  button: "Prüfen",
  coincontrol: {
    address: "Adresse",
    outpoint: "ID",
    title: "Outputs wählen"
  },
  confirm: {
    "selected-coins": "Ausgewählte Coins",
    title: "Bestätige und sende die Transaktion",
    total: "Gesamt"
  },
  error: {
    erc20InsufficientGasFunds: "Es scheint, als hättest du nicht genug Ether, um für diese ERC20-Transaktion zu bezahlen. Bitte vergewissere dich, dass du genug Ether in deiner Wallet hast.",
    feeTooLow: "Gebühr zu niedrig",
    feesNotAvailable: "Gebühren konnten nicht geschätzt werden",
    insufficientFunds: "Unzureichende Mittel",
    invalidAddress: "ungültige Adresse",
    invalidAmount: "ungültige Menge",
    invalidData: "ungültige Daten"
  },
  fee: {
    customPlaceholder: "Betrag eingeben",
    label: "Netzwerk Gebühr",
    placeholder: "Nicht verfügbar"
  },
  feeTarget: {
    customLabel: "Gebühren-Rate",
    customLabel_eth: "Gas-Preis",
    description: {
      economy: "4 Stunden (24 Blöcke)",
      economy_eth: "30 Minuten oder weniger",
      economy_ltc: "1 Stunde (24 Blöcke)",
      high: "20 Minuten (2 Blöcke)",
      high_eth: "30 Sekunden oder weniger",
      high_ltc: "5 Minuten (2 Blöcke)",
      low: "2 Stunden (12 Blöcke)",
      low_eth: "5 Minuten oder weniger",
      low_ltc: "30 Minuten (12 Blöcke)",
      normal: "1 Stunde (6 Blöcke)",
      normal_eth: "2 Minuten oder weniger",
      normal_ltc: "15 Minuten (6 Blöcke)"
    },
    estimate: "Geschätzte Wartezeit:",
    label: {
      custom: "Eigene Gebühr",
      economy: "Sehr niedrig",
      high: "Hoch",
      low: "Niedrig",
      normal: "Normal"
    },
    placeholder: "Gebühr wird berechnet...."
  },
  maximum: "Alles senden",
  maximumSelectedCoins: "Ausgewählte Coins senden",
  noFeeTargets: "Gebührenschätzungen sind derzeit nicht verfügbar. Bitte versuche es später erneut oder gib eine benutzerdefinierte Gebühr ein.",
  priority: "Priorität",
  scanQR: "QR Code scannen",
  signprogress: {
    description: "Dies ist eine Transaktion, die viele Daten enthält. Um die Transaktion vollständig zu signieren, wirst du aufgefordert, {{steps}} mal auf der BitBox zu bestätigen.",
    label: "Fortschritt"
  },
  success: "Die Transaktion wurde signiert und versendet.",
  title: "{{accountName}} senden",
  toggleCoinControl: "Coin Control",
  transactionDetails: "Transaktionsdetails"
}, settings$h = {
  about: "Über die App",
  accounts: "Konten",
  advancedSettings: "Erweiterte Einstellungen",
  appearance: "Ansicht",
  electrum: {
    add: "Server hinzufügen",
    "add-server": "Hinzufügen",
    check: "Überprüfen",
    checkFailed: "Fehlgeschlagen",
    checkSuccess: "Verbindung zu {{host}} wurde erfolgreich hergestellt",
    checking: "Überprüfen",
    "download-cert": "Remote-Zertifikat herunterladen",
    "remove-server": "Entfernen",
    removeConfirm: "Entfernen {{server}}?",
    reset: "In Werkszustand zurücksetzen",
    resetConfirm: "Möchtest du alle Server entfernen und die Standardserver installieren?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Gib den Endpunkt ein",
    step2: "2",
    "step2-text": "Gib ein Zertifikat der Zertifikatskette des Servers ein. Lade alternativ das Remote-Zertifikat herunter und vergleiche es visuell.",
    "step2-text-tcp": "Überspringe diesen Schritt, wenn du kein TLS verwenden möchtest.",
    step3: "3",
    "step3-text": "Überprüfe die Verbindung und füge den Server hinzu.",
    step4: "4",
    "step4-text": "Starte die BitBoxApp neu. Wenn du die Standardserver nicht entfernst, wird dein eigener Node als Redundanz hinzugefügt.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Coin Control aktivieren",
    electrum: {
      description: "Du kannst dich mit deinem eigenen Electrum-Fullnode verbinden.",
      title: "Eigenen Full Node verbinden"
    },
    fee: "Eigene Gebühr aktivieren",
    setProxyAddress: "Proxy Adresse eingeben",
    title: "Erweiterte Einstellungen",
    useProxy: "Tor Proxy aktivieren",
    useSats: "BTC-Werte in Satoshis anzeigen"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Neues Update verfügbar",
    title: "Info",
    "up-to-date": "Deine App ist auf dem neuesten Stand",
    version: "App-Version"
  },
  restart: "Bitte starte die BitBoxApp neu, damit die Änderungen wirksam werden.",
  services: {
    title: "Dienste"
  },
  success: "Bitte trenne die BitBox und stecke sie wieder ein, damit die Änderungen wirksam werden.",
  title: "Einstellungen"
}, setup$g = "Gerätepasswort festlegen", sidebar$h = {
  buy: "Krypto kaufen",
  device: "Gerät verwalten",
  leave: "Verlassen",
  settings: "Einstellungen"
}, success$n = {
  create: {
    info1: "Ein Backup deiner Wallet wurde sicher auf der microSD Karte gesichert. Entferne die Karte und bewahre diese an einem sicheren Ort auf.",
    info2: "Du hast ein Gerätepasswort erstellt, mit dem die BitBox entsperrt wird.",
    info3: "Du hast ein Wiederherstellungspasswort für deine Wallet erstellt, das deine Coins freigibt und dein Backup wiederherstellt.",
    summary: "Hier ist eine Zusammenfassung von dem, was du getan hast:",
    title: "Erfolg"
  },
  getstarted: "Loslegen",
  restore: {
    summary: "Du hast erfolgreich deine Wallet aus einem Backup wiederhergestellt.",
    title: "Erfolg"
  }
}, transaction$h = {
  confirmation: "Bestätigungen",
  details: {
    activity: "Aktivität",
    address: "Adresse",
    amount: "Betrag",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Fiatbetrag",
    fiatAtTime: "Fiat zur Transaktionszeit",
    status: "Status",
    type: "Typ"
  },
  explorer: "Transaktions ID",
  explorerTitle: "In externem Block Explorer öffnen.",
  fee: "Gebühr",
  fiatHistorical: "Historisch",
  gas: "Gas",
  note: {
    edit: "Notiz bearbeiten",
    save: "Notiz speichern"
  },
  pending: "Ausstehende Transaktion",
  size: "Größe",
  status: {
    complete: "Bestätigt",
    failed: "Fehlgeschlagen",
    pending: "Ausstehend"
  },
  tx: {
    received: "Empfangen an",
    sent: "Gesendet an"
  },
  vsize: "Virtuelle Größe",
  weight: "Gewicht"
}, transactions$g = {
  errorLoadTransactions: "Beim Laden der Transaktionen ist ein Fehler aufgetreten",
  placeholder: "Noch keine Transaktionen."
}, unknownError$g = `Ein unbekannter Fehler ist aufgetreten {{errorMessage}}

`, unlock$g = {
  description: "Gib dein Gerätepasswort ein um dein Gerät zu entsperren.",
  error: {
    e109_normal: "Gerätepasswort inkorrekt.  {{remainingAttempts}} Versuche verbleibend, bevor sich das Gerät in den Werkszustand zurücksetzt. ",
    e109_touch: "$t(unlock.error.e109_normal) Beim nächsten Loginversuch musst du die LED lange halten.",
    e113: "Aufgrund zu vieler Loginversuche musst du beim nächsten Versuch die LED 4 Sekunden lang drücken."
  },
  input: {
    label: "Gerätepasswort",
    placeholder: "Gib dein Gerätepasswort ein um das Gerät zu entsperren."
  },
  unlocking: "Entsperren..."
}, upgradeFirmware$h = {
  button: "Firmware aktualisieren",
  description: "Möchtest du von Version  {{currentVersion}} zu Version {{newVersion}} upgraden?",
  label: "Deine BitBox benötigt eine Firmware Aktualisierung.",
  locked: "Um von Version  {{currentVersion}} zu Version  {{newVersion}} upzugraden, drücke die LED bitte lange. ",
  title: "Firmware upgraden",
  unlocked: "Der Bootloader ist gesperrt. Um fortzufahren:",
  unlocked1: "Steck deine BitBox aus und dann wieder ein.",
  unlocked2: "Die LED wird aufleuchten, wenn deine BitBox wieder eingesteckt ist.",
  unlocked3: "Tippe auf die LED, wenn diese aufleuchtet."
}, walletConnect$a = {
  connect: {
    button: "Verbinden",
    dappLabel: "Gebe die URI-Adresse der Dapp ein",
    invalidPairingUri: "Ungültige Pairing-URI"
  },
  dashboard: {
    allSessions: "Alle Sitzungen",
    disclaimer: "Walletconnect ist ein Protokoll zur Verbindung mit Ethereum basierten Dapps. Diese Dapps werden von Drittanbieterdiensten betrieben. Stelle daher nur eine Verbindung zu Dapps her, denen du vertraust, und stelle sicher, dass du bei einer Transaktion immer weißt, was du signierst.",
    newConnection: "Neue Verbindung",
    noConnectedSessions: "Derzeit sind keine Konten mit Dapps verbunden."
  },
  invalidPairingChain: "Fehler beim Genehmigen des Pairing. Bitte stelle sicher, dass du eines der unterstützten Netzwerke verwendest: {{chains}}",
  pairingRequest: {
    approve: "Verbindung erlauben",
    reject: "Ablehnen",
    title: "Neue Verbindungsanfrage von"
  },
  pairingSuccess: "Dapp erfolgreich verbunden. Du kannst auf der Dapp-Website fortfahren.",
  signingRequest: {
    account: "Konto",
    chain: "Netzwerk",
    dapp: "Dapp",
    data: "Daten",
    dataParsingError: "Parsen der Daten fehlgeschlagen",
    decodeError: "Nachricht konnte nicht dekodiert werden",
    method: {
      sendTransaction: "Transaktion signieren und senden",
      signMessage: "Nachricht signieren",
      signTransaction: "Transaktion signieren",
      signTypedData: "Signiere eingegebene Daten"
    },
    successfullySigned: "Anfrage erfolgreich signiert",
    walletConnectRequest: "WalletConnect Anfrage"
  },
  useNewUri: "Dieser URI wurde bereits für den Verbindungsversuch verwendet. Bitte verwende eine neue URI.",
  walletConnect: "WalletConnect"
}, warning$m = {
  receivePairing: 'Bitte aktiviere 2FA, um Adressen sicher zu verifizieren. Klicke dazu auf "Geräte verwalten" im Menü auf der linken Seite.',
  sdcard: "Bewahre deine microSD Karte separat von deiner BitBox auf. Die microSD Karte wird nur benötigt, wenn du deine Backups verwalten willst. Für den normalen Betrieb ist sie nicht erforderlich.",
  sendPairing: 'Bitte koppele deine BitBox mit einem Smartphone um Transaktionen sicher verifizieren zu können. Klicke dazu auf "Geräte verwalten" im Menü auf der linken Seite.'
}, welcome$g = {
  connect: "Verbinde eine BitBox02",
  getStarted: "Beginnen wir mit der Installation der Firmware auf deiner BitBox02.",
  insertBitBox02: "Tippe dann auf die BitBox02 zum weiter machen. ",
  insertDevice: "Bitte verbinde dein Gerät, um loszulegen",
  title: "Willkommen"
}, appTranslationsDE = {
  account: account$g,
  accountInfo: accountInfo$g,
  accountSummary: accountSummary$g,
  addAccount: addAccount$h,
  aopp: aopp$a,
  app: app$g,
  auth: auth$9,
  backup: backup$g,
  bb02Bootloader: bb02Bootloader$g,
  bitbox: bitbox$g,
  bitbox02Interact: bitbox02Interact$g,
  bitbox02Settings: bitbox02Settings$g,
  bitbox02Wizard: bitbox02Wizard$g,
  blink: blink$g,
  bootloader: bootloader$g,
  button: button$k,
  buy: buy$c,
  changePin: changePin$g,
  chart: chart$c,
  checkSDcard: checkSDcard$g,
  clickHere: clickHere$g,
  confirm: confirm$i,
  confirmOnDevice: confirmOnDevice$g,
  connectKeystore: connectKeystore$9,
  darkmode: darkmode$a,
  device: device$g,
  deviceLock: deviceLock$g,
  deviceSettings: deviceSettings$g,
  deviceTampered: deviceTampered$g,
  dialog: dialog$h,
  error: error$c,
  fiat: fiat$i,
  footer: footer$i,
  generic: generic$c,
  genericError: genericError$g,
  goal: goal$g,
  guide: guide$h,
  headerssync: headerssync$g,
  hiddenWallet: hiddenWallet$g,
  initialize: initialize$g,
  invalidFormat: invalidFormat$g,
  language: language$h,
  legacyhiddenwallet: legacyhiddenwallet$g,
  loading: loading$g,
  manageAccounts: manageAccounts$a,
  mobile: mobile$b,
  newSettings: newSettings$9,
  note: note$c,
  notification: notification$g,
  pairing: pairing$g,
  passphrase: passphrase$a,
  password: password$g,
  random: random$h,
  receive: receive$i,
  reset: reset$g,
  securityInformation: securityInformation$g,
  seed: seed$g,
  seedRestore: seedRestore$g,
  send: send$i,
  settings: settings$h,
  setup: setup$g,
  sidebar: sidebar$h,
  success: success$n,
  transaction: transaction$h,
  transactions: transactions$g,
  unknownError: unknownError$g,
  unlock: unlock$g,
  upgradeFirmware: upgradeFirmware$h,
  walletConnect: walletConnect$a,
  warning: warning$m,
  welcome: welcome$g
}, account$f = {
  disconnect: "Connection lost. Retrying…",
  export: "Export",
  exportTransactions: "Export transactions to downloads folder as CSV file",
  fatalError: "There was an unexpected error.",
  incoming: "Incoming",
  initializing: "Getting information from the blockchain…",
  maybeProxyError: "Tor proxy enabled. Ensure that your Tor proxy is running properly, or disable the proxy setting.",
  reconnecting: "Lost connection, trying to reconnect…",
  syncedAddressesCount: "Scanned {{count}} addresses"
}, accountInfo$f = {
  address: "Address",
  buyCTA: {
    buy: "Buy {{unit}}",
    buyCrypto: "Buy Crypto",
    information: {
      looksEmpty: "Looks like this wallet is empty.",
      start: "Get started by depositing some coins to the wallet or buying directly in the BitBoxApp."
    }
  },
  extendedPublicKey: "Extended public key",
  label: "Account info",
  scriptType: "Script type",
  title: "Account information",
  verify: "Verify on device",
  xpubTypeChangeBtn: {
    p2pkh: "View legacy P2PKH extended public key",
    p2tr: "View Taproot",
    p2wpkh: "View Native Segwit",
    "p2wpkh-p2sh": "View older Segwit extended public key"
  },
  xpubTypeInfo: "Currently displaying {{scriptType}} extended public key ({{current}} of {{numberOfXPubs}})"
}, accountSummary$f = {
  availableBalance: "Available balance",
  balance: "Balance",
  exportSummary: "Export accounts summary to downloads folder as CSV file",
  fiatBalance: "Fiat balance",
  name: "Account name",
  noAccount: "There are no accounts to show.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "My portfolio",
  total: "Total",
  transactionHistory: "Transaction history"
}, addAccount$g = {
  chooseName: {
    nextButton: "Add account",
    step: "Name account",
    title: "Name your account"
  },
  selectCoin: {
    nextButton: "Next",
    step: "Select coin",
    title: "Select cryptocurrency"
  },
  success: {
    addAnotherAccount: "Add another account",
    message: "<strong>{{accountName}}</strong> has now been added to your accounts.",
    nextButton: "Done",
    step: "Finished",
    title: "Account added"
  },
  title: "Add account"
}, aopp$9 = {
  addressRequest: "{{host}} is requesting a receiving address.",
  addressRequestWithLogo: "is requesting a receiving address",
  banner: "Address request in progress. Please connect your device to continue.",
  errorTitle: "Error during address request ",
  labelAddress: "Address",
  labelMessage: "Message",
  reverifyInfoText: "Verify address",
  signing: "To proceed, sign message on your BitBox02",
  success: {
    message: "Proceed on {{host}}",
    title: "Address successfully sent"
  },
  syncing: "Syncing the account, please wait.",
  title: "Address request"
}, app$f = {
  upgrade: "A new version of this app is available! Please upgrade from {{current}} to {{version}}."
}, auth$8 = {
  authButton: "Authenticate",
  title: "Please authenticate to continue"
}, backup$f = {
  check: {
    checking: "Checking backup…",
    confirmTitle: "Check backup",
    notOK: "Backup does NOT match the wallet.",
    ok: "Backup matches the wallet.",
    password: {
      label: "Recovery password",
      placeholder: "Recovery password",
      showLabel: "recovery password"
    },
    success: "Successfully verified backup:",
    title: "Check backup"
  },
  create: {
    alreadyExists: "You already have a valid backup. Do you wish to re-create it?",
    fail: "Creating the backup FAILED!",
    info: "Please enter the recovery password of the current wallet for verification.",
    name: {
      label: "Backup name",
      placeholder: "Please name the backup"
    },
    password: {
      label: "Recovery password",
      placeholder: "Please enter your recovery password"
    },
    title: "Create backup",
    verificationFailed: "The recovery password does NOT MATCH the current wallet. The backup has been created. Please use 'Check backup' to verify your recovery password again."
  },
  description: "Select <strong>wallet backup file</strong>",
  insert: "Please insert the microSD card to manage backups.",
  insertButton: "I have inserted the microSD card",
  list: "Your microSD card backups",
  noBackups: "There are no backups on this microSD card.",
  restore: {
    confirmTitle: "Restore backup",
    error: {
      e200: "microSD card not found",
      general: "Error restoring the backup"
    },
    password: {
      label: "Recovery password or hidden recovery password",
      placeholder: "Recovery password",
      repeatPlaceholder: "Repeat recovery password",
      showLabel: "Recovery password"
    },
    restoring: "Restoring backup…",
    selectedBackup: "<strong>{{backupName}}</strong> created on {{createdDateTime}} will be restored.",
    title: "Restore",
    understand: "I understand that an incorrect recovery password will create a different wallet"
  },
  showMnemonic: {
    description: `You will be presented with your recovery words, which form a backup of your wallet. Write them down on paper.

<strong>Do not store them digitally or take pictures of it.</strong>

<strong>Do not say the words out loud.</strong>

<strong>This backup is not password-protected.</strong>

Afterwards, you will be asked to confirm each word.`,
    title: "Show recovery words",
    warning: "<strong>Never share your recovery words with anyone.</strong> Your recovery words give full access to your wallet. If someone is asking you for your recovery words, it's a scammer, do not share them!"
  },
  title: "Manage backups"
}, bb02Bootloader$f = {
  abort: "Don't upgrade – take me back",
  abort_noUpgrade: "Take me back",
  advanced: {
    label: "Advanced settings",
    toggleShowFirmwareHash: "Show the firmware hash every time on startup"
  },
  flipscreen: "Flip screen",
  orientation: "Device oriented the wrong way?",
  success: "Upgrade successful! Continuing in {{rebootSeconds}} seconds...",
  success_install: "Installation successful! Continuing in {{rebootSeconds}} seconds..."
}, bitbox$f = {
  error: {
    e10000: "Current device password incorrect.",
    e10001: "Failed to replace device password",
    e102: "The password must consist of at least 4 characters.",
    e112: "Hidden device password cannot be the same as the main device password."
  }
}, bitbox02Interact$f = {
  confirmDate: "Confirm today's date on your BitBox02",
  confirmDateText: "This date will be used to create your backup.",
  confirmName: "Confirm name on BitBox02",
  confirmWords: "Write down the {{amount}} recovery words from your BitBox02",
  confirmWordsText: "After that the BitBox02 asks you to confirm each word to verify that the backup is correct.",
  followInstructions: "Please follow the instructions on your BitBox02.",
  followInstructionsMnemonic: "Follow the instructions on your BitBox02 to enter the recovery words from your backup and restore your wallet.",
  followInstructionsMnemonicTitle: "Restore from recovery words"
}, bitbox02Settings$f = {
  deviceName: {
    current: "Current device name",
    error: "Device name could not be set",
    error_104: "Confirming device name was aborted on device.",
    input: "BitBox02 name",
    placeholder: "New device name",
    title: "Set BitBox02 name"
  },
  gotoStartupSettings: {
    description: "This will reboot your BitBox02 and enter the startup settings.",
    title: "Go to startup settings"
  }
}, bitbox02Wizard$f = {
  advanced: {
    button: "Advanced options",
    outOfDate: "Firmware out of date for this feature",
    seed12WordInfo: "Please note that the number of words cannot be changed after creating the wallet.",
    seed12WordLabel: "Create 12-word instead of 24-word seed",
    seed12WordText: "By default the BitBox02 uses a 24-word seed. Both seed lengths are secure against brute forcing in practice. Some users may prefer the convenience of the 12-word seed instead.",
    skipSDCardLabel: "Skip microSD card backup and write down recovery words instead",
    skipSDCardText: "You always have the option to create a microSD card backup or write your recovery words after setup. This can be done from settings.",
    title: "Advanced backup options"
  },
  attestationFailed: "Genuine check failed, which could be due to restarting the app while the device was waiting for user input. Please reconnect and try again. Please contact support@bitbox.swiss if this persists.",
  backup: {
    point1: "Select a backup on the microSD card",
    point2: "Set a password for your device",
    restoreText: "Ok, let's restore a backup!",
    text1: "Great, your BitBox02 password is now set and wallet created. Now it's time to create your first backup. Please make sure your microSD card is inserted into your BitBox02 and continue.",
    text2: "Please follow the on-screen instruction on your device to create a backup.",
    text3: "After your backup is created, please remove the microSD card and store it in a <strong>secure location</strong>. The contents of the microSD card is not password-protected. Never insert it into any other device but your BitBox02.",
    userConfirmation1: "I should store my backup in a secure location.",
    userConfirmation2: "My backup is not password protected. Anyone with access to it can access my wallet.",
    userConfirmation3: "If I lose or damage my BitBox02, the only way to recover my funds is to restore from my backup.",
    userConfirmation4: "If I lose or damage both my backup and my BitBox02 then my funds will be lost.",
    userConfirmation5: "I should not insert my microSD card backup into a computer, phone, printer or any device other than a BitBox02.",
    userConfirmation5mnemonic: "I should not put my recovery words in a computer, phone, printer or any device other than a BitBox02."
  },
  create: {
    button: "Name device & continue",
    info: "Here are the basics steps you will be taking to set up your BitBox: ",
    inputTitle: "Wallet name",
    point1: "Name your device",
    point2: "Set a password for your device",
    point3: "Create a backup",
    text: "Ok, let's create a new wallet!"
  },
  createBackupAborted: "Creating backup aborted.",
  createBackupFailed: "Creating backup failed, try again.",
  initialize: {
    passwordText: "Now let's set a password for your device. Use the controls on your BitBox to enter and choose a password.",
    passwordTitle: "Set a password for your BitBox",
    text: "Successfully paired your BitBox02! Now let's initialize your device. Get started by choosing to create a new wallet, or to restore a wallet from an existing backup. <strong>Please make sure you have a microSD card inserted in your BitBox02</strong>",
    tip: "We recommend that you proceed in a secure location.",
    title: "Initialize your BitBox"
  },
  insertSDCard: "<strong>Please make sure you have a microSD card inserted in your BitBox02.</strong>",
  noPasswordMatch: "Passwords did not match, please try again.",
  pairing: {
    failed: "Unconfirmed pairing. Please replug your BitBox02.",
    paired: "You have confirmed the following code on your device. Please continue.",
    title: "Verify pairing code",
    unpaired: "An unpaired BitBox02 has been detected. Please verify the pairing code matches what is shown on your BitBox02."
  },
  restoreFromMnemonic: {
    e104: "Restoring from recovery words was canceled.",
    failed: "Restoring from recovery words failed, please try again."
  },
  stepBackup: {
    beforeProceed: "Before proceeding, please read these important security considerations:",
    createBackup: "You will now create a backup on your microSD card.",
    createBackupMnemonic: "You will now write down the recovery words."
  },
  stepBackupSuccess: {
    fundsSafe: "To keep your funds safe, please remember the following:",
    title: "Backup Restored!"
  },
  stepConnected: {
    unlock: "Enter BitBox02 password to unlock."
  },
  stepCreate: {
    description: "This name is used as the device name and for the backup.",
    nameLabel: "BitBox02 name",
    namePlaceholder: "My BitBox02",
    title: "Choose BitBox02 name",
    toastMicroSD: "Please insert your microSD card into your BitBox02 which will be used to store a backup of the wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Please remove the microSD card from your BitBox02 and store it in a secure location.",
    storeMnemonic: "Please store your recovery words in a secure location",
    success: "You’ve successfully created your backup."
  },
  stepInsertSD: {
    insertSDCard: "Please insert a microSD card into your BitBox02 to continue.",
    insertSDcardTitle: "Insert microSD card"
  },
  stepPassword: {
    e104: "Setting password was canceled.",
    title: "Set BitBox02 password",
    useControls: "Use the controls on your BitBox02 to set a password."
  },
  stepUninitialized: {
    create: "I want to setup a new BitBox02.",
    restore: "I want to restore my wallet from a backup.",
    restoreMicroSD: "Restore from microSD card",
    restoreMnemonic: "Restore from recovery words",
    title: "Setup your BitBox02"
  },
  success: {
    text: `Hooray! Your BitBox02 is now ready to use. 

For further information on how to use the BitBoxApp, please use the in-app guide by clicking the question mark on the top right corner.`,
    title: "You're ready to go!"
  }
}, blink$f = {
  button: "Blink"
}, bootloader$f = {
  button: "Upgrade firmware now",
  button_install: "Install firmware now",
  progress: "Upgrading: {{progress}}%",
  progress_install: "Installing: {{progress}}%",
  success: "Upgrade successful! Please replug the device. This time, do not touch the button."
}, button$j = {
  abort: "Abort",
  back: "Back",
  buy: "Buy",
  changepin: "Change device password",
  check: "Check backup",
  continue: "Continue",
  copy: "Copy",
  create: "Create",
  dismiss: "Dismiss",
  done: "Done",
  download: "Download",
  hiddenwallet: "Create hidden wallet",
  next: "Next",
  ok: "OK",
  previous: "Previous",
  receive: "Receive",
  restore: "Restore",
  select: "Select",
  send: "Send",
  unlock: "Unlock",
  update: "Update",
  upgrade: "Upgrade"
}, buy$b = {
  exchange: {
    bankTransfer: "Bank transfer",
    bestDeal: "Best deal",
    creditCard: "Credit card",
    fast: "Fast",
    fee: "fee",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bank Transfer: {{fee}}%",
          creditDebitCard: "Credit/debit card: {{fee}}%",
          learnMore: "Learn more about Moonpay",
          title: "Fees"
        },
        fullCurrenciesList: "See full list of currencies here",
        payment: {
          asteriskText: "* Not available for US residents",
          bankTransfer: "Bank transfer*",
          bankTransferDetails: {
            pix: "PIX (BR transactions in Brazil only)",
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          creditDebitCard: "Credit/debit Card",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "See more details about payment methods",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports all major fiat currencies: USD, EUR, CHF, and more."
      },
      pocket: {
        fees: {
          info: "Bank transfer: {{fee}}%",
          title: "Fees"
        },
        learnMore: "Learn more about Pocket",
        payment: {
          bankTransfer: "Bank transfer",
          bankTransferDetails: {
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            sic: "Swiss Interbank Clearing (CHF transactions in CH/LI only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          bankTransferReccuring: "How to set up recurring purchases with a standing order?",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports European currencies: EUR, GBP, and CHF.",
        verification: {
          info: "Only requires identity verification above daily and annual thresholds.",
          link: "Find current thresholds here",
          title: "Identity verification"
        }
      },
      region: {
        title: "Select the region your bank account is registered in to see which options are available to you."
      }
    },
    noExchanges: "Sorry, there are no available exchanges in this region.",
    region: "Region",
    selectRegion: "Not specified",
    title: "Buy {{name}}"
  },
  info: {
    continue: "Agree and continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "We partner with MoonPay to offer you a seamless way to buy {{name}} directly within the BitBoxApp. It's just a few clicks.",
        "MoonPay is a platform that makes it easy and quick to buy {{name}} in over 160+ countries."
      ],
      payment: {
        details: "You can buy {{name}} instantly via MoonPay with the following payment methods. Credit or debit card orders are instant and convenient, but more expensive due to increased chargeback risk. We recommend using the bank transfer option for larger amounts. The minimum fee is 4 USD/EUR or equivalent.",
        footnote: "Please note that MoonPay's exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
        table: {
          "1_description": "Lowest fees, can take up to 3 working days",
          "1_method": "Bank transfers (SEPA)",
          "2_description": "Higher fees but quick and instant",
          "2_method": "Credit & debit cards",
          description: "Description",
          fee: "Fee",
          method: "Method"
        },
        title: "Payment methods and fees"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. MoonPay needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
        descriptionGeneric: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. However partner exchanges need to collect some information to operate. Please refer to their respective privacy policies to see in more detail how the data is handled.",
        title: "Data protection"
      },
      security: {
        description: "When you buy {{name}} via MoonPay, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        descriptionGeneric: "When you buy {{name}} via a partner exchange, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        link: "Security threat model",
        title: "Security model"
      },
      title: "Welcome to your one stop shop for buying {{name}}"
    },
    next: "Next",
    selectLabel: "Choose your account",
    selectPlaceholder: "Select a coin",
    skip: "Do not show again",
    title: "Buy {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket privacy policy",
      p1: "The BitBoxApp does not collect any data when buying bitcoin, the incoming funds are treated like a regular transaction. Pocket needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
      title: "Data protection"
    },
    kyc: {
      link: "Read Pocket FAQs",
      p1: "Pocket tries to keep KYC to a minimum. For purchases under 950 EUR (1000 CHF) a day, no additional documents are required. For purchases over this amount, you will need to schedule a call with Pocket to complete the necessary KYC/AML process.",
      title: "KYC/AML"
    },
    payment: {
      p1: "You can buy bitcoin instantly with Pocket via SEPA bank transfer. The fee is 1.5% and the bitcoin is deposited to your BitBox as soon as possible after Pocket receives the bank transfer (usually within the same day).",
      p2: "Please note that Pocket’s exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
      title: "Payment methods and fees"
    },
    previousTransactions: "The transaction history of this account is not empty. Sharing this account will make all its past and future transactions visible for Pocket. Proceed anyway?",
    security: {
      link: "BitBox02 security threat model",
      p1: "When you buy bitcoin via Pocket, you are using an external service. This service is out of scope of the BitBox02 Security Threat model and relies on the safety and security of the environment which the BitBoxApp software is running in. However we work together to improve security by using a two factor authentication mechanism to verify the address you are receiving to.",
      title: "Security model"
    },
    usedAddress: "The address {{address}} has been already used, please start again with a new address.",
    verifyBitBox02: "Please verify that the address you received via email matches the one displayed on your Bitbox. If possible, you should open the email on a second device for better security.",
    welcome: {
      p1: "We partner with Pocket to offer you a seamless way to buy bitcoin directly within the BitBoxApp. It's just a few clicks.",
      p2: "Pocket is a Swiss platform that makes it quick and easy to buy bitcoin in most of Europe (anywhere where SEPA bank transfers are supported).",
      p3: "With Pocket, you can also do regular buys through standing bank orders, so you can DCA (dollar-cost averaging) with ease.",
      title: "Welcome to your one stop shop for buying bitcoin"
    }
  },
  title: "Buy {{name}}"
}, changePin$f = {
  newTitle: "New device password",
  oldLabel: "Current device password"
}, chart$b = {
  dataMissing: "Gathering historical data... stay tuned.",
  dataOldTimestamp: "Historical exchange rates updating. The chart is not displaying data after {{time}}.",
  dataUpdating: "updating data…",
  filter: {
    all: "All",
    month: "Month",
    week: "Week",
    year: "Year"
  }
}, checkSDcard$f = "checking microSD card", clickHere$f = "Click here.", confirm$h = {
  abortInfo: "Tap to ",
  abortInfoRedText: "abort",
  approveInfo: "Hold 4+ secs to ",
  approveInfoGreenText: "confirm",
  info: "Continue on your BitBox. ",
  infoWhenPaired: "First on the paired mobile and then your BitBox"
}, confirmOnDevice$f = "Please confirm on your device.", connectKeystore$8 = {
  promptNoName: "Please connect your BitBox02 to continue",
  promptWithName: 'Please connect your BitBox02 named "{{name}}" to continue'
}, darkmode$9 = {
  toggle: "Dark mode"
}, device$f = {
  appUpradeRequired: "Your BitBox is not compatible with this desktop application. Please download and install the latest version.",
  keystoreConnected: "Connected wallet"
}, deviceLock$f = {
  button: "Enable two factor authorization (2FA)",
  condition1: "Do you have a backup?",
  condition2: "Is mobile app verification working?",
  condition3: "2FA DISABLES backups and mobile app pairing. The device must be RESET to exit 2FA!",
  confirm: "Enable two factor authorization (2FA)",
  title: "Enable two factor authorization (2FA)"
}, deviceSettings$f = {
  backups: {
    manageBackups: {
      description: "Create or verify your microSD card backup."
    },
    showRecoveryWords: {
      description: "Show and verify recovery words."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "The BitBoxApp checks if your device is authentic."
    },
    deviceName: {
      description: "Change the name of your device."
    },
    rootFingerprint: {
      description: "The root fingerprint is a unique identifier for the wallet currently in use. It can help you distinguish between different wallets if you use passphrases."
    },
    securechip: {
      description: "The model of the secure chip."
    },
    title: "Device information"
  },
  expert: {
    factoryReset: {
      description: "Reset your device to factory settings. This deletes the wallet from your BitBox02!",
      title: "Factory reset"
    },
    goToStartupSettings: {
      description: "Enter the bootloader of the BitBox02. You can enable the firmware hash from here."
    },
    passphrase: {
      description: "Enable or disable the passphrase feature.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Available version"
    },
    title: "Firmware",
    upToDate: "Your device is up to date",
    upgradeAvailable: "New upgrade available",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "Authenticity check failed",
      label: "Authenticity check",
      true: "Your BitBox02 is authentic"
    },
    sdcard: {
      false: "Not inserted",
      label: "microSD card",
      true: "Inserted"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Retrieving device info…",
  pairing: {
    lock: {
      false: "Disabled",
      label: "Two factor authorization (2FA)",
      true: "Enabled"
    },
    mobile: {
      false: "Closed",
      label: "Mobile app",
      true: "Open"
    },
    status: {
      false: "Not paired",
      label: "Status",
      true: "Paired"
    },
    title: "Pairing"
  },
  secrets: {
    manageBackups: "Manage backups",
    title: "Secrets"
  }
}, deviceTampered$f = "Has your BitBox been supplied with a recovery password? If so, stop the setup process and contact support immediately. Shift will never give you a ready made wallet or make password recommendations.", dialog$g = {
  cancel: "Cancel",
  confirm: "Confirm",
  confirmTitle: "Confirmation"
}, error$b = {
  accountAlreadyExists: "The account already exists.",
  accountLimitReached: "Cannot add account. The maximum number of accounts for this coin has been reached.",
  aoppCallback: "There was an error delivering the address to {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "There are no available accounts.",
  aoppSigningAborted: "Address ownership request cancelled.",
  aoppUnknown: "An unknown error occurred.",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "There are no available accounts that support the requested address format.",
  aoppUnsupportedKeystore: "The connected device cannot sign messages for this asset.",
  aoppVersion: "Unknown version.",
  wrongKeystore: "Wrong wallet connected. Please make sure to insert the correct device matching this account.",
  wrongKeystore2: " If you are using the optional passphrase, make sure you have entered the correct passphrase for the account."
}, fiat$h = {
  default: "default",
  setDefault: "Set {{code}} as default",
  title: "Currencies"
}, footer$h = {
  appVersion: "App version:"
}, generic$b = {
  enabled_false: "Disabled",
  enabled_true: "Enabled"
}, genericError$f = "An error occurred. If you notice any issues, please restart the application.", goal$f = {
  buttons: {
    create: "Create a new wallet",
    restore: "Restore a wallet from a backup"
  },
  paragraph: "Please select one of the following options:",
  step: {
    1: {
      title: "Security information"
    },
    2: {
      description: "Set a device password",
      title: "Device"
    },
    "3-create": {
      description: "Create a new wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "from a backup",
      title: "Restore"
    },
    "4-create": {
      title: "Summary"
    },
    "4-restore": {
      title: "Summary"
    }
  }
}, guide$g = {
  accountDescription: {
    text: "Your account overview shows your available balance as well as incoming and outgoing transactions. Our guide in ‘Settings’ has more information about each account type. ",
    title: "What does this page show me?"
  },
  accountFiat: {
    text: "Yes. Click on any ticker to rotate through fiat currencies. You can change the list of currencies in the settings.",
    title: "Can I display other conversion rates?"
  },
  accountIncomingBalance: {
    text: "Incoming sums up the amounts transferred to you but not yet confirmed by the network.",
    title: "What does incoming mean?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Each xpub is tied to the "Type" shown: either "Native Segwit (bech32)", "Wrapped Segwit" or “Taproot” (Bitcoin only). These are script types used by {{coinName}}. The BitBoxApp combines them, supporting multiple script types in the same account. Because each script type gives a different xpub, there are multiple xpubs per account.

If you consistently receive on the default address (Native Segwit), you only need the "bech32" xpub. However, if you also receive funds to "Wrapped Segwit" or “Taproot”, you also need to use the "Wrapped Segwit" and “Taproot” extended public keys respectively.`,
      title: "Why are there multiple xpubs?"
    },
    privacy: {
      text: `For this specific account, the extended public key reveals the entire financial history, your account balance, and all future transactions. But the xpub does not allow anyone to spend your coins.

If you give an xpub to someone, you should be aware that this person or company can see all other transactions of the same account. Therefore, it’s a good idea to use that account only for this purpose and keep other funds in different accounts.`,
      title: "Do I need to keep my xpub secret?"
    },
    verify: {
      text: "Yes, it’s always a good idea to double-check your xpub. If someone else will generate receive addresses from this xpub to send you money, this is especially important. You need to verify it on the device to ensure that this xpub belongs to you; otherwise, all funds could go to the wrong addresses.",
      title: "Do I need to verify the xpub on the device?"
    },
    xpub: {
      text: `An extended public key (xpub) is a root key from which all receiving addresses of an account are derived.

It is provided here for advanced use and interoperability with watch-only wallets, such as Electrum or Sentinel. If you received to different address types, please import all the different xpub formats into the watch-only wallet in order to see all your coins.

Please note, third party wallets may not support Taproot xpubs yet.`,
      title: "What is an extended public key?"
    }
  },
  accountRates: {
    text: "We update exchange rates every minute from CoinGecko.",
    title: "Which exchange rates apply?"
  },
  accountReload: {
    text: "There’s no need. Your transaction information is updated automatically.",
    title: "Can I reload the transaction history?"
  },
  accountSendDisabled: {
    text: "The ‘Send’ button is activated when your balance is more than zero.",
    title: "Why can't I send any {{unit}}?"
  },
  accountSummaryAmount: {
    text: `The total amount is the sum of all your crypto accounts. Exchange rates are obtained from coingecko.com.

Note: If you use MyEtherWallet for tokens not supported in the BitBoxApp, they will not be included in the amount displayed.`,
    title: "How is the total amount calculated?"
  },
  accountSummaryDescription: {
    text: "Here you can see the performance of your portfolio over time. A summary of your individual crypto accounts is displayed under the chart.",
    title: "What does this page show me?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtual size: Determines the network fee. You successfully saved on fees if it is smaller than the transaction size.
Size: Actual transaction size in bytes when serialized according to the underlying blockchain.
Weight: A new metric introduced with Segwit to evaluate transaction and block sizes. Each segregated witness byte counts as one, everything else as four weight units. Instead of one megabyte in actual size, the block size limit is now four million weight units.`,
    title: "What about the Bitcoin-specific transaction details?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmations: Your first transaction broadcast is unconfirmed until a miner includes it in a block, after which it has one confirmation. Each block broadcast on the network adds another confirmation to your transaction. Generally merchants and other network actors will only settle transactions with between three to six confirmations.
Transaction ID: A unique identification number that allows you to look up a transaction in a block explorer.
Fee: Miners are paid a transaction fee as an incentive to include transactions in the blocks they mine. To learn more, click on the send button.`,
    title: "What’s the information in the transaction details?"
  },
  accountTransactionConfirmation: {
    text: "A transaction broadcast to the network but not yet confirmed.",
    title: "What is a pending transaction?"
  },
  accountTransactionLabel: {
    text: "It’s the address you received coins from or sent coins to.",
    title: "Which address is displayed for each transaction?"
  },
  accountTransactionTime: {
    text: "The blockchain transaction confirmation time.",
    title: "What time is displayed?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin and Litecoin can have an arbitrary amount of accounts. After five accounts, you can only add another account if the previous account has been used. 
Other coins can have a maximum of five accounts.`,
      title: "How many accounts can I create?"
    },
    howtoAddTokens: {
      text: 'Tokens using the ERC20 standard are tied to a specific Ethereum account. To enable or disable a particular token, open the "Manage accounts" screen, expand your Ethereum account and switch the desired token on or off.',
      title: "How can I add additional tokens?"
    },
    moveFunds: {
      text: "Yes. But because accounts are independent, you need to send your funds using a regular transaction.",
      title: "Can I move funds between accounts?"
    },
    recoverAccounts: {
      text: "Yes. The BitBoxApp creates accounts using well-established standards compatible with most other crypto wallets.",
      title: "Can I recover my accounts with other wallets?"
    },
    whatAreAccounts: {
      text: "Your wallet can manage multiple accounts of the same coin. Accounts are helpful when you want to keep funds separate.",
      title: "What are accounts?"
    },
    whatIsRememberWallet: {
      text: `Enabling “Remember wallet” lets you see the accounts for this wallet in the BitBoxApp even when the BitBox02 is not plugged in. This allows you to check your balance and portfolio whenever you want. The BitBox02 still needs to be plugged in and unlocked to send or receive coins.

Disabling “Remember wallet” requires you to plug in the respective BitBox02 (or passphrase wallet) to see those accounts in the BitBoxApp.`,
      title: "What happens when I enable/disable “Remember wallet”?"
    },
    whyIsThisUseful: {
      text: 'Accounts are great for managing funds for different people or purposes because they are separated. You can also share the "extended public key" of an account without revealing anything about your other accounts. This allows you to repeatedly receive funds without reusing addresses, such as receiving your wage or regularly buying crypto.',
      title: "Why is this useful?"
    }
  },
  appendix: {
    link: "Contact us!",
    text: "Another question?"
  },
  backups: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet. It can also be used to verify that you still have the correct recovery password. You can check your main recovery password or your hidden recovery password.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: "No but your recovery password is required to derive the wallet from the stored seed.",
      title: "Can I encrypt the backup?"
    },
    howOften: {
      text: `The backup is automatically generated when a new wallet is created. You only have to make a new backup if your microSD card is lost or damaged, or if you want to use multiple microSD cards as backups.
You do not need to create new backups after transaction activity. All your transaction data can be recreated by your single backup that was automatically generated for you.`,
      title: "How often do I have to make a backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card. The seed together with your recovery password generates your wallet.",
      title: "What is a backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: 'No. Please keep the microSD card safe, as it contains the unencrypted seed to recover your wallet. If you wish to password-protect your seed, you can enable an optional passphrase in the expert settings under "Manage device".',
      title: "Can I encrypt the backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card.",
      title: "What is a backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `When 2FA is enabled, all transactions have to be approved on the paired mobile phone in order to spend coins. Under the hood, an encrypted single-use number is sent to the mobile app, decrypted there, and returned to the BitBox when pressing the Accept button. This communication with the device is done via the channel between the mobile phone and this desktop app established during pairing.

Be sure to backup your wallet and pair the mobile app before enabling 2FA. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.`,
      title: "How does Two factor authorization (2FA) work?"
    },
    disable2FA: {
      text: "In order to disable 2FA, you need to reset your BitBox and then restore the wallet from its backup. Make sure that you still have the microSD card with the backup and that you still remember the recovery password. Then press 'Reset device'. Set a new device password and choose 'Or restore a backup'. Select the backup you have made from the wallet, click 'Restore' and enter the recovery password you used when creating the wallet.",
      title: "How can I disable two factor authorization (2FA)?"
    },
    ejectBitbox: {
      text: "You can unplug the BitBox at any time without having to eject it first.",
      title: "How can I eject the BitBox?"
    },
    ejectSD: {
      text: "You can remove the microSD card from the BitBox at any time as long as you are not in the process of creating or restoring a backup.",
      title: "How can I eject the microSD card?"
    },
    hiddenWallet: {
      text: "It is a second wallet on the same device protected by a different device password and recovery password, which you can use for plausible deniability. The same backup seed is used for both your normal and hidden wallet, so no additional backup is required.",
      title: "What is a hidden wallet?"
    },
    legacyHiddenWallet: {
      text: "First click the button below (available if the BitBox is unlocked with the main device password and 2FA is disabled), then replug your Bitbox and unlock it with your hidden device password.",
      title: "How do I access the legacy hidden wallet?"
    },
    pairing: {
      text: "After having downloaded our mobile app for either iOS or Android, you scan the displayed QR code, which sets up a secure channel between the mobile app and this application. Once scanned, follow the instructions in the mobile app.",
      title: "How to securely pair with your phone"
    }
  },
  cointracking: {
    text: 'Click the "Export" button and open the downloads folder where you will find the CSV export. Then click the link below, upload your BitBox CSV file and import the data in order to use it for your CoinTracking portfolio manager and to create your tax reports.',
    title: "How to import my transactions into CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Read more about the authenticity check"
      },
      text: "The BitBoxApp performs an attestation check on the BitBox02 to verify if the device is genuine. The check is done locally and does not connect to any servers.",
      title: "How does the authenticity check work?"
    },
    name: {
      text: "This is the name of your wallet and backup. The name is used for future backups and can be used to help distinguish between different wallets. It can be changed at any time but note that backups made before the change will still use the previous name.",
      title: "What is the BitBox02 name used for?"
    },
    "secure-chip": {
      link: {
        text: "Read more about the secure chip"
      },
      text: "This information shows the model number of the secure chip, the most up to date chip is ATECC608B with improved security features compared to older models.",
      title: "Why show the secure chip model?"
    }
  },
  receive: {
    address: {
      text: "You can give the address to others to send you some coins. Just make sure they are sending to the correct address.",
      title: "What do I do with an address?"
    },
    addressChange: {
      text: "As soon as you transact, a new address is automatically added to the list so there are always 20 addresses available which have never received any coins.",
      title: "When do the addresses change?"
    },
    addressFormats: {
      text: "By default, the address type is Native Segwit. This address type is widely adopted by other wallets/exchanges and gives you the best fee rates for everyday transactions. However, you may also choose to send to Taproot (Bitcoin only), which is the newest address type, but may not be widely supported yet. Alternatively, if you are having issues sending to Native Segwit (the default type), you can try switching to the older Wrapped Segwit address type that may be compatible with more wallets/exchanges.",
      title: "When do I use “Change address type”?"
    },
    howVerify: {
      text: `For the BitBox01, click on the BitBox icon in the sidebar on the left and see the Pairing section. The guide will update and you can continue following the instructions from there.
For the BitBox02, you can verify addresses directly on the device during the send/receive process.`,
      title: "How can I verify an address securely?"
    },
    plugout: {
      text: "No, once you sent coins to your BitBox address, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while receiving?"
    },
    why20: {
      text: 'During start-up the app generates addresses derived from your seed to see if they have received funds. As the app can generate an almost infinite number of addresses, it could spend years determining the balance. To limit this search it stops after it sees 20 addresses that have never received funds. This is the "gap limit" and 20 is a de-facto standard though the number is arbitrary. These are the 20 addresses you can choose from.',
      title: "Why only 20 addresses?"
    },
    whyMany: {
      text: "To maintain privacy and security, never hand out the same address twice. If you have used an address, click on on the right arrow for a new address. You can generate up to 20 addresses at a time. Think of addresses like invoice numbers. All addresses are derived from your single backup seed.",
      title: "Why so many addresses?"
    },
    whyVerify: {
      text: "You shouldn’t trust your computer to generate and display authentic addresses. It’s big attack surface makes it significantly more vulnerable than a hardware wallet. For the BitBox01, The button to verify the address securely sends the address to a paired mobile phone, from which you can also scan and verify the QR code. For the BitBox02, the address can be verified directly on the BitBox02 display.",
      title: "Why should I verify the address securely?"
    }
  },
  send: {
    change: {
      text: "The change will be returned to a Taproot address if you have at least one Taproot UTXO. If you use coin control, the change will be returned to a Taproot address if there is at least one Taproot UTXO among the selected UTXOs. In all other cases, the change is returned to a Native Segwit address.",
      title: "How is the change output determined?"
    },
    fee: {
      text: `The fee is based on the transaction data size and not its amount. The fee targets are calculated by Bitcoin Core's fee estimation algorithm for each network priority you chose. They are shown if they have a different value from the target below.
Economy: 24 blocks (around 4 hours for Bitcoin, 1 hour for Litecoin)
Low: 12 blocks (around 2 hours for Bitcoin, 30 minutes for Litecoin)
Normal: 6 blocks (around 1 hour for Bitcoin, 15 minutes for Litecoin)
High: 2 blocks (around 20 minutes for Bitcoin, 5 minutes for Litecoin)
(A block takes on average ten minutes for Bitcoin (2.5 minutes in Litecoin) to mine and the network load may vary considerably in the above periods.)`,
      title: "How is the fee determined?"
    },
    plugout: {
      text: "No, once you have made a transaction, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while sending?"
    },
    priority: {
      text: "The higher fee you are willing to pay, the faster your transaction is typically confirmed by the network.",
      title: "What is the network priority?"
    },
    revert: {
      text: `Once a transaction is signed and sent (i.e. broadcasted to the network), it can no longer be reverted. Verify the transactions (including the fee) properly before signing!
If you know the recipient and he or she is willing to send the same amount (minus the transaction fees) back to you, you can send them a new receiving address.`,
      title: "Can I revert a transaction?"
    },
    whyFee: {
      text: `Transactions are competing to be confirmed by a miner. Miners choose transactions to be included in the blockchain based on their fee.
Miners vote on the history of transactions. Since there is no trusted third party to enforce one vote per person (which is the whole point of blockchains), miners vote on transactions by sacrificing a costly resource like computing power. As a reward for their work, they can claim newly created coins and the fee of all the transactions they included.`,
      title: "Why is there a network fee?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `If you intend to only connect to your node when you are on the same network (e.g. your home wifi), then using regular network communication is sufficient.
In this case it is advisable that your Electrum server provides a TLS certificate to encrypt the communication.
If you intend to connect to your node from anywhere, using Tor is the better option. No TLS certificate is necessary in that case.`,
      title: "Should I use clearnet TCP, TLS or Tor?"
    },
    instructions: {
      link: {
        text: "Guide to connect your node"
      },
      text: "For a full tutorial, please visit our guide:",
      title: "How do I connect my BitBoxApp to my own full node?"
    },
    options: {
      text: `There are multiple options to run your own node such as buying a finished device, building your own or running Bitcoin Core.
If you want to connect your BitBoxApp to your node, make sure that it runs an Electrum server. This is a dedicated program that allows a wallet app to communicate with your full node.
Supported options include Electrs, Electrum Personal Server (EPS) or Bitcoin Wallet Tracker (BTW).`,
      title: "What options are there to run a node?"
    },
    tor: {
      text: `Tor stands for 'The Onion Router', which is a free and open source software that offers a lot of privacy benefits and is especially useful when using Bitcoin.
If you intend to connect to your node via Tor, make sure that Tor is installed on your computer and then enable the Tor Proxy in the BitBoxApp settings.
On most operating systems there are two ways to run Tor:
1. Tor Browser: download and open the Tor Browser. This will allow the BitBoxApp to connect to the Tor network by setting port 9150 in the Tor proxy settings.
2. Tor background service: install the Tor daemon, which always runs in the background. The BitBoxApp can then connect by setting port 9050 in the Tor proxy settings.`,
      title: "What is Tor, Tor proxy and which port should I use?"
    },
    what: {
      text: "It is possible to power your wallet with your own full nodes instead of using Shift servers.",
      title: "What is this?"
    },
    why: {
      text: `Running your own node is not necessary but improves privacy and reduces the need to trust others.
Firstly, it means that you are using Bitcoin more privately as the BitBoxApp won't connect to our servers to fetch your transaction history; instead it will fetch that information from your own node.
Secondly, running your own node means that your node verifies all transactions itself, making sure that the consensus rules are enforced.`,
      title: "Why should I run my own node?"
    }
  },
  settings: {
    sats: {
      text: "A Satoshi ('sat' for short) is the smallest unit of Bitcoin. One Satoshi is a hundred millionth of a bitcoin (0.00000001 BTC). It is named after the creator of Bitcoin, Satoshi Nakamoto.",
      title: "What is a Satoshi?"
    },
    servers: {
      text: `This app communicates with the Shift Crypto servers to check for updates, load transactions, and send information to paired mobile apps.
The app also retrieves the latest exchange rates from CoinGecko. All conversions are calculated locally which means no data about the amount of your transaction is ever transmitted.
Note: For Ethereum and ERC20 Tokens, we use Etherscan.io APIs.`,
      title: "Which servers does this app talk to?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Close guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "On desktop, hover the cursor over the chart. On mobile, hold your finger on the chart and drag horizontally.",
    title: "How to see historical values on the chart?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "You have to reset the device and restore the wallet from a backup, using the recovery password.",
      title: "What do I do if I forgot the device password?"
    },
    reset: {
      text: "Enter a wrong device password 15 times. The last few attempts require a long touch on the device.",
      title: "How do I reset the device?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `The device should blink once when inserted. Make sure that it is inserted the right way around. If you are having trouble, please contact us through the link below.

The BitBox01 is not supported on mobile. Please use the BitBoxApp on desktop to connect your BitBox01.`,
      title: "My BitBox01 is not recognized"
    },
    getDevice: {
      link: {
        text: "Order a BitBox"
      },
      text: "You can buy a BitBox in our online shop:",
      title: "How can I get a device?"
    },
    internet: {
      text: "Yes, an internet connection is required to synchronize the wallet, send transactions and retrieve the latest exchange rates.",
      title: "Does this app require an internet connection?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "You can recover your accounts on a new BitBox or with our backup center.",
      title: "I lost my device. Now what?"
    },
    useWithoutDevice: {
      text: "Unfortunately, this is not yet possible at the moment.",
      title: "Can I use the app without a device?"
    },
    welcome: {
      text: "Thanks for using this app built by Shift Crypto in Switzerland. We appreciate any input you have to share. Please give feedback using the link at the bottom.",
      title: "Welcome to the BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "If you are using a new phone/computer with the BitBoxApp, then you will need to connect to the DApps again. You will then see your coins on the dapp again like usual.",
      title: "I don't see my previous connections."
    },
    supportedNetworks: {
      text: "Currently, only Ethereum mainnet is supported using WalletConnect in the BitBoxApp. To use other EVM compatible chains please use the Rabby browser extension wallet.",
      title: "What networks are supported?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is a communication protocol for web3 applications. It allows you to conveniently connect to Ethereum based DApps and web wallets without using a third party app, which is particularly useful for Android users of the BitBoxApp.",
      title: "What is WalletConnect?"
    }
  }
}, headerssync$f = {
  blocksSynced: "{{blocks}} blocks synced"
}, hiddenWallet$f = {
  info1HTML: "For plausible deniability purposes, a hidden wallet can be created based on a <strong>different</strong> device password + recovery password combination.",
  info2HTML: "Define the device password and recovery password you want to associate with your hidden wallet below. The device password and recovery password must be <strong>different</strong> from the ones you defined for your primary wallet.",
  passwordLabel: "Hidden recovery password",
  passwordPlaceholder: "Please confirm hidden recovery password",
  pinLabel: "Hidden device password",
  pinRepeatLabel: "Repeat hidden device password",
  pinRepeatPlaceholder: "Please confirm hidden device password",
  success: "Hidden wallet created successfully. Replug your BitBox to unlock it."
}, initialize$f = {
  create: "Set device password",
  creating: "Setting device password…",
  error: {
    e102: "The device password must consist of at least 4 characters."
  },
  info: {
    description1: "Choose your device password. This will be used to unlock your BitBox.",
    description2: "You can use numbers, letters & symbols. Longer passwords offer higher security.",
    description3: "If you lose the device password you will have to reset your device and restore your wallet backup.",
    subtitle: "Now you will set your device password",
    title: "Initializing your device"
  },
  input: {
    label: "Device password",
    labelRepeat: "Repeat device password",
    placeholderRepeat: "Please confirm device password"
  }
}, invalidFormat$f = "Invalid format", language$g = {
  title: "Select language"
}, legacyhiddenwallet$f = {
  disable: "Disable legacy hidden wallet",
  enable: "Enable legacy hidden wallet",
  successDisable: "Successfully disabled the legacy hidden wallet.",
  successEnable: "Successfully enabled the legacy hidden wallet. Replug your BitBox and enter the hidden device password to access the legacy hidden wallet."
}, loading$f = "loading…", manageAccounts$9 = {
  accountHidden: "This account has been hidden from your watch-only accounts. To see it again, please plug in your BitBox02.",
  editAccount: "Edit",
  editAccountNameTitle: "Edit account name",
  noAccounts: "no accounts found",
  settings: {
    hideTokens: "Hide tokens",
    showTokens: "Show tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Add and show/hide accounts",
  title: "Manage accounts",
  watchAccount: "Watch account",
  watchAccountDescription: "This account is part of your watch-only accounts. You can hide it from your watch-only accounts using the toggle."
}, mobile$a = {
  usingMobileDataWarning: "Mobile data usage: this app may download up to a few hundred megabytes of blockchain header data after unlocking an account. Please connect to Wi-Fi to avoid using mobile data. After dismissing it, this message won't be shown again."
}, newSettings$8 = {
  about: {
    appVersion: {
      title: "App version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Lock access to the app with screen lock/fingerprint.",
      title: "Screen lock"
    },
    coinControl: {
      description: "Select which UTXOs are part of a transaction to help improve privacy."
    },
    customFees: {
      description: "Lets you enter your own fee when sending."
    },
    torProxy: {
      description: "Connect over Tor for better privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "These additional currencies can be toggled through on your account page.",
      title: "Active currencies"
    },
    darkmode: {
      description: "See the BitBoxApp in dark mode."
    },
    defaultCurrency: {
      description: "Select your default currency",
      title: "Default currency"
    },
    enableAccount: {
      description: "Disabling your account means it will not appear in the sidebar or the portfolio. You can always enable it again from here. Coins on this account will not be affected and will remain safe.",
      title: "Enable/disable account"
    },
    hideAmounts: {
      description: "Displays a toggle to hide your balance and amounts to improve your privacy when using the app in public.",
      hideAmounts: "Hide amounts",
      showAmounts: "Show amounts",
      title: "Allow hiding amounts"
    },
    language: {
      description: "Which language you want the BitBoxApp to use.",
      title: "Language"
    },
    remebmerWallet: {
      name: "Remember wallet",
      warning: "This will remove your remembered wallet. To see it again, you will need to plug in the BitBox02 for this wallet. Any coins on this wallet are not affected. Do you want to continue?",
      warningTitle: "Disable remember wallet"
    },
    toggleSats: {
      description: "Enable or disable Satoshis."
    }
  }
}, note$b = {
  input: {
    description: "(optional)",
    placeholder: "Add note…"
  },
  title: "Note"
}, notification$f = {
  newTxs_one: "New transaction in: {{accountName}}",
  newTxs_other: "{{count}} new transactions in: {{accountName}}"
}, pairing$f = {
  aborted: {
    text: "The pairing has been aborted from the mobile app.",
    title: "Aborted"
  },
  button: "Pair mobile app",
  confirm: "Are you sure you want to pair your BitBox? Note that after, the mobile phone is required to perform a transaction.",
  connectOnly: {
    button: "Connect mobile app",
    title: "Scan with our mobile app by selecting the menu item 'Connect to new desktop app'"
  },
  error: {
    text: "Something went wrong. Please start again.",
    title: "Error"
  },
  pullFailed: {
    text: "Failed to pull a message from your mobile through the relay server. The relay server might be offline, please contact support.",
    title: "Pull failed"
  },
  reconnectOnly: {
    button: "Reconnect mobile app"
  },
  scanningFailed: {
    text: "Mobile was not able to scan the message successfully. Please try again.",
    title: "Scanning Failed"
  },
  start: {
    hideAppQRCode: "Hide QR code",
    revealAppQRCode: "Show QR code",
    step1: "If you do not have the mobile app, you can scan the QR code for the Apple App Store or the Google Play Store depending on which phone you have.",
    step2: "Scan with our mobile app, which you can find under the name 'Digital Bitbox 2FA' in the app stores for iOS and Android:"
  },
  started: {
    text: "Now please follow the instructions in the mobile app.",
    title: "Great"
  },
  success: {
    text: "Congratulations, you successfully paired your BitBox with the mobile app!",
    title: "Success"
  },
  timeout: {
    text: "The pairing timed out after two minutes. Start again if you still want to pair the mobile app.",
    title: "Timeout"
  },
  title: "Mobile pairing"
}, passphrase$9 = {
  considerations: {
    button: "Backup considerations",
    message: `The passphrase adds a layer of protection to your wallet backup (microSD card or recovery words). If someone has access to your backup they will also need the passphrase to access your wallet.

However, this means you will need <strong>both the passphrase + wallet backup</strong> to restore your passphrase-enabled wallet, in case your BitBox02 is lost or broken. If you forget or lose your passphrase, you will lose access to all the coins on that wallet.

When storing your passphrase, consider putting it in a separate location than your backup. That way if someone finds your backup they don’t find your passphrase as well.`,
    title: "Backup considerations"
  },
  disable: "Disable passphrase",
  disableInfo: {
    button: "Disable",
    message: `After disabling the passphrase, you will no longer be asked to enter a passphrase after unlocking your BitBox02. Therefore, you will enter your default wallet.

Any coins on your passphrase-wallet will still be on that wallet, however you won’t be able to access them because after unlocking your BitBox02, you will open your default wallet.

To access your passphrase-wallets again, simply re-enable the passphrase feature and enter the relevant passphrase after unlocking the BitBox02.

<strong>Tip:</strong> You can still enter your original wallet by leaving the passphrase empty.`
  },
  enable: "Enable passphrase",
  error: {
    e104: "Changing the passphrase setting was aborted."
  },
  how: {
    button: "What it looks like",
    message: `A passphrase doesn’t work like a password that you’re used to. If you mistype your passphrase, you will not be notified. This is because <strong>every passphrase creates a different, yet valid, wallet</strong>. This means you can use multiple passphrases for as many wallets as you want. But each wallet can only be accessed when typing in the corresponding passphrase.

When plugging in your BitBox02, you’ll be prompted for the device password as usual. After that, you’ll be asked to enter a passphrase on the device.

After entering the passphrase, you’ll be shown the passphrase you entered. This is so you can confirm you entered it correctly.`,
    title: "How does it work"
  },
  intro: {
    message: `A passphrase provides an additional layer of security on top of your wallet.
Let’s learn how it works.`,
    title: "Setup passphrase"
  },
  progressDisable: {
    message: "Confirm on your BitBox that you want to <strong>disable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  progressEnable: {
    message: "Confirm on your BitBox that you want to <strong>enable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  successDisabled: {
    message: `Optional passphrase <strong>successfully enabled</strong>!
You’ll be asked to provide a passphrase from now on.`,
    messageEnd: "Please replug the BitBox02 now.",
    title: "Passphrase enabled"
  },
  successEnabled: {
    message: `Optional passphrase <strong>successfully disabled</strong>!

You will not be asked to provide a passphrase anymore.`,
    messageEnd: "Please replug your BitBox02 now.",
    tips: "Tips",
    tipsList: [
      "We suggest sending a small amount to the passphrase wallet first. Then unplug and replug the BitBox02 and enter your password and passphrase. If you entered the passphrase correctly, you should see the coins in your wallet.",
      "If you want to enter your original wallet without a passphrase, you can still do this by entering nothing when prompted to enter the passphrase. Or you can disable the passphrase feature."
    ],
    title: "Passphrase disabled"
  },
  summary: {
    button: "Enable passphrase",
    title: "Summary",
    understand: "I understand how the passphrase works and the risks associated with it.",
    understandList: [
      "The passphrase is an additional layer of security on top of your backup.",
      "Entering a different passphrase will always generate a different wallet.",
      "To restore your wallet you need <strong>both the passphrase and backup</strong>.",
      "If you forget your passphrase, you can <strong>no longer access your coins</strong>."
    ]
  },
  what: {
    button: "Learn how this works",
    message: `A wallet is created (derived) from a very big random number, also known as a seed. This seed is created when you first set up your BitBox02 and is backed up with the microSD card or recovery words. Anyone who has access to the seed has full control over the funds on that wallet.

A passphrase is an <strong>optional secret</strong>, added to the seed. When using a passphrase, each passphrase creates a new wallet based on the seed + passphrase (optional secret). A passphrase can be anything: letters, words, special characters or it can even be empty. The default wallet is in fact derived from the seed + empty passphrase.

The passphrase is part of the BIP39 standard, which means it is compatible with all wallets that support the same standard.`,
    title: "What is a passphrase?"
  },
  why: {
    button: "Why use a passphrase",
    message: `The BitBox02 protects the seed against extraction from the device itself, but the backup (microSD card or recovery words) gives full access to the wallet. That is why it should be stored in a secure location!

Since a passphrase creates a new wallet using your existing seed, the passphrase-wallet requires both your <strong>backup AND passphrase to restore</strong>. The benefit of this is if someone finds your backup, they still need the passphrase to access the passphrase-wallet.

Additionally, the passphrase feature allows you to create multiple wallets on the same device, or “hidden wallets” in addition to the default one.`,
    title: "Why use a passphrase?"
  }
}, password$f = {
  show: "Show {{label}}",
  warning: {
    caps: "WARNING: caps lock (⇪) is enabled",
    paste: 'to paste text, enable "SHOW {{label}}"'
  }
}, random$g = {
  button: "Generate random number",
  description: "Your BitBox generated the following {{bits}}-bit random number:"
}, receive$h = {
  changeScriptType: "Change address type",
  label: "Your address",
  onlyThisCoin: {
    description: "To receive other tokens, enable them in the settings. If you deposit other tokens, they might not be accessible.",
    warning: "Make sure to only receive {{coinName}} on this address."
  },
  scriptType: {
    p2tr: "Taproot (newest format)",
    p2wpkh: "Native Segwit (default)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatible format)"
  },
  selectAccount: "Select account",
  showFull: "Show and verify full address on device",
  taprootWarning: "Note: Taproot is a new Bitcoin feature and is not yet widely adopted. Funds received on Taproot addresses may not be visible in third party watch-only wallets. Many wallets and exchanges are not yet able to send to Taproot addresses.",
  title: "Receive {{accountName}}",
  verify: "Verify address securely",
  verifyBitBox01: "Verify address on mobile app",
  verifyBitBox02: "Verify address on BitBox02",
  verifyInstruction: "Please verify that the following address matches the one displayed on your device.",
  warning: {
    secureOutput: "Please pair your BitBox with your mobile device to enable secure address verification. Go to 'Manage device' in the sidebar."
  }
}, reset$f = {
  description: "All data will be deleted from this device. That includes your Private Key!",
  notReset: "Device NOT reset.",
  title: "Factory reset device",
  understand: "I have a backup and know my recovery password",
  understandBB02: "I have a valid backup"
}, securityInformation$f = {
  create: {
    description1: "We recommend you set up your device in a safe environment, meaning you are away from other people that could see what password you choose.",
    description2: "You will be asked to create two passwords.",
    description3: "The first is the <strong>device password</strong> which unlocks your BitBox device and can be changed later.",
    description4: "The second is the <strong>recovery password</strong> which unlocks your wallet. This password cannot be changed later.",
    description5: "The wallet you create will be backed up to a file on the microSD card provided. This can be used in an emergency to recover your funds using your <strong>recovery password</strong>.",
    title: "Security information"
  },
  restore: {
    description1: "You will be asked to insert the microSD card you used to store you backup.",
    description2: "To restore your device you will need your recovery password. ",
    description3: "Please take care when entering the recovery password. Any password you enter will create a valid wallet. If you enter the wrong password you may be shown a wallet balance that you do not expect.",
    title: "Security information"
  }
}, seed$f = {
  agreements: {
    "funds-access": "I will NOT be able to access my funds if I forget my recovery password",
    "password-change": "I can NOT change the recovery password later",
    "password-required": "The recovery password is required to restore a wallet from a backup"
  },
  create: "Create wallet",
  creating: "Creating wallet",
  description: "I understand that:",
  error: {
    e102: "The password must consist of at least 4 characters.",
    e200: "You need to insert a microSD card into your BitBox in order to create a wallet, so a backup can be created automatically."
  },
  info: {
    button: "Set recovery password now",
    description1: "Insert the microSD card into the BitBox",
    description2: "Choose a recovery password for the wallet and select “Set recovery password now”",
    description3: "The back up to microSD card and your recovery password is the only method to recover your funds in case of lost or stolen BitBox device.",
    description4: "You cannot change your recovery password later on without transferring your funds.",
    title: "Create a new wallet"
  },
  password: {
    label: "Recovery password",
    repeatPlaceholder: "Repeat recovery password"
  },
  walletName: {
    label: "Wallet name"
  }
}, seedRestore$f = {
  error: {
    e200: "Restoring a wallet from a backup requires the microSD card."
  },
  info: {
    description1: "Insert the microSD card into the BitBox and click “Continue”",
    description2: "Choose a backup and click “Restore”",
    description3: "Enter the recovery password",
    description4: "You need to confirm to understand that an incorrect password will create a different wallet.",
    title: "How to restore a wallet from a backup"
  }
}, send$h = {
  abort: "The transaction has been aborted.",
  address: {
    label: "Receiver address",
    placeholder: "Enter address"
  },
  amount: {
    label: "Amount",
    placeholder: "Enter amount"
  },
  availableBalance: "Available balance",
  button: "Review",
  coincontrol: {
    address: "Address",
    outpoint: "Outpoint",
    title: "Send from output"
  },
  confirm: {
    "selected-coins": "Selected coins",
    title: "Confirm and send transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "It seems like you do not have enough Ether to pay for this ERC20 transaction. Please make sure you hold enough Ether in your wallet",
    feeTooLow: "fee too low",
    feesNotAvailable: "Could not estimate fees",
    insufficientFunds: "insufficient funds",
    invalidAddress: "invalid address",
    invalidAmount: "invalid amount",
    invalidData: "invalid data"
  },
  fee: {
    customPlaceholder: "Enter amount",
    label: "Network fee",
    placeholder: "Not available"
  },
  feeTarget: {
    customLabel: "Fee rate",
    customLabel_eth: "Gas price",
    description: {
      economy: "4 hours (24 blocks)",
      economy_eth: "30 minutes or less",
      economy_ltc: "1 hour (24 blocks)",
      high: "20 minutes (2 blocks)",
      high_eth: "30 seconds or less",
      high_ltc: "5 minutes (2 blocks)",
      low: "2 hours (12 blocks)",
      low_eth: "5 minutes or less",
      low_ltc: "30 minutes (12 blocks)",
      normal: "1 hour (6 blocks)",
      normal_eth: "2 minutes or less",
      normal_ltc: "15 minutes (6 blocks)"
    },
    estimate: "Estimated confirmation time:",
    label: {
      custom: "Custom",
      economy: "Economy",
      high: "High",
      low: "Low",
      normal: "Normal"
    },
    placeholder: "Calculating fee…"
  },
  maximum: "Send all",
  maximumSelectedCoins: "Send selected coins",
  noFeeTargets: "Fee rate estimations are currently unavailable. Please try again later or enter a custom fee.",
  priority: "Priority",
  scanQR: "Scan QR code",
  signprogress: {
    description: "This is a transaction containing a lot of data. To fully sign the transaction, you will be asked to confirm {{steps}} times.",
    label: "Progress"
  },
  success: "The transaction has been signed and sent.",
  title: "Send {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Transaction details"
}, settings$g = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Advanced settings",
  appearance: "Appearance",
  electrum: {
    add: "Add a server",
    "add-server": "Add",
    check: "Check",
    checkFailed: "Failed",
    checkSuccess: "Successfully established a connection to {{host}}",
    checking: "Checking",
    "download-cert": "Download remote certificate",
    "remove-server": "Remove",
    removeConfirm: "Remove {{server}}?",
    reset: "Reset to default",
    resetConfirm: "Do you want to remove all servers and install the default servers?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Enter the endpoint.",
    step2: "2",
    "step2-text": "Enter a certificate of the server's certificate chain. Alternatively, download the remote certificate and compare it visually.",
    "step2-text-tcp": "You can skip this step if you do not want to use TLS.",
    step3: "3",
    "step3-text": "Check the connection and add the server.",
    step4: "4",
    "step4-text": "Restart the wallet. If you do not remove the default servers, your own node will be added as a redundancy.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Enable coin control",
    electrum: {
      description: "You can connect to your own Electrum full node.",
      title: "Connect your own full node"
    },
    fee: "Enable custom fees",
    setProxyAddress: "Set proxy address",
    title: "Expert settings",
    useProxy: "Enable tor proxy",
    useSats: "Display BTC values in Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "New update available",
    title: "Info",
    "up-to-date": "Your app is up to date",
    version: "App Version"
  },
  restart: "Please re-start the BitBoxApp for the changes to take effect.",
  services: {
    title: "Services"
  },
  success: "Please unplug and replug the BitBox for the changes to take effect.",
  title: "Settings"
}, setup$f = "Setup device", sidebar$g = {
  buy: "Buy crypto",
  device: "Manage device",
  leave: "Leave",
  settings: "Settings"
}, success$m = {
  create: {
    info1: "Your wallet has been securely backed up to the microSD Card. Remove it and keep it safe.",
    info2: "You have created a secure device password that unlocks the BitBox.",
    info3: "You have created a secure recovery password for your wallet that unlocks your funds and restores your backups.",
    summary: "Here is a summary of what you have done",
    title: "Success"
  },
  getstarted: "Get started",
  restore: {
    summary: "You have successfully restored a wallet from your backup.",
    title: "Success"
  }
}, transaction$g = {
  confirmation: "Confirmations",
  details: {
    activity: "Activity",
    address: "Address",
    amount: "Amount",
    date: "Date",
    fiat: "Fiat",
    fiatAmount: "Fiat amount",
    fiatAtTime: "Fiat at time of transaction",
    status: "Status",
    type: "Type"
  },
  explorer: "Transaction ID",
  explorerTitle: "Open in external block explorer",
  fee: "Fee",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "Edit note",
    save: "Save note"
  },
  pending: "Pending transaction",
  size: "Size",
  status: {
    complete: "Complete",
    failed: "Failed",
    pending: "Pending"
  },
  tx: {
    received: "Received to",
    sent: "Sent to"
  },
  vsize: "Virtual size",
  weight: "Weight"
}, transactions$f = {
  errorLoadTransactions: "There was an error loading the transactions",
  placeholder: "No transactions yet."
}, unknownError$f = "An unknown error occurred: {{errorMessage}}", unlock$f = {
  description: "Enter your device password to unlock your device.",
  error: {
    e109_normal: "Wrong device password. {{remainingAttempts}} attempts remain before the device is reset.",
    e109_touch: "$t(unlock.error.e109_normal) The next login requires holding the touch button.",
    e113: "Due to many login attempts, the next login requires holding the touch button for 4 seconds."
  },
  input: {
    label: "Device password",
    placeholder: "Enter your device password to unlock the device"
  },
  unlocking: "Unlocking…"
}, upgradeFirmware$g = {
  button: "Upgrade firmware",
  description: "Do you want to upgrade the firmware from version {{currentVersion}} to {{newVersion}}?",
  label: "Your BitBox requires a firmware upgrade.",
  locked: "To upgrade from {{currentVersion}} to {{newVersion}}, please do a long touch.",
  title: "Upgrade firmware",
  unlocked: "The bootloader is unlocked. To continue, please:",
  unlocked1: "Unplug and replug your Bitbox",
  unlocked2: "The LED will light up when your BitBox is plugged back in",
  unlocked3: "Tap the touch button when the LED lights up"
}, walletConnect$9 = {
  connect: {
    button: "Connect",
    dappLabel: "Enter URI address of dapp",
    invalidPairingUri: "Invalid pairing uri"
  },
  dashboard: {
    allSessions: "All sessions",
    disclaimer: "Walletconnect is a protocol to connect to Ethereum based Dapps. These dapps are run by third-party services, so only connect to dapps you trust and be sure to always know what you are signing when making a transaction.",
    newConnection: "New connection",
    noConnectedSessions: "No accounts are currently connected to any dapps."
  },
  invalidPairingChain: "Error in approving pairing. Please make sure to use one of the supported chains: {{chains}}",
  pairingRequest: {
    approve: "Approve Connection",
    reject: "Reject",
    title: "New connection request from"
  },
  pairingSuccess: "Dapp successfully connected. You can continue on the dapp website.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Failed to parse data",
    decodeError: "Failed to decode message",
    method: {
      sendTransaction: "Sign and send transaction",
      signMessage: "Sign message",
      signTransaction: "Sign transaction",
      signTypedData: "Sign typed data"
    },
    successfullySigned: "Request succesfully signed",
    walletConnectRequest: "WalletConnect request"
  },
  useNewUri: "This URI has already been used to attempt a connection. Please use a new URI.",
  walletConnect: "WalletConnect"
}, warning$l = {
  receivePairing: "Please pair the BitBox to enable secure address verification. Go to 'Manage device' in the sidebar.",
  sdcard: "Keep the microSD card stored separate from the BitBox, unless you want to manage backups.",
  sendPairing: "Please pair the BitBox to securely verify transaction details. Go to 'Manage device' in the sidebar."
}, welcome$f = {
  connect: "Connect BitBox02",
  getStarted: "Let's get started by installing firmware on your BitBox02.",
  insertBitBox02: "For the BitBox02, please tap the device to continue.",
  insertDevice: "Please connect your device to get started",
  title: "Welcome"
}, appTranslationsEN = {
  account: account$f,
  accountInfo: accountInfo$f,
  accountSummary: accountSummary$f,
  addAccount: addAccount$g,
  aopp: aopp$9,
  app: app$f,
  auth: auth$8,
  backup: backup$f,
  bb02Bootloader: bb02Bootloader$f,
  bitbox: bitbox$f,
  bitbox02Interact: bitbox02Interact$f,
  bitbox02Settings: bitbox02Settings$f,
  bitbox02Wizard: bitbox02Wizard$f,
  blink: blink$f,
  bootloader: bootloader$f,
  button: button$j,
  buy: buy$b,
  changePin: changePin$f,
  chart: chart$b,
  checkSDcard: checkSDcard$f,
  clickHere: clickHere$f,
  confirm: confirm$h,
  confirmOnDevice: confirmOnDevice$f,
  connectKeystore: connectKeystore$8,
  darkmode: darkmode$9,
  device: device$f,
  deviceLock: deviceLock$f,
  deviceSettings: deviceSettings$f,
  deviceTampered: deviceTampered$f,
  dialog: dialog$g,
  error: error$b,
  fiat: fiat$h,
  footer: footer$h,
  generic: generic$b,
  genericError: genericError$f,
  goal: goal$f,
  guide: guide$g,
  headerssync: headerssync$f,
  hiddenWallet: hiddenWallet$f,
  initialize: initialize$f,
  invalidFormat: invalidFormat$f,
  language: language$g,
  legacyhiddenwallet: legacyhiddenwallet$f,
  loading: loading$f,
  manageAccounts: manageAccounts$9,
  mobile: mobile$a,
  newSettings: newSettings$8,
  note: note$b,
  notification: notification$f,
  pairing: pairing$f,
  passphrase: passphrase$9,
  password: password$f,
  random: random$g,
  receive: receive$h,
  reset: reset$f,
  securityInformation: securityInformation$f,
  seed: seed$f,
  seedRestore: seedRestore$f,
  send: send$h,
  settings: settings$g,
  setup: setup$f,
  sidebar: sidebar$g,
  success: success$m,
  transaction: transaction$g,
  transactions: transactions$f,
  unknownError: unknownError$f,
  unlock: unlock$f,
  upgradeFirmware: upgradeFirmware$g,
  walletConnect: walletConnect$9,
  warning: warning$l,
  welcome: welcome$f
}, account$e = {
  disconnect: "Connexion perdue. Tentative de reconnexion…",
  export: "Exporter",
  exportTransactions: "Exporter les transactions vers le dossier Téléchargements sous forme de fichier CSV",
  fatalError: "Une erreur inattendue s'est produite.",
  incoming: "Entrant",
  initializing: "Récupération d'informations de la blockchain…",
  maybeProxyError: "Proxy Tor activé. Assurez-vous que votre proxy Tor fonctionne correctement, ou désactivez la configuration du proxy.",
  reconnecting: "Connexion perdue, tentative de reconnexion…",
  syncedAddressesCount: "{{count}} adresses scannées"
}, accountInfo$e = {
  address: "Adresse",
  buyCTA: {
    buy: "Acheter {{unit}}",
    buyCrypto: "Acheter de la Crypto",
    information: {
      looksEmpty: "On dirait que ce portefeuille est vide",
      start: "Commencez par déposer des fonds dans le portefeuille ou bien achetez en directement dans l'application BitBoxApp."
    }
  },
  extendedPublicKey: "Clé publique étendue",
  label: "Informations du compte",
  scriptType: "Type de scrypt",
  title: "Informations sur le compte",
  verify: "Vérifier sur l'appareil",
  xpubTypeChangeBtn: {
    p2pkh: "Afficher la clé publique étendue (xpub) P2PKH legacy",
    p2tr: "Voir Taproot",
    p2wpkh: "Voir Native Segwit",
    "p2wpkh-p2sh": "Afficher l'ancienne clé publique étendue (xpub) Segwit"
  },
  xpubTypeInfo: "Affichage actuellement de la clé publique étendue {{scriptType}} ({{current}} de {{numberOfXPubs}})"
}, accountSummary$e = {
  availableBalance: "Solde disponible",
  balance: "Solde",
  exportSummary: "Exporter un extrait des comptes vers le dossier de Téléchargements sous forme de fichier CSV",
  fiatBalance: "Solde en devise",
  name: "Nom du compte",
  noAccount: "Il n'y a pas de compte à montrer.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Vue globale de mon portefeuille",
  total: "Total",
  transactionHistory: "Historique des transactions"
}, addAccount$f = {
  chooseName: {
    nextButton: "Ajouter un compte",
    step: "Donner un nom au compte",
    title: "Donnez un nom à votre compte"
  },
  selectCoin: {
    nextButton: "Suivant",
    step: "Sélectionner un coin (pièce)",
    title: "Sélectionnez une crypto-monnaie"
  },
  success: {
    addAnotherAccount: "Ajouter un autre compte",
    message: "<strong>{{accountName}}</strong> a maintenant été ajouté à vos comptes.",
    nextButton: "Terminé",
    step: "Fini",
    title: "Compte ajouté"
  },
  title: "Ajouter un compte"
}, aopp$8 = {
  addressRequest: "{{host}} exige une adresse de réception.",
  addressRequestWithLogo: "exige une adresse de réception.",
  banner: "Demande d'adresse en cours",
  errorTitle: "Erreur durant la demande d'adresse",
  labelAddress: "Adresse",
  labelMessage: "Message",
  reverifyInfoText: "Vérification de l'adresse",
  signing: "Afin de continuer, veuillez signer le message à l'aide de votre BitBox02",
  success: {
    message: "Continuer sur {{host}}",
    title: "Adresse envoyée avec succès"
  },
  syncing: "Synchronisation du compte, veuillez patienter.",
  title: "Demande d'adresse"
}, app$e = {
  upgrade: "Une nouvelle version de cette application est disponible ! Veuillez mettre à jour de la {{current}} à la {{version}}."
}, auth$7 = {
  authButton: "Authentification",
  title: "Veuillez vous authentifier pour continuer"
}, backup$e = {
  check: {
    checking: "Vérification de la sauvegarde…",
    confirmTitle: "Vérifier la sauvegarde",
    notOK: "La sauvegarde ne correspond PAS à ce portefeuille.",
    ok: "La sauvegarde correspond au portefeuille.",
    password: {
      label: "Mot de passe de récupération",
      placeholder: "Mot de passe de récupération",
      showLabel: "mot de passe de récupération"
    },
    success: "Sauvegarde vérifiée avec succès :",
    title: "Vérifier la sauvegarde"
  },
  create: {
    alreadyExists: "Vous avez déjà une sauvegarde valide. Souhaitez-vous la recréer ?",
    fail: "La création de la sauvegarde a échoué !",
    info: "Veuillez saisir le mot de passe de récupération du portefeuille actuel pour vérification.",
    name: {
      label: "Nom de la sauvegarde",
      placeholder: "Veuillez nommer la sauvegarde"
    },
    password: {
      label: "Mot de passe de récupération",
      placeholder: "Veuillez entrer votre mot de passe de récupération"
    },
    title: "Créer une sauvegarde",
    verificationFailed: "Le mot de passe de récupération NE CORRESPOND PAS à ce portefeuille. La sauvegarde a été créée. Veuillez utiliser «Vérifier la sauvegarde» pour vérifier à nouveau votre mot de passe de récupération."
  },
  description: "Sélectionnez le <strong>fichier de sauvegarde du portefeuille</strong>.",
  insert: "Veuillez insérer la carte microSD pour gérer les sauvegardes.",
  insertButton: "J'ai inséré la carte microSD",
  list: "Vos sauvegardes sur la carte microSD",
  noBackups: "Il n'existe aucune sauvegarde sur cette carte micro SD.",
  restore: {
    confirmTitle: "Restaurer la sauvegarde",
    error: {
      e200: "Carte microSD non trouvée",
      general: "Erreur lors de la restauration de la sauvegarde"
    },
    password: {
      label: "Mot de passe de récupération ou mot de passe de récupération caché",
      placeholder: "Mot de passe de récupération",
      repeatPlaceholder: "Répéter le mot de passe de récupération",
      showLabel: "Mot de passe de récupération"
    },
    restoring: "Restauration de la sauvegarde…",
    selectedBackup: "<strong>{{backupName}}</strong> créé le {{createdDateTime}} sera restauré.",
    title: "Restaurer",
    understand: "Je comprends qu'un mot de passe de récupération incorrect créera un portefeuille différent."
  },
  showMnemonic: {
    description: `24 mots de récupération vont vous être présentés; ils constituent une sauvegarde de votre portefeuille. Notez-les sur papier.

<strong>Ne les stockez pas sur un support numérique et ne les prenez pas en photo.</strong>

<strong>Ne prononcez pas les mots à haute voix.</strong>

<strong>Cette sauvegarde n'est pas protégée par un mot de passe.</strong>.

Il vous sera demandé ensuite de confirmer chacun de ces mots.`,
    title: "Montrer les mots de récupération",
    warning: "<strong>Ne partagez jamais vos mots de récupération avec qui que ce soit.</strong> Vos mots de récupération permettent un accès intégral à votre portefeuille. Si on vous demande vos mots de récupération, il s’agit d’une escroquerie, ne les partagez jamais !"
  },
  title: "Gérer les sauvegardes"
}, bb02Bootloader$e = {
  abort: "Ne pas mettre à jour - Revenir en arrière",
  abort_noUpgrade: "Retour en arrière",
  advanced: {
    label: "Paramètres avancés",
    toggleShowFirmwareHash: "Afficher le hash du firmware à chaque démarrage de l'application"
  },
  flipscreen: "Retourner l'écran",
  orientation: "Appareil dans le mauvais sens ?",
  success: "Mise à jour réussie ! Continue dans {{rebootSeconds}} secondes...",
  success_install: "Installation réussie ! Poursuite dans {{rebootSeconds}} secondes..."
}, bitbox$e = {
  error: {
    e10000: "Mot de passe de l'appareil incorrect.",
    e10001: "La tentative de remplacer le mot de passe de l'appareil a échoué",
    e102: "Le mot de passe doit comporter au minimum 4 caractères.",
    e112: "Le mot de passe caché ne peut pas être identique au mot de passe principal de l'appareil."
  }
}, bitbox02Interact$e = {
  confirmDate: "Confirmez la date du jour sur votre BitBox02",
  confirmDateText: "Cette date sera utilisée pour créer votre sauvegarde.",
  confirmName: "Confirmez le nom sur le BitBox02",
  confirmWords: "Notez les {{amount}} mots de récupération depuis votre BitBox02",
  confirmWordsText: "Ensuite, la BitBox02 vous demandera de confirmer chaque mot afin de s’assurer que la sauvegarde a été correctement effectuée.",
  followInstructions: "Veuillez suivre les instructions sur votre BitBox02.",
  followInstructionsMnemonic: "Suivez les instructions sur votre BitBox02 afin de saisir les mots de récupération de votre sauvegarde et restaurer ainsi votre portefeuille.",
  followInstructionsMnemonicTitle: "Restaurer à partir des mots de récupération"
}, bitbox02Settings$e = {
  deviceName: {
    current: "Nom du périphérique actuel",
    error: "Le nom de l'appareil n'a pas pu être configuré",
    error_104: "La confirmation du nom de l'appareil a été interrompu sur celui-ci.",
    input: "Nom du BitBox02",
    placeholder: "Nouveau nom de périphérique",
    title: "Définir le nom de votre BitBox02"
  },
  gotoStartupSettings: {
    description: "Cela va rebooter votre BitBox02 et entrer les paramètres de démarrage.",
    title: "Aller aux paramètres de démarrage"
  }
}, bitbox02Wizard$e = {
  advanced: {
    button: "Options avancées",
    outOfDate: "Le micrologiciel n'est pas à jour et ne permet pas cette fonctionnalité",
    seed12WordInfo: "Veuillez noter que le nombre de mots ne peut pas être modifié après la création du portefeuille.",
    seed12WordLabel: "Créer une seed de 12 mots plutôt que de 24 mots",
    seed12WordText: "Par défaut, la BitBox02 utilise une seed de 24 mots. Dans la pratique, les deux longueurs de seed sont fiables contre les attaques par force brute. Toutefois, certains utilisateurs peuvent préférer la commodité inhérente à une seed de 12 mots.",
    skipSDCardLabel: "Sauter l’étape de sauvegarde sur la carte microSD et écrire les mots de récupération plutôt.",
    skipSDCardText: "Vous avez toujours la possibilité de créer une sauvegarde sur la carte microSD ou d'écrire vos mots de récupération après la configuration. Vous pouvez le faire à partir des paramètres.",
    title: "Options de sauvegarde avancées"
  },
  attestationFailed: "L'authentification a échoué. Ceci est potentiellement dû au redémarrage de l'application alors que l'appareil attendait une saisie de la part de l'utilisateur. Veuillez vous reconnecter et essayer à nouveau. Si cela persiste, veuillez contacter support@bitbox.swiss",
  backup: {
    point1: "Sélectionner une sauvegarde sur la carte micro SD",
    point2: "Définissez un mot de passe pour votre appareil",
    restoreText: "Ok, restaurons une sauvegarde !",
    text1: "Parfait, le mot de passe pour votre BitBox02 est défini et votre portefeuille est créé. Il est maintenant temps de procéder à votre première sauvegarde. Assurez-vous que la carte micro SD soit bien insérée dans l'appareil et continuez.",
    text2: "Veuillez suivre les instructions sur l'écran de votre appareil pour créer une sauvegarde.",
    text3: "Une fois votre sauvegarde créée, veuillez retirer la carte micro SD et la conserver dans un endroit <strong>sécurisé</strong>. Le contenu de la carte micro SD n'est pas protégé par mot de passe. Ne l'insérez jamais dans un appareil autre que votre BitBox02.",
    userConfirmation1: "Je devrais stocker ma sauvegarde dans un endroit sûr.",
    userConfirmation2: "Ma sauvegarde n'est pas protégée par mot de passe. Quiconque y a accès peut accéder à mon portefeuille.",
    userConfirmation3: "Si je perds ou endommage mon BitBox02, la seule façon de récupérer mes fonds est de restaurer à partir de ma sauvegarde.",
    userConfirmation4: "Si je perds ou endommage à la fois ma sauvegarde et ma BitBox02, mes fonds seront perdus.",
    userConfirmation5: "Je ne dois pas insérer ma carte de sauvegarde microSD dans un ordinateur, un téléphone, une imprimante ou tout appareil autre qu'un BitBox02.",
    userConfirmation5mnemonic: "Je ne dois pas saisir mes mots de récupération dans un ordinateur, un téléphone, une imprimante ou tout autre appareil autre qu'une BitBox02."
  },
  create: {
    button: "Nommer l'appareil et continuer",
    info: "Voici les étapes de base à suivre pour configurer votre BitBox :",
    inputTitle: "Nom du portefeuille",
    point1: "Nommez votre appareil",
    point2: "Définir un mot de passe pour votre appareil",
    point3: "Créer une sauvegarde",
    text: "Ok, créons un nouveau portefeuille !"
  },
  createBackupAborted: "Création de la sauvegarde interrompue.",
  createBackupFailed: "La création de la sauvegarde a échoué, veuillez réessayer.",
  initialize: {
    passwordText: "Définissons maintenant un mot de passe pour votre appareil. Utilisez les commandes de votre BitBox pour entrer et choisir un mot de passe.",
    passwordTitle: "Définissez un mot de passe pour votre BitBox",
    text: "Votre BitBox02 a été appairé avec succès ! Initialisons maintenant votre appareil. Commencez par choisir de créer un nouveau portefeuille ou de restaurer un portefeuille à partir d'une sauvegarde existante. <strong>Veuillez vous assurer que vous avez une carte micro SD insérée dans votre BitBox02</strong>.",
    tip: "Nous recommandons de continuer dans un environnement sécurisé.",
    title: "Initialiser votre BitBox"
  },
  insertSDCard: "<strong>Assurez-vous d'avoir une carte micro SD insérée dans votre BitBox02.</strong>",
  noPasswordMatch: "Le mot de ",
  pairing: {
    failed: "Appariement non confirmé. Veuillez rebrancher votre BitBox02.",
    paired: "Vous avez confirmé le code suivant sur votre appareil. Veuillez continuer.",
    title: "Vérifier le code d'appairage",
    unpaired: "Une BitBox02 non-associée a été détectée. Veuillez vérifier que le code d’association correspond à celui indiqué sur votre BitBox02."
  },
  restoreFromMnemonic: {
    e104: "La restauration à partir des mots de récupération a été annulée.",
    failed: "La restauration à partir des mots de récupération a échoué, veuillez réessayer."
  },
  stepBackup: {
    beforeProceed: "Avant de continuer, veuillez lire ces importantes mesures de sécurité :",
    createBackup: "Vous allez maintenant créer une sauvegarde sur votre carte microSD.",
    createBackupMnemonic: "Vous allez à présent noter les mots de récupération."
  },
  stepBackupSuccess: {
    fundsSafe: "Pour assurer la sécurité de vos fonds, n'oubliez pas ce qui suit :",
    title: "Sauvegarde restaurée !"
  },
  stepConnected: {
    unlock: "Entrez le mot de passe du BitBox02 pour le déverrouiller."
  },
  stepCreate: {
    description: "Ce nom est utilisé comme celui de l'appareil et pour la sauvegarde.",
    nameLabel: "Nom du BitBox02",
    namePlaceholder: "Mon BitBox02",
    title: "Choisissez le nom du BitBox02",
    toastMicroSD: "Veuillez insérer votre carte microSD dans votre BitBox02, elle sera utilisée pour stocker une sauvegarde du portefeuille."
  },
  stepCreateSuccess: {
    removeMicroSD: "Veuillez retirer la carte microSD de votre BitBox02 et la stocker dans un endroit sûr.",
    storeMnemonic: "Veuillez conserver vos mots de récupération dans un emplacement sûr",
    success: "Vous avez créé votre sauvegarde avec succès."
  },
  stepInsertSD: {
    insertSDCard: "Veuillez insérer une carte microSD dans votre BitBox02 pour continuer.",
    insertSDcardTitle: "Insérer une carte microSD"
  },
  stepPassword: {
    e104: "Le paramétrage du mot de passe a été abandonné.",
    title: "Définissez le mot de passe du BitBox02",
    useControls: "Utilisez les touches de votre BitBox02 pour définir un mot de passe."
  },
  stepUninitialized: {
    create: "Je veux configurer un nouveau BitBox02.",
    restore: "Je veux restaurer mon portefeuille à partir d'une sauvegarde.",
    restoreMicroSD: "Restauration à partir d'une carte microSD",
    restoreMnemonic: "Restaurer à partir des mots de récupération",
    title: "Configurez votre BitBox02"
  },
  success: {
    text: `Hourra ! Votre BitBox02 est maintenant prêt à l'emploi. 

Pour plus d'informations sur l'utilisation de l'application BitBox, veuillez utiliser le guide d'utilisation en cliquant sur le point d'interrogation situé dans le coin supérieur droit.`,
    title: "Vous êtes prêt !"
  }
}, blink$e = {
  button: "Clignoter"
}, bootloader$e = {
  button: "Mettre à jour le micrologiciel maintenant",
  button_install: "Installer le firmware maintenant",
  progress: "Mise à jour : {{progress}}%",
  progress_install: "Installation : {{progress}}%",
  success: "Mise à jour réussie ! Veuillez rebrancher l'appareil. Cette fois, ne touchez pas le bouton."
}, button$i = {
  abort: "Abandonner",
  back: "Retour",
  buy: "Acheter",
  changepin: "Changer le mot de passe de l'appareil",
  check: "Vérifier la sauvegarde",
  continue: "Continuer",
  copy: "Copie",
  create: "Créer",
  dismiss: "Ignorer",
  done: "Terminé",
  download: "Télécharger",
  hiddenwallet: "Créer un portefeuille caché",
  next: "Suivant",
  ok: "D'accord",
  previous: "Précédent",
  receive: "Recevoir",
  restore: "Restaurer",
  select: "Sélectionner",
  send: "Envoyer",
  unlock: "Déverrouiller",
  update: "Mise à jour",
  upgrade: "Mettre à jour"
}, buy$a = {
  exchange: {
    bankTransfer: "Virement bancaire",
    bestDeal: "Meilleure offre",
    creditCard: "Carte de crédit",
    fast: "Rapide",
    fee: "frais",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Virement Bancaire: {{fee}}%",
          creditDebitCard: "Carte de crédit/débit: {{fee}}%",
          learnMore: "En savoir plus sur Moonpay",
          title: "Frais"
        },
        fullCurrenciesList: "Voir la liste complète des devises ici",
        payment: {
          asteriskText: "* Non disponible pour les résidents américains",
          bankTransfer: "Virement bancaire*",
          bankTransferDetails: {
            pix: "PIX (transactions BR au Brésil uniquement)",
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          creditDebitCard: "Carte de crédit/débit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "Voir plus de détails sur les méthodes de paiement",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte toutes les principales devises fiat : USD, EUR, CHF, et autres."
      },
      pocket: {
        fees: {
          info: "Virement bancaire : {{fee}}%",
          title: "Frais"
        },
        learnMore: "En savoir plus sur Pocket",
        payment: {
          bankTransfer: "Virement bancaire",
          bankTransferDetails: {
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            sic: "SIC - Swiss Interbank Clearing (Transactions CHF en Suisse/Liechtenstein uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          bankTransferReccuring: "Comment mettre en place des achats récurrents avec un ordre permanent?",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte les devises Européennes : EUR, GBP et CHF",
        verification: {
          info: "La vérification de l'identité n'est requise qu'au-delà des limites quotidiennes et annuelles.",
          link: "Consulter les limites en vigueur, ici.",
          title: "Vérification de l'identité"
        }
      },
      region: {
        title: "Sélectionnez la zone géographique de domiciliation de votre compte bancaire afin de déterminer les options à votre disposition."
      }
    },
    noExchanges: "Désolé, aucun échange disponible dans cette zone géographique",
    region: "Zone Géographique",
    selectRegion: "Non spécifié",
    title: "Acheter du {{name}}"
  },
  info: {
    continue: "Accepter et continuer",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nous avons un partenariat avec MoonPay afin de vous permettre d'acheter simplement des {{name}} directement depuis BitBoxApp. Quelques clics suffisent.",
        "MoonPay est une plateforme qui permet d’acheter des {{name}} de manière simple et rapide dans plus de 160 pays."
      ],
      payment: {
        details: "Vous pouvez acheter des {{name}} instantanément via MoonPay avec les méthodes de paiement suivantes. Les achats par carte de crédit ou de débit sont faciles et instantanés, mais plus chers en raison du risque de rétro-facturation plus élevé. Nous vous recommandons d'utiliser l'option du virement bancaire pour les montants plus importants. Les frais minimum sont de 4 USD/EUR ou équivalent.",
        footnote: "Veuillez noter que les taux de change de MoonPay peuvent différer de ceux utilisés dans BitBoxApp, ce qui peut entraîner potentiellement des montants légèrement différents.",
        table: {
          "1_description": "Frais les plus bas, peut prendre jusqu'à 3 jours ouvrables",
          "1_method": "Virements bancaires (SEPA)",
          "2_description": "Frais plus élevés mais rapides et directs",
          "2_method": "Cartes de crédit et de débit",
          description: "Description",
          fee: "Frais",
          method: "Méthode"
        },
        title: "Modes de paiement et frais"
      },
      privacyPolicy: "Politique de confidentialité de MoonPay",
      protection: {
        description: "BitBoxApp ne collecte aucune donnée lors de l'achat de {{name}}, les fonds entrants sont traités comme une transaction normale. MoonPay a besoin de collecter certaines données personnelles afin de fonctionner. Leur politique de confidentialité décrit en détail la façon dont ces données sont traitées.",
        descriptionGeneric: "BitBoxapp ne collecte aucune donnée lors de l'achat de {{nom}}, les fonds entrants sont traités comme une transaction normale. Cependant, les exchanges partenaires ont besoin de recueillir certaines informations pour fonctionner. Veuillez vous référer à leurs politiques de confidentialité respectives pour voir plus en détail comment sont traitées ces données.",
        title: "Protection des données"
      },
      security: {
        description: "Lorsque vous achetez du {{name}} via MoonPay, vous utilisez un service externe. Ce service est hors de portée du modèle sécurité contre les menaces de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé.",
        descriptionGeneric: "Lorsque vous achetez du {{nom}} via un exchange partenaire, vous utilisez un service externe. Ce service est hors de portée du modèle sécurité contre les menaces de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé.",
        link: "Modèle de menace à la sécurité",
        title: "Modèle de sécurité"
      },
      title: "Bienvenue sur la boutique de votre site clé en main pour acheter du {{name}}"
    },
    next: "Suivant",
    selectLabel: "Sélectionnez votre compte",
    selectPlaceholder: "Sélectionnez un coin (monnaie)",
    skip: "Ne plus montrer",
    title: "Acheter du {{name}}"
  },
  pocket: {
    data: {
      link: "Politique de confidentialité de Pocket",
      p1: "BitBoxApp ne recueille aucune donnée lors de l'achat de bitcoins, les fonds entrants sont traités comme une transaction ordinaire. Pocket a besoin de collecter certaines données personnelles pour son fonctionnement. La politique de confidentialité de Pocket expose en détail la manière dont elles sont exploitées.",
      title: "Protection des données"
    },
    kyc: {
      link: "Lire la FAQ de Pocket",
      p1: "Pocket s'efforce de réduire au minimum le processus d’identification (KYC). Pour les achats inférieurs à 950 EUR (1000 CHF) par jour, aucun document supplémentaire n'est requis. Pour les achats supérieurs à ce montant, vous devrez fixer un rendez-vous téléphonique avec Pocket au préalable afin de compléter le processus Identification/Lutte Contre le Blanchiment (KYC/AML) nécessaire.",
      title: "Identification/Lutte Contre le Blanchiment (KYC/AML)"
    },
    payment: {
      p1: "Vous avez la possibilité d’acheter des bitcoins instantanément avec Pocket via un transfert bancaire SEPA. Les frais sont de 1,5% et les bitcoins sont déposés dans votre BitBox dès que possible, une fois le virement bancaire  reçu par Pocket (généralement le jour même).",
      p2: "Veuillez noter que les taux de change de Pocket peuvent différer de ceux utilisés par BitBoxApp,et avoir pour effet des montants légèrement différents.",
      title: "Modes de paiement et frais"
    },
    previousTransactions: "L'historique des transactions de ce compte n'est pas vierge. En partageant ce compte, toutes ses transactions passées et futures seront exposées à Pocket. Souhaitez-vous continuer malgré tout ?",
    security: {
      link: "Modèle de menace de sécurité de BitBox02",
      p1: "Lorsque vous achetez des bitcoins via Pocket, vous utilisez un service externe. Ce service est hors de portée du modèle de menace de sécurité de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé. Cependant, nous collaborons dans le but de renforcer la sécurité en utilisant un mécanisme d'authentification à deux facteurs pour vérifier l'adresse sur laquelle vous les recevez.",
      title: "Modèle de sécurité"
    },
    usedAddress: "L'adresse {{adresse}} a déjà été utilisée, veuillez recommencer avec une nouvelle adresse.",
    verifyBitBox02: "Veuillez vérifier que l'adresse que vous avez reçue par email correspond à celle affichée sur votre Bitbox. Si vous en avez la possibilité, vous devriez ouvrir l'email sur un deuxième appareil pour plus de sécurité.",
    welcome: {
      p1: "Nous collaborons avec Pocket afin de vous offrir un processus simplifié pour vos achats de bitcoins directement dans l'application BitBox. Quelques clics suffisent.",
      p2: "Pocket est une plateforme suisse qui permet d'acheter rapidement et facilement des bitcoins depuis la plupart des pays européens (partout où les transferts bancaires SEPA sont disponibles).",
      p3: "Avec Pocket, vous pouvez également effectuer des achats réguliers par le biais d'ordres bancaires récurrents, vous donnant ainsi la possibilité d'effectuer facilement un lissage de votre prix d'acquisition (DCA).",
      title: "Bienvenue dans votre espace unique et complet dédié à l'achat de bitcoins."
    }
  },
  title: "Acheter du {{name}}"
}, changePin$e = {
  newTitle: "Nouveau mot de passe de l'appareil",
  oldLabel: "Mot de passe actuel de l'appareil"
}, chart$a = {
  dataMissing: "Récupération de l’historique des données… soyez patients.",
  dataOldTimestamp: "Mise à jour de l’historique des taux de change. Le graphique ne tient pas compte des données après {{time}}.",
  dataUpdating: "mise à jour des données...",
  filter: {
    all: "Tout",
    month: "Mois",
    week: "Semaine",
    year: "Année"
  }
}, checkSDcard$e = "vérification de la carte microSD", clickHere$e = "Cliquez ici.", confirm$g = {
  abortInfo: "Appuyez pour",
  abortInfoRedText: "abandonner",
  approveInfo: "Appuyez 4+ secondes pour",
  approveInfoGreenText: "confirmer",
  info: "Continuez sur votre BitBox",
  infoWhenPaired: "D'abord sur le mobile appairé, puis sur votre BitBox"
}, confirmOnDevice$e = "Veuillez confirmer sur l'appareil.", connectKeystore$7 = {
  promptNoName: "Veuillez connecter votre BitBox02 pour continuer",
  promptWithName: 'Veuillez connecter votre BitBox02 dénommée "{{name}}" pour continuer'
}, darkmode$8 = {
  toggle: "Dark mode"
}, device$e = {
  appUpradeRequired: "Votre BitBox n'est pas compatible avec cette version de l'application de bureau. Veuillez télécharger et installer la dernière version."
}, deviceLock$e = {
  button: "Activer la double authentification (2FA)",
  condition1: "Avez-vous une sauvegarde ?",
  condition2: "Est-ce que la vérification avec l'application mobile fonctionne-t-elle ?",
  condition3: "Le 2FA DÉSACTIVE les sauvegardes et l'appariement à l'application mobile. L'appareil doit être RÉINITIALISÉ pour enlever le 2FA !",
  confirm: "Activer la double authentification (2FA)",
  title: "Activer la double authentification (2FA)"
}, deviceSettings$e = {
  backups: {
    manageBackups: {
      description: "Créez ou vérifiez la sauvegarde de votre carte microSD."
    },
    showRecoveryWords: {
      description: "Afficher et vérifier les mots de récupération."
    },
    title: "Sauvegardes"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp vérifie l'authenticité de votre appareil."
    },
    deviceName: {
      description: "Modifiez le nom de votre appareil."
    },
    rootFingerprint: {
      description: "L'empreinte digitale racine est un identifiant unique du portefeuille en cours d'utilisation. Elle peut vous aider à distinguer les différents portefeuilles si vous utilisez des passsphrases."
    },
    securechip: {
      description: "Modèle de la puce sécurisée."
    },
    title: "Informations sur l'appareil"
  },
  expert: {
    factoryReset: {
      description: "Réinitialisez votre appareil aux paramètres d'usine. Cela supprimera le wallet de votre BitBox02 !",
      title: "Réinitialisation aux paramètres d'usine"
    },
    goToStartupSettings: {
      description: "Entrez le bootloader de la BitBox02. Vous pouvez activer le hachage du micrologiciel à partir de là."
    },
    passphrase: {
      description: "Activer ou désactiver la fonction de passphrase (phrase secrète)",
      title: "Passphrase (phrase secrète)"
    }
  },
  firmware: {
    firmwareVersion: "Version du Firmware",
    newVersion: {
      label: "Version disponible"
    },
    title: "Micrologiciel",
    upToDate: "Votre appareil est à jour",
    upgradeAvailable: "Nouvelle mise à jour disponible",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      false: "Échec du contrôle d'authenticité",
      label: "Contrôle d'authenticité",
      true: "Votre BitBox02 est authentique"
    },
    sdcard: {
      false: "Non insérée",
      label: "carte microSD",
      true: "Insérée"
    },
    securechip: "Puce sécurisée",
    title: "Matériel informatique"
  },
  loading: "Récupération des informations sur l'appareil…",
  pairing: {
    lock: {
      false: "Désactivé",
      label: "Double authentification (2FA)",
      true: "Activé"
    },
    mobile: {
      false: "Fermé",
      label: "Application mobile",
      true: "Ouvrir"
    },
    status: {
      false: "Non appairé",
      label: "Statut",
      true: "Appairé"
    },
    title: "Appariement"
  },
  secrets: {
    manageBackups: "Gérer les sauvegardes",
    title: "Secrets"
  }
}, deviceTampered$e = "Est-ce que votre BitBox a été fourni avec un mot de passe de récupération ? Si c'est le cas, arrêtez la procédure d'installation et contactez immédiatement le support. Shift ne vous donnera jamais un portefeuille prêt à l'emploi ni de recommandation de mot de passe.", dialog$f = {
  cancel: "Annuler",
  confirm: "Confirmer",
  confirmTitle: "Confirmation"
}, error$a = {
  accountAlreadyExists: "Ce compte existe déjà.",
  accountLimitReached: "Impossible d'ajouter un compte. Le nombre maximum de comptes pour ce coin (monaie) a été atteint.",
  aoppCallback: "Une erreur s'est produite lors de la transmission de l'adresse à {{host}}.",
  aoppInvalidRequest: "Requête invalide.",
  aoppNoAccounts: "Aucun comptes disponibles.",
  aoppSigningAborted: "Demande de possession de l'adresse annulée.",
  aoppUnknown: "Une erreur inconnue s'est produite.",
  aoppUnsupportedAsset: "Cet actif n'est pas pris en charge.",
  aoppUnsupportedFormat: "Aucun des comptes disponibles ne supporte le format d'adresse requis.",
  aoppUnsupportedKeystore: "L’appareil connecté ne peut pas signer de messages pour cet asset.",
  aoppVersion: "Version inconnue.",
  wrongKeystore: "Portefeuille connecté incorrect. Veuillez vous assurer d'insérer le bon appareil correspondant à ce compte",
  wrongKeystore2: "Si vous utilisez la passphrase facultative, assurez-vous bien que vous avez saisi la passphrase correspondant à ce compte."
}, fiat$g = {
  default: "défaut",
  setDefault: "Définir {{code}} comme paramètre par défaut",
  title: "Devises"
}, footer$g = {
  appVersion: "Version de l'application :"
}, generic$a = {
  enabled_false: "Désactivé",
  enabled_true: "Activé"
}, genericError$e = "Une erreur est survenue. Si vous rencontrez des problèmes, veuillez redémarrez l'application.", goal$e = {
  buttons: {
    create: "Créer un nouveau portefeuille",
    restore: "Restaurer un portefeuille à partir d'une sauvegarde"
  },
  paragraph: "Veuillez sélectionner l'une des options suivantes :",
  step: {
    1: {
      title: "Information de sécurité"
    },
    2: {
      description: "Définir un mot de passe pour l'appareil",
      title: "Appareil"
    },
    "3-create": {
      description: "Créer un nouveau portefeuille",
      title: "Portefeuille"
    },
    "3-restore": {
      description: "à partir d'une sauvegarde",
      title: "Restaurer"
    },
    "4-create": {
      title: "Résumé"
    },
    "4-restore": {
      title: "Résumé"
    }
  }
}, guide$f = {
  accountDescription: {
    text: `La vue d'ensemble de votre compte affiche votre solde disponible ainsi que les transactions entrantes et sortantes. Notre guide dans "Paramètres" contient plus d'informations sur chaque type de compte. `,
    title: "Que me montre cette page ?"
  },
  accountFiat: {
    text: "Oui. Cliquez sur n'importe quel symbol pour changer la devise. Vous pouvez modifier la liste des devises dans les paramètres.",
    title: "Puis-je afficher d'autres taux de conversion ?"
  },
  accountIncomingBalance: {
    text: "Entrant est la somme des montants qui vous ont été transférés mais qui n'ont pas encore été confirmés par le réseau.",
    title: "Que veut dire entrant ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Chaque xpub est liée au "Type" indiqué : soit "Native Segwit (bech32)", "Wrapped Segwit" ou "Taproot" (Bitcoin uniquement). Ce sont les types de script utilisés par {{coinName}}. BitBoxApp les combine, prenant en charge plusieurs types de script dans le même compte. Comme chaque type de script donne une xpub différente, il y a plusieurs xpubs par compte.

Si vous recevez systématiquement sur l'adresse par défaut (Native Segwit), vous n'avez besoin que de la xpub "bech32". Cependant, si vous recevez également des fonds sur "Wrapped Segwit" ou "Taproot", vous devez également utiliser respectivement les clés publiques étendues "Wrapped Segwit" et "Taproot".`,
      title: "Pourquoi y a-t-il plusieurs xpubs ?"
    },
    privacy: {
      text: `Pour ce compte spécifique, la clé publique étendue révèle l'ensemble de l'historique des opérations, le solde de votre compte et toutes les transactions futures. Mais la xpub ne permet à personne de dépenser vos coins (monnaie).

Si vous communiquez une xpub à quelqu'un, vous devez être conscient que cette personne ou entreprise peut visualiser toutes les autres transactions de ce même compte. Par conséquent, c'est une bonne idée d'utiliser ce compte uniquement à cette fin et de garder les autres fonds sur des comptes distincts.`,
      title: "Est-ce que je dois garder ma xpub secrète ?"
    },
    verify: {
      text: "Oui, c'est toujours une bonne initiative de revérifier votre xpub. Si un tiers va générer des adresses de réception à partir de cette xpub pour vous envoyer de l'argent, c'est tout particulièrement important. Vous devez la vérifier sur l'appareil afin de vous assurer que cette xpub vous appartient; sinon, l'ensemble des fonds pourraient être envoyés à des adresses non voulues.",
      title: "Est-ce que je dois vérifier la xpub sur l'appareil ?"
    },
    xpub: {
      text: `Une clé publique étendue (xpub) est une clé racine à partir de laquelle toutes les adresses de réception d'un compte sont dérivées.

Elle sont fournies ici à des fins d'utilisation avancée et d'interopérabilité avec les portefeuilles de type "watch-only", comme Electrum ou Sentinel. Si vous recevez des fonds sur différents types d'adresses, veuillez importer tous les différents formats xpub dans le portefeuille "watch-only" afin de pouvoir visualiser tous vos fonds.

Veuillez noter que certains portefeuilles tiers ne supportent pas encore les xpubs Taproot.`,
      title: "Qu'est-ce qu'une clé publique étendue ?"
    }
  },
  accountRates: {
    text: "Les taux de change sont mis à jour toutes les minutes à partir de CoinGecko.",
    title: "Quels taux de change sont utilisés ?"
  },
  accountReload: {
    text: "Il n'y a pas besoin. Vos informations de transaction sont mises à jour automatiquement.",
    title: "Puis-je recharger l'historique des transactions ?"
  },
  accountSendDisabled: {
    text: 'Le bouton "Envoyer" est activé lorsque votre solde est supérieur à zéro.',
    title: "Pourquoi ne puis-je pas envoyer de {{unit}} ?"
  },
  accountSummaryAmount: {
    text: `Le montant total est la somme de tous vos comptes crypto. Les taux de change sont obtenus auprès de coingecko.com.

Remarque : si vous utilisez MyEtherWallet pour des tokens (jetons) non pris en charge par BitBoxApp, ils ne seront pas inclus dans le montant affiché.`,
    title: "Comment le montant total est-il calculé ?"
  },
  accountSummaryDescription: {
    text: "Vous pouvez voir ici la performance de votre portefeuille au fil du temps. Un résumé de vos comptes cryptos individuels est affiché sous le graphique.",
    title: "Que me montre cette page ?"
  },
  accountTransactionAttributesBTC: {
    text: `Taille virtuelle : détermine les frais de réseau. Vous avez réussi à économiser sur les frais si elle est inférieure à la taille de la transaction.
Taille : Taille réelle de la transaction en octets dépendamment de la blockchain concernée.
Poids : Une nouvelle mesure, introduite avec Segwit, permettant d'évaluer la transaction et la taille du bloc. Chaque octet témoin est séparé et compte pour un, le reste en tant que quatre unités de poids. Au lieu d'un mégaoctet de taille réelle, la limite de taille de bloc est maintenant de quatre millions d'unités de poids.`,
    title: "Qu'en est-il des détails spécifiques de la transaction Bitcoin ?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmations : Lors de l'émission de votre transaction, elle ne sera pas confirmée. Vous devrez attendre qu'un mineur l'inclue dans un bloc, elle aura alors une confirmation. Chaque bloc émis sur le réseau par la suite ajoutera une nouvelle confirmation à votre transaction. En général, les commerçants et autres acteurs de l'écosystème considèrent comme valides les transactions ayant entre 3 et 6 confirmations.
Transaction ID : Numéro d'identification unique pouvant être utilisé pour rechercher une transaction dans un explorateur de blocs.
Frais : Les mineurs reçoivent des frais de transaction afin de les inciter à intégrer les transactions dans les blocs qu'ils minent. Pour en savoir plus, cliquez sur le bouton d'envoi.`,
    title: "Quelles sont les informations affichées dans le détail de la transaction?"
  },
  accountTransactionConfirmation: {
    text: "Il s’agit d’une transaction qui a été émise sur le réseau et en attente d’être confirmée.",
    title: "Qu'est-ce qu'une transaction en attente ?"
  },
  accountTransactionLabel: {
    text: "C'est l'adresse vous ayant envoyé les coins ou à laquelle vous les avez envoyés.",
    title: "Quelle adresse est affichée pour chaque transaction?"
  },
  accountTransactionTime: {
    text: "L'heure et la date à laquelle la transaction a été confirmée sur la blockchain.",
    title: "Quel horodatage est affiché ?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin et Litecoin ne peuvent avoir qu’un nombre arbitraire de comptes. Au delà de cinq comptes, vous ne pouvez en ajouter un supplémentaire que si le compte précédent a déjà été utilisé. 
Un maximum de cinq comptes est possible pour les autres coins (jetons).`,
      title: "Combien de comptes puis-je créer ?"
    },
    howtoAddTokens: {
      text: `Les jetons utilisant la norme ERC20 sont rattachés à un compte Ethereum spécifique. Pour activer ou désactiver un jeton en particulier, ouvrez l'écran "Gérer les comptes", élargissez votre compte Ethereum et activez ou désactivez le jeton souhaité.`,
      title: "Comment ajouter des jetons supplémentaires ?"
    },
    moveFunds: {
      text: "Oui. Mais comme les comptes sont indépendants, vous devez envoyer vos fonds en utilisant une transaction classique.",
      title: "Est-ce que je peux déplacer des fonds entre les différents comptes ?"
    },
    recoverAccounts: {
      text: "Oui. BitBoxApp crée des comptes en utilisant des normes bien établies et compatibles avec la plupart des autres portefeuilles de crypto-monnaies.",
      title: "Est-ce que je peux récupérer mes comptes avec d'autres portefeuilles ?"
    },
    whatAreAccounts: {
      text: "Votre portefeuille peut gérer plusieurs comptes pour un même coin (monnaie). Les différents comptes sont utiles lorsque vous souhaitez conserver des fonds séparément.",
      title: "Qu'est-ce qu'un compte ?"
    },
    whyIsThisUseful: {
      text: `Les comptes sont parfaits pour gérer des fonds destinés à des personnes ou des objectifs différents, car ils sont distincts. Vous pouvez également partager la "clé publique étendue" (xpub) d'un compte sans rien dévoiler de vos autres comptes. Cela vous permet de recevoir des fonds de manière répétée sans réutiliser les adresses, par exemple pour recevoir votre salaire ou acheter régulièrement des crypto-monnaies.`,
      title: "Pourquoi est-ce utile ?"
    }
  },
  appendix: {
    link: "Contactez-nous !",
    text: "Vous avez une autre question ?"
  },
  backups: {
    check: {
      text: `"Vérifier la sauvegarde" vous permet de vérifier que vous disposez d'une sauvegarde fonctionnelle correspondant à votre portefeuille actuel. Elle peut également être utilisée pour vérifier que vous disposez toujours du mot de passe de récupération correct. Vous pouvez vérifier votre mot de passe de récupération principal ou votre mot de passe de récupération caché.`,
      title: 'Que signifie "Vérifier la sauvegarde" ?'
    },
    encrypt: {
      text: "Non, mais votre mot de passe de récupération est nécessaire pour dériver le portefeuille à partir de la graine stockée.",
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    howOften: {
      text: `La sauvegarde est automatiquement générée lorsqu'un nouveau portefeuille est créé. Vous devez effectuer une nouvelle sauvegarde que si votre carte microSD est perdue ou endommagée ou si vous souhaitez utiliser plusieurs cartes microSD pour vos sauvegardes.
Vous n'avez pas besoin de créer une nouvelle sauvegarde après avoir effectué des transactions. Toutes les données associées à vos transactions peuvent être recréées par votre sauvegarde unique qui a été générée automatiquement.`,
      title: "À quelle fréquence dois-je faire une sauvegarde ?"
    },
    whatIsABackup: {
      text: "C'est une copie de la graine sur une carte microSD. La graine combinée à votre mot de passe de récupération génère votre portefeuille.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Vérifier la sauvegarde" vous permet de vérifier que la sauvegarde correspond bien à votre portefeuille.',
      title: 'Que signifie "Vérifier la sauvegarde" ?'
    },
    encrypt: {
      text: `Non. Veillez à conserver la carte microSD en sécurité compte tenu du fait qu'elle contient votre liste de mots permettant la restauration de votre portefeuille. Si vous souhaitez protéger votre graine par mot de passe, vous pouvez activer une phrase secrète dans les paramètres avancés du menu "Gérer l'appareil".`,
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    whatIsABackup: {
      text: "Il s'agit d'une copie de votre liste de mots BIP39 sur une carte microSD.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Lorsque le 2FA est activé, toutes les transactions doivent être approuvées sur votre téléphone portable appairé afin de pouvoir envoyer des jetons. En réalité, un numéro chiffré, à usage unique, est envoyé à l'application mobile, déchiffré  et renvoyé au BitBox lorsque vous appuyez sur le bouton "Accepter". Cette communication avec l'appareil se fait via le canal entre le téléphone mobile et l'application de bureau établie lors de l'appareillage.

Assurez-vous de sauvegarder votre portefeuille et d'appairer l'application mobile avant d'activer le 2FA. Une fois activé, l'appairage entre l'emplacement de la carte micro SD et l'application mobile est désactivé. Il peut être réactivé en réinitialisant le BitBox.`,
      title: "Comment fonctionne la double authentification (2FA) ?"
    },
    disable2FA: {
      text: `Pour désactiver le 2FA, vous devez réinitialiser votre BitBox, puis restaurer le portefeuille à partir de sa sauvegarde. Assurez-vous que vous êtes toujours en possession de la carte micro SD avec la sauvegarde et que vous vous souvenez du mot de passe de récupération. Puis appuyez sur "Réinitialiser l'appareil". Définissez un nouveau mot de passe et choisissez "Ou restaurer une sauvegarde". Sélectionnez la sauvegarde que vous avez effectuée à partir du portefeuille, cliquez sur "Restaurer" et entrez le mot de passe de récupération que vous avez utilisé lors de la création du portefeuille.`,
      title: "Comment puis-je désactiver la double authentification (2FA) ?"
    },
    ejectBitbox: {
      text: "Vous pouvez débrancher le BitBox à tout moment sans avoir à l'éjecter.",
      title: "Comment puis-je éjecter le BitBox ?"
    },
    ejectSD: {
      text: "Vous pouvez retirer la carte microSD du BitBox à tout moment, tant que vous n'êtes pas en train de créer ou de restaurer une sauvegarde.",
      title: "Comment puis-je éjecter la carte microSD ?"
    },
    hiddenWallet: {
      text: "Il s’agit d’un deuxième portefeuille sur le même appareil, protégé par un mot de passe d'appareil et de récupération différents, qui peut être utile pour un plausible déni. La même graine de sauvegarde est utilisée pour votre portefeuille normal et votre portefeuille caché. Aucune sauvegarde supplémentaire n'est donc nécessaire.",
      title: "Qu'est-ce qu'un portefeuille caché ?"
    },
    legacyHiddenWallet: {
      text: "Cliquez d'abord sur le bouton ci-dessous (disponible si le BitBox est déverrouillé avec le mot de passe principal de l'appareil et si la double authentification est désactivée), puis rebranchez votre BitBox et déverrouillez-le avec le mot de passe du portefeuille caché.",
      title: "Comment accéder au portefeuille Legacy caché ?"
    },
    pairing: {
      text: "Après avoir téléchargé notre application mobile pour iOS ou Android, vous devez scanner le QR code affiché, ce qui établit un canal sécurisé entre l'application mobile et l'application de bureau. Une fois scanné, suivez les instructions sur l'application mobile.",
      title: "Comment appairer votre téléphone en toute sécurité ?"
    }
  },
  cointracking: {
    text: `Cliquez sur le bouton "Exporter" et ouvrez le dossier de téléchargement où vous trouverez l'exportation CSV. Cliquez ensuite sur le lien ci-dessous, téléchargez votre fichier CSV BitBox et importez les données afin de les utiliser avec votre gestionnaire de portefeuille CoinTracking et pour créer vos déclaration fiscales.`,
    title: "Comment importer mes transactions dans CoinTracking ?"
  },
  device: {
    attestation: {
      link: {
        text: "En savoir plus sur le contrôle d'authenticité"
      },
      text: "BitBoxApp effectue un contrôle d'attestation sur la BitBox02 afin de confirmer que le dispositif est bien authentique. La vérification est effectuée localement et ne nécessite aucune connexion à un serveur.",
      title: "Comment fonctionne le contrôle d'authenticité?"
    },
    name: {
      text: "Ceci est le nom de votre portefeuille et de votre sauvegarde. Ce nom est utilisé pour les sauvegardes futures et permet de faire la distinction entre différents portefeuilles. Il peut être modifié à tout moment mais veuillez noter que les sauvegardes effectuées avant ce changement continueront d' utiliser le nom précédent.",
      title: "A quoi sert le nom BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "En savoir plus sur la puce sécurisée"
      },
      text: "Cette information indique le modèle de la puce sécurisée. La puce la plus récente est l'ATECC608B, qui bénéficie de caractéristiques de sécurité renforcées comparativement aux précédents modèles.",
      title: "Pourquoi indiquer le modèle de puce sécurisée?"
    }
  },
  receive: {
    address: {
      text: "Vous pouvez donner l'adresse à d'autres personnes pour qu'elles vous envoient des coins. Assurez-vous simplement qu'elles envoient à la bonne adresse.",
      title: "Que puis-je faire d'une adresse ?"
    },
    addressChange: {
      text: "Dès que vous effectuez une transaction, une nouvelle adresse est automatiquement ajoutée à la liste de sorte qu'il y ait toujours 20 adresses vierges disponibles.",
      title: "Quand les adresses changent-elles ?"
    },
    addressFormats: {
      text: "Par défaut, le type d'adresse est Native Segwit. Ce type d'adresse est largement adopté par d'autres portefeuilles/exchanges et vous offre les meilleurs niveau de frais pour les transactions quotidiennes. Cependant, vous pouvez également choisir d'envoyer vers Taproot (Bitcoin uniquement), qui est le type d'adresse le plus récent, mais qui n'est peut-être pas encore largement supporté. Par ailleurs, si vous rencontrez des difficultés pour vos envois vers Native Segwit (le type par défaut), vous pouvez essayer de passer à l'ancien type d'adresse Wrapped Segwit, qui peut se révéler compatible avec davantage de portefeuilles/exchanges.",
      title: `Quand dois-je utiliser la fonction "Modifier le type d'adresse" ?`
    },
    howVerify: {
      text: `Pour le BitBox01, cliquez sur l'icône BitBox dans la barre latérale de gauche et consultez la section appairage. Le guide sera mis à jour et vous pourrez continuer à suivre les instructions à partir de là.
Pour le BitBox02, vous pouvez vérifier les adresses directement sur l'appareil pendant le processus d'envoi/réception.`,
      title: "Comment puis-je vérifier une adresse en toute sécurité ?"
    },
    plugout: {
      text: "Non, une fois que vous avez envoyé des fonds sur votre adresse BitBox, vous n'avez pas besoin de laisser votre BitBox branchée. Vous êtes libre de pouvoir déconnecter votre BitBox.",
      title: "Est-ce que je dois laisser mon BitBox branché quand je reçois des fond ?"
    },
    why20: {
      text: `Au démarrage, l'application génère des adresses dérivées de votre graine pour vérifier si elles ont reçu des fonds. Comme l'application peut générer un nombre presque infini d'adresses, elle pourrait prendre des années à effectuer cette vérification de solde. Pour limiter cette recherche, elle s'arrête après avoir généré 20 adresses vierges. Il s'agit de la "limite d'écart" et 20 est une norme commune bien que arbitraire. Voici les 20 adresses parmi lesquelles vous pouvez choisir.`,
      title: "Pourquoi seulement 20 adresses ?"
    },
    whyMany: {
      text: "Pour préserver la confidentialité et la sécurité, ne donnez jamais deux fois la même adresse. Si vous avez utilisé une adresse, cliquez sur la flèche à droite pour obtenir une nouvelle adresse. Vous pouvez générer jusqu'à 20 adresses à la fois. Voyez les adresses comme des numéros de facture. Toutes les adresses sont dérivées de votre graine, elle même unique.",
      title: "Pourquoi y a-t-il autant d'adresses ?"
    },
    whyVerify: {
      text: "Vous ne devriez pas faire confiance à votre ordinateur pour générer et afficher des adresses authentiques. Sa grande surface d'attaque le rend beaucoup plus vulnérable qu'un portefeuille physique. Pour le BitBox01, le bouton permettant de vérifier l'adresse envoie l'adresse de manière sécurisée à un téléphone mobile jumelé, à partir duquel vous pouvez également scanner et vérifier le code QR. Pour le BitBox02, l'adresse peut être vérifiée directement sur l'écran du BitBox02.",
      title: "Pourquoi devrais-je vérifier l'adresse en toute sécurité ?"
    }
  },
  send: {
    change: {
      text: "Le change sera restituée sur une adresse Taproot si vous disposez d'au moins un UTXO Taproot. Si vous utilisez le coin control, le change sera transféré vers une adresse Taproot s'il y a au moins un UTXO Taproot parmi les UTXOs sélectionnés. Dans tous les autres cas, le change est envoyé vers une adresse Native Segwit.",
      title: "Comment le change output (de sortie) est-il déterminé ?"
    },
    fee: {
      text: `Les frais sont basés sur la taille des données de la transaction et non sur son montant. L'estimation des frais à payer sont calculés par l'algorithme du logiciel Bitcoin Core en fonction de la priorité de traitement par le réseau choisie. Ils sont affichés s'ils ont une valeur différente des cibles ci-dessous.

Économique : 24 blocs (environ 4 heures pour Bitcoin, 1 heure pour Litecoin)
Bas : 12 blocs (environ 2 heures pour Bitcoin, 30 minutes pour Litecoin)
Normal : 6 blocs (environ 1 heure pour Bitcoin, 15 minutes pour Litecoin)
Élevé : 2 blocs (environ 20 minutes pour Bitcoin, 5 minutes pour Litecoin)
(Un bloc prend en moyenne dix minutes pour Bitcoin (2,5 minutes pour Litecoin) à miner et la charge du réseau peut varier considérablement au cours des périodes ci-dessus.)`,
      title: "Comment les frais sont-ils déterminés ?"
    },
    plugout: {
      text: "Non, une fois que vous avez effectué une transaction, il n'est pas nécessaire de laisser votre BitBox branché. Vous pouvez déconnecter votre BitBox.",
      title: "Dois-je laisser ma BitBox branchée pendant l'envoi ?"
    },
    priority: {
      text: "Votre transaction sera généralement confirmée plus rapidement par le réseau si les frais que vous êtes prêt à payer sont élevés.",
      title: "Quelle est la priorité du réseau ?"
    },
    revert: {
      text: `Une fois qu'une transaction est signée et envoyée (c'est-à-dire diffusée sur le réseau), elle ne peut plus être annulée. Vérifiez les transactions (y compris les frais) correctement avant de signer !
Si vous connaissez le destinataire et qu'il est prêt à vous renvoyer le même montant (moins les frais de transaction), vous pouvez lui communiquer une adresse de réception à vous.`,
      title: "Puis-je annuler une transaction ?"
    },
    whyFee: {
      text: `Les transactions sont en compétitions les unes avec les autres pour être confirmées par un mineur. Les mineurs choisissent quelles transactions sont à inclure dans la blockchain en fonction des frais de réseau.
Les mineurs votent sur l'historique des transactions. Puisqu'il n'y a pas de tiers de confiance qui impose un vote par personne (ce qui est l'intérêt des blockchains), les mineurs votent sur les transactions en sacrifiant une ressource coûteuse telle que la puissance de calcul. En récompense de leur travail, ils peuvent prétendre aux jetons fraichement créés ainsi qu'aux frais de toutes les transactions qu'ils ont incluses dans leur bloc.`,
      title: "Pourquoi y a-t-il des frais de réseau ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Si vous avez l'intention de connecter à votre nœud exclusivement à un seul réseau (par exemple, le réseau wifi de votre domicile), l'utilisation d'une communication réseau normale est suffisante.
Dans ce cas, il est conseillé que votre serveur Electrum fournisse un certificat TLS pour crypter la communication.
Si vous avez l'intention de connecter votre nœud depuis n'importe où, l'utilisation de Tor est la meilleure option. Aucun certificat TLS n'est nécessaire dans ce cas.`,
      title: "Dois-je utiliser clearnet TCP, TLS ou Tor ?"
    },
    instructions: {
      link: {
        text: "Guide pour connecter votre nœud"
      },
      text: "Pour un tutoriel complet, veuillez consulter notre guide :",
      title: "Comment je fais pour connecter ma BitBoxApp à mon nœud personnel?"
    },
    options: {
      text: `Il existe différentes solutions pour faire tourner votre propre nœud, comme par exemple acheter un appareil prêt à l'emploi, ou bien fabriquer le vôtre, ou bien encore utiliser Bitcoin Core.
Si vous souhaitez connecter votre BitBoxApp à votre nœud, assurez-vous qu'il tourne sur un serveur Electrum. Il s'agit d'un programme dédié qui permet à une application de portefeuille de communiquer avec votre nœud.
Les options supportées sont Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).`,
      title: "Quelles sont les options disponibles pour faire tourner un nœud?"
    },
    tor: {
      text: `Tor est l'acronyme de "The Onion Router", un logiciel libre et gratuit qui offre de nombreux avantages en matière de confidentialité et qui est particulièrement intéressant lorsque vous utilisez Bitcoin.
Si vous avez l'intention de vous connecter à votre nœud via Tor, assurez-vous que Tor est installé sur votre ordinateur, puis activez le proxy Tor dans les paramètres de BitBoxApp.
Sur la plupart des systèmes d'exploitation, il existe deux façons d'exécuter Tor :
1. Navigateur Tor : téléchargez et ouvrez le navigateur Tor. Cela permettra à BitBoxApp de se connecter au réseau Tor en activant le port 9150 dans les paramètres du proxy Tor.
2. Background service Tor : installez le daemon Tor, qui fonctionne toujours en fond. BitBoxApp peut alors se connecter en configurant le port 9050 dans les paramètres du proxy Tor.`,
      title: "Qu'est-ce que Tor, le proxy Tor et quel port dois-je utiliser ?"
    },
    what: {
      text: "Il est possible de synchroniser votre portefeuille depuis vos propres nœuds complets au lieu d'utiliser les serveurs de Shift.",
      title: "Qu'est-ce que cela ?"
    },
    why: {
      text: `Faire tourner votre propre nœud n'est pas nécessaire mais améliore la confidentialité et réduit le besoin de faire confiance aux autres.
Premièrement, cela signifie que vous utilisez Bitcoin de manière plus privée car le BitBoxApp ne se connectera pas à nos serveurs pour récupérer l'historique de vos transactions, mais récupérera ces informations à partir de votre propre nœud.
Deuxièmement, faire tourner votre propre nœud signifie que celui-ci vérifie lui-même toutes les transactions, en s'assurant que les règles de consensus sont bien respectées.`,
      title: "Pourquoi est-ce que je devrais faire tourner mon propre nœud ?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" en abrégé) est la plus petite unité de Bitcoin. Un Satoshi correspond à un cent millionième de bitcoin (0,00000001 BTC). Il tire son nom du créateur de Bitcoin, Satoshi Nakamoto.',
      title: "Qu'est-ce qu'un Satoshi?"
    },
    servers: {
      text: `Cette application communique avec les serveurs de Shift Crypto pour rechercher des mises à jour, charger des transactions et envoyer des informations aux applications mobiles appairées.
De plus, elle récupère les derniers taux de change de CoinGecko.
Les conversions sont calculées localement, aucun de vos montants n'est transmis.
Note : Pour Ethereum et les jetons ERC20, nous utilisons Etherscan.io APIs.`,
      title: "Avec quels serveurs cette application communique-t-elle ?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Fermer le guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Sur ordinateur, déplacez le curseur sur le graphique. Sur mobile, maintenez le doigt sur le graphique et faites-le glisser horizontalement.",
    title: "Comment voir les valeurs historiques sur le graphique?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Vous devez réinitialiser l'appareil et restaurer le portefeuille à partir d'une sauvegarde et du mot de passe de récupération.",
      title: "Que dois-je faire si j'ai oublié le mot de passe de l'appareil ?"
    },
    reset: {
      text: "Entrez un mauvais mot de passe 15 fois. Les dernières tentatives nécessitent une longue pression du bouton tactile sur l'appareil.",
      title: "Comment réinitialiser l'appareil ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Le dispositif doit clignoter une fois qu'il est inséré. Assurez-vous qu'il soit inséré dans le bon sens. Si vous rencontrez des difficultés, veuillez nous contacter via le lien ci-dessous.

La BitBox01 n'est pas utilisable sur mobile. Veuillez utiliser la BitBoxApp sur votre ordinateur pour connecter votre BitBox01.`,
      title: "Mon BitBox01 n'est pas reconnu"
    },
    getDevice: {
      link: {
        text: "Commander un BitBox"
      },
      text: "Vous pouvez acheter un BitBox dans notre boutique en ligne :",
      title: "Comment puis-je obtenir un appareil BitBox ?"
    },
    internet: {
      text: "Oui, une connexion à Internet est nécessaire pour synchroniser le portefeuille, envoyer des transactions et récupérer les derniers taux de change.",
      title: "Cette application nécessite-t-elle une connexion à Internet ?"
    },
    lostDevice: {
      link: {
        text: "Centre de sauvegarde"
      },
      text: "Vous pouvez accéder à vos comptes via un nouveau BitBox ou depuis notre centre de sauvegarde.",
      title: "J'ai perdu mon appareil. Que faire ?"
    },
    useWithoutDevice: {
      text: "Ce n'est malheureusement pas possible pour le moment.",
      title: "Puis-je utiliser l'application sans appareil Bitbox ?"
    },
    welcome: {
      text: "Merci d'utiliser cette application développée par Shift Crypto en Suisse. Nous apprécions tous les commentaires dont vous pourriez nous faire part. Vous pouvez nous les soumettre en cliquant sur le lien en bas de page.",
      title: "Bienvenue dans l'application BitBox !"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si vous utilisez un nouveau téléphone/ordinateur avec la BitBoxApp, vous devrez vous connecter à nouveau aux DApps. Vous verrez alors vos coins sur la DApps comme précédemment.",
      title: "Je ne vois pas mes précédentes connexions."
    },
    supportedNetworks: {
      text: "Actuellement, seul le mainnet d’Ethereum est supporté lorsque vous utilisez WalletConnect dans la BitBoxApp. Pour utiliser d'autres chaînes compatibles EVM, veuillez utiliser l'extension de navigateur Rabby wallet.",
      title: "Quels sont les réseaux supportés ?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect est un protocole de communication pour les applications web3. Il vous permet de vous connecter facilement aux DApps et aux portefeuilles web reposant sur Ethereum sans utiliser d'application tierce; ceci constitue une solution particulièrement pratique pour les utilisateurs Android de la BitBoxApp.",
      title: "Qu'est-ce que WalletConnect ?"
    }
  }
}, headerssync$e = {
  blocksSynced: "{{blocks}} blocs synchronisés"
}, hiddenWallet$e = {
  info1HTML: "Pour un besoin de déni plausible, un portefeuille caché peut être créé à partir d'une combinaison de <strong> différents </strong> mot de passe de récupération et d'appareil.",
  info2HTML: "Définissez le mot de passe de l'appareil et de récupération que vous souhaitez associer à votre portefeuille caché ci-dessous. Le mot de passe de l'appareil et le mot de passe de récupération doivent être <strong> différents </strong> de ceux que vous avez définis pour votre portefeuille principal.",
  passwordLabel: "Mot de passe de récupération caché",
  passwordPlaceholder: "Veuillez confirmer le mot de passe de récupération caché",
  pinLabel: "Mot de passe de l'appareil caché",
  pinRepeatLabel: "Répéter le mot de passe de l'appareil caché",
  pinRepeatPlaceholder: "Veuillez confirmer le mot de passe de l'appareil caché",
  success: "Un portefeuille caché a été créé avec succès. Rebranchez votre BitBox pour le déverrouiller."
}, initialize$e = {
  create: "Définir le mot de passe de l'appareil",
  creating: "Définition du mot de passe de l'appareil en cours…",
  error: {
    e102: "Le mot de passe de l'appareil doit comporter au moins 4 caractères."
  },
  info: {
    description1: "Choisissez le mot de passe de votre appareil. Celui-ci sera utilisé pour déverrouiller votre BitBox.",
    description2: "Vous pouvez utiliser des chiffres, des lettres et des symboles. Les mots de passe longs offrent une meilleure sécurité.",
    description3: "Si vous perdez le mot de passe de votre appareil, vous devrez le réinitialiser et restaurer la sauvegarde de votre portefeuille.",
    subtitle: "Vous allez maintenant définir le mot de passe de votre appareil",
    title: "Initialisation de votre appareil"
  },
  input: {
    label: "Mot de passe de l'appareil",
    labelRepeat: "Répéter le mot de passe de l'appareil",
    placeholderRepeat: "Veuillez confirmer le mot de passe de l'appareil"
  }
}, invalidFormat$e = "Format invalide", language$f = {
  title: "Choisir la langue"
}, legacyhiddenwallet$e = {
  disable: "Désactiver le portefeuille Legacy caché",
  enable: "Activer le portefeuille Legacy caché",
  successDisable: "Portefeuille Legacy caché désactivé avec succès.",
  successEnable: "Portefeuille Legacy caché activé avec succès. Reconnectez votre BitBox et entrez le mot de passe de l'appareil caché pour accéder au portefeuille Legacy caché."
}, loading$e = "chargement en cours…", manageAccounts$8 = {
  accountHidden: "Ce compte a été retiré de vos comptes watch-only. Pour le voir à nouveau, veuillez brancher votre BitBox02.",
  editAccount: "Modifier",
  editAccountNameTitle: "Modifier le nom du compte",
  noAccounts: "aucun compte trouvé",
  settings: {
    hideTokens: "Cacher les jetons",
    showTokens: "Afficher les jetons ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Ajouter et afficher/masquer les comptes",
  title: "Gestion des comptes",
  watchAccount: "Compte de suivi",
  watchAccountDescription: "Ce compte fait partie de vos comptes watch-only. Vous pouvez le faire disparaître de vos comptes watch-only à l'aide du bouton."
}, mobile$9 = {
  usingMobileDataWarning: "Utilisation des données mobiles : cette application peut télécharger jusqu'à quelques centaines de mégaoctets de données d'en-tête de blockchain après avoir déverrouillé un compte. Veuillez vous connecter au Wi-Fi afin d'éviter d'utiliser les données mobiles. Après l'avoir quitté, ce message ne s'affichera plus."
}, newSettings$7 = {
  about: {
    appVersion: {
      title: "Version de l'application"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Verrouiller l'accès à l'application via le verrouillage de l'écran/empreinte digitale.",
      title: "Verrouillage de l'écran"
    },
    coinControl: {
      description: "Sélectionnez quelles UTXO font partie d'une transaction afin d'améliorer la confidentialité"
    },
    customFees: {
      description: "Vous permet de saisir vos propres frais lors de l'envoi."
    },
    torProxy: {
      description: "Se connecter via Tor pour une meilleure confidentialité."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Ces devises supplémentaires peuvent être sélectionnées sur la page de votre compte.",
      title: "Devises activées"
    },
    darkmode: {
      description: "Voir la BitBoxApp en dark mode (mode sombre)."
    },
    defaultCurrency: {
      description: "Sélectionnez votre devise par défaut",
      title: "Devise par défaut"
    },
    hideAmounts: {
      description: "Affiche un bouton permettant de masquer votre solde et vos montants afin d'améliorer votre confidentialité lorsque vous utilisez l'application en public.",
      hideAmounts: "Cacher les montants",
      showAmounts: "Afficher les montants",
      title: "Autoriser la dissimulation des montants"
    },
    language: {
      description: "Quelle langue souhaitez vous que BitBoxApp utilise?",
      title: "Langue"
    },
    toggleSats: {
      description: "Activer ou désactiver l'unité des Satoshis"
    }
  }
}, note$a = {
  input: {
    description: "(facultatif)",
    placeholder: "Ajouter une note..."
  },
  title: "Note"
}, notification$e = {
  newTxs_one: "Nouvelle transaction dans : {{accountName}}",
  newTxs_other: "{{count}} nouvelles transactions dans : {{accountName}}"
}, pairing$e = {
  aborted: {
    text: "L'appairage a été annulé depuis l'application mobile.",
    title: "Abandonné"
  },
  button: "Appairer l'application mobile",
  confirm: "Êtes-vous sûr de vouloir appairer votre BitBox ? Notez qu'ensuite le téléphone mobile est nécessaire pour effectuer une transaction.",
  connectOnly: {
    button: "Connecter l'application mobile",
    title: 'Scannez depuis notre application mobile en cliquant sur "Connecter à une nouvelle application de bureau"'
  },
  error: {
    text: "Quelque chose s'est mal passé. Veuillez recommencer.",
    title: "Erreur"
  },
  pullFailed: {
    text: "Impossible de faire passer un message de votre mobile par le serveur relais. Le serveur relais est peut-être hors ligne, veuillez contacter l'assistance.",
    title: "Échec de transfert"
  },
  reconnectOnly: {
    button: "Reconnecter l'application mobile"
  },
  scanningFailed: {
    text: "Le mobile n'a pas pu scanner le message correctement. Veuillez réessayer.",
    title: "Échec de la numérisation"
  },
  start: {
    hideAppQRCode: "Masquer le QR Code",
    revealAppQRCode: "Afficher le QR Code",
    step1: "Si vous ne possédez pas encore l'application mobile, vous pouvez scanner le QR code correspondant à l'App Store ou au Play Store en fonction de votre téléphone.",
    step2: `Scannez depuis notre application mobile, que vous pouvez trouver sous le nom "Digital Bitbox 2FA" dans les magasins d'applications pour iOS et Android :`
  },
  started: {
    text: "Veuillez maintenant suivre les instructions sur l'application mobile.",
    title: "Génial"
  },
  success: {
    text: "Félicitations, vous avez appairé votre BitBox à l’application mobile !",
    title: "Succès"
  },
  timeout: {
    text: "Le temps d'appairage expire après deux minutes. Recommencez si vous souhaitez toujours appairer l'application mobile.",
    title: "Expiration de session"
  },
  title: "Appairage mobile"
}, passphrase$8 = {
  considerations: {
    button: "Considérations relatives à la sauvegarde",
    message: `La passphrase ajoute une couche de protection supplémentaire  à la sauvegarde de votre portefeuille (carte microSD ou mots de récupération). Si quelqu'un a accès à votre sauvegarde, il aura également besoin de la passphrase pour accéder à votre portefeuille.

Cependant, cela signifie que vous aurez besoin <strong>à la fois de la passphrase ET de la sauvegarde du portefeuille</strong>  pour restaurer votre portefeuille pour lequel la passphrase est activée, au cas où votre BitBox02 serait perdu ou cassé. Si vous oubliez ou perdez votre passphrase, vous perdrez l'accès à toutes les fonds se trouvant dans ce portefeuille.

Lorsque vous stockez votre passphrase, pensez bien à la conserver dans un endroit différent de celui de votre sauvegarde. De cette façon, si venait à trouver votre sauvegarde, il n'aurait pas accès à votre passphrase également.`,
    title: "Considérations relatives à la sauvegarde"
  },
  disable: "Désactiver la passphrase",
  disableInfo: {
    button: "Désactiver",
    message: `Une fois la passphrase désactivée, il ne vous sera plus demandé de saisir une passphrase après avoir déverrouillé votre BitBox02. Par conséquent, vous entrerez dans votre portefeuille par défaut.

Tous les coins (monnaies) se trouvant sur votre portefeuille avec passphrase seront toujours sur ce portefeuille, mais vous ne pourrez plus y accéder car après avoir déverrouillé votre BitBox02, vous ouvrirez votre portefeuille par défaut.

Pour accéder de nouveau à vos portefeuilles avec passphrase, il suffit de réactiver la fonction passphrase et de saisir la passphrase correspondante après déverrouillage de la BitBox02.

<strong>Astuce:</strong> Vous pouvez toujours accéder à votre portefeuille d'origine en laissant la phrase de passe vide.`
  },
  enable: "Activer la passphrase",
  error: {
    e104: "La modification des paramètres de la passphrase a été interrompue."
  },
  how: {
    button: "A quoi ça ressemble",
    message: `Une passphrase ne fonctionne pas comme les mots de passe auxquels vous êtes habitué. Si vous vous trompez dans la saisie de votre passphrase, vous ne serez pas averti. En effet, <strong>chaque passphrase crée un portefeuille distinct, mais valide</strong>. Cela signifie que vous pouvez utiliser autant de passphrases que vous le souhaitez afin de créer autant de portefeuilles correspondants. Mais on ne peut accéder à chaque portefeuille qu'en saisissant la passphrase associée.

Au moment où vous branchez votre BitBox02, le mot de passe de l'appareil vous sera demandé de manière habituelle. Ensuite, il vous sera demandé d'entrer une passphrase sur l'appareil.

Après avoir saisi la passphrase, vous verrez s'afficher cette même passphrase que vous avez entrée. Cela vous permet de confirmer que vous l'avez saisie correctement.`,
    title: "Comment ça marche"
  },
  intro: {
    message: `Une passphrase fournit une couche supplémentaire de sécurité en plus pour votre portefeuille.
Voyons comment cela fonctionne.`,
    title: "Configurer la passphrase"
  },
  progressDisable: {
    message: "Confirmez sur votre BitBox que vous souhaitez <strong>désactiver</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  progressEnable: {
    message: "Confirmez sur votre BitBox que vous voulez <strong>activer</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  successDisabled: {
    message: `Passphrase optionnelle <strong>activée avec succès</strong> !
Il vous sera demandé de fournir une passphrase à partir de maintenant.`,
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02",
    title: "Passphrase activée"
  },
  successEnabled: {
    message: `Passphrase optionnelle <strong>désactivée avec succès</strong> !
Il ne vous sera plus demandé de fournir une passphrase à partir de maintenant.`,
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02.",
    tips: "Astuces",
    tipsList: [
      "Nous vous suggérons d'envoyer d'abord un petit montant dans le portefeuille avec passphrase. Ensuite, débranchez puis rebranchez la BitBox02 avant de saisir votre mot de passe et votre passphrase. Si vous avez entré votre passphrase correctement, vous devriez voir les fonds dans votre portefeuille.",
      "Si vous souhaitez accéder à votre portefeuille d'origine sans passphrase, vous pouvez toujours le faire en ne saisissant tout simplement rien lorsque vous êtes invité à fournir la passphrase. Vous pouvez également choisir de désactiver la fonction passphrase."
    ],
    title: "Passphrase désactivée"
  },
  summary: {
    button: "Activer la passphrase",
    title: "Résumé",
    understand: "Je comprends le fonctionnement de la passphrase et les risques qui lui sont associés.",
    understandList: [
      "La passphrase est une couche de sécurité supplémentaire en plus de votre sauvegarde.",
      "La saisie d'une passphrase différente générera à chaque fois un porte-monnaie différent.",
      "Pour restaurer votre portefeuille, vous avez besoin <strong>à la fois de la passphrase et de la sauvegarde</strong>.",
      "Si vous oubliez votre passphrase, vous ne pourrez plus accéder à vos fonds."
    ]
  },
  what: {
    button: "Découvrez comment cela fonctionne",
    message: `Un portefeuille est créé (dérivé) à partir d'un  nombre aléatoire très grand, également appelé "seed" (graine). Cette seed est créée lors de la première configuration de votre BitBox02 et est sauvegardée via la carte microSD ou les mots de récupération. Toute personne ayant accès à la seed dispose d'un contrôle total sur les fonds de ce portefeuille.

Une passphrase est un <strong>secret optionnel</strong>, ajouté à la seed. Lorsque vous utilisez une passphrase, chaque passphrase crée un nouveau portefeuille basé sur la seed + la passphrase (secret optionnel). Une passphrase peut être n'importe quoi : des lettres, des mots, des caractères spéciaux ou même être vide. Le portefeuille par défaut est en fait dérivé de la seed + passphrase vide.

La passphrase fait partie de la norme BIP39, ce qui signifie qu'elle est compatible avec tous les portefeuilles qui supportent cette dernière.`,
    title: "Qu'est-ce qu'une passphrase?"
  },
  why: {
    button: "Pourquoi utiliser une passphrase",
    message: `La BitBox02 protège la seed contre l'extraction depuis l'appareil lui-même, mais la sauvegarde (carte microSD ou mots de récupération) donne un accès complet au portefeuille. C'est pourquoi elle doit être stockée dans un endroit sûr !

Puisqu'une passphrase crée un nouveau portefeuille en utilisant votre seed existante, le portefeuille avec passphrase nécessite à la fois <strong> votre sauvegarde ET votre passphrase pour être restauré</strong>. L'avantage de ceci est que si quelqu'un trouve votre sauvegarde, il a toujours besoin de la passphrase pour accéder au poretefeuille avec passphrase.

En outre, la fonction passphrase vous permet de créer plusieurs portefeuilles sur le même appareil, ou "portefeuilles cachés", en plus du portefeuille par défaut.`,
    title: "Pourquoi utiliser une passphrase"
  }
}, password$e = {
  show: "Montrer {{label}}",
  warning: {
    caps: "ATTENTION : le verrouillage des majuscules (⇪) est activé",
    paste: 'Pour coller du texte, activez "Montrer {{label}}"'
  }
}, random$f = {
  button: "Générer un numéro aléatoire",
  description: "Votre BitBox a généré le numéro aléatoire à {{bits}}-bit suivant :"
}, receive$g = {
  changeScriptType: "Changer de type d'adresse",
  label: "Votre adresse",
  onlyThisCoin: {
    description: "Pour recevoir d'autres coins, activez-les dans les paramètres. Si vous déposez d'autres coins, il se peut qu'ils ne soient pas accessibles.",
    warning: "Assurez-vous de ne recevoir que {{coinName}} sur cette adresse."
  },
  scriptType: {
    p2tr: "Taproot (nouveau format d'adresse)",
    p2wpkh: "Native Segwit (par défaut)",
    "p2wpkh-p2sh": "Wrapped Segwit (format compatible)"
  },
  selectAccount: "Sélectionner un compte",
  showFull: "Afficher et vérifier l'adresse complète sur l'appareil",
  taprootWarning: `Remarque : Taproot est une nouvelle fonctionnalité sur Bitcoin et n'est pas encore largement adoptée. Les fonds reçus sur les adresses Taproot peuvent potentiellement ne pas être visibles depuis les portefeuilles "watch-only" tiers. De nombreux portefeuilles et exchanges ne sont pas encore en mesure d'envoyer des fonds aux adresses Taproot.`,
  title: "Recevoir {{accountName}}",
  verify: "Vérifier l'adresse de façon sécurisée",
  verifyBitBox01: "Vérifier l'adresse sur l'application mobile",
  verifyBitBox02: "Vérifier l'adresse sur le BitBox02",
  verifyInstruction: "Veuillez vérifier que l'adresse suivante correspond à celle affichée sur votre appareil.",
  warning: {
    secureOutput: "Veuillez appairer votre BitBox avec votre téléphone mobile pour activer la vérification sécurisée des adresses. Cliquez sur «Gérer l'appareil» dans la barre latérale."
  }
}, reset$e = {
  description: "Toutes les données vont être supprimées de l'appareil. Ceci inclut votre Clé Privée !",
  notReset: "Appareil NON réinitialisé.",
  title: "Réinitialiser l'appareil aux paramètres usine",
  understand: "J'ai une sauvegarde et je connais mon mot de passe de récupération",
  understandBB02: "J'ai une sauvegarde valide"
}, securityInformation$e = {
  create: {
    description1: "Il est recommandé de configurer votre appareil dans un environnement sécurisé; c'est-à-dire loin d'autres personnes qui seraient susceptibles de voir le mot de passe que vous choisissez.",
    description2: "Il vous sera demandé de créer deux mots de passe.",
    description3: "Le premier est le <strong>mot de passe de l'appareil</strong> qui déverrouille votre BitBox et peut être modifié ultérieurement.",
    description4: "Le second est le <strong>mot de passe de récupération</strong> qui déverrouille votre portefeuille. Ce mot de passe ne peut PAS être changé ultérieurement.",
    description5: "Le portefeuille que vous créez sera sauvegardé dans un fichier sur la carte microSD fournie. Elle peut être utilisé en cas d'urgence pour récupérer vos fonds avec l'aide de votre <strong>mot de passe de récupération</strong>.",
    title: "Information de sécurité"
  },
  restore: {
    description1: "Il vous sera demandé d'insérer la carte microSD utilisée pour votre sauvegarde.",
    description2: "Pour restaurer votre appareil, vous aurez besoin de votre mot de passe de récupération.",
    description3: "Veuillez faire attention lorsque vous entrez le mot de passe de récupération. Tout mot de passe que vous entrez créera un portefeuille valide. Si vous entrez un mot de passe différent, le solde du portefeuille ne sera pas celui attendu.",
    title: "Information de sécurité"
  }
}, seed$e = {
  agreements: {
    "funds-access": "Je ne pourrai PAS accéder à mes fonds si j'oublie mon mot de passe de récupération",
    "password-change": "Je ne peux PAS changer le mot de passe de récupération ultérieurement",
    "password-required": "Le mot de passe de récupération est nécessaire pour restaurer un portefeuille à partir d'une sauvegarde."
  },
  create: "Créer un portefeuille",
  creating: "Créer un portefeuille",
  description: "Je comprends que :",
  error: {
    e102: "Le mot de passe doit contenir au minimum 4 caractères.",
    e200: "Vous devez insérer une carte microSD dans votre BitBox afin de créer un portefeuille, une sauvegarde se créée ainsi automatiquement."
  },
  info: {
    button: "Définir le mot de passe maintenant",
    description1: "Insérez la carte microSD dans le BitBox",
    description2: 'Choisissez un mot de passe de récupération pour le portefeuille et sélectionnez "Définir le mot de passe de récupération maintenant".',
    description3: "La sauvegarde sur une carte microSD et votre mot de passe de récupération constituent le seul moyen de récupérer vos fonds en cas de perte ou de vol de votre BitBox.",
    description4: "Vous ne pouvez pas modifier votre mot de passe de récupération sans avoir transféré vos fonds au préalable.",
    title: "Créer un nouveau portefeuille"
  },
  password: {
    label: "Mot de passe de récupération",
    repeatPlaceholder: "Répéter le mot de passe de récupération"
  },
  walletName: {
    label: "Nom du portefeuille"
  }
}, seedRestore$e = {
  error: {
    e200: "La restauration d'un portefeuille à partir d'une sauvegarde nécessite la carte microSD."
  },
  info: {
    description1: "Insérez la carte microSD dans le BitBox et cliquez sur «Continuer»",
    description2: 'Choisissez une sauvegarde et cliquez sur "Restaurer"',
    description3: "Entrez le mot de passe de récupération",
    description4: "Vous devez confirmer avoir compris qu'un mot de passe incorrect créera un portefeuille différent.",
    title: "Comment restaurer un portefeuille à partir d'une sauvegarde"
  }
}, send$g = {
  abort: "La transaction a été annulée.",
  address: {
    label: "Adresse du destinataire",
    placeholder: "Entrer l'adresse"
  },
  amount: {
    label: "Montant",
    placeholder: "Entrer le montant"
  },
  availableBalance: "Solde disponible",
  button: "Revoir",
  coincontrol: {
    address: "Adresse",
    outpoint: "Point de sortie",
    title: "Envoi à partir de"
  },
  confirm: {
    "selected-coins": "Coins sélectionnés",
    title: "Confirmer et envoyer la transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Il semblerait que vous n'ayez pas assez d'Ether pour régler cette transaction ERC20. Veuillez vous assurer que vous avez suffisamment d'Ether dans votre portefeuille.",
    feeTooLow: "Frais pas assez élevés",
    feesNotAvailable: "Estimation des frais impossible",
    insufficientFunds: "fonds insuffisants",
    invalidAddress: "adresse invalide",
    invalidAmount: "montant invalide",
    invalidData: "données invalides"
  },
  fee: {
    customPlaceholder: "Entrer le montant",
    label: "Frais de réseau",
    placeholder: "Indisponible"
  },
  feeTarget: {
    customLabel: "Taux des frais",
    customLabel_eth: "Prix du Gas",
    description: {
      economy: "4 heures (24 blocs)",
      economy_eth: "30 minutes maximum",
      economy_ltc: "1 heure (24 blocs)",
      high: "20 minutes (2 blocs)",
      high_eth: "30 secondes maximum",
      high_ltc: "5 minutes (2 blocs)",
      low: "2 heures (12 blocs)",
      low_eth: "5 minutes maximum",
      low_ltc: "30 minutes (12 blocs)",
      normal: "1 heure (6 blocs)",
      normal_eth: "2 minutes maximum",
      normal_ltc: "15 minutes (6 blocs)"
    },
    estimate: "Temps d'attente estimé avant confirmation:",
    label: {
      custom: "Personnalisé",
      economy: "Économique",
      high: "Élevé",
      low: "Faible",
      normal: "Normal"
    },
    placeholder: "Calcul des frais…"
  },
  maximum: "Envoyer tout",
  maximumSelectedCoins: "",
  noFeeTargets: "L'estimation des frais n'est pas disponible actuellement. Veuillez réessayer plus tard ou saisir des frais personnalisés.",
  priority: "Priorité",
  scanQR: "Scanner un QR Code",
  signprogress: {
    description: "Cette transaction contient beaucoup de données. Pour la signer entièrement, il vous sera demandé de confirmer {{steps}} fois.",
    label: "Avancement"
  },
  success: "La transaction a été signée et envoyée.",
  title: "Envoyer {{accountName}}",
  toggleCoinControl: "Sélecteur de coins",
  transactionDetails: "Détails de la transaction"
}, settings$f = {
  about: "À propos",
  accounts: "Comptes",
  advancedSettings: "Paramètres avancés",
  appearance: "Apparence",
  electrum: {
    add: "Ajouter un serveur",
    "add-server": "Ajouter",
    check: "Vérifier",
    checkFailed: "Échoué",
    checkSuccess: "Connexion à {{hôte}} réussie",
    checking: "Vérification",
    "download-cert": "Télécharger le certificat distant",
    "remove-server": "Retirer",
    removeConfirm: "Supprimer {{serveur}} ?",
    reset: "Réinitialisation aux valeurs par défaut",
    resetConfirm: 'Voulez-vous retirer tous les serveurs et installer ceux "par défaut" ?',
    servers: "Serveurs",
    step1: "1",
    "step1-text": "Entrez le endpoint.",
    step2: "2",
    "step2-text": "Entrez un certificat de la chaîne de certificats du serveur. Vous pouvez également télécharger le certificat isolé et le comparer visuellement.",
    "step2-text-tcp": "Vous pouvez sauter cette étape si vous ne souhaitez pas utiliser TLS.",
    step3: "3",
    "step3-text": "Vérifiez la connexion et ajoutez le serveur.",
    step4: "4",
    "step4-text": "Redémarrez l'appareil. Si vous ne supprimez pas les serveurs par défaut votre nœud sera ajouté comme une redondance.",
    "title-btc": "Serveurs Bitcoin Electrum",
    "title-ltc": "Serveurs Litecoin Electrum",
    "title-tbtc": "Serveurs Bitcoin Testnet Electrum",
    "title-tltc": "Serveurs Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activer le contrôle des monnaies",
    electrum: {
      description: "Vous pouvez vous connecter à votre propre nœud Electrum.",
      title: "Connectez votre nœud complet"
    },
    fee: "Activer la personnalisation des frais",
    setProxyAddress: "Définir une adresse proxy",
    title: "Paramètres avancés",
    useProxy: "Activer tor proxy",
    useSats: "Afficher les valeurs des BTC en Satoshis"
  },
  header: {
    home: "Accueil"
  },
  info: {
    "out-of-date": "Nouvelle mise à jour disponible",
    title: "Info",
    "up-to-date": "Votre application est à jour",
    version: "Version de l'application"
  },
  restart: "Veuillez redémarrer la BitBoxApp pour que les changements prennent effet.",
  services: {
    title: "Services"
  },
  success: "Veuillez débrancher et reconnecter le BitBox pour que les modifications prennent effet.",
  title: "Paramètres"
}, setup$e = "Configuration de l'appareil", sidebar$f = {
  buy: "Acheter de la crypto",
  device: "Gérer l'appareil",
  leave: "Quitter",
  settings: "Paramètres"
}, success$l = {
  create: {
    info1: "Votre portefeuille a été correctement sauvegardé sur la carte microSD. Retirez-la et gardez-la en sécurité.",
    info2: "Vous avez créé un mot de passe sécurisé pour l'appareil qui permet de déverrouiller votre BitBox.",
    info3: "Vous avez créé un mot de passe de récupération sécurisé pour votre portefeuille, qui déverrouille vos fonds et permet la restauration de vos sauvegardes.",
    summary: "Voici un résumé de ce que vous avez fait",
    title: "Succès"
  },
  getstarted: "Commencer",
  restore: {
    summary: "Vous avez restauré avec succès un portefeuille à partir de votre sauvegarde.",
    title: "Succès"
  }
}, transaction$f = {
  confirmation: "Confirmations",
  details: {
    activity: "Activité",
    address: "Adresse",
    amount: "Montant",
    date: "Date",
    fiat: "Devise",
    fiatAmount: "Montant en Fiat",
    fiatAtTime: "Fiat au moment de la transaction",
    status: "Statut",
    type: "Type"
  },
  explorer: "Identification de transaction",
  explorerTitle: "Ouvrir dans un Explorateur de blocs externe",
  fee: "Frais",
  fiatHistorical: "Historique",
  gas: "Gaz",
  note: {
    edit: "Modifier la note",
    save: "Sauvegarder la note"
  },
  pending: "Transaction en attente",
  size: "Taille",
  status: {
    complete: "Terminé",
    failed: "Échoué",
    pending: "En attente"
  },
  tx: {
    received: "Reçu de",
    sent: "Envoyé à"
  },
  vsize: "Taille virtuelle",
  weight: "Poids"
}, transactions$e = {
  errorLoadTransactions: "Une erreur s'est produite lors du chargement des transactions",
  placeholder: "Aucune transaction pour le moment."
}, unknownError$e = "Une erreur inconnue s'est produite : {{errorMessage}}", unlock$e = {
  description: "Entrez le mot de passe de votre appareil pour le déverrouiller.",
  error: {
    e109_normal: "Mauvais mot de passe. {{remainingAttempts}} essais restant avant que l'appareil se réinitialise.",
    e109_touch: "$t(unlock.error.e109_normal) La prochaine connexion nécessite de maintenir le bouton tactile enfoncé.",
    e113: "En raison de nombreuses tentatives de connexion, la connexion suivante nécessite de maintenir le bouton tactile enfoncé pendant 4 secondes."
  },
  input: {
    label: "Mot de passe de l'appareil",
    placeholder: "Entrez le mot de passe de votre appareil pour le déverrouiller"
  },
  unlocking: "Déverrouillage…"
}, upgradeFirmware$f = {
  button: "Mettre à jour le firmware",
  description: "Voulez-vous mettre à jour le firmware de la version {{currentVersion}} à la {{newVersion}} ?",
  label: "Une mise à jour du firmware de votre BitBox est nécessaire.",
  locked: "Pour effectuer la mise à jour de la {{currentVersion}} à la {{newVersion}}, veuillez presser longuement le bouton tactile.",
  title: "Mettre à jour le firmware",
  unlocked: "Le chargeur d'amorçage est déverrouillé. Pour continuer, veuillez :",
  unlocked1: "Débrancher et rebrancher votre BitBox",
  unlocked2: "La LED s'allumera lorsque votre BitBox sera rebranché",
  unlocked3: "Appuyez sur le bouton tactile lorsque la LED s'allume"
}, walletConnect$8 = {
  connect: {
    button: "Connecter",
    dappLabel: "Saisir l'adresse URI de la Dapp",
    invalidPairingUri: "Uri d'appariement non valide"
  },
  dashboard: {
    allSessions: "Toutes les sessions",
    disclaimer: "Walletconnect est un protocole permettant de se connecter à des Dapps basées sur Ethereum. Ces Dapps sont gérées par des services tiers, ne vous connectez donc uniquement qu'à des Dapps en lesquelles vous avez entièrement confiance et assurez-vous de toujours savoir ce que vous signez lorsque vous effectuez une transaction.",
    newConnection: "Nouvelle connexion",
    noConnectedSessions: "Aucun compte n'est actuellement connecté à une Dapp."
  },
  invalidPairingChain: "Erreur dans l'approbation de l'appariement. Veillez à utiliser l'une des chaînes prises en charge : {{chains}}",
  pairingRequest: {
    approve: "Approuver la connexion",
    reject: "Rejeter",
    title: "Nouvelle demande de connexion de"
  },
  pairingSuccess: "Dapp connectée avec succès. Vous pouvez continuer sur le site de la Dapp.",
  signingRequest: {
    account: "Compte",
    chain: "Chaîne",
    dapp: "Dapp",
    data: "Données",
    dataParsingError: "Échec de l'analyse des données",
    decodeError: "Échec de déchiffrage du message",
    method: {
      sendTransaction: "Signer et envoyer la transaction",
      signMessage: "Signer un message",
      signTransaction: "Signer une transaction",
      signTypedData: "Signer les données saisies"
    },
    successfullySigned: "Requête signée avec succès",
    walletConnectRequest: "Demande WalletConnect"
  },
  useNewUri: "Cet URI a déjà été utilisé pour une tentative de connexion. Veuillez utiliser un nouvel URI.",
  walletConnect: "WalletConnect"
}, warning$k = {
  receivePairing: "Veuillez appairer le BitBox pour activer la vérification d'adresse sécurisée. Cliquez sur «Gérer l'appareil» dans la barre latérale.",
  sdcard: "Conservez la carte micro SD séparément du BitBox, à moins que vous ne  souhaitiez gérer les sauvegardes.",
  sendPairing: "Veuillez appairer le BitBox pour vérifier le détails de la transaction en toute sécurité. Cliquez sur «Gérer l'appareil» dans la barre latérale."
}, welcome$e = {
  connect: "Connexion BitBox02",
  getStarted: "Commençons en installant le firmware sur votre BitBox02",
  insertBitBox02: "Pour le BitBox02, appuyez sur l'appareil pour continuer.",
  insertDevice: "Pour commencer, veuillez connecter votre appareil",
  title: "Bienvenue"
}, appTranslationsFR = {
  account: account$e,
  accountInfo: accountInfo$e,
  accountSummary: accountSummary$e,
  addAccount: addAccount$f,
  aopp: aopp$8,
  app: app$e,
  auth: auth$7,
  backup: backup$e,
  bb02Bootloader: bb02Bootloader$e,
  bitbox: bitbox$e,
  bitbox02Interact: bitbox02Interact$e,
  bitbox02Settings: bitbox02Settings$e,
  bitbox02Wizard: bitbox02Wizard$e,
  blink: blink$e,
  bootloader: bootloader$e,
  button: button$i,
  buy: buy$a,
  changePin: changePin$e,
  chart: chart$a,
  checkSDcard: checkSDcard$e,
  clickHere: clickHere$e,
  confirm: confirm$g,
  confirmOnDevice: confirmOnDevice$e,
  connectKeystore: connectKeystore$7,
  darkmode: darkmode$8,
  device: device$e,
  deviceLock: deviceLock$e,
  deviceSettings: deviceSettings$e,
  deviceTampered: deviceTampered$e,
  dialog: dialog$f,
  error: error$a,
  fiat: fiat$g,
  footer: footer$g,
  generic: generic$a,
  genericError: genericError$e,
  goal: goal$e,
  guide: guide$f,
  headerssync: headerssync$e,
  hiddenWallet: hiddenWallet$e,
  initialize: initialize$e,
  invalidFormat: invalidFormat$e,
  language: language$f,
  legacyhiddenwallet: legacyhiddenwallet$e,
  loading: loading$e,
  manageAccounts: manageAccounts$8,
  mobile: mobile$9,
  newSettings: newSettings$7,
  note: note$a,
  notification: notification$e,
  pairing: pairing$e,
  passphrase: passphrase$8,
  password: password$e,
  random: random$f,
  receive: receive$g,
  reset: reset$e,
  securityInformation: securityInformation$e,
  seed: seed$e,
  seedRestore: seedRestore$e,
  send: send$g,
  settings: settings$f,
  setup: setup$e,
  sidebar: sidebar$f,
  success: success$l,
  transaction: transaction$f,
  transactions: transactions$e,
  unknownError: unknownError$e,
  unlock: unlock$e,
  upgradeFirmware: upgradeFirmware$f,
  walletConnect: walletConnect$8,
  warning: warning$k,
  welcome: welcome$e
}, account$d = {
  disconnect: "接続が切れました。再試行中です…",
  export: "エクスポート",
  exportTransactions: "取引一覧をCSV形式でダウンロードフォルダにエクスポート",
  fatalError: "予期せぬエラーが起こりました。",
  incoming: "受信中",
  initializing: "ブロックチェーンから情報を取得中…",
  maybeProxyError: "Torプロキシが有効化されています。Torプロキシが正しく動作していることを確認するか、プロキシ設定を無効にしてください。",
  reconnecting: "接続が切れました。再試行中…",
  syncedAddressesCount: "{{count}}個のアドレスをスキャンしました"
}, accountInfo$d = {
  address: "アドレス",
  buyCTA: {
    buy: "{{unit}}を購入する",
    buyCrypto: "仮想通貨を購入",
    information: {
      looksEmpty: "このウォレットは空のようです",
      start: "いくつかのコインをウォレットに入金するか、BitBoxAppで直接購入して始めましょう"
    }
  },
  extendedPublicKey: "拡張公開鍵",
  label: "アカウント情報",
  scriptType: "スクリプトタイプ",
  title: "アカウント情報",
  verify: "デバイスで確認",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH拡張公開鍵を表示",
    p2tr: "Taprootを表示",
    p2wpkh: "ネイティブSegwitを表示",
    "p2wpkh-p2sh": "古いSegwit拡張公開鍵を表示"
  },
  xpubTypeInfo: "現在、{{scriptType}}拡張公開鍵（{{numberOfXPubs}}中の{{current}}）を表示しています"
}, accountSummary$d = {
  availableBalance: "利用可能な残高",
  balance: "残高",
  exportSummary: "ダウンロードフォルダにアカウント概要をCSV形式でエクスポートする",
  fiatBalance: "フィアット残高",
  name: "アカウント名",
  noAccount: "表示できるアカウントがありません。",
  subtotalWithCoinName: "合計（{{coinName}}）",
  title: "ポートフォリオ",
  total: "合計",
  transactionHistory: "取引履歴"
}, addAccount$e = {
  chooseName: {
    nextButton: "アカウントを追加",
    step: "アカウント名をつける",
    title: "あなたのアカウントに名前を付けてください"
  },
  selectCoin: {
    nextButton: "次",
    step: "コインを選択",
    title: "仮想通貨を選択"
  },
  success: {
    addAnotherAccount: "別のアカウントを追加",
    message: "<strong>{{accountName}}</strong>があなたのアカウントに追加されました",
    nextButton: "完了",
    step: "終了",
    title: "アカウント追加済み"
  },
  title: "アカウントを追加"
}, aopp$7 = {
  addressRequest: "{{host}}は受け取りアドレスを要求しています",
  addressRequestWithLogo: "受け取りアドレスを要求しています",
  banner: "アドレスのリクエストを処理中",
  errorTitle: "アドレスのリクエスト中にエラーが起きました",
  labelAddress: "アドレス",
  labelMessage: "メッセージ",
  reverifyInfoText: "アドレスの確認",
  signing: "進めるには、BitBox02でメッセージに署名してください",
  success: {
    message: "{{host}}で進めてください",
    title: "アドレスの送信に成功"
  },
  syncing: "アカウントを同期しています、お待ちください",
  title: "アドレスリクエスト"
}, app$d = {
  upgrade: "アプリの新しいバージョンが利用可能です！{{current}}から{{version}}にアップグレードしてください。"
}, auth$6 = {
  authButton: "認証",
  title: "続行するには認証してください"
}, backup$d = {
  check: {
    checking: "バックアップを確認中…",
    confirmTitle: "バックアップを確認",
    notOK: "このバックアップはウォレットと一致しません。",
    ok: "このバックアップはウォレットと一致します。",
    password: {
      label: "リカバリーパスワード",
      placeholder: "リカバリーパスワード",
      showLabel: "リカバリーパスワード"
    },
    success: "バックアップの検証に成功：",
    title: "バックアップを確認"
  },
  create: {
    alreadyExists: "既に有効なバックアップが存在します。再作成しますか？",
    fail: "バックアップの作成に失敗しました。",
    info: "認証のため、現在のウォレットのリカバリーパスワードを入力してください。",
    name: {
      label: "バックアップの名前",
      placeholder: "バックアップに名前をつけてください"
    },
    password: {
      label: "リカバリーパスワード",
      placeholder: "リカバリーパスワードを入力してください"
    },
    title: "バックアップの作成",
    verificationFailed: "リカバリーパスワードが現在のウォレットと一致しません。バックアップは作成されました。リカバリーパスワードを検証するには「バックアップの確認」をご利用ください。"
  },
  description: "<strong>ウォレットのバックアップファイル</strong>を選択してください",
  insert: "バックアップを管理するにはSDカードを挿入してください。",
  insertButton: "SDカードを挿入しました",
  list: "microSDカード上のバックアップ",
  noBackups: "このmicroSDカードにはバックアップが存在しません。",
  restore: {
    confirmTitle: "バックアップの復元",
    error: {
      e200: "microSDカードが見つかりません",
      general: "バックアップの復元中にエラーが発生しました。"
    },
    password: {
      label: "リカバリーパスワードもしくは秘密リカバリーパスワード",
      placeholder: "リカバリーパスワード",
      repeatPlaceholder: "リカバリーパスワードの確認",
      showLabel: "リカバリーパスワード"
    },
    restoring: "バックアップから復元中…",
    selectedBackup: "<strong>{{backupName}}</strong>は、{{createdDateTime}}に作成され、復元されます。",
    title: "復元",
    understand: "間違ったリカバリーパスワードは別のウォレットを作成することを理解しました"
  },
  showMnemonic: {
    description: `あなたのリカバリーワードが表示されます。これらはあなたのウォレットのバックアップを形成します。それらを紙に書き留めてください。

<strong>それらをデジタルに保存したり、写真を撮ったりしないでください。</strong>

<strong>単語を大声で言わないでください。</strong>

<strong>このバックアップはパスワードによって保護されていません。</strong>

その後、各単語を確認していただくことになります。`,
    title: "リカバリーワードを表示する",
    warning: "<strong>リカバリーワードは決して誰にも教えないでください。</strong>それによって、あなたのウォレットへ完全にアクセスできるようになります。もし誰かがあなたのリカバリーワードを尋ねてきたら、それは詐欺師です！"
  },
  title: "バックアップの管理"
}, bb02Bootloader$d = {
  abort: "アップグレードしない – 前の画面に戻る",
  abort_noUpgrade: "前の画面に戻る",
  advanced: {
    label: "詳細設定",
    toggleShowFirmwareHash: "起動時に毎回ファームウェアのハッシュを表示"
  },
  flipscreen: "画面を反転",
  orientation: "デバイスの向きは合っていますか？　",
  success: "アップグレードに成功しました！{{rebootSeconds}}秒後に次に進みます。",
  success_install: "インストールが成功しました！{{rebootSeconds}} 秒後に次に進みます"
}, bitbox$d = {
  error: {
    e10000: "現在のデバイスのパスワードが間違っています。",
    e10001: "デバイスのパスワードの変更に失敗しました。",
    e102: "パスワードは4文字以上（半角）必要です。",
    e112: "秘密デバイスのパスワードとメインデバイスのパスワードは同じではいけません。"
  }
}, bitbox02Interact$d = {
  confirmDate: "本日の日付をBitBox02で確認してください",
  confirmDateText: "この日付はバックアップ作成に使用されます。",
  confirmName: "名前をBitBox02で確認してください",
  confirmWords: "あなたのBitBox02に{{amount}}のリカバリーワードを記入してください",
  confirmWordsText: "その後、BitBox02は、バックアップが正しいかどうかを確認するために、各単語を確認するよう求めます。",
  followInstructions: "BitBox02の手順に従ってください。",
  followInstructionsMnemonic: "バックアップからリカバリーワードを入力し、ウォレットを復元するために、BitBox02の指示に従ってください。",
  followInstructionsMnemonicTitle: "リカバリーワードから復元する"
}, bitbox02Settings$d = {
  deviceName: {
    current: "現在のデバイス名",
    error: "デバイス名を設定できませんでした。",
    error_104: "デバイス上でデバイス名の確認が中止されました。",
    input: "BitBox02　名前",
    placeholder: "新しいデバイス名",
    title: "BitBox02の名前を設定"
  },
  gotoStartupSettings: {
    description: "これにより、BitBox02が再起動し、起動設定に入ります",
    title: "起動設定に移動"
  }
}, bitbox02Wizard$d = {
  advanced: {
    button: "詳細オプション",
    outOfDate: "この機能にはファームウェアが古すぎます。",
    seed12WordInfo: "ウォレットを作成した後で単語の数を変更することはできないことに注意してください。",
    seed12WordLabel: "24語のシードの代わりに12語のシードを作成します。",
    seed12WordText: "デフォルトでは、BitBox02は24語のシードを使用します。どちらのシード長も実際のところブルートフォース攻撃に対して安全です。一部のユーザーは12語のシードの便利さを好むかもしれません。",
    skipSDCardLabel: "マイクロSDカードのバックアップをスキップして、代わりにリカバリーワードを書き留めてください",
    skipSDCardText: "セットアップ後にmicroSDカードのバックアップを作成したり、リカバリーワードを書き込んだりするオプションは常に用意されています。これは、設定から行うことができます。",
    title: "高度なバックアップオプション"
  },
  attestationFailed: "正規性チェックに失敗しました。これは、デバイスがユーザー入力を待っている間にアプリを再起動したためである可能性があります。再接続して再試行してください。この問題が続く場合は、support@bitbox.swissにお問合せください。",
  backup: {
    point1: "microSDカードのバックアップを選択してください",
    point2: "デバイスのパスワードを設定",
    restoreText: "さあ、バックアップを復元しましょう！",
    text1: "これでBitBox02のパスワードは設定され、ウォレットも作成されました。次はバックアップを作成しましょう、microSDカードがデバイスに挿入されていることを確認してから次に進んでください。",
    text2: "デバイス上の画面の指示に従って、バックアップを作成してください。",
    text3: "バックアップ作成後にデバイスからmicroSDカードを取り外し、<strong>安全な場所</strong>に保管してください。microSDカードの内容はパスワード保護されていません。BitBox02以外のデバイスに挿入しないよう気をつけてください。",
    userConfirmation1: "バックアップは安全な場所に保管するべきです。",
    userConfirmation2: "バックアップはパスワードによって保護されていません。バックアップにアクセスできる人はあなたのウォレットにもアクセスできます。",
    userConfirmation3: "BitBox02が損傷または紛失した際には、バックアップからしか、資金を復元できません。",
    userConfirmation4: "バックアップとBitBox02の両方を紛失または損傷させた場合、資金は失われます。",
    userConfirmation5: "マイクロSDカードのバックアップをコンピューター、携帯電話、プリンター、またはBitBox02以外の任意のデバイスに挿入すべきではありません。",
    userConfirmation5mnemonic: "リカバリーワードをBitBox02以外のコンピュータ、電話、プリンタ、または他のデバイスに入れるべきではありません。"
  },
  create: {
    button: "デバイス名を設定して続行",
    info: "BitBoxの初期設定には下記のステップを行います：",
    inputTitle: "ウォレット名前",
    point1: "デバイス名の設定",
    point2: "デバイスのパスワードを設定",
    point3: "バックアップ作成",
    text: "さあ、新しいウォレットを作りましょう！"
  },
  createBackupAborted: "バックアップの作成が中断されました。",
  createBackupFailed: "バックアップの作成に失敗しました、再度試してください。",
  initialize: {
    passwordText: "次にデバイスのパスワードを設定しましょう。BitBoxを操作してパスワードの入力を行ってください。",
    passwordTitle: "BitBoxのパスワードを設定",
    text: "BitBox02のペアリングに成功しました！次にデバイスの初期化を行いましょう。まず最初に新しくウォレットを作成するか、既存のバックアップを復元するかを選んでください。<strong>次のステップに進む前に、デバイスにmicroSDカードが挿入されていることを確認してください。</strong>",
    tip: "安全な場所で進めることをお勧めします。",
    title: "BitBoxの初期化"
  },
  insertSDCard: "<strong>BitBox02にmicroSDカードが挿入されていることを確認してください。</strong?",
  noPasswordMatch: "パスワードが一致しませんでした、再度試してください。",
  pairing: {
    failed: "ペアリングが確認できません。BitBox02を挿し直してください。",
    paired: "あなたのデバイスで以下のコードを確認しました。続行してください。",
    title: "ペアリングコードを確認する",
    unpaired: "ペアリングされていないBitBox02が検出されました。ペアリングコードがBitBox02に表示されているものと一致することを確認してください。"
  },
  restoreFromMnemonic: {
    e104: "カバリーワードからの復元がキャンセルされました。",
    failed: "リカバリーワードからの復元に失敗しました、もう一度試してください。"
  },
  stepBackup: {
    beforeProceed: "次へ進む前に、重要なセキュリティ事項を読んでください。",
    createBackup: "これからmicroSDカード上にバックアップを作成します。",
    createBackupMnemonic: "あなたは今、リカバリーワードを書き留めることになります。"
  },
  stepBackupSuccess: {
    fundsSafe: "資金の安全を保つため、次のことを覚えていてください：",
    title: "バックアップを復元しました！"
  },
  stepConnected: {
    unlock: "BitBox02のパスワードを入力してロックを解除してください"
  },
  stepCreate: {
    description: "この名前はデバイス名とバックアップのために使用されます。",
    nameLabel: "BitBox02の名前",
    namePlaceholder: "私のBitBox02",
    title: "BitBox02の名前を決めてください",
    toastMicroSD: "ウォレットのバックアップを保存するために、BitBox02にmicroSDカードを挿入してください。"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02からmicroSDカードを抜いて安全な場所にしまってください。",
    storeMnemonic: "リカバリーワードを安全な場所に保管してください",
    success: "バックアップの作成に成功しました。"
  },
  stepInsertSD: {
    insertSDCard: "次へ進むにはBitBox02にmicroSDカードを挿入してください。",
    insertSDcardTitle: "microSDカードを挿入してください。"
  },
  stepPassword: {
    e104: "パスワードの設定がキャンセルされました。",
    title: "BitBox02のパスワードを設定する",
    useControls: "BitBox02を操作してパスワードを設定してください。"
  },
  stepUninitialized: {
    create: "新しいBitBox02をセットアップする。",
    restore: "バックアップからウォレットを復元する。",
    restoreMicroSD: "microSDカードから復元する",
    restoreMnemonic: "リカバリーワードから復元",
    title: "BitBox02をセットアップする"
  },
  success: {
    text: `おめでとうございます！BitBox02を使い始める準備が整いました。

BitBox Appの使用方法についての詳細は、画面右上のクエスチョンマークからアプリ内のガイドを参照してください。`,
    title: "準備が整いました"
  }
}, blink$d = {
  button: "点滅"
}, bootloader$d = {
  button: "ファームウェアをアップグレードする",
  button_install: "ファームウェアをインストールする",
  progress: "アップグレード中：{{progress}}\r%",
  progress_install: `インストール中：{{progress}}
%`,
  success: "アップグレートが完了しました。今回は、ボタンを触らずにデバイスを挿入し直してください。"
}, button$h = {
  abort: "中止",
  back: "戻る",
  buy: "購入",
  changepin: "デバイスのパスワード変更",
  check: "バックアップの確認",
  continue: "続行",
  copy: "コピー",
  create: "作成",
  dismiss: "閉じる",
  done: "完了",
  download: "ダウンロード",
  hiddenwallet: "隠しウォレットの作成",
  next: "次へ",
  ok: "OK",
  previous: "前へ",
  receive: "受信",
  restore: "復元",
  select: "選択",
  send: "送信",
  unlock: "アンロック",
  update: "アップデート",
  upgrade: "アップグレード"
}, buy$9 = {
  exchange: {
    bankTransfer: "銀行振込",
    bestDeal: "最高の取引",
    creditCard: "クレジットカード",
    fast: "高速",
    fee: "手数料",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "銀行振込: {{fee}}%",
          creditDebitCard: "クレジット/デビットカード: {{fee}}%",
          learnMore: "Moonpayについて詳しく知る",
          title: "手数料"
        },
        fullCurrenciesList: "ここで全ての通貨のリストを見る",
        payment: {
          asteriskText: "米国在住の方はご利用いただけません。",
          bankTransfer: "銀行振込",
          bankTransferDetails: {
            pix: "PIX（ブラジル内の取引のみ）",
            sepa: "SEPAおよびSEPAインスタント（SEPA加盟国内のユーロ取引のみ）",
            uk: "UKファスターペイメント（イギリス内のGBP取引のみ）"
          },
          creditDebitCard: "クレジット/デビットカード",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "お支払い方法について詳しく見る",
          title: "お支払い方法"
        },
        supportedCurrencies: "すべての主要なフィアット通貨をサポート：USD、EUR、CHFなど。"
      },
      pocket: {
        fees: {
          info: "銀行振込: {{fee}}%",
          title: "手数料"
        },
        learnMore: "Pocketについて詳しく知る",
        payment: {
          bankTransfer: "銀行振込",
          bankTransferDetails: {
            sepa: "「SEPAおよびSEPAインスタント（SEPA国のユーロ取引のみ）」",
            sic: "スイス・インターバンク・クリアリング（CH/LI内のCHF取引のみ）",
            uk: "UKファスターペイメント（イギリス内のGBP取引のみ）"
          },
          bankTransferReccuring: "スタンディングオーダーでの定期購入をどのように設定しますか？",
          title: "お支払い方法"
        },
        supportedCurrencies: "欧州通貨に対応：EUR, GBP, and CHF.",
        verification: {
          info: "日次と年次のしきい値を超える場合にのみ、身元確認が必要です。",
          link: "現在のしきい値はこちら",
          title: "本人確認"
        }
      },
      region: {
        title: "お客様の銀行口座が登録されている地域を選択すると、どのようなオプションが利用できるかを確認することができます。"
      }
    },
    noExchanges: "申し訳ございませんが、この地域では利用可能な取引所はございません。",
    region: "地域",
    selectRegion: "指定なし",
    title: "{{name}}購入"
  },
  info: {
    continue: "同意して続ける",
    crypto: "仮想通貨",
    disclaimer: {
      intro: [
        "私たちはMoonPayと提携し、BitBoxApp内で直接{{name}}を購入するためのシームレスな方法を提供しています。数回クリックするだけです。",
        "MoonPayは、160以上の国で{{name}}を簡単かつ迅速に購入することができるプラットフォームです。"
      ],
      payment: {
        details: "MoonPay経由で、以下の支払い方法で{{name}}を即座に購入することができます。クレジットカードまたはデビットカードの注文は即座にできて便利ですが、チャージバックのリスクが高まるため、割高になります。大量の購入には銀行振込のご利用をお勧めします。最低手数料は4 USD/EURまたはそれに相当する金額です。",
        footnote: "MoonPayの為替レートはBitBoxAppで使用されているものと異なる場合があり、その結果、金額が若干異なることをご了承ください。",
        table: {
          "1_description": "最安値の料金で、最大3営業日かかります。",
          "1_method": "銀行振込(SEPA)",
          "2_description": "手数料は高いが、迅速な対応で即座に",
          "2_method": "クレジットとデビットカード",
          description: "概要",
          fee: "手数料",
          method: "方法"
        },
        title: "支払い方法と手数料"
      },
      privacyPolicy: "MoonPayのプライバシーポリシー",
      protection: {
        description: "BitBoxAppは{{name}}を購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。MoonPayは運用のために一部の個人情報を収集する必要があります。そのプライバシーポリシーでは、そのデータがどのように取り扱われるかが詳細に説明されています。",
        descriptionGeneric: "BitBoxAppは{{name}}を購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。しかし、パートナーの取引所は運営のためにいくつかの情報を収集する必要があります。データがどのように取り扱われるのか、詳細は各々のプライバシーポリシーをご覧ください。",
        title: "データ保護"
      },
      security: {
        description: "MoonPay経由で{{name}}を購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。",
        descriptionGeneric: "パートナーの取引所経由で{{name}}を購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。",
        link: "キュリティ脅威モデル",
        title: "セキュリティモデル"
      },
      title: "ようこそ、{{name}}を買うためのワンストップショップへ。"
    },
    next: "次へ",
    selectLabel: "アカウントを選択する",
    selectPlaceholder: "コインを選択する",
    skip: "再表示しない",
    title: " {{name}}購入 "
  },
  pocket: {
    data: {
      link: "Pocket のプライバシーポリシー",
      p1: "BitBoxAppはビットコインを購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。Pocketは運用のために一部の個人情報を収集する必要があります。そのプライバシーポリシーでは、そのデータがどのように取り扱われるかが詳細に説明されています。",
      title: "データ保護"
    },
    kyc: {
      link: "Pocket よくあるご質問を読む",
      p1: "PocketはKYC（顧客の本人確認）を最小限に抑えるよう努力しています。1日に950ユーロ（1000スイスフラン）以下の購入には、追加の書類は必要ありません。この金額を超える購入には、必要なKYC/AML（アンチマネーロンダリング）プロセスを完了するために、Pocketとの電話予約をする必要があります。",
      title: "KYC/AML"
    },
    payment: {
      p1: "SEPA銀行振込を利用して、Pocketを通じてビットコインを即時に購入することができます。手数料は1.5%で、Pocketが銀行振込を受け取った後できるだけ早くビットコインがあなたのBitBoxに預けられます（通常は同日中）。",
      p2: "Pocketの為替レートはBitBoxAppで使用されるものと異なる場合があり、その結果、少し異なる金額になることに注意してください。",
      title: "支払い方法と手数料"
    },
    previousTransactions: "このアカウントの取引履歴は空ではありません。このアカウントを共有すると、過去及び未来の全ての取引がPocketに表示されます。それでも進みますか？",
    security: {
      link: "BitBox02のセキュリティ脅威のモデル",
      p1: "Pocket経由でビットコインを購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。しかし、あなたが受け取るアドレスを確認するために二要素認証メカニズムを使用して、我々は共同でセキュリティを向上させる努力をしています。",
      title: "セキュリティモデル"
    },
    usedAddress: "アドレス{{address}}はすでに使用されているため、新しいアドレスでやり直してください。",
    verifyBitBox02: "あなたがメールで受け取ったアドレスがBitboxに表示されているアドレスと一致することを確認してください。可能であれば、より高いセキュリティを確保するために、別のデバイスでメールを開くべきです。",
    welcome: {
      p1: "私たちはPocketと提携し、BitBoxApp内で直接ビットコインを購入するシームレスな方法を提供しています。数回クリックするだけです。",
      p2: "Pocketはスイスのプラットフォームで、ヨーロッパのほとんどの地域（SEPA銀行送金がサポートされている場所）でビットコインを迅速かつ簡単に購入することができます。",
      p3: "Pocketを利用すると、定期的な銀行注文を通じて定期的な購入も行うことができますので、簡単にDCA（ドルコスト平均法）を実践することができます。",
      title: "ビットコインを購入するためのワンストップショップへようこそ"
    }
  },
  title: "{{name}}を購入"
}, changePin$d = {
  newTitle: "新しいデバイスパスワード",
  oldLabel: "現在のデバイスパスワード"
}, chart$9 = {
  dataMissing: "過去のデータを収集中です...お待ちください",
  dataOldTimestamp: "過去の為替レートが更新されています。{{time}}以降のデータがチャートに表示されません。",
  dataUpdating: "データを更新中です...",
  filter: {
    all: "全て",
    month: "月",
    week: "週",
    year: "年"
  }
}, checkSDcard$d = "microSDカードを確認しています", clickHere$d = "こちらをクリック", confirm$f = {
  abortInfo: "タップしてください",
  abortInfoRedText: "中止する",
  approveInfo: "4秒以上長押ししてください",
  approveInfoGreenText: "確認",
  info: "BitBoxで続けてください",
  infoWhenPaired: "まずペアリングされたモバイルアプリで操作し、次にBitBox上で続けてください"
}, confirmOnDevice$d = "デバイス上で確認してください。", connectKeystore$6 = {
  promptNoName: "続行するには、BitBox02を接続してください",
  promptWithName: '"{{name}}" という名前のBitBox02を接続してください'
}, darkmode$7 = {
  toggle: "ダークモード"
}, device$d = {
  appUpradeRequired: "あなたのBitBoxはこのソフトウェアとの互換性がありません。最新のバージョンをダウンロードしてからインストールしてください。"
}, deviceLock$d = {
  button: "2段階認証(2FA)を有効にしてください",
  condition1: "バックアップはありますか？",
  condition2: "モバイルアプリでの検証はできていますか？",
  condition3: "2段階認証(2FA)はバックアップ及びモバイルアプリのペアリングを無効にします。2段階認証を終了するにはデバイスのリセットが必要です。",
  confirm: "2段階認証(2FA)を有効にする",
  title: "2段階認証(2FA)を有効にする"
}, deviceSettings$d = {
  backups: {
    manageBackups: {
      description: "マイクロSDカードのバックアップを作成するか確認してください。"
    },
    showRecoveryWords: {
      description: "リカバリーワードを表示し、確認する。"
    },
    title: "バックアップ"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxAppはあなたのデバイスが本物であるかどうかを確認します"
    },
    deviceName: {
      description: "あなたのデバイスの名前を変更してください。"
    },
    rootFingerprint: {
      description: "ルートフィンガープリントは、現在使用中のウォレットに対して固有の識別子です。パスフレーズを使用する場合、異なるウォレットを区別するのに役立ちます。"
    },
    securechip: {
      description: "セキュアチップのモデルです。"
    },
    title: "デバイス情報"
  },
  expert: {
    factoryReset: {
      description: "デバイスを工場出荷時の設定にリセットしてください。これにより、BitBox02からウォレットが削除されます！",
      title: "工場出荷時の設定にリセットします。"
    },
    goToStartupSettings: {
      description: "BitBox02のブートローダーに入ります。ここからファームウェアハッシュを有効にすることができます。"
    },
    passphrase: {
      description: "パスフレーズ機能を有効または無効にします。",
      title: "パスフレーズ"
    }
  },
  firmware: {
    firmwareVersion: "ファームウェアのバージョン",
    newVersion: {
      label: "使用可能なバージョン"
    },
    title: "ファームウェア",
    upToDate: "デバイスは最新の状態です",
    upgradeAvailable: "新しいアップグレードが可能です",
    version: {
      label: "バージョン"
    }
  },
  hardware: {
    attestation: {
      false: "認証チェックに失敗しました",
      label: "真贋チェック",
      true: "あなたのBitBox02は本物です"
    },
    sdcard: {
      false: "挿入されていません",
      label: "microSDカード",
      true: "挿入されています"
    },
    securechip: "セキュアチップ",
    title: "ハードウェア"
  },
  loading: "デバイス情報を読込中…",
  pairing: {
    lock: {
      false: "無効",
      label: "2段階認証(2FA)",
      true: "有効"
    },
    mobile: {
      false: "停止中",
      label: "モバイルアプリ",
      true: "起動中"
    },
    status: {
      false: "ペアされていません",
      label: "ステータス",
      true: "ペアされています"
    },
    title: "ペアリング"
  },
  secrets: {
    manageBackups: "バックアップを管理",
    title: "秘密"
  }
}, deviceTampered$d = "あたなのBitBoxにリカバリーパスワードが同梱されていた場合、直ちにセットアップをやめてサポートに連絡をしてください。Shiftは設定済みのウォレットの販売及びパスワードの推奨を行うことはありません。", dialog$e = {
  cancel: "キャンセル",
  confirm: "確認",
  confirmTitle: "確認"
}, error$9 = {
  accountAlreadyExists: "アカウントはすでに存在しています。",
  accountLimitReached: "アカウントを追加できません。このコインのアカウント最大数に達しました。",
  aoppCallback: "アドレスを{{host}}に配信する際にエラーが発生しました。",
  aoppInvalidRequest: "無効なリクエストです",
  aoppNoAccounts: "利用可能なアカウントはありません。",
  aoppSigningAborted: "アドレス所有権の要求がキャンセルされました。",
  aoppUnknown: "不明なエラーが発生しました",
  aoppUnsupportedAsset: "アセットがサポートされていません。",
  aoppUnsupportedFormat: "要求されたアドレス形式をサポートする利用可能なアカウントはありません。",
  aoppUnsupportedKeystore: "接続されたデバイスは、このアセットのメッセージに署名できません",
  aoppVersion: "不明なバージョンです。",
  wrongKeystore: "接続されたウォレットが間違っています。このアカウントに合致する正しいデバイスを挿入しているかを確認してください。",
  wrongKeystore2: "オプションのパスフレーズを使用している場合、アカウントの正しいパスフレーズを入力していることを確認してください。"
}, fiat$f = {
  default: "デフォルト",
  setDefault: "{{code}}をデフォルトに設定する",
  title: "通貨"
}, footer$f = {
  appVersion: "アプリのバージョン："
}, generic$9 = {
  enabled_false: "無効化",
  enabled_true: "有効化"
}, genericError$d = "エラーが発生しました。問題が起きた場合はソフトウェアを再起動してください。", goal$d = {
  buttons: {
    create: "新しいウォレットの作成",
    restore: "バックアップからウォレットを復元"
  },
  paragraph: "次の中から一つ選択してください",
  step: {
    1: {
      title: "セキュリティ情報"
    },
    2: {
      description: "デバイスパスワード",
      title: "デバイス"
    },
    "3-create": {
      description: "新しいウォレットの作成",
      title: "ウォレット"
    },
    "3-restore": {
      description: "バックアップから",
      title: "復元"
    },
    "4-create": {
      title: "概括"
    },
    "4-restore": {
      title: "概括"
    }
  }
}, guide$e = {
  accountDescription: {
    text: "あなたのアカウント概要は、利用可能な残高と受け取りおよび送り出しのトランザクションを表示します。「設定」のガイドには、各アカウントタイプに関する詳しい情報があります。",
    title: "ここには何を示していますか？"
  },
  accountFiat: {
    text: "はい。どのティッカーでもクリックするとフィアット通貨が順に切り替わります。設定で通貨のリストを変更することができます。",
    title: "他の換算レートも表示できますか？"
  },
  accountIncomingBalance: {
    text: "受信中は、あなたに送金されたがまだネットワークによって確認されていない金額を合計します。",
    title: "受信中とはどういう意味ですか？"
  },
  accountInfo: {
    multipleXPubs: {
      text: `それぞれのxpubは、表示された"Type"（タイプ）に結びついています："Native Segwit (bech32)"、"Wrapped Segwit"または“Taproot”（ビットコインのみ）。これらは{{coinName}}で使用されるスクリプトタイプです。BitBoxAppはこれらを組み合わせ、同じアカウントで複数のスクリプトタイプをサポートします。各スクリプトタイプは異なるxpubを提供するため、アカウントごとに複数のxpubが存在します。

デフォルトのアドレス（Native Segwit）に一貫して受け取る場合、"bech32" xpubだけが必要です。しかし、"Wrapped Segwit"または“Taproot”にも資金を受け取る場合は、それぞれ"Wrapped Segwit"と“Taproot”の拡張公開鍵も使用する必要があります。`,
      title: "なぜ複数のxpubが存在するのですか？"
    },
    privacy: {
      text: `この特定のアカウントでは、拡張公開キー（xpub）が全ての金融履歴、アカウントの残高、そして全ての将来の取引を明らかにします。しかし、xpubでは誰もあなたのコインを使うことはできません。

もしxpubを誰かに渡す場合、その人や会社が同一のアカウントの他の全ての取引を見ることができることを理解しておくべきです。それゆえ、その目的のためだけにそのアカウントを使用し、他の資金は別のアカウントに保管するのが良い考えです。`,
      title: "私のxpub（拡張公開キー）を秘密に保つ必要がありますか？"
    },
    verify: {
      text: "はい、xpubを再確認することは常に良い考えです。もし他の人があなたにお金を送るためにこのxpubから受け取りアドレスを生成する場合、これは特に重要です。このxpubがあなたのものであることを確認するために、デバイス上で確認する必要があります。そうしないと、全ての資金が誤ったアドレスに送られる可能性があります。",
      title: "デバイス上でxpub（拡張公開キー）を確認する必要がありますか？"
    },
    xpub: {
      text: `拡張公開キー（xpub）は、アカウントの全ての受け取りアドレスが派生するルートキーです。

これは、ElectrumやSentinelなどのウォッチオンリー（閲覧専用）ウォレットとの高度な使用と相互運用性のために提供されています。異なるアドレスタイプに対して資金を受け取った場合は、全てのコインを確認するために、異なるxpubフォーマット全てをウォッチオンリーウォレットにインポートしてください。

ただし、第三者のウォレットはまだTaproot xpubをサポートしていないかもしれませんので、ご注意ください。`,
      title: "拡張公開鍵とはなんですか？"
    }
  },
  accountRates: {
    text: "換算レートは毎分CoinGeckoの情報を取得して更新されます。",
    title: "どの為替レートが適用されますか？"
  },
  accountReload: {
    text: "それは必要ありません。あなたの取引情報は自動的に更新されます。",
    title: "取引履歴を再読み込みすることは可能ですか？"
  },
  accountSendDisabled: {
    text: "「送信」ボタンは残高が0以上の時に有効になります。",
    title: "{{unit}}を送ることが出来ないのですが？"
  },
  accountSummaryAmount: {
    text: `合計金額は、すべての仮想通貨アカウントの合計です。為替レートはcoingecko.comから取得されます。

注意: BitBoxAppでサポートされていないトークンをMyEtherWalletで使用している場合、表示される金額には含まれません。



`,
    title: "総額はどのように算出されるのですか？"
  },
  accountSummaryDescription: {
    text: "ここでは、ポートフォリオの時間経過に伴うパフォーマンスを確認できます。チャートの下には、個々の仮想通貨アカウントのサマリーが表示されます。",
    title: "このページは何を示しているのでしょうか？"
  },
  accountTransactionAttributesBTC: {
    text: `バーチャルサイズ（Virtual size）：ネットワーク手数料を決定する要素です。もしトランザクションサイズよりも小さい場合、手数料を節約できています。
サイズ（Size）：ブロックチェーンに基づいてシリアライズされた場合の実際のトランザクションサイズ（バイト単位）です。
ウェイト（Weight）：Segwitで導入された新しい指標で、トランザクションやブロックのサイズを評価するために使用されます。Segregated Witnessのバイトは1として数えられ、それ以外は4のウェイト単位として数えられます。従来の1メガバイトのサイズではなく、ブロックサイズの制限は現在400万のウェイト単位となります。`,
    title: "ビットコイン特有の取引内容についてはどうでしょうか。　"
  },
  accountTransactionAttributesGeneric: {
    text: `
承認数：最初のトランザクションのブロードキャストは、マイナーがそれをブロックに含めるまで承認されていません。ブロードキャストされた各ブロックは、取引に別の承認を追加します。一般的に、商人や他のネットワーク参加者は、取引が3〜6回の承認を受けた後にのみ決済を行います。
トランザクションID：block explorerでトランザクションを検索するための一意の識別番号です。
手数料：マイナーはトランザクションをブロックに含めるためのインセンティブとして手数料を受け取ります。詳細については、送信ボタンをクリックしてください。`,
    title: "取引明細に記載されている情報は何ですか？"
  },
  accountTransactionConfirmation: {
    text: "ネットワークにブロードキャストされたが、まだ承認されていないトランザクションです。",
    title: "ペンディングトランザクションとは何ですか？"
  },
  accountTransactionLabel: {
    text: `それは、コインを受け取ったアドレスまたはコインを送ったアドレスです。
`,
    title: "各トランザクションには、どのアドレスが表示されますか？"
  },
  accountTransactionTime: {
    text: `ブロックチェーントランザクションの確認時間です。
`,
    title: "表示される時間は何時ですか？"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoinと Litecoinは任意の数のアカウントを持つことができます。5つのアカウントがある場合、前のアカウントが使用された場合のみ別のアカウントを追加できます。
他のコインは最大で5つのアカウントを持つことができます。`,
      title: "何個のアカウントを作成することができますか？"
    },
    howtoAddTokens: {
      text: "ERC20標準を使用するトークンは特定のイーサリアムアカウントに関連付けられています。特定のトークンを有効にしたり無効にしたりするには、「アカウントの管理」画面を開き、あなたのイーサリアムアカウントを展開し、目的のトークンをオンまたはオフに切り替えます。",
      title: "トークンを追加したいのですが、どうすればよいですか？"
    },
    moveFunds: {
      text: "はい。しかし、アカウントが独立しているため、通常の取引を使用して資金を送金する必要があります。",
      title: "アカウント間で資金を移動することは可能ですか？"
    },
    recoverAccounts: {
      text: "はい。BitBoxAppは、他のほとんどの暗号ウォレットと互換性のある、確立された標準を使用してアカウントを作成します。",
      title: "他のウォレットのアカウントを復元することはできますか？"
    },
    whatAreAccounts: {
      text: "ウォレットは、同じコインの複数のアカウントを管理することができます。資金を別々に管理したいときに便利です。",
      title: "アカウントとは何ですか？"
    },
    whyIsThisUseful: {
      text: "アカウントは分離されているため、異なる人や目的のための資金を管理するのに適しています。また、アカウントの「拡張公開鍵」を共有することで、他のアカウントについて何も明かすことなく利用することができます。これにより、給料の受け取りや暗号の定期購入など、アドレスを再利用することなく繰り返し資金を受け取ることができます。",
      title: "なぜこれが便利なのでしょうか？"
    }
  },
  appendix: {
    link: "ご連絡ください！",
    text: "他にも質問がありますか？"
  },
  backups: {
    check: {
      text: "「バックアップのチェック」機能により、現在のウォレットに対応する動作するバックアップを確認することができます。また、正しいリカバリーパスワードを持っているかどうかを確認するためにも使用することができます。メインのリカバリーパスワードまたは隠しリカバリーパスワードのどちらかをチェックすることができます。",
      title: "「バックアップのチェック」とは何ですか？"
    },
    encrypt: {
      text: "できませんが、保管されたシードから正しいウォレットを復元するには関連付けたリカバリーパスワードが必要です。",
      title: "バックアップを暗号化することはできますか？"
    },
    howOften: {
      text: `新しいウォレットが作成されると、バックアップは自動的に生成されます。microSDカードが紛失または破損した場合、または複数のmicroSDカードをバックアップとして使用したい場合を除き、新しいバックアップを作成する必要はありません。
取引後に新しいバックアップを作成する必要はありません。すべての取引データは、自動的に生成された単一のバックアップによって再作成できます。`,
      title: "どれだけ頻繁にバックアップを作成するべきですか？"
    },
    whatIsABackup: {
      text: "microSDカードにシードをコピーしたものです。シードとリカバリーパスワードを合わせてウォレットを生成します。",
      title: "バックアップとは？"
    }
  },
  backupsBB02: {
    check: {
      text: "「バックアップの確認」では現在のウォレットに対応するバックアップが動作しているかどうかを確認することができます。",
      title: "「バックアップの確認」とは？"
    },
    encrypt: {
      text: "いいえ。microSDカードにはウォレット復元のために必要な暗号化されていないシード情報を含んでいるため、安全な場所に保管してください。シードをパスワードで保護したい場合は、エキスパート設定の「デバイスの管理」でオプションのパスフレーズを有効にすることができます。",
      title: "バックアップを暗号化することはできますか？"
    },
    whatIsABackup: {
      text: "microSDカードにシードをコピーしたものです。",
      title: "バックアップとは？"
    }
  },
  bitbox: {
    "2FA": {
      text: `2段階認証(2FA)が有効な場合、コインを消費するには全ての取引をペアされた携帯電話で承認する必要があります。裏側では暗号化された一回限り使用可能な番号をモバイルアプリに送信し、承認ボタンが押されたタイミングで解読された番号をBitBoxに送り返します。この送受信は、最初にモバイルアプリとのペアリングを行った際に開設されたチャンネルを使用します。
2段階認証(2FA)を有効にする前に、必ずウォレットのバックアップを作成し、モバイルアプリとのペアリングを行ってください。2段階認証(2FA)が有効になると、バックアップ時に使用されるmicroSDカードスロットとモバイルアプリのペアリングは無効となります。これらを再度使用したい場合は再設定、つまりはBitBoxをリセットしなければなりません。`,
      title: "2段階認証(2FA)はどのように機能するのですか？"
    },
    disable2FA: {
      text: "2段階認証(2FA)を無効にするためには、BitBoxをリセットし、バックアップからウォレットを復元する必要があります。バックアップが記録されているmicroSDカードをまだ持っていること、そしてリカバリーパスワードをまだ覚えていることを確認してください。それから、「デバイスをリセット」を押します。新しいデバイスパスワードを設定し、「バックアップを復元する」を選択します。ウォレットから作成したバックアップを選択し、「復元」をクリックし、ウォレットを作成する際に使用したリカバリーパスワードを入力します。",
      title: "どのように2段階認証(2FA)を無効にするにはどうしたらいいですか？"
    },
    ejectBitbox: {
      text: "BitBoxはいつでも取り外すことができます。",
      title: "どのようにBitBoxを取り出すのですか？"
    },
    ejectSD: {
      text: "バックアップの作成・復元作業中でなければ、いつでもmicroSDカードをBitBoxから取り外すことができます。",
      title: "microSDカードを取り出すにはどうしたらよいですか？"
    },
    hiddenWallet: {
      text: "隠しウォレットとは同じデバイス上にあり、別のパスワード・リカバリーパスワードで守られた２つ目のウォレットであり、妥当な否認権(plausible deniability)として使用できます。普通のウォレットと隠しウォレット両方で一つのバックアップを使用するので、新しくバックアップを作成する必要はありません。",
      title: "隠しウォレットとは何ですか？"
    },
    legacyHiddenWallet: {
      text: "最初に下のボタンをクリックし（BitBoxがメインデバイスパスワードによりアンロックされていて、2段階認証が無効な場合押すことができます）、BitBoxを挿し直してから秘密デバイスパスワードでアンロックしてください。",
      title: "どのように legacyの秘密ウォレットにアクセスできますか？"
    },
    pairing: {
      text: "iOSもしくはAndroid用のモバイルアプリのダウンロード後、表示されているQRコードをスキャンすることでこのソフトウェアとモバイルアプリの間に安全なチャンネルが開設されます。スキャン後はモバイルアプリに表示される手順に従ってペアリングを行なってください。",
      title: "安全に携帯電話とペアリングを行うには"
    }
  },
  cointracking: {
    text: '"エクスポート"ボタンをクリックし、CSVエクスポートが見つかるダウンロードフォルダを開きます。その後、以下のリンクをクリックし、BitBoxのCSVファイルをアップロードしてデータをインポートします。これにより、CoinTrackingのポートフォリオマネージャーで使用したり、税金報告書を作成したりすることができます。',
    title: "CoinTrackingに自分の取引をどのようにインポートするか？"
  },
  device: {
    attestation: {
      link: {
        text: "真贋チェックの詳細はこちら"
      },
      text: "BitBoxAppは、デバイスが本物であることを確認するために、BitBox02に対して認証チェックを実行します。このチェックはローカルで行われ、サーバーには接続しません。",
      title: "真贋チェックはどのように行われるのですか？"
    },
    name: {
      text: "これはあなたのウォレットとバックアップの名前です。この名前は将来のバックアップに使われ、異なるウォレットを区別するのに役立つことがあります。いつでも変更することができますが、変更前に作成したバックアップは以前の名前を使用し続けることに注意してください。",
      title: "BitBox02の名前は何に使われているのですか？"
    },
    "secure-chip": {
      link: {
        text: "セキュアチップについて詳しく見る"
      },
      text: "この情報はセキュアチップのモデル番号を表示しています。最新のチップはATECC608Bで、旧モデルに比べてセキュリティ機能が向上しています。",
      title: "セキュアチップモデルを見せる理由は？"
    }
  },
  receive: {
    address: {
      text: "あなたは他の人にこのアドレスを教えて、コインを送ってもらうことができます。ただし、正しいアドレスに送金していることを確認してください。",
      title: "アドレスは何に使用することができますか？"
    },
    addressChange: {
      text: "取引を行うとすぐに、新しいアドレスが自動的にリストに追加され、常に受け取り履歴のないアドレスが20個利用可能となります。",
      title: "アドレスが変わるのはいつですか？"
    },
    addressFormats: {
      text: "デフォルトでは、アドレスタイプはNative Segwitです。このアドレスタイプは他のウォレット/取引所に広く採用されており、日常のトランザクションに最適な手数料率を提供します。しかし、Taproot（ビットコインのみ）に送ることも選択できます。これは最新のアドレスタイプですが、まだ広くサポートされていないかもしれません。また、Native Segwit（デフォルトタイプ）への送金に問題がある場合は、より多くのウォレット/取引所と互換性がある可能性のある古いWrapped Segwitアドレスタイプに切り替えることを試みることができます。",
      title: '"アドレスタイプを変更"はいつ使用しますか？」という質問に対する回答は次のとおりです：'
    },
    howVerify: {
      text: `BitBox01については、左側のサイドバーにあるBitBoxアイコンをクリックし、「ペアリング」セクションを参照してください。ガイドが更新され、そこから指示に従って続行することができます。
BitBox02では、送受信プロセス中にデバイス上で直接アドレスを確認することができます。`,
      title: "安全にアドレスを検証するにはどうすればいいですか？"
    },
    plugout: {
      text: "BitBoxのアドレスにコインを送った後は、BitBoxを接続したままにしておく必要はありません。BitBoxの接続を解除することは自由です。",
      title: "受信中、BitBoxを接続したままにしておく必要はありますか？"
    },
    why20: {
      text: "スタートアップ時に、アプリはあなたのシードから派生したアドレスを生成し、彼らが資金を受け取ったかどうかを確認します。アプリはほぼ無限にアドレスを生成できるため、残高の確認に何年も費やす可能性があります。この検索を制限するために、資金を受け取ったことがないアドレスを20個見つけたら停止するようにしています。これが「ギャップリミット」で、20個がデファクトスタンダードになっていますが、その数は任意です。これが、あなたが選ぶことのできる20のアドレスです。",
      title: "なぜ20個のアドレスだけなのですか？"
    },
    whyMany: {
      text: "プライバシーとセキュリティを保つため、同じアドレスを2度渡さないようにしてください。アドレスを使用してしまった場合は、右矢印をクリックして新しいアドレスを作成してください。一度に最大20個のアドレスを生成することができます。住所は、請求書番号のようなものだと考えてください。すべてのアドレスは、あなたの1つのバックアップシードから派生します。",
      title: "なぜこんなにたくさんのアドレスが存在するのですか？"
    },
    whyVerify: {
      text: "コンピュータが本物のアドレスを生成して表示することを信用してはいけません。攻撃対象が大きいので、ハードウェアウォレットよりもかなり脆弱です。BitBox01の場合、アドレスを確認するボタンは、ペアリングされた携帯電話にアドレスを安全に送信し、そこからQRコードをスキャンして確認することもできます。BitBox02の場合は、BitBox02のディスプレイ上で直接アドレスを確認することができます。",
      title: "なぜ安全にアドレスを検証したほうがいいのですか？"
    }
  },
  send: {
    change: {
      text: "Taproot UTXOが1つ以上あれば、お釣りはTaprootアドレスに返却されます。コインコントロールを使用する場合、選択したUTXOの中に少なくとも1つのTaproot UTXOがある場合、釣りはTaprootアドレスに返されます。それ以外の場合は、Native Segwitアドレスにお釣りが返されます。",
      title: "変化出力はどのように決定されるのですか？"
    },
    fee: {
      text: `手数料は取引の総額ではなくデータサイズによって決まります。手数料は選択したネットワーク優先度毎にBitcoin Coreの手数料見積もりアルゴリズムを使用して算出されます。結果が下記情報と違った場合に表示されます。
エコノミー：24ブロック(Bitcoinで約4時間、Litecoinで約1時間)
低：12ブロック(Bitcoinで約2時間、Litecoinで約30分)
普通：6ブロック(Bitcoinで約1時間、Litecoinで約15分)
高：2ブロック(Bitcoinで約20分、Litecoinで約5分)
(1つのブロックを採掘するのにBitcoinで約10分、Litecoinで約2.5分かかり、上記時間内にネットーワーク負荷が変化する可能性もあります。)`,
      title: "手数料はどのように計算されているのですか？"
    },
    plugout: {
      text: "いいえ、一度取引した後は、BitBoxを接続したままにしておく必要はありません。BitBoxの接続を解除することは自由です。",
      title: "送信中にBitBoxを接続したままにしておく必要はありますか？"
    },
    priority: {
      text: "高い手数料を払うほど、より早くあなたの取引がネットワークに認証されます。",
      title: "ネットワーク優先度とは何ですか？"
    },
    revert: {
      text: `一度署名し、送信された(ネットワークに向けて発信された)取引は取り消すことができません。署名を行う前に取引内容の確認(手数料を含む)を行なってください！
送信先の人を知っていて、その人が同額(手数料含まず)を送り返してくれるのであれは、新しい受信用アドレスをその人に教えてください。`,
      title: "取引を取り消すことは可能ですか？"
    },
    whyFee: {
      text: "取引は採掘者によって承認されるよう競争しています。採掘者はブロックに含む取引を手数料によって決めています。採掘者は取引履歴を元に投票しており、1人につき1票を取り締まる第三者がいないため(そもそもブロックチェーンが存在する理由)、高価なパソコン演算力などのリソースを犠牲に投票しています。これに対する報酬として、新しく作られたコインとブロックに含めた取引の手数料を獲得できます。",
      title: "なぜネットワーク手数料は存在するのですか？"
    }
  },
  "settings-electrum": {
    connection: {
      text: `同じネットワーク（例：自宅のwifi）にいるときだけノードに接続するつもりであれば、通常のネットワーク通信を使用すれば十分です。
この場合、Electrumサーバーは、通信を暗号化するためにTLS証明書を提供することをお勧めします。
もし、どこからでもノードに接続するつもりであれば、Torを使うのがよいでしょう。この場合、TLS証明書は必要ありません。`,
      title: "clearnet TCP、TLS、Torのどれを使うべきですか？"
    },
    instructions: {
      link: {
        text: "ノード接続の手引き"
      },
      text: "詳しいチュートリアルは、こちらのガイドをご覧ください：",
      title: "BitBoxAppを自分のフルノードに接続するにはどうすればよいですか？"
    },
    options: {
      text: `自分のノードを動かすには、完成品を買う、自作する、Bitcoin Coreを動かすなど、複数の選択肢があります。
BitBoxAppをノードに接続したい場合は、Electrumサーバーが動作していることを確認します。これは、ウォレットアプリがあなたのフルノードと通信するための専用プログラムです。
サポートされているオプションには、Electrs、Electrum Personal Server (EPS)、Bitcoin Wallet Tracker (BTW)があります。`,
      title: "ノードを動かすには、どのようなオプションがあるのでしょうか？"
    },
    tor: {
      text: `Torは「The Onion Router」の略で、フリーでオープンソースのソフトウェアで、多くのプライバシー上の利点を提供し、特にビットコインを使用する際に便利です。
Tor経由でノードに接続する場合は、Torがコンピュータにインストールされていることを確認し、BitBoxAppの設定でTor Proxyを有効にします。
ほとんどのOSで、Torを実行する方法は2つあります：
1. Tor Browser: Tor Browser をダウンロードし、開いてください。これにより、Torプロキシ設定でポート9150を設定することで、BitBoxAppがTorネットワークに接続することができます。
2. Tor background service：Torデーモンをインストールし、常にバックグラウンドで実行します。これにより、BitBoxAppはTorプロキシ設定にポート9050を設定することで接続できるようになります。`,
      title: `Tor、Torプロキシとはどのようなもので、どのポートを使用すればいいのでしょうか？
`
    },
    what: {
      text: "Shiftのサーバーを使う代わりに、自分のノードを使用してウォレットを運用することができます。",
      title: "ここで何ができますか？"
    },
    why: {
      text: `自分のノードを実行することは必須ではありませんが、プライバシーを向上させ、他人を信頼する必要性を減らすことができます。
まず、BitBoxAppが私たちのサーバーに接続して取引履歴を取得するのではなく、自分のノードから情報を取得するため、より個人的にビットコインを使用することを意味します。
第二に、自分のノードを動かすということは、自分のノードがすべてのトランザクションを自分で検証し、コンセンサスルールが実施されていることを確認することを意味します。`,
      title: "なぜ自分でノードを動かす必要があるのか？"
    }
  },
  settings: {
    sats: {
      text: "Satoshi（略して「sat」）とは、ビットコインの最小単位である。1 Satoshiはbitcoinの1億分の1（0.00000001BTC）です。bitcoinの生みの親であるサトシ・ナカモトにちなんで名づけられました。",
      title: "Satoshiとはなんですか？"
    },
    servers: {
      text: "このアプリは情報更新、取引履歴の読み込み、ペアされたモバイルアプリへの情報送信のためShift Cryptoのサーバーと繋がっています。また、CoinGeckoより最新の換算レートを取得しています(換算はローカル環境で行われます、あなたの金額等の情報は一切発信されません)。",
      title: "このアプリはどのサーバーと接続していますか？"
    }
  },
  title: "ガイド",
  toggle: {
    close: "ガイドを終了します",
    open: "ガイド"
  },
  trackingModePortfolioChart: {
    text: "デスクトップでは、カーソルをチャート上に重ねてください。モバイルでは、指をチャート上に長押しし、横方向にドラッグしてください。",
    title: "チャートで過去の値を見るには？"
  },
  unlock: {
    forgotDevicePassword: {
      text: "デバイスのリセットを行い、リカバリーパスワードを使用してバックアップからウォレットを復元する必要があります。",
      title: "デバイスパスワードを忘れてしまった場合どうすればいいですか？"
    },
    reset: {
      text: "15回続けて間違ったパスワードを入力してください。最後の何度かはデバイスを長押しするよう求められます。",
      title: "どのようにデバイスをリセットできますか？"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `デバイスは挿入時に一度点滅するはずです。正しい向きで挿入されていることを確認してください。問題がある場合は、以下のリンクからお問い合わせください。

BitBox01はモバイルではサポートされていません。BitBox01を接続するには、デスクトップのBitBoxAppを使用してください`,
      title: "私のBitBox01は認識されません"
    },
    getDevice: {
      link: {
        text: "BitBoxを注文"
      },
      text: "BitBoxは弊社オンラインショップよりご購入いただけます：",
      title: "どのようにデバイスを入手できますか？"
    },
    internet: {
      text: "はい、ウォレットの同期、取引の送信、最新の換算レートの取得等を行うためにインターネット接続が必要になります。",
      title: "アプリを使用するのにインターネット接続は必要ですか？"
    },
    lostDevice: {
      link: {
        text: "バックアップセンター"
      },
      text: "バックアップセンターを使用することで、新しいBitBoxにあなたのアカウントを復元することができます。",
      title: "デバイスを紛失してしまったのですが？"
    },
    useWithoutDevice: {
      text: "残念ながら現段階では使用できません。",
      title: "アプリをデバイスなしでも使用することができますか？"
    },
    welcome: {
      text: "スイスのShift Cryptoにより開発されたこのアプリをご使用いただきありがとうございます。現在はまだベータ版となっているため、使い勝手においての不明点・お気付きの点などのご連絡をいただけると幸いです。",
      title: "BitBoxAppにようこそ！"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "新しい携帯やコンピューターでBitBoxAppを使用している場合、dappsに再度接続する必要があります。そうすると、通常通りdapp上で再びあなたのコインを確認することができます。",
      title: "以前の接続が見えません。"
    },
    supportedNetworks: {
      text: "現在、BitBoxAppでWalletConnectを使用してサポートされているのはEthereumメインネットのみです。他のEVM互換チェーンを使用するには、Rabbyブラウザ拡張ウォレットをご利用ください。",
      title: "どのネットワークがサポートされていますか？"
    },
    whatIsWalletConnect: {
      text: "WalletConnectは、web3アプリケーションのための通信プロトコルです。これにより、第三者のアプリを使用せずに、EthereumベースのDAppsやウェブウォレットに便利に接続することができます。これは、BitBoxAppのAndroidユーザーに特に便利です。",
      title: "WalletConnectとは何ですか？"
    }
  }
}, headerssync$d = {
  blocksSynced: "{{blocks}}のブロックを同期済み"
}, hiddenWallet$d = {
  info1HTML: "妥当性のある否認権(plausible deniability)目的のため、普段お使いのウォレットとは<strong>違った</strong>デバイスパスワード・リカバリーパスワードで隠しウォレットを作ることができます。",
  info2HTML: "隠しウォレットに紐づけるデバイスパスワードとリカバリーパスワードを決めてください。これら2つのパスワードは、通常のウォレットとは<strong>違う</strong>パスワードでなければいけません。",
  passwordLabel: "隠しリカバリーパスワード",
  passwordPlaceholder: "隠しリカバリーパスワードの確認",
  pinLabel: "隠しデバイスパスワード",
  pinRepeatLabel: "隠しデバイスパスワードの確認",
  pinRepeatPlaceholder: "隠しデバイスパスワードの確認",
  success: "隠しウォレットの作成に成功しました。アンロックするにはデバイスを一度抜いて、再度挿入してください。"
}, initialize$d = {
  create: "デバイスパスワードを設定",
  creating: "デバイスパスワードを設定中…",
  error: {
    e102: "デバイスパスワードは4文字以上(半角)でなければいけません。"
  },
  info: {
    description1: "デバイスパスワードを決めてください。これはあなたのBitBoxのアンロックに使用されます。",
    description2: "半角の数字、文字、及び記号を使用できます。",
    description3: "デバイスパスワードを紛失した場合は、デバイスをリセットしてからウォレットをバックアップから復元する必要があります。",
    subtitle: "これからあなたのデバイスパスワードを設定します",
    title: "デバイスの初期化"
  },
  input: {
    label: "デバイスパスワード",
    labelRepeat: "デバイスパスワードの確認",
    placeholderRepeat: "デバイスパスワードの確認"
  }
}, invalidFormat$d = "無効な形式です", language$e = {
  title: "言語を選択してください"
}, legacyhiddenwallet$d = {
  disable: " legacy秘密ウォレットの無効化",
  enable: " legacy秘密ウォレットの有効化",
  successDisable: " legacy秘密ウォレットの無効化に成功しました。",
  successEnable: " legacy秘密ウォレットの有効化に成功しました。BitBoxを挿し直し、秘密デバイスパスワードを入力してレガシー秘密ウォレットにアクセスしてください。"
}, loading$d = "ロード中…", manageAccounts$7 = {
  accountHidden: "このアカウントは、閲覧専用アカウントから非表示にされています。再度表示するには、BitBox02を接続してください。",
  editAccount: "編集",
  editAccountNameTitle: "アカウント名を編集する",
  noAccounts: "アカウントが見つかりません",
  settings: {
    hideTokens: "トークンを隠す",
    showTokens: "トークンを表示する ({{activeTokenCount}})"
  },
  settingsButtonDescription: "アカウントの追加と表示/非表示",
  title: "アカウント管理",
  watchAccount: "閲覧アカウント",
  watchAccountDescription: "このアカウントは閲覧専用アカウントの一部です。トグルを使用して、閲覧専用から非表示にすることができます。"
}, mobile$8 = {
  usingMobileDataWarning: "モバイルデータ使用：このアプリは、アカウントロック解除後に最大数百メガバイトのブロックチェーンヘッダーデータをダウンロードする場合があります。モバイルデータの使用を避けるため、Wi-Fiに接続してください。このメッセージは、一度閉じると再び表示されません。"
}, newSettings$6 = {
  about: {
    appVersion: {
      title: "アプリバージョン"
    }
  },
  advancedSettings: {
    authentication: {
      description: "アプリへのアクセスを画面ロックや指紋認証でロックします。",
      title: "スクリーンロック"
    },
    coinControl: {
      description: "プライバシーを向上させるために、トランザクションに含まれるUTXO（未使用取引出力）を選択してください。"
    },
    customFees: {
      description: "送信時に独自の手数料を入力することができます。"
    },
    torProxy: {
      description: "プライバシーを向上させるために、Tor経由で接続してください。"
    }
  },
  appearance: {
    activeCurrencies: {
      description: "これらの追加通貨は、アカウントページで切り替えることができます。",
      title: "活発な通貨"
    },
    darkmode: {
      description: "ダークモードでのBitBoxAppをご覧ください。"
    },
    defaultCurrency: {
      description: "デフォルトの通貨を選択してください。",
      title: "デフォルトの通貨"
    },
    hideAmounts: {
      description: "公共の場でアプリを使用する際にプライバシーを向上させるために、残高や金額を非表示にするトグルを表示します。",
      hideAmounts: "金額を隠す",
      showAmounts: "金額を表示する",
      title: "金額の非表示を許可する"
    },
    language: {
      description: "BitBoxAppで使用する言語を選択してください。",
      title: "言語"
    },
    toggleSats: {
      description: " Satoshi単位を有効または無効にします。"
    }
  }
}, note$9 = {
  input: {
    description: "(任意)",
    placeholder: "メモを追加する..."
  },
  title: "メモ"
}, notification$d = {
  newTxs_one: "{{accountName}}にて{{count}}個の新しいトランザクション",
  newTxs_other: "{{accountName}}に{{count}}件の新しい取引があります"
}, pairing$d = {
  aborted: {
    text: "ペアリングはモバイルアプリから取り消されました。",
    title: "中止しました"
  },
  button: "モバイルアプリをペアリングする",
  confirm: "本当にBitBoxのペアリングを行いますか？この場合、トランザクションを行うには携帯電話が必要になります。",
  connectOnly: {
    button: "モバイルアプリに接続する",
    title: "モバイルアプリから「Connect to new desktop app」を選択してスキャンを行なってください。"
  },
  error: {
    text: "問題が起きました。もう一度やり直してください。",
    title: "エラー"
  },
  pullFailed: {
    text: "リレーサーバーを介してモバイルからメッセージを取得できませんでした。リレーサーバーがオフラインの可能性がありますので、サポートにお問い合わせください。",
    title: "取得に失敗しました"
  },
  reconnectOnly: {
    button: "モバイルアプリに再接続"
  },
  scanningFailed: {
    text: "モバイルでは、メッセージを正常にスキャンできませんでした。もう一度お試しください。",
    title: "スキャンに失敗しました"
  },
  start: {
    hideAppQRCode: "QRコードを隠す",
    revealAppQRCode: "QRコードを表示",
    step1: "もしモバイルアプリをお持ちでない場合、お使いの携帯電話に応じてApple App StoreまたはGoogle Play StoreのQRコードをスキャンすることができます。",
    step2: "モバイルアプリ（「Digital Bitbox 2FA」の名前でiOS・Android用アプリを検索できます）からQRコードをスキャンしてください。"
  },
  started: {
    text: "モバイルアプリに表示されている手順に従ってください。",
    title: "いい調子です"
  },
  success: {
    text: "おめでとうございます、あなたのBitBoxは問題なくモバイルアプリとペアリングされました。",
    title: "成功"
  },
  timeout: {
    text: "ペアリング作業は2分経過した時点でタイムアウトしました。ペアリングを行いたい場合はもう一度最初からやり直してください。",
    title: "タイムアウト"
  },
  title: "モバイルペアリング"
}, passphrase$7 = {
  considerations: {
    button: "バックアップについて",
    message: `パスフレーズは、あなたのウォレットのバックアップ（マイクロSDカードまたはリカバリーワード）に保護の層を追加します。誰かがあなたのバックアップにアクセスできる場合、あなたのウォレットにアクセスするためにもパスフレーズが必要になります。

しかし、これはあなたがBitBox02を失ったり壊したりした場合、パスフレーズを有効にしたウォレットを復元するためには<strong>パスフレーズ + ウォレットのバックアップ</strong>の両方が必要になることを意味します。パスフレーズを忘れたり失ったりすると、そのウォレットの全てのコインにアクセスできなくなります。

パスフレーズを保存する際には、バックアップとは別の場所に置くことを検討してください。そのようにすると、誰かがあなたのバックアップを見つけてもパスフレーズは見つけられないでしょう。`,
    title: "バックアップについて"
  },
  disable: "パスフレーズを無効にする",
  disableInfo: {
    button: "無効にする",
    message: `パスフレーズを無効にした後、BitBox02のロックを解除した後でパスフレーズを入力するよう求められることはもうありません。したがって、デフォルトのウォレットを入力することになります。

パスフレーズウォレット上のコインはそのまま残りますが、BitBox02のロックを解除した後はデフォルトのウォレットが開くため、アクセスできなくなります。

再度パスフレーズウォレットにアクセスするには、単にパスフレーズ機能を再有効にし、BitBox02のロックを解除した後に関連するパスフレーズを入力します。

<strong>ヒント:</strong>パスフレーズを空白にすることで、元のウォレットに依然として入ることができます。`
  },
  enable: "パスフレーズを有効にする",
  error: {
    e104: "パスフレーズ設定の変更が中止された。"
  },
  how: {
    button: "どのようなものか",
    message: `パスフレーズは、あなたが普段使っているパスワードとは異なります。パスフレーズを間違って入力しても、通知はされません。これは、<strong>すべてのパスフレーズが異なる、しかしそれでも有効なウォレットを作成する</strong>からです。これは、あなたが望むだけの多くのウォレットに対して複数のパスフレーズを使用できることを意味します。しかし、各ウォレットは対応するパスフレーズを入力したときにのみアクセスできます。

BitBox02を接続すると、通常どおりデバイスのパスワードが求められます。その後、デバイス上でパスフレーズを入力するよう求められます。

パスフレーズを入力した後、入力したパスフレーズが表示されます。これは、あなたが正しく入力したことを確認するためです。`,
    title: "どのような仕組みになっているのか"
  },
  intro: {
    message: `パスフレーズは、ウォレットのセキュリティを一層強化するためのものです。
それがどのように機能するかを学んでみましょう。

`,
    title: "パスフレーズの設定"
  },
  progressDisable: {
    message: "オプションのパスフレーズを<strong>disable</strong>にすることをBitBoxで確認します。",
    title: "デバイスで確認する"
  },
  progressEnable: {
    message: "オプションのパスフレーズを<strong>enable</strong>にすることをBitBoxで確認します。",
    title: "デバイスで確認する"
  },
  successDisabled: {
    message: `オプションのパスフレーズ <strong>successfully enabled</strong>！
今後、パスフレーズの入力が求められます。`,
    messageEnd: "今すぐBitBox02を再接続してください。",
    title: "パスフレーズを有効にする"
  },
  successEnabled: {
    message: `オプションのパスフレーズは<strong>正常に無効化されました</strong>！

パスフレーズの入力を求められることはなくなりました。`,
    messageEnd: "今すぐあなたのBitBox02を再接続してください。",
    tips: "ヒント",
    tipsList: [
      "まず少額をパスフレーズウォレットに送金することをおすすめします。その後、BitBox02を抜き差しし、パスワードとパスフレーズを入力します。パスフレーズを正しく入力した場合、ウォレットにコインが表示されます。",
      "パスフレーズなしで元のウォレットに入りたい場合、パスフレーズの入力を求められたときに何も入力しないことでパスフレーズを入力することができます。また、パスフレーズ機能を無効にすることもできます。"
    ],
    title: "パスフレーズ無効"
  },
  summary: {
    button: "パスフレーズ有効",
    title: "要約",
    understand: "パスフレーズの仕組みやリスクについて理解している。",
    understandList: [
      "パスフレーズは、バックアップの上に追加されるセキュリティの層です。",
      "異なるパスフレーズを入力すると、必ず異なるウォレットが生成されます。",
      "ウォレットを復元するには、<strong>パスフレーズとバックアップの両方が必要です</strong>。",
      "パスフレーズを忘れた場合、<strong>コインにアクセスできなくなります</strong>。"
    ]
  },
  what: {
    button: "この仕組みについてはこちら",
    message: `ウォレットは非常に大きなランダムな数値（シードとも呼ばれる）から作成（派生）されます。このシードはBitBox02を初めて設定したときに作成され、マイクロSDカードまたはリカバリーワードでバックアップされます。シードにアクセスできる人は、そのウォレットの資金を完全にコントロールすることができます。

パスフレーズは、シードに追加される<strong>オプションの秘密</strong>です。パスフレーズを使用すると、各パスフレーズはシード + パスフレーズ（オプションの秘密）に基づいた新しいウォレットを作成します。パスフレーズは何でもよいです：文字、単語、特殊文字、または空でも可能です。デフォルトのウォレットは実際にはシード + 空のパスフレーズから派生します。

パスフレーズはBIP39標準の一部であり、これは同じ標準をサポートするすべてのウォレットと互換性があることを意味します。`,
    title: "パスフレーズとは何ですか？"
  },
  why: {
    button: "パスフレーズを使用する理由",
    message: `BitBox02は、デバイス自体からのシードの抽出を防ぎますが、バックアップ（マイクロSDカードまたはリカバリーワード）はウォレットへの完全なアクセスを提供します。そのため、それは安全な場所に保存するべきです！

パスフレーズが既存のシードを使用して新しいウォレットを作成するため、パスフレーズウォレットの復元には<strong>バックアップとパスフレーズの両方が必要</strong>です。これの利点は、誰かがあなたのバックアップを見つけても、パスフレーズウォレットにアクセスするためにはパスフレーズが必要であるということです。

さらに、パスフレーズ機能を使用すると、同じデバイス上に複数のウォレットを作成したり、デフォルトのものに加えて「隠されたウォレット」を作成したりすることができます。`,
    title: "なぜパスフレーズを使うのですか？"
  }
}, password$d = {
  show: "{{label}}を表示",
  warning: {
    caps: "注意：caps lock(⇪)が有効になっています",
    paste: "貼り付けを行うには「{{label}}を表示」を有効にしてください"
  }
}, random$e = {
  button: "乱数を生成する",
  description: "あなたのBitBoxは次の{{bits}}bit乱数を生成しました："
}, receive$f = {
  changeScriptType: "アドレスの種類を変更する",
  label: "あなたのアドレス",
  onlyThisCoin: {
    description: "他のトークンを受け取るには、設定で有効にしてください。他のトークンを預けると、アクセスできなくなる場合があります。",
    warning: "このアドレスで{{coinName}}だけを受信するようにしてください。"
  },
  scriptType: {
    p2tr: "Taproot (最新版)",
    p2wpkh: "Native Segwit (デフォルト)",
    "p2wpkh-p2sh": "Wrapped Segwit（互換フォーマット）"
  },
  selectAccount: "アカウント選択",
  showFull: "フルアドレスをデバイス上で表示・確認",
  taprootWarning: "注意：Taprootは新しいビットコインの機能であり、まだ広く採用されていません。Taprootアドレスで受け取った資金は、サードパーティのwatch-only ウォレットでは表示されない場合があります。多くのウォレットと取引所はまだTaprootアドレスに送金することができません。",
  title: "受け取る{{accountName}}",
  verify: "安全にアドレスを検証する",
  verifyBitBox01: "モバイルアプリでアドレスを確認する",
  verifyBitBox02: "BitBox02のアドレスを確認する",
  verifyInstruction: "下記アドレスがデバイス画面に表示されているものと一致することを確認してください。",
  warning: {
    secureOutput: `あなたのBitBoxをあなたのモバイルデバイスとペアリングして、安全なアドレス検証を有効にしてください。サイドバーの「デバイスの管理」に移動してください。



`
  }
}, reset$d = {
  description: "このデバイスからすべてのデータが削除されます。それには、あなたのプライベートキーも含まれます！",
  notReset: "デバイスはリセットされませんでした。",
  title: "デバイスを工場出荷状態にリセット",
  understand: "私はバックアップがあり、リカバリーパスワードも覚えています",
  understandBB02: "有効なバックアップがあります"
}, securityInformation$d = {
  create: {
    description1: "私たちは、他の人があなたが選んだパスワードを見ることができる環境から離れた、安全な環境でデバイスを設定することをお勧めします。",
    description2: "これから2つのパスワードを設定します。",
    description3: "1つ目は<strong>デバイスパスワード</strong>です。あなたのBitBoxをアンロックをするのに必要で、後から変更することができます。",
    description4: "2つ目は<strong>リカバリーパスワード</strong>です。これはウォレットのアンロックに使用され、後から変更できません。",
    description5: "作成したウォレットは、提供されたマイクロSDカード上のファイルにバックアップされます。これは緊急時にあなたの<strong>リカバリーパスワード</strong>を使用して資金を回復するために使用することができます。",
    title: "セキュリティ情報"
  },
  restore: {
    description1: "バックアップを保存するために使用したmicroSDカードを挿入するよう求められます。",
    description2: "復元を行うにはリカバリーパスワードが必要です。",
    description3: "リカバリーパスワードを入力する際はご注意ください。間違ったパスワードを入力した場合でも妥当なウォレットは作成されます。パスワードが間違っていた場合は予期せぬウォレット残高が表示される場合があります。",
    title: "セキュリティ情報"
  }
}, seed$d = {
  agreements: {
    "funds-access": "リカバリーパスワードを忘れてしまった場合は資金へアクセスできません",
    "password-change": "リカバリーパスワードを後から変更することができません",
    "password-required": "ウォレットをバックアップから復元したい場合はリカバリーパスワードが必要になります"
  },
  create: "ウォレットを作成する",
  creating: "ウォレットの作成中",
  description: "次の項目を確認しました：",
  error: {
    e102: "パスワードは最低4文字(半角)必要です。",
    e200: "ウォレットを作成するためには、BitBoxにmicroSDカードを挿入する必要があるため、自動的にバックアップを作成することが可能です。"
  },
  info: {
    button: "今すぐリカバリーパスワードを設定する",
    description1: "BitBoxにmicroSDカードを挿入してください",
    description2: "ウォレットのリカバリーパスワードを決めて「リカバリーパスワードを設定する」を選択してください",
    description3: "マイクロSDカードへのバックアップとあなたのリカバリーパスワードは、BitBoxデバイスが紛失または盗難の場合に資金を回復する唯一の方法です。",
    description4: "資金を移す以外の方法で、後からリカバリーパスワードの変更を行うことはできません。",
    title: "新しいウォレットの作成"
  },
  password: {
    label: "リカバリーパスワード",
    repeatPlaceholder: "リカバリーパスワードの確認"
  },
  walletName: {
    label: "ウォレット名"
  }
}, seedRestore$d = {
  error: {
    e200: "バックアップからウォレットを復元するには、マイクロSDカードが必要です。"
  },
  info: {
    description1: "BitBoxにmicroSDカードを挿入し「続ける」をクリックしてください。",
    description2: "バックアップを選択し、「復元」をクリックしてください",
    description3: "リカバリーパスワード",
    description4: "間違ったパスワードは別のウォレットを作成することを理解するため、あなたの確認が必要です。",
    title: "バックアップからウォレットを復元する方法"
  }
}, send$f = {
  abort: "取引は中止されました。",
  address: {
    label: "受信者アドレス",
    placeholder: "アドレスを入力してください"
  },
  amount: {
    label: "金額",
    placeholder: "金額を入力してください"
  },
  availableBalance: "利用可能な残高",
  button: "レビュー",
  coincontrol: {
    address: "アドレス",
    outpoint: "アウトポイント",
    title: "アウトプットから送信します。"
  },
  confirm: {
    "selected-coins": "選択されたコイン",
    title: "トランザクションの確認と送信",
    total: "総額"
  },
  error: {
    erc20InsufficientGasFunds: "このERC20トランザクションの手数料を支払うために十分なイーサがないようです。ウォレットに十分なイーサが保有されているか確認してください。",
    feeTooLow: "手数料が低すぎます。",
    feesNotAvailable: "手数料を見積もることができませんでした。",
    insufficientFunds: "資金が不十分です",
    invalidAddress: "無効なアドレス",
    invalidAmount: "無効な金額",
    invalidData: "無効なデータ"
  },
  fee: {
    customPlaceholder: "金額を入力してください",
    label: "ネットワーク手数料",
    placeholder: "情報がありません"
  },
  feeTarget: {
    customLabel: "手数料率",
    customLabel_eth: "ガス料金",
    description: {
      economy: "4時間（24ブロック）",
      economy_eth: "30分以内",
      economy_ltc: "1時間（24ブロック）",
      high: "20分（2ブロック）",
      high_eth: "30秒以内",
      high_ltc: "5分（2ブロック）",
      low: "2時間（12ブロック）",
      low_eth: "5分以内",
      low_ltc: "30分（12ブロック）",
      normal: "1時間（6ブロック）",
      normal_eth: "2分以内",
      normal_ltc: "15分（6ブロック）"
    },
    estimate: "推定確認時間：",
    label: {
      custom: "カスタム",
      economy: "エコノミー",
      high: "高い",
      low: "低い",
      normal: "ノーマル"
    },
    placeholder: "手数料を計算しています..."
  },
  maximum: "全て送信",
  maximumSelectedCoins: "選択したコインを送信します。",
  noFeeTargets: "現在、手数料率の見積もりは利用できません。後でもう一度試すか、カスタム手数料を入力してください",
  priority: "優先",
  scanQR: "QRコードをスキャン",
  signprogress: {
    description: "この取引はたくさんのデータを含みます。取引を完全にサインするには、{{steps}}回確認することを求められます。",
    label: "進行度"
  },
  success: "取引は署名され送信されました。",
  title: "{{accountName}}送信する。",
  toggleCoinControl: "コインコントロールの切り替え",
  transactionDetails: "トランザクションの詳細"
}, settings$e = {
  about: "について",
  accounts: "アカウント",
  advancedSettings: "詳細設定",
  appearance: "外観",
  electrum: {
    add: "サーバーを追加",
    "add-server": "追加",
    check: "チェック",
    checkFailed: "失敗しました",
    checkSuccess: "{{host}}への接続に成功しました",
    checking: "チェック中",
    "download-cert": "リモート証明書をダウンロード",
    "remove-server": "削除",
    removeConfirm: "{{server}} を削除しますか？",
    reset: "デフォルト値に戻す",
    resetConfirm: "全てのサーバーを削除して、デフォルトのサーバーをインストールしますか？",
    servers: "サーバー一覧",
    step1: "1",
    "step1-text": "エンドポイントを入力してください。",
    step2: "2",
    "step2-text": "サーバーの証明書チェーンの証明書を入力してください。または、リモート証明書をダウンロードして比較することも可能です。",
    "step2-text-tcp": "もしTLSを使用したくない場合は、このステップをスキップしてください。",
    step3: "3",
    "step3-text": "接続の確認を行なってサーバーを追加しましょう。",
    step4: "4",
    "step4-text": "ウォレットを再起動してください。デフォルトのサーバーを削除したくない場合、あなたのノードは重複物としてついかされます。",
    "title-btc": "Bitcoin Electrumサーバー",
    "title-ltc": "Litecoin Electrumサーバー",
    "title-tbtc": "Bitcoin Testnet Electrumサーバー",
    "title-tltc": "Litecoin Testnet Electrumサーバー"
  },
  expert: {
    coinControl: "コインコントロールを有効にする",
    electrum: {
      description: "独自のElectrumフルノードに接続することができます。",
      title: "自分のノードに接続"
    },
    fee: "カスタム手数料を有効にします。",
    setProxyAddress: "プロキシアドレスを設定します。",
    title: "エキスパート設定",
    useProxy: "Torプロキシを有効にします。",
    useSats: `
BTCの値をSatoshiで表示します。`
  },
  header: {
    home: "ホーム"
  },
  info: {
    "out-of-date": "新しいアップデートが利用可能です。",
    title: "情報",
    "up-to-date": "お使いのアプリは最新版です。",
    version: "アプリのバージョン"
  },
  restart: "変更が反映されるためには、BitBoxAppを再起動してください。",
  services: {
    title: "サービス"
  },
  success: "変更を適用するにはBitBoxを一度引き抜いてから再度挿入してください。",
  title: "設定"
}, setup$d = "デバイスを設定", sidebar$e = {
  buy: "仮想通貨を購入する",
  device: "デバイス管理",
  leave: "離れる",
  settings: "設定"
}, success$k = {
  create: {
    info1: "ウォレットは安全にmicroSDカードにバックアップされました。カードを取り外して安全な場所に保管してください。",
    info2: "Bitboxのアンロックに使われる安全なデバイスパスワードを作成しました。",
    info3: "あなたのウォレットの資産とバックアップをアンロックする安全なリカバリーパスワードを作成しました。",
    summary: "これまでのサマリーです",
    title: "成功"
  },
  getstarted: "始めましょう",
  restore: {
    summary: "バックアップからのウォレットの復元に成功しました。",
    title: "成功"
  }
}, transaction$e = {
  confirmation: "認証済み",
  details: {
    activity: "アクティビティ",
    address: "アドレス",
    amount: "金額",
    date: "日付",
    fiat: "フィアット",
    fiatAmount: "フィアットの金額",
    fiatAtTime: "取引時のフィアットの価格",
    status: "ステータス",
    type: "タイプ"
  },
  explorer: "取引ID",
  explorerTitle: "外部のブロックエクスプローラで開く",
  fee: "手数料",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "ノートを編集する",
    save: "ノートを保存する"
  },
  pending: "保留中のトランザクション",
  size: "サイズ",
  status: {
    complete: "完了",
    failed: "失敗しました",
    pending: "保留中"
  },
  tx: {
    received: "受信先",
    sent: `送信先
`
  },
  vsize: "バーチャルサイズ",
  weight: "重量"
}, transactions$d = {
  errorLoadTransactions: "トランザクションの読み込み中にエラーが発生しました。",
  placeholder: "表示できる取引がありません。"
}, unknownError$d = "不明なエラーが起きました：{{errorMessage}}", unlock$d = {
  description: "デバイスパスワードを入力してアンロックしてください。",
  error: {
    e109_normal: "デバイスパスワードが間違っています。デバイスがリセットされるまで後{{remainingAttempts}}回入力できます。",
    e109_touch: "$t(unlock.error.e109_normal) 次のログインではデバイスの長押しが必要です。",
    e113: "ログインを試みた回数が多いため、次のログインではデバイスを4秒以上長いしする必要があります。"
  },
  input: {
    label: "デバイスパスワード",
    placeholder: "デバイスをアンロックするにはデバイスパスワードを入力してください。"
  },
  unlocking: "アンロック中…"
}, upgradeFirmware$e = {
  button: "ファームウェアをアップグレード",
  description: "{{currentVersion}}から{{newVersion}}へのファームウェアのアップグレードを行いますか？",
  label: "BitBoxのファームウェアアップグレードが必要です。",
  locked: "{{currentVersion}}から{{newVersion}}にアップグレードするには、デバイスを長押ししてください。",
  title: "ファームウェアをアップグレード",
  unlocked: "ブートローダーはアンロックされています。続けるには：",
  unlocked1: "BitBoxを引き抜き、再度差し込んでください",
  unlocked2: "BitBoxを再度挿入した際にLEDが点灯します",
  unlocked3: "LEDが点灯したらデバイスをタップしてください"
}, walletConnect$7 = {
  connect: {
    button: "接続する",
    dappLabel: "dappのURIアドレスを入力してください。",
    invalidPairingUri: "無効なペアリングURIです"
  },
  dashboard: {
    allSessions: "全セッション",
    disclaimer: "Walletconnectは、EthereumベースのDappsに接続するためのプロトコルです。これらのdappsはサードパーティのサービスによって運営されているため、信頼できるdappsにのみ接続し、トランザクションを行う際には常に署名している内容を把握しておくことが重要です。",
    newConnection: "新しい接続",
    noConnectedSessions: "現在、どのアカウントもdappsに接続されていません。"
  },
  invalidPairingChain: "ペアリングの承認にエラーが発生しました。サポートされているチェーンの一つを使用していることを確認してください：{{chains}}",
  pairingRequest: {
    approve: "接続を承認する",
    reject: "拒否する",
    title: "からの新規接続リクエスト"
  },
  pairingSuccess: "Dappが正常に接続されました。dappのウェブサイトで続行できます。",
  signingRequest: {
    account: "アカウント",
    chain: "チェーン",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "データの解析に失敗しました",
    decodeError: "メッセージのデコードに失敗しました。",
    method: {
      sendTransaction: "トランザクションに署名して送信する",
      signMessage: "メッセージに署名する",
      signTransaction: "トランザクションに署名する",
      signTypedData: "タイプされたデータに署名する"
    },
    successfullySigned: "リクエストが正常に署名されました。",
    walletConnectRequest: "WalletConnectリクエスト"
  },
  useNewUri: "このURIはすでに接続を試みるために使用されています。新しいURIを使用してください。",
  walletConnect: "WalletConnect"
}, warning$j = {
  receivePairing: "安全なアドレス検証を有効にするために、BitBoxをペアリングしてください。サイドバーの「デバイスの管理」に移動してください。",
  sdcard: "バックアップを管理したい場合を除き、BitBoxとマイクロSDカードを別々に保管してください。",
  sendPairing: "トランザクションの詳細を安全に確認するために、BitBoxをペアリングしてください。サイドバーの「デバイスの管理」に移動してください。"
}, welcome$d = {
  connect: "BitBox02を接続する",
  getStarted: "BitBox02にファームウェアをインストールして始めましょう。",
  insertBitBox02: "BitBox02の場合は、続行するためにデバイスをタップしてください。",
  insertDevice: "開始するにはデバイスを差し込んでください",
  title: "ようこそ"
}, appTranslationsJA = {
  account: account$d,
  accountInfo: accountInfo$d,
  accountSummary: accountSummary$d,
  addAccount: addAccount$e,
  aopp: aopp$7,
  app: app$d,
  auth: auth$6,
  backup: backup$d,
  bb02Bootloader: bb02Bootloader$d,
  bitbox: bitbox$d,
  bitbox02Interact: bitbox02Interact$d,
  bitbox02Settings: bitbox02Settings$d,
  bitbox02Wizard: bitbox02Wizard$d,
  blink: blink$d,
  bootloader: bootloader$d,
  button: button$h,
  buy: buy$9,
  changePin: changePin$d,
  chart: chart$9,
  checkSDcard: checkSDcard$d,
  clickHere: clickHere$d,
  confirm: confirm$f,
  confirmOnDevice: confirmOnDevice$d,
  connectKeystore: connectKeystore$6,
  darkmode: darkmode$7,
  device: device$d,
  deviceLock: deviceLock$d,
  deviceSettings: deviceSettings$d,
  deviceTampered: deviceTampered$d,
  dialog: dialog$e,
  error: error$9,
  fiat: fiat$f,
  footer: footer$f,
  generic: generic$9,
  genericError: genericError$d,
  goal: goal$d,
  guide: guide$e,
  headerssync: headerssync$d,
  hiddenWallet: hiddenWallet$d,
  initialize: initialize$d,
  invalidFormat: invalidFormat$d,
  language: language$e,
  legacyhiddenwallet: legacyhiddenwallet$d,
  loading: loading$d,
  manageAccounts: manageAccounts$7,
  mobile: mobile$8,
  newSettings: newSettings$6,
  note: note$9,
  notification: notification$d,
  pairing: pairing$d,
  passphrase: passphrase$7,
  password: password$d,
  random: random$e,
  receive: receive$f,
  reset: reset$d,
  securityInformation: securityInformation$d,
  seed: seed$d,
  seedRestore: seedRestore$d,
  send: send$f,
  settings: settings$e,
  setup: setup$d,
  sidebar: sidebar$e,
  success: success$k,
  transaction: transaction$e,
  transactions: transactions$d,
  unknownError: unknownError$d,
  unlock: unlock$d,
  upgradeFirmware: upgradeFirmware$e,
  walletConnect: walletConnect$7,
  warning: warning$j,
  welcome: welcome$d
}, account$c = {
  disconnect: "Потеряна связь. Восстановление связи ... ",
  export: "Экспортировать",
  exportTransactions: "Экспортировать транзакций в папку «загрузки» в виде файла CSV",
  fatalError: "Произошла ошибка.",
  incoming: "Ждите",
  initializing: "Получение информации из блокчейна ...",
  maybeProxyError: "Прокси-сервер включен. Убедитесь, что Ваш прокси-сервер рабочий, иначе отключите использование прокси-сервера в настройках.",
  reconnecting: "Потерянна связь, попытка повторного подключения ...",
  syncedAddressesCount: "Отсканировано {{count}} адресов"
}, accountInfo$c = {
  address: "Адрес",
  buyCTA: {
    buy: "Покупка {{unit}}",
    buyCrypto: "Купить криптовалюту",
    information: {
      looksEmpty: "Возможно, этот кошелёк пустой",
      start: "Внесите интересующую криптовалюту на кошелёк или купите в приложении BitBoxApp."
    }
  },
  extendedPublicKey: "Расширенный Public Key",
  label: "Информация об учетной записи",
  scriptType: "Тип шифрования",
  title: "Информация об учетной записи",
  verify: "Подтвердите на устройстве",
  xpubTypeChangeBtn: {
    p2pkh: "Обзор legacy P2PKH расширенного открытого ключа",
    p2tr: "Просмотр счета Taproot",
    p2wpkh: "Просмотр счета Native Segwit",
    "p2wpkh-p2sh": "Просмотр Segwit расширенного открытого ключа"
  },
  xpubTypeInfo: "Отображение {{scriptType}} расширенного открытого ключа ({{current}} из {{numberOfXPubs}})"
}, accountSummary$c = {
  availableBalance: "Доступный баланс",
  balance: "Баланс",
  exportSummary: "Экспортировать сводку учетных записей в папку загрузок в виде файла CSV",
  fiatBalance: "Валютный баланс",
  name: "Название учетной записи",
  noAccount: "Нет аккаунтов для показа.",
  subtotalWithCoinName: "Монета ({{coinName}})",
  title: `Моя учетная запись
`,
  total: "Всего",
  transactionHistory: "Журнал транзакций"
}, addAccount$d = {
  chooseName: {
    nextButton: "Добавить аккаунт",
    step: "Имя аккаунта",
    title: "Назовите свой аккаунт"
  },
  selectCoin: {
    nextButton: "Далее",
    step: "Выберите монету",
    title: "Выберите криптовалюту"
  },
  success: {
    message: "<strong>{{accountName}}</strong> добавлен в аккаунт",
    nextButton: "Выполнено",
    step: "Завершено",
    title: "Добавлен аккаунт"
  },
  title: "Добавить учётную запись"
}, aopp$6 = {
  addressRequest: "{{host}} запрашивает адрес получателя",
  addressRequestWithLogo: "запрашивается адрес получателя",
  banner: "Выполняется запрос адреса",
  errorTitle: "Ошибка при запросе адреса",
  labelAddress: "Адрес",
  labelMessage: "Сообщение",
  reverifyInfoText: "Проверка адреса",
  signing: "Чтобы продолжить, подпишите сообщение на BitBox02",
  success: {
    message: "Продолжить на {{host}}",
    title: "Адрес успешно отправлен"
  },
  syncing: "Синхронизация аккаунта, пожалуйста, подождите.",
  title: "Запрос адреса"
}, app$c = {
  upgrade: "Доступна новая версия этого приложения! Обновите с {{current}} на {{version}}."
}, backup$c = {
  check: {
    checking: "Проверка резервных копий ...",
    confirmTitle: "Проверить резервную копию",
    notOK: "Резервная копия НЕ соответствует текущему кошельку. ",
    ok: "Резервная копия соответствует текущему кошельку.",
    password: {
      label: "Пароль восстановления",
      placeholder: "Пароль восстановления",
      showLabel: "пароль восстановления"
    },
    success: "Резервная копия успешно подтверждена:",
    title: "Проверить резервную копию"
  },
  create: {
    alreadyExists: "У вас уже существует резервная копия. Вы хотите её переписать?",
    fail: "Создание резервной копии НЕ удалось!",
    info: "Введите пароль восстановления текущего кошелька для проверки.",
    name: {
      label: "Имя резервной копии",
      placeholder: "Укажите имя резервной копии"
    },
    password: {
      label: "Пароль восстановления",
      placeholder: "Введите Ваш пароль восстановления"
    },
    title: "Создать резервную копию",
    verificationFailed: "Пароль восстановления НЕ СООТВЕТСВУЕТ текущему кошельку. Создана новая резервная копия. Используйте «Проверить резервную копию», чтобы подтвердить пароль восстановления."
  },
  description: "Выбрать <strong>файл резервной копии</strong>",
  insert: "Вставьте карту памяти microSD для управления резервными копиями.",
  insertButton: "Я вставил карту памяти microSD",
  list: "Список резервных копий на карте памяти microSD",
  noBackups: "На этой карте microSD нет резервных копий.",
  restore: {
    confirmTitle: "Восстановление резервной копии",
    error: {
      e200: "Карта памяти microSD не обнаружена",
      general: "Невозможно восстановить резервную копию"
    },
    password: {
      label: "Пароль восстановления или скрытый пароль восстановления",
      placeholder: "Пароль восстановления",
      repeatPlaceholder: "Повторите пароль восстановления",
      showLabel: "Пароль восстановления"
    },
    restoring: "Происходит восстановление резервной копии ...",
    selectedBackup: "<strong>{{backupName}}</strong> созданный на {{createdDateTime}}будет восстановлен",
    title: "Восстановить",
    understand: "Я понимаю, что неверный пароль восстановления создаст другой кошелек"
  },
  showMnemonic: {
    description: `Вам будут представлены 24 слова восстановления, которые образуют резервную копию Вашего кошелька. Запишите их на бумаге.

<strong>Не храните их в цифровом виде и не фотографируйте.</strong>

<strong>Не произносите слова вслух.</strong>

<strong>Эта резервная копия не защищена паролем.</strong>

После этого вам будет предложено подтвердить каждое слово.`,
    title: "Показать слова восстановления кошелька"
  },
  title: "Управление резервными копиями"
}, bb02Bootloader$c = {
  abort: "Не обновлять - вернуться обратно",
  abort_noUpgrade: "Вернуть назад",
  advanced: {
    label: "Дополнительные настройки",
    toggleShowFirmwareHash: "Показывать хэш прошивки каждый раз при запуске"
  },
  flipscreen: "Перевернуть экран",
  orientation: "Экран ориентирован на другую сторону?",
  success: "Обновление прошло успешно! Перезагрузка через {{rebootSeconds}} секунд ...",
  success_install: "Установка прошла успешно! Перезагрузка через {{rebootSeconds}} секунд..."
}, bitbox$c = {
  error: {
    e10000: "Неверный пароль устройства.",
    e10001: "Не удалось заменить пароль устройства",
    e102: "Пароль должен содержать не менее 4 символов.",
    e112: "Скрытый пароль устройства не может совпадать с основным паролем устройства."
  }
}, bitbox02Interact$c = {
  confirmDate: "Подтвердите сегодняшнюю дату на Вашем устройстве BitBox02",
  confirmDateText: "Эта дата будет использована для создания Вашей резервной копии.",
  confirmName: "Подтвердите имя на Вашем устройстве BitBox02",
  followInstructions: "Пожалуйста, следуйте инструкциям на Вашем устройстве BitBox02.",
  followInstructionsMnemonic: "Пожалуйста, следуйте инструкциям на вашем устройстве BitBox02, чтобы восстановить кошелек используя резервную копию слов",
  followInstructionsMnemonicTitle: "Восстановление из резервных слов (мнемонической фразы)"
}, bitbox02Settings$c = {
  deviceName: {
    current: "Текущее имя устройства",
    input: "Имя устройства BitBox02",
    placeholder: "Новое имя устройства",
    title: "Переименовать устройство BitBox02"
  },
  gotoStartupSettings: {
    description: "Данное действие перезагрузит BitBox02 и вернет начальные настройки запуска",
    title: "Перейти к начальным настройкам"
  }
}, bitbox02Wizard$c = {
  attestationFailed: "Проверка подлинности устройства не удалась. Это могло быть связано с перезапуском приложения, когда устройство ожидало ввода данных. Пожалуйста, снова переподключите устройство и повторите попытку. Пожалуйста, свяжитесь с support@bitbox.swiss если эта проблема не решилась",
  backup: {
    point1: "Выберите резервную копию на карте microSD",
    point2: "Установите пароль для вашего устройства",
    restoreText: "Хорошо, давайте восстановим резервную копию!",
    text1: "Отлично, ваш пароль BitBox02 теперь установлен и кошелек создан. Теперь пришло время создать вашу первую резервную копию. Убедитесь, что ваша карта microSD вставлена ​​в BitBox02, и продолжайте.",
    text2: "Пожалуйста, следуйте инструкциям на экране вашего устройства, чтобы создать резервную копию.",
    text3: "После создания резервной копии извлеките карту microSD и храните её в <strong>безопасном месте</strong>. Содержимое карты microSD не защищено паролем. Никогда не вставляйте её в любое другое устройство, кроме вашего BitBox02.",
    userConfirmation1: "Я должен хранить резервную копию в надежном месте.",
    userConfirmation2: "Моя резервная копия не защищена паролем. Любой, у кого есть доступ, сможет владеть моим кошельком.",
    userConfirmation3: "Если я потеряю или повредю мой BitBox02, единственный способ восстановить все средства - это резервная копия.",
    userConfirmation4: "Если я потеряю или повредю резервную копию и мой BitBox02, все средства будут утеряны.",
    userConfirmation5: "Я не должен вставлять мою карту памяти microSD на которой находится резервная копия в компьютер, телефон, принтер или любое другое устройство, кроме BitBox02."
  },
  create: {
    button: "Именовать устройство и продолжить",
    info: "Вот основные шаги, которые вы будете предпринимать для настройки вашего BitBox: ",
    inputTitle: "Название кошелька",
    point1: "Назовите Ваше устройство",
    point2: "Установите пароль для Вашего устройства",
    point3: "Создать резервную копию",
    text: "Хорошо, давайте создадим новый кошелек!"
  },
  createBackupFailed: "Не удалось создать резервную копию. Попробуйте еще раз.",
  initialize: {
    passwordText: "Теперь давайте установим пароль для вашего устройства. Используйте элементы управления на вашем BitBox для ввода и выбора пароля.",
    passwordTitle: "Установите пароль для вашего BitBox",
    text: "Ваш BitBox02 был успешно присоединен! Теперь давайте инициализировать ваше устройство. Начните с выбора создания нового кошелька или восстановления кошелька из существующей резервной копии. <strong>Убедитесь, что в ваш BitBox02 вставлена ​​карта памяти microSD</strong>",
    tip: "Прежде чем продолжить, настоятельно рекомендуется продолжить работу в безопасной среде.",
    title: "Инициализируйте ваш BitBox"
  },
  insertSDCard: "<strong>Убедитесь, что в BitBox02 вставлена ​​карта microSD.</strong>",
  noPasswordMatch: "Пароли не совпадают, попробуйте еще раз.",
  pairing: {
    failed: "Неподтвержденное присоединение. Пожалуйста, подключите ваш BitBox02 заново.",
    paired: "Вы подтвердили на своем устройстве, что код соответствует. Если это правильно, вы можете продолжить, нажав кнопку ниже.",
    title: "Проверьте код соединения",
    unpaired: "Новый BitBox02 был обнаружен. Убедитесь, что следующий код соответствует тому, что показан на вашем устройстве. Если код соответствует, нажмите под галочкой на вашем BitBox02 и затем нажмите кнопку ниже, чтобы продолжить."
  },
  restoreFromMnemonic: {
    failed: "Не удалось выполнить восстановление. Попробуйте еще раз."
  },
  stepBackup: {
    beforeProceed: "Прежде чем продолжить, прочтите следующие важные примечания по безопасности:",
    createBackup: "Теперь вы создадите резервную копию на карте microSD."
  },
  stepBackupSuccess: {
    fundsSafe: "Для максимальной безопасности ваших средств, помните следующее:",
    title: "Резервная копия восстановлена!"
  },
  stepConnected: {
    unlock: "Введите пароль BitBox02 для разблокировки."
  },
  stepCreate: {
    description: "Это имя используется в качестве имени устройства и для резервного копирования",
    nameLabel: "Имя BitBox02",
    namePlaceholder: "Мой BitBox02",
    title: "Выберите имя BitBox02",
    toastMicroSD: "Убедитесь, что карта microSD вставлена ​​в BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "Извлеките карту microSD из BitBox02 и храните ее в надежном месте.",
    success: "Вы успешно создали резервную копию"
  },
  stepInsertSD: {
    insertSDCard: "Чтобы продолжить, вставьте карту microSD в BitBox02.",
    insertSDcardTitle: "Вставьте карту microSD"
  },
  stepPassword: {
    title: "Установить пароль BitBox02",
    useControls: "Используйте элементы управления на устройстве BitBox02, чтобы установить пароль."
  },
  stepUninitialized: {
    create: "Я хочу инициализировать новый BitBox02.",
    restore: "Я хочу восстановить мой кошелек из резервной копии.",
    restoreMicroSD: "Восстановить с карты microSD",
    restoreMnemonic: "Восстановить с помошью слов восстановления",
    title: "Инициализируйте Ваш BitBox02"
  },
  success: {
    text: `Ура! Ваш BitBox02 теперь готов к использованию.

Для получения дополнительной информации о том, как использовать приложение BitBoxApp, пожалуйста, используйте руководство в приложении, нажав на знак вопроса в верхнем правом углу.`,
    title: "Вы готовы к работе!"
  }
}, blink$c = {
  button: "Мерцать"
}, bootloader$c = {
  button: "Обновить прошивку",
  button_install: "Установить прошивку",
  progress: "Обновление: {{progress}}%",
  progress_install: "Установка: {{progress}}%",
  success: "Успешное обновление! Отсоедините и присоедените устройство заново. На этот раз не прикасайтесь к кнопке."
}, button$g = {
  abort: "Прервать",
  back: "Назад",
  buy: "Купить",
  changepin: "Изменить пароль устройства",
  check: "Проверить резервную копию",
  continue: "Продолжить",
  copy: "Копировать",
  create: "Создать",
  dismiss: "Отклонить",
  done: "Выполнено",
  download: "Скачать",
  hiddenwallet: "Создать скрытый кошелек",
  next: "Следующее",
  ok: "Хорошо",
  previous: "Предыдущее",
  receive: "Получить",
  restore: "Восстановить",
  select: "Выбрать",
  send: "Перевести",
  unlock: "Разблокировать",
  update: "Обновить",
  upgrade: "Обновить"
}, buy$8 = {
  info: {
    continue: "Подтвердить и продолжить",
    crypto: "Криптовалюта",
    disclaimer: {
      intro: [
        "Мы сотрудничаем с MoonPay, чтобы предложить удобный способ покупки {{name}} в приложении BitBoxApp. Всего в несколько кликов",
        "MoonPay - это платформа, позволяющая легко и быстро совершать покупки {{name}} в более чем 160+ странах"
      ],
      payment: {
        details: "Вы можете мгновенно купить {{name}} через MoonPay различными способами оплаты. Переводы по кредитной или дебетовой карте выполняются мгновенно и это удобно, но стоят дороже из-за повышенного риска возврата средств. Для более крупных сумм, мы рекомендуем использовать вариант банковского перевода. Минимальная плата составляет 4 USD/EUR или эквивалент",
        footnote: "Обратите внимание, что обменные курсы MoonPay могут отличаться от курсов, используемые в BitBoxApp, в результате суммы могут немного отличаться.",
        table: {
          "1_description": "Самая низкая комиссия, может занять до 3-х рабочих дней",
          "1_method": "Банковские переводы (SEPA)",
          "2_description": "Более высокая комиссия, но быстро и мгновенно",
          "2_method": "Кредитные и дебетовые карты",
          description: "Описание",
          fee: "Оплата",
          method: "способ"
        },
        title: "Способы оплаты и комиссии"
      },
      privacyPolicy: "Политика конфиденциальности MoonPay",
      protection: {
        description: "Приложение BitBoxApp не собирает никаких данных при покупке {{name}}, входящие средства обрабатываются как обычная транзакция. MoonPay необходимо собирать некоторые персональные данные для работы. Их политика конфиденциальности подробно объясняет, как обрабатываются предоставляемые данные",
        title: "Защита данных"
      },
      security: {
        description: "Покупая {{name}} через MoonPay, вы используете внешний сервис. Этот сервис выходит за рамки модели угроз безопасности BitBox02 и зависит от безопасности среды, в которой работает программное обеспечение BitBoxApp",
        link: "Модель угроз безопасности",
        title: "Модель безопасности"
      },
      title: "Добро пожаловать в ваш универсальный магазин для покупки {{name}}"
    },
    next: "Далее",
    selectLabel: "Выберите аккаунт",
    selectPlaceholder: "Выберите монету",
    skip: "Не показывать снова",
    title: "Купить {{name}}"
  },
  title: "Купить {{name}}"
}, changePin$c = {
  newTitle: "Новый пароль устройства",
  oldLabel: "Текущий пароль устройства"
}, chart$8 = {
  dataMissing: "Мы все еще собираем информацию. Пожалуйста, подождите.",
  dataUpdating: "обновление данных…",
  filter: {
    all: "Все",
    month: "Месяц",
    week: "Неделя",
    year: "Год"
  }
}, checkSDcard$c = "Проверка карты памяти microSD", clickHere$c = "Нажмите здесь.", confirm$e = {
  abortInfo: "Нажмите, чтобы",
  abortInfoRedText: " прервать",
  approveInfo: "Удерживайте 4 секунды, чтобы",
  approveInfoGreenText: " подтвердить",
  info: "Продолжайте на Вашем устройстве BitBox. ",
  infoWhenPaired: "Сначала на присоединённом мобильном устройстве, а затем на BitBox"
}, confirmOnDevice$c = "Пожалуйста, подтвердите на вашем устройстве.", device$c = {
  appUpradeRequired: "Ваш BitBox несовместим с этой версией приложения. Загрузите и установите последнюю версию."
}, deviceLock$c = {
  button: "Включить двухфакторную авторизацию (2FA)",
  condition1: "У Вас есть резервная копия?",
  condition2: "Работает ли проверка мобильного приложения?",
  condition3: "Двухфакторная авторизация ЗАПРЕЩАЕТ резервное копирование и подключение мобильных приложений. Устройство должно быть СБРОШЕНО для выхода из режима двухфакторной авторизации (2FA)!",
  confirm: "Включить 2FA",
  title: "Включить двухфакторною авторизацию (2FA)"
}, deviceSettings$c = {
  firmware: {
    newVersion: {
      label: "Доступная версия"
    },
    title: "Прошивка",
    upToDate: "Ваше устройство использует самую актуальную версию",
    version: {
      label: "Версия"
    }
  },
  hardware: {
    sdcard: {
      false: "Не вставленна",
      label: "Карта Micro SD",
      true: "Вставленный"
    },
    securechip: "Защищенный чип",
    title: "Техническое обеспечение"
  },
  loading: "Получение информации об устройстве ...",
  pairing: {
    lock: {
      false: "Отключено",
      label: "Двухфакторная авторизации (2FA)",
      true: "Включено"
    },
    mobile: {
      false: "Закрыто",
      label: "Мобильное приложение",
      true: "Открыто"
    },
    status: {
      false: "Не соединено",
      label: "Статус",
      true: "Соединено"
    },
    title: "Соединение"
  },
  secrets: {
    manageBackups: "Управление резервными копиями",
    title: "Полезные функции"
  }
}, deviceTampered$c = "У Вашего BitBox был создан пароль восстановления? Если это так, немедленно прекратите процесс установки и обратитесь в службу поддержки. Shift никогда не даст Вам готовый кошелек и не будет давать рекомендации по паролю.", dialog$d = {
  cancel: "Отменить",
  confirm: "Подтвердить",
  confirmTitle: "Подтверждение"
}, error$8 = {
  accountAlreadyExists: "Аккаунт уже существует",
  accountLimitReached: "Невозможно добавить счет. Достигнуто максимальное количество счетов для этой монеты",
  aoppCallback: "Произошла ошибка при добавлении адреса на {{host}}",
  aoppInvalidRequest: "Неверный запрос",
  aoppNoAccounts: "Нет доступных аккаунтов",
  aoppSigningAborted: "Запрос адресом на подключение отменен",
  aoppUnknown: "Произошла неизвестная ошибка",
  aoppUnsupportedAsset: "Актив не поддерживается",
  aoppUnsupportedFormat: "Нет доступных счетов, поддерживающих запрошенный формат адреса.",
  aoppUnsupportedKeystore: "Подключенное устройство не может подписывать сообщения для этого актива",
  aoppVersion: "Неизвестная версия"
}, fiat$e = {
  default: "Стандарт",
  setDefault: "Настроить {{code}} ",
  title: "Валюты"
}, footer$e = {
  appVersion: "Версия приложения:"
}, generic$8 = {
  enabled_false: "Отключено",
  enabled_true: "Включено"
}, genericError$c = "Произошла ошибка. Если вы заметили какие-либо проблемы, перезапустите приложение.", goal$c = {
  buttons: {
    create: "Создать новый кошелек",
    restore: "Восстановить кошелек "
  },
  paragraph: "Выберите одну из следующих опций:",
  step: {
    1: {
      title: "Информация о безопасности"
    },
    2: {
      description: "Установка пароля устройства",
      title: "Устройство"
    },
    "3-create": {
      description: "Создать новый кошелек",
      title: "Кошелек"
    },
    "3-restore": {
      description: "из резервной копии",
      title: "Восстановить"
    },
    "4-create": {
      title: "Сводка"
    },
    "4-restore": {
      title: "Сводка"
    }
  }
}, guide$d = {
  accountDescription: {
    text: "Это обзор вашей учетной записи. Он показывает входящие и исходящие транзакции. Баланс отображается для каждой учетной записи отдельно. Прочитайте инструкцию, чтобы узнать больше о разных типах учетных записей.",
    title: "Что здесь отображается?"
  },
  accountFiat: {
    text: "Да, Вы можете нажать на любую кнопку, чтобы выбрать валюту. Вы также можете изменить список валют в настройках.",
    title: "Можно ли отображать другие курсы обмены валюты?"
  },
  accountIncomingBalance: {
    text: "Входящие, это общая сумма средств, которые были переведены Вам, но еще не подтверждены сетью.",
    title: "Что обозначает входящее?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Каждый xpub ключ привязан к конкретному "Формату": "Native Segwit (bech32)", "Wrapped Segwit" or “Taproot” (Только для Bitcoin). Это форматы адресов, используемые {{coinName}}. Приложение BitBoxApp объединяет их, поддерживая несколько форматов адресов в одном аккаунте. Поскольку каждый формат адреса предоставляет разные xpub ключи, для каждого аккаунта существует несколько xpub ключей.

Если вы получаете монеты по умолчанию, на формат адреса (Native Segwit), для этого нужен только xpub ключ "bech32". Однако, если вы получаете средства на "Wrapped Segwit" или “Taproot” адреса, то необходимо использовать расширенные открытые ключи от "Wrapped Segwit" и “Taproot” соответственно`,
      title: "Почему существует несколько xpub ключей?"
    },
    privacy: {
      text: `Для текущего аккаунта расширенный открытый ключ (xpub) раскрывает всю финансовую историю, баланс вашего счета и все будущие транзакции. Данный xpub ключ никому не позволяет тратить ваши монеты.

Если Вы предоставляете кому-либо xpub ключ, вы соглашаетесь с тем, что лицо или компания могут видеть все другие транзакции текущего аккаунта. Поэтому рекомендуется при передаче данного xpub ключа все иные средства хранить на других счетах или аккаунтах.`,
      title: "Нужно ли хранить свой xpub ключ в секрете?"
    },
    verify: {
      text: "Да, будет полезно перепроверить свой xpub ключ. Если кто-то другой будет генерировать новые адреса из xpub ключа, для отправки вам активов, это будет особенно важно. Вам необходимо будет подтвердить это на устройстве, чтобы убедиться, что этот xpub ключ принадлежит вам. В противном случае все средства могут отправиться не по тем адресам!",
      title: "Нужно ли мне проверять xpub ключ на устройстве?"
    },
    xpub: {
      text: `Расширенный открытый ключ (xpub) - это корневой ключ, из которого выводятся все адреса получения в аккаунте.

Он предоставляется здесь для расширенного использования и взаимодействия с кошельками, предназначенными только для просмотра, такими как Electrum или Sentinel. Если вы получили ключи от разных типов адресов, пожалуйста, импортируйте все различные форматы xpub в кошелек, доступный только для просмотра, чтобы увидеть все ваши монеты.

Обратите внимание, что сторонние кошельки могут еще не поддерживать Taproot xpubs ключи`,
      title: "Что такое расширенный открытый ключ?"
    }
  },
  accountRates: {
    text: "Курсы валют обновляются каждую минуту с помощью CoinGecko.",
    title: "Какие курсы используются?"
  },
  accountReload: {
    text: "Вся информация о транзакции обновляется автоматически.",
    title: "Как я могу перезагрузить историю транзакций?"
  },
  accountSendDisabled: {
    text: "Кнопка «Отправить» активируется, когда ваш баланс больше нуля.",
    title: "Почему я не могу отправить {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Общая сумма всех ваших криптовалютных счетов. Курсы обмена можно узнать на сайте coingecko.com.

Примечание. Токены используемые с помощью MyEtherWallet которые не поддерживаются в BitBoxApp исключены из общей суммы.`,
    title: "Как вычисляется общая сумма?"
  },
  accountSummaryDescription: {
    text: "Здесь вы можете увидеть динамику вашего портфолио. Сводная информация по вашим индивидуальным учетным записям отображается под графиком.",
    title: "Что изображается на этой странице?"
  },
  accountTransactionAttributesBTC: {
    text: `Виртуальный размер: используется для определения стоимости отправки транзакции. Вы успешно сэкономили, если этот размер меньше размера транзакции.
Размер: фактический размер транзакции в байтах при сериализации в соответствии с протоколом блокчейна.
Вес: Введенный в Segwit, это новый показатель для оценки размеров транзакций и блоков. Каждый отдельный байт Segwit считается как один, а все остальные - четырьмя единицами веса. Вместо одного мегабайта, размер блока теперь составляет четыре миллиона единиц веса.`,
    title: "Сведения о транзакции, связанные с биткойнами"
  },
  accountTransactionAttributesGeneric: {
    text: `Подтверждения: Изначально, при трансляции Вашей транзакции, она будет неподтвержденной. Вам нужно будет дождаться, когда она будет включена в блок каким-либо майнером, после чего у Вас будет одно подтверждение. Затем каждый блок, передаваемый по сети, добавит еще одно подтверждение к Вашей транзакции. Обычно торговцы принимают транзакции только с 3-6 подтверждениями.
Идентификатор транзакции: уникальный идентификационный номер, который можно использовать для поиска транзакции.
Комиссионный сбор: майнерам выплачивается комиссия за транзакцию в качестве стимула для включения транзакций в блоки, которые они создают. Чтобы узнать больше, нажмите кнопку «Перевести».`,
    title: "Какова информация, указанная в деталях транзакции?"
  },
  accountTransactionConfirmation: {
    text: "Это транзакция была передана в сеть но еще не получила подтверждения.",
    title: "Что такое ожидающая транзакция?"
  },
  accountTransactionLabel: {
    text: "Это адрес, с которого вы получали или отправляли монеты.",
    title: "Какой адрес отображается для каждой транзакции?"
  },
  accountTransactionTime: {
    text: "Время, когда транзакция была подтверждена в блокчейне.",
    title: "Какое время отображается?"
  },
  accounts: {
    howManyAccounts: {
      text: "Каждая монета может иметь максимум пять счетов",
      title: "Сколько счетов я могу создать?"
    },
    howtoAddTokens: {
      text: 'Токены, использующие стандарт ERC20, привязаны к счету Ethereum. Чтобы включить или отключить определенный токен, откройте экран "Управление счетами", разверните свою учетную запись Ethereum и включите или выключите нужный токен.',
      title: "Как мне добавить дополнительные токены?"
    },
    moveFunds: {
      text: "Да. Но так как счета независимы, вам необходимо отправлять свои средства с помощью обычной транзакции.",
      title: "Могу ли я переводить средства между счетами?"
    },
    recoverAccounts: {
      text: "Да. BitBoxApp создает аккаунт, используя устоявшиеся стандарты, совместимые с большинством других крипто-кошельков.",
      title: "Могу ли я восстановить свои аккаунт с помощью других кошельков?"
    },
    whatAreAccounts: {
      text: "Кошелек может управлять несколькими счетами одной монеты. Несколько счетов полезны, когда вы хотите хранить средства раздельно",
      title: "Что такое аккаунт?"
    },
    whyIsThisUseful: {
      text: 'В аккаунте сами счета отлично подходят для управления активами разными людьми или создания целей, так как они разделены. Вы также можете поделиться "расширенным открытым ключом (xpub)" выбранной конкретной монеты, не раскрывая ничего о других ваших монетах. Это позволит вам получать активы без повторного создания адресов. Например, у доверенных людей получать заработную плату или регулярно покупать криптовалюту',
      title: "Почему это полезно?"
    }
  },
  appendix: {
    link: "Свяжитесь с нами!",
    text: "Другой вопрос?"
  },
  backups: {
    check: {
      text: "«Проверить резервную копию» позволяет подтвердить, что у Вас есть рабочая резервная копия, соответствующая Вашему текущему кошельку. Её также можно использовать для проверки пароля восстановления.",
      title: "Что такое «Проверить резервную копию»?"
    },
    encrypt: {
      text: "Нет, но ваш пароль восстановления необходим для получения кошелька.",
      title: "Могу ли я зашифровать резервную копию?"
    },
    howOften: {
      text: `Резервная копия создается автоматически при создании нового кошелька. Вам нужно создать новую резервную копию только если ваша карта micro SD потеряна или повреждена, или если вы хотите использовать несколько микро SD-карт в качестве резервных копий.
Вам не нужно создавать новые резервные копии после транзакций. Все ваши данные транзакций могут быть воссозданы с помощью одной резервной копии, которая была автоматически создана.`,
      title: "Как часто мне стоит делать резервную копию?"
    },
    whatIsABackup: {
      text: "Это копия сид на карте micro SD. Сид вместе с вашим паролем восстановления образует ваш кошелек.",
      title: "Что такое резервная копия?"
    }
  },
  backupsBB02: {
    check: {
      text: "«Проверка резервной копии» позволяет проверить, есть ли у вас рабочая резервная копия, соответствующая вашему текущему кошельку.",
      title: "Что такое «Проверка резервной копии»?"
    },
    encrypt: {
      text: "Нет. Храните карту microSD в надежном месте, поскольку она содержит незашифрованные исходные данные для восстановления вашего кошелька. Если вы хотите защитить свой сид паролем, вы можете включить факультативную фразу в экспертных настройках в разделе «Управление устройством».",
      title: "Могу ли я зашифровать резервную копию?"
    },
    whatIsABackup: {
      text: "Это копия сида на карте micro SD.",
      title: "Что такое резервная копия?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Когда функция 2FA включена, все транзакции должны быть одобрены на подключённом мобильном телефоне, для того, чтобы тратить монеты. Одноразовый зашифрованный номер отправляется в мобильное приложение, дешифруется там и возвращается в BitBox при нажатии кнопки «Подтвердить». Эта связь с устройством осуществляется через канал между мобильным телефоном и настольным приложением, установленным во время подключения.

Обязательно создайте резервную копию своего кошелька и соедините мобильное приложение, прежде чем включить функцию 2FA. После включения, слот micro SD и подключение мобильного приложения отключены. Их можно повторно включить, сбросив BitBox, который стирает устройство.`,
      title: "Как работает двухфакторная авторизация (2FA)?"
    },
    disable2FA: {
      text: "Чтобы отключить 2FA, вам необходимо сбросить BitBox, а затем восстановить кошелек из его резервной копии. Убедитесь, что у вас все еще есть карта microSD с резервной копией и вы все еще помните пароль восстановления. Затем нажмите «Сбросить устройство». Установите новый пароль устройства и выберите «Или восстановить резервную копию». Выберите резервную копию, которую вы сделали из кошелька, нажмите «Восстановить» и введите пароль восстановления, который вы использовали при создании кошелька.",
      title: "Как отключить двухфакторную авторизацию (2FA)?"
    },
    ejectBitbox: {
      text: "Вы можете отсоединить BitBox в любое время.",
      title: "Как я могу извлечь BitBox?"
    },
    ejectSD: {
      text: "Вы можете удалить карту microSD из BitBox в любое время, если вы не находитесь в процессе создания или восстановления резервной копии.",
      title: "Как я могу извлечь карту microSD?"
    },
    hiddenWallet: {
      text: "Это второй кошелек на том же устройстве, который защищен паролем другого устройства и паролем восстановления, который Вы можете использовать для правдоподобия. Такая же резервное семя используется как для Вашего обычного, так и скрытого кошелька, поэтому дополнительная резервная копия не требуется.",
      title: "Что такое скрытый кошелек?"
    },
    legacyHiddenWallet: {
      text: "Сначала нажмите кнопку ниже (доступно, если BitBox разблокирован с помощью пароля основного устройства, и двухфакторная авторизация 2FA отключена), затем переподключите Ваш Bitbox и разблокируйте его с помощью пароля скрытого устройства.",
      title: "Как получить доступ к унаследованному скрытому кошельку?"
    },
    pairing: {
      text: "После загрузки нашего мобильного приложения для iOS или Android сканируйте отображаемый QR-код, который устанавливает безопасный канал между мобильным приложением и этим приложением. После сканирования следуйте инструкциям в мобильном приложении.",
      title: "Как безопасно соединить с телефоном"
    }
  },
  cointracking: {
    text: 'Нажмите кнопку "Экспорт" и откройте папку загрузок, где вы найдете файл в формате CSV. Затем нажмите на ссылку ниже, загрузите свой CSV-файл BitBox и импортируйте данные, чтобы использовать их для управления портфелем (отслеживанием монет) и для создания налоговых отчетов',
    title: "Как импортировать мои транзакции из раздела с отслеживанием монет?"
  },
  receive: {
    address: {
      text: "Вы можете дать адрес другим, чтобы они отправили вам монеты. Просто убедитесь, что вы отправляете на правильный адрес.",
      title: "Что мне делать с адресом?"
    },
    addressChange: {
      text: "Как только адрес используется в транзакции, новый адрес добавляется в список для его замены. В списке всегда будет 20 неиспользуемых адресов.",
      title: "Когда меняются адреса?"
    },
    addressFormats: {
      text: "По умолчанию формат адреса - Native Segwit. Этот тип адреса широко используется другими кошельками / биржами и предлагает вам лучшие комиссионные за повседневные транзакции. Однако вы также можете выбрать отправку на Taproot (только для Биткойна (Btc)), который является самым новым типом адреса, но, возможно, еще не получил широкой поддержки на разных площадках. Если у вас возникли проблемы с отправкой на Native Segwit (тип по умолчанию), вы можете попробовать переключиться на более старый тип адреса Wrapped Segwit, который может быть совместим с разными кошельками / биржами",
      title: "Когда я должен использовать “Изменить тип адреса”?"
    },
    howVerify: {
      text: `Если у Вас BitBox01, щелкните значок BitBox на боковой панели слева и перейдите в раздел «Соединение». Руководство обновится, и вы сможете продолжить выполнение инструкций.
Если у Вас BitBox02, вы можете проверять адреса непосредственно на устройстве в процессе отправки и получения.`,
      title: "Как я могу безопасно проверить адрес?"
    },
    plugout: {
      text: "Нет, после того, как вы отправили монеты на свой адрес BitBox, вам не нужно оставлять свой BitBox подключенным. Вы можете отключить свой BitBox",
      title: "Нужно ли мне оставлять BitBox подключенным во время получения активов?"
    },
    why20: {
      text: "Во время запуска приложение генерирует адреса, полученные из вашего сида, чтобы вычислить, были ли отправленны на них средства. Поскольку приложение может генерировать почти бесконечное количество адресов, на определение баланса можно потратить годы. Чтобы ограничить этот поиск, он останавливается после 20 адресов на которые никогда не были отправленны средства. Это «предел разрыва» с 20 адресами является стандартом де-факто, хотя число было выбрано произвольно.",
      title: "Почему всего 20 адресов?"
    },
    whyMany: {
      text: "Для обеспечения конфиденциальности и безопасности никогда не давайте один и тот же адрес дважды. Если вы использовали адрес, щелкните стрелку вправо для перехода к новому адресу. Вы можете создать до 20 адресов одновременно. Думайте об адресах как о номерах счетов. Все адреса получены из вашего единственного сида.",
      title: "Почему так много адресов?"
    },
    whyVerify: {
      text: "Вы не должны доверять своему компьютеру во время создания и отображение подлинных адресов. Компьютер намного более уязвимый чем аппаратный кошелек. Если у вас BitBox01, кнопка подтверждения адреса безопасно отправляет адрес на соединенный мобильный телефон, с которого вы также можете сканировать и проверять QR-код. Если у вас BitBox02, адрес можно проверить непосредственно на дисплее BitBox02.",
      title: "Зачем мне безопасно проверять адрес?"
    }
  },
  send: {
    change: {
      text: "Сдача будет возвращена на адрес формата Taproot, если у вас есть хотя бы один UTXO (Выход неизрасходованных транзакций) формата Taproot. Другими словами, если вы контролируете монеты, сдача будет возвращена на адрес Taproot, если среди выбранных UTXOs есть хотя бы один Taproot UTXO. Во всех остальных случаях сдача возвращается на адрес формата Native Segwit",
      title: "Как определяется выход сдачи?"
    },
    fee: {
      text: `Плата основана на размере данных транзакции, а не на её сумме. Платы рассчитываются по алгоритму оценки платы Bitcoin Core для каждого сетевого приоритета.
Экономический: 24 блока (около 4 часов для биткойнов, 1 час для Litecoin)
Низкий: 12 блоков (около 2 часов для биткойнов, 30 минут для Litecoin)
Нормальный: 6 блоков (около 1 часа для биткойнов, 15 минут для Litecoin)
Высокий: 2 блока (около 20 минут для биткойнов, 5 минут для Litecoin)
(Блок берет в среднем десять минут для биткойнов (2,5 минуты для Litecoin) для обработки но сетевая нагрузка может значительно различаться в вышеуказанные периоды.)`,
      title: "Как определяется комиссионная плата?"
    },
    plugout: {
      text: "Нет, после того, как вы совершили транзакцию, вам не нужно оставлять свой BitBox подключенным. Вы можете отключить свой BitBox",
      title: "Нужно ли мне оставлять свой BitBox подключенным во время отправки активов?"
    },
    priority: {
      text: "Чем выше плата, которую вы готовы заплатить, тем быстрее ваша транзакция обычно подтверждается сетью.",
      title: "Что такое сетевой приоритет?"
    },
    revert: {
      text: `Как только транзакция будет подписана и отправлена ​​(это значит транслирована в сеть), она больше не может быть отменена. Перед началом подписания проверьте транзакции (включая плату)!
Если Вы знаете, что получатель желает отправить ту же сумму к вам обратно, Вы можете отправить им новый адрес получателя.`,
      title: "Можно ли вернуть транзакцию?"
    },
    whyFee: {
      text: `Сделки конкурируют, чтобы быть подверженными шахтером. Шахтеры выбирают транзакции, которые должны быть включены в blockchain, исходя из их стоимости.
Шахтеры голосуют на опоре историй транзакций. Поскольку нет доверенной третьей стороны для обеспечения одного голоса на одного человека (что является целым звеном цепочки блоков), шахтеры голосуют за транзакции, жертвуя дорогостоящим ресурсом, таким как вычислительная мощность. В качестве награды за свою работу они могут требовать вновь созданные монеты и плату за все транзакции, которые они причастны.`,
      title: "Почему существует сетевая плата?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Если вы намереваетесь подключаться к своему узлу только тогда, когда находитесь в той же сети (например, к домашнему Wi-Fi), тогда достаточно обычного сетевого взаимодействия.
В этом случае рекомендуется, чтобы ваш сервер Electrum предоставил сертификат TLS для шифрования связи.
Если вы собираетесь подключиться к своему узлу из любого места, лучше использовать Tor. В этом случае сертификат TLS не требуется.`,
      title: "Что мне следует использовать, TCP, TLS или Tor?"
    },
    instructions: {
      link: {
        text: "Руководство по подключению собственного узла"
      },
      text: "Посетите наше полное руководство",
      title: "Как подключить BitBoxApp к собственному крипто узлу (серверу)?"
    },
    options: {
      text: `Есть несколько вариантов запуска собственного узла, таких как покупка готового устройства, создание собственного либо Bitcoin Core.
Если вы хотите подключить BitBoxApp к своему узлу, убедитесь, что он запускает сервер Electrum. Это специальная программа, которая позволяет приложению взаимодействовать с вашим узлом.
Поддерживаемые варианты включают Electrs, персональный сервер Electrum (EPS) или Bitcoin Wallet Tracker (BTW).`,
      title: "Какие есть варианты запуска собственного узла?"
    },
    tor: {
      text: `Tor означает «луковый маршрутизатор». Это бесплатное программное обеспечение с открытым исходным кодом, которое предлагает множество преимуществ в отношении конфиденциальности и особенно полезно при использовании биткойнов.
Если вы собираетесь подключиться к своему узлу через Tor, убедитесь, что Tor установлен на вашем компьютере, а затем включите Tor Proxy в настройках BitBoxApp.
В большинстве операционных систем есть два способа запустить Tor:
1. Tor Browser: загрузите и откройте Tor Browser. Это позволит BitBoxApp подключиться к сети Tor, установив порт 9150 в настройках прокси-сервера Tor.
2. Фоновая служба Tor: установите демон Tor, который всегда работает в фоновом режиме. Затем BitBoxApp сможет подключиться, установив порт 9050 в настройках прокси-сервера Tor.`,
      title: "Что такое Tor, прокси-сервер Tor и какой порт мне следует использовать?"
    },
    what: {
      text: "Возможно использовать свой кошелек с вашими собственными полными узлами вместо использования серверов Shift.",
      title: "Что это?"
    },
    why: {
      text: `Запуск собственного узла не является обязательным, но улучшает конфиденциальность и снижает необходимость доверять другим.
Во-первых, это означает, что вы используете биткойн более конфиденциально, поскольку BitBoxApp не будет подключаться к нашим серверам для получения сводки ваших транзакций; вместо этого приложение получит эту информацию из вашего собственного узла.
Во-вторых, запуск собственного узла означает, что ваш узел сам проверяет все транзакции, следя за соблюдением правил консенсуса.`,
      title: "Зачем мне запускать собственный узел?"
    }
  },
  settings: {
    servers: {
      text: `Это приложение взаимодействует с серверами Shift Crypto для проверки обновлений, загрузки транзакций и отправки информации к соединенным мобильным приложениям.
Кроме того, оно извлекает последнии курсы обмена от CoinGecko. (Конверсии вычисляются локально, никакие суммы не передаются.)`,
      title: "На каких серверах работает это приложение?"
    }
  },
  title: "Руководство",
  toggle: {
    close: "Закрыть руководство",
    open: "Руководство"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Вам необходимо сбросить устройство и восстановить кошелек из резервной копии, используя пароль восстановления.",
      title: "Что делать, если я забыл пароль устройства?"
    },
    reset: {
      text: "Введите неверный пароль устройства 15 раз. Последние несколько попыток требуют длительного касания устройства.",
      title: "Как сбросить устройство?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Устройство должно мигнуть один раз при присоединении. Убедитесь, что оно вставлено правильно. Если у вас возникли проблемы, пожалуйста, свяжитесь с нами по ссылке ниже.

BitBox01 не поддерживается на мобильных устройствах. Пожалуйста, используйте приложение BitBoxApp на рабочем столе для подключения вашего BitBox01`,
      title: "Мое устройство BitBox01 не распознается"
    },
    getDevice: {
      link: {
        text: "Заказать BitBox"
      },
      text: "Вы можете купить BitBox в нашем интернет-магазине:",
      title: "Как я могу получить устройство?"
    },
    internet: {
      text: "Да, для синхронизации кошелька, транзакций и получения последних обменных курсов, требуется интернет-соединение.",
      title: "Требуется ли для этого приложения подключение к Интернету?"
    },
    lostDevice: {
      link: {
        text: "Центр резервных копий"
      },
      text: "Вы можете восстановить свои учетные записи на новом BitBox или в нашем центре резервных копий.",
      title: "Я потерял свое устройство. Что теперь?"
    },
    useWithoutDevice: {
      text: "К сожалению, пока это невозможно.",
      title: "Могу ли я использовать приложение без устройства?"
    },
    welcome: {
      text: "Спасибо за использование этого приложения, созданного Shift Crypto в Швейцарии. Он по-прежнему находится в стадии бета-тестирования, и мы ценим любой вклад, которым Вы можете поделиться. Пожалуйста, оцените приложение, используя ссылку внизу.",
      title: "Добро пожаловать в приложение BitBoxApp!"
    }
  }
}, headerssync$c = {
  blocksSynced: "{{blocks}} блоков синхронизированы"
}, hiddenWallet$c = {
  info1HTML: "Для правдоподобных целей неприкосновенности скрытый кошелек может быть создан на основе комбинации <strong> разных </strong> паролей для восстановления пароля устройства.",
  info2HTML: "Определите пароль устройства и пароль восстановления, которые Вы хотите связать с Вашим скрытым кошельком. Пароль устройства и пароль восстановления должны <strong> отличатся </strong> от тех, которые Вы используете для своего основного кошелька.",
  passwordLabel: "Скрытый пароль восстановления",
  passwordPlaceholder: "Подтвердите скрытый пароль восстановления",
  pinLabel: "Скрытый пароль устройства",
  pinRepeatLabel: "Повторить скрытый пароль устройства",
  pinRepeatPlaceholder: "Подтвердите пароль скрытого устройства",
  success: "Скрытый кошелек создан успешно. Переподключите BitBox, чтобы разблокировать его."
}, initialize$c = {
  create: "Установить пароля устройства",
  creating: "Установка пароля устройства ...",
  error: {
    e102: "Пароль устройства должен содержать не менее 4 символов."
  },
  info: {
    description1: "Выберите пароль устройства. Он будет использоваться для разблокировки вашего BitBox.",
    description2: "Вы можете использовать числа и буквы. Длинные пароли гарантируют больше безопасности.",
    description3: "Если Вы потеряете пароль устройства, вам придётся сбросить  Ваше устройство и восстановить резервную копию Вашего кошелька.",
    subtitle: "Теперь Вы установите пароль своего устройства",
    title: "Инициализация устройства"
  },
  input: {
    label: "Пароль устройства",
    labelRepeat: "Повторить пароль устройства",
    placeholderRepeat: "Подтвердить пароль устройства"
  }
}, invalidFormat$c = "Недопустимый формат", language$d = {
  title: "Выбрать язык"
}, legacyhiddenwallet$c = {
  disable: "Отключить скрытый кошелек устаревшего типа",
  enable: "Включить скрытый кошелек устаревшего типа",
  successDisable: "Успешно отключился скрытый кошелек.",
  successEnable: "Успешно включился скрытый кошелек. Переподключите свой BitBox и введите пароль скрытого устройства, чтобы получить доступ к скрытому кошельку."
}, loading$c = "загрузка ...", manageAccounts$6 = {
  editAccount: "Изменить",
  editAccountNameTitle: "Изменить имя аккаунта",
  noAccounts: " Аккаунты не найдены",
  settings: {
    hideTokens: "Скрыть токены",
    showTokens: "Показать токены ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Добавить и отобразить/скрыть аккаунты",
  title: "Управление аккаунтами"
}, mobile$7 = {
  usingMobileDataWarning: "Использование мобильных данных: это приложение может загружать до нескольких сотен мегабайт данных из блокчейна после разблокировки учетной записи. Пожалуйста, подключитесь к Wi-Fi, чтобы не использовать мобильные данные. После закрытия этого сообщения, оно больше не будет отображаться."
}, note$8 = {
  input: {
    description: "(факультативно)",
    placeholder: "Добавить примечание ..."
  },
  title: "Примечание"
}, notification$c = {
  newTxs_one: "Новая транзакция в: {{accountName}}",
  newTxs_other: "{{count}} новых транзакций в: {{accountName}}"
}, pairing$c = {
  aborted: {
    text: "Присоединение с мобильным приложением было отменено.",
    title: "Ошибка"
  },
  button: "Присоединить мобильное приложение ",
  confirm: "Вы уверены, что хотите присоединить свой BitBox? Обратите внимание, что после этого для выполнения транзакции требуется мобильный телефон.",
  connectOnly: {
    button: "Подключить мобильное приложение",
    title: "Сканируйте с помощью нашего мобильного приложения, выбрав пункт меню «Подключиться к новому настольному приложению»,"
  },
  error: {
    text: "Произошла ошибка. Пожалуйста, начните заново.",
    title: "Ошибка"
  },
  pullFailed: {
    text: "Не удалось получить сообщение с мобильного телефона через ретрансляционный сервер. Возможно, сервер ретрансляции отключен, обратитесь в службу технической поддержки",
    title: "Ошибка извлечения"
  },
  reconnectOnly: {
    button: "Запустите заново мобильное приложение"
  },
  scanningFailed: {
    text: "Мобильный телефон не смог успешно отсканировать сообщение. Пожалуйста, попробуйте еще раз",
    title: "Ошибка сканирования"
  },
  start: {
    hideAppQRCode: "Скрыть QR код",
    revealAppQRCode: "Показать QR код",
    step1: "Если у вас нет мобильного приложения, вы можете отсканировать QR-код для Apple App Store или Google Play Store в зависимости от того, какое у вас устройство.",
    step2: "Сканируйте с помощью нашего мобильного приложения, которое вы можете найти под названием «Digital Bitbox 2FA» в магазинах приложений для iOS и Android:"
  },
  started: {
    text: "Теперь следуйте инструкциям в мобильном приложении.",
    title: "Отлично"
  },
  success: {
    text: "Поздравляем, Вы успешно соединили свой BitBox с мобильным приложением!",
    title: "Успех"
  },
  timeout: {
    text: "Время ожидания истекло спустя две минуты. Начните снова, если Вы все еще хотите соединить мобильное приложение.",
    title: "Тайм-аут"
  },
  title: "Мобильное сопряжение"
}, passphrase$6 = {
  considerations: {
    button: "Рекомендации по резервному копированию",
    message: `Кодовая фраза добавляет дополнительный уровень защиты к резервной копии вашего кошелька (карта microSD или seed фраза из 24 слов). Если у кого-то есть доступ к вашей резервной копии, ему также понадобится кодовая фраза для доступа к вашему кошельку.

Однако это означает, что вам понадобится <strong>как кодовая фраза, так и резервная копия кошелька</strong> для восстановления кошелька с поддержкой кодовой фразы, в случае, если ваш BitBox02 потерян или сломан. Если вы забудете или потеряете свою кодовую фразу, вы потеряете доступ ко всем монетам на данном кошельке (аккаунте).

При хранении кодовой фразы подумайте о том, чтобы поместить ее в отдельное место, отличное от резервной копии. Таким образом, если кто-то найдет вашу резервную копию, он не найдет вашу кодовую фразу!`,
    title: "Рекомендации по резервному копированию"
  },
  disable: "Отключение кодовой фразы",
  disableInfo: {
    button: "Отключить",
    message: `После отключения кодовой фразы вам больше не будет предложено ввести кодовую фразу после разблокировки BitBox02. Вы увидите свой кошелек по умолчанию.

Любые монеты на вашем кошельке с кодовой фразой по-прежнему будут находиться на этом кошельке, но вы не сможете получить к ним доступ, потому что после разблокировки вашего BitBox02 откроется кошелек по умолчанию.

Чтобы снова получить доступ к вашим кошелькам с кодовой фразой, просто повторно включите функцию кодовой фразы и введите соответствующую кодовую фразу после разблокировки BitBox02.

<strong>Совет:</strong> Вы можете попасть в свой кошелек по умолчанию, оставив пароль пустым`
  },
  enable: "Включить кодовую фразу",
  error: {
    e104: "Изменение настройки кодовой фразы было прервано"
  },
  how: {
    button: "Как это выглядит",
    message: `Кодовая фраза работает не так, как пароль, к которому вы привыкли. Если вы неправильно введете свою кодовую фразу, то не получите уведомление. Это происходит потому, что <strong>каждая кодовая фраза создает другой, но действительный кошелек</strong>. Вы можете использовать несколько кодовых фраз для любого количества кошельков, сколько захотите. Доступ к каждому кошельку возможен только при вводе соответствующей кодовой фразы.

При включении BitBox02 вам, как обычно, будет предложено ввести пароль устройства. После этого будет предложено ввести кодовую фразу на устройстве.

После ввода кодовой фразы вам будет показана введенная вами кодовая фраза. Это сделано для того, чтобы вы могли убедиться, что ввели её правильно`,
    title: "Как это работает"
  },
  intro: {
    message: `Кодовая фраза обеспечивает дополнительный уровень безопасности вашего кошелька.
Давайте узнаем, как это работает`,
    title: "Установить кодовую фразу"
  },
  progressDisable: {
    message: "Подтвердите в своем BitBox, что вы хотите <strong>отключить</strong> необязательную кодовую фразу",
    title: "Подтвердите на устройстве"
  },
  progressEnable: {
    message: "Подтвердите на своем BitBox, что вы хотите <strong>включить</strong> необязательную кодовую фразу",
    title: "Подтвердите на устройстве"
  },
  successDisabled: {
    message: `Необязательная кодовая фраза <strong>успешно включена</strong>!
С этого момента вас попросят её ввести`,
    messageEnd: "Пожалуйста, подключите BitBox02 сейчас",
    title: "Кодовая фраза включена"
  },
  successEnabled: {
    message: `Необязательная кодовая фраза <strong>успешно отключена</strong>!
Вас больше не будут просить ввести кодовую фразу`,
    messageEnd: "Пожалуйста, подключите ваш BitBox02 сейчас",
    tips: "Рекомендации",
    tipsList: [
      "Мы рекомендуем сначала отправить небольшую сумму на кошелек с кодовой фразой. Затем отключите и снова подключите BitBox02 и введите свой пароль и кодовую фразу. Если вы правильно ввели кодовую фразу, вы должны увидеть монеты в своем кошельке",
      "Если вы хотите ввести свой оригинальный кошелек без кодовой фразы, достаточно не вводить ничего, когда будет предложено ввести кодовую фразу, оставить пустую строку. Или вы можете отключить функцию кодовой фразы"
    ],
    title: "Кодовая фраза отключена"
  },
  summary: {
    button: "Включить кодовую фразу",
    title: "Сводка",
    understand: "Я понимаю, как работает кодовая фраза и связанные с ней риски",
    understandList: [
      "Кодовая фраза - это дополнительный уровень безопасности, помимо вашей резервной копии",
      "Ввод другой кодовой фразы всегда приведет к созданию нового кошелька",
      "Чтобы восстановить свой кошелек, вам понадобится <strong>как кодовая фраза, так и резервная копия</strong>",
      "Если вы забудете свою кодовую фразу, вы больше не сможете получить доступ к своим монетам"
    ]
  },
  what: {
    button: "Узнайте, как это работает",
    message: `Кошелек создается (выводится) из очень большого случайного числа, также известного как seed фраза (начальная фраза). Это начальная фраза создается при первой настройке BitBox02 и сохраняется с помощью карты microSD или 24 слов. Любой, у кого есть доступ к seed фразе, имеет полный контроль над средствами на этом кошельке.

Кодовое слово - это <strong>необязательный секрет</strong>, добавляемый к seed фразе. При использовании кодового слова создается новый кошелек на основе seed фразы + кодового слова (необязательного секрета). Каждое новое кодовое слово создает новый, другой кошелек. Кодовое слово может состоять из: букв, слов, специальных символов или даже быть пустым. На самом деле при создании начальной фразы по умолчанию стоит пустая кодовая фраза, т.е. seed фраза + пустое кодовое слово.

Кодовое слово является частью стандарта BIP39 - это означает, что она совместима со всеми кошельками, поддерживающими один и тот же стандарт`,
    title: "Что такое кодовое слово?"
  },
  why: {
    button: "Зачем использовать кодовое слово",
    message: `BitBox02 полностью защищает seed фразу от извлечения с самого устройства, но резервная копия (карта microSD или 24 слова) дают полный доступ к кошельку. Они должны храниться в надежном месте!

Так как кодовое слово создает новый кошелек, используя вашу существующую seed фразу, его также требуется хранить, <strong>как резервную копию для восстановления</strong>. Преимущество этого заключается в том, что если кто-то найдет вашу резервную копию (от seed фразы), ему все равно понадобится пароль для доступа к кошельку с кодовой фразой.

Кроме того, функция кодовой фразы позволяет создавать несколько кошельков на одном устройстве, как “скрытые кошельки” в дополнение к кошельку по умолчанию`,
    title: "Зачем использовать кодовое слово?"
  }
}, password$c = {
  show: "Показать {{label}}",
  warning: {
    caps: "ВНИМАНИЕ: «Caps Lock» (⇪) включен",
    paste: "Для того чтобы вставить текст, включите «ПОКАЗАТЬ {{label}}»"
  }
}, random$d = {
  button: "Сгенерировать случайное число",
  description: "Ваш BitBox сгенерировал следующее {{bits}}-битное случайное число:"
}, receive$e = {
  changeScriptType: "Изменить тип адреса",
  label: "Ваш адрес",
  onlyThisCoin: {
    description: "Чтобы получать другие токены, включите их в настройках. Если вы внесете другие токены, они могут быть недоступны.",
    warning: "Убедитесь, что получаете только {{coinName}} по этому адресу."
  },
  scriptType: {
    p2tr: "Taproot (новейший формат)",
    p2wpkh: "Native Segwit (по умолчанию)",
    "p2wpkh-p2sh": "Wrapped Segwit (совместимый формат)"
  },
  showFull: "Показать и проверить полный адрес на устройстве",
  taprootWarning: "Примечание: Taproot - это новая функция Биткойна, которая еще не получила широкого распространения. Средства, полученные на формат адреса Taproot, могут быть недоступны для просмотра в сторонних кошельках, предназначенных только для просмотра. Многие кошельки и биржи пока не могут отправлять на адреса Taproot",
  title: "Получить {{accountName}}",
  verify: "Безопасно проверить адрес",
  verifyBitBox01: "Подтвердите адрес в мобильном приложении",
  verifyBitBox02: "Проверить адрес на BitBox02",
  verifyInstruction: "Убедитесь, что этот адрес совпадает с тем который отображается на Вашем устройстве.",
  warning: {
    secureOutput: 'Пожалуйста, соедините ваш BitBox с мобильным устройством, чтобы включить безопасную проверку адреса. Перейдите в раздел "Управление устройством" на боковой панели'
  }
}, reset$c = {
  description: "Все данные на устройстве будут удалены. Это включает в себя Ваш закрытый ключ!",
  notReset: "Не удалось сбросить устройство.",
  title: "Сбросить устройство на заводскую прошивку",
  understand: "У меня есть резервная копия и я знаю пароль восстановления",
  understandBB02: "У меня есть действующая резервная копия"
}, securityInformation$c = {
  create: {
    description1: "Мы рекомендуем вам инициализировать устройство в безопасной среде, вдали от других людей которые могут видеть Ваш пароль.",
    description2: "Вам будет предложено создать два пароля.",
    description3: "Первый <strong>device password</strong>, это тот, который разблокирует Ваш BitBox и может быть изменен позже.",
    description4: "Второй  <strong>recovery password</strong> открывает Ваш кошелек. Этот пароль не может быть изменен позже.",
    description5: "Созданный кошелек будет скопирован в файл на прилагаемой карте micro SD. Её можно использовать в чрезвычайной ситуации, чтобы восстановить свои средства, используя <strong>пароль восстановления</strong>.",
    title: "Информация о безопасности"
  },
  restore: {
    description1: "Вам нужно будет вставить карту micro SD, которую вы использовали для хранения резервной копии",
    description2: "Для восстановления вашего устройства вам понадобится пароль восстановления.",
    description3: "Будьте внимательны при вводе пароля восстановления. Любой введенный Вами пароль создаст действительный кошелек. Если Вы введете неправильный пароль, вам может быть показан баланс кошелька, которого вы не ожидаете.",
    title: "Информация о безопасности"
  }
}, seed$c = {
  agreements: {
    "funds-access": "Я НЕ смогу получить доступ к своим средствам, если я забуду пароль восстановления",
    "password-change": "Я НЕ смогу изменить пароль восстановления позже.",
    "password-required": "Пароль восстановления необходим для восстановления кошелька из резервной копии"
  },
  create: "Создать кошелек",
  creating: "Создание кошелька",
  description: "Я подтверждаю:",
  error: {
    e102: "Пароль должен состоять не менее чем из 4 символов.",
    e200: "Вам необходимо вставить карту micro SD в свой BitBox, чтобы создать кошелек и создать автоматически резервную копию"
  },
  info: {
    button: "Установить пароль восстановления",
    description1: "Вставьте карту micro SD в BitBox",
    description2: "Выберите пароль восстановления для кошелька и нажмите «Установить пароль восстановления»",
    description3: "Резервная копия на карте micro SD и резервная копия из слов (seed фраза) - единственный способ восстановить ваши средства в случае потери или кражи BitBox.",
    description4: "Вы не можете изменить пароль для восстановления позже, не переводя свои средства.",
    title: "Создать новый кошелек"
  },
  password: {
    label: "Пароль восстановления",
    repeatPlaceholder: "Повторить пароль восстановления"
  },
  walletName: {
    label: "Название кошелька"
  }
}, seedRestore$c = {
  error: {
    e200: "Для восстановления кошелька из резервной копии требуется карта micro SD."
  },
  info: {
    description1: "Вставьте карту micro SD в BitBox и нажмите «Продолжить»,",
    description2: "Выберите резервную копию и нажмите «Восстановить»,",
    description3: "Введите пароль восстановления",
    description4: "Вам нужно подтвердить, что неверный пароль создаст другой кошелек.",
    title: "Как восстановить кошелек из резервной копии"
  }
}, send$e = {
  abort: "Транзакция была прервана.",
  address: {
    label: "Адрес получателя",
    placeholder: "Введите адрес"
  },
  amount: {
    label: "Сумма",
    placeholder: "Введите сумму"
  },
  availableBalance: "Доступные средства",
  button: "Проверка",
  coincontrol: {
    address: "Адрес",
    outpoint: "Outpoint",
    title: "Отправить с выхода"
  },
  confirm: {
    "selected-coins": "Выбранные монеты",
    title: "Подтвердить и отправить транзакцию",
    total: "Всего"
  },
  error: {
    feeTooLow: "комиссия слишком малая",
    feesNotAvailable: "Не удалось оценить комиссии",
    insufficientFunds: "недостаточно средств",
    invalidAddress: "неверный адрес",
    invalidAmount: "недопустимая сумма",
    invalidData: "неверные данные"
  },
  fee: {
    customPlaceholder: "Внести сумму",
    label: "Сетевая комиссия",
    placeholder: "Недоступно"
  },
  feeTarget: {
    customLabel: "Процент комиссии",
    customLabel_eth: "Цена gas (газа eth)",
    description: {
      economy: "4 часа (24 блока)",
      economy_eth: "30 минут или меньше",
      economy_ltc: "1 час (24 блока)",
      high: "20 минут (2 блока)",
      high_eth: "30 секунд или меньше",
      high_ltc: "5 минут (2 блока)",
      low: "2 часа (12 блоков)",
      low_eth: "5 минут или меньше",
      low_ltc: "30 минут (12 блоков)",
      normal: "1 час (6 блоков)",
      normal_eth: "2 минуты или меньше",
      normal_ltc: "15 минут (6 блоков)"
    },
    estimate: "Расчетное время подтверждения транзакции:",
    label: {
      custom: "Кастом",
      economy: "Эконом",
      high: "Быстро",
      low: "Медленно",
      normal: "Средне"
    },
    placeholder: "Расчет сетевой комиссии  ..."
  },
  maximum: "Отправить все",
  maximumSelectedCoins: "Отправить выбранные монеты",
  priority: "Приоритет",
  scanQR: "Сканировать QR код",
  signprogress: {
    description: "Это транзакция содержит много данных. Чтобы полностью подписать транзакцию, вы должны подтвердить {{steps}} разa.",
    label: "Прогресс"
  },
  success: "Транзакция была подписана и отправлена.",
  title: "Послать {{accountName}}",
  toggleCoinControl: "Переключить управление входами",
  transactionDetails: "Детали транзакции"
}, settings$d = {
  electrum: {
    add: "Добавить сервер",
    "add-server": "Добавить",
    check: "Проверка",
    checkFailed: "Не удалось",
    checkSuccess: "Успешно установлено соединение с {{host}}",
    checking: "Проверка",
    "download-cert": "Загрузить сертификат",
    "remove-server": "Удалить",
    removeConfirm: "Удалить {{server}}?",
    reset: "Восстановить на изначальные настройки",
    resetConfirm: "Вы хотите удалить все серверы и установить изначальные?",
    servers: "Серверы",
    step1: "1",
    "step1-text": "Введите эндпоинт.",
    step2: "2",
    "step2-text": "Введите сертификат цепочки сертификатов сервера. Либо, скачайте сертификат и сравните его визуально.",
    "step2-text-tcp": "Вы можете пропустить этот шаг, если не хотите использовать TLS.",
    step3: "3",
    "step3-text": "Проверьте подключение и добавьте сервер.",
    step4: "4",
    "step4-text": "Перезагрузите кошелек. Если Вы не удалите дефолтные серверы, Ваш собственный узел будет добавлен как избыточность.",
    "title-btc": "Серверы Bitcoin Electrum",
    "title-ltc": "Серверы Litecoin Electrum",
    "title-tbtc": "Серверы Bitcoin Testnet Electrum ",
    "title-tltc": "Серверы Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "Включить управление входами",
    electrum: {
      title: "Подключить свой собственный узел"
    },
    fee: "Включить индивидуальную сетевую комиссию",
    setProxyAddress: "Установить адрес прокси",
    title: "Экспертные настройки",
    useProxy: "Включить прокси-сервер тор"
  },
  header: {
    home: "Главная"
  },
  restart: "Перезапустите BitBoxApp, чтобы изменения вступили в силу.",
  services: {
    title: "Сервисы"
  },
  success: "Пожалуйста, отключите и подключите BitBox заново, чтобы изменения вступили в силу.",
  title: "Настройки"
}, setup$c = "Инициализировать устройство", sidebar$d = {
  buy: "Купить криптовалюту",
  device: "Управление устройством",
  leave: "Выйти",
  settings: "Настройки"
}, success$j = {
  create: {
    info1: "Резервная копия вашего кошелька была надежно сохранена на карту microSD. Выньте ее и сохраните в надежном месте.",
    info2: "Вы создали пароль защищающий устройство, который открывает доступ к BitBox.",
    info3: "Вы создали безопасный пароль для восстановления Вашего кошелька, который разблокировывает Ваши средства и восстанавливает Ваши резервные копии.",
    summary: "Вот краткое изложение того, что Вы сделали",
    title: "Успешно"
  },
  getstarted: "Начать",
  restore: {
    summary: "Вы успешно восстановили кошелек из резервной копии.",
    title: "Успешно"
  }
}, transaction$d = {
  confirmation: "Подтверждения",
  details: {
    activity: "Деятельность",
    address: "Адрес",
    amount: "Сумма",
    date: "Дата",
    fiat: "Фиат",
    fiatAmount: "Сумма фиата",
    status: "Статус",
    type: "Тип"
  },
  explorer: "Номер транзакции",
  explorerTitle: "Открыть во внешнем проводнике блоков",
  fee: "Плата",
  fiatHistorical: "Исторический",
  gas: "Газ",
  note: {
    edit: "Изменить заметку",
    save: "Сохранить заметку"
  },
  pending: "Неподтвержденная транзакция",
  size: "Размер",
  status: {
    complete: "Завершенная",
    failed: "Неудавшаяся",
    pending: "В ожидании"
  },
  tx: {
    received: "Получено",
    sent: "Отправлено"
  },
  vsize: "Виртуальный размер",
  weight: "Вес"
}, transactions$c = {
  placeholder: "Нет пока никаких транзакций."
}, unknownError$c = "Произошла неизвестная ошибка: {{errorMessage}}", unlock$c = {
  description: "Введите пароль своего устройства, чтобы разблокировать устройство.",
  error: {
    e109_normal: "Неверный пароль устройства. {{remainingAttempts}} попыток остаются до сброса данных устройства.",
    e109_touch: "$t(unlock.error.e109_normal) Следующий вход в систему требует удерживание сенсорной кнопки.",
    e113: "Из-за многих попыток входа в систему, для очередного входа в систему требуется удерживать сенсорную кнопку в течение 4 секунд."
  },
  input: {
    label: "Пароль устройства",
    placeholder: "Введите пароль своего устройства."
  },
  unlocking: "Разблокировка ..."
}, upgradeFirmware$d = {
  button: "Обновление прошивки",
  description: "Вы хотите обновить прошивку с {{currentVersion}} на {{newVersion}}?",
  label: "Для использования BitBox требуется обновление прошивки.",
  locked: "Чтобы обновить с {{currentVersion}} на {{newVersion}}, долго нажмите кнопку.",
  title: "Обновление прошивки",
  unlocked: "Загрузчик разблокирован. Чтобы продолжить, пожалуйста:",
  unlocked1: "Отсоедините и присоедините Ваш Bitbox заново",
  unlocked2: "Светодиод загорится, когда Ваш BitBox будет снова присоеденён",
  unlocked3: "Нажмите сенсорную кнопку, когда загорится светодиод"
}, warning$i = {
  receivePairing: "Пожалуйста, соедините BitBox, для безопасной проверки адреса. Перейдите в «Настройки Устройства» на боковой панели",
  sdcard: "Храните карту micro SD отдельно от BitBox, если только вы не хотите управлять резервными копиями",
  sendPairing: "Присоедините BitBox, для безопасного провeрки данных транзакции. Перейдите в «Настройки устройства» на боковой панели"
}, welcome$c = {
  getStarted: "Давайте начнем с установки прошивки на ваш BitBox02",
  insertBitBox02: "Для использования BitBox02, пожалуйста, коснитесь устройства.",
  insertDevice: "Присоедините Ваше устройство для начала работы",
  title: "Добро пожаловать"
}, appTranslationsRU = {
  account: account$c,
  accountInfo: accountInfo$c,
  accountSummary: accountSummary$c,
  addAccount: addAccount$d,
  aopp: aopp$6,
  app: app$c,
  backup: backup$c,
  bb02Bootloader: bb02Bootloader$c,
  bitbox: bitbox$c,
  bitbox02Interact: bitbox02Interact$c,
  bitbox02Settings: bitbox02Settings$c,
  bitbox02Wizard: bitbox02Wizard$c,
  blink: blink$c,
  bootloader: bootloader$c,
  button: button$g,
  buy: buy$8,
  changePin: changePin$c,
  chart: chart$8,
  checkSDcard: checkSDcard$c,
  clickHere: clickHere$c,
  confirm: confirm$e,
  confirmOnDevice: confirmOnDevice$c,
  device: device$c,
  deviceLock: deviceLock$c,
  deviceSettings: deviceSettings$c,
  deviceTampered: deviceTampered$c,
  dialog: dialog$d,
  error: error$8,
  fiat: fiat$e,
  footer: footer$e,
  generic: generic$8,
  genericError: genericError$c,
  goal: goal$c,
  guide: guide$d,
  headerssync: headerssync$c,
  hiddenWallet: hiddenWallet$c,
  initialize: initialize$c,
  invalidFormat: invalidFormat$c,
  language: language$d,
  legacyhiddenwallet: legacyhiddenwallet$c,
  loading: loading$c,
  manageAccounts: manageAccounts$6,
  mobile: mobile$7,
  note: note$8,
  notification: notification$c,
  pairing: pairing$c,
  passphrase: passphrase$6,
  password: password$c,
  random: random$d,
  receive: receive$e,
  reset: reset$c,
  securityInformation: securityInformation$c,
  seed: seed$c,
  seedRestore: seedRestore$c,
  send: send$e,
  settings: settings$d,
  setup: setup$c,
  sidebar: sidebar$d,
  success: success$j,
  transaction: transaction$d,
  transactions: transactions$c,
  unknownError: unknownError$c,
  unlock: unlock$c,
  upgradeFirmware: upgradeFirmware$d,
  warning: warning$i,
  welcome: welcome$c
}, account$b = {
  disconnect: "Sambungan hilang. Mencuba lagi...",
  export: "Eksport",
  exportTransactions: "Eksport transaksi ke folder muat turun sebagai fail CSV",
  fatalError: "Terdapat kesilapan yang tidak dijangka.",
  incoming: "Masuk",
  initializing: "Mendapatkan maklumat dari blockchain ...",
  maybeProxyError: "Proksi Tor diaktifkan. Pastikan proksi Tor anda berfungsi dengan baik atau matikan tetapan proksi.",
  reconnecting: "Sambungan hilang, mencuba menyambung kembali...",
  syncedAddressesCount: "{{count}} alamat telah diimbas"
}, accountInfo$b = {
  address: "Alamat",
  buyCTA: {
    buy: "Beli {{unit}}",
    buyCrypto: "Beli Kripto",
    information: {
      looksEmpty: "Nampaknya dompet ini kosong.",
      start: "Memulakan dengan mendepositkan beberapa syiling ke dalam dompet atau membeli terus di dalam aplikasi BitBoxApp."
    }
  },
  extendedPublicKey: "Public key lanjutan",
  label: "Maklumat akaun",
  scriptType: "Jenis skrip",
  title: "Maklumat Akaun",
  verify: "Sahkan pada peranti",
  xpubTypeChangeBtn: {
    p2pkh: "Lihat legacy P2PKH extended public key",
    p2tr: "Lihat Taproot",
    p2wpkh: "Lihat Segwit Asli",
    "p2wpkh-p2sh": "Lihat Segwit public key lanjutan yang lebih lama"
  },
  xpubTypeInfo: "Sedang memaparkan {{scriptType}} public key lanjutan ({{current}} daripada {{numberOfXPubs}})"
}, accountSummary$b = {
  availableBalance: "Baki yang ada",
  balance: "Baki",
  exportSummary: "Eksport Ringkasan Akaun ke Folder Muat Turun sebagai Fail CSV",
  fiatBalance: "Baki Fiat",
  name: "Nama Akaun",
  noAccount: "Tiada akaun untuk dipaparkan.",
  subtotalWithCoinName: "Jumlah ({{coinName}})",
  title: "Ringkasan Akaun",
  total: "Jumlah",
  transactionHistory: "Sejarah transaksi"
}, addAccount$c = {
  chooseName: {
    nextButton: "Tambah Akaun",
    step: "Nama akaun",
    title: "Namakan akaun anda"
  },
  selectCoin: {
    nextButton: "Seterusnya",
    step: "Pilih syiling",
    title: "Pilih mata wang kripto"
  },
  success: {
    addAnotherAccount: "Tambah akaun lain",
    message: "<strong>{{accountName}}</strong> telah ditambahkan ke akaun anda",
    nextButton: "Selesai",
    step: "Selesai",
    title: "Akaun ditambahkan"
  },
  title: "Tambah Akaun"
}, aopp$5 = {
  addressRequest: "{{host}} sedang meminta alamat penerimaan.",
  addressRequestWithLogo: "sedang meminta alamat penerima",
  banner: "Permintaan alamat dalam proses.",
  errorTitle: "Ralat semasa permintaan alamat",
  labelAddress: "Alamat",
  labelMessage: "Mesej",
  reverifyInfoText: "Sahkan alamat",
  signing: "Untuk meneruskan, tandatangani mesej pada BitBox02 anda.",
  success: {
    message: "Teruskan {{host}}",
    title: "Alamat berjaya dihantar"
  },
  syncing: "Menyelaraskan akaun, sila tunggu.",
  title: "Permintaan alamat"
}, app$b = {
  upgrade: "Versi baru aplikasi ini telah didapati! Sila kemaskini dari {{current}} ke {{version}}."
}, auth$5 = {
  authButton: "Sahkan",
  title: "Sila sahkan untuk meneruskan"
}, backup$b = {
  check: {
    checking: "Memeriksa backup...",
    confirmTitle: "Semak Backup",
    notOK: "Backup TIDAK sepadan dengan wallet.",
    ok: "Backup sepadan dengan wallet.",
    password: {
      label: "Kata laluan pemulihan",
      placeholder: "Kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    success: "Backup berjaya disahkan",
    title: "Semak Backup"
  },
  create: {
    alreadyExists: "Anda sudah mempunyai backup yang sah. Adakah anda ingin menciptanya kembali?",
    fail: "TIDAK BERJAYA membuat backup!",
    info: "Sila masukkan kata laluan pemulihan dari wallet terkini untuk pengesahan",
    name: {
      label: "Nama backup",
      placeholder: "Sila memberi nama backup"
    },
    password: {
      label: "Kata Laluan Pemulihan",
      placeholder: "Sila masukkan kata laluan pemulihan anda"
    },
    title: "Buat Backup",
    verificationFailed: "Kata laluan pemulihan TIDAK sesuai dompet terkini. Backup telah dibuat. Sila gunakan 'Semak Backup' untuk mengesahkan kembali password pemulihan anda."
  },
  description: "Pilih <strong>fail backup wallet</strong>",
  insert: "Sila masukkan kad micro SD untuk mengurus backup.",
  insertButton: "Saya telah memasukkan kad micro SD",
  list: "Telah jumpa <strong>backup berikut</strong> pada kad SD ini:",
  noBackups: "Tiada backup pada kad microSD ini.",
  restore: {
    confirmTitle: "Memulihkan Backup",
    error: {
      e200: "SD card tidak dijumpai",
      general: "Ralat memulihkan sandaran"
    },
    password: {
      label: "Kata laluan pemulihan atau kata laluan pemulihan tersembunyi",
      placeholder: "Kata laluan pemulihan",
      repeatPlaceholder: "Ulangi kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    restoring: "Memulihkan backup...",
    selectedBackup: "<strong>{{backupName}}</strong> dicipta pada {{createdDateTime}} akan dipulihkan.",
    title: "Memulihkan",
    understand: "Saya faham bahawa kata laluan pemulihan yang salah akan membuat dompet yang berbeza"
  },
  showMnemonic: {
    description: `Anda akan diberikan 24 perkataan pemulihan, yang membentuk sandaran dompet anda. Tulis mereka di atas kertas.

<strong>Jangan menyimpannya secara digital atau mengambil gambar.</strong>

<strong>Jangan mengucapkannya dengan lantang.</strong>

<strong>Sandaran ini tidak dilindungi kata laluan.</strong>

Selepas itu, anda akan diminta mengesahkan setiap perkataan.`,
    title: "Tunjukkan perkataan pemulihan",
    warning: "<strong>Jangan sekali-kali berkongsi kata-kata pemulihan anda dengan sesiapa pun.</strong> Perkataan pemulihan anda memberikan akses penuh kepada dompet anda. Jika seseorang meminta anda untuk kata-kata pemulihan anda, ia adalah penipu, jangan kongsikannya!"
  },
  title: "Urus Backup"
}, bb02Bootloader$b = {
  abort: "Jangan naik taraf - Kembali",
  abort_noUpgrade: "Bawa saya balik",
  advanced: {
    label: "Tetapan lanjutan",
    toggleShowFirmwareHash: "Tunjukkan hash firmware setiap kali pada permulaan"
  },
  flipscreen: "Putar skrin",
  orientation: "Orientasi peranti salah?",
  success: "Naik taraf berjaya! Meneruskan dalam {{rebootSeconds}} detik...",
  success_install: "Pemasangan berjaya! Meneruskan dalam {{rebootSeconds}} detik..."
}, bitbox$b = {
  error: {
    e10000: "Kata laluan peranti terkini salah",
    e10001: "Gagal mengganti kata laluan peranti",
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e112: "Kata laluan peranti tersembunyi tidak boleh sama dengan kata laluan peranti utama."
  }
}, bitbox02Interact$b = {
  confirmDate: "Sahkan tarikh hari ini pada BitBox02 anda.",
  confirmDateText: "Tarikh ini akan digunakan untuk membuat sandaran anda.",
  confirmName: "Sahkan nama pada BitBox02",
  confirmWords: "Tuliskan {{amount}} perkataan pemulihan daripada BitBox02 anda",
  confirmWordsText: "Selepas itu BitBox02 meminta anda mengesahkan setiap perkataan untuk mengesahkan bahawa sandaran adalah betul.",
  followInstructions: "Sila ikuti arahan pada BitBox02 anda.",
  followInstructionsMnemonic: "Ikuti arahan pada BitBox02 anda untuk memasukkan perkataan pemulihan dari sandaran dan pulihkan dompet anda.",
  followInstructionsMnemonicTitle: "Pulihkan dari perkataan pemulihan"
}, bitbox02Settings$b = {
  deviceName: {
    current: "Nama peranti semasa",
    error: "Nama peranti tidak dapat ditetapkan",
    error_104: "Mengesahkan nama peranti telah digugurkan pada peranti.",
    input: "Nama BitBox02",
    placeholder: "Nama peranti baharu",
    title: "Tetapkan Nama BitBox02"
  },
  gotoStartupSettings: {
    description: "Ini akan but semula BitBox02 anda dan masukkan tetapan permulaan.",
    title: "Ini akan me-reboot BitBox02 anda dan masuk ke dalam tetapan permulaan semula."
  }
}, bitbox02Wizard$b = {
  advanced: {
    button: "Pilihan lanjutan",
    outOfDate: "Perisian tegar sudah lapuk untuk ciri ini",
    seed12WordInfo: "Sila ambil perhatian bahawa bilangan perkataan tidak boleh diubah selepas mencipta dompet.",
    seed12WordLabel: "Buat 12 perkataan dan bukannya benih 24 perkataan",
    seed12WordText: "Secara lalai, BitBox02 menggunakan benih 24 perkataan. Kedua-dua panjang benih adalah selamat daripada paksaan kasar dalam amalan. Sesetengah pengguna mungkin lebih suka kemudahan benih 12 perkataan sebaliknya.",
    skipSDCardLabel: "Langkau sandaran kad microSD dan tulis perkataan pemulihan sebaliknya",
    skipSDCardText: "Anda sentiasa mempunyai pilihan untuk membuat sandaran kad microSD atau menulis perkataan pemulihan anda selepas persediaan. Ini boleh dilakukan dari tetapan.",
    title: "Pilihan sandaran lanjutan"
  },
  attestationFailed: "Pengesahan peranti gagal. BitBox anda mungkin palsu atau terkompromi. Syiling di BitBox02 mungkin berisiko hilang. Sila hubungi support@bitbox.swiss dengan segera.",
  backup: {
    point1: "Pilih backup pada kad microSD",
    point2: "Tetapkan kata laluan untuk peranti anda",
    restoreText: "Ok, mari kita pulihkan backup!",
    text1: "Hebat, kata laluan BitBox02 anda sudah ditetapkan dan wallet dibuat. Kini tiba masanya untuk membuat backup pertama anda. Sila pastikan kad microSD anda dimasukkan ke dalam BitBox02 anda dan teruskan.",
    text2: "Sila ikuti arahan pada skrin pada peranti anda untuk membuat backup.",
    text3: "Selepas backup anda dicipta, sila tarik keluar kad microSD dan simpan itu di <strong>lokasi selamat</strong>. Kandungan kad microSD tidak dilindungi kata laluan. Jangan sekali-kali memasukkannya ke peranti lain selain BitBox02 anda.",
    userConfirmation1: "Saya harus menyimpan sandaran saya di lokasi yang selamat.",
    userConfirmation2: "Sandaran saya tidak dilindungi dengan kata laluan. Siapa saja yang mempunyai akses kepadanya dapat mengakses dompet saya.",
    userConfirmation3: "Jika saya kehilangan atau merosakkan BitBox02 saya, satu-satunya cara untuk memulihkan dana saya adalah dengan memulihkan daripada sandaran saya.",
    userConfirmation4: "Jika saya kehilangan atau merusakkan kedua-dua sandaran dan BitBox02 saya, maka dana saya akan hilang.",
    userConfirmation5: "Saya sepatutnya tidak memasukkan sandaran kad microSD saya ke dalam komputer, telefon, pencetak atau sebarang peranti selain daripada BitBox02.",
    userConfirmation5mnemonic: "Saya tidak sepatutnya meletakkan perkataan pemulihan saya dalam komputer, telefon, pencetak atau mana-mana peranti selain daripada BitBox02."
  },
  create: {
    button: "Beri Nama dan Teruskan",
    info: "Inilah langkah-langkah asas yang akan anda ambil untuk menyediakan BitBox anda: ",
    inputTitle: "Nama Wallet",
    point1: "Tetapkan nama untuk peranti anda",
    point2: "Tetapkan kata laluan untuk peranti anda",
    point3: "Buat backup",
    text: "Ok, mari buat dompet baru!"
  },
  createBackupAborted: "Membuat sandaran dihentikan.",
  createBackupFailed: "Gagal membuat sandaran, cuba lagi.",
  initialize: {
    passwordText: "Sekarang mari kita tetapkan kata laluan untuk peranti anda. Gunakan kawalan pada BitBox anda untuk memasukkan dan memilih kata laluan.",
    passwordTitle: "Tetapkan kata laluan untuk BitBox anda",
    text: "Berjaya berpasangan dengan BitBox02 anda! Sekarang mari kita inisialisasi peranti anda. Mulailah dengan memilih untuk membuat wallet baru, atau untuk memulihkan wallet dari backup yang sudah ada. <strong>Sila pastikan anda mempunyai kad microSD yang sudah dimasukkan dalam BitBox02 anda</strong>",
    tip: "Sebelum meneruskan, sangat disyorkan supaya anda meneruskan di persekitaran yang selamat.",
    title: "Inisialisasi BitBox anda"
  },
  insertSDCard: "<strong>Sila pastikan anda mempunyai kad microSD yang dimasukkan ke dalam BitBox02 anda.</strong>",
  noPasswordMatch: "Kata laluan tidak sepadan, sila cuba lagi.",
  pairing: {
    failed: "Pasangan tidak berjaya disahkan. Sila tancap ulang BitBox02 anda.",
    paired: "Anda telah mengesahkan pada peranti anda bahawa kod sepadan. Jika ini betul, anda boleh meneruskan dengan mengklik butang di bawah.",
    title: "Sahkan Kod Pasangan",
    unpaired: "BitBox02 baru telah dikesan. Sila sahkan bahawa kod berikut sepadan dengan apa yang ditunjukkan pada peranti anda. Jika kod itu sepadan, sentuh di bawah tanda semak pada BitBox02 anda dan kemudian klik butang di bawah untuk meneruskan."
  },
  restoreFromMnemonic: {
    e104: "Pemulihan daripada perkataan pemulihan telah dibatalkan.",
    failed: "Pemulihan daripada perkataan pemulihan gagal, sila cuba lagi."
  },
  stepBackup: {
    beforeProceed: "Sebelum meneruskan, sila baca pertimbangan keselamatan berikut:",
    createBackup: "Anda kini akan membuat sandaran pada kad microSD anda.",
    createBackupMnemonic: "Kini, anda akan dapat menulis perkataan pemulihan."
  },
  stepBackupSuccess: {
    fundsSafe: "Untuk memastikan dana anda selamat, sila ingat perkara berikut:",
    title: "Sandaran Dipulihkan!"
  },
  stepConnected: {
    unlock: "Masukkan kata laluan BitBox02 untuk membuka kunci."
  },
  stepCreate: {
    description: "Nama ini digunakan sebagai nama peranti dan untuk sandaran.",
    nameLabel: "Nama BitBox02",
    namePlaceholder: "BitBox02 Saya",
    title: "Pilih nama BitBox02",
    toastMicroSD: "Sila masukkan kad microSD anda ke dalam BitBox02 anda yang akan digunakan untuk menyimpan sandaran dompet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Sila keluarkan kad microSD dari BitBox02 anda dan simpan di tempat yang selamat.",
    storeMnemonic: "Sila simpan perkataan pemulihan anda di lokasi yang selamat",
    success: "Anda telah berjaya membuat sandaran anda."
  },
  stepInsertSD: {
    insertSDCard: "Sila masukkan kad mikroSD ke dalam BitBox02 anda untuk meneruskan.",
    insertSDcardTitle: "Masukkan kad mikroSD"
  },
  stepPassword: {
    e104: "Menetapkan kata laluan telah dibatalkan.",
    title: "Tetapkan kata laluan BitBox02",
    useControls: "Gunakan kawalan pada BitBox02 anda untuk menetapkan kata laluan."
  },
  stepUninitialized: {
    create: "Saya mahu menyiapkan BitBox02 baru",
    restore: "Saya mahu memulihkan dompet saya daripada sandaran.",
    restoreMicroSD: "Pulihkan daripada kad microSD",
    restoreMnemonic: "Pulihkan daripada perkataan pemulihan",
    title: "Sediakan BitBox02 anda"
  },
  success: {
    text: `Hooray! BitBox02 anda kini siap untuk digunakan.

Untuk maklumat lanjut mengenai cara menggunakan aplikasi BitBox, sila gunakan panduan dalam aplikasi dengan mengklik tanda tanya di sudut kanan atas.`,
    title: "Anda sudah bersedia untuk pergi!"
  }
}, blink$b = {
  button: "Berkedip"
}, bootloader$b = {
  button: "Naik taraf Firmware sekarang",
  button_install: "Pasang firmware sekarang",
  progress: "Menaiktaraf: {{progress}}%",
  progress_install: "Memasang: {{progress}}%",
  success: "Naik taraf berjaya! Sila pasang ulang peranti. Kali ini, jangan sentuh butang."
}, button$f = {
  abort: "Tinggalkan",
  back: "Kembali",
  buy: "Beli",
  changepin: "Ubah kata laluan peranti",
  check: "Semak Backup",
  continue: "Teruskan",
  copy: "Menyalin",
  create: "Buat",
  dismiss: "Batalkan",
  done: "Selesai",
  download: "Muat turun",
  hiddenwallet: "Buat wallet tersembunyi",
  next: "Berikut",
  ok: "OK",
  previous: "Sebelumnya",
  receive: "Terima",
  restore: "Memulihkan",
  select: "Pilih",
  send: "Hantar",
  unlock: "Buka",
  update: "Kemas kini",
  upgrade: "Naik taraf"
}, buy$7 = {
  exchange: {
    bankTransfer: "Transfer bank",
    bestDeal: "Tawaran terbaik",
    creditCard: "Kad kredit",
    fast: "Cepat",
    fee: "bayaran",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Pemindahan bank: {{fee}}%",
          creditDebitCard: "Kad kredit/debit: {{fee}}%",
          learnMore: "Ketahui lebih lanjut tentang Moonpay",
          title: "Bayaran"
        },
        fullCurrenciesList: "Lihat senarai penuh mata wang di sini",
        payment: {
          asteriskText: "* Tidak tersedia untuk penduduk AS",
          bankTransfer: "Transfer bank*",
          bankTransferDetails: {
            pix: "PIX (transaksi BR di Brasil sahaja)",
            sepa: "SEPA dan SEPA Instant (transaksi EUR di negara-negara SEPA sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          creditDebitCard: "Kad kredit/debit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa dan Maestro"
          },
          learnMore: "Lihat butiran lanjut tentang kaedah pembayaran",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong semua mata wang fiat utama: USD, EUR, CHF dan lain-lain."
      },
      pocket: {
        fees: {
          info: "Transfer bank: {{fee}}%",
          title: "Bayaran"
        },
        learnMore: "Ketahui lebih lanjut tentang Pocket",
        payment: {
          bankTransfer: "Transfer bank",
          bankTransferDetails: {
            sepa: "SEPA dan SEPA Segera (urus niaga EUR di negara SEPA sahaja)",
            sic: "Swiss Interbank Clearing (transaksi CHF di CH/LI sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          bankTransferReccuring: "Bagaimana cara menyiapkan pembelian berkala dengan standing order?",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong mata wang Eropah: EUR, GBP dan CHF.",
        verification: {
          info: "Hanya memerlukan pengesahan identiti melebihi ambang harian dan tahunan.",
          link: "Cari ambang semasa di sini",
          title: "Pengesahan identiti"
        }
      },
      region: {
        title: "Pilih wilayah akaun bank anda didaftarkan untuk melihat pilihan yang tersedia untuk anda."
      }
    },
    noExchanges: "Maaf, tiada pertukaran tersedia di rantau ini.",
    region: "Wilayah",
    selectRegion: "Tidak dinyatakan",
    title: "Beli {{name}}"
  },
  info: {
    continue: "Setuju dan teruskan",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "Kami bekerjasama dengan MoonPay untuk menawarkan anda cara yang lancar untuk membeli {{name}} terus dalam BitBoxApp. Ia hanya beberapa klik.",
        "MoonPay ialah platform yang memudahkan dan cepat untuk membeli {{name}} di lebih 160+ negara."
      ],
      payment: {
        details: "Anda boleh beli {{name}} serta-merta melalui MoonPay dengan kaedah pembayaran berikut. Pesanan kad kredit atau debit adalah segera dan mudah, tetapi lebih mahal disebabkan peningkatan risiko caj balik. Kami mengesyorkan menggunakan pilihan pindahan bank untuk jumlah yang lebih besar. Yuran minimum ialah 4 USD/EUR atau setara.",
        footnote: "Sila ambil perhatian bahawa kadar pertukaran MoonPay boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
        table: {
          "1_description": "Yuran terendah, boleh mengambil masa sehingga 3 hari bekerja",
          "1_method": "Pindahan bank (SEPA)",
          "2_description": "Yuran yang lebih tinggi tetapi cepat dan segera",
          "2_method": "Kad kredit & debit",
          description: "Penerangan",
          fee: "Yuran",
          method: "Kaedah"
        },
        title: "Kaedah pembayaran dan yuran"
      },
      privacyPolicy: "Dasar privasi MoonPay",
      protection: {
        description: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana masuk dianggap seperti transaksi biasa. MoonPay perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
        descriptionGeneric: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana yang masuk dianggap seperti transaksi biasa. Bagaimanapun pertukaran rakan kongsi perlu mengumpul beberapa maklumat untuk beroperasi. Sila rujuk dasar privasi masing-masing untuk melihat dengan lebih terperinci cara data dikendalikan.",
        title: "Perlindungan Data"
      },
      security: {
        description: "Apabila anda membeli {{name}} melalui MoonPay, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        descriptionGeneric: "Apabila anda membeli {{name}} melalui pertukaran rakan kongsi, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        link: 'Model "security threat"',
        title: "Model security"
      },
      title: ""
    },
    next: "Seterusnya",
    selectLabel: "Pilih akaun anda",
    selectPlaceholder: "Pilih syiling",
    skip: "Jangan tunjukkan lagi",
    title: "Beli {{name}}"
  },
  pocket: {
    data: {
      link: "Dasar privasi poket",
      p1: "BitBoxApp tidak mengumpul sebarang data semasa membeli bitcoin, dana masuk dianggap seperti transaksi biasa. Pocket perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
      title: "Perlindungan Data"
    },
    kyc: {
      link: "Baca Soalan Lazim Poket",
      p1: "Pocket cuba mengekalkan KYC pada tahap minimum. Untuk pembelian di bawah 950 EUR (1000 CHF) sehari, tiada dokumen tambahan diperlukan. Untuk pembelian melebihi jumlah ini, anda perlu menjadualkan panggilan dengan Pocket untuk melengkapkan proses KYC/AML yang diperlukan.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Anda boleh membeli bitcoin serta-merta dengan Pocket melalui pindahan bank SEPA. Yuran adalah 1.5% dan bitcoin didepositkan ke BitBox anda secepat mungkin selepas Pocket menerima pindahan bank (biasanya dalam hari yang sama).",
      p2: "Sila ambil perhatian bahawa kadar pertukaran Pocket boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
      title: "Kaedah pembayaran dan yuran"
    },
    previousTransactions: "Sejarah transaksi akaun ini tidak kosong. Berkongsi akaun ini akan menjadikan semua urus niaga masa lalu dan masa depannya kelihatan untuk Pocket. Teruskan juga?",
    security: {
      link: "Model ancaman keselamatan BitBox02",
      p1: "Apabila anda membeli bitcoin melalui Pocket, anda menggunakan perkhidmatan luaran. Perkhidmatan ini di luar skop model Ancaman Keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran yang dijalankan oleh perisian BitBoxApp. Walau bagaimanapun, kami bekerjasama untuk meningkatkan keselamatan dengan menggunakan mekanisme pengesahan dua faktor untuk mengesahkan alamat anda menerima ke.",
      title: "Model keselamatan"
    },
    usedAddress: "Alamat {{address}} telah digunakan, sila mulakan semula dengan alamat baharu.",
    verifyBitBox02: "Sila sahkan bahawa alamat yang anda terima melalui e-mel sepadan dengan alamat yang dipaparkan pada Bitbox anda. Jika boleh, anda harus membuka e-mel pada peranti kedua untuk keselamatan yang lebih baik.",
    welcome: {
      p1: "Kami bekerjasama dengan Pocket untuk menawarkan anda cara yang lancar untuk membeli bitcoin terus dalam BitBoxApp. Ia hanya beberapa klik.",
      p2: "Pocket ialah platform Switzerland yang menjadikannya cepat dan mudah untuk membeli bitcoin di kebanyakan Eropah (di mana-mana sahaja di mana pemindahan bank SEPA disokong).",
      p3: "Dengan Pocket, anda juga boleh melakukan pembelian biasa melalui pesanan bank tetap, jadi anda boleh DCA (purata kos dolar) dengan mudah.",
      title: "Selamat datang ke kedai sehenti anda untuk membeli bitcoin"
    }
  },
  title: "Beli {{name}}"
}, changePin$b = {
  newTitle: "Kata laluan peranti baru",
  oldLabel: "Kata laluan peranti terkini"
}, chart$7 = {
  dataMissing: "Mengumpul data sejarah... nantikan.",
  dataOldTimestamp: "Pengemaskinian kadar pertukaran sejarah. Carta tidak memaparkan data selepas {{time}}.",
  dataUpdating: "mengemas kini data…",
  filter: {
    all: "Semua",
    month: "Bulan",
    week: "Minggu",
    year: "Tahun"
  }
}, checkSDcard$b = "memeriksa kad micro SD", clickHere$b = "Tekan di sini.", confirm$d = {
  abortInfo: "Sentuh untuk ",
  abortInfoRedText: "tinggalkan",
  approveInfo: "Tahan 4 detik untuk ",
  approveInfoGreenText: "sahkan",
  info: "Pada BitBox anda",
  infoWhenPaired: "Mula-mula pada telefon mudah alih yang dipasangkan dan kemudian BitBox anda"
}, confirmOnDevice$b = "Sila sahkan pada peranti anda.", connectKeystore$5 = {
  promptNoName: "Sila sambungkan BitBox02 anda untuk meneruskan",
  promptWithName: 'Sila sambungkan BitBox02 anda bernama "{{name}}" bersambung'
}, darkmode$6 = {
  toggle: "Mod gelap"
}, device$b = {
  appUpradeRequired: "BitBox anda tidak sesuai dengan aplikasi desktop ini. Sila muat turun dan pasang versi terkini."
}, deviceLock$b = {
  button: "Membolehkan Pengesahan Dua Langkah (2FA)",
  condition1: "Adakah anda mempunyai backup?",
  condition2: "Apakah pengesahan aplikasi mudah alih berfungsi?",
  condition3: "2FA MENYAHAKTIFKAN backup dan pemasangan aplikasi. Peranti mesti DITETAPKAN SEMULA untuk keluar dari 2FA!",
  confirm: "Membolehkan Pengesahan Dua Langkah (2FA)",
  title: "Membolehkan Pengesahan Dua Langkah (2FA)"
}, deviceSettings$b = {
  backups: {
    manageBackups: {
      description: "Cipta atau sahkan sandaran kad microSD anda."
    },
    showRecoveryWords: {
      description: "Tunjukkan dan sahkan perkataan pemulihan."
    },
    title: "Sandaran"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp menyemak sama ada peranti anda adalah tulen."
    },
    deviceName: {
      description: "Tukar nama peranti anda."
    },
    rootFingerprint: {
      description: "Root fingerprint ialah pengecam unik untuk dompet yang sedang digunakan. Root fingerpri boleh membantu anda membezakan antara dompet yang berbeza jika anda menggunakan frasa laluan."
    },
    securechip: {
      description: "Model cip selamat."
    },
    title: "Maklumat peranti"
  },
  expert: {
    factoryReset: {
      description: "Tetapkan semula peranti anda kepada tetapan kilang. Ini memadamkan dompet daripada BitBox02 anda!",
      title: "Tetapan semula kilang"
    },
    goToStartupSettings: {
      description: "Masukkan pemuat but BitBox02. Anda boleh mendayakan cincang perisian tegar dari sini."
    },
    passphrase: {
      description: "Dayakan atau lumpuhkan ciri frasa laluan.",
      title: "Ungkapan laluan"
    }
  },
  firmware: {
    firmwareVersion: "Versi Perisian Tegar",
    newVersion: {
      label: "Versi yang tersedia"
    },
    title: "Firmware",
    upToDate: "Peranti anda adalah yang terkini",
    upgradeAvailable: "Peningkatan baharu tersedia",
    version: {
      label: "Versi"
    }
  },
  hardware: {
    attestation: {
      false: "Semakan ketulenan gagal",
      label: "Semakan ketulenan",
      true: "BitBox02 anda adalah sahih"
    },
    sdcard: {
      false: "Belum dimasukkan",
      label: "Kad micro SD",
      true: "Telah dimasukkan"
    },
    securechip: "Cip selamat",
    title: "Hardware"
  },
  loading: "Mengambil maklumat peranti ...",
  pairing: {
    lock: {
      false: "dinyahaktifkan",
      label: "Pengesahan Dua Langkah (2FA)",
      true: "Diaktifkan"
    },
    mobile: {
      false: "Ditutup",
      label: "Aplikasi Mudah Alih",
      true: "Buka"
    },
    status: {
      false: "Belum dipasangkan",
      label: "Status",
      true: "Dipasangkan"
    },
    title: "Memasang"
  },
  secrets: {
    manageBackups: "Urus Backup",
    title: "Rahsia"
  }
}, deviceTampered$b = "Apakah BitBox anda dibekalkan dengan kata laluan pemulihan? Jika ya, hentikan proses persediaan dan hubungi sokongan segera. Shift tidak akan memberikan anda dompet siap pakai atau membuat cadangan kata laluan.", dialog$c = {
  cancel: "Batal",
  confirm: "Sahkan",
  confirmTitle: "Pengesahan"
}, error$7 = {
  accountAlreadyExists: "Akaun sudah wujud.",
  accountLimitReached: "Tidak boleh menambah akaun. Bilangan maksimum akaun untuk syiling ini telah dicapai.",
  aoppCallback: "Terdapat ralat menghantar alamat kepada {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "Tiada akaun tersedia.",
  aoppSigningAborted: "Permintaan pemilikan alamat dibatalkan.",
  aoppUnknown: "Ralat tidak diketahui berlaku.",
  aoppUnsupportedAsset: "Aset tidak disokong.",
  aoppUnsupportedFormat: "Tiada akaun tersedia yang menyokong format alamat yang diminta.",
  aoppUnsupportedKeystore: "Peranti yang disambungkan tidak boleh menandatangani mesej untuk aset ini.",
  aoppVersion: "Versi tidak diketahui.",
  wrongKeystore: "Dompet salah disambungkan. Sila pastikan anda memasukkan peranti yang betul yang sepadan dengan akaun ini.",
  wrongKeystore2: " Jika anda menggunakan frasa laluan pilihan, pastikan anda telah memasukkan frasa laluan yang betul untuk akaun tersebut."
}, fiat$d = {
  default: "tetapan standard",
  setDefault: "Tetapkan {{code}} sebagai tetapan standard",
  title: "Mata wang"
}, footer$d = {
  appVersion: "Versi App:"
}, generic$7 = {
  enabled_false: "Dinyahaktifkan",
  enabled_true: "Diaktifkan"
}, genericError$b = "Kesalahan muncul. Sekiranya anda melihat sebarang masalah, sila mulakan semula aplikasi.", goal$b = {
  buttons: {
    create: "Buat wallet baru",
    restore: "Pulihkan wallet dari backup"
  },
  paragraph: "Sila pilih salah satu pilihan berikut:",
  step: {
    1: {
      title: "Maklumat Keselamatan"
    },
    2: {
      description: "Tetapkan kata laluan peranti",
      title: "Peranti"
    },
    "3-create": {
      description: "Buat wallet baru",
      title: "Wallet"
    },
    "3-restore": {
      description: "dari backup",
      title: "Memulihkan"
    },
    "4-create": {
      title: "Ringkasan"
    },
    "4-restore": {
      title: "Ringkasan"
    }
  }
}, guide$c = {
  accountDescription: {
    text: "Ini adalah gambaran keseluruhan akaun anda. Ia menunjukkan transaksi masuk dan keluar. Baki dipaparkan untuk setiap akaun secara berasingan. Rujuk panduan dalam tetapan untuk mengetahui lebih lanjut mengenai jenis akaun yang berlainan.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountFiat: {
    text: "Ya, anda boleh mengklik ticker mana sahaja untuk berputar melalui beberapa mata wang fiat. Anda juga boleh menukar senarai mata wang dalam tetapan.",
    title: "Bolehkah saya memaparkan kadar penukaran lain?"
  },
  accountIncomingBalance: {
    text: "Jumlah yang akan masuk dan akan dipindahkan kepada anda tetapi belum disahkan oleh rangkaian.",
    title: "Apakah maksud akan masuk?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Setiap xpub terikat dengan "Jenis" yang ditunjukkan: sama ada "Segwit Asli (bech32)", "Segwit Terbungkus" atau "Taproot" (Bitcoin sahaja). Ini adalah jenis skrip yang digunakan oleh {{coinName}}. BitBoxApp menggabungkannya, menyokong berbilang jenis skrip dalam akaun yang sama. Kerana setiap jenis skrip memberikan xpub yang berbeza, terdapat berbilang xpub bagi setiap akaun.

Jika anda menerima secara konsisten pada alamat lalai (Native Segwit), anda hanya memerlukan xpub "bech32". Walau bagaimanapun, jika anda turut menerima dana untuk "Wrapped Segwit" atau "Taproot", anda juga perlu menggunakan kunci awam lanjutan "Wrapped Segwit" dan "Taproot".`,
      title: "Mengapa terdapat banyak xpub?"
    },
    privacy: {
      text: `Untuk akaun khusus ini, kunci awam lanjutan mendedahkan keseluruhan sejarah kewangan, baki akaun anda dan semua urus niaga masa hadapan. Tetapi xpub tidak membenarkan sesiapa membelanjakan syiling anda.

Jika anda memberikan xpub kepada seseorang, anda harus sedar bahawa orang atau syarikat ini boleh melihat semua transaksi lain akaun yang sama. Oleh itu, adalah idea yang baik untuk menggunakan akaun itu hanya untuk tujuan ini dan menyimpan dana lain dalam akaun yang berbeza.`,
      title: "Adakah saya perlu merahsiakan xpub saya?"
    },
    verify: {
      text: "Ya, adalah idea yang baik untuk menyemak semula xpub anda. Jika orang lain akan menjana alamat terima daripada xpub ini untuk menghantar wang kepada anda, ini amat penting. Anda perlu mengesahkannya pada peranti untuk memastikan bahawa xpub ini kepunyaan anda; jika tidak, semua dana boleh pergi ke alamat yang salah.",
      title: "Adakah saya perlu mengesahkan xpub pada peranti?"
    },
    xpub: {
      text: `Public Key Lanjutan adalah kunci akar yang mana semua alamat penerima sebuah akaun diperoleh.
Ia disediakan di sini untuk kegunaan lanjutan dan saling kendalian dengan wallet yang hanya boleh dilihat sahaja, seperti Electrum atau Sentinel.`,
      title: "Apa itu Public Key Lanjutan?"
    }
  },
  accountRates: {
    text: "Kadar pertukaran dikemas kini setiap minit oleh CoinGecko.",
    title: "Kadar mana yang digunakan?"
  },
  accountReload: {
    text: "Semua maklumat transaksi dikemas kini secara automatik.",
    title: "Bagaimanakah saya dapat memuatkan semula sejarah transaksi?"
  },
  accountSendDisabled: {
    text: "Butang 'Hantar' diaktifkan apabila baki anda tidak kosong.",
    title: "Mengapa saya tidak dapat menghantar sebarang {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Jumlah keseluruhan ialah jumlah semua akaun crypto anda. Kadar pertukaran diperoleh daripada coingecko.com.

Nota: Jika anda menggunakan MyEtherWallet untuk token yang tidak disokong dalam BitBoxApp, ia tidak akan dimasukkan dalam jumlah yang dipaparkan.`,
    title: "Bagaimanakah jumlah keseluruhan dikira?"
  },
  accountSummaryDescription: {
    text: "Di sini anda boleh melihat prestasi portfolio anda dari semasa ke semasa. Ringkasan akaun crypto individu anda dipaparkan di bawah carta.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountTransactionAttributesBTC: {
    text: `Saiz maya: Digunakan untuk menentukan yuran rangkaian. Anda telah berjaya menyimpan yuran jika ia lebih kecil daripada saiz transaksi.
Saiz: Saiz transaksi yang sebenarnya dalam bait apabila disirikan mengikuti blockchan yang mendasarinya.
Berat: Diperkenalkan dengan Segwit, itu adalah metrik baru untuk menilai saiz transaksi dan blok. Setiap bait saksi yang dipisahkan dianggap sebagai satu, semua yang lain sebagai empat unit berat. Dibandingkan satu megabyte dalam saiz sebenarnya, had saiz blok kini adalah empat juta unit berat.`,
    title: "Butiran transaksi yang berkaitan dengan Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: `Pengesahan: Apabila transaksi anda disiarkan buat kali pertama, ia tidak akan disahkan terlebih dahulu. Anda perlu menunggu untuk dimasukkan ke dalam blok oleh pelombong, selepas itu ia akan mempunyai 1 pengesahan. Setiap blok yang disiarkan di rangkaian selepas itu akan menambah pengesahan lain ke transaksi anda. Secara umum pedagang dan pelaku rangkaian lain hanya akan menerima transaksi dengan pengesahan 3-6 sebelum mempertimbangkan transaksi sebagai selesai.
ID Transaksi: Nombor pengenalan unik yang boleh digunakan untuk mencari transaksi dalam blok explorer.
Yuran: Pelombong dibayar yuran transaksi sebagai insentif untuk memasukkan transaksi di blok-blok yang mereka laksanakan. Untuk mengetahui lebih lanjut, klik pada butang hantar.`,
    title: "Apa makna daripada maklumat yang ditunjukkan dalam butiran transaksi?"
  },
  accountTransactionConfirmation: {
    text: "Ini adalah transaksi yang telah disiarkan ke rangkaian dan sedang menunggu untuk disahkan.",
    title: "Apa itu transaksi yang tertunda?"
  },
  accountTransactionLabel: {
    text: "Ia adalah alamat di mana anda menerima syiling atau menghantar syiling itu. Satu alamat menyandi bagaimana (dan dengan demikian oleh siapa) syiling dapat dibelanjakan.",
    title: "Alamat mana yang dipaparkan untuk setiap transaksi?"
  },
  accountTransactionTime: {
    text: "Masa daripada transaksi yang telah disahkan di blokchain.",
    title: "Masa mana yang dipaparkan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Setiap syiling boleh mempunyai maksimum lima akaun.",
      title: "Berapa banyak akaun yang boleh saya buat?"
    },
    howtoAddTokens: {
      text: 'Token yang menggunakan standard ERC20 terikat pada akaun Ethereum tertentu. Untuk mendayakan atau melumpuhkan token tertentu, buka skrin "Urus akaun", kembangkan akaun Ethereum anda dan hidupkan atau matikan token yang dikehendaki.',
      title: "Bagaimanakah saya boleh menambah token tambahan?"
    },
    moveFunds: {
      text: "ya. Tetapi kerana akaun adalah bebas, anda perlu menghantar dana anda menggunakan transaksi biasa.",
      title: "Bolehkah saya memindahkan dana antara akaun?"
    },
    recoverAccounts: {
      text: "ya. BitBoxApp mencipta akaun menggunakan piawaian yang mantap yang serasi dengan kebanyakan dompet crypto lain.",
      title: "Bolehkah saya memulihkan akaun saya dengan dompet lain?"
    },
    whatAreAccounts: {
      text: "Dompet anda boleh mengurus berbilang akaun syiling yang sama. Akaun berguna apabila anda ingin mengasingkan dana.",
      title: "Apakah akaun?"
    },
    whyIsThisUseful: {
      text: 'Akaun bagus untuk mengurus dana untuk orang atau tujuan yang berbeza kerana ia dipisahkan. Anda juga boleh berkongsi "kunci awam lanjutan" akaun tanpa mendedahkan apa-apa tentang akaun anda yang lain. Ini membolehkan anda berulang kali menerima dana tanpa menggunakan semula alamat, seperti menerima gaji anda atau kerap membeli kripto.',
      title: "Mengapa ini berguna?"
    }
  },
  appendix: {
    link: "Hubungi kami!",
    text: "Soalan lain?"
  },
  backups: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda. Ia juga boleh digunakan untuk mengesahkan bahawa anda masih mempunyai kata laluan pemulihan yang betul. Anda dapat menyemak kata laluan pemulihan utama atau tersembunyi anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak, tetapi kata laluan pemulihan diperlukan untuk memperoleh wallet dari benih yang disimpan.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    howOften: {
      text: `Cadangan dibuat secara automatik apabila dompet baru dibuat. Anda hanya perlu membuat backup baru jika kad micro SD anda hilang atau rosak, atau jika anda mahu menggunakan lebih daripada satu kad micro SD sebagai backup.
Anda tidak perlu membuat backup baru selepas aktiviti transaksi. Semua data transaksi anda dapat diciptakan oleh backup tunggal anda yang dijana secara automatik untuk anda.`,
      title: "Berapa kerap saya perlu membuat backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad micro SD. Benih bersama-sama dengan kata laluan pemulihan menjana dompet anda.",
      title: "Apa itu backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak. Sila simpan kad SD mikro dengan selamat, kerana ia mengandung benih yang tidak disenarai untuk memulihkan dompet anda.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad microSD.",
      title: "Apakah backup itu?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Apabila 2FA dihidupkan, semua transaksi perlu diluluskan pada telefon mudah alih yang dipasangkan untuk membelanjakan duit syiling. Di bawah tudung, nombor guna tunggal yang disulitkan dihantar ke aplikasi mudah alih, disahsulitkan di sana, dan kembali ke BitBox dengan menekan butang Terima. Komunikasi dengan peranti ini dilakukan melalui saluran antara telefon mudah alih dan aplikasi desktop ini yang ditubuhkan semasa berpasangan.

Pastikan anda telah membackup wallet anda dan pasangkan aplikasi mudah alih sebelum menghidupkan 2FA. Setelah dihidupkan, slot micro SD dan pasangan aplikasi mudah alih akan dimatikan. Mereka boleh diaktifkan semula dengan menetapkan semula BitBox, yang mana akan menghapuskan peranti tersebut.`,
      title: "Bagaimanakah Pengesahan Dua Langkah (2FA) berfungsi?"
    },
    disable2FA: {
      text: "Untuk mematikan 2FA, anda perlu menetapkan semula BitBox anda dan kemudian memulihkan wallet dari backupnya. Pastikan anda masih mempunyai kad micro SD dengan backup dan bahawa anda masih ingat kata laluan pemulihan anda. Kemudian tekan 'Tetapkan semula Peranti'. Lalu tetapkan kata laluan peranti baru dan pilih 'Atau Pulihkan Backup'. Pilih backup yang telah anda buat dari wallet, klik 'Pulihkan' dan masukkan kata laluan pemulihan yang anda gunakan semasa membuat dompet.",
      title: "Bagaimanakah saya dapat mematikan Pengesahan Dua Langkah (2FA)?"
    },
    ejectBitbox: {
      text: "Anda boleh mencabut BitBox bila-bila masa tanpa perlu mengklik ikon 'Selamat Lepaskan Perkakasan' terlebih dahulu.",
      title: "Bagaimana saya dapat menarik keluar BitBox?"
    },
    ejectSD: {
      text: "Anda dapat menyingkirkan micro SD kad dari BitBox kapanpun selama anda tidak menciptakan atau memulihkan sebuah backup",
      title: "Bagaimana saya dapat mengeluarkan kad micro SD?"
    },
    hiddenWallet: {
      text: "Ia adalah wallet kedua pada peranti yang sama yang dilindungi oleh kata laluan peranti dan kata laluan pemulihan yang berlainan, yang boleh anda gunakan untuk tujuan penafian yang munasabah. Dikeranakan penggunaan benih backup yang sama untuk wallet biasa dan tersembunyi anda, tiada tambahan backup diperlukan.",
      title: "Apa itu wallet tersembunyi?"
    },
    legacyHiddenWallet: {
      text: "Mula-mula klik butang di bawah (tersedia jika BitBox dikunci dengan kata laluan peranti utama dan 2FA dinyahdayakan), kemudian pasang kembali Bitbox dan buka dengan kata laluan peranti tersembunyi anda.",
      title: "Bagaimanakah saya dapat mengakses legacy wallet tersembunyi?"
    },
    pairing: {
      text: "Selepas memuat turun aplikasi mudah alih kami untuk iOS atau Android, anda dapat menubuhkan saluran selamat antara aplikasi mudah alih dan aplikasi ini dengan mengimbas kod QR yang dipaparkan. Setelah diimbas, ikut arahan dalam aplikasi mudah alih.",
      title: "Bagaimana memasangkan dengan selamat telefon anda"
    }
  },
  cointracking: {
    text: 'Klik butang "Eksport" dan buka folder muat turun di mana anda akan menemui eksport CSV. Kemudian klik pautan di bawah, muat naik fail CSV BitBox anda dan import data untuk menggunakannya untuk pengurus portfolio CoinTracking anda dan untuk membuat laporan cukai anda.',
    title: "Bagaimana untuk mengimport urus niaga saya ke dalam CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Baca lebih lanjut mengenai semakan ketulenan"
      },
      text: "BitBoxApp menjalankan semakan pengesahan pada BitBox02 untuk mengesahkan sama ada peranti itu tulen. Semakan dilakukan secara tempatan dan tidak bersambung ke mana-mana pelayan.",
      title: "Bagaimanakah semakan ketulenan berfungsi?"
    },
    name: {
      text: "Ini adalah nama dompet dan sandaran anda. Nama itu digunakan untuk sandaran masa hadapan dan boleh digunakan untuk membantu membezakan antara dompet yang berbeza. Ia boleh ditukar pada bila-bila masa tetapi ambil perhatian bahawa sandaran yang dibuat sebelum perubahan masih akan menggunakan nama sebelumnya.",
      title: "Apakah nama BitBox02 digunakan?"
    },
    "secure-chip": {
      link: {
        text: "Baca lebih lanjut mengenai cip selamat"
      },
      text: "Maklumat ini menunjukkan nombor model cip selamat, cip paling terkini ialah ATECC608B dengan ciri keselamatan yang dipertingkatkan berbanding model lama.",
      title: "Mengapa tunjukkan model cip selamat?"
    }
  },
  receive: {
    address: {
      text: `Berikan kepada orang lain untuk menghantarkan anda beberapa syiling.
(Sentiasa sahkan alamat secara mandiri, contohnya dengan panggilan telefon.)`,
      title: "Apa yang boleh saya lakukan dengan alamat?"
    },
    addressChange: {
      text: "Selepas alamat digunakan dalam sebuah transaksi, alamat baru akan ditambah ke senarai untuk menggantikannya. Setiap masa terdapat 20 alamat yang belum digunakan dalam senarai.",
      title: "Bila alamat berubah?"
    },
    addressFormats: {
      text: "Secara lalai, jenis alamat ialah Segwit Asli. Jenis alamat ini digunakan secara meluas oleh dompet/pertukaran lain dan memberikan anda kadar yuran terbaik untuk transaksi harian. Walau bagaimanapun, anda juga boleh memilih untuk menghantar kepada Taproot (Bitcoin sahaja), yang merupakan jenis alamat terbaharu, tetapi mungkin belum disokong secara meluas lagi. Sebagai alternatif, jika anda menghadapi masalah menghantar kepada Native Segwit (jenis lalai), anda boleh cuba bertukar kepada jenis alamat Wrapped Segwit yang lebih lama yang mungkin serasi dengan lebih banyak dompet/pertukaran.",
      title: 'Bilakah saya menggunakan "Tukar jenis alamat"?'
    },
    howVerify: {
      text: "Klik ikon BitBox pada bar sisi di sebelah kiri dan lihat bahagian Pemasangan. Panduan akan dikemas kini dan anda boleh terus mengikuti arahan dari sana.",
      title: "Bagaimana saya dapat mengesahkan alamat dengan selamat?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda menghantar syiling ke alamat BitBox anda, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menerima?"
    },
    why20: {
      text: 'Semasa permulaan apl menjana alamat yang diperoleh daripada benih anda untuk melihat sama ada mereka telah menerima dana. Memandangkan apl boleh menjana bilangan alamat yang hampir tidak terhingga, ia boleh menghabiskan masa bertahun-tahun untuk menentukan baki. Untuk mengehadkan carian ini ia berhenti selepas ia melihat 20 alamat yang tidak pernah menerima dana. Ini ialah "had jurang" dan 20 ialah piawaian de-facto walaupun bilangannya adalah sewenang-wenangnya. Ini ialah 20 alamat yang boleh anda pilih.',
      title: "Mengapa hanya 20 alamat?"
    },
    whyMany: {
      text: "Untuk sebab-sebab privasi dan keselamatan, anda tidak perlu menyerahkan alamat yang sama dua kali. Klik 'Berikut' untuk mendapatkan alamat baru untuk tujuan yang berbeza. Anda boleh menjana hingga 20 alamat dalam satu masa. Semua alamat diperoleh dari biji backup tunggal anda. (Bayangkan alamat seperti nombor invois.)",
      title: "Mengapa terdapat banyak alamat?"
    },
    whyVerify: {
      text: "Salah satu sebab untuk membeli wallet hardware seperti BitBox ialah anda tidak boleh mempercayai komputer anda kerana permukaan serangan yang besar. Oleh itu, anda tidak boleh mempercayai komputer anda untuk menjana dan memaparkan alamat yang sahih. Butang untuk mengesahkan alamat dengan selamat membuat BitBox menghantar alamat ke telefon mudah alih yang dipasangkan, dari mana anda juga boleh mengimbas dan mengesahkan kod QR.",
      title: "Mengapa saya perlu mengesahkan alamat dengan selamat?"
    }
  },
  send: {
    change: {
      text: "Perubahan akan dikembalikan ke alamat Taproot jika anda mempunyai sekurang-kurangnya satu Taproot UTXO. Jika anda menggunakan kawalan syiling, perubahan akan dikembalikan ke alamat Taproot jika terdapat sekurang-kurangnya satu Taproot UTXO antara UTXO yang dipilih. Dalam semua kes lain, perubahan dikembalikan ke alamat Segwit Asli.",
      title: "Bagaimanakah output perubahan ditentukan?"
    },
    fee: {
      text: `Yuran ini didasarkan pada saiz data transaksi dan bukan jumlahnya. Sasaran yuran dikira oleh algoritma pengiraan yuran Bitcoin Core untuk setiap keutamaan rangkaian yang anda pilih. Mereka ditunjukkan jika mereka mempunyai nilai yang berbeza dari sasaran di bawah.
Ekonomi: 24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)
Rendah: 12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)
Normal: 6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)
Tinggi: 2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)
(Blok mengambil purata sepuluh minit untuk Bitcoin (2.5 minit di Litecoin) untuk melombong dan beban rangkaian mungkin berbeza-beza untuk tempoh di atas.)`,
      title: "Bagaimanakah bayaran ditentukan?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda membuat transaksi, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menghantar?"
    },
    priority: {
      text: "Semakin tinggi yuran yang anda bayar, semakin cepat transaksi anda disahkan oleh rangkaian.",
      title: "Apa itu keutamaan rangkaian?"
    },
    revert: {
      text: `Selepas sebuah transaksi ditandatangani dan dihantar (disiarkan ke rangkaian), ia tidak dapat lagi dipulangkan. Periksa ulang transaksi (termasuk yurannya) dengan teliti sebelum menandatangani!
Sekiranya anda tahu sang penerima dan dia akan menghantar jumlah yang sama (dikurang yuran transaksi) kepada anda, anda boleh menghantar kepadanya alamat penerima yang baru.`,
      title: "Dapatkah saya memulangkan transaksi?"
    },
    whyFee: {
      text: `Transaksi bersaing untuk disahkan oleh penambang. Pelombong memilih transaksi untuk dimasukkan ke dalam blok yang berdasarkan yuran mereka.
Miners mengundi untuk sejarah transaksi. Dikeranakan tidak ada pihak ketiga yang dipercayai untuk menguatkuasakan satu undi bagi setiap orang (yang merupakan titik keseluruhan blok), penambang mengundi transaksi dengan mengorbankan sumber yang mahal seperti daya pengkomputeran. Sebagai hadiah untuk kerja mereka, mereka boleh menuntut duit syiling yang baru dibuat dan yuran dari semua transaksi yang mereka sertakan.`,
      title: "Mengapa ada yuran rangkaian?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Jika anda berhasrat untuk menyambung ke nod anda sahaja apabila anda berada di rangkaian yang sama (cth. wifi rumah anda), maka menggunakan komunikasi rangkaian biasa sudah memadai.
Dalam kes ini, adalah dinasihatkan bahawa pelayan Electrum anda menyediakan sijil TLS untuk menyulitkan komunikasi.
Jika anda berhasrat untuk menyambung ke nod anda dari mana-mana sahaja, menggunakan Tor ialah pilihan yang lebih baik. Tiada sijil TLS diperlukan dalam kes itu.`,
      title: "Sekiranya saya menggunakan clearnet TCP, TLS atau Tor?"
    },
    instructions: {
      link: {
        text: "Panduan untuk menyambungkan nod anda"
      },
      text: "Untuk tutorial penuh, sila lawati panduan kami:",
      title: "Bagaimanakah cara saya menyambungkan BitBoxApp saya ke nod penuh saya sendiri?"
    },
    options: {
      text: `Terdapat pelbagai pilihan untuk menjalankan nod anda sendiri seperti membeli peranti siap, membina sendiri atau menjalankan Bitcoin Core.
Jika anda ingin menyambungkan BitBoxApp anda ke nod anda, pastikan ia menjalankan pelayan Electrum. Ini ialah program khusus yang membolehkan apl dompet berkomunikasi dengan nod penuh anda.
Pilihan yang disokong termasuk Electrs, Electrum Personal Server (EPS) atau Bitcoin Wallet Tracker (BTW).`,
      title: "Apakah pilihan yang ada untuk menjalankan nod?"
    },
    tor: {
      text: `Tor adalah singkatan kepada 'The Onion Router', iaitu perisian percuma dan sumber terbuka yang menawarkan banyak faedah privasi dan amat berguna apabila menggunakan Bitcoin.
Jika anda berhasrat untuk menyambung ke nod anda melalui Tor, pastikan Tor dipasang pada komputer anda dan kemudian dayakan Proksi Tor dalam tetapan BitBoxApp.
Pada kebanyakan sistem pengendalian terdapat dua cara untuk menjalankan Tor:
1. Pelayar Tor: muat turun dan buka Pelayar Tor. Ini akan membolehkan BitBoxApp menyambung ke rangkaian Tor dengan menetapkan port 9150 dalam tetapan proksi Tor.
2. Perkhidmatan latar belakang Tor: pasang daemon Tor, yang sentiasa berjalan di latar belakang. BitBoxApp kemudiannya boleh menyambung dengan menetapkan port 9050 dalam tetapan proksi Tor.`,
      title: "Apakah Tor, proksi Tor dan port mana yang harus saya gunakan?"
    },
    what: {
      text: "Adalah mungkin untuk menggerakkan dompet anda dengan nod penuh anda sendiri sebagai ganti menggunakan server Shift.",
      title: "Apakah ini?"
    },
    why: {
      text: `Menjalankan nod anda sendiri tidak perlu tetapi meningkatkan privasi dan mengurangkan keperluan untuk mempercayai orang lain.
Pertama, ini bermakna anda menggunakan Bitcoin secara lebih peribadi kerana BitBoxApp tidak akan menyambung ke pelayan kami untuk mengambil sejarah transaksi anda; sebaliknya ia akan mengambil maklumat tersebut daripada nod anda sendiri.
Kedua, menjalankan nod anda sendiri bermakna nod anda mengesahkan semua transaksi itu sendiri, memastikan peraturan konsensus dikuatkuasakan.`,
      title: "Mengapa saya perlu menjalankan nod saya sendiri?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (pendek kata 'sat') ialah unit terkecil Bitcoin. Satu Satoshi ialah seratus juta bitcoin (0.00000001 BTC). Ia dinamakan sempena pencipta Bitcoin, Satoshi Nakamoto.",
      title: "Apa itu Satoshi?"
    },
    servers: {
      text: `Aplikasi ini berkomunikasi dengan server Shift Crypto untuk memeriksa kemas kini, memuat transaksi, dan menghantar maklumat ke aplikasi mudah alih yang telah dipasangkan.
Di samping itu, ia mengambil kadar pertukaran terkini dari CoinGecko. (Penukaran dikira secara tempatan, tiada wang anda yang dihantar)`,
      title: "Server mana yang digunakan aplikasi ini?"
    }
  },
  title: "Panduan",
  toggle: {
    close: "Tutup panduan",
    open: "Panduan"
  },
  trackingModePortfolioChart: {
    text: "Pada desktop, tuding kursor pada carta. Pada mudah alih, pegang jari anda pada carta dan seret secara mendatar.",
    title: "Bagaimana untuk melihat nilai sejarah pada carta?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Anda perlu menetapkan semula peranti dan memulihkan wallet dari backup dengan menggunakan kata laluan pemulihan.",
      title: "Apa yang perlu saya lakukan jika saya lupa kata laluan peranti?"
    },
    reset: {
      text: "Anda telah memasukkan kata laluan peranti yang salah sebanyak 15 kali. Beberapa percubaan terakhir memerlukan sentuhan panjang pada peranti.",
      title: "Bagaimana menetapkan semula peranti?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Peranti mesti berkelip sekali apabila dimasukkan. Pastikan ia dimasukkan ke arah yang betul. Jika anda menghadapi masalah, sila hubungi kami melalui pautan di bawah.",
      title: "Peranti saya tidak diketahui"
    },
    getDevice: {
      link: {
        text: "Pesan sebuah BitBox"
      },
      text: "Anda boleh membeli BitBox di kedai online kami:",
      title: "Bagaimana saya boleh mendapatkan peranti?"
    },
    internet: {
      text: "Ya, sambungan internet diperlukan untuk menyegerakkan wallet, menghantar transaksi dan mendapatkan kadar pertukaran terkini.",
      title: "Apakah aplikasi ini memerlukan sambungan internet?"
    },
    lostDevice: {
      link: {
        text: "Pusat Backup"
      },
      text: "Anda boleh memulihkan akaun anda pada BitBox baru atau dengan pusat backup kami.",
      title: "Saya kehilangan peranti saya. Bagaimana sekarang?"
    },
    useWithoutDevice: {
      text: "Maaf, ini belum mungkin pada masa ini.",
      title: "Bolehkah saya menggunakan aplikasi tanpa peranti?"
    },
    welcome: {
      text: "Terima kasih kerana menggunakan aplikasi ini yang dibina oleh Shift Crypto dari Switzerland. Ia masih dalam versi beta dan kami menghargai apa-apa input yang anda perlu bagikan. Sila berikan maklum balas menggunakan pautan di bahagian bawah.",
      title: "Selamat datang ke aplikasi BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Jika anda menggunakan telefon/komputer baharu dengan BitBoxApp, maka anda perlu menyambung semula ke DApps. Anda kemudian akan melihat syiling anda pada dapp semula seperti biasa.",
      title: "Saya tidak melihat sambungan saya sebelum ini."
    },
    supportedNetworks: {
      text: "Pada masa ini, hanya mainnet Ethereum disokong menggunakan WalletConnect dalam BitBoxApp. Untuk menggunakan rantaian serasi EVM lain, sila gunakan dompet sambungan penyemak imbas Rabby.",
      title: "Apakah rangkaian yang disokong?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ialah protokol komunikasi untuk aplikasi web3. Ia membolehkan anda menyambung dengan mudah ke DApps berasaskan Ethereum dan dompet web tanpa menggunakan aplikasi pihak ketiga, yang amat berguna untuk pengguna Android BitBoxApp.",
      title: "Apakah itu WalletConnect?"
    }
  }
}, headerssync$b = {
  blocksSynced: "{{blocks}} blok telah disegerakkan"
}, hiddenWallet$b = {
  info1HTML: "Untuk tujuan penafian yang munasabah, wallet tersembunyi boleh dibuat dengan kombinasi kata laluan pemulihan dan kata laluan peranti yang <strong> berbeza </strong>.",
  info2HTML: "Tentukan kata laluan peranti dan kata laluan pemulihan yang anda mahu kaitkan dengan wallet tersembunyi anda di bawah ini. Kata laluan peranti dan kata laluan pemulihan mestilah <strong> berbeza </strong> daripada yang anda tentukan untuk wallet utama anda.",
  passwordLabel: "Kata laluan pemulihan tersembunyi",
  passwordPlaceholder: "Sila ulangi kata laluan pemulihan tersembunyi",
  pinLabel: "Kata laluan peranti tersembunyi",
  pinRepeatLabel: "Ulangi kata laluan peranti tersembunyi",
  pinRepeatPlaceholder: "Sila ulangi kata laluan peranti tersembunyi",
  success: "Dompet tersembunyi berjaya dibuat. Pasang ulang BitBox anda untuk membuka kuncinya."
}, initialize$b = {
  create: "Tetapkan kata laluan peranti",
  creating: "Menetapkan kata laluan peranti...",
  error: {
    e102: "Kata laluan peranti mestilah mengandung sekurang-kurangnya 4 aksara."
  },
  info: {
    description1: "Pilih kata laluan peranti anda. Ini akan digunakan untuk membuka kunci BitBox anda.",
    description2: "Anda boleh menggunakan nombor, huruf dan simbol. Kata laluan yang lebih panjang memberikan keselamatan yang lebih tinggi",
    description3: "Jika anda kehilangan kata laluan peranti, anda perlu menetapkan semula peranti anda dan memulihkan backup wallet anda.",
    subtitle: "Sekarang anda boleh menetapkan kata laluan peranti anda",
    title: "Memulakan peranti anda"
  },
  input: {
    label: "Kata laluan peranti",
    labelRepeat: "Ulangi kata laluan peranti",
    placeholderRepeat: "Sila ulangi kata laluan peranti"
  }
}, invalidFormat$b = "Format tidak sah", language$c = {
  title: "Pilih Bahasa"
}, legacyhiddenwallet$b = {
  disable: "Matikan Legacy Hidden Wallet",
  enable: "Aktifkan Legacy Hidden Wallet",
  successDisable: "Berjaya melumpuhkan legacy hidden wallet",
  successEnable: "Berjaya menyahaktifkan wallet legacy tersembunyi. Pasang semula BitBox anda dan masukkan kata laluan peranti tersembunyi untuk mengakses wallet legacy tersembunyi warisan."
}, loading$b = "memuatkan ...", manageAccounts$5 = {
  accountHidden: "Akaun ini telah disembunyikan daripada akaun watch-only anda sahaja. Untuk melihatnya semula, sila pasangkan BitBox02 anda.",
  editAccount: "Sunting",
  editAccountNameTitle: "Sunting nama akaun",
  noAccounts: "tiada akaun ditemui",
  settings: {
    hideTokens: "Sembunyikan token",
    showTokens: "Tunjukkan token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Tambah dan tunjukkan/sembunyikan akaun",
  title: "Urus akaun",
  watchAccount: "Tonton akaun",
  watchAccountDescription: "Akaun ini adalah sebahagian daripada akaun watch-only anda sahaja. Anda boleh menyembunyikannya daripada akaun jam tangan anda menggunakan togol."
}, mobile$6 = {
  usingMobileDataWarning: "Penggunaan data mudah alih: apl ini boleh memuat turun sehingga beberapa ratus megabait data pengepala blockchain selepas membuka kunci akaun. Sila sambung ke Wi-Fi untuk mengelak daripada menggunakan data mudah alih. Selepas menolaknya, mesej ini tidak akan ditunjukkan lagi."
}, newSettings$5 = {
  about: {
    appVersion: {
      title: "Versi aplikasi"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Kunci akses kepada aplikasi dengan kunci skrin/cap jari.",
      title: "Kunci skrin"
    },
    coinControl: {
      description: "Pilih UTXO yang merupakan sebahagian daripada transaksi untuk membantu meningkatkan privasi."
    },
    customFees: {
      description: "Membolehkan anda memasukkan yuran anda sendiri semasa menghantar."
    },
    torProxy: {
      description: "Sambungkan melalui Tor untuk privasi yang lebih baik."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Mata wang tambahan ini boleh ditogol pada halaman akaun anda.",
      title: "Mata wang aktif"
    },
    darkmode: {
      description: "Lihat BitBoxApp dalam mod gelap."
    },
    defaultCurrency: {
      description: "Pilih mata wang lalai anda",
      title: "Mata wang lalai"
    },
    hideAmounts: {
      description: "Memaparkan togol untuk menyembunyikan baki anda dan amaun untuk meningkatkan privasi anda apabila menggunakan apl di khalayak ramai.",
      hideAmounts: "Sembunyikan jumlah",
      showAmounts: "Tunjukkan jumlah",
      title: "Benarkan menyembunyikan jumlah"
    },
    language: {
      description: "Bahasa yang anda mahu BitBoxApp gunakan.",
      title: "Bahasa"
    },
    toggleSats: {
      description: "Dayakan atau lumpuhkan Satoshis."
    }
  }
}, note$7 = {
  input: {
    description: "(pilihan)",
    placeholder: "Tambah Nota…"
  },
  title: "Catatan"
}, notification$b = {
  newTxs_one: "{{count}} transaksi baru di: {{accountName}}",
  newTxs_other: "{{count}} transaksi baharu dalam: {{accountName}}"
}, pairing$b = {
  aborted: {
    text: "Pemasangan telah ditinggalkan oleh aplikasi mudah alih.",
    title: "Ditinggalkan"
  },
  button: "Pasangkan Aplikasi Mudah Alih",
  confirm: "Adakah anda pasti mahu memasangkan BitBox anda? Ambil perhatian bahawa selepas itu, telefon bimbit diperlukan untuk melakukan transaksi.",
  connectOnly: {
    button: "Sambungkan aplikasi mudah alih",
    title: "Imbas dengan aplikasi mudah alih kami dengan memilih item menu 'Sambung ke aplikasi desktop baharu'"
  },
  error: {
    text: "Ada yang salah. Sila mulakan lagi.",
    title: "Ada yang salah"
  },
  pullFailed: {
    text: "Gagal menarik mesej daripada telefon bimbit anda melalui pelayan geganti. Pelayan geganti mungkin berada di luar talian, sila hubungi sokongan.",
    title: "Pull gagal"
  },
  reconnectOnly: {
    button: "Sambung semula aplikasi mudah alih"
  },
  scanningFailed: {
    text: "Mudah alih tidak berjaya mengimbas mesej. Sila cuba lagi.",
    title: "Pengimbasan Gagal"
  },
  start: {
    hideAppQRCode: "Sembunyikan QR Code",
    revealAppQRCode: "Tunjukkan QR Code",
    step1: "Jika anda tidak mempunyai aplikasi mudah alih, anda boleh mengimbas kod QR untuk Apple App Store atau Google Play Store.",
    step2: "Imbas dengan aplikasi mudah alih kami, yang anda dapati di bawah nama 'Digital Bitbox 2FA' di kedai aplikasi untuk iOS dan Android:"
  },
  started: {
    text: "Kini sila ikuti arahan dalam aplikasi mudah alih.",
    title: "Hebat"
  },
  success: {
    text: "Selamat, anda berjaya memasangkan BitBox anda dengan aplikasi mudah alih!",
    title: "Berjaya"
  },
  timeout: {
    text: "Pemasanganan ini berakhir selepas dua minit. Mula semula jika anda masih mahu memasangkan aplikasi mudah alih.",
    title: "Berakhir"
  },
  title: "Memasang telefon bimbit"
}, passphrase$5 = {
  considerations: {
    button: "Pertimbangan sandaran",
    message: `Frasa laluan menambah lapisan perlindungan pada sandaran dompet anda (kad mikroSD atau perkataan pemulihan). Jika seseorang mempunyai akses kepada sandaran anda, mereka juga memerlukan frasa laluan untuk mengakses dompet anda.

Walau bagaimanapun, ini bermakna anda perlu <strong>kedua-dua frasa laluan + sandaran dompet</strong> untuk memulihkan dompet didayakan frasa laluan anda, sekiranya BitBox02 anda hilang atau rosak. Jika anda terlupa atau kehilangan frasa laluan anda, anda akan kehilangan akses kepada semua syiling pada dompet itu.

Apabila menyimpan frasa laluan anda, pertimbangkan untuk meletakkannya di lokasi yang berasingan daripada sandaran anda. Dengan cara itu jika seseorang menjumpai sandaran anda, mereka juga tidak menemui frasa laluan anda.`,
    title: "Pertimbangan sandaran"
  },
  disable: "Lumpuhkan frasa laluan",
  disableInfo: {
    button: "Lumpuhkan",
    message: `Selepas melumpuhkan frasa laluan, anda tidak lagi akan diminta untuk memasukkan frasa laluan selepas membuka kunci BitBox02 anda. Oleh itu, anda akan memasukkan dompet lalai anda.

Mana-mana syiling pada dompet frasa laluan anda masih ada pada dompet itu, namun anda tidak akan dapat mengaksesnya kerana selepas membuka kunci BitBox02 anda, anda akan membuka dompet lalai anda.

Untuk mengakses dompet frasa laluan anda sekali lagi, cukup dayakan semula ciri frasa laluan dan masukkan frasa laluan yang berkaitan selepas membuka kunci BitBox02.

<strong>Petua:</strong> Anda masih boleh memasukkan dompet asal anda dengan membiarkan frasa laluan kosong.`
  },
  enable: "Dayakan frasa laluan",
  error: {
    e104: "Menukar tetapan frasa laluan telah digugurkan."
  },
  how: {
    button: "Macam mana rupanya",
    message: `Frasa laluan tidak berfungsi seperti kata laluan yang anda gunakan. Jika anda tersalah taip frasa laluan anda, anda tidak akan dimaklumkan. Ini adalah kerana <strong>setiap frasa laluan mencipta dompet yang berbeza, namun sah</strong>. Ini bermakna anda boleh menggunakan berbilang frasa laluan untuk seberapa banyak dompet yang anda mahukan. Tetapi setiap dompet hanya boleh diakses apabila menaip frasa laluan yang sepadan.

Apabila memasang BitBox02 anda, anda akan digesa untuk kata laluan peranti seperti biasa. Selepas itu, anda akan diminta untuk memasukkan frasa laluan pada peranti.

Selepas memasukkan frasa laluan, anda akan ditunjukkan frasa laluan yang anda masukkan. Ini supaya anda boleh mengesahkan anda memasukkannya dengan betul.`,
    title: "Bagaimanakah ia berfungsi"
  },
  intro: {
    message: `Frasa laluan menyediakan lapisan keselamatan tambahan di atas dompet anda.
Mari belajar bagaimana ia berfungsi.`,
    title: "Sediakan frasa laluan"
  },
  progressDisable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>melumpuhkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  progressEnable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>membolehkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  successDisabled: {
    message: `Ungkapan laluan pilihan <strong>berjaya didayakan</strong>!
Anda akan diminta untuk memberikan frasa laluan mulai sekarang.`,
    messageEnd: "Sila pasang semula BitBox02 sekarang.",
    title: "Ungkapan laluan didayakan"
  },
  successEnabled: {
    message: `Ungkapan laluan pilihan <strong>berjaya dilumpuhkan</strong>!

Anda tidak akan diminta untuk memberikan frasa laluan lagi.`,
    messageEnd: "Sila pasang semula BitBox02 anda sekarang.",
    tips: "Petua",
    tipsList: [
      "Kami cadangkan menghantar sejumlah kecil ke dompet frasa laluan terlebih dahulu. Kemudian cabut dan pasang semula BitBox02 dan masukkan kata laluan dan frasa laluan anda. Jika anda memasukkan frasa laluan dengan betul, anda sepatutnya melihat syiling dalam dompet anda.",
      "Jika anda ingin memasukkan dompet asal anda tanpa frasa laluan, anda masih boleh melakukan ini dengan memasukkan apa-apa apabila digesa untuk memasukkan frasa laluan. Atau anda boleh melumpuhkan ciri frasa laluan."
    ],
    title: "Ungkapan laluan dilumpuhkan"
  },
  summary: {
    button: "Dayakan frasa laluan",
    title: "Ringkasan",
    understand: "Saya faham cara frasa laluan berfungsi dan risiko yang berkaitan dengannya.",
    understandList: [
      "Frasa laluan ialah lapisan keselamatan tambahan di atas sandaran anda.",
      "Memasukkan frasa laluan yang berbeza akan sentiasa menghasilkan dompet yang berbeza.",
      "Untuk memulihkan dompet anda yang anda perlukan <strong>kedua-dua frasa laluan dan sandaran</strong>.",
      "Jika anda terlupa frasa laluan anda, anda tidak lagi boleh mengakses syiling anda."
    ]
  },
  what: {
    button: "Ketahui cara ini berfungsi",
    message: `Dompet dicipta (berasal) daripada nombor rawak yang sangat besar, juga dikenali sebagai benih. Benih ini dicipta apabila anda mula-mula menyediakan BitBox02 anda dan disandarkan dengan kad microSD atau perkataan pemulihan. Sesiapa sahaja yang mempunyai akses kepada benih mempunyai kawalan penuh ke atas dana pada dompet itu.

Frasa laluan ialah <strong>rahsia pilihan</strong>, ditambah kepada benih. Apabila menggunakan frasa laluan, setiap frasa laluan mencipta dompet baharu berdasarkan benih + frasa laluan (rahsia pilihan). Frasa laluan boleh jadi apa-apa sahaja: huruf, perkataan, aksara khas atau malah boleh kosong. Dompet lalai sebenarnya berasal daripada benih + frasa laluan kosong.

Frasa laluan adalah sebahagian daripada standard BIP39, yang bermaksud ia serasi dengan semua dompet yang menyokong standard yang sama.`,
    title: "Apakah frasa laluan?"
  },
  why: {
    button: "Mengapa menggunakan frasa laluan",
    message: `BitBox02 melindungi benih daripada pengekstrakan daripada peranti itu sendiri, tetapi sandaran (kad mikroSD atau perkataan pemulihan) memberikan akses penuh kepada dompet. Itulah sebabnya ia harus disimpan di lokasi yang selamat!

Memandangkan frasa laluan mencipta dompet baharu menggunakan benih sedia ada anda, frasa laluan-dompet memerlukan kedua-dua anda <strong>sandaran DAN frasa laluan untuk memulihkan</strong>. Faedah ini ialah jika seseorang menemui sandaran anda, mereka masih memerlukan frasa laluan untuk mengakses dompet frasa laluan.

Selain itu, ciri frasa laluan membolehkan anda membuat berbilang dompet pada peranti yang sama, atau "dompet tersembunyi" sebagai tambahan kepada dompet lalai.`,
    title: "Mengapa menggunakan frasa laluan?"
  }
}, password$b = {
  show: "Tunjukkan {{label}}",
  warning: {
    caps: "AMARAN: kunci caps (⇪) diaktifkan",
    paste: 'untuk menampal teks, aktifkan "SHOW {{label}}"'
  }
}, random$c = {
  button: "Menjana Nombor Rawak",
  description: "BitBox anda telah menjana nombor rawak {{bits}}-bit berikut:"
}, receive$d = {
  changeScriptType: "Tukar jenis alamat",
  label: "Alamat anda",
  onlyThisCoin: {
    description: "Untuk menerima token lain, dayakannya dalam tetapan. Jika anda mendepositkan token lain, ia mungkin tidak boleh diakses.",
    warning: "Pastikan hanya menerima {{coinName}} pada alamat ini."
  },
  scriptType: {
    p2tr: "Akar Tunjang (format terbaharu)",
    p2wpkh: "Segwit asli (lalai)",
    "p2wpkh-p2sh": "Wrapped Segwit (format yang serasi)"
  },
  selectAccount: "Pilih akaun",
  showFull: "Tunjukkan dan sahkan alamat lengkap",
  taprootWarning: "Nota: Taproot ialah ciri Bitcoin baharu dan belum diterima pakai secara meluas. Dana yang diterima pada alamat Taproot mungkin tidak kelihatan dalam dompet jam tangan pihak ketiga sahaja. Banyak dompet dan pertukaran belum dapat dihantar ke alamat Taproot.",
  title: "Dapatkan syiling",
  verify: "Sahkan alamat dengan selamat",
  verifyBitBox01: "Sahkan alamat pada apl mudah alih",
  verifyBitBox02: "Sahkan alamat pada BitBox02",
  verifyInstruction: "Sila sahkan bahawa alamat berikut sepadan dengan yang dipaparkan pada peranti anda.",
  warning: {
    secureOutput: "Sila pasangkan BitBox anda dengan peranti mobile anda untuk menghidupkan pengesahan alamat selamat. Pergi ke 'Urus Peranti' pada bar sisi."
  }
}, reset$b = {
  description: "Semua data pada peranti akan dihapus. Itu termasuk Private Key anda!",
  notReset: "Peranti BELUM ditetapkan semula.",
  title: "Tetapkan semula peranti",
  understand: "Saya mempunyai backup dan mengetahui kata laluan pemulihan saya",
  understandBB02: "Saya mempunyai sandaran yang sah"
}, securityInformation$b = {
  create: {
    description1: "Sebelum menetapkan peranti anda, disarankan agar anda dalam persekitaran yang selamat.",
    description2: "Anda akan diminta untuk membuat dua kata laluan.",
    description3: "Yang pertama adalah <strong> kata laluan peranti </strong> yang digunakan untuk membuka peranti BitBox anda dan boleh diubah kemudian.",
    description4: "Yang kedua ialah <strong>kata laluan pemulihan</strong> yang digunakan untuk membuka wallet anda. Kata laluan ini tidak boleh diubah kemudian.",
    description5: "Wallet yang anda buat akan dibackupkan kepada fail pada kad micro SD yang disediakan. Ini boleh digunakan dalam kecemasan untuk memulihkan wang anda menggunakan <strong> kata laluan pemulihan </strong> anda.",
    title: "Maklumat Keselamatan"
  },
  restore: {
    description1: "Anda akan diminta untuk memasukkan kad micro SD yang digunakan untuk menyimpan backup.",
    description2: "Untuk memulihkan peranti, anda memerlukan kata laluan pemulihan anda.",
    description3: "Sila berhati-hati semasa memasukkan kata laluan pemulihan. Sebarang kata laluan yang anda masukkan akan membuat wallet yang sah. Jika anda memasukkan kata laluan yang salah, anda mungkin akan mendapatkan baki wallet yang tidak anda harapkan.",
    title: "Maklumat Keselamatan"
  }
}, seed$b = {
  agreements: {
    "funds-access": "Saya TIDAK akan dapat mengakses dana saya jika saya lupa kata laluan pemulihan saya",
    "password-change": "Saya TIDAK dapat menukar kata laluan pemulihan di kemudian hari",
    "password-required": "Kata laluan pemulihan diperlukan untuk memulihkan dompet dari backup"
  },
  create: "Buat Wallet",
  creating: "Membuat dompet",
  description: "Saya faham bahawa:",
  error: {
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e200: "Anda perlu memasukkan kad micro SD ke dalam BitBox anda untuk membuat wallet, agar backup boleh dibuat secara automatik."
  },
  info: {
    button: "Tetapkan kata laluan pemulihan sekarang",
    description1: "Masukkan kad micro SD ke dalam BitBox",
    description2: 'Pilih kata laluan pemulihan untuk wallet dan pilih "Tetapkan kata laluan pemulihan sekarang"',
    description3: "Backup ke kad micro SD dan kata laluan pemulihan anda adalah satu-satunya cara untuk mendapatkan semula wang anda, sekiranya peranti BitBox hilang atau dicuri.",
    description4: "Anda tidak dapat mengganti kata laluan pemulihan anda di kemudian hari tanpa memindahkan wang anda.",
    title: "Buat wallet baru"
  },
  password: {
    label: "Kata laluan pemulihan",
    repeatPlaceholder: "Ulangi kata laluan pemulihan"
  },
  walletName: {
    label: "Nama Wallet"
  }
}, seedRestore$b = {
  error: {
    e200: "Untuk memulihkan wallet dari backup memerlukan kad micro SD."
  },
  info: {
    description1: 'Masukkan kad micro SD ke BitBox dan klik "Teruskan"',
    description2: 'Pilih backup pada dan klik "Simpan semula"',
    description3: "Masukkan kata laluan pemulihan",
    description4: "Anda perlu mengesahkan untuk memahami bahawa kata laluan salah akan membuat dompet yang berbeza.",
    title: "Bagaimana cara memulihkan wallet dari backup"
  }
}, send$d = {
  abort: "Transaksi telah ditinggalkan.",
  address: {
    label: "Alamat Penerima",
    placeholder: "Masukkan alamat"
  },
  amount: {
    label: "Jumlah",
    placeholder: "Masukkan jumlah"
  },
  availableBalance: "Baki yang ada",
  button: "Tandatangan dan Hantar",
  coincontrol: {
    address: "Alamat",
    outpoint: "Outpoint",
    title: "Hantar dari Output"
  },
  confirm: {
    "selected-coins": "Syiling yang dipilih",
    title: "Sahkan Transaksi",
    total: "Jumlah"
  },
  error: {
    erc20InsufficientGasFunds: "Nampaknya anda tidak mempunyai Eter yang mencukupi untuk membayar transaksi ERC20 ini. Sila pastikan anda memegang cukup Eter dalam dompet anda",
    feeTooLow: "bayaran terlalu rendah",
    feesNotAvailable: "Tidak dapat menganggarkan bayaran",
    insufficientFunds: "Dana tidak mencukupi",
    invalidAddress: "alamat tidak sah",
    invalidAmount: "jumlah tidak sah",
    invalidData: "data tidak sah"
  },
  fee: {
    customPlaceholder: "Masukkan jumlah",
    label: "Yuran Rangkaian",
    placeholder: "Tidak tersedia"
  },
  feeTarget: {
    customLabel: "Kadar bayaran",
    customLabel_eth: "Harga gas",
    description: {
      economy: "24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)",
      economy_eth: "30 minit atau kurang",
      economy_ltc: "1 jam (24 blok)",
      high: "2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)",
      high_eth: "30 saat atau kurang",
      high_ltc: "5 minit (2 blok)",
      low: "12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)",
      low_eth: "5 minit atau kurang",
      low_ltc: "30 minit (12 blok)",
      normal: "6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)",
      normal_eth: "2 minit atau kurang",
      normal_ltc: "15 minit (6 blok)"
    },
    estimate: "Anggaran masa pengesahan:",
    label: {
      custom: "Adat",
      economy: "ekonomi",
      high: "tinggi",
      low: "rendah",
      normal: "normal"
    },
    placeholder: "Mengira bayaran anggaran ..."
  },
  maximum: "Hantar semua",
  maximumSelectedCoins: "Hantar syiling terpilih",
  noFeeTargets: "Anggaran kadar yuran tidak tersedia pada masa ini. Sila cuba sebentar lagi atau masukkan yuran tersuai.",
  priority: "Keutamaan",
  scanQR: "Imbas Kod QR",
  signprogress: {
    description: "Ini adalah transaksi yang mengandung banyak data. Untuk menandatangani transaksi dengan sepenuhnya, anda akan diminta untuk mengesahkan sebanyak {{steps}} kali.",
    label: "Kemajuan"
  },
  success: "Transaksi telah ditandatangani dan dihantar.",
  title: "Hantar syiling",
  toggleCoinControl: "Toggle Kawalan Syiling",
  transactionDetails: "Butiran transaksi"
}, settings$c = {
  about: "Tentang aplikasi",
  accounts: "Akaun",
  advancedSettings: "Tetapan lanjutan",
  appearance: "Penampilan",
  electrum: {
    add: "Tambah server",
    "add-server": "Tambah",
    check: "Periksa",
    checkFailed: "Gagal",
    checkSuccess: "Berhasil menubuhkan sambungan ke {{host}}",
    checking: "Memeriksa",
    "download-cert": "Muat turun sijil jauh",
    "remove-server": "Hapus",
    removeConfirm: "Hapus {{server}}?",
    reset: "Tetapkan semula kepada tetapan standard",
    resetConfirm: "Apakah anda mahu menyingkirkan semua server dan memasang server standard?",
    servers: "Server",
    step1: "1",
    "step1-text": "Masukkan titik akhir.",
    step2: "2",
    "step2-text": "Masukkan sijil dari rantai sijil server. Secara alternatif, muat turun sijil jauh dan bandingkan secara visual.",
    "step2-text-tcp": "Anda boleh melangkau langkah ini jika anda tidak mahu menggunakan TLS.",
    step3: "3",
    "step3-text": "Semak sambungan dan tambahkan server.",
    step4: "4",
    "step4-text": "Mulakan semula wallet anda. Jika anda tidak menyingkirkan server standard, nod anda akan ditambah sebagai redundansi.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Hidupkan kawalan syiling",
    electrum: {
      description: "Anda boleh menyambung ke nod penuh Electrum anda sendiri.",
      title: "Sambung nod penuh anda sendiri"
    },
    fee: "Dayakan yuran tersuai",
    setProxyAddress: "Tetapkan alamat proksi",
    title: "Tetapan Pakar",
    useProxy: "Dayakan proksi tor",
    useSats: "Paparkan nilai BTC dalam Satoshis"
  },
  header: {
    home: "Rumah"
  },
  info: {
    "out-of-date": "Kemas kini baharu tersedia",
    title: "info",
    "up-to-date": "Apl anda adalah terkini",
    version: "Versi Apl"
  },
  restart: "Sila mulakan semula BitBoxApp untuk perubahan berkuat kuasa.",
  services: {
    title: "Perkhidmatan"
  },
  success: "Sila cabut dan pasang kembali BitBox agar perubahan dapat berlaku.",
  title: "Tetapan"
}, setup$b = "Menetapkan peranti", sidebar$c = {
  buy: "Beli kripto",
  device: "Urus Peranti",
  leave: "Tinggalkan",
  settings: "Tetapan"
}, success$i = {
  create: {
    info1: "Dompet anda telah dibackupkan dengan selamat ke kad micro SD. Tarik keluar kad micro SD dan simpan dengan selamat.",
    info2: "Anda telah membuat kata laluan peranti yang selamat yang dapat membuka BitBox.",
    info3: "Anda telah membuat kata laluan pemulihan yang selamat untuk wallet anda yang dapat membuka wang anda dan mengembalikan backup anda.",
    summary: "Berikut adalah ringkasan dari apa yang telah anda lakukan",
    title: "Berjaya"
  },
  getstarted: "Bermula",
  restore: {
    summary: "Anda telah berjaya memulihkan wallet dari backup anda.",
    title: "Berjaya"
  }
}, transaction$c = {
  confirmation: "Pengesahan",
  details: {
    activity: "Aktiviti",
    address: "Alamat",
    amount: "Jumlah",
    date: "Tarikh",
    fiat: "Fiat",
    fiatAmount: "Jumlah Fiat",
    fiatAtTime: "Fiat pada masa transaksi",
    status: "Status",
    type: "taip"
  },
  explorer: "ID Transaksi",
  explorerTitle: "Buka dalam blok Explorer luaran",
  fee: "Yuran",
  fiatHistorical: "Sejarah",
  gas: "Gas",
  note: {
    edit: "Edit nota",
    save: "Simpan nota"
  },
  pending: "Transaksi Menunggu",
  size: "Saiz",
  status: {
    complete: "lengkap",
    failed: "Gagal",
    pending: "Yang belum selesai"
  },
  tx: {
    received: "Diterima kepada",
    sent: "Dihantar kepada"
  },
  vsize: "Saiz maya",
  weight: "Berat"
}, transactions$b = {
  errorLoadTransactions: "Terdapat ralat semasa memuatkan urus niaga",
  placeholder: "Belum ada transaksi."
}, unknownError$b = "Kesalahan yang tidak diketahui muncul: {{errorMessage}}", unlock$b = {
  description: "Masukkan kata laluan peranti anda untuk membuka peranti.",
  error: {
    e109_normal: "Kata laluan peranti salah. Masih ada {{remainingAttempts}} percubaan sebelum peranti diset semula.",
    e109_touch: "$t(unlock.error.e109_normal) Menahan butang sentuhan diperlukan pada log masuk berikutnya",
    e113: "Oleh kerana banyaknya percubaan masuk, menahan butang sentuhan selama 4 saat diperlukan pada log masuk berikutnya ."
  },
  input: {
    label: "Kata laluan peranti",
    placeholder: "Masukkan kata laluan peranti anda"
  },
  unlocking: "Membuka ..."
}, upgradeFirmware$c = {
  button: "Tingkatkan firmware",
  description: "Apakah anda mahu menaik taraf Firmware dari versi {{currentVersion}} ke {{newVersion}}?",
  label: "Peningkatan firmware diperlukan untuk BitBox anda.",
  locked: "Untuk menaik taraf dari {{currentVersion}} ke {{newVersion}}, sila buat sentuhan panjang.",
  title: "Tingkatkan Firmware",
  unlocked: "Bootloader terbuka. Untuk meneruskan, sila:",
  unlocked1: "Tarik keluar dan pasang ulang BitBox anda",
  unlocked2: "LED akan menyala apabila BitBox anda terpasang kembali",
  unlocked3: "Tekan butang sentuh apabila LED menyala"
}, walletConnect$6 = {
  connect: {
    button: "Sambung",
    dappLabel: "Masukkan alamat URI dapp",
    invalidPairingUri: "Uri gandingan tidak sah"
  },
  dashboard: {
    allSessions: "Semua sesi",
    disclaimer: "Walletconnect ialah protokol untuk menyambung ke Dapps berasaskan Ethereum. Dapps ini dijalankan oleh perkhidmatan pihak ketiga, jadi hanya sambungkan kepada dapps yang anda percayai dan pastikan anda sentiasa mengetahui perkara yang anda tandatangani semasa membuat transaksi.",
    newConnection: "Sambungan baharu",
    noConnectedSessions: "Tiada akaun disambungkan ke mana-mana dapp pada masa ini."
  },
  invalidPairingChain: "Ralat dalam meluluskan gandingan. Sila pastikan anda menggunakan salah satu rangkaian yang disokong: {{chains}}",
  pairingRequest: {
    approve: "Luluskan Sambungan",
    reject: "Tolak",
    title: "Permintaan sambungan baharu daripada"
  },
  pairingSuccess: "Dapp berjaya disambungkan. Anda boleh teruskan di laman web dapp.",
  signingRequest: {
    account: "Akaun",
    chain: "Rantai",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Gagal menghuraikan data",
    decodeError: "Gagal menyahkod mesej",
    method: {
      sendTransaction: "Tandatangan dan hantar transaksi",
      signMessage: "Tandatangan mesej",
      signTransaction: "Tandatangani transaksi",
      signTypedData: "Tandatangani data yang ditaip"
    },
    successfullySigned: "Permintaan berjaya ditandatangani",
    walletConnectRequest: "Permintaan WalletConnect"
  },
  useNewUri: "URI ini telah digunakan untuk mencuba sambungan. Sila gunakan URI baharu.",
  walletConnect: "WalletConnect"
}, warning$h = {
  receivePairing: "Sila pasangkan BitBox untuk membolehkan pengesahan alamat dengan selamat. Pergi ke 'Uruskan Peranti' pada bar sisi.",
  sdcard: "Pastikan kad micro SD disimpan berasingan dari BitBox, kecuali jika anda mahu mengurus backup.",
  sendPairing: "Sila pasang BitBox untuk mengesahkan butiran transaksi dengan selamat. Pergi ke 'Urus Peranti' di bar sisi."
}, welcome$b = {
  connect: "Sambungkan BitBox02",
  getStarted: "Mari mulakan dengan memasang perisian tegar pada BitBox02 anda.",
  insertBitBox02: "Untuk BitBox02, sila ketik peranti untuk meneruskan.",
  insertDevice: "Sila sambungkan peranti anda untuk memulakan",
  title: "Selamat datang"
}, appTranslationsMS = {
  account: account$b,
  accountInfo: accountInfo$b,
  accountSummary: accountSummary$b,
  addAccount: addAccount$c,
  aopp: aopp$5,
  app: app$b,
  auth: auth$5,
  backup: backup$b,
  bb02Bootloader: bb02Bootloader$b,
  bitbox: bitbox$b,
  bitbox02Interact: bitbox02Interact$b,
  bitbox02Settings: bitbox02Settings$b,
  bitbox02Wizard: bitbox02Wizard$b,
  blink: blink$b,
  bootloader: bootloader$b,
  button: button$f,
  buy: buy$7,
  changePin: changePin$b,
  chart: chart$7,
  checkSDcard: checkSDcard$b,
  clickHere: clickHere$b,
  confirm: confirm$d,
  confirmOnDevice: confirmOnDevice$b,
  connectKeystore: connectKeystore$5,
  darkmode: darkmode$6,
  device: device$b,
  deviceLock: deviceLock$b,
  deviceSettings: deviceSettings$b,
  deviceTampered: deviceTampered$b,
  dialog: dialog$c,
  error: error$7,
  fiat: fiat$d,
  footer: footer$d,
  generic: generic$7,
  genericError: genericError$b,
  goal: goal$b,
  guide: guide$c,
  headerssync: headerssync$b,
  hiddenWallet: hiddenWallet$b,
  initialize: initialize$b,
  invalidFormat: invalidFormat$b,
  language: language$c,
  legacyhiddenwallet: legacyhiddenwallet$b,
  loading: loading$b,
  manageAccounts: manageAccounts$5,
  mobile: mobile$6,
  newSettings: newSettings$5,
  note: note$7,
  notification: notification$b,
  pairing: pairing$b,
  passphrase: passphrase$5,
  password: password$b,
  random: random$c,
  receive: receive$d,
  reset: reset$b,
  securityInformation: securityInformation$b,
  seed: seed$b,
  seedRestore: seedRestore$b,
  send: send$d,
  settings: settings$c,
  setup: setup$b,
  sidebar: sidebar$c,
  success: success$i,
  transaction: transaction$c,
  transactions: transactions$b,
  unknownError: unknownError$b,
  unlock: unlock$b,
  upgradeFirmware: upgradeFirmware$c,
  walletConnect: walletConnect$6,
  warning: warning$h,
  welcome: welcome$b
}, account$a = {
  disconnect: "Verbinding verbroken. Opnieuw aan het verbinden...",
  export: "Exporteren",
  exportTransactions: "Transacties als CSV bestand naar de downloads map exporteren",
  fatalError: "Er is een onverwachte fout opgetreden",
  incoming: "Inkomende",
  initializing: "Blockchain wordt gesynchroniseerd",
  maybeProxyError: "De Tor Proxy staat ingeschakeld. Zorg ervoor dat deze correct werkt, of schakel de proxy-instelling uit.",
  reconnecting: "Verbinding verbroken, opnieuw aan het verbinden...",
  syncedAddressesCount: "{{count}} adressen gescand"
}, accountInfo$a = {
  address: "Adres",
  buyCTA: {
    buy: "Koop {{unit}}",
    buyCrypto: "Koop Crypto",
    information: {
      looksEmpty: "Het lijkt erop dat deze wallet leeg is.",
      start: "Begin door coins naar deze wallet te sturen, of direct vanuit de BitBoxApp te kopen."
    }
  },
  extendedPublicKey: "Uitgebreide publieke sleutel",
  label: "Accountinformatie",
  scriptType: "Script-type",
  title: "Accountinformatie",
  verify: "Verifieer op je adres",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy P2PKH uitgebreide publieke sleutel weergeven",
    p2tr: "Taproot weergeven",
    p2wpkh: "Native SegWit weergeven",
    "p2wpkh-p2sh": "Oude SegWit uitgebreide publieke sleutel weergeven"
  },
  xpubTypeInfo: "Op dit moment wordt nummer {{current}} van de {{numberOfXPubs}} {{scriptType}} uitgebreide publieke sleutels weergegeven"
}, accountSummary$a = {
  availableBalance: "Beschikbare balans",
  balance: "Balans",
  exportSummary: "Accounts als CSV bestand naar de downloads map exporteren",
  fiatBalance: "Fiat balans",
  name: "Accountnaam",
  noAccount: "Er zijn geen accounts om weer te geven",
  subtotalWithCoinName: "Totaal ({{coinName}})",
  title: "Mijn portfolio",
  total: "Totaal",
  transactionHistory: "Transactiegeschiedenis"
}, addAccount$b = {
  chooseName: {
    nextButton: "Account toevoegen",
    step: "Account benoemen",
    title: "Geef je account een naam"
  },
  selectCoin: {
    nextButton: "Volgende",
    step: "Coin selecteren",
    title: "Cryptovaluta selecteren"
  },
  success: {
    addAnotherAccount: "Voeg een account toe",
    message: "<strong>{{accountName}}</strong> is aan je accounts toegevoegd",
    nextButton: "Klaar",
    step: "Afgerond",
    title: "Account toegevoegd"
  },
  title: "Account toevoegen"
}, aopp$4 = {
  addressRequest: "Er wordt een ontvangstadres aangevraagd door {{host}}",
  addressRequestWithLogo: "vraagt een ontvangstadres aan",
  banner: "Adresaanvraag in behandeling",
  errorTitle: "Foutmelding tijdens adresaanvraag",
  labelAddress: "Adres",
  labelMessage: "Bericht",
  reverifyInfoText: "Adres verifiëren",
  signing: "Onderteken het bericht op je BitBox02 om door te gaan",
  success: {
    message: "Ga door op {{host}}",
    title: "Adres verzonden"
  },
  syncing: "Account aan het synchroniseren, even geduld",
  title: "Adresaanvraag"
}, app$a = {
  upgrade: "Er is een nieuwe versie van de app beschikbaar! Upgrade nu van versie {{current}} naar {{version}}>"
}, backup$a = {
  check: {
    checking: "Backup aan het controleren...",
    confirmTitle: "Controleer backup",
    notOK: "De backup komt NIET overeen met de wallet",
    ok: "Backup komt overeen met de wallet",
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      showLabel: "herstelwachtwoord"
    },
    success: "Backup geverifieerd:",
    title: "Controleer backup"
  },
  create: {
    alreadyExists: "Je hebt al een valide backup. Wil je deze opnieuw maken?",
    fail: "Backup is NIET gemaakt!",
    info: "Voer het herstelwachtwoord van de huidige wallet in.",
    name: {
      label: "Backup naam",
      placeholder: "Geef de backup een naam"
    },
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Voer alsjeblieft je herstelwachtwoord in"
    },
    title: "Creeër backup",
    verificationFailed: "Het herstelwachtworod komt NIET overeen met de huidige wallet. De backup is aangemaakt. Gebruik 'Check backup' om je herstelwachtwoord nogmaals te verifiëren."
  },
  description: "Selecteer <strong>wallet backup bestand</strong>",
  insert: "Voer de microSD kaart in om je backups te beheren",
  insertButton: "Ik heb de microSD kaart ingevoerd",
  list: "Jouw microSD kaart backups",
  noBackups: "Er zijn geen backups op deze microSD kaart aanwezig.",
  restore: {
    confirmTitle: "Backup herstellen",
    error: {
      e200: "microSD kaart niet gevonden",
      general: "Fout tijdens het herstellen van de backup"
    },
    password: {
      label: "Herstelwachtwoord of verborgen herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      repeatPlaceholder: "Herstelwachtwoord herhalen",
      showLabel: "Herstelwachtwoord"
    },
    restoring: "Backup aan het herstellen",
    selectedBackup: "De backup <strong>{{backupName}}</strong>, aangemaakt op {{createdDateTime}}, wordt hersteld",
    title: "Herstellen",
    understand: ""
  },
  showMnemonic: {
    description: `Je ziet zometeen de 24 herstelwoorden die de backup van je wallet vormen. Schrijf ze op papier op.
<strong>Sla ze niet digitaal op en neem er geen foto's van</strong>
<strong>Zeg de woorden niet hardop</strong>
<strong>Deze backup is niet beschermd met een wachtwoord</strong>
Achteraf word je gevraagd ieder woord te bevestigen`,
    title: "Herstelwoorden tonen"
  },
  title: "Backups beheren"
}, bb02Bootloader$a = {
  abort: "Terug - doe de update niet",
  abort_noUpgrade: "Breng me terug",
  advanced: {
    label: "Geavanceerde instellingen",
    toggleShowFirmwareHash: "Toon de firmware hash iedere keer tijdens het opstarten"
  },
  flipscreen: "Scherm omkeren",
  orientation: "Tekst op je BitBox ondersteboven?",
  success: "Upgrade voltooid! Verder in {{rebootSeconds}} seconden...",
  success_install: "Installatie voltooid! Verder in {{rebootSeconds}} seconden..."
}, bitbox$a = {
  error: {
    e10000: "Huidig apparaatwachtwoord incorrect",
    e10001: "Het veranderen van het wachtwoord is niet gelukt",
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e112: "Het verborgen apparaatwachtwoord kan niet hetzelfde zijn als het hoofdwachtwoord."
  }
}, bitbox02Interact$a = {
  confirmDate: "Bevestig de huidige datum op je BitBox02",
  confirmDateText: "Deze datum wordt gebruikt om je backup te maken.",
  confirmName: "Bevestig naam op je BitBox02",
  confirmWords: "Schrijf de {{amount}}",
  confirmWordsText: "Hierna vraagt de BitBox je om ieder woord te bevestigen zodat je zeker weet dat de backup correct is.",
  followInstructions: "Volg de instructies op je BitBox02",
  followInstructionsMnemonic: "Volg de instructies op je BitBox02 om te herstellen met je herstelwoorden.",
  followInstructionsMnemonicTitle: "Met herstelwoorden herstellen"
}, bitbox02Settings$a = {
  deviceName: {
    current: "Huidige naam",
    error: "Het is niet gelukt de naam in te stellen.",
    error_104: "Het instellen van de naam is afgebroken door de BitBox.",
    input: "BitBox02 naam",
    placeholder: "Nieuwe naam",
    title: "BitBox02 naam instellen"
  },
  gotoStartupSettings: {
    description: "",
    title: "Ga naar opstartinstellingen"
  }
}, bitbox02Wizard$a = {
  advanced: {
    button: "Geavanceerde opties",
    outOfDate: "Deze optie is niet beschikbaar voor deze firmware-versie",
    seed12WordInfo: "De hoeveelheid woorden kan niet veranderd worden nadat je de wallet hebt aangemaakt.",
    seed12WordLabel: "Seed met 12 ipv 24 herstelwoorden aanmaken",
    seed12WordText: 'De BitBox maakt standaard een backup met 24 herstelwoorden aan. Backups met zowel 12 als 24 woorden zijn in de praktijk veilig tegen "brute force" aanvallen. ',
    skipSDCardLabel: "MicroSD backup overslaan en herstelwoorden opschrijven",
    skipSDCardText: "Je hebt altijd de mogelijkheid om via de instellingen alsnog een microSD- of herstelwoord-backup te maken.",
    title: "Geavanceerde backup-opties"
  },
  attestationFailed: "Validiteitscheck niet gehaald. Dit kan gebeuren als de app opnieuw wordt opgestart terwijl de BitBox wachtte op input. Probeer de BitBox opnieuw te verbinden. Neem contact op met support@bitbox.swiss als dit probleem blijft voortbestaan.",
  backup: {
    point1: "Selecteer een backup op de microSD kaart",
    point2: "Stel een wachtwoord in voor je apparaat",
    restoreText: "Ok, laten we een backup herstellen!",
    text1: "Je BitBox02 wachtwoord is ingesteld en je wallet is aangemaakt. Nu gaan we je eerste backup instellen. Zorg dat je microSD kaart is ingevoerd in de BitBox02 en ga verder.",
    text2: "Volg de instructies op je BitBox om een backup te maken.",
    text3: "Verwijder de microSD kaart en sla hem op in een <strong>veilige locatie</strong> nadat je backup is aangemaakt. De inhoud van de microSD kaart is niet beveiligd met een wachtwoord. Voer je microSD kaart nooit in een ander apparaat dan je BitBox02 in.",
    userConfirmation1: "Ik zal mijn backup in een veilige locatie opslaan.",
    userConfirmation2: "Mijn backup is niet beveiligd met een wachtwoord. Iedereen die er toegang tot heeft, heeft toegang tot mijn wallet.",
    userConfirmation3: "Als ik mijn BitBox02 verlies of beschadig, is de backup mijn enige manier om weer toegang tot mijn wallet te krijgen.",
    userConfirmation4: "Als ik mijn BitBox02 én mijn backup verlies of beschadig, is mijn wallet permanent verloren.",
    userConfirmation5: "Ik moet mijn microSD kaart niet in een computer, telefoon, printer of ieder ander apparaat dan een BitBox02 invoeren.",
    userConfirmation5mnemonic: "Ik snap dat ik mijn herstelwoorden NOOIT in een computer, telefoon, printer of ieder ander apparaat dat geen BitBox is moet invoeren"
  },
  create: {
    button: "",
    info: "Dit zijn de stappen die je gaat nemen om je BitBox in te stellen:",
    inputTitle: "Walletnaam",
    point1: "Geef je BitBox een naam",
    point2: "Stel een wachtwoord voor je BitBox in",
    point3: "Maak een backup",
    text: "Ok, we gaan nu een nieuwe wallet aanmaken!"
  },
  createBackupAborted: "Backup afgebroken",
  createBackupFailed: "Het maken van een backup is niet gelukt, probeer het opnieuw.",
  initialize: {
    passwordText: "Gebruik de touch-sensors op je BitBox om een wachtwoord in te stellen.",
    passwordTitle: "Stel een wachtwoord in voor je BitBox.",
    text: "Je BitBox02 is gekoppeld. Stel hem in door te kiezen voor het maken van een nieuwe wallet, of het herstellen van een backup. <strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
    tip: "We raden je aan in een veilige omgeving door te gaan.",
    title: "Initializeer je BitBox"
  },
  insertSDCard: "<strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
  noPasswordMatch: "De wachtwoorden kwamen niet overeen, probeer het op nieuw.",
  pairing: {
    failed: "Koppeling niet bevestigd. Plug je BitBox opnieuw in.",
    paired: "Je hebt de volgende code op je BitBox bevestigd. Klik om door te gaan.",
    title: "Verifieer koppelcode",
    unpaired: "Er is een nieuwe BitBox02 gedetecteerd. Controleer dat onderstaande code overeenkomt met wat er op je BitBox staat"
  },
  restoreFromMnemonic: {
    e104: "Het herstellen is afgebroken",
    failed: "Herstel is niet gelukt, probeer het nog eens."
  },
  stepBackup: {
    beforeProceed: "Lees deze belangrijke veiligheidsoverwegingen voordat je verder gaat:",
    createBackup: "Je gaat nu een backup op je microSD kaart maken.",
    createBackupMnemonic: "Je gaat nu de herstelwoorden opschrijven"
  },
  stepBackupSuccess: {
    fundsSafe: "Houd rekening met het volgende om je crypto veilig te houden:",
    title: "Backup hersteld!"
  },
  stepConnected: {
    unlock: "Voer je BitBox02 wachtwoord in om te ontgrendelen."
  },
  stepCreate: {
    description: "Deze naam wordt gebruikt als apparaatnaam en voor de backup",
    nameLabel: "BitBox02 naam",
    namePlaceholder: "Mijn BitBox02",
    title: "Kies een naam voor je BitBox02",
    toastMicroSD: "Zorg dat je microSD kaart is ingevoerd in je BitBox02; deze wordt gebruikt om een backup van je wallet op te slaan."
  },
  stepCreateSuccess: {
    removeMicroSD: "Haal de microSD kaart uit je BitBox02 en bewaar deze in een veilige locatie.",
    storeMnemonic: "Bewaar je herstelwoorden op een veilige locatie",
    success: "Je backup is aangemaakt."
  },
  stepInsertSD: {
    insertSDCard: "Stop een microSD kaart in je BitBox02 om door te gaan.",
    insertSDcardTitle: "Voer microSD kaart in"
  },
  stepPassword: {
    e104: "Het instellen van een wachtwoord is afgebroken",
    title: "BitBox02 wachtwoord instellen",
    useControls: "Gebruik de touch-sensors op je BitBox02 om een wachtwoord in te voeren."
  },
  stepUninitialized: {
    create: "Ik wil een nieuwe BitBox02 instellen.",
    restore: "Ik wil de backup van een bestaande wallet herstellen.",
    restoreMicroSD: "Herstel met microSD kaart",
    restoreMnemonic: "Herstel met herstelwoorden",
    title: "Stel je BitBox02 in"
  },
  success: {
    text: `Gefeliciteerd! Je BitBox02 is nu klaar om te gebruiken.
Voor meer informatie over het gebruik van de BitBoxApp check je de applicatiehulp door op het icoon rechtsbovenin te klikken.`,
    title: "Je bent helemaal klaar!"
  }
}, blink$a = {
  button: "Knipperen"
}, bootloader$a = {
  button: "Firmwareupgrade uitvoeren",
  button_install: "Firmware installeren",
  progress: "Firmwareupgrade wordt uitgevoerd: {{progress}}%",
  progress_install: "Firmware wordt geïnstalleerd: {{progress}}%",
  success: "Upgrade voltooid! Plug je BitBox opnieuw in. Druk deze keer niet op de knop."
}, button$e = {
  abort: "Annuleren",
  back: "Terug",
  buy: "Koop",
  changepin: "BitBox-wachtwoord veranderen",
  check: "Backup controleren",
  continue: "Verder",
  copy: "Kopiëren",
  create: "Aanmaken",
  dismiss: "Sluiten",
  done: "Klaar",
  download: "Download",
  hiddenwallet: "Verborgen wallet aanmaken",
  next: "Volgende",
  ok: "OK",
  previous: "Vorige",
  receive: "Ontvangen",
  restore: "Herstellen",
  select: "Selecteren",
  send: "Verzenden",
  unlock: "Ontgrendelen",
  update: "Updaten",
  upgrade: "Upgraden"
}, buy$6 = {
  exchange: {
    bankTransfer: "Bankoverschrijving",
    bestDeal: "Beste deal",
    creditCard: "Creditcard",
    fast: "Snel",
    fee: "transactiekosten",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankoverschrijving: {{fee}}%",
          creditDebitCard: "Creditcard:  {{fee}}%",
          learnMore: "Lees meer over Moonpay",
          title: "Transactiekosten"
        },
        fullCurrenciesList: "Bekijk hier de hele Valutalijst",
        payment: {
          asteriskText: "* Niet beschikbaar voor inwoners van de VS",
          bankTransfer: "Bankoverschrijving*",
          bankTransferDetails: {
            pix: "PIX (Alleen in Brazilië)",
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          creditDebitCard: "Credit/debitkaart",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa en Maestro"
          },
          learnMore: "Zie meer details over betaalmethodes",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "Ondersteunt alle grote fiat-valuta: USD, EUR, CHF en meer"
      },
      pocket: {
        fees: {
          info: "Bankoverschrijving: {{fee}}%",
          title: "Transactiekosten"
        },
        learnMore: "Lees meer over Pocket",
        payment: {
          bankTransfer: "Bankoverschrijving",
          bankTransferDetails: {
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            sic: "Swiss Interbank Clearing (CHF-transacties alleen in CH/LI)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          bankTransferReccuring: "Hoe stel ik regelmatige aankopen in?",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "EUR, GBP en CHF worden ondersteund",
        verification: {
          info: "Vereist alleen identiteitsverificatie boven een dagelijks/jaarlijks limiet",
          link: "Vind de huidige limieten hier",
          title: "Identiteitsverificatie"
        }
      },
      region: {
        title: "Selecteer het land waarin je bankrekening is geregistreerd om de beschikbare opties te zien"
      }
    },
    noExchanges: "Sorry, er zijn geen exchanges beschikbaar in jouw regio",
    region: "Regio",
    selectRegion: "Niet aangegeven",
    title: "Koop {{name}}"
  },
  info: {
    continue: "Akkoord, verder",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Samen met MoonPay bieden we je een naadloze manier om {{name}} direct in de BitBoxApp te kopen. Het is met een paar kliks gedaan.",
        "MoonPay is een platform dat het snel en makkelijk maakt om {{name}} in meer dan 160 landen te kopen."
      ],
      payment: {
        details: "Je kunt via MoonPay direct {{name}} kopen met de volgende betaalmethodes. Credit- of debitcard aankopen zijn makkelijk en snel, maar zijn duurder omdat de transactie teruggedraaid kan worden. We raden aan om een bankoverschrijving te doen voor grotere hoeveelheden. De minimale kosten zijn 4 euro.",
        footnote: "Houd er rekening mee dat de wisselkoers die MoonPay aanhoudt anders kan zijn dan die in de BitBoxApp, waardoor de hoeveelheden kunnen verschillen.",
        table: {
          "1_description": "Laagste kosten, kan tot 3 werkdagen duren.",
          "1_method": "Bankoverschrijving (SEPA)",
          "2_description": "Hogere kosten, onmiddelijke aankoop",
          "2_method": "Credit- en debitcards",
          description: "Omschrijving",
          fee: "Kosten",
          method: "Methode"
        },
        title: "Betaalmethode en kosten"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "De BitBoxApp verzamelt geen data als je {{name}} koopt, de inkomende transactie wordt als gewone transactie behandeld. MoonPay moet wat persoonlijke data verzamelen om je hun diensten aan te bieden. Hun privacy policy legt in detail uit hoe die data behandeld wordt.",
        descriptionGeneric: "De BitBoxApp verzamelt geen informatie van je als je {{name}} koopt. De inkomende transactie wordt als een normale transactie behandeld. Onze partner-exchanges moeten echter wat informatie verzamelen om hun diensten te kunnen verlenen. Zie hun respectievelijke privacybeleid voor meer informatie over hoe ze met je data omgaan.",
        title: "Databescherming."
      },
      security: {
        description: "Als je {{name}} koopt via MoonPay, gebruik je een externe dienst. Deze dienst valt buiten het BitBox02 Beveiligings- en bedreigingsmodel en vertrouwt op de beveiliging van de omgeving waarin je de BitBoxApp draait.",
        descriptionGeneric: "Als je {{name}} koopt via een van onze partner-exchanges, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait.",
        link: "Beveiliging- en bedreigingsmodel",
        title: "Bedreigingsmodel"
      },
      title: "Welkom bij jouw one-stop-shop om {{name}} te kopen"
    },
    next: "Volgende",
    selectLabel: "Kies je account",
    selectPlaceholder: "Selecteer een coin",
    skip: "Niet nog eens weergeven",
    title: "Koop {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket's privacybeleid",
      p1: "De BitBoxApp verzamelt geen informatie van je als je bitcoin koopt. De inkomende transactie wordt als een normale transactie behandeld. Moet echter wat informatie verzamelen om hun diensten te kunnen verlenen. Pocket's privacybeleid legt in detail uit hoe ze met je data omgaan.",
      title: "Databescherming"
    },
    kyc: {
      link: "Lees de Pocket-FAQs",
      p1: "Pocket probeert KYC tot een minimum te beperken. Voor aankopen van minder dan 950EUR (1000 CHF) per dag, is het uploaden van identificatie-documenten niet nodig. Als je meer dan dit wilt kopen, zul je een gesprek met Pocket in moeten plannen om de benodigde KYC/AML-procedure te doorlopen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Je kunt bij Pocket direct bitcoin kopen met een simpele SEPA bankoverschrijving. De transactiekosten hiervoor zijn 1.5%, en de bitcoin wordt direct naar je BitBox gestuurd (zodra Pocket de bankoverschrijving heeft ontvangen - meestal dezelfde dag nog).",
      p2: "Let er op dat de wisselkoers die Pocket hanteert verschillend kan zijn dan die in de BitBoxApp wordt aangegeven, wat een klein verschil in de hoeveelheden kan opleveren.",
      title: "Betaalmethodes en transactiekosten"
    },
    previousTransactions: "Je deelt een bestaande en gebruikte account met Pocket. Als je dit doet kunnen ze je volledige transactiegeschiedenis en alle toekomstige transacties inzien. Wil je toch doorgaan?",
    security: {
      link: "BitBox02 beveiligings- en bedreigingsmodel",
      p1: "Als je bitcoin koopt via Pocket, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait. We werken echter samen met Pocket om de beveiliging te verbeteren door het adres waar je op ontvangt te controleren met een tweefactor-authenticatiemechanisme.",
      title: "Beveiligingsmodel"
    },
    usedAddress: "Het adres {{address}} is al gebruikt, probeer het opnieuw met een nieuw adres.",
    verifyBitBox02: "Verifieer alsjeblieft of het adres wat je via de mail is toegestuurd hetzelfde is als het adres dat op je BitBox wordt weergegeven. Als het kan, is het het beste om de email op een tweede apparaat te openen.",
    welcome: {
      p1: "Met Pocket kun je binnen een paar kliks direct in de BitBoxApp bitcoin kopen.",
      p2: "Pocket is een Zwitsers platform wat het makkelijk en snel maakt om bitcoin te kopen in bijna heel Europa (overal waar SEPA bankoverschrijvingen beschikbaar zijn).",
      p3: "Met Pocket kun je ook regelmatige aankopen doen door een herhaalopdracht in te stellen bij je bank, zodat je makkelijk een DCA (dollar-cost-averaging) spaarplan in kunt stellen.",
      title: "Welkom bij je one-stop-shop voor bitcoin-aankopen"
    }
  },
  title: "Koop {{name}}"
}, changePin$a = {
  newTitle: "Nieuw BitBox02 wachtwoord",
  oldLabel: "Huidig BitBox02 wachtwoord"
}, chart$6 = {
  dataMissing: "Datahistorie aan het verzamelen... even geduld.",
  dataUpdating: "Data aan het updaten...",
  filter: {
    all: "Alle",
    month: "Maand",
    week: "Week",
    year: "Jaar"
  }
}, checkSDcard$a = "microSD kaart aan het controleren", clickHere$a = "Klik hier", confirm$c = {
  abortInfo: "Klik om",
  abortInfoRedText: "annuleren",
  approveInfo: "Houd 4 seconden ingedrukt om te",
  approveInfoGreenText: "bevestigen",
  info: "Ga verder op je BitBox",
  infoWhenPaired: "Eerst op de gekoppelde telefoon en dan op je BitBox"
}, confirmOnDevice$a = "Bevestig op je BitBox", darkmode$5 = {
  toggle: "Donkere kleurstelling"
}, device$a = {
  appUpradeRequired: "Je BitBox wordt niet ondersteund door deze desktop applicatie. Download en installeer de laatste versie."
}, deviceLock$a = {
  button: "Stel tweefactor authenticatie (2FA) in",
  condition1: "Heb je een backup?",
  condition2: "Werkt de mobiele app verificatie?",
  condition3: "2FA stelt backups en app-koppelingen buiten werking. De BitBox moet worden gereset om 2FA uit te zetten!",
  confirm: "Stel tweefactor authenticatie (2FA) in",
  title: "Stel tweefactor authenticatie (2FA) in"
}, deviceSettings$a = {
  backups: {
    manageBackups: {
      description: "MicroSD kaart backup aanmaken of controleren."
    },
    showRecoveryWords: {
      description: "Herstelwoorden tonen en verifiëren."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "De BitBoxApp controleert of je apparaat echt is."
    },
    deviceName: {
      description: "Verander de naam van je apparaat."
    },
    securechip: {
      description: "Secure-chip modelnummer"
    },
    title: "Apparaatinformatie"
  },
  expert: {
    factoryReset: {
      description: "Zet je BitBox terug naar de fabrieksinstellingen - dit verwijdert de wallet uit je BitBox02!",
      title: "Terugzetten naar fabrieksinstellingen"
    },
    goToStartupSettings: {
      description: 'Ga naar de bootloader van de BitBox02. Je kunt hier het laten zien van de "firmware hash" inschakelen.'
    },
    passphrase: {
      description: "Zet de optionele passphrase aan of uit",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware-versie",
    newVersion: {
      label: "Beschikbare versie"
    },
    title: "Firmware",
    upToDate: "Je BitBox is up-to-date",
    upgradeAvailable: "Een nieuwe upgrade is beschikbaar",
    version: {
      label: "Versie"
    }
  },
  hardware: {
    attestation: {
      false: "Autentiteitscontrole mislukt",
      label: "Autentiteitscontrole",
      true: "Je hebt een autentieke BitBox02"
    },
    sdcard: {
      false: "Niet ingevoerd",
      label: "microSD kaart",
      true: "Ingevoerd"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Apparaatinformatie aan het verzamelen...",
  pairing: {
    lock: {
      false: "Uitgeschakeld",
      label: "Tweefactor authenticatie (2FA)",
      true: "Ingeschakeld"
    },
    mobile: {
      false: "Gesloten",
      label: "Mobiele app",
      true: "Open"
    },
    status: {
      false: "Niet gekoppeld",
      label: "Status",
      true: "Gekoppeld"
    },
    title: "Aan het koppelen"
  },
  secrets: {
    manageBackups: "Backups beheren",
    title: "Geheimen"
  }
}, deviceTampered$a = "Heb je een herstelwachtwoord gekregen bij de aankoop van je BitBox? Zo ja, moet je onmiddelijk stoppen en ons onmiddelijk contacteren. Shift zal je nooit een kant-en-klare wallet aanbieden of aanbevelingen doen voor je wachtwoorden.", dialog$b = {
  cancel: "Annuleren",
  confirm: "Bevestigen",
  confirmTitle: "Bevestiging"
}, error$6 = {
  accountAlreadyExists: "Deze account bestaat al",
  accountLimitReached: "Kan account niet toevoegen. Je hebt de maximale hoeveelheid accounts voor deze coin.",
  aoppCallback: "Er is een fout opgetreden tijdens het versturen van het adres naar {{host}}",
  aoppInvalidRequest: "Ongeldig verzoek.",
  aoppNoAccounts: "Er zijn geen accounts beschikbaar.",
  aoppSigningAborted: "Verzoek om adreseigenaarschap geannuleerd.",
  aoppUnknown: "Er is een onbekende fout opgetreden.",
  aoppUnsupportedAsset: "Dit token wordt niet ondersteund.",
  aoppUnsupportedFormat: "Er zijn geen accounts beschikbaar die de het verzochte adresformaat ondersteunen.",
  aoppUnsupportedKeystore: "Het verbonden apparaat kan voor deze crypto geen berichten ondertekenen.",
  aoppVersion: "Onbekende versie."
}, fiat$c = {
  default: "Standaard",
  setDefault: "Stel {{code}} in als standaard",
  title: "Valuta's"
}, footer$c = {
  appVersion: "App versie:"
}, generic$6 = {
  enabled_false: "Uitgeschakeld",
  enabled_true: "Ingeschakeld"
}, genericError$a = "Er is een fout opgetreden. Start de applicatie opnieuw op als je problemen tegenkomt.", goal$a = {
  buttons: {
    create: "Maak een nieuwe wallet aan.",
    restore: "Herstel een wallet met een backup"
  },
  paragraph: "Selecteer één van de volgende opties:",
  step: {
    1: {
      title: "Beveiligingsinformatie"
    },
    2: {
      description: "Stel een apparaatwachtwoord in",
      title: "Apparaat"
    },
    "3-create": {
      description: "Maak een nieuwe wallet aan",
      title: "Wallet"
    },
    "3-restore": {
      description: "met een backup",
      title: "Herstel"
    },
    "4-create": {
      title: "Samenvatting"
    },
    "4-restore": {
      title: "Samenvatting"
    }
  }
}, guide$b = {
  accountDescription: {
    text: "Je accountpagina laat je beschikbare balansen, en binnenkomende en uitgaande transacties zien. In de instellingen kun je meer informatie vinden over iedere accountsoort.",
    title: "Wat staat er op deze pagina?"
  },
  accountFiat: {
    text: "Ja. Je kunt op iedere 'ticker' klikken om door fiatvaluta te roteren. Je kunt de lijst van valuta's in de instellingen veranderen.",
    title: "Kan ik ook andere wisselkoersen weergeven?"
  },
  accountIncomingBalance: {
    text: "Binnenkomende transacties zijn een som van de hoeveelheden die naar je toe gestuurd zijn, maar nog geen bevestiging hebben van het netwerk.",
    title: "Wat zijn binnenkomende transacties?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Iedere xpub is gekoppeld aan het getoonde 'type': dit is "Native segwit (bech32)", "Wrapped segwit" of "Taproot" (alleen bij Bitcoin). Dit zijn scrypttypes die gebruikt worden door {{coinName}}. De BitBoxApp combineert ze door meerdere scripttypes in dezelfde account te ondersteunen. Omdat ieder scripttype een andere xpub heeft, heb je meerdere xpubs per account.

Als je altijd op het standaardadres ontvangt, heb je alleen de 'bech32' xpub nodig. Als je echter ook (handmatig) ontvangt op je compatibiliteitsadres, staan deze onder de "oudere Segwit" of "Taproot" uitgebreide publieke sleutel (xpub).`,
      title: "Waarom heb ik meerdere xpubs?"
    },
    privacy: {
      text: `Met de uitgebreide publieke sleutel vallen de volledige financiële geschiedenis, de balans van je account en alle eventuele toekomstige transacties te achterhalen. Met alleen de xpub heb je echter geen verzendcontrole over de coins.

Als je een xpub aan iemand geeft, moet je je ervan bewust zijn dat deze persoon of dit bedrijf alle transacties van dit account kan zien. Daarom is het handig om accounts waarvan je de xpub weggeeft maar voor één doel te gebruiken, en je andere financiën op een ander account te beheren. `,
      title: "Moet ik mijn xpub geheim houden?"
    },
    verify: {
      text: "Ja, het is altijd een goed idee om je xpub te dubbel-checken. Zeker als iemand anders met deze xpub adressen gaat genereren om je geld te sturen is het extra belangrijk. Je verifieert de xpub op je BitBox om er zeker van te zijn dat de xpub van jou is. Anders zullen alle transacties naar een verkeerd adres gaan. ",
      title: "Moet ik de xpub verifiëren op mijn BitBox?"
    },
    xpub: {
      text: `Een uitgebreide publieke sleutel (xpub) is de bron waaruit alle ontvangstadressen van een account gemaakt worden. 

Het wordt hier weergegeven voor geavanceerde gebruikers en voor ondersteuning van watch-only wallets zoals Electrum of Sentinel. Als je verschillende adrestypes gebruikt, noteer dan alle verschillende xpub-formaten in de watch-only wallet om al je coins te kunnen zien.

Let op dat nog niet alle externe wallets Taproot ondersteunen. `,
      title: "Wat is een uitgebreide publieke sleutel?"
    }
  },
  accountRates: {
    text: "We vernieuwen de wisselkoers iedere minuut gebaseerd op de wisselkoersen van CoinGecko.",
    title: "Welke wisselkoersen gelden er?"
  },
  accountReload: {
    text: "Dat is niet nodig. Je transactiegeschiedenis wordt automatisch geüpdatet.",
    title: "Kan ik de transactiegeschiedenis herladen?"
  },
  accountSendDisabled: {
    text: "De verzendknop wordt geactiveerd als de balans van dat account meer dan nul is.",
    title: "Waarom kan ik geen {{unit}} verzenden?"
  },
  accountSummaryAmount: {
    text: `De totale balans is de som van al je crypto-accounts, berekend met de wisselkoers van coingecko.com.
Let op: Gebruik je MyEtherWallet voor toekens die niet ondersteund worden door de BitBoxApp? Dan worden deze niet meegerekend in dit totaal.`,
    title: "Hoe wordt de totale balans berekend?"
  },
  accountSummaryDescription: {
    text: "Hier kun je de prestaties van je gehele portfolio gedurende verschillende tijdsbestekken bekijken. Een overzicht van je individuele crypto-accounts wordt onder de grafiek weergegeven.",
    title: "Wat zie ik op deze pagina?"
  },
  accountTransactionAttributesBTC: {
    text: `Grootte: De daadwerkelijke grootte van de transactie in bytes zoals berekend volgens de onderliggende blockchain.
Virtuele grootte: Dit bepaalt de netwerkkosten. Je bespaart op kosten als de virtuele grootte kleiner is dan de transactiegrootte.
Gewicht: Een nieuwe meeteenheid die geïntroduceerd is met Segwit om de grootte van transacties en blokken te evalueren. Iedere 'segregated witness' byte telt als één gewichtseenheid (weight unit), alle andere data telt als vier. In plaats van één megabyte is de grootte van een block nu vier miljoen weight units.`,
    title: "Hoe zit het met de Bitcoin-specifieke transactiedetails?"
  },
  accountTransactionAttributesGeneric: {
    text: `Bevestigingen: Je transactie is onbevestigd totdat een miner het toevoegt aan een block. Op dat moment heeft het één bevestiging. Ieder block wat daarna komt geeft jouw transactie een extra bevestiging. Over het algemeen vereisen winkels en andere mensen op het netwerk drie tot zes bevestigingen.
Transactie-ID: Een uniek identificatienummer waarmee je je transactie in een block explorer kunt opzoeken.
Transactiekosten: Miners worden betaald met transactiekosten, die ervoor moet zorgen dat ze jouw transactie in een block opnemen. Klik op 'verzenden' om hier meer over te leren.`,
    title: "Welke informatie vind ik in de transactiedetails?"
  },
  accountTransactionConfirmation: {
    text: "Een transactie die is uitgezondern naar het netwerk, maar nog geen bevestigingen heeft. ",
    title: "Wat is een transactie in afwachting?"
  },
  accountTransactionLabel: {
    text: "Dit is het adres waarop je coins hebt ontvangen of naartoe hebt verzonden. ",
    title: "Wat is het adres wat bij iedere transactie wordt weergegeven?"
  },
  accountTransactionTime: {
    text: "De transactiebevestigingstijd op de blockchain",
    title: "Wat is de tijd die wordt weergegeven?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin en Litecoin kunnen zoveel accounts hebben als je wilt. Na vijf accounts kun je pas een nieuwe toevoegen als de vorige account daadwerkelijk gebruikt is voor een transactie. Andere coins hebben een maximum van vijf accounts.",
      title: "Hoeveel accounts kan ik aanmaken?"
    },
    howtoAddTokens: {
      text: 'Tokens die gebruik maken van de ERC20 standaard worden aan een specifieke Ethereum-account gekoppeld. Om een token aan- of uit te zetten, open je het "Accounts beheren" scherm, klik je op je Ethereum account en schakel je de gewenste token in of uit.',
      title: "Hoe kan ik meer tokens toevoegen?"
    },
    moveFunds: {
      text: "Ja, maar omdat accounts onafhankelijk van elkaar zijn, moet je een reguliere transactie maken.",
      title: "Kan ik mijn coins tussen accounts verplaatsen?"
    },
    recoverAccounts: {
      text: "Ja, de BitBoxApp maakt accounts die voldoen aan breed gebruikte standaarden, zodat je accounts compatibel zijn met de meeste andere crypto-wallets.",
      title: "Kan ik mijn accounts in een andere wallet herstellen?"
    },
    whatAreAccounts: {
      text: "Je wallet kan meerdere accounts van dezelfde coin aanmaken. Accounts zijn handig als je verschillende 'rekeningen' wilt hebben om je financiën gescheiden te houden..",
      title: "Wat zijn accounts?"
    },
    whyIsThisUseful: {
      text: "Accounts zijn een goede manier om bijvoorbeeld de financiën van verschillende mensen of voor verschillende doeleinden te beheren omdat deze gescheiden gehouden worden in verschillende accounts. Je kunt ook de uitgebreide publieke sleutel (xpub) van één account met iemand anders delen zonder ook maar iets over je andere accounts aan diegene bloot te stellen. Dit zorgt ervoor dat je herhaaldelijk kunt ontvangen zonder een adres te hergebruiken, bijvoorbeeld om een salaris te ontvangen of regelmatig crypto te kopen.",
      title: "Waar is dit goed voor?"
    }
  },
  appendix: {
    link: "Neem contact met ons op!",
    text: "Nog een vraag?"
  },
  backups: {
    check: {
      text: "Het checken van je backup zorgt ervoor dat je kunt controleren of je een geldige backup hebt voor je huidige wallet. Het kan ook gebruikt worden om te controleren of je herstelwachtwoord nog klopt. Je kunt je hoofdherstelwachtwoord checken, of je verborgen herstelwachtwoord.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, maar je herstelwachtwoord is nodig om de wallet vanuit de seed phrase te herstellen.",
      title: "Kan ik de backup versleutelen?"
    },
    howOften: {
      text: "De backup wordt automatisch gegenereerd wanneer je een nieuwe wallet aanmaakt. Je hoeft alleen een nieuwe backup te maken als je microSD kaart kapot of kwijt is, of als je meerdere microSD kaarten als backup wilt gebruiken. Je hoeft geen nieuwe backup te maken nadat je een transactie hebt gedaan; alle transactiedata kan worden hersteld met de backup die aan het begin gemaakt is.",
      title: "Hoe vaak moet ik een nieuwe backup maken?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwoorden ('seed phrase') op een microSD kaart. De herstelwoorden samen met je herstelwachtwoord genereren je wallet.",
      title: "Wat is een backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "Met 'check backup' kun je verifiëren dat je een werkende backup hebt die overeenkomt met je huidige wallet.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, dit is niet mogelijk. Bewaar de microSD kaart op een veilige plek, omdat de onversleutelde herstelwoorden die je wallet kunnen herstellen hierop staan. Als je een wachtwoordbeveiliging wilt gebruiken, kun je de optionele wachtwoordfunctie inschakelen onder de geavanceerde instellingen. ",
      title: "Kan ik de backup versleutelen?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwachtwoorden op een microSD kaart.",
      title: "Wat is een backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Wanneer 2FA is ingeschakeld moeten alle (verzend-) transacties goedgekeurd worden met de gekoppelde mobiele telefoon. Dit is wat er onder de motorkap gebeurt: Een versleuteld bericht wordt naar de mobiele app gestuurd en ontgrendeld, waarna het teruggestuurd wordt naar de BitBoxApp als je op 'accepteren' klikt. Deze communicatie wordt gedaan via het kanaal dat opgezet wordt tussen de mobiele telefoon en de BitBoxApp tijdens het koppelen. 

Zorg dat je wallet gebackupt is en gekoppeld met de mobiele app voordat je 2FA inschakeld. Zodra dit gebeurd is worden de microSD poort en het koppelen met de mobiele app uitgeschakeld. Ze kunnen opnieuw ingeschakeld worden door de BitBox te resetten, wat ook je wallets verwijdert. `,
      title: "Hoe werkt tweefactor authenticatie (2FA)?"
    },
    disable2FA: {
      text: "Om 2FA uit te zetten moet je de BitBox resetten en herstellen middels je backup. Zorg ervoor dat je de microSD kaart met de backup nog hebt en dat je het herstelwachtwoord nog weet. Kies dan voor 'Reset BitBox' in de instellingen. Kies een nieuw apparaatwachtwoord en kies 'herstel een backup'. Selecteer de backup die je voor je wallet hebt gemaakt, klik op herstellen en voer het herstelwachtwoord in wat je hebt gekozen toen je de wallet aanmaakte.",
      title: "Hoe kan ik tweefactor authenticatie (2FA) uitschakelen?"
    },
    ejectBitbox: {
      text: "Je kunt de BitBox op ieder moment uit je apparaat halen, zonder dat je het eerst hoeft uit te werpen.",
      title: "Hoe kan ik de BitBox uitwerpen?"
    },
    ejectSD: {
      text: "Je kunt de microSD kaart op ieder moment handmatig uit je BitBox halen, zo lang je niet op dat moment een backup aan het maken of herstellen bent.",
      title: "Hoe kan ik de microSD kaart uitwerpen?"
    },
    hiddenWallet: {
      text: "Het is een tweede wallet op dezelfde BitBox, die beschermd wordt door aparte apparaat- en herstelwachtwoorden, die je kunt gebruiken om een gedeelte van je balans te verbergen. Dezelfde herstelwoorden / SD kaart backup wordt gebruikt voor je normale en verborgen wallet, dus je hebt geen extra backup nodig.",
      title: "Wat is een verborgen wallet?"
    },
    legacyHiddenWallet: {
      text: "Klik eerst op onderstaande button (die beschikbaar is als de BitBox ontgrendeld is en 2FA niet ingeschakeld staat), plug daarna je BitBox opnieuw in en ontgrendel hem met je verborgen apparaatwachtwoord.",
      title: "Hoe krijg ik toegang tot mijn verborgen legacy wallet?"
    },
    pairing: {
      text: "Nadat je de mobiele BitBoxApp hebt gedownload voor iOS of Android, kun je de weergegeven QR-code scannen. Dit zet een beveiligd kanaal op tussen de mobiele telefoon en deze applicatie. Zodra je de QR-code gescand hebt, kun je de instructies op je telefoon volgen.",
      title: "Hoe koppel ik mijn mobiele telefoon?"
    }
  },
  cointracking: {
    text: "Klik op de 'exporteren' knop en open de downloads map. Hier vind je een .csv export bestand. Klik op onderstaande link, upload je BitBox .csv bestand en importeer de data om het in je CoinTracking porfoliomanager te gebruiken en je belastingaangifte te genereren.",
    title: "Hoe importeer ik mijn transacties in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lees meer over de authenticiteits-check"
      },
      text: "De BitBoxApp doet een authenticiteitscheck om er zeker van te zijn dat je BitBox echt is. Deze check wordt lokaal uitgevoerd en benodigt geen verbinding naar externe servers.",
      title: "Hoe werkt de authenticiteitscheck?"
    },
    name: {
      text: "Dit is de naam van je wallet en van je backup. De naam wordt gebruikt voor toekomstige backups en kan ook gebruikt worden om verschillende wallets te onderscheiden. Deze kun je op ieder moment veranderen, maar backups die je hiervoor gemaakt hebt zullen nog steeds de oude naam gebruiken.",
      title: "Waar wordt de BitBox02-naam voor gebruikt?"
    },
    "secure-chip": {
      link: {
        text: "Lees meer over de secure chip"
      },
      text: "Deze informatie toont het modelnummer van de secure chip. De het nieuwste model is de ATECC608B, die verbeterde beveiligings-eigenschappen heeft vergleken met oudere modellen.",
      title: "Waarom wordt het secure chip modelnummer getoond?"
    }
  },
  receive: {
    address: {
      text: "Je kunt dit adres aan anderen geven, zodat ze transacties naar je kunnen doen. Controleer altijd met de verzender of zij wel het juiste adres hebben ingevuld!",
      title: "Wat moet ik met een adres?"
    },
    addressChange: {
      text: "Zodra je een transactie doet, wordt er automatisch een nieuw adres gegenereerd en toegevoegd aan de lijst. Zo heb je altijd 20 adressen beschikbaar die nog nooit coins hebben ontvangen.",
      title: "Wanneer veranderen mijn adressen?"
    },
    addressFormats: {
      text: "Het standaardadrestype is Native Segwit. Dit adrestype is het meest gebruikt door andere wallets en exchanges en zorgt ervoor dat je de laagste transactiekosten betaalt. Je kunt er echter voor kiezen om bitcointransacties naar Taproot-adressen te doen, wat het nieuwste adresformaat is, maar nog niet overal ondersteund wordt. Als je problemen ondervind met het versturen naar een Native Segwit adres, kun je ervoor kiezen om een Wrapped Segwit adres te gebruiken, wat met vrijwel alle andere wallets en exchanges compatibel is. ",
      title: 'Wanneer moet ik "Adrestype wijzigen" gebruiken?'
    },
    howVerify: {
      text: `Voor de BitBox01 klik je op het BitBox icoon in het zijmenu aan de linkerkant en ga je naar de 'koppelen'-sectie. Als je daar bent, updatet de hulp en kun je de instructies daar verder volgen.
Op de BitBox02 kun je adressen direct op het apparaat verifiëren tijdens het proces van verzenden of ontvangen.`,
      title: "Hoe kan ik veilig mijn adressen verifiëren?"
    },
    plugout: {
      text: "Nee, zodra je je coins naar het adres hebt verstuurd, kun je je BitBox gewoon weer opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het ontvangen?"
    },
    why20: {
      text: "Tijdens het opstarten genereert de app verschillende adressen op basis van je seed om te kijken of ze iets hebben ontvangen. Omdat de app een praktisch oneindige hoeveelheid adressen kan genereren, kan de app ook oneindig doorgaan met adressen controleren tijdens het opstarten. Om dit te voorkomen, stopt de app met controleren als het 20 adressen achter elkaar heeft gezien die niets ontvangen hebben. Dit is het tussenruimte-limiet en 20 is hiervoor de arbitraire standaard. Dit zijn de 20 adressen waar je uit kunt kiezen.",
      title: "Waarom slechts 20 adressen?"
    },
    whyMany: {
      text: "Om je privacy en veiligheid te bewaken, moet je nooit twee keer hetzelfde adres gebruiken; bekijk een adres als een factuurnummer. Als je een adres hebt gebruikt, kun je op de rechterpijl klikken voor een nieuw adres. Je kunt tot 20 adressen tegelijkertijd aanmaken. Alle adressen zijn gegenereerd op basis van je backup herstelwoorden.",
      title: "Waarom zo veel adressen?"
    },
    whyVerify: {
      text: `Je zou je computer niet moeten vertrouwen om adressen te genereren en weer te geven. Je computer heeft een veel hoger aanvalsrisico dan een hardware wallet, waardoor de kans op virussen en malware vele malen hoger is. 
Voor de BitBox01 klik je op de knop om een veilig adres naar de gekoppelde telefoon te sturen, die je ook kun gebruiken om de QR-code te scannen en verifiëren. Voor de BitBox02 kun je het adres direct op het display verifiëren. `,
      title: "Waarom moet ik mijn adressen verifiëren. "
    }
  },
  send: {
    change: {
      text: "Het wisselgeld wordt naar een Taproot-adres gestort als je ten minste één andere Taproot-UTXO hebt. Als je coin control gebruikt, wordt het wisselgeld naar een Taproot adres gestort als er zich ten minste één Taproot-UTXO tussen de geselecteerde UTXOs bevindt. In alle andere gevallen wordt het wisselgeld naar een Native Segwit adres gestort. ",
      title: "Hoe wordt het wisselgeldadres bepaald?"
    },
    fee: {
      text: `De netwerkkosten worden geschat op basis van de grootte van de transactie en niet de hoeveelheid. De netwerkkosten worden berekend door het algoritme van Bitcoin Core op basis van de prioriteit die je zelf kiest. Deze worden weergegeven als ze een andere waarde hebben dan de waardes hieronder:
Budget: 24 blokken (ongeveer 4 uur voor Bitcoin, 1 uur voor Litecoin)
Laag: 12 blokken (ongeveer 2 uur voor Bitcoin, 30 minuten voor Litecoin)
Normaal: 6 blokken (ongeveer 1 uur voor Bitcoin, 15 minuten voor Litecoin)
Hoog: 2 blokken (ongeveer 20 uur voor Bitcoin, 5 minuten voor Litecoin)
(Een Bitcoin-blok kost gemiddeld 10 minuten en een Litecoin-blok 2,5 minuut om te minen. De belasting op het netwerk en dus je bevestigingstijd kan drastisch variëren.)`,
      title: "Hoe worden de netwerkkosten bepaald?"
    },
    plugout: {
      text: "Nee, zodra je een transactie hebt gemaakt, hoef je je BitBox niet ingeplugd te laten. Je kunt je BitBox direct na verzenden veilig opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het verzenden?"
    },
    priority: {
      text: "Hoe hoger de netwerkkosten die je bereid bent te betalen, hoe sneller je transactie bevestigd zal worden door het netwerk.",
      title: "Wat is de netwerkprioriteit?"
    },
    revert: {
      text: "Zodra een transactie is ondertekend en verzonden (uitgezonden naar het netwerk), kan het niet teruggedraaid worden. Verifieer daarom altijd alle onderdelen van de transactie (inclusief de netwerkkosten) voordat je hem ondertekent! Als je de ontvanger kent, kun je ze middels een ontvangstadres vragen om de transactie handmatig terug te sturen.",
      title: "Kan ik een transactie terugdraaien?"
    },
    whyFee: {
      text: "Transacties concurreren met elkaar om bevestigd te worden door een miner. Miners kiezen de transacties die ze in hun blokken stoppen op basis van welke transacties het meeste betalen. Miners bepalen welke transacties er opgenomen worden in de blockchain. Omdat er geen vertrouwde derde partijen zijn om te bepalen welke transacties valide zijn, doen miners dit door middel van computerkracht op te offeren. Als beloning voor hun werk, kunnen ze nieuwe Bitcoin en de netwerkkosten van alle transacties die ze hebben uitgekozen opeisen.",
      title: "Waarom zijn er netwerkkosten?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Als je je eigen node wilt verbinden die zich op hetzelfde netwerk bevindt (bv. je wifinetwerk thuis), kun je zonder problemen normale netwerkcommunicatie gebruiken. Het is aan te raden dat je Electrum-server een TLS-certificaat heeft om de communicatie te versleutelen.
Als je op andere locaties dan alleen thuis met je node wilt verbinden, is Tor de betere optie. In dit geval is een TLS-certificaat niet nodig.`,
      title: "Moet ik clearnet TCP, TLS of Tor gebruiken?"
    },
    instructions: {
      link: {
        text: "Instructies om je eigen node te koppelen."
      },
      text: "Voor een volledige tutorial kun je onze instructies op deze webpagina volgen:",
      title: "Hoe verbind ik mijn BitBoxApp met mijn eigen full node?"
    },
    options: {
      text: `Er zijn meerdere opties om je eigen node te draaien, zoals een kant-en-klaar apparaat te kopen, er zelf een te bouwen of Bitcoin Core te draaien op je PC. Als je de BitBoxApp wilt verbinden met je eigen node, moet je ervoor zorgen dat het beschikt over een Electrum server. Dit is een programma dat toegeweid is aan het verbinden van wallets met je full node.
Ondersteunde opties zijn Electrs, Electrum Personal Server of Bitcoin Wallet Tracker.`,
      title: "Welke opties heb ik om zelf een full node te draaien?"
    },
    tor: {
      text: `Tor staat voor 'The Onion Router'. Het is een gratis, open source programma dat je extra privacy biedt en heel nuttig is in combinatie met Bitcoin. 
Als je met je node wilt verbinden via Tor, moet je ervoor zorgen dat Tor is geïnstalleerd op je computer en dat de Tor Proxy is ingeschakeld in de instellingen van de BitBoxApp.
Op de meeste besturingssystemen zijn er twee manieren om Tor te gebruiken:
1. Tor Browser: download en open de Tor Browser. Dit zorgt ervoor dat de BitBoxApp kan verbinden met het Tor netwerk als je poort 9150 hebt ingesteld in de Tor Proxy instellingen.
2. Tor achtergronddienst: installeer de Tor daemon, die altijd in de achtergrond draait. De BitBoxApp kan dan verbinden door poort 9050 in te stellen in de Tor Proxy instellingen.`,
      title: "Wat zijn Tor en de Tor Proxy, en welke poort moet ik gebruiken?"
    },
    what: {
      text: "Het is mogelijk om je wallet te verbinden met je eigen full node, in plaats van het gebruiken van de Shift servers.",
      title: "Wat is dit?"
    },
    why: {
      text: `Het draaien van je eigen node is niet noodzakelijk, maar het verhoogt wel je privacy en verlaagt de noodzaak om anderen te vertrouwen.
Het betekent dat je Bitcointransacties meer privé zijn, omdat de BitBoxApp niet meer verbindt met onze servers om je transactiegeschiedenis op te halen. In plaats daarvan wordt die informatie van je eigen node gehaald.
Ten tweede zorgt het draaien van je eigen node ervoor dat je alle transacties zelf verifieerd en controleert of de consensusregels gevolgd worden `,
      title: "Waarom zou ik mijn eigen node moeten draaien?"
    }
  },
  settings: {
    sats: {
      text: 'Een Satoshi (of "sat" in het kort) is de kleinst mogelijke eenheid op het bitcoinnetwerk. Een satoshi is één honderdmiljoenste bitcoin (0.00 000 001 BTC). Het is vernoemd naar de maker van Bitcoin, Satoshi Nakamoto.',
      title: "Wat is een Satoshi?"
    },
    servers: {
      text: `De app communiceert met de Shift Crypto servers om op updates te controleren, je transacties te laden en informatie te versturen naar je gekoppelde mobiele apps. 
De app haalt ook de huidige wisselkoersen van CoinGecko. Alle conversies worden lokaal gedaan, zodat je balansen nooit naar derde partijen verstuurd worden.
Voor Ethereum en ERC20 tokens worden de Etherscan.io APIs gebruikt.`,
      title: "Met welke servers verbindt deze app?"
    }
  },
  title: "Gids",
  toggle: {
    close: "Gids sluiten",
    open: "Gids"
  },
  trackingModePortfolioChart: {
    text: "Op de desktop kun je je muiscursor over de grafiek heen bewegen. Op je telefoon gebruik je je vinger om horizontaal over de grafiek te slepen.",
    title: "Hoe kan ik de historische waardes op de grafiek inzien?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Je moet het apparaat resetten en de wallet herstellen middels een backup en het herstelwachtwoord.",
      title: "Wat moet ik doen als ik het wachtwoord van mijn BitBox vergeten ben?"
    },
    reset: {
      text: "Door 15 keer een verkeerd apparaatwachtwoord in te voeren. Tijdens de laatste paar keer moet je de knoppen langer ingedrukt houden.",
      title: "Hoe reset ik mijn BitBox?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Het apparaat zou één keer moeten knipperen als het ingevoerd wordt. Zorg dat het met de juiste kant boven ingevoerd is. Als je het probleem niet opgelost krijgt, kun je contact met ons opnemen via onderstaande link.
De BitBox01 is niet te koppelen met mobiele telefoons. Gebruik alsjeblieft de BitBoxApp op een PC om je BitBox01 te verbinden.`,
      title: "Mijn BitBox01 wordt niet herkend."
    },
    getDevice: {
      link: {
        text: "Bestel een BitBox"
      },
      text: "Je kunt een BitBox op onze webwinkel bestellen:",
      title: "Hoe kan ik aan een BitBox komen?"
    },
    internet: {
      text: "Ja, een internetverbinding is nodig om de wallet te synchroniseren, transacties te versturen en de laatste wisselkoersen op te halen.",
      title: "Heeft deze app een internetverbinding nodig?"
    },
    lostDevice: {
      link: {
        text: "Backup-center"
      },
      text: "Je kunt je accounts herstellen met een nieuwe BitBox of via ons backup-center",
      title: "Ik ben mijn BitBox kwijt, wat nu?"
    },
    useWithoutDevice: {
      text: "Dat is op dit moment niet mogelijk.",
      title: "Kan ik de app ook zonder BitBox gebruiken?"
    },
    welcome: {
      text: "Bedankt voor het gebruiken van deze app, gemaakt door Shift Crypto in Zwitserland. We waarderen alle feedback die je voor ons hebt! Die kun je delen door op de link onderaan het scherm te klikken.",
      title: "Welkom in de BitBoxApp!"
    }
  }
}, headerssync$a = {
  blocksSynced: "{{blocks}} blokken gesynchroniseerd"
}, hiddenWallet$a = {
  info1HTML: "Je kunt een verborgen wallet aanmaken met een <strong>andere</strong> combinatie van apparaatwachtwoord & herstelwachwoord, om plausibele ontkenning mogelijk te maken.",
  info2HTML: "Voer het apparaatwachwoord en het herstelwachtwoord dat je met je verborgen wallet wilt associëren hieronder in. Het apparaatwachtworod en het herstelwachtwoord <strong>moeten</strong> van je hoofdwallet verschillen.",
  passwordLabel: "Verborgen herstelwachtwoord",
  passwordPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  pinLabel: "Verborgen apparaatwachtwoord",
  pinRepeatLabel: "Herhaal je verborgen herstelwachtwoord",
  pinRepeatPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  success: "Verborgen wallet aangemaakt. Voer je BitBox opnieuw in om het te ontgrendelen."
}, initialize$a = {
  create: "Stel apparaatwachtwoord in",
  creating: "Apparaatwachtwoord instellen...",
  error: {
    e102: "Het apparaatwachtwoord moet ten minste vier karakters bevatten."
  },
  info: {
    description1: "Kies je apparaatwachtwoord. Dit wordt gebruikt om je BitBox te ontgrendelen.",
    description2: "Je kunt nummers, letters en symbolen gebruiken. Langere wachtwoorden bieden je meer veiligheid.",
    description3: "Als je je apparaatwachtwoord kwijtraakt moet je je BitBox resetten met je backup.",
    subtitle: "Nu ga je je apparaatwachtwoord instellen.",
    title: "Apparaat initialiseren..."
  },
  input: {
    label: "Apparaatwachtwoord",
    labelRepeat: "Herhaal apparaatwachtwoord",
    placeholderRepeat: "Bevestig apparaatwachtwoord"
  }
}, invalidFormat$a = "Ongeldig format", language$b = {
  title: "Selecteer je taal"
}, legacyhiddenwallet$a = {
  disable: "Verborgen legacy wallet uitschakelen",
  enable: "Verborgen legacy wallet inschakelen",
  successDisable: "Verborgen legacy wallet uitgeschakeld",
  successEnable: "Verborgen legacy wallet ingeschakeld. Plug je BitBox opnieuw in en voer het verborgen apparaatwachtwoord in om toegang te krijgen tot je verborgen legacy wallet."
}, loading$a = "laden...", manageAccounts$4 = {
  editAccount: "Bewerken",
  editAccountNameTitle: "Accountnaam bewerken",
  noAccounts: "Geen accounts gevonden",
  settings: {
    hideTokens: "Tokens verbergen",
    showTokens: "Tokens tonen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Accounts toevoegen en tonen/verbergen",
  title: "Accounts beheren"
}, mobile$5 = {
  usingMobileDataWarning: `Mobiel datagebruik: deze app kan een paar honderd megabyte aan blockchaindata downloaden als je een account opent. Verbind met een wifinetwerk om je mobiele datagebruik te beperken.

Dit bericht wordt niet nogmaals getoond.`
}, newSettings$4 = {
  about: {
    appVersion: {
      title: "App versie"
    }
  },
  advancedSettings: {
    coinControl: {
      description: "Selecteer welke UTXOs onderdeel van een transactie zijn om privacy te verbeteren."
    },
    customFees: {
      description: "Dit laat je de transactiekosten van een overboeking precies bepalen."
    },
    torProxy: {
      description: "Verbind via Tor voor betere privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Je kunt door alle valuta heen wisselen op de acccountpagina.",
      title: "Actieve valuta"
    },
    darkmode: {
      description: "Verander het uiterlijk van de BitBoxApp naar een donkere kleurstelling."
    },
    defaultCurrency: {
      description: "Selecteer je standaardvaluta",
      title: "Standaardvaluta"
    },
    language: {
      description: "De taal waarin je de BitBoxApp wilt gebruiken.",
      title: "Taal"
    },
    toggleSats: {
      description: "Satoshis in- of uitschakelen."
    }
  }
}, note$6 = {
  input: {
    description: "(optioneel)",
    placeholder: "Notitie toevoegen"
  },
  title: "Notitie"
}, notification$a = {
  newTxs_one: "Nieuwe transactie in: {{accountName}}",
  newTxs_other: "{{count}} nieuwe transacties in: {{accountName}}"
}, pairing$a = {
  aborted: {
    text: "Het koppelen van de mobiele app is afgebroken.",
    title: "Afgebroken"
  },
  button: "Mobiele app koppelen",
  confirm: "Weet je zeker dat je je BitBox wilt koppelen? Hierna heb je je mobiele telefoon nodig om een transactie uit te voeren.",
  connectOnly: {
    button: "Mobiele app verbinden",
    title: "Scan met de mobiele app door in het menu 'Nieuwe desktop-app verbinden' te kiezen."
  },
  error: {
    text: "Er is iets misgegaan. Probeer het opnieuw.",
    title: "Fout"
  },
  pullFailed: {
    text: "We konden het bericht niet van je telefoon ophalen door de relay server. De server kan offline zijn, neem contact op met de klantenservice.",
    title: "Pull niet gelukt"
  },
  reconnectOnly: {
    button: "Mobiele app opnieuw verbinden"
  },
  scanningFailed: {
    text: "Telefoon kon het bericht niet scannen. Probeer het opnieuw.",
    title: "Scan niet gelukt"
  },
  start: {
    hideAppQRCode: "QR-code verbergen",
    revealAppQRCode: "QR-code tonen",
    step1: "Als je de mobiele app niet hebt, kun je de QR-code voor de App Store of Play store scannen, afhankelijk van welke telefoon je hebt. ",
    step2: "Scan met onze mobiele app, die je kunt vinden als 'Digital BitBox 2FA' in de iOS en Android app stores."
  },
  started: {
    text: "Volg de instructies op de mobiele app",
    title: "Fantastisch"
  },
  success: {
    text: "Gefeliciteerd, je hebt je BitBox met de mobiele app gekoppeld!",
    title: "Gelukt"
  },
  timeout: {
    text: "Het koppelen is na twee minuten automatisch gestopt. Begin opnieuw als je de mobiele app nog steeds wilt koppelen. ",
    title: "Time-out"
  },
  title: "Mobiele koppeling"
}, passphrase$4 = {
  considerations: {
    button: "Backup overwegingen",
    message: `De passphrase biedt je extra bescherming voor je (microSD of herstelwoord-) backup. Als iemand toegang heeft gekregen tot je backup, hebben ze nu ook de passphrase nodig om toegang te krijgen tot je wallet.

Dit betekent echter dat je <strong>zowel de passphrase als de backup</strong> nodig hebt om je wallet te herstellen wanneer je BitBox02 kapot gaat of verloren raakt. Als je je passphrase verliest of vergeet, raak je de toegang tot alle coins op die wallet kwijt.

Als je je passphrase ergens opslaat, zou je dit op een andere plek dan je backup moeten doen. Op die manier heeft iemand die je backup vindt niet ook toegang tot je passphrase.`,
    title: "Backup overwegingen"
  },
  disable: "Passphrase uitzetten",
  disableInfo: {
    button: "Uitzetten",
    message: `Nadat je de passphrase hebt uitgezet, word je niet langer gevraagd om een passphrase in te voeren nadat je je BitBox02 hebt ontgrendeld. Je voert dus je standaard wallet in.

Eventuele coins die nog op je passphrase wallet staan, zullen daarop blijven staan, en je kunt hier niet meer bij; je BitBox vraagt immers niet meer om de passphrase en opent direct je standaard wallet. Om weer toegang te krijgen, kun je simpelweg de passphrase opnieuw inschakelen en de passphrase weer invoeren bij het opstarten.

<strong>Tip:</strong> Je kunt ook met een passphrase toegang tot je standaardwallet krijgen door niks in te voeren als er om je passphrase gevraagd wordt.`
  },
  enable: "Passphrase inschakelen",
  error: {
    e104: "Het veranderen van de passphrase-instelling is geannuleerd."
  },
  how: {
    button: "Hoe het er uit ziet",
    message: `Een passphrase werkt niet zoals andere wachtwoorden waar je aan gewend bent. Als je je passphrase verkeerd invoerd, krijg je hier geen melding van. Dit komt omdat <strong>iedere passphrase een nieuwe, valide wallet maakt</strong>. Dit betekent dat je zo veel verschillende wallets kunt aanmaken als je wilt door een andere passphrase in te voeren. Je kunt weer toegang krijgen tot iedere wallet door de bijbehorende passphrase in te voeren.

Als je je BitBox02 invoert, zul je zoals je gewend bent om het gewone wachtwoord gevraagd worden. Daarna kun je een passphrase invoeren.

Nadat je de passphrase hebt ingevoerd, kun je nog een keer checken wat je precies hebt ingevoerd, zodat je zeker weet dat het was wat je verwachtte.`,
    title: "Hoe werkt het"
  },
  intro: {
    message: `Een passphrase zorgt voor extra beveiliging voor je wallet.
Dit is hoe het werkt.`,
    title: "Passphrase instellen"
  },
  progressDisable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>uitschakelen</strong>",
    title: "Bevestig op je BitBox"
  },
  progressEnable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>aanzetten</strong>.",
    title: "Bevestig op je BitBox"
  },
  successDisabled: {
    message: `De passphrase <strong>staat nu aan</strong>!
Vanaf nu zul je tijdens het opstarten om een passphrase worden gevraagd.`,
    messageEnd: "Plug alsjeblieft de BitBox opnieuw in.",
    title: "Passphrase aangezet"
  },
  successEnabled: {
    message: `De passphrase <strong>staat nu uit</strong>!
Vanaf nu zul je niet langer tijdens het opstarten om een passphrase worden gevraagd.`,
    messageEnd: "Plug je BitBox02 opnieuw in.",
    tips: "Tips",
    tipsList: [
      "We raden je aan om een kleine hoeveelheid coins naar de passphrase wallet te sturen. Plug daarna je BitBox opnieuw in en voer je wachtwoord en passphrase in. Als je passphrase correct is, zou je de coins in je wallet moeten zien.",
      "Als je toegang wilt krijgen tot de originele wallet, kun je dit nog steeds doen door niets in te voeren als je om een passphrase wordt gevraagd. Of je kunt de passphrase helemaal uitzetten."
    ],
    title: "Passphrase uitgeschakeld"
  },
  summary: {
    button: "Passphrase aanzetten",
    title: "Samenvatting",
    understand: "Ik snap hoe de passphrase werkt, en begrijp de risico's die het met zich meebrengt.",
    understandList: [
      "De passphrase is een extra beveiliging bovenop je backup",
      "Het invoeren van een andere passphrase genereert een andere wallet.",
      "Om je wallet te herstellen heb je <strong>zowel de passphrase als de backup</strong> nodig.",
      "Als je je passphrase vergeet, kun je geen toegang meer krijgen tot je coins."
    ]
  },
  what: {
    button: "Leer hoe dit werkt",
    message: `Een wallet komt voort uit een heel groot willekeurig getal, ook wel bekend als je 'seed'. Deze seed is gemaakt toen je je BitBox02 voor het eerst instelde en is gebackupt met de microSD kaart of je lijst van herstelwoorden. Iedereen die toegang heeft tot de seed, heeft volledige controle over de coins in die wallet. 

Een passphrase is een <strong>optioneel geheim</strong> dat toegevoegd wordt aan de seed. Wanneer je de passphrase aanzet, maakt iedere verschillende passphrase een nieuwe wallet op basis van de seed <strong>en</strong> de passphrase. Een passphrase kan alles zijn; letters, woorden, speciale karakters, of helemaal niets. In feite is je standaardwallet een seed met een lege passphrase.

Deze passphrase is onderdeel van de BIP39 standaard, wat betekent dat hij compatibel is met alle wallets die diezelfde standaard ondersteunen. `,
    title: "Wat is een passphrase?"
  },
  why: {
    button: "Waarom zou ik een passphrase gebruiken?",
    message: `De BitBox02 beschermt je seed op het apparaat zelf, maar de backup (op de microSD kaart of je herstelwoorden) geeft nog steeds volledige controle over de wallet. Dat is waarom deze backup veilig opgeslagen moet worden!

Omdat een passphrase een nieuwe wallet genereert met de bestaande seed, heeft een passphrase wallet <strong>zowel de backup als de passphrase</strong> nodig om hem te herstellen. Het voordeel hiervan is dat als iemand je backup vindt, ze nog steeds je passphrase nodig hebben om toegang te krijgen tot je wallet.

Daarnaast kun je met de passphrase meerdere wallets op hetzelfde device aanmaken, ook bekend als 'verborgen wallets', naast de bestaande wallet.`,
    title: "Waarom zou je een passphrase gebruiken?"
  }
}, password$a = {
  show: "Toon {{label}}",
  warning: {
    caps: "WAARSCHUWING: Caps lock (⇪) is ingeschakeld",
    paste: 'om tekst te plakken, schakel je "SHOW {{label}}" in'
  }
}, random$b = {
  button: "Genereer willekeurig getal",
  description: "Je BitBox heeft het volgende willekeurige getal van {{bits}} bits gegenereerd:"
}, receive$c = {
  changeScriptType: "Adrestype wijzigen",
  label: "Jouw adres",
  onlyThisCoin: {
    description: "Om andere tokens te ontvangen, moet je deze inschakelen in de instellingen. Als je hier andere tokens stort, zijn ze mogelijk niet toegankelijk.",
    warning: "Zorg dat je alleen {{coinName}} op dit adres ontvangt."
  },
  scriptType: {
    p2tr: "Taproot (nieuwste adresformaat)",
    p2wpkh: "Native Segwit (standaard)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatibiliteitsformaat)"
  },
  selectAccount: "Selecteer een account",
  showFull: "Toon het volledige adres op je BitBox om te verifiëren",
  taprootWarning: "Let op: Taproot is een nieuwe adressoort in Bitcoin en wordt nog niet op grote schaal gebruikt. Het kan bijvoorbeeld zijn dat bitcoin die op een Taproot-adres ontvangen wordt, niet weergegeven wordt in andere watch-only wallets. Veel andere wallets en exchanges kunnen ook nog niet naar Taproot-adressen zenden.",
  title: "{{accountName}} ontvangen",
  verify: "Verifieer veilig je adres ",
  verifyBitBox01: "Verifieer het adres op de mobiele app",
  verifyBitBox02: "Verifieer het adres op je BitBox02",
  verifyInstruction: "Verifieer of het volgende adres hetzelfde is als het adres wat op je BitBox wordt getoond.",
  warning: {
    secureOutput: "Koppel je BitBox met je mobiele telefoon om beveiligde adresverificatie in te schakelen. Ga hiervoor naar 'Apparaten beheren' in de zijbalk."
  }
}, reset$a = {
  description: "Alle data zal van dit apparaat worden verwijderd, inclusief je privésleutel!",
  notReset: "Apparaat NIET gereset",
  title: "Fabrieksinstellingen terugzetten",
  understand: "Ik heb een backup en weet mijn herstelwachtwoord",
  understandBB02: "Ik heb een geldige backup"
}, securityInformation$a = {
  create: {
    description1: "We raden je aan om je apparaat in te stellen in een veilige omgeving. Het belangrijkste is dat andere mensen niet kunnen zien welk wachtwoord je keist.",
    description2: "Je wordt gevraagd om twee wachtwoorden aan te maken.",
    description3: "Het eerste is het <strong>apparaatwachtwoord</strong>, wat je BitBox ontgrendeld. Dit kan later veranderd worden.",
    description4: "Het tweede is je <strong>herstelwachtwoord</strong>, wat je wallet ontgrendeld. Dit wachtwoord kan niet gewijzigd worden.",
    description5: "De wallet die je aanmaakt wordt gebackupt als bestand op de meegeleverde microSD kaart. Dit kan <strong>samen met je herstelwachtwoord</strong> gebruikt worden om je wallets te herstellen.",
    title: "Beveiligingsinformatie"
  },
  restore: {
    description1: "Je wordt gevraagd om de microSD kaart die je gebruikt hebt om je backup te maken in te voeren.",
    description2: "Om je apparaat te herstellen, heb je je herstelwachtwoord nodig.",
    description3: "Zorg ervoor dat je het juiste herstelwachtwoord invoert. Ongeacht wat je hier invoert, maak je een valide wallet aan. Als je een verkeerd wachtwoord invoert, krijg je waarschijnlijk een nieuwe, lege wallet te zien.",
    title: "Beveiligingsinformatie"
  }
}, seed$a = {
  agreements: {
    "funds-access": "Ik kan NIET bij mijn wallets als ik mijn herstelwachtwoord vergeet",
    "password-change": "Ik kan het herstelwachtwoord NIET meer veranderen",
    "password-required": "Het hetstelwachtwoord is nodig om een wallet van een backup te herstellen"
  },
  create: "Wallet aanmaken",
  creating: "Wallet aanmaken...",
  description: "Ik heb het volgende gelezen en begrepen:",
  error: {
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e200: "Je moet een microSD kaart in je BitBox invoeren om een wallet aan te maken, zodat er automatisch een backup gegenereerd kan worden."
  },
  info: {
    button: "Stel nu je herstelwachtwoord in",
    description1: "Voer de microSD kaart in de BitBox in",
    description2: 'Kies een herstelwachtwoord voor de wallet en selecteer "Herstelwachtwoord nu instellen"',
    description3: "De backup op je microSD kaart en je herstelwachtwoord zijn de enige manier om weer toegang te krijgen tot je wallet als je BitBox verloren raakt, gestolen wordt, of kapot gaat.",
    description4: "Je kunt je herstelwachtwoord niet veranderen zonder je balans over te zetten op een nieuwe wallet.",
    title: "Nieuwe wallet aanmaken"
  },
  password: {
    label: "Herstelwachtwoord",
    repeatPlaceholder: "Herstelwachtwoord herhalen"
  },
  walletName: {
    label: "Walletnaam"
  }
}, seedRestore$a = {
  error: {
    e200: "Voor het herstellen van een backup is de microSD kaart nodig"
  },
  info: {
    description1: 'Voer de microSD kaart in de BitBox in en klik op "verder"',
    description2: 'Kies een backup en klik op "herstellen"',
    description3: "Voer het herstelwachtwoord in",
    description4: "Je moet bevestigen dat je begrijpt dat een verkeerd wachtwoord een nieuwe, andere wallet aanmaakt.",
    title: "Hoe herstel je een wallet vanuit een backup"
  }
}, send$c = {
  abort: "De transactie is afgebroken",
  address: {
    label: "Adres van de ontvanger",
    placeholder: "Adres invoeren"
  },
  amount: {
    label: "Hoeveelheid",
    placeholder: "Hoeveelheid invoeren"
  },
  availableBalance: "Beschikbare balans",
  button: "Controle",
  coincontrol: {
    address: "Adres",
    outpoint: "Output",
    title: "Verstuur uit output"
  },
  confirm: {
    "selected-coins": "Geselecteerde coins",
    title: "Bevestigen & transactie versturen",
    total: "Totaal"
  },
  error: {
    erc20InsufficientGasFunds: "Je hebt niet genoeg Ether in je wallet voor deze transactie. Stort meer Ether in je wallet om de transactie uit te voeren.",
    feeTooLow: "netwerkkosten te laag",
    feesNotAvailable: "Schatting van netwerkkosten niet beschikbaar",
    insufficientFunds: "ontoereikende balans",
    invalidAddress: "ongeldig adres",
    invalidAmount: "ongeldige hoeveelheid",
    invalidData: "ongeldige data"
  },
  fee: {
    customPlaceholder: "Hoeveelheid invoeren",
    label: "Netwerkkosten",
    placeholder: "Niet beschikbaar"
  },
  feeTarget: {
    customLabel: "Netwerktarief",
    customLabel_eth: "Gas-prijs",
    description: {
      economy: "4 uur (24 blokken)",
      economy_eth: "30 minuten of minder",
      economy_ltc: "1 uur (24 blokken)",
      high: "20 minuten (2 blokken)",
      high_eth: "30 seconden of minder",
      high_ltc: "5 minuten (2 blokken)",
      low: "2 uur (12 blokken)",
      low_eth: "5 minuten of minder",
      low_ltc: "30 minuten (12 blokken)",
      normal: "1 uur (6 blokken)",
      normal_eth: "2 minuten of minder",
      normal_ltc: "15 minuten (6 blokken)"
    },
    estimate: "Geschatte bevestigingstijd:",
    label: {
      custom: "Eigen selectie",
      economy: "Budget",
      high: "Hoog",
      low: "Laag",
      normal: "Normaal"
    },
    placeholder: "Netwerkkosten berekenen..."
  },
  maximum: "Alles verzenden",
  maximumSelectedCoins: "Geselecteerde coins verzenden",
  noFeeTargets: "Schattingen van de transactiekosten zijn op dit moment niet beschikbaar. Probeer het later opnieuw of stel zelf de hoogte in.",
  priority: "Prioriteit",
  scanQR: "QR-code scannen",
  signprogress: {
    description: "Dit is een transactie die veel data in zich heeft. Om de transactie te verzenden, word je gevraagd om {{steps}} keer te ondertekenen.",
    label: "Voortgang"
  },
  success: "De transactie is ondertekend en verzonden.",
  title: "Verstuur {{accountName}}",
  toggleCoinControl: "Coin control aan/uitzetten",
  transactionDetails: "Transactiedetails"
}, settings$b = {
  about: "Over",
  accounts: "Accounts",
  advancedSettings: "Geavanceerde instellingen",
  appearance: "Uiterlijk",
  electrum: {
    add: "Server toevoegen",
    "add-server": "Toevoegen",
    check: "Controleer",
    checkFailed: "Niet geslaagd",
    checkSuccess: "Verbinding met {{host}} tot stand gebracht",
    checking: "Aan het controleren",
    "download-cert": "Remote certificate downloaden",
    "remove-server": "Verwijderen",
    removeConfirm: "Wil je {{server}} verwijderen?",
    reset: "Terugzetten naar standaardinstelling",
    resetConfirm: "Wil je alle servers verwijderen en de standaard-servers instellen?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Voer het eindpunt in.",
    step2: "2",
    "step2-text": "Voer een certificaat van de server in. Je kunt ook het remote certificate downloaden en het op het oog inspecteren.",
    "step2-text-tcp": "Je kunt deze stap overslaan als je geen TLS wilt gebruiken.",
    step3: "3",
    "step3-text": "Controleer de verbinding en voeg de server toe.",
    step4: "4",
    "step4-text": "Start de wallet opnieuw op. Als je de standaard servers niet verwijderd, wordt je eigen node als backup-server toegevoegd.",
    "title-btc": "",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Coin control aanzetten",
    electrum: {
      description: "Je kunt hier met je eigen Electrum-fullnode verbinden.",
      title: "Verbind met je eigen full node"
    },
    fee: "Custom fees aanzetten",
    setProxyAddress: "Proxy adres instellen",
    title: "Geavanceerde instellingen",
    useProxy: "Tor proxy aanzetten",
    useSats: "BTC-waarde in Satoshis weergeven"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nieuwe update beschikbaar ",
    title: "Info",
    "up-to-date": "Je app is bijgewerkt",
    version: "App versie"
  },
  restart: "Start de BitBoxApp opnieuw op om de veranderde instellingen in te schakelen.",
  services: {
    title: "Diensten"
  },
  success: "Voer de BitBox opnieuw in om de veranderde instellingen in te schakelen.",
  title: "Instellingen"
}, setup$a = "Apparaat instellen", sidebar$b = {
  buy: "Crypto kopen",
  device: "Apparaat beheren",
  leave: "Verlaten",
  settings: "Instellingen"
}, success$h = {
  create: {
    info1: "Je wallet is veilig gebackupt op de microSD kaart. Verwijder deze en bewaar hem op een veilige plek.",
    info2: "Je hebt een veilig apparaatwachtwoord aangemaakt dat de BitBox ontgrendelt.",
    info3: "Je hebt een veilig herstelwachtwoord voor je wallet aangemaakt die je wallet ontgrendeld en nodig is om je backups te herstellen.",
    summary: "Hier is een samenvatting van wat je gedaan hebt",
    title: "Gelukt"
  },
  getstarted: "Get started",
  restore: {
    summary: "Je hebt je wallet vanuit je backup hersteld",
    title: "Gelukt"
  }
}, transaction$b = {
  confirmation: "Bevestigingen",
  details: {
    activity: "Activiteit",
    address: "Adres",
    amount: "Hoeveelheid",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Hoeveelheid in fiat",
    fiatAtTime: "Fiat-waarde ten tijde van de transactie",
    status: "Status",
    type: "Type"
  },
  explorer: "Transactie-ID",
  explorerTitle: "In externe block explorer openen",
  fee: "Netwerkkosten",
  fiatHistorical: "Historie",
  gas: "Gas",
  note: {
    edit: "Notitie aanpassen",
    save: "Notitie opslaan"
  },
  pending: "Transactie in afwachting",
  size: "Grootte",
  status: {
    complete: "Afgerond",
    failed: "Niet gelukt",
    pending: "In afwachting"
  },
  tx: {
    received: "Ontvangen naar",
    sent: "Verzonden naar"
  },
  vsize: "Virtuele grootte",
  weight: "Gewicht"
}, transactions$a = {
  errorLoadTransactions: "Er is een fout opgetreden bij het laden van de transacties",
  placeholder: "Nog geen transacties"
}, unknownError$a = "Er is een onbekende fout opgetreden: {{errorMessage}}", unlock$a = {
  description: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen",
  error: {
    e109_normal: "Apparaatwachtwoord onjuist. Je hebt nog {{remainingAttempts}} over voordat je BitBox wordt gereset.",
    e109_touch: "$t(unlock.error.e109_normal) Met de volgende login moet je de touchknop ingedrukt houden.",
    e113: "Omdat je tevaak geprobeerd hebt in te loggen, moet je de touchknop 4 seconden ingedrukt houden bij de volgende login."
  },
  input: {
    label: "Apparaatwachtwoord",
    placeholder: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen"
  },
  unlocking: "Ontgrendelen..."
}, upgradeFirmware$b = {
  button: "Firmware updaten",
  description: "Wil je de firmware updaten van versie {{currentVersion}} naar versie {{newVersion}}?",
  label: "Je BitBox heeft een firmwareupdate nodig.",
  locked: "Hou de touchknop lang ingedrukt om van {{currentVersion}} naar {{newVersion}} te updaten.",
  title: "Firmware updaten",
  unlocked: "De bootloader is ontgrendeld. Om door te gaan:",
  unlocked1: "Voer je BitBox opnieuw in",
  unlocked2: "Het LED lichtje gaat branden als je BitBox opnieuw is ingevoerd",
  unlocked3: "Klik op de touchknop wanneer het LED lichtje gaat branden"
}, warning$g = {
  receivePairing: "Koppel de BitBox om beveiligde adresverificatie in te schakelen. Ga naar 'Apparaat beheren' in de sidebar.",
  sdcard: "Bewaar de microSD kaart apart van de BitBox, tenzij je je backups aan het beheren bent.",
  sendPairing: "Koppel de BitBox om je transactiedetails beveiligd te kunnen verifiëren. Ga naar 'Manage device' in de sidebar."
}, welcome$a = {
  getStarted: "Laten we beginnen door de firmware op je BitBox02 te installeren.",
  insertBitBox02: "Tap de touch-sensoren op je BitBox02 om door te gaan.",
  insertDevice: "Verbind je BitBox om te starten",
  title: "Welkom"
}, appTranslationsNL = {
  account: account$a,
  accountInfo: accountInfo$a,
  accountSummary: accountSummary$a,
  addAccount: addAccount$b,
  aopp: aopp$4,
  app: app$a,
  backup: backup$a,
  bb02Bootloader: bb02Bootloader$a,
  bitbox: bitbox$a,
  bitbox02Interact: bitbox02Interact$a,
  bitbox02Settings: bitbox02Settings$a,
  bitbox02Wizard: bitbox02Wizard$a,
  blink: blink$a,
  bootloader: bootloader$a,
  button: button$e,
  buy: buy$6,
  changePin: changePin$a,
  chart: chart$6,
  checkSDcard: checkSDcard$a,
  clickHere: clickHere$a,
  confirm: confirm$c,
  confirmOnDevice: confirmOnDevice$a,
  darkmode: darkmode$5,
  device: device$a,
  deviceLock: deviceLock$a,
  deviceSettings: deviceSettings$a,
  deviceTampered: deviceTampered$a,
  dialog: dialog$b,
  error: error$6,
  fiat: fiat$c,
  footer: footer$c,
  generic: generic$6,
  genericError: genericError$a,
  goal: goal$a,
  guide: guide$b,
  headerssync: headerssync$a,
  hiddenWallet: hiddenWallet$a,
  initialize: initialize$a,
  invalidFormat: invalidFormat$a,
  language: language$b,
  legacyhiddenwallet: legacyhiddenwallet$a,
  loading: loading$a,
  manageAccounts: manageAccounts$4,
  mobile: mobile$5,
  newSettings: newSettings$4,
  note: note$6,
  notification: notification$a,
  pairing: pairing$a,
  passphrase: passphrase$4,
  password: password$a,
  random: random$b,
  receive: receive$c,
  reset: reset$a,
  securityInformation: securityInformation$a,
  seed: seed$a,
  seedRestore: seedRestore$a,
  send: send$c,
  settings: settings$b,
  setup: setup$a,
  sidebar: sidebar$b,
  success: success$h,
  transaction: transaction$b,
  transactions: transactions$a,
  unknownError: unknownError$a,
  unlock: unlock$a,
  upgradeFirmware: upgradeFirmware$b,
  warning: warning$g,
  welcome: welcome$a
}, account$9 = {
  disconnect: "Conexão perdida. Tentando novamente...",
  export: "Exportar",
  exportTransactions: "Exportar transações para a pasta Downloads como um arquivo CSV.",
  fatalError: "Ocorreu um erro inesperado.",
  incoming: "Lançamentos",
  initializing: "Obtendo informações da blockchain...",
  maybeProxyError: "Tor proxy ativado. Certifique-se que seu Tor esteja rodando corretamente ou desative as opções de proxy.",
  reconnecting: "Conexão perdida, tentando reconectar...",
  syncedAddressesCount: "Encontrado {{count}} endereços"
}, accountInfo$9 = {
  address: "Endereço",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Cripto",
    information: {
      looksEmpty: "Parece que esta carteira está vazia.",
      start: "Comece depositando algumas moedas na carteira ou comprando diretamente no BitBoxApp."
    }
  },
  extendedPublicKey: "Chave pública estendida",
  label: "Informações da conta",
  scriptType: "Tipo de script",
  title: "Informações da conta",
  verify: "Verificar no dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizar chave P2PKH pública estendida já existente.",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Segwit Nativo",
    "p2wpkh-p2sh": "Veja a chave pública estendida do Segwit mais antiga"
  },
  xpubTypeInfo: "Atualmente mostrando {{scriptType}} chave pública estendida ({{current}} de {{numberOfXPubs}})"
}, accountSummary$9 = {
  availableBalance: "Saldo disponível",
  balance: "Saldo",
  exportSummary: "Exportar resumo de contas para a pasta de Downloads como um arquivo CSV",
  fiatBalance: "Saldo em moeda corrente",
  name: "Nome da conta",
  noAccount: "Não há contas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Meu portfólio",
  total: "Total",
  transactionHistory: "Histórico de transações"
}, addAccount$a = {
  chooseName: {
    nextButton: "Adicionar conta",
    step: "Nome conta",
    title: "Um nome para sua conta"
  },
  selectCoin: {
    nextButton: "Próximo",
    step: "Selecione a moeda",
    title: "Selecione a crypto."
  },
  success: {
    addAnotherAccount: "Adicionar outra conta",
    message: "<strong>{{accountName}}</strong> foi addicionado agora as suas contas.",
    nextButton: "Pronto",
    step: "Terminado",
    title: "Conta adicionada"
  },
  title: "Adicionar conta"
}, aopp$3 = {
  addressRequest: "{{host}} está solicitando um endereço de recebimento.",
  addressRequestWithLogo: "está solicitando um endereço de recebimento",
  banner: "Solicitação de endereço em andamento.",
  errorTitle: "Erro durante a solicitação de endereço",
  labelAddress: "Endereço",
  labelMessage: "Mensagem",
  reverifyInfoText: "Verificar endereço",
  signing: "Para prosseguir, assine a mensagem na sua BitBox02",
  success: {
    message: "Prossiga em {{host}}",
    title: "Endereço enviado com sucesso"
  },
  syncing: "Sincronizando a conta, aguarde.",
  title: "Solicitação de endereço"
}, app$9 = {
  upgrade: "Uma nova versão desse app está disponível! Por favor, atualize de {{current}} para {{version}}."
}, auth$4 = {
  authButton: "Autenticar",
  title: "Autentique-se para continuar"
}, backup$9 = {
  check: {
    checking: "Checando backup...",
    confirmTitle: "Checar backup",
    notOK: "O Backup NÃO corresponde à carteira.",
    ok: "Backup corresponde à carteira.",
    password: {
      label: "Senha de recuperação",
      placeholder: "Senha de recuperação",
      showLabel: "senha de recuperação"
    },
    success: "Backup verificado com sucesso:",
    title: "Checar backup"
  },
  create: {
    alreadyExists: "Você já tem um backup válido. Você deseja recriá-lo?",
    fail: "A criação do backup FALHOU!",
    info: "Por favor, digite a senha de recuperação da carteira atual para verificação.",
    name: {
      label: "Nome do backup",
      placeholder: "Por favor, nomeie o backup"
    },
    password: {
      label: "Senha de recuperação",
      placeholder: "Por favor, digite sua senha de recuperação"
    },
    title: "Criar backup",
    verificationFailed: "A senha de recuperação NÃO CORRESPONDE à carteira atual. O backup foi criado. Por favor, use 'Checar backup' para verificar sua senha de recuperação novamente."
  },
  description: "Selecione um <strong>arquivo de backup da carteira</strong>",
  insert: "Por favor, insira o cartão microSD para gerenciar backups.",
  insertButton: "Eu inseri o cartão microSD",
  list: "Os backups do seu cartão microSD",
  noBackups: "Não há backups neste cartão microSD.",
  restore: {
    confirmTitle: "Restaurar backup",
    error: {
      e200: "Cartão microSD não encontrado",
      general: "Erro ao restaurar o backup"
    },
    password: {
      label: "Senha de recuperação ou senha de recuperação oculta",
      placeholder: "Senha de recuperação",
      repeatPlaceholder: "Repita a senha de recuperação",
      showLabel: "Senha de recuperação"
    },
    restoring: "Restaurando o backup...",
    selectedBackup: "<strong>{{backupName}}</strong> criado em {{createdDateTime}} será restaurado.",
    title: "Restaurar",
    understand: "Eu entendo que uma senha de recuperação incorreta criará uma carteira diferente"
  },
  showMnemonic: {
    description: `Serão mostradas suas palavras de recuperação, que formam um backup de sua carteira. Anote-as em um papel.

<strong>Não as armazene digitalmente nem tire fotos delas.</strong>

<strong>Não diga as palavras em voz alta.</strong>

<strong>Este backup não é protegido por senha.</strong>

Depois disso, você será solicitado a confirmar cada palavra.`,
    title: "Mostrar frase de recuperação",
    warning: "<strong>Nunca compartilhe suas palavras de recuperação com ninguém.</strong> Suas palavras de recuperação dão acesso total à sua carteira. Se alguém está pedindo suas palavras de recuperação, é um golpista, não as compartilhe!"
  },
  title: "Gerenciar backups"
}, bb02Bootloader$9 = {
  abort: "Não atualizar - Leve-me de volta",
  abort_noUpgrade: "Me leve de volta",
  advanced: {
    label: "Configurações avançadas",
    toggleShowFirmwareHash: "Mostrar o hash de firmware toda vez na inicialização"
  },
  flipscreen: "Girar tela",
  orientation: "Dispositivo orientado de maneira errada?",
  success: "Atualização bem sucedida! Continuando em {{rebootSeconds}} segundos...",
  success_install: "Instalação com sucesso! Continuando em {{rebootSeconds}} segundos..."
}, bitbox$9 = {
  error: {
    e10000: "Senha atual do dispositivo incorreta.",
    e10001: "Falha ao substituir a senha do dispositivo",
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e112: "A senha do dispositivo oculto não pode ser igual à senha do dispositivo principal."
  }
}, bitbox02Interact$9 = {
  confirmDate: "Confirme a data de hoje em sua BitBox02",
  confirmDateText: "Esta data será usada para criar seu backup.",
  confirmName: "Confirme o nome na BitBox02",
  confirmWords: "Escreva as {{amount}} palavras de recuperação da sua BitBox02",
  confirmWordsText: "Depois disso a BitBox02 pede para você confirmar cada palavra para verificar se o backup está correto.",
  followInstructions: "Por favor, siga as instruções na sua BitBox02.",
  followInstructionsMnemonic: "Siga as instruções em sua BitBox02 para inserir as palavras de recuperação de seu backup e restaurar sua carteira.",
  followInstructionsMnemonicTitle: "Restaurar a partir da frase de recuperação"
}, bitbox02Settings$9 = {
  deviceName: {
    current: "Nome atual do dispositivo",
    error: "Não foi possível definir o nome do dispositivo",
    error_104: "A confirmação do nome do dispositivo foi interrompida no dispositivo.",
    input: "Nome da BitBox02",
    placeholder: "Novo nome de dispositivo",
    title: "Definir nome da BitBox02"
  },
  gotoStartupSettings: {
    description: "Isso reiniciará sua BitBox02 e entrará nas configurações de inicialização.",
    title: "Vá para as configurações de inicialização"
  }
}, bitbox02Wizard$9 = {
  advanced: {
    button: "Opções avançadas",
    outOfDate: "Firmware desatualizado para este recurso",
    seed12WordInfo: "Observe que o número de palavras não pode ser alterado após a criação da carteira.",
    seed12WordLabel: "Criar uma semente de 12 palavras em vez de 24 palavras",
    seed12WordText: "Por padrão, a BitBox02 usa uma semente de 24 palavras. Ambos os tamanhos de sementes são seguros contra força bruta na prática. Alguns usuários podem preferir a conveniência da semente de 12 palavras.",
    skipSDCardLabel: "Pule o backup do cartão microSD e anote as palavras de recuperação",
    skipSDCardText: "Você sempre tem a opção de criar um backup em um cartão microSD ou escrever suas palavras de recuperação após a configuração. Isso pode ser feito nas configurações.",
    title: "Opções avançadas de backup"
  },
  attestationFailed: "Falha na verificação do dispositivo, o que pode ter ocorrido ao reniciar o app enquanto o dispositivo estava esperando uma entrada do usuário. Por favor, reconecte e tente novamente. Entre em contato com support@bitbox.swiss se a falha persistir.",
  backup: {
    point1: "Selecione um backup no cartão microSD",
    point2: "Defina uma senha para o seu dispositivo",
    restoreText: "Ok, vamos restaurar um backup!",
    text1: "Ótimo, sua senha da BitBox02 foi definida e a carteira foi criada. Agora é hora de criar seu primeiro backup. Por favor, verifique se o seu cartão microSD está inserido na sua BitBox02 e continue.",
    text2: "Por favor, siga as instruções na tela do seu dispositivo para criar um backup.",
    text3: "Após o backup ser criado, remova o cartão microSD e armazene-o em um <strong>local seguro</strong>. O conteúdo do cartão microSD não é protegido por senha. Nunca insira em qualquer outro dispositivo além de sua BitBox02.",
    userConfirmation1: "Eu devo armazenar meu backup em um local seguro.",
    userConfirmation2: "Meu backup não é protegido por senha. Qualquer pessoa com acesso a ele pode acessar minha carteira.",
    userConfirmation3: "Se eu perder ou danificar minha BitBox02, a única maneira de recuperar meus fundos é restaurando do meu backup.",
    userConfirmation4: "Se eu perder ou danificar meu backup e minha BitBox02, meus fundos serão perdidos.",
    userConfirmation5: "Eu não devo colocar meu cartão de backup microSD em um computador, telefone, impressora ou qualquer dispositivo a não ser o BitBox02. ",
    userConfirmation5mnemonic: "Não devo colocar minhas palavras de recuperação em um computador, telefone, impressora ou qualquer outro dispositivo que não seja uma BitBox02."
  },
  create: {
    button: "Nomear dispositivo e continuar",
    info: "Aqui estão os passos básicos que você vai seguir para configurar a sua BitBox: ",
    inputTitle: "Nome da carteira",
    point1: "Nomear seu dispositivo",
    point2: "Definir uma senha para o seu dispositivo",
    point3: "Criar um backup",
    text: "Ok, vamos criar uma nova carteira!"
  },
  createBackupAborted: "Criação de backup abortada.",
  createBackupFailed: "Falha na criação do backup, tente novamente.",
  initialize: {
    passwordText: "Agora vamos definir uma senha para o seu dispositivo. Use os controles da sua BitBox para entrar e escolher uma senha.",
    passwordTitle: "Definir uma senha para a sua BitBox",
    text: "Sucesso ao emparelhar sua BitBox02! Agora vamos inicializar seu dispositivo. Comece escolhendo criar uma nova carteira ou restaurar uma carteira a partir de um backup existente. <strong>Por favor, verifique se você tem um cartão microSD inserido na sua BitBox02</strong>",
    tip: "Recomendamos que você proceda em um ambiente seguro.",
    title: "Inicialize sua BitBox"
  },
  insertSDCard: "<strong>Por favor, verifique se você tem um cartão microSD inserido em sua BitBox02.</strong>",
  noPasswordMatch: "Senhas não conferem, tente novamente.",
  pairing: {
    failed: "Pareamento não confirmado. Por favor, reconecte sua BitBox02.",
    paired: "Você confirmou o seguinte código em seu dispositivo. Por favor continue.",
    title: "Verificar o código de pareamento",
    unpaired: "Uma BitBox02 não pareada foi detectada. Verifique se o código de pareamento corresponde ao que é mostrado em sua BitBox02."
  },
  restoreFromMnemonic: {
    e104: "A restauração a partir das palavras de recuperação foi cancelada.",
    failed: "A restauração a partir da frase de recuperação falhou, por favor, tente novamente."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, leia estas importantes considerações de segurança:",
    createBackup: "Agora você criará um backup no seu cartão microSD.",
    createBackupMnemonic: "Agora você anotará as palavras de recuperação."
  },
  stepBackupSuccess: {
    fundsSafe: "Para manter seus fundos seguros, lembre-se do seguinte:",
    title: "Backup restaurado!"
  },
  stepConnected: {
    unlock: "Digite a senha da BitBox02 para desbloquear."
  },
  stepCreate: {
    description: "Este nome é usado como o nome do dispositivo e para o backup.",
    nameLabel: "Nome da BitBox02",
    namePlaceholder: "Minha BitBox02",
    title: "Escolha o nome da BitBox02",
    toastMicroSD: "Por favor, insira seu cartão microSD em sua BitBox02, que será usado para armazenar um backup da carteira."
  },
  stepCreateSuccess: {
    removeMicroSD: "Remova o cartão microSD de sua BitBox02 e guarde-o em um local seguro.",
    storeMnemonic: "Guarde suas palavras de recuperação em um local seguro",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "Por favor insira um cartão microSD na sua BitBox02 para continuar.",
    insertSDcardTitle: "Insira cartão microSD."
  },
  stepPassword: {
    e104: "A definição da senha foi cancelada.",
    title: "Definir senha da BitBox02",
    useControls: "Use os controles em sua BitBox02 para definir uma senha."
  },
  stepUninitialized: {
    create: "Quero configurar uma nova BitBox02.",
    restore: "Quero restaurar minha carteira a partir de um backup.",
    restoreMicroSD: "Restaurar a partir do cartão microSD",
    restoreMnemonic: "Restaurar a partir da frase de recuperação",
    title: "Configure sua BitBox02"
  },
  success: {
    text: `Oba! Sua BitBox02 agora está pronta para uso.

Para obter mais informações sobre como usar o BitBoxApp, use o guia no aplicativo clicando no ponto de interrogação no canto superior direito.`,
    title: "Você está pronto para começar!"
  }
}, blink$9 = {
  button: "Piscar"
}, bootloader$9 = {
  button: "Atualizar firmware agora",
  button_install: "Instale o firmware agora",
  progress: "Atualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Atualização bem sucedida! Por favor, insira novamente o dispositivo. Desta vez, não toque no botão."
}, button$d = {
  abort: "Abortar",
  back: "Voltar",
  buy: "Comprar",
  changepin: "Mudar senha do dispositivo",
  check: "Checar backup",
  continue: "Continuar",
  copy: "Copiar",
  create: "Criar",
  dismiss: "Dispensar",
  done: "Pronto",
  download: "Baixar",
  hiddenwallet: "Criar carteira oculta",
  next: "Próximo",
  ok: "OK",
  previous: "Anterior",
  receive: "Receber",
  restore: "Restaurar",
  select: "Selecionar",
  send: "Enviar",
  unlock: "Desbloquear",
  update: "Atualizar",
  upgrade: "Atualizar"
}, buy$5 = {
  exchange: {
    bankTransfer: "Transferência bancária",
    bestDeal: "Melhor oferta",
    creditCard: "Cartão de crédito",
    fast: "Rápido",
    fee: "taxa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferência bancária: {{fee}}%",
          creditDebitCard: "Cartão de crédito/débito: {{fee}}%",
          learnMore: "Saiba mais sobre a Moonpay",
          title: "Taxas"
        },
        fullCurrenciesList: "Veja a lista completa de moedas aqui",
        payment: {
          asteriskText: "* Não disponível para residentes nos EUA",
          bankTransfer: "Transferência bancária*",
          bankTransferDetails: {
            pix: "PIX (transações BR somente no Brasil)",
            sepa: "SEPA e SEPA Instant (transações em EUR somente em países SEPA)",
            uk: "UK Faster Payments (transações em GBP somente no Reino Unido)"
          },
          creditDebitCard: "Cartão de crédito/débito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Veja mais detalhes sobre os métodos de pagamento",
          title: "Métodos de Pagamento"
        },
        supportedCurrencies: "Suporta todas as principais moedas fiduciárias: USD, EUR, CHF e outras."
      },
      pocket: {
        fees: {
          info: "Transferência bancária: {{fee}}%",
          title: "Taxas"
        },
        learnMore: "Saiba mais sobre a Pocket",
        payment: {
          bankTransfer: "Transferência bancária",
          bankTransferDetails: {
            sepa: "SEPA e SEPA Instant (transações em EUR somente em países SEPA)",
            sic: "Swiss Interbank Clearing (transações em CHF apenas em CH/LI)",
            uk: "UK Faster Payments (transações em GBP somente no Reino Unido)"
          },
          bankTransferReccuring: "Como configurar compras recorrentes com uma ordem permanente?",
          title: "Métodos de Pagamento"
        },
        supportedCurrencies: "Suporta moedas europeias: EUR, GBP e CHF.",
        verification: {
          info: "Requer apenas verificação de identidade acima dos limites diários e anuais.",
          link: "Encontre os limites atuais aqui",
          title: "Verificação de Identidade"
        }
      },
      region: {
        title: "Selecione a região em que sua conta bancária está registrada para ver quais opções estão disponíveis para você."
      }
    },
    noExchanges: "Desculpe, não há exchanges disponíveis nesta região.",
    region: "Região",
    selectRegion: "Não especificada",
    title: "Comprar {{name}}"
  },
  info: {
    continue: "Concordo e continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Somos parceiros da MoonPay para oferecer a você um modo perfeito de comprar {{name}} diretamente para o BitBoxApp. Em apenas alguns cliques.",
        "MoonPay é uma plataforma simples e rápida para comprar {{name}} em mais de 160 países."
      ],
      payment: {
        details: "Você pode comprar {{name}} instantâneamente através da MoonPay com os seguintes métodos de pagamento. Compras com cartão de crédito ou débito são convenientes e instantâneas, mas são mais caras devido ao risco de estorno. Nós recomendamos que use a opção de transferência bancária para quantidades maiores. A taxa mínima é de 4 USD/EUR ou equivalente.",
        footnote: "Por favor perceba que as taxas da corretora MoonPay pode ser diferente das utilizadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
        table: {
          "1_description": "Taxas baixas podem levar até 3 dias úteis.",
          "1_method": "Transferência bancária (SEPA)",
          "2_description": "Taxas altas mas rápidas e instantâneas",
          "2_method": "Cartões de crédito & débito",
          description: "Descrição",
          fee: "Taxa",
          method: "Método"
        },
        title: "Métodos de pagamento e taxas"
      },
      privacyPolicy: "Política de privacidade da MoonPay",
      protection: {
        description: "O BitBoxApp não coleta nenhum dado quando você compra {{name}}, o saldo recebido é tratado como uma transação regular. A MoonPay precisa coletar alguns dados pessoais para a operação. A Política de Privacidade da MoonPay explica detalhadamente como esses dados são tratados.",
        descriptionGeneric: "O BitBoxApp não coleta nenhum dado quando você compra {{name}}, os fundos recebidos são tratados como uma transação normal. No entanto, as exchanges parceiras precisam coletar algumas informações para operar. Consulte suas respectivas políticas de privacidade para ver com mais detalhes como os dados são tratados.",
        title: "Proteção dos dados"
      },
      security: {
        description: "Quando você compra {{name}} através da MoonPay, você está usando um serviço externo. Esse serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e fora do ambiente de segurança onde o aplicativo BitBoxApp está rodando.",
        descriptionGeneric: "Quando você compra {{name}} através de uma exchange parceira, você está usando um serviço externo. Este serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e depende da proteção e segurança do ambiente em que o software BitBoxApp está sendo executado.",
        link: "Modelo de ameaças de segurança",
        title: "Modelo de segurança"
      },
      title: "Bem-vindo a sua loja virtual pessoal para comprar {{name}}"
    },
    next: "Próximo",
    selectLabel: "Seleciona sua conta",
    selectPlaceholder: "Selecione uma moeda",
    skip: "Não mostre novamente",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Política de privacidade da Pocket",
      p1: "O BitBoxApp não coleta nenhum dado ao comprar bitcoin, os fundos recebidos são tratados como uma transação regular. A Pocket precisa coletar alguns dados pessoais para operar. Sua Política de Privacidade explica em detalhes como esses dados são tratados.",
      title: "Proteção de dados"
    },
    kyc: {
      link: "Leia as perguntas frequentes da Pocket",
      p1: "A Pocket tenta manter o KYC no mínimo. Para compras abaixo de 950 EUR (1000 CHF) por dia, não são necessários documentos adicionais. Para compras acima desse valor, será necessário agendar uma ligação com a Pocket para concluir o processo KYC/AML necessário.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Você pode comprar bitcoin instantaneamente com a Pocket via transferência bancária SEPA. A taxa é de 1,5% e o bitcoin é depositado em sua BitBox o mais rápido possível após a Pocket receber a transferência bancária (geralmente no mesmo dia).",
      p2: "Observe que as taxas de câmbio da Pocket podem diferir daquelas usadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
      title: "Métodos de pagamento e taxas"
    },
    previousTransactions: "O histórico de transações desta conta não está vazio. Compartilhar esta conta tornará todas as transações passadas e futuras visíveis para a Pocket. Continuar mesmo assim?",
    security: {
      link: "Modelo de ameaças de segurança da BitBox02",
      p1: "Ao comprar bitcoin via Pocket, você está usando um serviço externo. Este serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e depende da proteção e segurança do ambiente em que o software BitBoxApp está sendo executado. No entanto, trabalhamos juntos para melhorar a segurança usando um mecanismo de autenticação de dois fatores para verificar o endereço em que você está recebendo.",
      title: "Modelo de segurança"
    },
    usedAddress: "O endereço {{address}} já foi usado, comece novamente com um novo endereço.",
    verifyBitBox02: "Verifique se o endereço que você recebeu por e-mail corresponde ao exibido em sua Bitbox. Se possível, você deve abrir o e-mail em um segundo dispositivo para maior segurança.",
    welcome: {
      p1: "Fizemos parceria com a Pocket para oferecer a você uma maneira perfeita de comprar bitcoin diretamente no BitBoxApp. São apenas alguns cliques.",
      p2: "Pocket é uma plataforma suíça que facilita e agiliza a compra de bitcoin na maior parte da Europa (em qualquer lugar onde as transferências bancárias SEPA sejam suportadas).",
      p3: "Com a Pocket, você também pode fazer compras regulares por meio de ordens bancárias recorrentes, para poder fazer DCA (dollar-cost averaging) com facilidade.",
      title: "Bem-vindo ao seu balcão único para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
}, changePin$9 = {
  newTitle: "Nova senha do dispositivo",
  oldLabel: "Senha atual do dispositivo"
}, chart$5 = {
  dataMissing: "Buscando dados históricos... fique ligado.",
  dataOldTimestamp: "Atualização das taxas de câmbio históricas. O gráfico não está exibindo dados após {{time}}.",
  dataUpdating: "atualizando dados...",
  filter: {
    all: "Todos",
    month: "Mês",
    week: "Semana",
    year: "Ano"
  }
}, checkSDcard$9 = "checando cartão microSD", clickHere$9 = "Clique aqui.", confirm$b = {
  abortInfo: "Toque para ",
  abortInfoRedText: "abortar",
  approveInfo: "Segure 4 segundos ou mais para ",
  approveInfoGreenText: "confirmar",
  info: "Prossiga na sua BitBox.",
  infoWhenPaired: "Primeiro no celular emparelhado e depois na sua BitBox"
}, confirmOnDevice$9 = "Por favor, confirme no seu dispositivo.", connectKeystore$4 = {
  promptNoName: "Por favor conecte sua BitBox02 para continuar",
  promptWithName: 'Por favor conecte sua BitBox02 chamada "{{name}}" para continuar'
}, darkmode$4 = {
  toggle: "Modo escuro"
}, device$9 = {
  appUpradeRequired: "Sua BitBox não é compatível com este aplicativo. Por favor, baixe e instale a versão mais recente."
}, deviceLock$9 = {
  button: "Ativar autorização de dois fatores (2FA)",
  condition1: "Você tem um backup?",
  condition2: "A verificação pelo aplicativo de celular está funcionando?",
  condition3: "2FA DESATIVA backups e emparelhamento de aplicativos móveis. O dispositivo precisa ser RESETADO para sair do 2FA!",
  confirm: "Ativar autorização de dois fatores (2FA)",
  title: "Ativar autorização de dois fatores (2FA)"
}, deviceSettings$9 = {
  backups: {
    manageBackups: {
      description: "Criar ou verificar o backup do cartão microSD."
    },
    showRecoveryWords: {
      description: "Mostrar e verificar palavras de recuperação."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "O BitBoxApp verifica se o seu dispositivo é autêntico."
    },
    deviceName: {
      description: "Altere o nome do seu dispositivo."
    },
    rootFingerprint: {
      description: "A impressão digital raiz é um identificador exclusivo da carteira atualmente em uso. Pode ajudá-lo a distinguir entre diferentes carteiras se você usar frases secretas."
    },
    securechip: {
      description: "O modelo do chip seguro."
    },
    title: "Informações do dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Redefina seu dispositivo para as configurações de fábrica - isso apagará a sua carteira BitBox02!",
      title: "Restauração de fábrica"
    },
    goToStartupSettings: {
      description: "Acesse o bootloader da BitBox02. Você pode habilitar o hash do firmware aqui."
    },
    passphrase: {
      description: "Ative ou desative o recurso de frase secreta.",
      title: "Frase secreta"
    }
  },
  firmware: {
    firmwareVersion: "Versão do firmware",
    newVersion: {
      label: "Versão disponível"
    },
    title: "Firmware",
    upToDate: "Seu dispositivo está atualizado",
    upgradeAvailable: "Nova atualização disponível",
    version: {
      label: "Versão"
    }
  },
  hardware: {
    attestation: {
      false: "Falha na verificação de autenticidade",
      label: "Verificação de autenticidade",
      true: "Sua BitBox02 é autêntica"
    },
    sdcard: {
      false: "Não inserido",
      label: "Cartão microSD",
      true: "Inserido"
    },
    securechip: "Chip seguro",
    title: "Hardware"
  },
  loading: "Recuperando informações do dispositivo...",
  pairing: {
    lock: {
      false: "Desativado",
      label: "Autorização de dois fatores (2FA)",
      true: "Ativado"
    },
    mobile: {
      false: "Fechado",
      label: "Aplicativo móvel",
      true: "Abrir"
    },
    status: {
      false: "Não emparelhado",
      label: "Status",
      true: "Emparelhado"
    },
    title: "Emparelhamento"
  },
  secrets: {
    manageBackups: "Gerenciar backups",
    title: "Privacidade"
  }
}, deviceTampered$9 = "Sua BitBox foi fornecida com uma senha de recuperação? Se sim, pare o processo de configuração e contate o suporte imediatamente. A Shift nunca lhe dará uma carteira pronta ou fará recomendações de senha.", dialog$a = {
  cancel: "Cancelar",
  confirm: "Confirmar",
  confirmTitle: "Confirmação"
}, error$5 = {
  accountAlreadyExists: "A conta já existe.",
  accountLimitReached: "Não foi possível adicionar a conta. O número máximo de contas para essa moeda foi atingido.",
  aoppCallback: "Ocorreu um erro ao entregar o endereço para {{host}}.",
  aoppInvalidRequest: "Pedido inválido.",
  aoppNoAccounts: "Não há contas disponíveis.",
  aoppSigningAborted: "Solicitação de propriedade de endereço cancelada.",
  aoppUnknown: "Ocorreu um erro desconhecido.",
  aoppUnsupportedAsset: "O ativo não é compatível.",
  aoppUnsupportedFormat: "Não há contas disponíveis que suportem o formato de endereço solicitado.",
  aoppUnsupportedKeystore: "O dispositivo conectado não pode assinar mensagens para este ativo.",
  aoppVersion: "Versão desconhecida.",
  wrongKeystore: "Carteira errada conectada. Certifique-se de inserir o dispositivo correto que corresponde a esta conta.",
  wrongKeystore2: " Se você estiver usando a frase secreta opcional, certifique-se de ter digitado a frase secreta correta para a conta."
}, fiat$b = {
  default: "padrão",
  setDefault: "Definir {{code}} como padrão",
  title: "Moedas"
}, footer$b = {
  appVersion: "Versão do aplicativo:"
}, generic$5 = {
  enabled_false: "Desabilitado",
  enabled_true: "Habilitado"
}, genericError$9 = "Um erro ocorreu. Se você notar algum problema, por favor, reinicie o aplicativo.", goal$9 = {
  buttons: {
    create: "Criar uma nova carteira",
    restore: "Restaurar uma carteira de um backup"
  },
  paragraph: "Por favor, selecione uma das seguintes opções:",
  step: {
    1: {
      title: "Informação de segurança"
    },
    2: {
      description: "Definir uma senha do dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Criar uma nova carteira",
      title: "Carteira"
    },
    "3-restore": {
      description: "de um backup",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumo"
    },
    "4-restore": {
      title: "Resumo"
    }
  }
}, guide$a = {
  accountDescription: {
    text: 'A visão geral da sua conta mostra seu saldo disponível, além de transações de entrada e saída. Nosso guia em "Configurações" contém mais informações sobre cada tipo de conta. ',
    title: "O que esta página me mostra?"
  },
  accountFiat: {
    text: "Sim. Clique em qualquer código para alternar entre moedas fiduciárias. Você pode alterar a lista de moedas nas configurações.",
    title: "Posso exibir outras taxas de conversão?"
  },
  accountIncomingBalance: {
    text: "Lançamentos soma os valores transferidos para você ainda não confirmados pela rede.",
    title: "O que significa lançamentos?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Cada xpub é atrelado ao "Tipo" mostrado: tanto o "Segwit Nativo (bech32)" como ao "Wrapped Segwit" ou "Taproot" (somente Bitcoin). Esses são tipos de scripts usados pela {{coinName}}. O BitBoxApp combina eles, suportando múltiplos tipos de scripts na mesma conta. Por isso cada tipo de script te fornece um xpub diferente, existem vários xpubs por conta.

Se você recebe constantemente em um tipo de endereço padrão (Segwit Nativo), você só precisa do xpub "bech32". Entretando, se você também recebe valores nos tipos "Wrapped Segwit" ou "Taproot", você precisa usar as chaves públicas estendidas do "Wrapped Segwit" e "Taproot" respectivamente.`,
      title: "Por que tem vários xpubs?"
    },
    privacy: {
      text: `Para esse tipo específio de conta, a chave pública estendida revela seu histórico financeiro completo, seu saldo em conta e todas suas transações futuras. Mas a xpub não permite que ninguém gaste suas moedas.

Se você fornecer sua xpub à alguém, você deverá ter em mente que essa pessoa ou empresa poderá ver todas as transações antigas da sua conta. Assim achamos uma boa idéia que você use essa conta somente para esse propósito e mantenha seus fundos salvos em contas diferentes dessa.`,
      title: "Por que preciso manter minha xpub secreta?"
    },
    verify: {
      text: "Sim, é sempre uma boa idéia revisar sua xpub. Se alguma outra pessoa gerar um endereço de recebimento através da sua xpub para mandar seu dinheiro, isso é muito importante. Você precisa verificar no dispositivo para garantir que essa xpub pertence a você para que seus fundos não acabem indo para endereços errados e sejam perdidos.",
      title: "Preciso verificar minha xpub nesse dispositivo?"
    },
    xpub: {
      text: `Uma chave pública estendida (xpub) é uma chave-raiz da qual todos os endereços de recebimento de uma conta são derivados.

Ela é fornecida aqui para uso avançado e interoperabilidade com carteiras watch-only, como Electrum ou Sentinel. Se você recebeu de diferentes tipos de endereço, importe todos os formatos diferentes de xpub em sua carteira watch-only para ver todas as suas moedas.

Por favor, note que que carteiras de terceiros podem não suportar xpubs do tipo Taproot ainda.`,
      title: "O que é uma chave pública estendida?"
    }
  },
  accountRates: {
    text: "Nós atualizamos as taxas de câmbio a cada minuto no CoinGecko.",
    title: "Quais taxas de câmbio são aplicadas?"
  },
  accountReload: {
    text: "Não há necessidade. Suas informações de transação são atualizadas automaticamente.",
    title: "Posso recarregar o histórico de transações?"
  },
  accountSendDisabled: {
    text: 'O botão "Enviar" é ativado quando seu saldo for maior que zero.',
    title: "Por que não consigo enviar {{unit}}?"
  },
  accountSummaryAmount: {
    text: `O montante total é a soma de de saldo de todas sua contas crypto. Taxas de troca são obtidas através da coingecko.com.

Obs: Se você usa a MyEtherWallet para tokens ela não é suportada no BitBoxApp, por isso não será incluso no montante total mostrado.`,
    title: "Como o valor total é calculado?"
  },
  accountSummaryDescription: {
    text: "Aqui você pode ver o desempenho do seu portfólio ao longo do tempo. Um resumo de suas contas crypto individuais é exibido abaixo do gráfico.",
    title: "O que essa página me mostra?"
  },
  accountTransactionAttributesBTC: {
    text: `Tamanho virtual: determina a taxa de rede. Você economizou com sucesso em taxas se for menor que o tamanho da transação.
Tamanho: tamanho real da transação em bytes quando serializado de acordo com a blockchain subjacente.
Peso: uma nova métrica introduzida no Segwit para avaliar os tamanhos de transação e bloco. Cada segregated witness (segwit) byte conta como um, todo o resto como quatro unidades de peso. Em vez de um megabyte em tamanho real, o limite de tamanho do bloco agora é de quatro milhões de unidades de peso.`,
    title: "E os detalhes da transação específica do Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmações: sua primeira transmissão de transação não é confirmada até que um minerador a inclua em um bloco, isso só acontece após uma confirmação. Cada bloco transmitido na rede adiciona outra confirmação à sua transação. Geralmente, os comerciantes e outros agentes da rede somente liquidam transações com três a seis confirmações.
ID da transação: um número de identificação exclusivo que permite procurar uma transação em um explorador de blocos.
Taxa: Os mineradores recebem uma taxa de mineração como incentivo para incluir transações nos blocos que mineram. Para saber mais, clique no botão enviar.`,
    title: "Quais são as informações nos detalhes da transação?"
  },
  accountTransactionConfirmation: {
    text: "Uma transação transmitida para a rede, mas ainda não confirmada.",
    title: "O que é uma transação pendente?"
  },
  accountTransactionLabel: {
    text: "É o endereço para o qual você recebeu ou enviou moedas.",
    title: "Qual endereço é exibido para cada transação?"
  },
  accountTransactionTime: {
    text: "O horário de confirmação da transação blockchain.",
    title: "Qual horário é exibido?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin e Litecoin podem ter uma quantidade arbitrária de contas. Após cinco contas, você só pode adicionar outra conta se a conta anterior tiver sido usada. Outras moedas podem ter um máximo de cinco contas.",
      title: "Quantas contas posso criar?"
    },
    howtoAddTokens: {
      text: 'Tokens usando o padrão ERC20 são atrelados a uma conta Ethereum específica. Para habilitar ou desabilitar um token em particular, abra a tela "Gerenciar contas", e expanda até a sua conta Ethereum e mude o token desejado para ligado ou desligado.',
      title: "Como posso adicionar mais tokens?"
    },
    moveFunds: {
      text: "Sim. Porque as contas são independentes, você deve mandar saldo usando uma transação regular.",
      title: "Posso mover saldo entre contas?"
    },
    recoverAccounts: {
      text: "Sim, O BitBoxApp cria suas contas usando o melhor padrão estabelecido compatível com a maioria das outras carteiras de crypto.",
      title: "Posso recuperar minhas contas com outras carteiras?"
    },
    whatAreAccounts: {
      text: "Sua carteira pode gerenciar contas múltiplas da mesma moeda. Várias contas são de extrema ajuda para manter seus fundos separadamente.",
      title: "O que são contas?"
    },
    whyIsThisUseful: {
      text: 'Contas são ótimas para gerenciar seus fundos para pessoas ou propósitos diferentes porque são separadas. Você pode também compartilhar sua "chave pública estendida" de uma conta sem revelar nada sobre suas outras contas.Isso permite você repetidamente receber saldo sem reutilizar os seus endereços, bem como receber seu salário ou seu saldo de crypto que for comprado.',
      title: "Por que isso é útil?"
    }
  },
  appendix: {
    link: "Contate-nos!",
    text: "Outra pergunta?"
  },
  backups: {
    check: {
      text: "'Checar backup' permite verificar se você tem um backup funcionando correspondente à sua carteira atual. Também pode ser usado para verificar se você ainda tem a senha de recuperação correta. Você pode verificar sua senha de recuperação principal ou sua senha de recuperação oculta.",
      title: "O que é 'Checar backup'?"
    },
    encrypt: {
      text: "Não, mas sua senha de recuperação é necessária para derivar a carteira a partir da semente armazenada.",
      title: "Posso criptografar o backup?"
    },
    howOften: {
      text: `O backup é gerado automaticamente quando uma nova carteira é criada. Você só precisa fazer um novo backup se o seu cartão microSD for perdido ou danificado ou se desejar usar vários cartões microSD como backups.
Você não precisa criar novos backups depois das atividades de transação. Todos os seus dados de transação podem ser recriados pelo backup único que foi gerado automaticamente para você.`,
      title: "Com que frequência tenho que fazer um backup?"
    },
    whatIsABackup: {
      text: "É uma cópia da semente em um cartão microSD. A semente junto com sua senha de recuperação gera sua carteira.",
      title: "O que é um backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Checar backup' permite verificar se você tem um backup funcionando correspondente à sua carteira atual.",
      title: "O que é 'Checar backup'?"
    },
    encrypt: {
      text: 'Não. Por favor, mantenha o cartão microSD seguro, pois ele contém a semente não criptografada para recuperar sua carteira. Se você deseja proteger sua semente com senha, é possível ativar uma frase secreta opcional nas configurações de especialistas em "Gerenciar dispositivo".',
      title: "Posso criptografar o backup?"
    },
    whatIsABackup: {
      text: "É uma cópia da semente em um cartão microSD.",
      title: "O que é um backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando o 2FA é ativado, todas as transações de moedas precisam ser aprovadas no celular emparelhado. Internamente, um número de uso único criptografado é enviado para o aplicativo móvel, é descriptografado e retornado à BitBox ao pressionar o botão Aceitar. Esta comunicação com o dispositivo é feita através do canal entre o telefone celular e este aplicativo de desktop estabelecido durante o emparelhamento.

Certifique-se de fazer um backup de sua carteira e emparelhar o aplicativo móvel antes de ativar o 2FA. Uma vez ativado, o slot de cartão microSD e o emparelhamento via aplicativo móvel são desativados. Eles podem ser reativados resetando a BitBox, o que formata o dispositivo.`,
      title: "Como funciona a autenticação de dois fatores (2FA)?"
    },
    disable2FA: {
      text: `Para desabilitar o 2FA, você precisa resetar a sua BitBox e restaurar a carteira através do seu backup. Certifique-se de que você ainda tem o cartão microSD com o backup e que você ainda se lembra da senha de recuperação. Em seguida, pressione 'Resetar dispositivo'. Defina uma nova senha para o dispositivo e escolha "Ou restaurar a partir de um backup". Selecione o backup que você fez da carteira, clique em 'Restaurar' e insira a senha de recuperação que você usou ao criar a carteira.`,
      title: "Como posso desativar a autorização de dois fatores (2FA)?"
    },
    ejectBitbox: {
      text: "Você pode desconectar a BitBox a qualquer momento sem precisar ejetá-la primeiro.",
      title: "Como posso ejetar a BitBox?"
    },
    ejectSD: {
      text: "Você pode remover o cartão microSD da BitBox a qualquer momento, desde que não esteja criando ou restaurando um backup.",
      title: "Como posso ejetar o cartão microSD?"
    },
    hiddenWallet: {
      text: "É uma segunda carteira no mesmo dispositivo protegida por uma senha de dispositivo e senha de recuperação diferentes, que você pode usar para negação plausível (plausible deniability). A mesma semente do backup é usada para sua carteira normal e oculta, portanto, nenhum backup adicional é necessário.",
      title: "O que é uma carteira oculta?"
    },
    legacyHiddenWallet: {
      text: "Primeiro, clique no botão abaixo (disponível se a BitBox estiver desbloqueada com a senha principal do dispositivo e o 2FA estiver desabilitado), em seguida, reconecte sua BitBox e desbloqueie-a com a senha oculta do dispositivo.",
      title: "Como faço para acessar a carteira legacy oculta?"
    },
    pairing: {
      text: "Depois de fazer o download do nosso aplicativo para dispositivos móveis para iOS ou Android, escaneie o QR code exibido, que cria um canal seguro entre o aplicativo móvel e este aplicativo. Depois de escanear, siga as instruções no aplicativo para dispositivos móveis.",
      title: "Como emparelhar de forma segura com o seu telefone"
    }
  },
  cointracking: {
    text: 'Clique no botão "Exportar" e abra a pasta de downloads onde você ira encontrar seu arquivo CSV exportado. Depois clique no link abaixo, faça upload do arquivo CSV BitBox e importe ele a fim de usar os dados no seu Gerenciador de rastreamento de moeda e poderá criar seus relatórios de taxa.',
    title: "Como importar minhas transações para a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leia mais sobre a verificação de autenticidade"
      },
      text: "O BitBoxApp executa uma verificação de atestado na BitBox02 para verificar se o dispositivo é genuíno. A verificação é feita localmente e não se conecta a nenhum servidor.",
      title: "Como funciona a verificação de autenticidade?"
    },
    name: {
      text: "Este é o nome da sua carteira e backup. O nome é usado para backups futuros e pode ser usado para ajudar a distinguir entre diferentes carteiras. Ele pode ser alterado a qualquer momento, mas observe que os backups feitos antes da alteração ainda usarão o nome anterior.",
      title: "Para que serve o nome da BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leia mais sobre o chip seguro"
      },
      text: "Esta informação mostra o número do modelo do chip seguro, o chip mais atualizado é o ATECC608B com recursos de segurança aprimorados em comparação com modelos mais antigos.",
      title: "Por que mostrar o modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Você pode dar o endereço para que outras pessoas lhe enviem algumas moedas. Apenas certifique-se de que estão enviando para o endereço correto.",
      title: "O que eu faço com um endereço?"
    },
    addressChange: {
      text: "Assim que você realiza a transação, um novo endereço é automaticamente adicionado à lista, para que haja sempre 20 endereços disponíveis que nunca receberam moedas.",
      title: "Quando os endereços mudam?"
    },
    addressFormats: {
      text: "Por padrão, o tipo de endereço é Segwit Nativo. Esse tipo de endereço é amplamente adotado por outras carteiras/corretoras e oferece as melhores taxas para transações habituais. No entanto, você também pode optar por enviar para Taproot (somente Bitcoin), que é o tipo de endereço mais recente, mas pode não ser amplamente suportado ainda. Alternativamente, se você estiver tendo problemas para enviar para o Segwit Nativo (o tipo padrão), tente alternar para o tipo de endereço mais antigo Wrapped Segwit que pode ser compatível com mais carteiras/corretoras.",
      title: 'Quando usar "Alterar tipo de endereço"?'
    },
    howVerify: {
      text: `Para a BitBox01, clique no ícone BitBox na barra lateral à esquerda e veja a seção Emparelhamento. O guia será atualizado e você poderá continuar seguindo as instruções.
Para a BitBox02, você pode verificar os endereços diretamente no dispositivo durante o processo de envio/recebimento.`,
      title: "Como posso verificar um endereço com segurança?"
    },
    plugout: {
      text: "Não, uma vez que você enviou moedas para o seu endereço BitBox, você não precisa deixar sua BitBox conectada. Você pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o recebimento?"
    },
    why20: {
      text: 'Durante a inicialização, o aplicativo gera endereços derivados de sua semente para ver se eles receberam fundos. Como o aplicativo pode gerar um número quase infinito de endereços, poderia levar anos determinando o saldo. Para limitar essa pesquisa, ele para depois de ver 20 endereços que nunca receberam fundos. Esse é o "gap limit" e 20 é um padrão de fato, embora o número seja arbitrário. Estes são os 20 endereços que você pode escolher.',
      title: "Por que apenas 20 endereços?"
    },
    whyMany: {
      text: "Para manter a privacidade e a segurança, nunca distribua o mesmo endereço duas vezes. Se você usou um endereço, clique na seta para a direita para obter um novo endereço. Você pode gerar até 20 endereços por vez. Pense em endereços como números de fatura. Todos os endereços são derivados de sua única semente de backup.",
      title: "Por que tantos endereços?"
    },
    whyVerify: {
      text: "Você não deve confiar no seu computador para gerar e exibir endereços autênticos. As diferentes formas que um computador convencional pode ser atacado o torna significativamente mais vulnerável do que uma carteira de hardware. Para a BitBox01, o botão para verificar o endereço envia o endereço com segurança para um telefone celular emparelhado, a partir do qual você também pode digitalizar e verificar o QR code. Para a BitBox02, o endereço pode ser verificado diretamente no visor da BitBox02.",
      title: "Por que devo verificar o endereço com segurança?"
    }
  },
  send: {
    change: {
      text: "O troco será devolvido a um endereço Taproot se você tiver pelo menos um Taproot UTXO. Se você usar o controle de moedas, o troco será devolvido a um endereço Taproot se houver pelo menos um Taproot UTXO entre os UTXOs selecionados. Em todos os outros casos, o troco é devolvido a um endereço Segwit Nativo.",
      title: "Como o output do troco é determinado?"
    },
    fee: {
      text: `A taxa é baseada no tamanho dos dados da transação e não no valor. As metas de taxas são calculadas pelo algoritmo de estimativa de taxas do Bitcoin Core para cada prioridade de rede que você escolher. Elas são mostradas se tiverem um valor diferente do objetivo abaixo.
Econômica: 24 blocos (cerca de 4 horas para Bitcoin, 1 hora para Litecoin)
Baixa: 12 blocos (cerca de 2 horas para o Bitcoin, 30 minutos para o Litecoin)
Normal: 6 blocos (cerca de 1 hora para o Bitcoin, 15 minutos para o Litecoin)
Alta: 2 blocos (cerca de 20 minutos para Bitcoin, 5 minutos para Litecoin)
(Um bloco demora, em média, dez minutos para Bitcoin (2,5 minutos para Litecoin) para ser minerado e o carregamento da rede pode variar consideravelmente nos períodos acima.)`,
      title: "Como a taxa é determinada?"
    },
    plugout: {
      text: "Não, uma vez que você tenha feito uma transação, você não precisa deixar sua BitBox conectada. Você pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o envio?"
    },
    priority: {
      text: "Tipicamente, quanto maior a taxa que você está disposto a pagar, mais rapidamente sua transação é confirmada pela rede.",
      title: "Qual é a prioridade da rede?"
    },
    revert: {
      text: `Depois que uma transação é assinada e enviada (ou seja, transmitida para a rede), ela não pode mais ser revertida. Verifique as transações (incluindo a taxa) corretamente antes de assinar!
Se você conhece o destinatário e ele ou ela está disposto a enviar o mesmo valor (menos as taxas de transação) de volta para você, você pode enviar um novo endereço de recebimento.`,
      title: "Posso reverter uma transação?"
    },
    whyFee: {
      text: `As transações estão competindo para serem confirmadas por um minerador. Mineradores escolhem transações para serem incluídas na blockchain com base em sua taxa.
Os mineradores votam no histórico das transações. Como não há nenhum terceiro confiável para fazer valer um voto por pessoa (que é a ideia das blockchains), os mineradores votam em transações sacrificando um recurso caro como o poder de computação. Como recompensa por seu trabalho, eles podem reivindicar moedas recém-criadas e a taxa de todas as transações incluídas.`,
      title: "Por que há uma taxa de rede?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Se você pretente apenas conectar seu nó quando você tiver em uma rede específica (ex: seu wifi de casa), então uma comunicação padrão apenas é suficiente.
Nesse caso é aconselhado que seu servidor Electrum forneça um certificado TLS para encriptar a comunicação.
Se você prente conectar seu nó de qualquer lugar usando o protocolo Tor a melhor opção e necessária é não usar um certificado TLS para esse caso.`,
      title: "Devo usar clearnet TCP, TLS ou Tor?"
    },
    instructions: {
      link: {
        text: "Guia para conectar seu nó"
      },
      text: "Para um tutorial completo, por favor visite nosso guia:",
      title: "Como conecto meu BitBoxApp no meu prórprio nó?"
    },
    options: {
      text: `Existem várias opções para você rodar seu próprio nó, como comprar um dispositivo próprio, construir um ou usar a rede Bitcoin Core.
Se você deseja conectar seu BitBoxApp no seu nó, certifique-se de quele roda um servidor Electrum compatível. Trata-se de um programa dedicado que permite que seu aplicativo de carteira se comunique com seu próprio nó.
Operações suportadas incluem Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).`,
      title: "Quais opções tenho para rodar um nó?"
    },
    tor: {
      text: `Tor significa 'The Onion Router', que é um software de código aberto e gratuito que oferece muitos benefícios de privacidade e é especialmente útil ao usar Bitcoin.
Se você pretende se conectar ao seu node através do Tor, certifique-se de que o Tor está instalado no seu computador e ative o Proxy Tor nas configurações do BitBoxApp.
Na maioria dos sistemas operacionais, existem duas maneiras de executar o Tor:
1. Navegador Tor: baixe e abra o navegador Tor. Isso permitirá que o BitBoxApp se conecte à rede Tor configurando a porta 9150 nas configurações de proxy do Tor.
2. Serviço Tor em segundo plano: instale o daemon Tor, que sempre é executado em segundo plano. O BitBoxApp pode então se conectar definindo a porta 9050 nas configurações de proxy do Tor.`,
      title: "O que é Tor, proxy Tor e qual porta devo usar?"
    },
    what: {
      text: "É possível alimentar sua carteira com seus próprios full nodes em vez de usar os servidores Shift.",
      title: "O que é isso?"
    },
    why: {
      text: `Executar seu próprio node não é necessário, mas melhora a privacidade e reduz a necessidade de confiar nos outros.
Em primeiro lugar, significa que você está usando o Bitcoin de forma mais privada, pois o BitBoxApp não se conecta aos nossos servidores para buscar seu histórico de transações; em vez disso, ele buscará essas informações em seu próprio node.
Em segundo lugar, executar seu próprio node significa que ele verifica todas as transações por si mesmo, garantindo que as regras de consenso sejam aplicadas.`,
      title: "Por que devo executar meu próprio node?"
    }
  },
  settings: {
    sats: {
      text: "Um Satoshi ('sat' para abreviar) é a menor unidade de Bitcoin. Um Satoshi é um centésimo milionésimo de um bitcoin (0,00000001 BTC). É o nome do criador do Bitcoin, Satoshi Nakamoto.",
      title: "O que é um Satoshi?"
    },
    servers: {
      text: `Este aplicativo se comunica com os servidores Shift Crypto para verificar atualizações, carregar transações e enviar informações para aplicativos móveis emparelhados.
O aplicativo também busca as taxas de câmbio mais recentes do CoinGecko. Todas as conversões são calculadas localmente, o que significa que nenhum dado sobre o valor da sua transação é transmitido.
Nota: Para Ethereum e ERC20 Tokens, nós usamos APIs do Etherscan.io.`,
      title: "Com quais servidores este aplicativo se comunica?"
    }
  },
  title: "Guia",
  toggle: {
    close: "Fechar guia",
    open: "Guia"
  },
  trackingModePortfolioChart: {
    text: "No desktop passe o cursor sobre o gráfico. No celular, segure o dedo no gráfico e arraste horizontalmente.",
    title: "Como ver os valores históricos no gráfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Você precisa resetar o dispositivo e restaurar a carteira a partir de um backup, usando a senha de recuperação.",
      title: "O que faço se eu esquecer a senha do dispositivo?"
    },
    reset: {
      text: "Digite uma senha do dispositivo errada 15 vezes. As últimas tentativas exigem um toque longo no dispositivo.",
      title: "Como faço para resetar o dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `O dispositivo deve piscar uma vez quando inserido. Certifique-se de que está inserido de maneira correta. Se você está tendo problemas, por favor, entre em contato conosco através do link abaixo.

A BitBox01 não é suportada em dispositivos móveis. Por favor, use o BitBoxApp no Desktop para conectar sua BitBox01.`,
      title: "Minha BitBox01 não é reconhecida"
    },
    getDevice: {
      link: {
        text: "Encomendar uma BitBox"
      },
      text: "Você pode comprar uma BitBox em nossa loja online:",
      title: "Como posso obter um dispositivo?"
    },
    internet: {
      text: "Sim, uma conexão com a internet é necessária para sincronizar a carteira, enviar transações e buscar as taxas de câmbio mais recentes.",
      title: "Este aplicativo requer uma conexão com a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de backup"
      },
      text: "Você pode recuperar suas contas em uma nova BitBox ou com o nosso centro de backup.",
      title: "Eu perdi meu dispositivo. E agora?"
    },
    useWithoutDevice: {
      text: "Infelizmente, isso ainda não é possível no momento.",
      title: "Posso usar o aplicativo sem um dispositivo?"
    },
    welcome: {
      text: "Obrigado por usar este aplicativo criado pela Shift Crypto na Suíça. Agradecemos qualquer contribuição que você tenha para compartilhar. Por favor, dê feedback usando o link na parte inferior.",
      title: "Bem-vindo ao BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se você estiver usando um novo telefone/computador com o BitBoxApp, precisará se conectar aos DApps novamente. Você verá suas moedas no dapp novamente, como de costume.",
      title: "Não vejo minhas conexões anteriores."
    },
    supportedNetworks: {
      text: "Atualmente, apenas a rede principal Ethereum é suportada usando WalletConnect no BitBoxApp. Para usar outras cadeias compatíveis com a EVM, use a carteira de extensão do navegador Rabby.",
      title: "Quais redes são suportadas?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect é um protocolo de comunicação para aplicativos web3. Ele permite que você se conecte convenientemente a DApps baseados em Ethereum e carteiras web sem usar um aplicativo de terceiros, o que é particularmente útil para usuários Android do BitBoxApp.",
      title: "O que é WalletConnect?"
    }
  }
}, headerssync$9 = {
  blocksSynced: "{{blocks}} blocos sincronizados"
}, hiddenWallet$9 = {
  info1HTML: "Para fins de negação plausível (plausible deniability), uma carteira oculta pode ser criada com base em uma combinação de senha de recuperação e uma senha de dispositivo <strong>diferente</strong>.",
  info2HTML: "Defina a senha do dispositivo e a senha de recuperação que você deseja associar à sua carteira oculta abaixo. A senha do dispositivo e a senha de recuperação devem ser <strong>diferentes</strong> das que você definiu para sua carteira principal.",
  passwordLabel: "Senha de recuperação oculta",
  passwordPlaceholder: "Por favor, confirme a senha de recuperação oculta",
  pinLabel: "Senha oculta do dispositivo",
  pinRepeatLabel: "Repita a senha oculta do dispositivo",
  pinRepeatPlaceholder: "Por favor, confirme a senha oculta do dispositivo",
  success: "Carteira oculta criada com sucesso. Reconecte a sua BitBox para desbloqueá-la."
}, initialize$9 = {
  create: "Definir senha do dispositivo",
  creating: "Configurando senha do dispositivo...",
  error: {
    e102: "A senha do dispositivo precisa conter pelo menos 4 caracteres."
  },
  info: {
    description1: "Escolha a senha do seu dispositivo. Ela será usada para desbloquear a sua BitBox.",
    description2: "Você pode usar números, letras & símbolos. Senhas maiores oferecem mais segurança.",
    description3: "Se você perder a senha do dispositivo, precisará resetá-lo e restaurar o backup da carteira.",
    subtitle: "Agora você vai definir a senha do seu dispositivo",
    title: "Inicializando seu dispositivo"
  },
  input: {
    label: "Senha do dispositivo",
    labelRepeat: "Repita a senha do dispositivo",
    placeholderRepeat: "Por favor, confirme a senha do dispositivo"
  }
}, invalidFormat$9 = "Formato Inválido", language$a = {
  title: "Selecione o idioma"
}, legacyhiddenwallet$9 = {
  disable: "Desativar carteira legacy oculta",
  enable: "Ativar carteira legacy oculta",
  successDisable: "Carteira legacy oculta desativada com sucesso.",
  successEnable: "Carteira legacy oculta ativada com sucesso. Reconecte sua BitBox e digite a senha oculta do dispositivo para acessar a carteira legacy oculta."
}, loading$9 = "carregando…", manageAccounts$3 = {
  accountHidden: "Esta conta foi ocultada das suas contas watch-only. Para vê-la novamente, conecte sua BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nome da conta",
  noAccounts: "nenhuma conta encontrada",
  settings: {
    hideTokens: "Esconder tokens",
    showTokens: "Exibir tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Adicionar e exibir/mostrar contas",
  title: "Gerenciar contas",
  watchAccount: "Observar conta",
  watchAccountDescription: "Esta conta faz parte das suas contas watch-only. Você pode ocultá-la de suas contas watch-only usando o botão de alternância."
}, mobile$4 = {
  usingMobileDataWarning: "Uso de dados móveis: esse aplicativo baixa centenas de megabytes de dados de cabeçalho de blockhain depois de desbloquear sua conta. Por favor conecte no Wi-Fi para evitar de usar dados móveis desnecessários. Depois de descartar isso, essa mensagem não aparecerá novamente."
}, newSettings$3 = {
  about: {
    appVersion: {
      title: "Versão do aplicativo"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloqueie o acesso ao aplicativo com bloqueio de tela/impressão digital.",
      title: "Bloqueio de tela"
    },
    coinControl: {
      description: "Selecione quais UTXOs fazem parte de uma transação para ajudar a melhorar a privacidade."
    },
    customFees: {
      description: "Permite inserir sua própria taxa ao enviar."
    },
    torProxy: {
      description: "Conecte-se via Tor para melhor privacidade."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Essas moedas adicionais podem ser alternadas na página da sua conta.",
      title: "Moedas ativas"
    },
    darkmode: {
      description: "Veja o BitBoxApp no modo escuro."
    },
    defaultCurrency: {
      description: "Selecione sua moeda padrão",
      title: "Moeda padrão"
    },
    hideAmounts: {
      description: "Exibe um botão para ocultar seu saldo e valores para melhorar sua privacidade ao usar o aplicativo em público.",
      hideAmounts: "Ocultar valores",
      showAmounts: "Mostrar valores",
      title: "Permitir ocultar valores"
    },
    language: {
      description: "Qual idioma você deseja que o BitBoxApp use.",
      title: "Idioma"
    },
    toggleSats: {
      description: "Ativar ou desativar Satoshis."
    }
  }
}, note$5 = {
  input: {
    description: "(opcional)",
    placeholder: "Adicionar nota..."
  },
  title: "Nota"
}, notification$9 = {
  newTxs_one: "Nova transação em: {{accountName}}",
  newTxs_other: "{{count}} novas transações em: {{accountName}}"
}, pairing$9 = {
  aborted: {
    text: "O emparelhamento foi cancelado no aplicativo para dispositivos móveis.",
    title: "Abortado"
  },
  button: "Emparelhar aplicativo móvel",
  confirm: "Tem certeza de que deseja emparelhar sua BitBox? Observe que, depois disso, o celular será necessário para realizar uma transação.",
  connectOnly: {
    button: "Conectar aplicativo móvel",
    title: "Escaneie com nosso aplicativo móvel selecionando o item 'Conectar ao novo aplicativo de desktop' do menu"
  },
  error: {
    text: "Algo deu errado. Por favor comece de novo.",
    title: "Erro"
  },
  pullFailed: {
    text: "Falha ao obter mensagem de seu dispositivo móvel através do servidor. O servidor pode estar offline, por favor entre em contato com o suporte.",
    title: "Falha ao obter"
  },
  reconnectOnly: {
    button: "Reconectar aplicativo móvel"
  },
  scanningFailed: {
    text: "Telefone não foi capaz de scanear a mensagem com sucesso. Por favor tente novamente.",
    title: "Falha ao scanear."
  },
  start: {
    hideAppQRCode: "Ocultar QR code",
    revealAppQRCode: "Mostrar QR code",
    step1: "Se você não tiver o aplicativo para dispositivos móveis, você pode escanear o QR code da Apple App Store ou da Google Play Store, dependendo de qual celular você possui.",
    step2: 'Escaneie com nosso aplicativo para celular, que você pode encontrar sob o nome "Digital Bitbox 2FA" nas lojas de aplicativos para iOS e Android:'
  },
  started: {
    text: "Agora, por favor, siga as instruções no aplicativo móvel.",
    title: "Ótimo"
  },
  success: {
    text: "Parabéns, você pareou com sucesso sua BitBox com o aplicativo móvel!",
    title: "Sucesso"
  },
  timeout: {
    text: "O emparelhamento expirou após dois minutos. Comece novamente se você ainda deseja emparelhar o aplicativo para dispositivos móveis.",
    title: "Tempo esgotado"
  },
  title: "Emparelhamento por celular"
}, passphrase$3 = {
  considerations: {
    button: "Considerações sobre backup",
    message: `A frase secreta adiciona uma camada de proteção ao backup da sua carteira (cartão microSD ou palavras de recuperação). Se alguém tiver acesso ao seu backup, também precisará da frase secreta para acessar sua carteira.

No entanto, isso significa que você precisará <strong>tanto da frase secreta + backup da carteira</strong> para restaurar sua carteira habilitada para frase secreta, caso sua BitBox02 seja perdida ou danificada. Se você esquecer ou perder sua frase secreta, perderá o acesso a todas as moedas dessa carteira.

Ao armazenar sua frase secreta, considere colocá-la em um local separado do backup. Dessa forma, se alguém encontrar seu backup, eles também não encontrarão sua frase secreta.`,
    title: "Considerações sobre backup"
  },
  disable: "Desabilitar frase secreta",
  disableInfo: {
    button: "Desabilitar",
    message: `Depois de desabilitar a frase secreta, você não será mais solicitado a inserir uma frase secreta após desbloquear sua BitBox02. Portanto, você entrará em sua carteira padrão.

Quaisquer moedas em sua carteira gerada com a frase secreta ainda estarão nessa carteira, mas você não poderá acessá-las porque depois de desbloquear sua BitBox02, você abrirá sua carteira padrão.

Para acessar suas carteiras geradas com frases secretas novamente, basta reativar o recurso de frase secreta e inserir a frase secreta relevante após desbloquear a BitBox02.

<strong>Dica:</strong> você ainda pode acessar sua carteira original deixando a frase secreta vazia.`
  },
  enable: "Habilitar frase secreta",
  error: {
    e104: "A alteração da configuração da frase secreta foi abortada."
  },
  how: {
    button: "Como funciona",
    message: `Uma frase secreta não funciona como uma senha com a qual você está acostumado. Se você digitar incorretamente sua frase secreta, você não será notificado. Isso ocorre porque <strong>cada frase secreta cria uma carteira diferente, porém válida</strong>. Isso significa que você pode usar várias frases secretas para quantas carteiras quiser. Mas cada carteira só pode ser acessada ao digitar a frase secreta correspondente.

Ao conectar sua BitBox02, você será solicitado a inserir a senha do dispositivo como de costume. Depois disso, você será solicitado a inserir uma frase secreta no dispositivo.

Depois de inserir a frase secreta, você verá a frase secreta digitada. Isso é para que você possa confirmar que digitou corretamente.`,
    title: "Como funciona"
  },
  intro: {
    message: `Uma frase secreta fornece uma camada adicional de segurança em sua carteira.
Vamos aprender como funciona.`,
    title: "Configurar frase secreta"
  },
  progressDisable: {
    message: "Confirme em sua BitBox que você deseja <strong>desabilitar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  progressEnable: {
    message: "Confirme em sua BitBox que você deseja <strong>ativar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  successDisabled: {
    message: `Frase secreta opcional <strong>ativada com sucesso</strong>!
Você será solicitado a fornecer uma frase secreta a partir de agora.`,
    messageEnd: "Por favor, reconecte a BitBox02 agora.",
    title: "Frase secreta ativada"
  },
  successEnabled: {
    message: `Frase secreta opcional <strong>desativada com sucesso</strong>!

Você não será mais solicitado a fornecer uma frase secreta.`,
    messageEnd: "Por favor, reconecte sua BitBox02 agora.",
    tips: "Dicas",
    tipsList: [
      "Sugerimos enviar primeiro uma pequena quantia para a carteira gerada pela frase secreta. Em seguida, desconecte e reconecte a BitBox02 e digite sua senha e frase secreta. Se você digitou a frase secreta corretamente, deverá ver as moedas em sua carteira.",
      "Se você deseja acessar sua carteira original sem uma frase secreta, você ainda pode fazer isso não digitando nada quando solicitado a inserir a frase secreta. Ou você pode desativar o recurso de frase secreta."
    ],
    title: "Frase secreta desativada"
  },
  summary: {
    button: "Ativar frase secreta",
    title: "Resumo",
    understand: "Eu entendo como a frase secreta funciona e os riscos associados a ela.",
    understandList: [
      "A frase secreta é uma camada adicional de segurança em seu backup.",
      "A inserção de uma frase secreta diferente sempre gerará uma carteira diferente.",
      "Para restaurar sua carteira, você precisa <strong>da frase secreta e do backup</strong>.",
      "Se você esquecer sua frase secreta, você <strong>não poderá mais acessar suas moedas</strong>."
    ]
  },
  what: {
    button: "Saiba como isso funciona",
    message: `Uma carteira é criada (derivada) a partir de um número aleatório muito grande, também conhecido como semente. Essa semente é criada quando você configura sua BitBox02 pela primeira vez e é feito backup com o cartão microSD ou palavras de recuperação. Qualquer pessoa que tenha acesso à semente tem controle total sobre os fundos dessa carteira.

Uma frase secreta é um <strong>segredo opcional</strong>, adicionado à semente. Ao usar uma frase secreta, cada frase secreta cria uma nova carteira com base na semente + frase secreta (segredo opcional). Uma frase secreta pode ser qualquer coisa: letras, palavras, caracteres especiais ou pode até ser vazia. A carteira padrão é de fato derivada da semente + frase secreta vazia.

A frase secreta é parte do padrão BIP39, o que significa que é compatível com todas as carteiras que suportam o mesmo padrão.`,
    title: "O que é uma frase secreta?"
  },
  why: {
    button: "Por que usar uma frase secreta",
    message: `A BitBox02 protege a semente contra extração do próprio dispositivo, mas o backup (cartão microSD ou palavras de recuperação) dá acesso total à carteira. É por isso que deve ser armazenado em um local seguro!

Como uma frase secreta cria uma nova carteira usando sua semente existente, a carteira da frase secreta requer tanto seu <strong>backup quanto sua frase secreta para restaurar</strong>. O benefício disso é que, se alguém encontrar seu backup, ainda precisará da frase secreta para acessar a carteira.

Além disso, o recurso de frase secreta permite que você crie várias carteiras no mesmo dispositivo ou “carteiras ocultas” além da padrão.`,
    title: "Por que usar uma frase secreta?"
  }
}, password$9 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "ATENÇÃO: o caps lock (⇪) está ativado",
    paste: 'para colar o texto, ative "MOSTRAR {{label}}"'
  }
}, random$a = {
  button: "Gerar número aleatório",
  description: "Sua BitBox gerou o seguinte número aleatório de {{bits}} bits:"
}, receive$b = {
  changeScriptType: "Alterar tipo de endereço",
  label: "Seu endereço",
  onlyThisCoin: {
    description: "Para receber outros tokens, ative-os nas configurações. Se você depositar outros tokens, eles podem não ser acessíveis.",
    warning: "Certifique-se de receber apenas {{coinName}} neste endereço."
  },
  scriptType: {
    p2tr: "Taproot (formato mais recente)",
    p2wpkh: "Segwit Nativo (padrão)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatível)"
  },
  selectAccount: "Selecione a conta",
  showFull: "Mostrar e verificar endereço completo no dispositivo",
  taprootWarning: "Nota: Taproot é um novo recurso do Bitcoin e ainda não é amplamente adotado. Os valores recebidos em endereços Taproot podem não ser visíveis em carteiras watch-only de terceiros. Muitas carteiras e corretoras ainda não podem enviar para endereços Taproot.",
  title: "Receber {{accountName}}",
  verify: "Verificar endereço com segurança",
  verifyBitBox01: "Verifique o endereço no aplicativo móvel",
  verifyBitBox02: "Verifique o endereço na BitBox02",
  verifyInstruction: "Por favor, verifique se o endereço a seguir corresponde ao exibido no seu dispositivo.",
  warning: {
    secureOutput: "Por favor, emparelhe sua BitBox com seu dispositivo móvel para ativar a verificação segura de endereço. Vá para 'Gerenciar dispositivo' na barra lateral."
  }
}, reset$9 = {
  description: "Todos os dados serão excluídos deste dispositivo. Isso inclui sua chave privada!",
  notReset: "Dispositivo NÃO redefinido.",
  title: "Restaurar configurações de fábrica",
  understand: "Eu tenho um backup e sei minha senha de recuperação",
  understandBB02: "Eu tenho um backup válido"
}, securityInformation$9 = {
  create: {
    description1: "Recomendamos que você configure seu dispositivo em um ambiente seguro, ou seja, você estará longe de outras pessoas que possam ver a senha que você escolher.",
    description2: "Você será solicitado a criar duas senhas.",
    description3: "A primeira é a <strong>senha do dispositivo</strong> que desbloqueia o seu dispositivo BitBox e pode ser alterada mais tarde.",
    description4: "A segunda é a <strong>senha de recuperação</strong> que desbloqueia sua carteira. Esta senha não pode ser alterada mais tarde.",
    description5: "A carteira que você criar será copiada para um arquivo no cartão microSD fornecido. Ele pode ser usado em caso de emergência para recuperar seus fundos usando a sua <strong>senha de recuperação</strong>.",
    title: "Informação de segurança"
  },
  restore: {
    description1: "Você será solicitado a inserir o cartão microSD usado para armazenar seu backup.",
    description2: "Para restaurar o seu dispositivo, você precisará da sua senha de recuperação.",
    description3: "Por favor, tenha cuidado ao digitar a senha de recuperação. Qualquer senha que você inserir criará uma carteira válida. Se você digitar a senha errada, poderá ser mostrado um saldo da carteira que você não espera.",
    title: "Informação de segurança"
  }
}, seed$9 = {
  agreements: {
    "funds-access": "Eu NÃO poderei acessar meus fundos se esquecer minha senha de recuperação",
    "password-change": "Eu NÃO posso mudar a senha de recuperação mais tarde",
    "password-required": "A senha de recuperação é necessária para restaurar uma carteira de um backup"
  },
  create: "Criar carteira",
  creating: "Criando carteira",
  description: "Eu entendo que:",
  error: {
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e200: "Você precisa inserir um cartão microSD na sua BitBox para criar uma carteira, para que um backup possa ser criado automaticamente."
  },
  info: {
    button: "Definir senha de recuperação agora",
    description1: "Insira o cartão microSD na BitBox",
    description2: 'Escolha uma senha de recuperação para a carteira e selecione "Definir senha de recuperação agora"',
    description3: "O backup para o cartão microSD e sua senha de recuperação é o único método para recuperar seus fundos em caso de perda ou roubo de um dispositivo BitBox.",
    description4: "Você não pode alterar sua senha de recuperação posteriormente sem transferir seus fundos.",
    title: "Criar uma nova carteira"
  },
  password: {
    label: "Senha de recuperação",
    repeatPlaceholder: "Repita a senha de recuperação"
  },
  walletName: {
    label: "Nome da carteira"
  }
}, seedRestore$9 = {
  error: {
    e200: "Restaurar uma carteira a partir de um backup requer o cartão microSD."
  },
  info: {
    description1: 'Insira o cartão microSD na BitBox e clique em "Continuar"',
    description2: 'Escolha um backup e clique em "Restaurar"',
    description3: "Digite a senha de recuperação",
    description4: "Você precisa confirmar que entende que uma senha incorreta criará uma carteira diferente.",
    title: "Como restaurar uma carteira a partir de um backup"
  }
}, send$b = {
  abort: "A transação foi abortada.",
  address: {
    label: "Endereço do destinatário",
    placeholder: "Insira o endereço"
  },
  amount: {
    label: "Montante",
    placeholder: "Insira o valor"
  },
  availableBalance: "Saldo disponível",
  button: "Revisar",
  coincontrol: {
    address: "Endereço",
    outpoint: "Outpoint",
    title: "Enviar da saída"
  },
  confirm: {
    "selected-coins": "Moedas selecionadas",
    title: "Confirmar e enviar transação",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que você não tem Ether suficiente para pagar por esta transação ERC20. Certifique-se de ter Ether suficiente em sua carteira",
    feeTooLow: "taxa muito baixa",
    feesNotAvailable: "Não foi possível estimar as taxas",
    insufficientFunds: "saldo insuficiente",
    invalidAddress: "endereço inválido",
    invalidAmount: "montante inválido",
    invalidData: "dados inválidos"
  },
  fee: {
    customPlaceholder: "Insira o valor",
    label: "Taxa de rede",
    placeholder: "Não disponível"
  },
  feeTarget: {
    customLabel: "Taxa",
    customLabel_eth: "Preço do gás",
    description: {
      economy: "4 horas (24 blocos)",
      economy_eth: "30 minutos ou menos",
      economy_ltc: "1 hora (24 blocos)",
      high: "20 minutos (2 blocos)",
      high_eth: "30 segundos ou menos",
      high_ltc: "5 minutos (2 blocos)",
      low: "2 horas (12 blocos)",
      low_eth: "5 minutos ou menos",
      low_ltc: "30 minutos (12 blocos)",
      normal: "1 hora (6 blocos)",
      normal_eth: "2 minutos ou menos",
      normal_ltc: "15 minutos (6 blocos)"
    },
    estimate: "Tempo estimado de confirmação:",
    label: {
      custom: "Customizar",
      economy: "Econômica",
      high: "Alta",
      low: "Baixa",
      normal: "Normal"
    },
    placeholder: "Calculando a taxa ..."
  },
  maximum: "Enviar tudo",
  maximumSelectedCoins: "Enviar moedas selecionadas",
  noFeeTargets: "As estimativas de taxa de transação estão indisponíveis no momento. Por favor, tente novamente mais tarde ou insira uma taxa personalizada.",
  priority: "Prioridade",
  scanQR: "Escanear QR code",
  signprogress: {
    description: "Esta é uma transação que contém muitos dados. Para assinar completamente a transação, você será solicitado a confirmar {{steps}} vezes.",
    label: "Progresso"
  },
  success: "A transação foi assinada e enviada.",
  title: "Enviar {{accountName}}",
  toggleCoinControl: "Alternar controle de moedas",
  transactionDetails: "Detalhes da transação"
}, settings$a = {
  about: "Sobre",
  accounts: "Contas",
  advancedSettings: "Configurações avançadas",
  appearance: "Aparência",
  electrum: {
    add: "Adicionar um servidor",
    "add-server": "Adicionar",
    check: "Checar",
    checkFailed: "Falhou",
    checkSuccess: "Conexão com {{host}} estabelecida com sucesso.",
    checking: "Checando",
    "download-cert": "Baixar certificado remoto",
    "remove-server": "Remover",
    removeConfirm: "Remover {{server}}?",
    reset: "Redefinir para o padrão",
    resetConfirm: "Você deseja remover todos os servidores e instalar os servidores padrão?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Digite o endpoint.",
    step2: "2",
    "step2-text": "Digite um certificado da cadeia de certificados do servidor. Alternativamente, baixe o certificado remoto e compare-o visualmente.",
    "step2-text-tcp": "Você pode pular essa estapa se não quiser usar TLS.",
    step3: "3",
    "step3-text": "Checar a conexão e adicionar o servidor.",
    step4: "4",
    "step4-text": "Reinicie a carteira. Se você não remover os servidores padrão, seu próprio node será adicionado como uma redundância.",
    "title-btc": "Servidores Bitcoin Electrum",
    "title-ltc": "Servidores Litecoin Electrum",
    "title-tbtc": "Servidores Bitcoin Testnet Electrum",
    "title-tltc": "Servidores Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Ativar controle de moedas",
    electrum: {
      description: "Você pode se conectar ao seu próprio nó completo Electrum.",
      title: "Conectar seu próprio full node"
    },
    fee: "Habilitar taxas personalizadas",
    setProxyAddress: "Configurar endereço de proxy",
    title: "Configurações para especialistas",
    useProxy: "Ativar proxy Tor",
    useSats: "Exibir valores BTC em Satoshis"
  },
  header: {
    home: "Início"
  },
  info: {
    "out-of-date": "Nova atualização disponível",
    title: "Informações",
    "up-to-date": "Seu aplicativo está atualizado",
    version: "Versão do aplicativo"
  },
  restart: "Por favor, reinicie o BitBoxApp para que as alterações façam efeito.",
  services: {
    title: "Serviços"
  },
  success: "Por favor, retire e reconecte a BitBox para que as mudanças façam efeito.",
  title: "Configurações"
}, setup$9 = "Configurar dispositivo", sidebar$a = {
  buy: "Comprar crypto",
  device: "Gerenciar dispositivo",
  leave: "Sair",
  settings: "Configurações"
}, success$g = {
  create: {
    info1: "Sua carteira foi armazenada com segurança no cartão microSD. Remova-o e mantenha-o seguro.",
    info2: "Você criou uma senha de dispositivo segura que desbloqueia a BitBox.",
    info3: "Você criou uma senha de recuperação segura para sua carteira que desbloqueia seu saldo e restaura seus backups.",
    summary: "Aqui está um resumo do que você fez",
    title: "Sucesso"
  },
  getstarted: "Começar",
  restore: {
    summary: "Você restaurou uma carteira a partir do seu backup com sucesso.",
    title: "Sucesso"
  }
}, transaction$a = {
  confirmation: "Confirmações",
  details: {
    activity: "Movimentação",
    address: "Endereço",
    amount: "Valor",
    date: "Data",
    fiat: "Fiduciária",
    fiatAmount: "Valor fiduciário",
    fiatAtTime: "Fiat no momento da transação",
    status: "Status",
    type: "Tipo"
  },
  explorer: "ID da transação",
  explorerTitle: "Abrir no explorador de blocos externo",
  fee: "Taxa",
  fiatHistorical: "Histórico",
  gas: "Gas",
  note: {
    edit: "Editar nó",
    save: "Salvar nó"
  },
  pending: "Transação pendente",
  size: "Tamanho",
  status: {
    complete: "Completa",
    failed: "Falhou",
    pending: "Pendente"
  },
  tx: {
    received: "Recebido para",
    sent: "Enviado para"
  },
  vsize: "Tamanho virtual",
  weight: "Peso"
}, transactions$9 = {
  errorLoadTransactions: "Ocorreu um erro ao carregar as transações",
  placeholder: "Nenhuma transação ainda."
}, unknownError$9 = "Ocorreu um erro desconhecido: {{errorMessage}}", unlock$9 = {
  description: "Digite a senha do dispositivo para desbloqueá-lo.",
  error: {
    e109_normal: "Senha do dispositivo errada. {{remainingAttempts}} tentativas restantes antes que o dispositivo seja resetado.",
    e109_touch: "$t(unlock.error.e109_normal) O próximo login requer que segure o botão touch.",
    e113: "Devido a muitas tentativas de login, o próximo login requer que o botão touch seja pressionado por 4 segundos."
  },
  input: {
    label: "Senha do dispositivo",
    placeholder: "Digite a senha do dispositivo para desbloqueá-lo"
  },
  unlocking: "Desbloqueando..."
}, upgradeFirmware$a = {
  button: "Atualizar firmware",
  description: "Deseja atualizar o firmware da versão {{currentVersion}} para {{newVersion}}?",
  label: "Sua BitBox requer uma atualização de firmware.",
  locked: "Para atualizar da versão {{currentVersion}} para a {{newVersion}}, por favor, realize um longo toque.",
  title: "Atualizar firmware",
  unlocked: "O bootloader está desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecte e reconecte sua Bitbox",
  unlocked2: "O LED acenderá quando a sua BitBox for conectada novamente",
  unlocked3: "Toque no botão touch quando o LED acender"
}, walletConnect$5 = {
  connect: {
    button: "Conectar",
    dappLabel: "Insira o endereço URI do dapp",
    invalidPairingUri: "Uri de emparelhamento inválido"
  },
  dashboard: {
    allSessions: "Todas as sessões",
    disclaimer: "Walletconnect é um protocolo para conectar-se a Dapps baseados em Ethereum. Esses dapps são executados por serviços de terceiros, portanto, conecte-se apenas a dapps em que você confia e sempre saiba o que está assinando ao fazer uma transação.",
    newConnection: "Nova conexão",
    noConnectedSessions: "Nenhuma conta está atualmente conectada a nenhum dapps."
  },
  invalidPairingChain: "Erro ao aprovar o emparelhamento. Certifique-se de usar uma das cadeias suportadas: {{chains}}",
  pairingRequest: {
    approve: "Aprovar conexão",
    reject: "Rejeitar",
    title: "Nova solicitação de conexão de"
  },
  pairingSuccess: "Dapp conectado com sucesso. Você pode continuar no site dapp.",
  signingRequest: {
    account: "Conta",
    chain: "Cadeia",
    dapp: "Dapp",
    data: "Dados",
    dataParsingError: "Falha ao analisar os dados",
    decodeError: "Falha ao decodificar a mensagem",
    method: {
      sendTransaction: "Assinar e enviar transação",
      signMessage: "Assinar mensagem",
      signTransaction: "Assinar transação",
      signTypedData: "Assinar dados digitados"
    },
    successfullySigned: "Solicitação assinada com sucesso",
    walletConnectRequest: "Solicitação WalletConnect"
  },
  useNewUri: "Este URI já foi usado para tentar uma conexão. Use um novo URI.",
  walletConnect: "WalletConnect"
}, warning$f = {
  receivePairing: "Por favor, emparelhe a BitBox para ativar a verificação segura de endereço. Vá para 'Gerenciar dispositivo' na barra lateral.",
  sdcard: "Mantenha o cartão microSD guardado separado da BitBox, a menos que você queira gerenciar os backups.",
  sendPairing: 'Por favor, emparelhe a BitBox para verificar com segurança os detalhes da transação. Vá para "Gerenciar dispositivo" na barra lateral.'
}, welcome$9 = {
  connect: "Conecte a BitBox02",
  getStarted: "Vamos começar instalando o firmware na sua BitBox02.",
  insertBitBox02: "Para a BitBox02, por favor, toque no dispositivo para continuar.",
  insertDevice: "Por favor, conecte seu dispositivo para iniciar",
  title: "Bem-vindo"
}, appTranslationsPT = {
  account: account$9,
  accountInfo: accountInfo$9,
  accountSummary: accountSummary$9,
  addAccount: addAccount$a,
  aopp: aopp$3,
  app: app$9,
  auth: auth$4,
  backup: backup$9,
  bb02Bootloader: bb02Bootloader$9,
  bitbox: bitbox$9,
  bitbox02Interact: bitbox02Interact$9,
  bitbox02Settings: bitbox02Settings$9,
  bitbox02Wizard: bitbox02Wizard$9,
  blink: blink$9,
  bootloader: bootloader$9,
  button: button$d,
  buy: buy$5,
  changePin: changePin$9,
  chart: chart$5,
  checkSDcard: checkSDcard$9,
  clickHere: clickHere$9,
  confirm: confirm$b,
  confirmOnDevice: confirmOnDevice$9,
  connectKeystore: connectKeystore$4,
  darkmode: darkmode$4,
  device: device$9,
  deviceLock: deviceLock$9,
  deviceSettings: deviceSettings$9,
  deviceTampered: deviceTampered$9,
  dialog: dialog$a,
  error: error$5,
  fiat: fiat$b,
  footer: footer$b,
  generic: generic$5,
  genericError: genericError$9,
  goal: goal$9,
  guide: guide$a,
  headerssync: headerssync$9,
  hiddenWallet: hiddenWallet$9,
  initialize: initialize$9,
  invalidFormat: invalidFormat$9,
  language: language$a,
  legacyhiddenwallet: legacyhiddenwallet$9,
  loading: loading$9,
  manageAccounts: manageAccounts$3,
  mobile: mobile$4,
  newSettings: newSettings$3,
  note: note$5,
  notification: notification$9,
  pairing: pairing$9,
  passphrase: passphrase$3,
  password: password$9,
  random: random$a,
  receive: receive$b,
  reset: reset$9,
  securityInformation: securityInformation$9,
  seed: seed$9,
  seedRestore: seedRestore$9,
  send: send$b,
  settings: settings$a,
  setup: setup$9,
  sidebar: sidebar$a,
  success: success$g,
  transaction: transaction$a,
  transactions: transactions$9,
  unknownError: unknownError$9,
  unlock: unlock$9,
  upgradeFirmware: upgradeFirmware$a,
  walletConnect: walletConnect$5,
  warning: warning$f,
  welcome: welcome$9
}, account$8 = {
  disconnect: "संपर्क टूट गया। फिरसे प्रयास कर रहे हे...",
  exportTransactions: "ट्रांसेक्शन्स को डाउनलोड फ़ोल्डर में CSV फाइल के रूप में निर्यात करें।",
  fatalError: "एक अनपेक्षित भूल थी।",
  incoming: "आ रहे है",
  initializing: "ब्लॉकचेन से जानकारी प्राप्त कर रहे हैं ...",
  reconnecting: "कनेक्शन खो दिया, फिर से कनेक्ट करने का प्रयास कर रहा है ..."
}, accountInfo$8 = {
  address: "एड्रेस",
  extendedPublicKey: "विस्तारित पब्लिक की",
  label: "खाता जानकारी",
  title: "अकाउंट की जानकारी",
  verify: "डिवाइस पर सत्यापित करें"
}, accountSummary$8 = {
  balance: "बेलेंस",
  exportSummary: "अकाउंट सारांश को डाउनलोड फ़ोल्डर में CSV फाइल के स्वरूप में एक्सपोर्ट करे",
  fiatBalance: "फिएट बैलेंस",
  name: "अकाउंट का नाम",
  noAccount: "दिखाने के लिए कोई अकाउंट नहीं हैं।",
  title: "एकाउंट्स सारांश",
  total: "टोटल"
}, addAccount$9 = {
  title: "अकाउंट जोड़ो"
}, app$8 = {
  upgrade: "इस एप्लिकेशन का एक नया संस्करण उपलब्ध है! कृपया {{current}} से {{version}} अपग्रेड करें ।"
}, backup$8 = {
  check: {
    checking: "बैकअप जाँच रहा है ...",
    confirmTitle: "बैकअप की जाँच करें",
    notOK: "बैकअप वॉलेट से मेल नहीं खाता है।",
    ok: "बैकअप वॉलेट से मेल खाता है।",
    password: {
      label: "रिकवरी पासवर्ड",
      placeholder: "रिकवरी पासवर्ड",
      showLabel: "रिकवरी पासवर्ड"
    },
    success: "सफलतापूर्वक सत्यापित बैकअप:",
    title: "बैकअप की जाँच करें"
  },
  create: {
    alreadyExists: "आपके पास पहले से ही एक वैध बैकअप है। क्या आप इसे फिर से बनाना चाहते हैं?",
    fail: "बैकअप बनाना असफल हुआ",
    info: "कृपया सत्यापन के लिए वर्तमान वॉलेट का रिकवरी पासवर्ड दर्ज करें।",
    name: {
      label: "बैकअप का नाम",
      placeholder: "कृपया बैकअप को नाम दे"
    },
    password: {
      label: "रिकवरी पासवर्ड",
      placeholder: "कृपया अपना रिकवरी पासवर्ड दर्ज करें"
    },
    title: "बैकअप बनाए",
    verificationFailed: "रिकवरी पासवर्ड वर्तमान वॉलेट से नहीं मिलता है। बैकअप बनाया गया है। कृपया अपने रिकवरी पासवर्ड को फिर से सत्यापित करने के लिए 'चेक बैकअप' का उपयोग करें।"
  },
  description: "<strong>वॉलेट बैकअप फ़ाइल</strong> को चुने",
  insert: "कृपया बैकअप को मैनेज करने लिए माइक्रो एसडी कार्ड डालें।",
  insertButton: "मैंने माइक्रो एसडी कार्ड डाला है",
  list: "आपके माइक्रोएसडी कार्ड बैकअप",
  noBackups: "इस माइक्रो एसडी कार्ड पर कोई बैकअप नहीं है।",
  restore: {
    confirmTitle: "बैकअप पुनर्स्थापित करे",
    error: {
      e200: "एसडी कार्ड नहीं मिला"
    },
    password: {
      label: "रिकवरी पासवर्ड या हिडन रिकवरी पासवर्ड",
      placeholder: "रिकवरी पासवर्ड",
      repeatPlaceholder: "रिकवरी पासवर्ड दोहराएँ",
      showLabel: "रिकवरी पासवर्ड"
    },
    restoring: "बैकअप पुनर्स्थापित कर रहा है ...",
    title: "पुनर्स्थापित करें",
    understand: "मैं समझता हूं कि एक गलत रिकवरी पासवर्ड एक अलग वॉलेट बनाएगा"
  },
  showMnemonic: {
    description: `आपको 24 शब्द दिखाए जाएँगे, जो आपके वॉलेट का बैकअप बनाते हैं। उन्हें कागज पर लिख लें।

<strong>उन्हें डिजिटल रूप से संग्रहीत न करें या इसकी तस्वीरें न लें।</strong>

<strong>शब्दों को ज़ोर से मत बोलो।</strong>

<strong>यह बैकअप पासवर्ड से सुरक्षित नहीं है।</strong>

बाद में, आपको प्रत्येक शब्द की पुष्टि करने के लिए कहा जाएगा।`,
    title: "नेमोनिक सीड दिखाओ"
  },
  title: "बैकअप मैनेज करें"
}, bb02Bootloader$8 = {
  abort: "अपग्रेड न करें - मुझे वापस ले जाएं",
  advanced: {
    label: "एडवांस सेटिंग",
    toggleShowFirmwareHash: "स्टार्टअप पर हर बार फ़र्मवेयर hash दिखाएं"
  },
  flipscreen: "फ्लिप स्क्रीन",
  orientation: "डिवाइस गलत तरीके से उन्मुख है?",
  success: "अपग्रेड सफल हुआ!  {{rebootSeconds}} सेकंड में में जारी है..."
}, bitbox$8 = {
  error: {
    e10000: "वर्तमान डिवाइस पासवर्ड गलत है।",
    e10001: "डिवाइस पासवर्ड बदलने में विफल",
    e102: "पासवर्ड में कम से कम 4 अक्षर होने चाहिए।",
    e112: "हिडन डिवाइस पासवर्ड मुख्य डिवाइस पासवर्ड के समान नहीं हो सकता है।"
  }
}, bitbox02Interact$8 = {
  followInstructions: "कृपया अपने BitBox02 पर दिए गए निर्देशों का पालन करें।"
}, bitbox02Settings$8 = {
  deviceName: {
    current: "वर्तमान डिवाइस का नाम",
    input: "BitBox02 का नाम",
    title: "BitBox02 का नाम सेट करें"
  }
}, bitbox02Wizard$8 = {
  attestationFailed: "उपकरण सत्यापन विफल हो गया, जो ऐप को पुनरारंभ करने के कारण हो सकता है जबकि डिवाइस उपयोगकर्ता इनपुट की प्रतीक्षा कर रहा था। कृपया पुन: कनेक्ट करें और पुनः प्रयास करें।",
  backup: {
    point1: "माइक्रोएसडी कार्ड पर बैकअप का चयन करें",
    point2: "अपने डिवाइस के लिए एक पासवर्ड सेट करें",
    restoreText: "ठीक है, चलो बैकअप पुनर्स्थापित करें!",
    text1: "बढ़िया, अब आपका BitBox02 पासवर्ड सेट और वॉलेट बनाया गया है। अब आपका पहला बैकअप बनाने का समय आ गया है। कृपया सुनिश्चित करें कि आपका माइक्रोएसडी कार्ड आपके BitBox02 में डाला गया है और जारी है।",
    text2: "बैकअप बनाने के लिए कृपया अपने डिवाइस पर ऑन-स्क्रीन निर्देश का पालन करें।",
    text3: "आपका बैकअप बन जाने के बाद, कृपया माइक्रोएसडी कार्ड निकालें और इसे <strong>सुरक्षित स्थान</strong> में स्टोर करें । माइक्रोएसडी कार्ड की सामग्री पासवर्ड से सुरक्षित नहीं है। इसे कभी BitBox02 के अलावा किसी अन्य डिवाइस में न डालें।",
    userConfirmation1: "मुझे अपना बैकअप सुरक्षित स्थान पर संग्रहीत करना चाहिए।",
    userConfirmation2: "मेरा बैकअप पासवर्ड प्रोटेक्टेड नहीं है। इससे कोई भी व्यक्ति मेरे वॉलेट तक पहुंच सकता है।",
    userConfirmation3: "यदि मैं अपना BitBox02 खो देता हूं या नुकसान पहुंचाता हूं, तो अपने फंड को पुनर्प्राप्त करने का एकमात्र तरीका मेरे बैकअप से पुनर्स्थापित करना है।",
    userConfirmation4: "अगर मैं अपना बैकअप और मेरा BitBox02 दोनों खो देता हूं या नुकसान होता है तो मेरे फंड हमेशा के लिए खो जाएंगे।"
  },
  create: {
    button: "डिवाइस को नाम दे और जरी रखे",
    info: "अपना BitBox सेटअप करने के लिए यहाँ पे बेसिक स्टेप्स हे जिसका आप पालन करेंगे",
    inputTitle: "वॉलेट का नाम",
    point1: "अपने डिवाइस को नाम दे",
    point2: "अपने डिवाइस के लिए एक पासवर्ड सेट करें",
    point3: "एक बैकअप बनाएं",
    text: "ठीक है, चलो एक नया वॉलेट बनाएँ!"
  },
  initialize: {
    passwordText: "अब आप अपने डिवाइस के लिए एक पासवर्ड सेट करें। पासवर्ड दर्ज करने और चुनने के लिए अपने BitBox पर नियंत्रण का उपयोग करें।",
    passwordTitle: "अपने BitBox के लिए एक पासवर्ड सेट करें",
    text: "सफलतापूर्वक अपने BitBox02 को जोड़ा! अब अपने डिवाइस को इनिशियलाइज़ करते हैं। एक नया वॉलेट बनाने से, या एक मौजूदा बैकअप से एक वॉलेट को पुनर्स्थापित करने से शुरुआत करते है। <strong>कृपया सुनिश्चित करें कि आपने BitBox02 में एक माइक्रोएसडी कार्ड डाला  है</strong>",
    tip: "यह सुनिश्चित करें कि आप सुरक्षित वातावरण में आगे बढ़ें।",
    title: "अपने BitBox को इनिशियलाइज़ करें"
  },
  insertSDCard: "<strong>कृपया सुनिश्चित करें कि आपके पास अपने BitBox02 में एक माइक्रोएसडी कार्ड डाला गया है।</strong>",
  pairing: {
    failed: "अपुष्ट युग्मन। कृपया अपना BitBox02 फिरसे प्लग करें।",
    paired: "आपने अपने डिवाइस पर पुष्टि की है कि कोड मेल खाता है। यदि यह सही है, तो आप नीचे दिए गए बटन पर क्लिक करके जारी रख सकते हैं।",
    title: "pairing कोड सत्यापित करें",
    unpaired: "एक नया BitBox02 पता चला है। कृपया सत्यापित करें कि निम्न कोड आपके डिवाइस पर दिखाया गया है। यदि कोड मेल खाता है, तो अपने BitBox02 पर चेक मार्क के नीचे टच करें और फिर जारी रखने के लिए नीचे दिए गए बटन पर क्लिक करें।"
  },
  restoreFromMnemonic: {
    failed: "नेमोनिक सीड से बहाल करना विफल रहा, कृपया पुनः प्रयास करें।"
  },
  stepBackup: {
    beforeProceed: "आगे बढ़ने से पहले, कृपया इन महत्वपूर्ण सुरक्षा विचारों को पढ़ें:",
    createBackup: "अब आप अपने माइक्रोएसडी कार्ड पर एक बैकअप बनाएंगे।"
  },
  stepBackupSuccess: {
    fundsSafe: "अपने धन को सुरक्षित रखने के लिए, कृपया निम्नलिखित को याद रखें:",
    title: "बैकअप पुनः स्थापित किया!"
  },
  stepConnected: {
    unlock: "अनलॉक करने के लिए BitBox02 पासवर्ड डाले।"
  },
  stepCreate: {
    nameLabel: "BitBox02 नाम",
    namePlaceholder: "मेरा BitBox02",
    title: "BitBox02 का नाम चुनें",
    toastMicroSD: "कृपया सुनिश्चित करें कि आपका माइक्रोएसडी कार्ड आपके BitBox02 में डाला गया है।"
  },
  stepCreateSuccess: {
    removeMicroSD: "कृपया अपने BitBox02 से माइक्रोएसडी कार्ड निकालें और इसे सुरक्षित स्थान पर संग्रहीत करें।",
    success: "आपने सफलतापूर्वक अपना बैकअप बना लिया है।"
  },
  stepPassword: {
    title: "BitBox02 का पासवर्ड सेट करें",
    useControls: "पासवर्ड सेट करने के लिए अपने BitBox02 के नियंत्रण का उपयोग करें।"
  },
  stepUninitialized: {
    create: "मैं एक नया BitBox02 सेटअप करना चाहता हूं।",
    restore: "मैं अपने वॉलेट को एक बैकअप से पुनर्स्थापित करना चाहता हूं।",
    restoreMicroSD: "माइक्रोएसडी कार्ड से पुनर्स्थापित करें",
    restoreMnemonic: "mnemonic से पुनर्स्थापित करें",
    title: "अपना BitBox02 सेटअप करें"
  },
  success: {
    text: `हुर्रे! आपका BitBox02 अब उपयोग करने के लिए तैयार है।

BitBoxApp का उपयोग कैसे करें के बारे में अधिक जानकारी के लिए, शीर्ष दाएं कोने पर प्रश्न चिह्न पर क्लिक करके इन-ऐप गाइड का उपयोग करें।`,
    title: "आप आगे जाने के लिए तैयार हैं!"
  }
}, blink$8 = {
  button: "झपकी"
}, bootloader$8 = {
  button: "अब फर्मवेयर अपग्रेड करें",
  progress: "अपग्रेड हो रहा है: {{progress}}%",
  success: "अपग्रेड सफल हुआ! कृपया डिवाइस को फिर से डाले। इस बार, बटन को स्पर्श न करें।"
}, button$c = {
  abort: "बीच में ही नष्ट करने के लिए",
  back: "वापस जाएँ",
  changepin: "डिवाइस पासवर्ड बदलें",
  check: "बैकअप की जाँच करें",
  continue: "Continue",
  copy: "कॉपी करें",
  create: "सर्जन करे",
  download: "डाउनलोड",
  hiddenwallet: "हिडन वॉलेट बनाएं",
  next: "आगे",
  ok: "ठीक",
  previous: "पिछला",
  receive: "प्राप्त करें",
  restore: "पुनर्स्थापित करें",
  select: "Select",
  send: "भेजें",
  unlock: "अनलॉक",
  update: "Update",
  upgrade: "अपग्रेड"
}, changePin$8 = {
  newTitle: "नया डिवाइस पासवर्ड",
  oldLabel: "वर्तमान डिवाइस पासवर्ड"
}, checkSDcard$8 = "माइक्रो एसडी कार्ड की जाँच हो रही है", clickHere$8 = "यहां क्लिक करे।", confirm$a = {
  abortInfo: "टेप करे ",
  abortInfoRedText: "बीच में ही नष्ट करे",
  approveInfo: "4+ सेकंड के लिए होल्ड करें",
  approveInfoGreenText: " पुष्टि करने के लिए",
  info: "अपने BitBox पर",
  infoWhenPaired: "पहले आपका पेर किया हुआ मोबाइल और फिर आपका BitBox"
}, confirmOnDevice$8 = "कृपया अपने डिवाइस पर पुष्टि करें।", device$8 = {
  appUpradeRequired: "आपका BitBox इस डेस्कटॉप एप्लिकेशन के अनुकूल नहीं है। कृपया नवीनतम वर्जन डाउनलोड और इंस्टॉल करें।"
}, deviceLock$8 = {
  button: "Two Factor Authorization (2FA) सक्षम करे",
  condition1: "क्या आपके पास बैकअप है?",
  condition2: "क्या मोबाइल ऐप वेरिफिकेशन कार्य कर रहा है?",
  condition3: "2FA बैकअप और मोबाइल ऐप पेयरिंग को बेकार बनाता है। डिवाइस को 2FA से बाहर निकलने के लिए RESET होना चाहिए!",
  confirm: "Two Factor Authorization (2FA) सक्षम करे",
  title: "Two Factor Authorization (2FA) सक्षम करे"
}, deviceSettings$8 = {
  firmware: {
    newVersion: {
      label: "उपलब्ध वर्जन"
    },
    title: "फर्मवेयर",
    upToDate: "आपका डिवाइस अप टू डेट है",
    version: {
      label: "वर्जन"
    }
  },
  hardware: {
    sdcard: {
      false: "डाला नहीं गया",
      label: "माइक्रो एसडी कार्ड",
      true: "डाला गया"
    },
    title: "हार्डवेयर"
  },
  loading: "उपकरण जानकारी पुनर्प्राप्त कर रहा है…",
  pairing: {
    lock: {
      false: "डिसेबल है",
      label: "Two Factor Authorization (2FA)",
      true: "सक्रिय है"
    },
    mobile: {
      false: "बन्द है",
      label: "मोबाइल एप्लिकेशन",
      true: "खोलो"
    },
    status: {
      false: "जोड़ा नहीं",
      label: "स्थिति",
      true: "जुड़ गया"
    },
    title: "पेअर करो"
  },
  secrets: {
    manageBackups: "बैकअप मैनेज करें",
    title: "सीक्रेट"
  }
}, deviceTampered$8 = "क्या आपका BitBox एक रिकवरी पासवर्ड के साथ आया गई है? यदि हां, तो सेटअप प्रक्रिया बंद करें और तुरंत support से संपर्क करें। Shift आपको कभी भी तैयार किए गए वॉलेट या पासवर्ड की सिफारिशें नहीं देगा।", dialog$9 = {
  cancel: "रद्द करे",
  confirm: "पुष्टि करें"
}, fiat$a = {
  default: "डिफ़ॉल्ट",
  setDefault: "set {{code}} as default",
  title: "मुद्राओं"
}, footer$a = {
  appVersion: "एप्लिकेशन वर्जन:"
}, genericError$8 = "एक एरर पाई गई। यदि आपको कोई समस्या दिखाई देती है, तो कृपया एप्लिकेशन को पुनः आरंभ करें।", goal$8 = {
  buttons: {
    create: "एक नया वॉलेट बनाएँ",
    restore: "बैकअप से वॉलेट को पुनर्स्थापित करें"
  },
  paragraph: "कृपया निम्न में से किसी एक विकल्प को चुनें:",
  step: {
    1: {
      title: "सुरक्षा जानकारी"
    },
    2: {
      description: "डिवाइस पासवर्ड सेट करें",
      title: "डिवाइस"
    },
    "3-create": {
      description: "एक नया वॉलेट बनाएँ",
      title: "वॉलेट"
    },
    "3-restore": {
      description: "बैकअप से",
      title: "पुनर्स्थापित करें"
    },
    "4-create": {
      title: "सारांश"
    },
    "4-restore": {
      title: "सारांश"
    }
  }
}, guide$9 = {
  accountDescription: {
    text: "आपका खाता अवलोकन आपके उपलब्ध संतुलन के साथ-साथ आने वाले और बाहर जाने वाले लेनदेन को दर्शाता है। 'सेटिंग्स’ में हमारे गाइड में प्रत्येक खाता प्रकार के बारे में अधिक जानकारी है। ",
    title: "यह पेज मुझे क्या दिखाता है?"
  },
  accountFiat: {
    text: "हाँ। फिएट मुद्राओं के माध्यम से घूमने के लिए किसी भी टिकर पर क्लिक करें। आप सेटिंग्स में मुद्राओं की सूची को बदल सकते हैं।",
    title: "क्या मैं अन्य रूपांतरण दरें प्रदर्शित कर सकता हूं?"
  },
  accountIncomingBalance: {
    text: "आने वाली रकम आपके द्वारा हस्तांतरित की गई राशि के बराबर है लेकिन अभी तक नेटवर्क द्वारा पुष्टि नहीं की गई है।",
    title: "incoming का क्या मतलब है?"
  },
  accountInfo: {
    xpub: {
      text: `एक विस्तारित पुब्लिक की एक रूट की है जिसमें से कोई अकाउंट के सारे रिसीव एड्रेस बनाये जाते हे।
यह यहां केवल-वॉलेट्स जैसे कि इलेक्ट्रम या सेंटिनल के साथ उन्नत उपयोग और इंटरऑपरेबिलिटी के लिए प्रदान किया जाता है।`,
      title: "एक विस्तारित पुब्लिक की क्या है?"
    }
  },
  accountRates: {
    text: `हम CoinGecko से हर मिनट विनिमय दर अपडेट करते हैं। 
`,
    title: "कौन सी विनिमय दरें लागू होती हैं?"
  },
  accountReload: {
    text: "कोई जरूरत नहीं है। आपकी लेन-देन की जानकारी अपने आप अपडेट हो जाती है।",
    title: "क्या मैं लेनदेन इतिहास पुनः लोड कर सकता हूं?"
  },
  accountSendDisabled: {
    text: "आपका शेष शून्य से अधिक होने पर  'Send' बटन सक्रिय हो जाता है।",
    title: "मैं कोई {{unit}} क्यों नहीं भेज सकता ?"
  },
  accountTransactionAttributesBTC: {
    text: `वर्चुअल साइज: नेटवर्क शुल्क निर्धारित करने के लिए उपयोग किया जाता है। यदि ट्रांजेक्शन के साइज से छोटा है तो आपने फीस पर सफलतापूर्वक बचत की है।
साइज: ब्लॉकचैन के अनुसार क्रमबद्ध होने पर बाइट्स में वास्तविक लेनदेन का साइज।
वेइट: Segwit के साथ पेश किया गया, यह ट्रांजेक्शन और ब्लॉक आकारों का मूल्यांकन करने के लिए एक नया मीट्रिक है। प्रत्येक segregated witness बाइट की गिनती एक के रूप में होती है, बाकी सब चार वेट यूनिट के रूप में। वास्तविक आकार में एक मेगाबाइट के बजाय, ब्लॉक आकार की सीमा अब चार मिलियन वेट यूनिट है।`,
    title: "बिटकॉइन-विशिष्ट लेनदेन के विवरण के बारे में क्या?"
  },
  accountTransactionAttributesGeneric: {
    text: `पुष्टि(Confirmations): आपका पहला लेन-देन प्रसारण अपुष्ट है जब तक कि एक miner इसे एक ब्लॉक में शामिल नहीं करता है, जिसके बाद इसकी एक पुष्टि होती है। नेटवर्क पर प्रसारित प्रत्येक ब्लॉक आपके लेनदेन में एक और पुष्टि जोड़ता है। आम तौर पर व्यापारी केवल तीन से छह पुष्टियों के बीच लेनदेन का निपटान करेंगे।
लेनदेन आईडी(Transaction ID): एक विशिष्ट पहचान संख्या जो आपको ब्लॉक एक्सप्लोरर में लेनदेन देखने की अनुमति देती है।
शुल्क(Fee): ब्लॉक में लेनदेन को शामिल करने के लिए एक प्रोत्साहन के रूप में खनिकों को लेनदेन शुल्क का भुगतान किया जाता है। अधिक जानने के लिए, भेजें बटन पर क्लिक करें।`,
    title: "ट्रांजेक्शन के विवरण में दर्शाई गई जानकारी क्या है?"
  },
  accountTransactionConfirmation: {
    text: "यह एक ट्रांजेक्शन है जिसे नेटवर्क पर प्रसारित किया गया है और पुष्टि होने की प्रतीक्षा कर रहा है।",
    title: "पेंडिंग ट्रांजेक्शन क्या है?"
  },
  accountTransactionLabel: {
    text: "यह वह एड्रेस है जहां आपने कोइन्स प्राप्त किए थे या कोइन्स को भेजा था।",
    title: "प्रत्येक लेनदेन के लिए कौन सा पता प्रदर्शित होता है?"
  },
  accountTransactionTime: {
    text: "ब्लॉकचेन लेनदेन पुष्टि समय।",
    title: "क्या समय प्रदर्शित किया जाता है?"
  },
  appendix: {
    link: "हमसे संपर्क करें!",
    text: "एक और सवाल?"
  },
  backups: {
    check: {
      text: "'चेक बैकअप' आपको यह सत्यापित करने की अनुमति देता है कि आपके पास अपने वर्तमान बटुए के अनुरूप काम करने वाला बैकअप है। यह सत्यापित करने के लिए भी उपयोग किया जा सकता है कि आपके पास अभी भी सही पुनर्प्राप्ति पासवर्ड है। आप अपने मुख्य रिकवरी पासवर्ड या अपने छिपे हुए रिकवरी पासवर्ड की जांच कर सकते हैं।",
      title: "'चेक बैकअप’ क्या है?"
    },
    encrypt: {
      text: "नहीं, लेकिन आपके संग्रहीत सीड से वॉलेट को पाने के लिए रिकवरी पासवर्ड जरुरी है लेकिन आपके रिकवरी पासवर्ड को संग्रहीत बीज से वॉलेट प्राप्त करना आवश्यक है।",
      title: "क्या मैं बैकअप एन्क्रिप्ट कर सकता हूं?"
    },
    howOften: {
      text: `नया वॉलेट बनाए जाने पर बैकअप अपने आप जेनरेट हो जाता है। यदि आपका माइक्रोएसडी कार्ड खो जाता है या क्षतिग्रस्त हो जाता है, या यदि आप कई माइक्रोएसडी कार्ड बैकअप के रूप में उपयोग करना चाहते हैं, तो आपको केवल एक नया बैकअप बनाना होगा।
लेन-देन गतिविधि के बाद आपको नए बैकअप बनाने की आवश्यकता नहीं है। आपके सभी लेनदेन डेटा को आपके एकल बैकअप द्वारा पुनः बनाया जा सकता है जो आपके लिए स्वचालित रूप से उत्पन्न हुआ था।`,
      title: "मुझे कितनी बार बैकअप लेना है?"
    },
    whatIsABackup: {
      text: "यह माइक्रोएसडी कार्ड पर सीड की एक प्रति है। आपके पुनर्प्राप्ति पासवर्ड के साथ सीड आपके बटुए को उत्पन्न करता है।",
      title: "बैकअप क्या है?"
    }
  },
  backupsBB02: {
    check: {
      text: "'चेक बैकअप' आपको यह सत्यापित करने की अनुमति देता है कि आपके पास अपने वर्तमान बटुए के अनुरूप काम करने वाला बैकअप है।",
      title: "'चेक बैकअप ’क्या है?"
    },
    encrypt: {
      text: 'नहीं, कृपया माइक्रोएसडी कार्ड को सुरक्षित रखें, क्योंकि इसमें आपके बटुए को पुनर्प्राप्त करने के लिए अनएन्क्रिप्टेड बीज होता है। यदि आप अपने बीज को पासवर्ड से सुरक्षित करना चाहते हैं, तो आप "मैनेज डिवाइस" के तहत विशेषज्ञ सेटिंग्स में एक वैकल्पिक पासफ़्रेज़ सक्षम कर सकते हैं।',
      title: "क्या मैं बैकअप एन्क्रिप्ट कर सकता हूं?"
    },
    whatIsABackup: {
      text: "यह माइक्रो एसडी कार्ड पर सीड की एक नकल है।",
      title: "बैकअप क्या है?"
    }
  },
  bitbox: {
    "2FA": {
      text: `जब 2FA सक्षम होता है, तो कोइन्स को खर्च करने के लिए जोड़े गए मोबाइल फोन पर सभी ट्रांजेक्शन को मंजूरी देनी होती है। थोड़े शब्दों में, एक एन्क्रिप्टेड एकल-उपयोग नंबर मोबाइल ऐप पर भेजा जाता है, वहां डिक्रिप्ट किया जाता है, और स्वीकार बटन दबाते ही BitBox में वापस आ जाता है। डिवाइस के साथ यह संचार मोबाइल फोन और डेस्कटॉप ऐप के बीच पेयरिंग के दौरान स्थापित चैनल के माध्यम से किया जाता है।
2FA सक्षम करने से पहले अपने वॉलेट का बैकअप लें और मोबाइल ऐप को पेयर करें। एक बार सक्षम होने के बाद, माइक्रो एसडी स्लॉट और मोबाइल ऐप पेयरिंग अक्षम हो जाती है। वे BitBox को रीसेट करके फिर से सक्षम हो सकते हैं, जो डिवाइस को मिटा देता है।`,
      title: "Two Factor Authorization (2FA) कैसे काम करता है?"
    },
    disable2FA: {
      text: "2FA को निष्क्रिय करने के लिए, आपको अपना BitBox रीसेट करना होगा और फिर इसके बैकअप से वॉलेट को पुनर्स्थापित करना होगा। सुनिश्चित करें कि आपके पास अभी भी बैकअप के साथ माइक्रो एसडी कार्ड है और आपको अभी भी रिकवरी पासवर्ड याद है। फिर 'रीसेट डिवाइस' दबाएं। एक नया डिवाइस पासवर्ड सेट करें और 'बैकअप पुनर्स्थापित करें' चुनें। वॉलेट से आपके द्वारा बनाया गया बैकअप चुनें, 'रिस्टोर' पर क्लिक करें और वॉलेट बनाते समय आपके द्वारा उपयोग किए गए रिकवरी पासवर्ड को दर्ज करें।",
      title: "मैं Two Factor Authorization (2FA) को कैसे निष्क्रिय कर सकता हूं?"
    },
    ejectBitbox: {
      text: "बिना BitBox को हटाए आप किसी भी समय BitBox को अनप्लग कर सकते हैं।",
      title: "मैं BitBox कैसे निकाल सकता हूं?"
    },
    ejectSD: {
      text: "जब तक आप बैकअप बनाने या पुनर्स्थापित करने की प्रक्रिया में नहीं हैं, तब तक आप किसी भी समय बिटबॉक्स से माइक्रोएसडी कार्ड निकाल सकते हैं।",
      title: "मैं माइक्रो एसडी कार्ड कैसे निकाल सकता हूं?"
    },
    hiddenWallet: {
      text: "यह एक अलग डिवाइस पासवर्ड और रिकवरी पासवर्ड द्वारा संरक्षित एक ही डिवाइस पर एक दूसरा वॉलेट है, जिसका उपयोग आप संभावित इनकार (plausible deniability) के लिए कर सकते हैं। एक ही बैकअप बीज का उपयोग आपके सामान्य और हिडन वॉलेट दोनों के लिए किया जाता है, इसलिए अतिरिक्त बैकअप की आवश्यकता नहीं है।",
      title: "हिडन वॉलेट क्या है?"
    },
    legacyHiddenWallet: {
      text: "पहले नीचे दिए गए बटन पर क्लिक करें (उपलब्ध यदि BitBox मुख्य डिवाइस पासवर्ड के साथ अनलॉक किया गया है और 2FA अक्षम है), तो अपने BitBox को फिर से प्लेग क्रे और इसे अपने छिपे हुए डिवाइस पासवर्ड से अनलॉक करें।",
      title: "मैं लिगेसी हिडन वॉलेट का उपयोग कैसे करूं?"
    },
    pairing: {
      text: "iOS या Android के लिए हमारे मोबाइल ऐप को डाउनलोड करने के बाद, आप प्रदर्शित QR कोड को स्कैन करते हैं, जो मोबाइल ऐप और इस एप्लिकेशन के बीच एक सुरक्षित चैनल सेट करता है। एक बार स्कैन करने के बाद, मोबाइल ऐप में दिए गए निर्देशों का पालन करें।",
      title: "कैसे सुरक्षित रूप से अपने फोन के साथ जोड़े"
    }
  },
  receive: {
    address: {
      text: "आप सिक्के भेजने के लिए दूसरों को पता दे सकते हैं। बस सुनिश्चित करें कि आप सही पते पर भेज रहे हैं।",
      title: "मैं एड्रेस के साथ क्या करूँ?"
    },
    addressChange: {
      text: "जैसे ही आप लेन-देन करते हैं, सूची में एक नया पता अपने आप जुड़ जाता है इसलिए हमेशा 20 पते उपलब्ध होते हैं जिन्हें कभी कोई सिक्का नहीं मिला।",
      title: "एड्रेसिस कब बदलते हैं?"
    },
    howVerify: {
      text: `BitBox01 के लिए, बाईं ओर साइडबार में BitBox आइकन पर क्लिक करें और युग्मन अनुभाग देखें। गाइड अपडेट होगा और आप वहां से निर्देशों का पालन करना जारी रख सकते हैं।
BitBox02 के लिए, आप भेजने / प्राप्त करने की प्रक्रिया के दौरान सीधे डिवाइस पर पते सत्यापित कर सकते हैं।`,
      title: "मैं किसी एड्रेस को सुरक्षित रूप से कैसे सत्यापित कर सकता हूं?"
    },
    why20: {
      text: 'स्टार्ट-अप के दौरान ऐप आपके सीड से प्राप्त पते को यह देखने के लिए उत्पन्न करता है कि क्या उन्हें धन प्राप्त हुआ है।चूंकि एप्लिकेशन लगभग अनंत संख्या में पते उत्पन्न कर सकता है, इसलिए यह शेष राशि निर्धारित करने में वर्षों का समय लगा सकता है। इस खोज को सीमित करने के लिए यह 20 पते देखने के बाद बंद हो जाता है जिन्हें कभी धन नहीं मिला है। यह "गैप सीमा" है और 20 एक वास्तविक मानक है, हालांकि संख्या मनमानी है। ये वे 20 पते हैं जिनसे आप चुन सकते हैं।',
      title: "केवल 20 पते ही क्यों?"
    },
    whyMany: {
      text: "गोपनीयता और सुरक्षा बनाए रखने के लिए, एक ही पते पर दो बार प्रयोग न करें। यदि आपने एक पते का उपयोग किया है, तो एक नए पते के लिए दाहिने तीर पर क्लिक करें। आप एक बार में 20 पते तक उत्पन्न कर सकते हैं।सभी पते आपके एकल बैकअप बीज से प्राप्त होते हैं।",
      title: "कई एड्रेसिस क्यों हैं?"
    },
    whyVerify: {
      text: `
प्रामाणिक पते बनाने और प्रदर्शित करने के लिए आपको अपने कंप्यूटर पर भरोसा नहीं करना चाहिए। यह एक बड़ी हमले की सतह हार्डवेयर वॉलेट की तुलना में इसे काफी कमजोर बनाता है। BitBox01 के लिए, पते को सत्यापित करने का बटन सुरक्षित रूप से एक युग्मित मोबाइल फोन पर पते को भेजता है, जिससे आप QR कोड को स्कैन और सत्यापित भी कर सकते हैं। BitBox02 के लिए, पते को सीधे BitBox02 डिस्प्ले पर सत्यापित किया जा सकता है।`,
      title: "मुझे एड्रेस सुरक्षित रूप से क्यों सत्यापित करना चाहिए?"
    }
  },
  send: {
    fee: {
      text: `शुल्क ट्रांजेक्शन डेटा के साइज पर आधारित है, न कि इसकी राशि पर। शुल्क लक्ष्य की गणना आपके द्वारा चुनी गई प्रत्येक नेटवर्क प्राथमिकता के लिए Bitcoin Core के शुल्क आकलन एल्गोरिथ्म द्वारा की जाती है। यदि वे नीचे दिए गए लक्ष्य से भिन्न हैं, तो उन्हें दिखाया जाता है।
इकोनॉमी: 24 ब्लॉक (Bitcoin के लिए लगभग 4 घंटे, Litecoin के लिए 1 घंटे)
कम: 12 ब्लॉक (Bitcoin के लिए लगभग 2 घंटे, Litecoin के लिए 30 मिनट)
सामान्य: 6 ब्लॉक (Bitcoin के लिए लगभग 1 घंटे, Litecoin के लिए 15 मिनट)
उच्च: 2 ब्लॉक (Bitcoin के लिए लगभग 20 मिनट, Litecoin के लिए 5 मिनट)
(Bitcoin के लिए औसत दस मिनट (लिटकोइन में 2.5 मिनट) में एक ब्लॉक में होता है  और उपरोक्त अवधि में नेटवर्क लोड काफी भिन्न हो सकता है।)`,
      title: "शुल्क कैसे निर्धारित किया जाता है?"
    },
    priority: {
      text: "जितना ज्यादा शुल्क आप भुगतान करने के लिए तैयार हैं, उतनी जल्दी आपके ट्रांजेक्शन की नेटवर्क द्वारा आम तौर पर पुष्टि की जाती है।",
      title: "नेटवर्क प्राथमिकता क्या है?"
    },
    revert: {
      text: `ट्रांजेक्शन पर हस्ताक्षर करने और भेजने (यानी नेटवर्क पर प्रसारित) के बाद, इसे वापस नहीं किया जा सकता है। हस्ताक्षर करने से पहले लेनदेन (शुल्क सहित) को ठीक से सत्यापित करें!
यदि आप प्राप्तकर्ता को जानते हैं और वह या वह आपको वही राशि (लेनदेन शुल्क घटाकर) भेजने को तैयार है, तो आप उन्हें एक नया प्राप्त करने वाला एड्रेस भेज सकते हैं।`,
      title: "क्या मैं ट्रांजेक्शन वापस कर सकता हूं?"
    },
    whyFee: {
      text: `ट्रांजेक्शन माइनर द्वारा पुष्टि किए जाने की होड़ में होते है। माइनर्स अपनी फीस के आधार पर ब्लॉकचैन में शामिल किए जाने वाले ट्रांजेक्शन का चयन करते हैं।
ट्रांजेक्शन के इतिहास पर माइनर्स वोट करते हैं। चूंकि प्रति व्यक्ति एक वोट (जो कि ब्लॉकचेन का पूरा बिंदु है) को लागू करने के लिए कोई विश्वसनीय तीसरा पक्ष नहीं है, माइनर कंप्यूटिंग शक्ति जैसे महंगे संसाधन का त्याग करके लेनदेन पर वोट देते हैं। अपने काम के लिए एक इनाम के रूप में, वे नए बनाए गए कोइन्स और उनके द्वारा शामिल सभी ट्रांजेक्शन के शुल्क का दावा कर सकते हैं।`,
      title: "नेटवर्क शुल्क क्यों है?"
    }
  },
  "settings-electrum": {
    what: {
      text: "शिफ्ट सर्वर का उपयोग करने के बजाय अपने स्वयं के पूर्ण नोड के साथ अपने वॉलेट को चलाना संभव है।",
      title: "यह क्या है?"
    }
  },
  settings: {
    servers: {
      text: `यह ऐप अपडेट, चेक लेन-देन के लिए शिफ़्ट क्रिप्टोकरेंसी सर्वर के साथ संचार करता है, और युग्मित मोबाइल ऐप पर जानकारी भेजता है।
ऐप क्रिप्टोकरंसीप के नवीनतम विनिमय दरों को भी पुनः प्राप्त करता है। सभी रूपांतरणों की गणना स्थानीय रूप से की जाती है जिसका अर्थ है कि आपके लेन-देन की मात्रा के बारे में कोई डेटा कभी प्रसारित नहीं होता है।
नोट: एथेरियम और ईआरसी 20 टोकन के लिए, हम एथरस्कैनियो एपीआई का उपयोग करते हैं।`,
      title: "यह ऐप किन सर्वरों से बात करता है?"
    }
  },
  title: "मार्गदर्शक",
  toggle: {
    close: "गाइड बंद करें",
    open: "गाइड"
  },
  unlock: {
    forgotDevicePassword: {
      text: "आपको रिकवरी पासवर्ड का उपयोग करके डिवाइस को रीसेट करना होगा और वॉलेट को बैकअप से पुनर्स्थापित करना होगा।",
      title: "यदि मैं डिवाइस पासवर्ड भूल गया हूं तो मैं क्या करूं?"
    },
    reset: {
      text: "15 बार एक गलत डिवाइस पासवर्ड डालें। अंतिम कुछ प्रयासों के लिए डिवाइस पर एक लंबे स्पर्श की आवश्यकता होती है।",
      title: "मैं डिवाइस को कैसे रीसेट करूं?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "एक बार डालने पर डिवाइस को ब्लिंक करना चाहिए। सुनिश्चित करें कि यह सही तरीके से डाला गया है। यदि आपको परेशानी हो रही है, तो कृपया नीचे दिए गए लिंक के माध्यम से हमसे संपर्क करें।",
      title: "मेरा BitBox01 पहचान नहीं रहा है"
    },
    getDevice: {
      link: {
        text: "BitBox ऑर्डर करें"
      },
      text: "आप हमारी ऑनलाइन दुकान में BitBox खरीद सकते हैं:",
      title: "मैं BitBox डिवाइस कैसे प्राप्त कर सकता हूं?"
    },
    internet: {
      text: "हां, वॉलेट को सिंक्रनाइज़ करने, ट्रांजेक्शन भेजने और नवीनतम विनिमय दरों को पुनः प्राप्त करने के लिए इंटरनेट कनेक्शन की आवश्यकता होती है।",
      title: "क्या इस ऐप के लिए इंटरनेट कनेक्शन की आवश्यकता है?"
    },
    lostDevice: {
      link: {
        text: "बैकअप सेंटर"
      },
      text: "आप एक नए BitBox पर या हमारे बैकअप सेंटर के साथ अपने अकाउंट को पुनर्प्राप्त कर सकते हैं।",
      title: "मैंने अपना डिवाइस खो दिया। अब क्या?"
    },
    useWithoutDevice: {
      text: "दुर्भाग्य से, यह फिलहाल संभव नहीं है।",
      title: "क्या मैं डिवाइस के बिना ऐप का उपयोग कर सकता हूं?"
    },
    welcome: {
      text: "स्विट्जरलैंड में Shift Crypto द्वारा निर्मित इस ऐप का उपयोग करने के लिए धन्यवाद। हम आपके द्वारा साझा किए गए किसी भी इनपुट की सराहना करते हैं। कृपया नीचे दिए गए लिंक का उपयोग करके प्रतिक्रिया दें।",
      title: "BitBox ऐप में आपका स्वागत है!"
    }
  }
}, headerssync$8 = {
  blocksSynced: "{{blocks}} ब्लॉक सिंक किए गए"
}, hiddenWallet$8 = {
  info1HTML: "संभावित अस्वीकार (plausible deniability) के लिए, <strong>विभिन्न</strong> डिवाइस पासवर्ड + रिकवरी पासवर्ड संयोजन के आधार पर एक हिडन वॉलेट बनाया जा सकता है ।",
  info2HTML: "डिवाइस पासवर्ड और रिकवरी पासवर्ड को परिभाषित करें जिसे आप अपने छिपे हुए वॉलेट के साथ जोड़ना चाहते हैं। जिन्हें आपने अपने प्राथमिक वॉलेट के लिए परिभाषित किया है उनसे डिवाइस पासवर्ड और रिकवरी पासवर्ड <strong>विभिन्न</strong> होना चाहिए   ",
  passwordLabel: "हिडन रिकवरी पासवर्ड",
  passwordPlaceholder: "कृपया हिडन रिकवरी पासवर्ड की पुष्टि करें",
  pinLabel: "हिडन डिवाइस पासवर्ड",
  pinRepeatLabel: "हिडन डिवाइस पासवर्ड को दोहराएं",
  pinRepeatPlaceholder: "कृपया हिडन डिवाइस पासवर्ड की पुष्टि करें",
  success: "हिडन वॉलेट सफलतापूर्वक बनाया गया। इसे अनलॉक करने के लिए अपने BitBox को फिर से भरें।"
}, initialize$8 = {
  create: "डिवाइस पासवर्ड सेट करें",
  creating: "डिवाइस पासवर्ड सेट कर रहे है ...",
  error: {
    e102: "डिवाइस पासवर्ड में कम से कम 4 अक्षर होने चाहिए।"
  },
  info: {
    description1: "अपना डिवाइस पासवर्ड चुनें। इसका उपयोग आपके BitBox को अनलॉक करने के लिए किया जाएगा।",
    description2: "आप संख्याओं, अक्षरों का उपयोग कर सकते हैं। लंबे पासवर्ड उच्च सुरक्षा प्रदान करते हैं।",
    description3: "यदि आप डिवाइस पासवर्ड खो देते हैं, तो आपको अपना डिवाइस रीसेट करना होगा और अपने वॉलेट बैकअप को पुनर्स्थापित करना होगा।",
    subtitle: "अब आप अपना डिवाइस पासवर्ड सेट करेंगे",
    title: "अपने डिवाइस को इनिशियलाइज़ करे"
  },
  input: {
    label: "डिवाइस पासवर्ड",
    labelRepeat: "डिवाइस पासवर्ड दोहराएँ",
    placeholderRepeat: "कृपया डिवाइस पासवर्ड की पुष्टि करें"
  }
}, invalidFormat$8 = "अवैध फॉर्मेट", language$9 = {
  title: "भाषा चुनिए"
}, legacyhiddenwallet$8 = {
  disable: "लिगेसी हिडन वॉलेट को अक्षम करें",
  enable: "लिगेसी हिडन वॉलेट सक्षम करें",
  successDisable: "सफलतापूर्वक लिगेसी हिडन वॉलेट अक्षम कर दिया गया।",
  successEnable: "सफलतापूर्वक लिगेसी हिडन वॉलेट सक्षम किया गया। अपने BitBox को फिर से शुरू करें और लिगेसी हिडन वॉलेट तक पहुंचने के लिए हिडन डिवाइस पासवर्ड दर्ज करें।"
}, loading$8 = "लोड हो रहा है…", notification$8 = {
  newTxs_one: "{{accountName}} में इसमें नया ट्रांजेक्शन",
  newTxs_other: "{{accountName}} में {{count}} नए ट्रांजेक्शंस"
}, pairing$8 = {
  aborted: {
    text: "मोबाइल ऐप से जोड़ी को समाप्त कर दिया गया है।",
    title: "अंत कर दिया"
  },
  button: "मोबाइल ऐप जोड़े",
  confirm: "क्या आप वाकई अपने BitBox को जोड़ना चाहते हैं? ध्यान दें कि उसके बाद ट्रांजेक्शन करने के लिए मोबाइल फोन आवश्यक है।",
  connectOnly: {
    button: "मोबाइल ऐप कनेक्ट करें",
    title: "मेनू आइटम 'नए डेस्कटॉप ऐप से कनेक्ट करें' का चयन करके हमारे मोबाइल ऐप से स्कैन करें"
  },
  error: {
    text: "कुछ गलत हो गया। कृपया फिर से शुरू करें।",
    title: "एरर"
  },
  reconnectOnly: {
    button: "मोबाइल ऐप को फिर से कनेक्ट करें"
  },
  start: {
    hideAppQRCode: "QR कोड छिपाएं",
    revealAppQRCode: "QR कोड दिखाएं",
    step1: "यदि आपके पास मोबाइल ऐप नहीं है, तो आपके पास कौन सा फोन है उसके मुताबिक आप Apple App Store या Google Play Store के लिए QR कोड को स्कैन कर सकते हैं।",
    step2: "हमारे मोबाइल ऐप से स्कैन करें, जिसे आप iOS और Android के लिए ऐप स्टोर में 'Digital BitBox 2FA' नाम से पा सकते हैं:"
  },
  started: {
    text: "अब कृपया मोबाइल ऐप में दिए गए निर्देशों का पालन करें।",
    title: "Great"
  },
  success: {
    text: "बधाई हो, आपने अपने BitBox को सफलतापूर्वक मोबाइल ऐप के साथ जोड़ा है!",
    title: "सफलता"
  },
  timeout: {
    text: "यह जोड़ी दो मिनट के बाद समाप्त हो गई। यदि आप अभी भी मोबाइल ऐप को पेयर करना चाहते हैं तो फिर से शुरू करें।",
    title: "समय समाप्त"
  },
  title: "Mobile Pairing"
}, password$8 = {
  show: "{{label}} दिखाए",
  warning: {
    caps: "चेतावनी: कैप्स लॉक (⇪) सक्षम है",
    paste: 'text चिपकाने के लिए, "{{label}} दिखाए" को सक्षम करें '
  }
}, random$9 = {
  button: "रेण्डम संख्या उत्पन्न करें",
  description: "आपके BitBox ने निम्न {{bits}}-bit यादृच्छिक संख्या उत्पन्न किया :"
}, receive$a = {
  label: "आपका एड्रेस",
  onlyThisCoin: {
    description: "अन्य टोकन प्राप्त करने के लिए, उन्हें सेटिंग में सक्षम करें। यदि आप अन्य टोकन जमा करते हैं, तो हो सकता है की वे सुलभ ना हो सके।",
    warning: "केवल इस पते पर {{coinName}} प्राप्त करना सुनिश्चित करें।"
  },
  showFull: "पूरा एड्रेस दिखाएं और सत्यापित करें",
  title: "{{accountName}} पाए",
  verify: "एड्रेस को सुरक्षित रूप से सत्यापित करें",
  verifyBitBox01: "मोबाइल ऐप पर एड्रेस सत्यापित करें",
  verifyBitBox02: "BitBox02 पर एड्रेस सत्यापित करें",
  verifyInstruction: "कृपया सत्यापित करें कि निम्न एड्रेस आपके डिवाइस पर प्रदर्शित एड्रेस से मेल खाता है।",
  warning: {
    secureOutput: "सुरक्षित पता सत्यापन को सक्षम करने के लिए कृपया अपने मोबाइल डिवाइस के साथ अपने BitBox को जोड़े। साइडबार में 'मैनेज डिवाइस' पर जाएं।"
  }
}, reset$8 = {
  description: "डिवाइस का सभी डेटा हटा दिया जाएगा। जिसमें आपकी निजी कुंजी शामिल है!",
  notReset: "डिवाइस रीसेट नहीं है।",
  title: "फैक्टरी रीसेट डिवाइस",
  understand: "मेरे पास बैकअप है और मेरा रिकवरी पासवर्ड मुझे पता है",
  understandBB02: "मेरे पास एक वैध बैकअप है"
}, securityInformation$8 = {
  create: {
    description1: "अपने डिवाइस को सेट करने से पहले यह सलाह दी जाती है कि आप ऐसा सुरक्षित वातावरण में करें।",
    description2: "आपको दो पासवर्ड बनाने के लिए कहा जाएगा।",
    description3: "पहला है <strong>डिवाइस पासवर्ड</strong> जो आपके BitBox डिवाइस को अनलॉक करता है और ये पासवर्ड बादमे में बदला जा सकता है।",
    description4: "दूसरा है <strong>रिकवरी पासवर्ड</strong> जो आपके वॉलेट को अनलॉक करता है। इस पासवर्ड को बाद में नहीं बदला जा सकता है।",
    description5: "आपके द्वारा बनाया गया वॉलेट, माइक्रो SD कार्ड पर एक फाइल में बैकअप होगा। इसका उपयोग आपातकाल में <strong>रिकवरी पासवर्ड</strong> का उपयोग करके आपके धन को प्राप्त करने के लिए किया जा सकता है ।",
    title: "सुरक्षा जानकारी"
  },
  restore: {
    description1: "आपको उस माइक्रोएसडी कार्ड को डालने के लिए कहा जाएगा जिसका उपयोग आपने बैकअप स्टोर करने के लिए किया था।",
    description2: "अपने डिवाइस को पुनर्स्थापित करने के लिए आपको अपने रिकवरी पासवर्ड की आवश्यकता होगी। ",
    description3: "कृपया रिकवरी पासवर्ड दर्ज करते समय ध्यान रखें। आपके द्वारा दर्ज किया गया कोई भी पासवर्ड एक वैध वॉलेट बनाएगा। यदि आप गलत पासवर्ड दर्ज करते हैं तो आपको एक वॉलेट बैलेंस दिखाया जा सकता है जिसकी आपको उम्मीद नहीं है।",
    title: "सुरक्षा जानकारी"
  }
}, seed$8 = {
  agreements: {
    "funds-access": "यदि मैं अपना रिकवरी पासवर्ड भूल जाता हूं तो मैं अपने फंड तक नहीं पहुंच पाऊंगा",
    "password-change": "मैं बाद में रिकवरी पासवर्ड नहीं बदल सकता",
    "password-required": "एक बैकअप से वॉलेट को पुनर्स्थापित करने के लिए रिकवरी पासवर्ड आवश्यक है"
  },
  create: "वॉलेट बनाएं",
  creating: "वॉलेट बन रहा है",
  description: "मैं समझता हूँ कि:",
  error: {
    e102: "पासवर्ड में कम से कम 4 अक्षर होने चाहिए।",
    e200: "वॉलेट बनाने के लिए आपको अपने BitBox में एक माइक्रो एसडी कार्ड डालने की आवश्यकता होती है, इसलिए एक बैकअप स्वचालित रूप से बनाया जा सकता है।"
  },
  info: {
    button: "अब रिकवरी पासवर्ड सेट करें",
    description1: "BitBox में माइक्रो एसडी कार्ड डालें",
    description2: 'वॉलेट के लिए एक रिकवरी पासवर्ड चुनें और "अब रिकवरी पासवर्ड सेट करें" चुनें।',
    description3: "BitBox डिवाइस के गुम या चोरी हुए मामले में माइक्रो एसडी कार्ड का बैक अप और आपका रिकवरी पासवर्ड ही आपके फंड को रिकवर करने का एकमात्र तरीका है।",
    description4: "आप बाद में अपने धन को स्थानांतरित किए बिना अपना रिकवरी पासवर्ड नहीं बदल सकते।",
    title: "एक नया वॉलेट बनाएँ"
  },
  password: {
    label: "रिकवरी पासवर्ड",
    repeatPlaceholder: "रिकवरी पासवर्ड दोहराएँ"
  },
  walletName: {
    label: "वॉलेट का नाम"
  }
}, seedRestore$8 = {
  error: {
    e200: "बैकअप से वॉलेट को पुनर्स्थापित करने के लिए माइक्रो एसडी कार्ड की आवश्यकता होती है।"
  },
  info: {
    description1: 'BitBox में माइक्रो एसडी कार्ड डालें और "जारी रखें" पर क्लिक करें',
    description2: 'एक बैकअप चुनें और "पुनर्स्थापित करें" पर क्लिक करें',
    description3: "रिकवरी पासवर्ड डालें",
    description4: "आपको यह पुष्टि करने की आवश्यकता है कि आप ये समझते है की एक गलत पासवर्ड एक अलग वॉलेट बनाएगा।",
    title: "बैकअप से वॉलेट को कैसे पुनर्स्थापित करें"
  }
}, send$a = {
  abort: "ट्रांजेक्शन निरस्त कर दिया गया है।",
  address: {
    label: "रिसीवर का एड्रेस",
    placeholder: "एड्रेस डालें"
  },
  amount: {
    label: "रकम",
    placeholder: "राशी डालें"
  },
  button: "हस्ताक्षर करें और भेजें",
  coincontrol: {
    address: "एड्रेस",
    outpoint: "outpoint",
    title: "आउटपुट से भेजें"
  },
  confirm: {
    "selected-coins": "चयनित कोइन्स",
    title: "ट्रांजेक्शन की पुष्टि करें",
    total: "टोटल"
  },
  error: {
    insufficientFunds: "अपर्याप्त कोष",
    invalidAddress: "गलत एड्रेस",
    invalidAmount: "अवैध राशि",
    invalidData: "अमान्य डेटा"
  },
  fee: {
    customPlaceholder: "राशी डालें",
    label: "नेटवर्क शुल्क",
    placeholder: "उपलब्ध नहीं है"
  },
  feeTarget: {
    description: {
      economy: "24 ब्लॉक (Bitcoin के लिए लगभग 4 घंटे, Litecoin के लिए 1 घंटा)",
      high: "2 ब्लॉक (Bitcoin के लिए लगभग 20 मिनट, Litecoin के लिए 5 मिनट)",
      low: "12 ब्लॉक (Bitcoin के लिए लगभग 2 घंटे, Litecoin के लिए 30 मिनट)",
      normal: "6 ब्लॉक (Bitcoin के लिए लगभग 1 घंटे, Litecoin के लिए 15 मिनट)"
    },
    estimate: "अनुमानित प्रतीक्षा समय:",
    label: {
      economy: "किफायती",
      high: "उच्च",
      low: "कम",
      normal: "साधारण"
    },
    placeholder: "शुल्क आकलन की गणना कर रहे हैं ..."
  },
  maximum: "सब भेजें",
  scanQR: "QR कोड स्कैन करें",
  signprogress: {
    description: "यह एक ऐसा ट्रांजेक्शन है जिसमें बहुत अधिक डेटा है। ट्रांजेक्शन पर पूरी तरह से हस्ताक्षर करने के लिए आपको {{steps}} बार पुष्टि करने के लिए कहा जाएगा।",
    label: "प्रगति"
  },
  success: "ट्रांजेक्शन पर हस्ताक्षर किए गए हैं और भेजे गए हैं।",
  title: "{{accountName}} भेजें",
  toggleCoinControl: "Coin Control टॉगल करें"
}, settings$9 = {
  electrum: {
    add: "एक सर्वर जोड़ें",
    "add-server": "जोड़े",
    check: "जांचें",
    checkFailed: "असफल हुआ",
    checkSuccess: "सफलतापूर्वक {{host}} से एक कनेक्शन स्थापित किया ",
    checking: "जांच हो रही है",
    "download-cert": "रिमोट सर्टिफिकेट डाउनलोड करें",
    "remove-server": "हटाएं",
    removeConfirm: "{{server}} हटाएं?",
    reset: "डिफ़ॉल्ट पर रीसेट करे",
    resetConfirm: "क्या आप सभी सर्वरों को हटाना चाहते हैं और डिफ़ॉल्ट सर्वरों को स्थापित करना चाहते हैं?",
    servers: "सर्वर्स",
    step1: "1",
    "step1-text": "endpoint दर्ज करें।",
    step2: "2",
    "step2-text": "सर्वर की सर्टिफिकेट चेन का एक सर्टिफिकेट डालें। वैकल्पिक रूप से, दूरस्थ प्रमाणपत्र डाउनलोड करें और इसे देख के तुलना करें।",
    step3: "3",
    "step3-text": "कनेक्शन की जाँच करें और सर्वर जोड़ें।",
    step4: "4",
    "step4-text": "वॉलेट को पुनरारंभ करें। यदि आप डिफ़ॉल्ट सर्वर को नहीं हटाते हैं, तो आपका अपना नोड अतिरेक के रूप में जोड़ा जाएगा।",
    "title-btc": "Bitcoin Electrum सर्वर्स",
    "title-ltc": "Litecoin Electrum सर्वर्स",
    "title-tbtc": "Bitcoin Testnet Electrum सर्वर्स",
    "title-tltc": "Litecoin Testnet Electrum सर्वर्स"
  },
  expert: {
    coinControl: "कॉइन नियंत्रण सक्षम करें",
    electrum: {
      title: "अपना फूल नोड कनेक्ट करें"
    },
    setProxyAddress: "प्रॉक्सी पता सेट करें",
    title: "विशेषज्ञ सेटिंग्स",
    useProxy: "टोर प्रॉक्सी सक्षम करें"
  },
  header: {
    home: "Home"
  },
  restart: "परिवर्तनों को प्रभावी करने के लिए कृपया BitBoxApp को फिर से शुरू करें।",
  success: "कृपया अनप्लग करें और परिवर्तनों को प्रभावी करने के लिए BitBox को फिर से भरें।",
  title: "सेटिंग्स"
}, setup$8 = "सेटअप डिवाइस", sidebar$9 = {
  device: "डिवाइस मैनेज करे",
  leave: "छोड़े",
  settings: "सेटिंग्स"
}, success$f = {
  create: {
    info1: "आपके वॉलेट को माइक्रो एसडी कार्ड में सुरक्षित रूप से बैकअप दिया गया है। इसे हटा दें और सुरक्षित रखें।",
    info2: "आपने एक सुरक्षित डिवाइस पासवर्ड बनाया है जो BitBox को अनलॉक करता है।",
    info3: "आपने अपने वॉलेट के लिए एक सुरक्षित रिकवरी पासवर्ड बनाया है जो आपके धन को अनलॉक करता है और आपके बैकअप को पुनर्स्थापित करता है।",
    summary: "आपने जो किया है उसका सारांश यहां दिया गया है",
    title: "सफलता"
  },
  getstarted: "शुरू करें",
  restore: {
    summary: "आपने अपने बैकअप से वॉलेट को सफलतापूर्वक पुनर्स्थापित कर दिया है।",
    title: "सफलता"
  }
}, transaction$9 = {
  confirmation: "Confirmations",
  explorer: "ट्रांजेक्शन आईडी",
  explorerTitle: "बाहरी ब्लॉक एक्सप्लोरर में खोलें",
  fee: "शुल्क",
  fiatHistorical: "ऐतिहासिक",
  gas: "Gas",
  pending: "लंबित ट्रांजेक्शन",
  size: "आकार",
  vsize: "आभासी आकार",
  weight: "वजन"
}, transactions$8 = {
  placeholder: "अभी तक कोई ट्रांजेक्शन नहीं हुआ।"
}, unknownError$8 = "एक अज्ञात एरर हुई: {{errorMessage}}", unlock$8 = {
  description: "अपने डिवाइस को अनलॉक करने के लिए अपना डिवाइस पासवर्ड डालें।",
  error: {
    e109_normal: "गलत डिवाइस पासवर्ड। डिवाइस के रीसेट होने से पहले  {{remainingAttempts}} प्रयास बाकी रहे।",
    e109_touch: "$t(unlock.error.e109_normal) अगले लॉगिन के लिए टच बटन को पकड़ना आवश्यक है।",
    e113: "कई लॉगिन प्रयासों के कारण, अगले लॉगिन के लिए 4 सेकंड के लिए टच बटन को दबाए रखना पड़ेगा।"
  },
  input: {
    label: "डिवाइस पासवर्ड",
    placeholder: "डिवाइस को अनलॉक करने के लिए अपना डिवाइस पासवर्ड डालें"
  },
  unlocking: "अनलॉक कर रहे हैं ..."
}, upgradeFirmware$9 = {
  button: "फर्मवेयर अपग्रेड करें",
  description: "क्या आप फर्मवेयर को {{currentVersion}} से {{newVersion}} वर्ज़न में अपग्रेड करना चाहते हैं ?",
  label: "आपके BitBox के लिए फर्मवेयर अपग्रेड आवश्यक है।",
  locked: "{{currentVersion}} से {{newVersion}} अपग्रेड करने के लिए, कृपया एक लंबा स्पर्श करें।",
  title: "फर्मवेयर अपग्रेड करें",
  unlocked: "बूटलोडर अनलॉक किया गया है। जारी रखने के लिए, कृपया:",
  unlocked1: "अपने Bitbox को अनप्लग करें और फिर से प्लग करें ",
  unlocked2: "जब आपका BitBox वापस प्लग इन हो जाएगा तब एलईडी लाइट प्रकाशित होगी",
  unlocked3: "एलईडी लाइट्स प्रकाशित होने पर पर टच बटन पर टैप करें"
}, warning$e = {
  receivePairing: "कृपया सुरक्षित एड्रेस सत्यापन सक्षम करने के लिए BitBox को जोड़ीएं। साइडबार में 'मैनेज डिवाइस' पर जाएं।",
  sdcard: "जब तक आप बैकअप प्रबंधित नहीं करना चाहते, तब तक माइक्रो एसडी कार्ड को बिटबॉक्स से अलग रखें।",
  sendPairing: "ट्रांजेक्शन के विवरण को सुरक्षित रूप से सत्यापित करने के लिए कृपया BitBox को जोड़े। साइडबार में 'मैनेज डिवाइस' पर जाएं।"
}, welcome$8 = {
  insertBitBox02: "BitBox02 के लिए, जारी रखने के लिए कृपया डिवाइस पर टैप करें।",
  insertDevice: "आरंभ करने के लिए कृपया अपना डिवाइस कनेक्ट करें",
  title: "आपका स्वागत हे"
}, appTranslationsHI = {
  account: account$8,
  accountInfo: accountInfo$8,
  accountSummary: accountSummary$8,
  addAccount: addAccount$9,
  app: app$8,
  backup: backup$8,
  bb02Bootloader: bb02Bootloader$8,
  bitbox: bitbox$8,
  bitbox02Interact: bitbox02Interact$8,
  bitbox02Settings: bitbox02Settings$8,
  bitbox02Wizard: bitbox02Wizard$8,
  blink: blink$8,
  bootloader: bootloader$8,
  button: button$c,
  changePin: changePin$8,
  checkSDcard: checkSDcard$8,
  clickHere: clickHere$8,
  confirm: confirm$a,
  confirmOnDevice: confirmOnDevice$8,
  device: device$8,
  deviceLock: deviceLock$8,
  deviceSettings: deviceSettings$8,
  deviceTampered: deviceTampered$8,
  dialog: dialog$9,
  fiat: fiat$a,
  footer: footer$a,
  genericError: genericError$8,
  goal: goal$8,
  guide: guide$9,
  headerssync: headerssync$8,
  hiddenWallet: hiddenWallet$8,
  initialize: initialize$8,
  invalidFormat: invalidFormat$8,
  language: language$9,
  legacyhiddenwallet: legacyhiddenwallet$8,
  loading: loading$8,
  notification: notification$8,
  pairing: pairing$8,
  password: password$8,
  random: random$9,
  receive: receive$a,
  reset: reset$8,
  securityInformation: securityInformation$8,
  seed: seed$8,
  seedRestore: seedRestore$8,
  send: send$a,
  settings: settings$9,
  setup: setup$8,
  sidebar: sidebar$9,
  success: success$f,
  transaction: transaction$9,
  transactions: transactions$8,
  unknownError: unknownError$8,
  unlock: unlock$8,
  upgradeFirmware: upgradeFirmware$9,
  warning: warning$e,
  welcome: welcome$8
}, account$7 = {
  disconnect: "Връзката е прекъсната. Опитваме отново ...",
  exportTransactions: "Експорт на транзакциите в папката Downloads като CSV файл",
  fatalError: "Възникна неочаквана грешка.",
  incoming: "Входящи",
  initializing: "Извличане на информация от блокчейна...",
  reconnecting: "Връзката е прекъсната, опитваме се да я възстановим..."
}, accountInfo$7 = {
  address: "Адрес",
  extendedPublicKey: "Разширен публичен ключ",
  label: "Информация за профила",
  title: "Информация за портфейла",
  verify: "Потвърждение чрез устройството"
}, accountSummary$7 = {
  balance: "Баланс",
  exportSummary: "Експорт на обобщената информация за портфейлите като CSV файл в папката Downloads",
  fiatBalance: "Баланс във фиатна валута",
  name: "Име на портфейла",
  noAccount: "Не съществуват портфейли",
  title: "Обобщена информация за портфейлите",
  total: "Общо"
}, addAccount$8 = {
  title: "Добавяне на портфейл"
}, app$7 = {
  upgrade: "Намерена е по-нова версия на това приложение! Моля актуализирайте от {{current}} до {{version}}."
}, backup$7 = {
  check: {
    checking: "Проверяваме архива...",
    confirmTitle: "Проверка на архив",
    notOK: "Архивът НЕ ОТГОВАРЯ на настоящия портфейл.",
    ok: "Архивът съвпада с настоящия портфейл.",
    password: {
      label: "Парола за възстановяване",
      placeholder: "Парола за възстановяване",
      showLabel: "Парола за възстановяване"
    },
    success: "Успешно проверен архив:",
    title: "Проверка на архив"
  },
  create: {
    alreadyExists: "Вече разполагате с валиден архив. Желаете ли да го създадете повторно?",
    fail: "Създаването на архив беше НЕУСПЕШНО!",
    info: "Моля въведете паролата за възстановяване на текущия портфейл за потвърждение.",
    name: {
      label: "Име на архива",
      placeholder: "Моля задайте име на архива"
    },
    password: {
      label: "Парола за възстановяване",
      placeholder: "Моля въведете паролата за възстановяване"
    },
    title: "Създаване на архив",
    verificationFailed: 'Паролата за възстановяване НЕ СЪВПАДА с тази на настоящия портфейл. Архивът е създаден. Моля използвайте функцията "Проверка на архив", за да потвърдите вашата парола отново.'
  },
  description: "Избор на <strong>архивен файл за портфейла</strong>",
  insert: "Моля поставете microSD картата, за да управлявате архивите.",
  insertButton: "microSD картата е поставена",
  list: "Вашите архиви на micro SD картата:",
  noBackups: "На тази microSD карта няма архиви.",
  restore: {
    confirmTitle: "Възстановяване от архив",
    error: {
      e200: "Не е намерена microSD карта"
    },
    password: {
      label: "Парола за възстановяване или скрита парола за възстановяване",
      placeholder: "Парола за възстановяване",
      repeatPlaceholder: "Въведете паролата за възстановяване още веднъж",
      showLabel: "Парола за възстановяване"
    },
    restoring: "Възстановяване от архив...",
    title: "Възстановяване",
    understand: "Разбирам, че въвеждането на грешна парола за възстановяване ще генерира различен портфейл"
  },
  showMnemonic: {
    description: `Ще ви покажем поредица с дължина до 24 думи, която представлява резервно копие на вашия портфейл. Запишете ги на хартия.

<strong>Не ги съхранявайте в цифров вид и не ги снимайте.</strong>

<strong>Не казвайте думите на глас.</strong>

<strong>Архивът не е защитен с парола.</strong>

След това ще ви помолим да потвърдите всяка дума.`,
    title: "Показване на мнемоничната фраза"
  },
  title: "Управление на архивите"
}, bb02Bootloader$7 = {
  abort: "Прекратяване на актуализацията – Връщане обратно",
  advanced: {
    label: "Разширени настройки",
    toggleShowFirmwareHash: "Показване на контролна сума на фърмуера при всяко стартиране на устройството"
  },
  flipscreen: "Завъртане на екрана",
  orientation: "Устройството е ориентирано по непоходящ начин?",
  success: "Актуализацията е успешна! Рестарт след {{rebootSeconds}} секунди..."
}, bitbox$7 = {
  error: {
    e10000: "Въведената защитна парола на устройството е грешна.",
    e10001: "Неуспешна промяна на защитната парола на устройството",
    e102: "Паролата трябва да съдържа минимум 4 символа",
    e112: "Паролата за скритото устройство не може да бъде същата като паролата на основното устройство."
  }
}, bitbox02Interact$7 = {
  followInstructions: "Моля спазвайте инструкциите, които подава Вашият BitBox02."
}, bitbox02Settings$7 = {
  deviceName: {
    current: "Настоящо име на устройството",
    input: "Име на BitBox02",
    title: "Задайте име на BitBox02"
  }
}, bitbox02Wizard$7 = {
  attestationFailed: "Атестацията на устройството беше неуспешна. Възможно е това да стане, ако рестартирате приложението, докато устройството очаква въвеждане на данни от потребителя. Свържете устройството повторно и опитайте отново.",
  backup: {
    point1: "Изберете архив на microSD картата",
    point2: "Задайте парола за своето устройство",
    restoreText: "ОК, нека възстановим от архив!",
    text1: "Отлично, паролата на Вашия BitBox02 е зададена и портфейлът е генериран. Сега е моментът да създадете първия си архив. Уверете се, че microSD картата е поставена в BitBox02 и продължете.",
    text2: "Следвайте инструкциите на екрана на устройството, за да създадете архив.",
    text3: "След като архивът е създаден, извадете micro SD картата и я съхранете <strong>на сигурно място</strong>. Съдържанието на micro SD картата не е защитено с парола. Никога не я поставяйте в каквото и да е устройство, освен Вашия BitBox02.",
    userConfirmation1: "Трябва да съхранявам архива на сигурно място.",
    userConfirmation2: "Архивът не е защитен с парола. Всеки, който има достъп до него, може да разполага с моя портфейл.",
    userConfirmation3: "Ако изгубя или повредя моя BitBox02, единственият начин да възстановя достъпа до средствата в него е да възстановя от направения архив.",
    userConfirmation4: "Ако изгубя или повредя и архива, и BitBox02 устройството, моите средства ще бъдат изгубени."
  },
  create: {
    button: "Задайте име на устройството и продължете нататък",
    info: "Ето поредицата от стъпки, които трябва да изпълните, за да настроите Вашия BitBox:",
    inputTitle: "Име на портфейла",
    point1: "Задайте име на своето устройство",
    point2: "Задайте парола за своето устройство",
    point3: "Създайте архив",
    text: "ОК, нека създадем нов портфейл!"
  },
  initialize: {
    passwordText: "Нека сега зададем парола за устройството. Използвайте сензорните бутони на Вашия BitBox, за да въведете избраната от Вас парола.",
    passwordTitle: "Задайте парола на Вашия BitBox",
    text: "Връзката с Вашия BitBox02 е успешна! Сега нека инициализираме устройството. Най-напред трябва да изберете дали искате да създадете нов портфейл, или да възстановите съществуващ портфейл от архив. <strong>Уверете се, че във Вашия BitBox02 има поставена microSD карта</strong>",
    tip: "Преди да продължите, ви препоръчваме да установите защитена среда.",
    title: "Инициализиране на Вашия BitBox"
  },
  insertSDCard: "<strong>Уверете се, че във Вашия BitBox02 има поставена microSD карта</strong>",
  pairing: {
    failed: "Връзката не е потвърдена. Моля свържете отново Вашия BitBox02.",
    paired: "Вие потвърдихте чрез устройството, че кодът съвпада. Ако това е вярно, можете да продължите, като натиснете бутона отдолу.",
    title: "Потвърждение на кода за обвързване.",
    unpaired: "Открит е нов BitBox02. Уверете се, че следният код съвпада с показаното на екрана на Вашето устройство. Ако кодът съвпада, натиснете сензорния участък под символа с отметка на екрана на Вашия BitBox02 и натиснете бутона отдолу, за да продължите."
  },
  restoreFromMnemonic: {
    failed: "Неуспешно възстановяване от мнемонична фраза, опитайте отново."
  },
  stepBackup: {
    beforeProceed: "Преди да продължите, моля прочетете тази важна информация за сигурността:",
    createBackup: "Предстои Ви да създадете архив върху Вашата microSD карта."
  },
  stepBackupSuccess: {
    fundsSafe: "За да имате винаги достъп до Вашите средства, моля запомнете следното:",
    title: "Архивът е възстановен!"
  },
  stepConnected: {
    unlock: "Въведете паролата на BitBox02, за да отключите устройството."
  },
  stepCreate: {
    nameLabel: "Име на BitBox02",
    namePlaceholder: "Моето BitBox02 устройство",
    title: "Изберете име за Вашия BitBox02",
    toastMicroSD: "Уверете се, че microSD картата е поставена във Вашия BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "Извадете microSD картата от Вашия BitBox02 и я приберете на сигурно място.",
    success: "Архивът е създаден успешно."
  },
  stepPassword: {
    title: "Задаване на парола на BitBox02",
    useControls: "Използвайте бутоните на Вашия BitBox02, за да зададете парола."
  },
  stepUninitialized: {
    create: "Искам да настроя ново BitBox02 устройство.",
    restore: "Искам да възстановя съществуващ портфейл от архив.",
    restoreMicroSD: "Възстановяване от microSD карта",
    restoreMnemonic: "Възстановяване от мнемонична фраза",
    title: "Настройване на Вашето BitBox02 устройство"
  },
  success: {
    text: `Ура! Вашият BitBox02 е готов за употреба.

За повече информация как да използвате приложението BitBox, използвайте вграденото ръководство за употреба, като кликнете върху въпросителната в горния десен ъгъл на екрана.`,
    title: "Можете да работите!"
  }
}, blink$7 = {
  button: "Мигане"
}, bootloader$7 = {
  button: "Актуализиране на firmware",
  progress: "Актуализиране: {{progress}}%",
  success: "Актуализацията е успешна! Моля извадете устройството и го свържете отново, без да докосвате бутона."
}, button$b = {
  abort: "Прекратяване",
  back: "Назад",
  changepin: "Смяна на паролата на устройството",
  check: "Проверка на архив",
  continue: "Напред",
  copy: "Копиране",
  create: "Създаване",
  download: "Сваляне",
  hiddenwallet: "Създаване на скрит портфейл",
  next: "Напред",
  ok: "ОК",
  previous: "Назад",
  receive: "Получаване",
  restore: "Възстановяване",
  select: "Изберете",
  send: "Изпращане",
  unlock: "Отключване",
  update: "Обновяване",
  upgrade: "Актуализиране"
}, changePin$7 = {
  newTitle: "Нова парола на устройството",
  oldLabel: "Настояща парола на устройството"
}, checkSDcard$7 = "проверка на microSD картата", clickHere$7 = "Кликнете тук", confirm$9 = {
  abortInfo: "Докоснете, за да",
  abortInfoRedText: "прекратите",
  approveInfo: "Задръжте над 4 секунди, за да",
  approveInfoGreenText: "потвърдите",
  info: "на Вашия BitBox",
  infoWhenPaired: "Първо на свързаното мобилно устройство и след това на Вашия BitBox"
}, confirmOnDevice$7 = "Моля потвърдете върху Вашето устройство.", device$7 = {
  appUpradeRequired: "Вашият BitBox не е съвместим с това настолно приложение. Трябва да изтеглите и инсталирате най-новата версия."
}, deviceLock$7 = {
  button: "Активиране на двустепенна автентикация (2FA)",
  condition1: "Разполагате ли с архив?",
  condition2: "Дали верификацията чрез мобилно приложение работи?",
  condition3: "2FA ДЕАКТИВИРА възможностите за създаване на архив и свързване с мобилни приложения. Устройството трябва да се РЕСЕТИРА, за да се изключи 2FA!",
  confirm: "Активиране на двустепенна автентикация (2FA)",
  title: "Активиране на двустепенна автентикация (2FA)"
}, deviceSettings$7 = {
  firmware: {
    newVersion: {
      label: "Налична версия"
    },
    title: "Firmware",
    upToDate: "Вашето устройство използва най-новия софтуер",
    version: {
      label: "Версия"
    }
  },
  hardware: {
    sdcard: {
      false: "Не е поставена",
      label: "microSD карта",
      true: "Поставена"
    },
    title: "Хардуер"
  },
  loading: "Извличане на информация за устройството...",
  pairing: {
    lock: {
      false: "Деактивирано",
      label: "Двустепенна автентикация (2FA)",
      true: "Активирана"
    },
    mobile: {
      false: "Затворено",
      label: "Мобилно приложение",
      true: "Отворено"
    },
    status: {
      false: "Няма връзка",
      label: "Статус",
      true: "Има връзка"
    },
    title: "Обвързване"
  },
  secrets: {
    manageBackups: "Управление на архивите",
    title: "Тайни"
  }
}, deviceTampered$7 = "Ако сте получили парола за възстановяване заедно с Вашия BitBox, прекратете незабавно процеса по настройка и се свържете с екипа по поддръжката. Shift никога не предоставя предварително подготвен портфейл и не дава препоръки за паролата!", dialog$8 = {
  cancel: "Отказ",
  confirm: "Потвърждение"
}, fiat$9 = {
  default: "по подразбиране",
  setDefault: "Задайте {{code}} по подразбиране",
  title: "Валути"
}, footer$9 = {
  appVersion: "Версия на приложението:"
}, genericError$7 = "Възникна грешка. Ако забележите проблеми, рестартирайте приложението.", goal$7 = {
  buttons: {
    create: "Създаване на нов портфейл",
    restore: "Възстановяване на портфейл от архив"
  },
  paragraph: "Изберете една от следните възможности:",
  step: {
    1: {
      title: "Информация за сигурността"
    },
    2: {
      description: "Задаване на парола на устройството",
      title: "Устройство"
    },
    "3-create": {
      description: "Създаване на нов портфейл",
      title: "Портфейл"
    },
    "3-restore": {
      description: "от архив",
      title: "Възстановяване"
    },
    "4-create": {
      title: "Обща информация"
    },
    "4-restore": {
      title: "Обща информация"
    }
  }
}, guide$8 = {
  accountDescription: {
    text: 'Страницата с обща информация за Вашия портфейл показва наличния баланс, входящите и изходящи транзакции. Помощното ръководство в панела "Настройки" предоставя повече информация за различните видове портфейли.',
    title: "Какво се показва на тази страница?"
  },
  accountFiat: {
    text: "Да. Кликнете върху тикера, за да превключвате фиатните валути. Можете да изберете кои валути се показват от панела за настройки.",
    title: "Мога ли да виждам други обменни курсове?"
  },
  accountIncomingBalance: {
    text: 'Колоната "Входящи" сумира всички плащания към Вас, които все още не са потвърдени от мрежата.',
    title: 'Какво означава "Входящи"?'
  },
  accountInfo: {
    xpub: {
      text: "Разширеният публичен ключ (Extended Public Key) представлява базов ключ, от който се генерират всички получаващи адреси в портфейла. Предоставяме го тук за нуждите на опитните потребители и за съвместимост с пасивни портфейли като Electrum и Sentinel.",
      title: "Какво представлява разширеният публичен ключ?"
    }
  },
  accountRates: {
    text: "Обменните курсове се актуализират веднъж на минута от CoinGecko.",
    title: "Какви обменни курсове използваме?"
  },
  accountReload: {
    text: "Не е необходимо. Информация за Вашите транзакции се актуализира автоматично.",
    title: "Мога ли да презаредя информацията за транзакциите?"
  },
  accountSendDisabled: {
    text: 'Бутонът "Изпращане" се активира, когато балансът е по-голям от нула.',
    title: "Защо не мога да изпращам {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    text: `Виртуален размер: определя мрежовата такса. Ако е по-малък от същинския размер на транзакцията, спестявате от такси.
Същински размер: реалният размер на транзакцията в байтове, както се подава към съответния блокчейн.
Тегло: нов параметър, въведен заедно със SegWit с цел определяне на размера на транзакцията и блоковете. Всеки SegWit байт се брои за една тегловна единица, а всички останали байтове се смятат по четири тегловни единици. Вместо един мегабайт същински размер, лимитът за големина на блока вече е четири милиона тегловни единици.`,
    title: "Ами специфичните за Bitcoin подробности за транзакцията?"
  },
  accountTransactionAttributesGeneric: {
    text: `Потвърждения: Вашата транзакция има състояние "непотвърдена", докато някой миньор я включи в блок, при което нейното състояние ще стане "1 потвърждение". Всеки блок, излъчен след това в мрежата, добавя още едно потвърждение на Вашата транзакция. Търговците и други мрежови потребители обичайно приемат транзакцията за валидна едва след като тя получи между 3 и 6 потвърждения.
ID на транзакция: уникален идентификатор, чрез който можете да намерите дадена транзакция чрез block explorer.
Такса: Миньорите получават определена такса като стимул да включат транзакциите в блоковете, които откриват. За да научите повече, натиснете бутона "Изпращане".`,
    title: "Каква информация съдържат подробностите за транзакцията? "
  },
  accountTransactionConfirmation: {
    text: "Транзакция, която е излъчена в мрежата, но още не е потвърдена.",
    title: "Какво означава чакаща (pending) транзакция?"
  },
  accountTransactionLabel: {
    text: "Това е адресът, от който сте получили или към който изпращате пари.",
    title: "Кой адрес се показва за всяка транзакция?"
  },
  accountTransactionTime: {
    text: "Времето за потвърждението на транзакцията в блокчейна.",
    title: "Какво време се показва?"
  },
  appendix: {
    link: "Свържете се с нас!",
    text: "Имате друг въпрос?"
  },
  backups: {
    check: {
      text: '"Проверка на архива" Ви позволява да потвърдите, че разполагате с работещ архив, който съответства на избрания в момента портфейл. Можете да използвате тази функция и за да се уверите, че разполагате с правилната парола за възстановяване. Можете да сверите и главната, и скритата парола за възстановяване.',
      title: 'Какво представлява "Проверка на архива"?'
    },
    encrypt: {
      text: "Не, но Вашата парола е необходима, за да се извлече портфейлът от съхраненото отправно число (seed).",
      title: "Мога ли да криптирам архива?"
    },
    howOften: {
      text: `Архивът се създава автоматично при генерирането на нов портфейл. Необходимо е да направите нов архив само ако повредите или изгубите Вашата microSD карта или ако искате да направите архиви на различни microSD карти.
Не е необходимо да създавате нови архиви след създаването или получаването на нови транзакции. Всичката информация за транзакциите може да се пресъздаде от първоначалния архив, който е създаден автоматично.`,
      title: "Колко често трябва да правя архив?"
    },
    whatIsABackup: {
      text: "Това е копие на отправното число (seed), записано върху microSD карта. Отправното число и паролата за възстановяване генерират Вашия портфейл.",
      title: "Какво представлява архивът?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Проверка на архива" Ви позволява да се уверите, че разполагате с работещ архив, съответстващ на портфейла, който използвате в момента.',
      title: 'Какво представлява "Проверка на архива"?'
    },
    encrypt: {
      text: 'Не. Съхранявайте microSD картата на сигурно място, тъй като тя съдържа в нешифриран вид отправното число (seed), от което се възстановява портфейлът. Ако искате да защитите отправното число с парола, можете да активирате функцията за използване на допълнителна фраза в панела за експертни настройки под "Управление на устройството".',
      title: "Мога ли да шифрирам архива?"
    },
    whatIsABackup: {
      text: "Това е копие на отправното число (seed), записано върху microSD карта.",
      title: "Какво представлява архивът?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Когато е активирана двустепенна автентикация (2FA), всички изходящи транзакции трябва да се потвърдят на обвързания мобилен телефон. По-точно описано, към мобилното устройство се изпраща шифриран номер за еднократна употреба; този номер се дешифрира от устройството и с натискането на бутона "Приемам" (Accept) се връща обратно към BitBox. Комуникацията между двете устройства използва канала за връзка, установен по време на обвързването.

Уверете се, че Вашият портфейл е архивиран и направете обвръзка мобилното устройство, преди да активирате двустепенната автентикация. След като тя се активира, microSD слотът и възможността за обвързване с мобилно устройство се изключват. Можете да ги активирате отново, ако нулирате своя BitBox — операция, която изтрива неговото съдържание.`,
      title: "Как работи двустепенната автентикация (2FA)?"
    },
    disable2FA: {
      text: 'За да премахнете двустепенната автентикация, трябва да нулирате своя BitBox и след това да възстановите портфейла си от архива. Най-напред се уверете, че разполагате с microSD картата с архива и че все още помните паролата за възстановяване. След това натиснете бутона "Нулиране на устройството". Задайте нова парола за устройството и изберете "или възстановяване от архив". Изберете архивното копие на портфейла, кликнете на "Възстановяване" и въведете паролата за възстановяване, която сте използвали при създаването на портфейла.',
      title: "Как мога да премахна двустепенната автентикация (2FA)?"
    },
    ejectBitbox: {
      text: 'Можете да издърпате BitBox по всяко време; няма нужда да изпълнявате "безопасно премахване" (Eject Media).',
      title: "Как да разкача BitBox от компютъра?"
    },
    ejectSD: {
      text: "Можете да извадите microSD картата от BitBox по всяко време, освен ако устройството не се намира в процес на създаване или възстановяване на архив.",
      title: "Как мога да извадя microSD картата?"
    },
    hiddenWallet: {
      text: "Това е втори портфейл в същото устройство, който е защитен с различна защитна парола и парола за възстановяване. Употребата на тази функция прави притежанието на различни портфейли недоказуемо (т.н. 'plausible deniability'). И нормалният, и скритият портфейл използват едно и също отправно число, така че не е необходим отделен архив за скрития портфейл.",
      title: 'Какво представлява "скрит портфейл"?'
    },
    legacyHiddenWallet: {
      text: "Най-напред кликнете на бутона отдолу (той ще се появи ако BitBox е отключен с главната парола на устройството и двустепенната автентикация е изключена), след което извадете и включете BitBox отново и го отключете с паролата за Вашия скрит портфейл.",
      title: "Как да получа достъп до стария (legacy) формат скрит портфейл?"
    },
    pairing: {
      text: "След като свалите мобилното приложение за iOS или Android, трябва да сканирате показания QR код. По този начин между мобилното устройство и това приложение се изгражда защитена връзка. След като сканирате кода, следвайте инструкциите в мобилното приложение.",
      title: "Как да изградите защитена връзка с Вашия телефон"
    }
  },
  receive: {
    address: {
      text: "Можете да предоставите адреса на други потребители, които да Ви изпратят средства по него. Добрата практика е да генерирате нов адрес за всяко плащане.",
      title: "Какво мога да правя с адрес?"
    },
    addressChange: {
      text: "Веднага щом извършите транзакция, към списъка се добавя нов адрес, така че винаги разполагате с 20 адреса, които не са получавали криптовалута.",
      title: "Кога се променят адресите?"
    },
    howVerify: {
      text: `За BitBox01: кликнете на иконата на BitBox в лявата лента и вижте панела "Обвързване". Ръководството ще се презареди и ще покаже на екрана по-нататъшни инструкции.
За BitBox02: потвърждението на адресите става автоматично на устройството в процеса на изпращане/получаване на средства.`,
      title: "Как мога да потвърдя адрес по надежден начин?"
    },
    why20: {
      text: "По време на стартиране, приложението генерира адреси, извлечени от Вашето отправно число (seed) и проверява дали по тях са получени средства. Тъй като приложението може да генерира почти неограничен брой адреси, определянето на баланса може да отнеме години. За да се ограничи времето на търсене, проверката спира след като регистрира 20 последователни адреса, които не са получавали плащания. Това е т.н. праг (gap limit), който е възприет като стандартен в индустрията, макар самото число да е избрано произволно. Това са 20-те адреса, от които можете да избирате.",
      title: "Защо само 20 адреса?"
    },
    whyMany: {
      text: "За да поддържате максимална анонимност и сигурност, никога не използвайте един и същ адрес два пъти. Ако сте използвали вече даден адрес, натиснете дясната стрелка, за да получите нов адрес. Можете да генерирате до 20 адреса наведнъж. Мислете за адресите като за фактури от кочан — всички адреси се генерират от Вашето архивирано отправно число (seed).",
      title: "Защо толкова много адреси?"
    },
    whyVerify: {
      text: "Не трябва да се доверявате на компютъра за генерирането и показването на автентични адреси. Компютърът е значително по-уязвим на атаки от хардуерния портфейл. За BitBox01 бутонът за сигурно потвърждение изпраща адреса към сдвоен мобилен телефон, от който Вие можете също да сканирате и да валидирате QR кода. За BitBox02 адресите могат да се потвърдят директно върху дисплея на самото устройство.",
      title: "Защо трябва да валидирам адресите?"
    }
  },
  send: {
    fee: {
      text: `Таксата зависи от размера на транзакция в байтове, а не от сумата. Таксите се изчисляват чрез алгоритъма на Bitcoin Core за всеки вид приоритет и се показват, ако имат различна стойност от посочените по-долу стандартни стойности.
Икономична: 24 блока (ок. 4 часа за Bitcoin, 1 час за Litecoin)
Ниска: 12 блока (ок. 2 часа за Bitcoin, 30 минути за Litecoin)
Нормална: 6 блока (ок. 1 час за Bitcoin, 15 минути за Litecoin)
Висока: 2 блока (ок. 20 минути за Bitcoin, 5 минути за Litecoin)

Забележка: генерирането на нов блок отнема средно 10 минути за Bitcoin (2.5 минути за Litecoin) и капацитетът на мрежата може да варира значително.`,
      title: "Как се определя мрежовата такса?"
    },
    priority: {
      text: "Колкото по-висока такса предложите, толкова по-бързо Вашата транзакция ще бъде потвърдена от мрежата.",
      title: "Какво представлява мрежовият приоритет?"
    },
    revert: {
      text: `След като веднъж една транзакция бъде подписана и изпратена (т.е. излъчена към мрежата), тя не може да бъде анулирана. Проверете всички детайли на плащането (включително размера на таксата) внимателно, преди да подпишете!
Ако познавате получателя и той или тя приеме да Ви възстанови плащането (след приспадане на разходите по транзакцията), можете да предоставите нов адрес за получаване.`,
      title: "Мога ли да отменя вече направена транзакция?"
    },
    whyFee: {
      text: 'Транзакциите се конкурират помежду си за потвърждение от миньорите. Миньорът подбира кои транзакции да включи във веригата според големината на таксата. Миньорите "гласуват" за историята на транзакциите. Тъй като не съществува доверена трета страна, която да преброява гласовете, миньорите дават своя глас, жертвайки скъп ресурс — изчислителна мощност. Като възнаграждение за своята работа те получават новосъздадени средства и таксите от всички транзакции, които включат в блока.',
      title: "Защо е необходима мрежова такса?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Възможно е да свържете Вашия портфейл към собствен сървър, вместо да използвате сървърите на Shift.",
      title: "Какво е това?"
    }
  },
  settings: {
    servers: {
      text: `Приложението комуникира със сървърите на Shift Crypto, за да проверява за нови версии, да зарежда транзакции и да изпраща информация към сдвоеното мобилно приложение. Също така, приложението тегли актуални обменни курсове от CoinGecko. Всички конверсии се прилагат локално — не се предава никаква информация за размера на Вашите транзакции.
Забележка: за Ethereum и ERC20 токени използваме API-то на Etherscan.io`,
      title: "С кои сървъри комуникира приложението?"
    }
  },
  title: "Ръководство",
  toggle: {
    close: "Затваряне на ръководството",
    open: "Ръководство"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Трябва да нулирате устройството и да възстановите портфейла от архив с помощта на паролата за възстановяване.",
      title: "Какво трябва да направя, ако изгубя защитната парола на устройството?"
    },
    reset: {
      text: "Въведете грешна парола за блокиране на устройството 15 пъти подред. Последните няколко опита изискват дълго докосване на сензора на устройството.",
      title: "Как се нулира устройството?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Устройството трябва да премигне веднъж след поставянето. Уверете се, че е поставено успешно. Ако имате затруднения, свържете се с нас чрез връзката отдолу.",
      title: "Моето BitBox 01 устройство не се разпознава"
    },
    getDevice: {
      link: {
        text: "Поръчайте BitBox устройство"
      },
      text: "Можете да закупите BitBox от нашия онлайн магазин:",
      title: "Как да получа устройство?"
    },
    internet: {
      text: "Да — за синхронизиране на портфейла, изпращане на транзакции и извличане на актуалните обменни курсове е необходима интернет връзка.",
      title: "Приложението изисква ли връзка с интернет?"
    },
    lostDevice: {
      link: {
        text: "Архивен център"
      },
      text: "Можете да възстановите Вашите портфейли върху ново BitBox устройство или с помощта на нашия архивен център",
      title: "Изгубих устройството. Какво следва?"
    },
    useWithoutDevice: {
      text: "За съжаление към момента това все още не е възможно.",
      title: "Мога ли да използвам приложението без устройство?"
    },
    welcome: {
      text: "Благодарим Ви, че използвате настоящото приложение, създадено от Shift Crypto в Швейцария. Ние ценим всеки коментар, който нашите клиенти споделят. За да подадете обратна връзка, моля използвайте линка отдолу.",
      title: "Добре дошли в BitBoxApp!"
    }
  }
}, headerssync$7 = {
  blocksSynced: "Синхронизирани {{blocks}} блока"
}, hiddenWallet$7 = {
  info1HTML: "За допълнителна защита можете да създадете скрит портфейл, базиран на <strong>различна</strong> комбинация от защитна парола и парола за възстановяване. Съществуването на такъв портфейл е недоказуемо.",
  info2HTML: "Отдолу задайте парола за блокиране на устройството и парола за възстановяване на портфейла, които ще се асоциират със скрития портфейл. И паролата за блокиране, и паролата за възстановяване трябва да бъдат <strong>различни</strong> спрямо използваните в основния портфейл.",
  passwordLabel: "Скрита парола за възстановяване",
  passwordPlaceholder: "Моля потвърдете скритата парола за възстановяване",
  pinLabel: "Скрита защитна парола на устройството",
  pinRepeatLabel: "Скрита защитна парола на устройството (повторно)",
  pinRepeatPlaceholder: "Моля потвърдете скритата защитна парола на устройството",
  success: "Скритият портфейл е създаден успешно. Свържете повторно Вашия BitBox, за да го отключите."
}, initialize$7 = {
  create: "Задаване на защитна парола на устройството",
  creating: "Задаване на защитната парола...",
  error: {
    e102: "Защитната парола трябва да съдържа поне 4 символа."
  },
  info: {
    description1: "Изберете защитна парола на устройството. Тя се използва за отключване на Вашия BitBox.",
    description2: "Можете да използвате числа, букви и символи. По-дългите пароли дават по-голяма сигурност.",
    description3: "Ако изгубите защитната парола на устройството, ще се наложи да го нулирате и да възстановите портфейла от архив.",
    subtitle: "Сега трябва да зададете защитна парола за устройството",
    title: "Инициализиране на устройството"
  },
  input: {
    label: "Защитна парола за устройството",
    labelRepeat: "Защитна парола за устройството (повторно)",
    placeholderRepeat: "Моля потвърдете защитната парола за устройството"
  }
}, invalidFormat$7 = "Невалиден формат", language$8 = {
  title: "Избор на език"
}, legacyhiddenwallet$7 = {
  disable: "Деактивиране на скрит портфейл тип Legacy",
  enable: "Активиране на скрит портфейл тип Legacy",
  successDisable: "Скритият Legacy портфейл беше успешно деактивиран.",
  successEnable: "Успешно активиране на скрит портфейл тип Legacy. Свържете отново Вашето BitBox устройство и въведете скритата защитна парола, за да получите достъп до този скрит портфейл."
}, loading$7 = "зареждане...", notification$7 = {
  newTxs_one: "Нова транзакция в {{accountName}}",
  newTxs_other: "{{count}} нови транзакции в {{accountName}}"
}, pairing$7 = {
  aborted: {
    text: "Обвързването беше прекъснато от мобилното приложение.",
    title: "Прекратено"
  },
  button: "Обвързване с мобилното приложение",
  confirm: "Сигурни ли сте, че искате да свържете Вашия BitBox с мобилното приложение? Ако направите това, ще се нуждаете от мобилния си телефон, за да извършвате транзакции.",
  connectOnly: {
    button: "Свързване с мобилното приложение",
    title: 'Сканирайте с мобилното приложение, като изберете опцията "Връзка с ново настолно приложение" от менюто.'
  },
  error: {
    text: "Нещо не е наред. Моля започнете процедурата отначало.",
    title: "Грешка"
  },
  reconnectOnly: {
    button: "Повторно свързване с мобилното приложение"
  },
  start: {
    hideAppQRCode: "Скриване на QR кода",
    revealAppQRCode: "Показване на QR кода",
    step1: "Ако не разполагате с мобилното приложение, можете да сканирате QR кода за Apple App Store или Google Play Store в зависимост от вида на Вашия телефон.",
    step2: "Сканирайте с мобилното приложение, което можете да намерите в софтуерните магазини за iOS и Android под името 'Digital Bitbox 2FA':"
  },
  started: {
    text: "Следвайте инструкциите на екрана на мобилното приложение.",
    title: "Отлично"
  },
  success: {
    text: "Поздравления, сдвояването на Вашия BitBox с мобилното приложение беше успешно!",
    title: "Успех"
  },
  timeout: {
    text: "Опитът за връзка беше прекратен след 2 минути. Пробвайте отново, ако все още искате да свържете мобилното приложение.",
    title: "Таймаут"
  },
  title: "Мобилно обвързване"
}, password$7 = {
  show: "Показване на {{label}}",
  warning: {
    caps: "ВНИМАНИЕ: Caps lock (⇪) е включен",
    paste: 'за да копирате текста, активирайте "ПОКАЗВАНЕ НА {{label}}"'
  }
}, random$8 = {
  button: "Генериране на случайно число",
  description: "Вашият BitBox генерира следното {{bits}}-битово случайно число:"
}, receive$9 = {
  label: "Вашият адрес",
  onlyThisCoin: {
    description: "За да получавате други криптовалути, ги активирайте в настройките. Ако депозирате различна криптовалута тук, е много вероятно да не можете да получите достъп до нея.",
    warning: "Уверете се, че ще получавате само {{coinName}} на този адрес."
  },
  showFull: "Показване и потвърждаване на пълния адрес върху устройство",
  title: "Извличане на {{accountName}}",
  verify: "Сигурно потвърждение на адреса",
  verifyBitBox01: "Потвърждение на адреса чрез мобилно приложение",
  verifyBitBox02: "Потвърждение на адреса чрез BitBox02",
  verifyInstruction: "Уверете се, че адресът съвпада с показания на екрана на Вашето устройство.",
  warning: {
    secureOutput: 'Обвържете Вашия BitBox с мобилно устройство, за да можете да изпълнявате сигурна верификация на адресите. Отворете менюто "Управление на устройството" от страничната лента.'
  }
}, reset$7 = {
  description: "Всички данни върху устройството ще бъдат изтрити. Това включва частния ключ!",
  notReset: "Устройството НЕ Е нулирано.",
  title: "Нулиране на устройството",
  understand: "Разполагам с архив и знам паролата за възстановяване",
  understandBB02: "Разполагам с валиден архив"
}, securityInformation$7 = {
  create: {
    description1: "Преди да настроите своето устройство, уверете се че, че се намирате в сигурна среда.",
    description2: "Ще поискаме от Вас да създадете две пароли.",
    description3: "Първото е <strong>защитната парола</strong>, която отключва Вашето BitBox устройство и може да бъде променяна.",
    description4: "Втората е <strong>паролата за възстановяване от архив</strong>, която отключва Вашия портфейл. Тази парола не може да бъде променяна на по-късен етап.",
    description5: "Създаденият портфейл ще бъде архивиран върху предоставената microSD карта. Този архив може да се използва в аварийна ситуация за възстановяване на достъпа до Вашите средства чрез въвеждане на <strong>паролата за възстановяване</strong>.",
    title: "Информация за сигурността"
  },
  restore: {
    description1: "Ще поискаме от Вас да поставите microSD картата, която съдържа Вашия архив.",
    description2: "За да възстановите съдържанието на устройството, се нуждаете от паролата за възстановяване.",
    description3: "Бъдете изключително внимателни, когато въвеждате паролата за възстановяване. Всяка парола ще създаде валиден портфейл. Ако въведете грешна парола, няма да видите очаквания баланс.",
    title: "Информация за сигурността"
  }
}, seed$7 = {
  agreements: {
    "funds-access": "НЯМА ДА МОГА да получа достъп до моите средства, ако загубя паролата за възстановяване.",
    "password-change": "НЯМА ДА МОГА да променя паролата за възстановяване в по-късен момент.",
    "password-required": "Паролата за възстановяване е необходима за реконструирането на портфейл от архивно копие"
  },
  create: "Създаване на портфейл",
  creating: "Създаване на портфейл...",
  description: "Разбирам, че:",
  error: {
    e102: "Паролата трябва да съдържа минимум 4 символа.",
    e200: "При създаването на портфейл трябва да поставите microSD карта във Вашето BitBox устройство, за да може да бъде генериран автоматичен архив."
  },
  info: {
    button: "Задаване на парола за възстановяване",
    description1: "Поставете microSD картата в BitBox",
    description2: 'Въведете парола за възстановяване на портфейла и изберете "Задаване на парола за възстановяване"',
    description3: "Архивът върху microSD картата и избраната от Вас парола за възстановяване заедно представляват единственото възможно средство за възобновяване на достъпа до Вашите средства в случай, че BitBox устройството бъде изгубено или откраднато.",
    description4: "Не можете да промените паролата за възстановяване на по-късен етап, без да прехвърлите всичките средства от портфейла.",
    title: "Създаване на нов портфейл"
  },
  password: {
    label: "Парола за възстановяване",
    repeatPlaceholder: "Парола за възстановяване (повторете)"
  },
  walletName: {
    label: "Име на портфейла"
  }
}, seedRestore$7 = {
  error: {
    e200: "За възстановяване на портфейл от архива е необходима използваната microSD карта."
  },
  info: {
    description1: 'Поставете microSD картата в BitBox устройството и натиснете "Напред"',
    description2: 'Изберете архив и натиснете "Възстановяване"',
    description3: "Въведете паролата за възстановяване",
    description4: "Трябва да потвърдите, че разбирате, че неправилно въведената парола ще създаде различен портфейл.",
    title: "Как се възстановява портфейл от архив"
  }
}, send$9 = {
  abort: "Транзакцията беше прекъсната.",
  address: {
    label: "Адрес на получателя",
    placeholder: "Въвеждане на адрес"
  },
  amount: {
    label: "Сума",
    placeholder: "Въведете сума"
  },
  button: "Подписване и изпращане",
  coincontrol: {
    address: "Адрес",
    outpoint: "Избор на output",
    title: "Избор на output за харчене"
  },
  confirm: {
    "selected-coins": "Избрана криптовалута",
    title: "Потвърждение на транзакцията",
    total: "Общо"
  },
  error: {
    insufficientFunds: "недостатъчно средства",
    invalidAddress: "невалиден адрес",
    invalidAmount: "невалидна сума",
    invalidData: "невалидни данни"
  },
  fee: {
    customPlaceholder: "Въведете сума",
    label: "Мрежова такса",
    placeholder: "Не е налична"
  },
  feeTarget: {
    description: {
      economy: "24 блока (около 4 часа за Bitcoin, 1 час за Litecoin)",
      high: "2 блока (около 20 минути за Bitcoin, 5 минути за Litecoin)",
      low: "12 блока (около 2 часа за Bitcoin, 30 минути за Litecoin)",
      normal: "6 блока (около 1 час за Bitcoin, 15 минути за Litecoin)"
    },
    estimate: "Прогнозно време за включване:",
    label: {
      economy: "икономична",
      high: "висока",
      low: "ниска",
      normal: "нормална"
    },
    placeholder: "Изчисляване на таксата..."
  },
  maximum: "Изпращане на всичко",
  scanQR: "Сканиране на QR код",
  signprogress: {
    description: "Тази транзакция съдържа много данни. За да я подпишете изцяло са необходими {{steps}} потвърждения.",
    label: "Напредък"
  },
  success: "Транзакцията е подписана и изпратена.",
  title: "Изпращане от {{accountName}}",
  toggleCoinControl: "Контрол върху харченето (Coin Control)"
}, settings$8 = {
  electrum: {
    add: "Добавяне на сървър",
    "add-server": "Добавяне",
    check: "Проверка",
    checkFailed: "Неуспешно",
    checkSuccess: "Успешно установена връзка с {{host}}",
    checking: "Проверка...",
    "download-cert": "Сваляне на сертификата на сървъра",
    "remove-server": "Премахване",
    removeConfirm: "Да премахнем ли {{server}}?",
    reset: "Възстановяване на настройките по подразбиране",
    resetConfirm: "Желаете ли да премахнете всички добавени сървъри и да инсталирате сървърите по подразбиране?",
    servers: "Сървъри",
    step1: "1",
    "step1-text": "Въведете крайната точка.",
    step2: "2",
    "step2-text": "Въведете сертификат за удостоверителната верига на сървъра, или свалете сертификата на сървъра и го сравнете визуално.",
    step3: "3",
    "step3-text": "Проверете връзката и добавете сървъра",
    step4: "4",
    "step4-text": "Рестартирайте портфейла. Ако не премахнете сървърите по подразбиране, вашият собствен сървър ще се използва като резервен.",
    "title-btc": "Bitcoin Electrum сървъри",
    "title-ltc": "Litecoin Electrum сървъри",
    "title-tbtc": "Bitcoin Testnet Electrum сървъри",
    "title-tltc": "Litecoin Testnet Electrum сървъри"
  },
  expert: {
    coinControl: "Активиране на контрола върху монетите (Coin Control)",
    electrum: {
      title: "Свързване на Вашия собствен сървър"
    },
    setProxyAddress: "Задаване на прокси адрес",
    title: "Експертни настройки",
    useProxy: "Активиране на Tor прокси"
  },
  header: {
    home: "Начало"
  },
  restart: "Рестартирайте BitBoxApp, за да могат промените да влязат в сила.",
  success: "Извадете BitBox устройството и го поставете отново, за да могат промените да влязат в сила.",
  title: "Настройки"
}, setup$7 = "Настройка на устройството", sidebar$8 = {
  device: "Управление на устройството",
  leave: "Напускане",
  settings: "Настройки"
}, success$e = {
  create: {
    info1: "Вашият портфейл е успешно архивиран върху microSD картата. Извадете я от устройството и я съхранявайте на сигурно място.",
    info2: "Създадохте силна защитна парола, която служи да отключва Вашия BitBox.",
    info3: "Създадохте сигурна парола за възстановяване на портфейла, която отключва достъпа до Вашата криптовалута и възстановява портфейла от архив.",
    summary: "Резюме на извършените действия",
    title: "Успех"
  },
  getstarted: "Начало",
  restore: {
    summary: "Успешно възстановихте Вашия портфейл от архив.",
    title: "Успех"
  }
}, transaction$8 = {
  confirmation: "Потвърждения",
  explorer: "ID на транзакция",
  explorerTitle: "Отваряне във външен блок експлорер",
  fee: "Такса",
  fiatHistorical: "Исторически стойности",
  gas: "Gas",
  pending: "Транзакция, чакаща потвърждение",
  size: "Размер",
  vsize: "Виртуален размер",
  weight: "Тегло"
}, transactions$7 = {
  placeholder: "Още няма транзакции."
}, unknownError$7 = "Възникна неизвестна грешка: {{errorMessage}}", unlock$7 = {
  description: "Въведете защитната парола, за да отключите Вашето устройство.",
  error: {
    e109_normal: "Грешна защитна парола. Остават {{remainingAttempts}}, преди устройството да се самоизтрие.",
    e109_touch: "$t(unlock.error.e109_normal) Следващия опит за влизане изисква натискане и задържане на сензорния бутон.",
    e113: "Заради много последователни неуспешни опити за вход, следващият опит за въвеждане изисква да задържите сензорния бутон натиснат за 4 секунди."
  },
  input: {
    label: "Защитна парола",
    placeholder: "Въведете защитната парола, за да отключите устройството"
  },
  unlocking: "Отключване..."
}, upgradeFirmware$8 = {
  button: "Актуализиране на firmware",
  description: "Съгласни ли сте да обновите firmware от версия {{currentVersion}} до {{newVersion}}?",
  label: "Вашият BitBox изисква актуализация на firmware.",
  locked: "За да надградите от {{currentVersion}} до {{newVersion}}, моля натиснете сензорния бутон продължително.",
  title: "Актуализиране на firmware",
  unlocked: "Bootloader-ът е отключен. За да продължите, моля:",
  unlocked1: "Откачете и включето отново Вашия BitBox",
  unlocked2: "Когато BitBox устройството е включено отново, ще светне светодиодният индикатор",
  unlocked3: "Когато светодиодният индикатор светне, натиснете сензорния бутон"
}, warning$d = {
  receivePairing: 'Обвържете Вашия BitBox, за да можете да изпълнявате сигурна верификация на адресите. Отворете менюто "Управление на устройството" от страничната лента.',
  sdcard: "Съхранявайте microSD картата отделно от BitBox устройството, освен ако не управлявате архивите.",
  sendPairing: 'Обвържете BitBox устройството, за да можете да потвърждавате параметрите на транзакциите в сигурна среда. Отворете менюто "Управление на устройството" от страничната лента.'
}, welcome$7 = {
  insertBitBox02: "За BitBox02, докоснете сензорния бутон на устройството, за да продължите.",
  insertDevice: "Свържете устройството, за да започнем работа",
  title: "Добре дошли!"
}, appTranslationsBG = {
  account: account$7,
  accountInfo: accountInfo$7,
  accountSummary: accountSummary$7,
  addAccount: addAccount$8,
  app: app$7,
  backup: backup$7,
  bb02Bootloader: bb02Bootloader$7,
  bitbox: bitbox$7,
  bitbox02Interact: bitbox02Interact$7,
  bitbox02Settings: bitbox02Settings$7,
  bitbox02Wizard: bitbox02Wizard$7,
  blink: blink$7,
  bootloader: bootloader$7,
  button: button$b,
  changePin: changePin$7,
  checkSDcard: checkSDcard$7,
  clickHere: clickHere$7,
  confirm: confirm$9,
  confirmOnDevice: confirmOnDevice$7,
  device: device$7,
  deviceLock: deviceLock$7,
  deviceSettings: deviceSettings$7,
  deviceTampered: deviceTampered$7,
  dialog: dialog$8,
  fiat: fiat$9,
  footer: footer$9,
  genericError: genericError$7,
  goal: goal$7,
  guide: guide$8,
  headerssync: headerssync$7,
  hiddenWallet: hiddenWallet$7,
  initialize: initialize$7,
  invalidFormat: invalidFormat$7,
  language: language$8,
  legacyhiddenwallet: legacyhiddenwallet$7,
  loading: loading$7,
  notification: notification$7,
  pairing: pairing$7,
  password: password$7,
  random: random$8,
  receive: receive$9,
  reset: reset$7,
  securityInformation: securityInformation$7,
  seed: seed$7,
  seedRestore: seedRestore$7,
  send: send$9,
  settings: settings$8,
  setup: setup$7,
  sidebar: sidebar$8,
  success: success$e,
  transaction: transaction$8,
  transactions: transactions$7,
  unknownError: unknownError$7,
  unlock: unlock$7,
  upgradeFirmware: upgradeFirmware$8,
  warning: warning$d,
  welcome: welcome$7
}, account$6 = {
  disconnect: "Bağlantı koptu. Tekrar deneniyor...",
  exportTransactions: "İşlemleri İndirilenler Klasörüne CSV Dosyası Olarak Dışa Aktar",
  fatalError: "Beklenmeyen bir hata oluştu.",
  incoming: "Gelen",
  initializing: "Blockchain'den bilgi alınıyor…",
  reconnecting: "Bağlantı koptu, yeniden bağlantı kuruluyor..."
}, accountInfo$6 = {
  address: "Adres",
  extendedPublicKey: "Genişletilmiş Genel Anahtar",
  label: "Hesap bilgileri",
  title: "Hesap Bilgileri",
  verify: "Bu cihazda doğrula"
}, accountSummary$6 = {
  balance: "Bakiye",
  exportSummary: "Hesap Özetini İndirilenler Klasörüne CSV Dosyası Olarak Dışa Aktar",
  fiatBalance: "Fiat Bakiyesi",
  name: "Hesap adı",
  noAccount: "Gösterilecek hesap yok.",
  title: "Hesap Özeti",
  total: "Toplam"
}, addAccount$7 = {
  title: "Hesap Ekle"
}, app$6 = {
  upgrade: "Bu uygulamanın yeni bir sürümü mevcut! Lütfen  {{current}} 'dan  {{version}}'a yükseltin."
}, backup$6 = {
  check: {
    checking: "Yedekleme kontrol ediliyor...",
    confirmTitle: "Yedeklemeyi Kontrol Et",
    notOK: "Yedekleme cüzdanla eşleşmiyor.",
    ok: "Yedekleme cüzdanla eşleşti.",
    password: {
      label: "Şifre yenileme",
      placeholder: "Kurtarma şifresi",
      showLabel: "kurtarma şifresi"
    },
    success: "Başarıyla doğrulanmış yedeklemeler:",
    title: "Yedeklemeyi Kontrol Et"
  },
  create: {
    alreadyExists: "Zaten geçerli bir yedeğiniz var. Yeniden yedeklemek ister misiniz?",
    fail: "Yedekleme oluşturma BAŞARISIZ!",
    info: "Lütfen doğrulama için mevcut cüzdanınızın kurtarma şifresini girin.",
    name: {
      label: "Yedek Adı",
      placeholder: "Lütfen yedeği adlandırın"
    },
    password: {
      label: "Kurtarma Şifresi",
      placeholder: "Lütfen kurtarma şifrenizi girin"
    },
    title: "Yedek Oluştur",
    verificationFailed: "Kurtarma şifresi mevcut cüzdanla eşleşmiyor. Yedekleme oluşturuldu. Lütfen kurtarma şifrenizi tekrar doğrulamak için 'Yedeklemeyi Kontrol Et'i kullanın."
  },
  description: "<strong>cüzdan yedekleme dosyasını</strong> seçin",
  insert: "Yedeklemeleri yönetmek için lütfen micro SD kartı takın.",
  insertButton: "Mikro SD kartımı taktım",
  list: "MicroSD kart yedekleriniz",
  noBackups: "Bu microSD kartta yedekleme yok.",
  restore: {
    confirmTitle: "Yedeklemeyi Geri Yükle",
    error: {
      e200: "SD kart bulunamadı"
    },
    password: {
      label: "Kurtarma şifresi veya gizli kurtarma şifresi",
      placeholder: "Kurtarma şifresi",
      repeatPlaceholder: "Kurtarma şifresini tekrar girin",
      showLabel: "Kurtarma şifresi"
    },
    restoring: "Yedekleme geri yükleniyor...",
    title: "Geri Yükle",
    understand: "Yanlış kurtarma şifresinin farklı bir cüzdan yaratacağını onaylıyorum"
  },
  showMnemonic: {
    description: `Cüzdanınızın yedeğini oluşturan 24 kelimeyi size sunacağız. Onları kağıda yazın.

<strong>Bunları dijital olarak saklamayın veya fotoğraflarını çekmeyin.</strong>

<strong>Kelimeleri yüksek sesle söyleme.</strong>

<strong>Bu yedekleme şifre korumalı değildir.</strong>

Sonrasında, her bir kelimeyi tek tek onaylamanız istenecektir.`,
    title: "BIP39 Anımsatıcısını Göster"
  },
  title: "Yedeklemeleri Yönet"
}, bb02Bootloader$6 = {
  abort: "Yükseltmeyi durdur – Beni geri götür",
  advanced: {
    label: "Gelişmiş Ayarlar",
    toggleShowFirmwareHash: "Her açılışta bellenim hash'ini göster"
  },
  flipscreen: "Ekran çevir",
  orientation: "Cihaz yanlış yöne mi yöneldi?",
  success: "Yükseltme başarılı!  {{rebootSeconds}} saniye içerisinde devam edecek..."
}, bitbox$6 = {
  error: {
    e10000: "Geçerli cihaz şifresi yanlış.",
    e10001: "Cihazın şifresini değiştirme başarısız",
    e102: "Şifre en az 4 karakterden oluşmalıdır.",
    e112: "Gizli cihaz şifresi, ana cihaz şifresi ile aynı olamaz."
  }
}, bitbox02Interact$6 = {
  followInstructions: "Lütfen BitBox02 üzerindeki talimatları takip edin."
}, bitbox02Settings$6 = {
  deviceName: {
    current: "Geçerli cihaz adı",
    input: "BitBox02 Adı",
    title: "BitBox02 cihazınızı isimlendirin"
  }
}, bitbox02Wizard$6 = {
  attestationFailed: "Cihaz onayı başarısız oldu. BitBox'ınız sahte veya tehlikede olabilir. BitBox02 üzerindeki paralar kaybolma riski altında olabilir. Lütfen acilen support@bitbox.swiss ile iletişime geçin.",
  backup: {
    point1: "MicroSD karttan bir yedek seçin",
    point2: "Cihazınız için bir şifre belirleyin",
    restoreText: "Tamam, hadi bir yedeği geri yükleyelim!",
    text1: "Harika, BitBox02 şifreniz ayarlandı ve cüzdan oluşturuldu. Şimdi ilk yedeğinizi oluşturma zamanı. Lütfen microSD kartınızın BitBox02 cihazınıza takılı olduğundan emin olun ve devam edin.",
    text2: "Bir yedekleme oluşturmak için lütfen cihazınızdaki ekrandaki talimatları izleyin.",
    text3: "Yedeklemeniz oluşturulduktan sonra, lütfen microSD kartı çıkarın ve <strong>güvenli bir yerde</strong> saklayın. MicroSD kartın içeriği şifre korumalı değildir. Bu nedenle asla başka bir cihaza yerleştirmeyin.",
    userConfirmation1: "Yedeklememi güvenli bir yerde saklamalıyım.",
    userConfirmation2: "Yedeklerim şifre korumalı değil. Buna erişimi olan herkes cüzdanıma erişebilir.",
    userConfirmation3: "BitBox02 yazılımımı kaybedersem veya zarar verirsem, paramı kurtarmanın tek yolu yedeklememden geri yüklemektir.",
    userConfirmation4: "Hem yedeğimi hem de BitBox02’mi kaybedersem veya zarar verirsem fonlarım kaybolacak."
  },
  create: {
    button: "Cihazı adlandır ve devam et",
    info: "İşte BitBox'ınızı ayarlamak için atmanız gereken temel adımlar: ",
    inputTitle: "Cüzdan adı",
    point1: "Cihazınızı adlandırın",
    point2: "Cihazınız için bir şifre belirleyin",
    point3: "Yedekleme oluştur",
    text: "Tamam, hadi yeni bir cüzdan yaratalım!"
  },
  initialize: {
    passwordText: "Şimdi cihazınız için bir şifre ayarlayalım. Bir şifre girmek ve bir şifre seçmek için BitBox'ınızdaki kontrolleri kullanın.",
    passwordTitle: "BitBox'ınız için bir şifre belirleyin",
    text: "BitBox02 cihazınız başarıyla eşleştirildi! Şimdi cihazınızı başlatalım. Yeni bir cüzdan oluşturmayı veya cüzdanı mevcut bir yedekten geri yüklemeyi seçerek başlayın. <strong>Lütfen BitBox02 cihazınıza takılı bir microSD kartın olduğundan emin olun.</strong>",
    tip: "Başlamadan önce, işlemlere güvenli bir ortamda devam etmeniz şiddetle tavsiye edilir.",
    title: "BitBox'ınızı başlatın"
  },
  insertSDCard: "<strong>Lütfen BitBox02 cihazınıza takılı bir microSD kartın olduğundan emin olun.</strong>",
  pairing: {
    failed: "Onaylanmamış eşleştirme. Lütfen BitBox02'nizi değiştirin.",
    paired: "Cihazınızda kodun eşleştiğini onayladınız. Bu doğruysa, aşağıdaki düğmeye tıklayarak devam edebilirsiniz.",
    title: "Eşleştirme Kodunu Doğrulayın",
    unpaired: "Yeni bir BitBox02 tespit edildi. Lütfen aşağıdaki kodun cihazınızda gösterilenlerle eşleştiğini doğrulayın. Kod eşleşirse, BitBox02 üzerindeki onay işaretinin altındaki simgeye dokunun ve devam etmek için aşağıdaki düğmeye tıklayın."
  },
  restoreFromMnemonic: {
    failed: "BIP39 anımsatıcısından geri yükleme başarısız oldu, lütfen tekrar deneyin."
  },
  stepBackup: {
    beforeProceed: "Devam etmeden önce, lütfen şu önemli güvenlik hususlarını okuyun:",
    createBackup: "Şimdi microSD kartınızda bir yedekleme oluşturacaksınız."
  },
  stepBackupSuccess: {
    fundsSafe: "Fonlarınızı güvende tutmak için lütfen aşağıdakileri unutmayın:",
    title: "Yedekleme Geri Yüklendi!"
  },
  stepConnected: {
    unlock: "Kilidi açmak için BitBox02 şifresini girin."
  },
  stepCreate: {
    nameLabel: "BitBox02 adı",
    namePlaceholder: "Benim BitBox02 cüzdanım",
    title: "BitBox02 adını seçin",
    toastMicroSD: "Lütfen microSD kartınızın BitBox02 cihazınıza takılı olduğundan emin olun."
  },
  stepCreateSuccess: {
    removeMicroSD: "Lütfen microSD kartı BitBox02 cihazınızdan çıkarın ve güvenli bir yerde saklayın.",
    success: "Yedeklemenizi başarıyla oluşturdunuz."
  },
  stepPassword: {
    title: "BitBox02 şifresini ayarla",
    useControls: "Bir şifre belirlemek için BitBox02 üzerindeki kontrolleri kullanın."
  },
  stepUninitialized: {
    create: "BitBox02 cihazımı yeniden kurmak istiyorum.",
    restore: "Cüzdanımı bir yedekten geri yüklemek istiyorum.",
    restoreMicroSD: "MicroSD karttan geri yükle",
    restoreMnemonic: "Anımsatıcıdan geri yükle",
    title: "BitBox02 cihazınızı kurun"
  },
  success: {
    text: `Yaşasın! BitBox02'niz artık kullanıma hazır.

BitBox Uygulaması'nın nasıl kullanılacağı hakkında daha fazla bilgi için, lütfen sağ üst köşedeki soru işaretini tıklayarak uygulama içi kılavuzunu kullanın.`,
    title: "Başlamaya hazırsın!"
  }
}, blink$6 = {
  button: "Göz ardı et"
}, bootloader$6 = {
  button: "Donanım yazılımını şimdi yükselt",
  progress: "Yükseltme: {{progress}}%",
  success: "Yükseltme başarılı! Lütfen cihazı tekrar takın. Bu kez, düğmeye dokunmayın."
}, button$a = {
  abort: "İptal Et",
  back: "Geri",
  changepin: "Cihaz Şifresini Değiştir",
  check: "Yedeklemeyi Kontrol Et",
  continue: "Devam et",
  copy: "Kopyala",
  create: "Oluştur",
  download: "İndir",
  hiddenwallet: "Gizli Cüzdan Oluştur",
  next: "Sonraki",
  ok: "Tamam",
  previous: "Önceki",
  receive: "Alınan",
  restore: "Geri Yükle",
  select: "Seç",
  send: "Gönder",
  unlock: "Kilidini aç",
  update: "Güncelleştirme",
  upgrade: "Yükselt"
}, changePin$6 = {
  newTitle: "Yeni cihazın şifresi",
  oldLabel: "Mevcut cihazın şifresi"
}, checkSDcard$6 = "Mikro SD kart kontrol ediliyor", clickHere$6 = "Buraya tıklayın.", confirm$8 = {
  abortInfo: "Dokunun",
  abortInfoRedText: "İptal et",
  approveInfo: "Şu tuşa 4 saniye basılı tut ",
  approveInfoGreenText: "doğrula",
  info: "BitBox'ınızda",
  infoWhenPaired: "Önce telefonla sonrasında Bitbox'la eşleştirin"
}, confirmOnDevice$6 = "Lütfen cihazınızda onaylayın.", device$6 = {
  appUpradeRequired: "BitBox'ınız bu masaüstü uygulaması ile uyumlu değil. Lütfen en son sürümü indirin ve yükleyin."
}, deviceLock$6 = {
  button: "Two Factor Authorization (2FA) Etkinleştirme",
  condition1: "Bir yedeğin var mı?",
  condition2: "Mobil uygulama doğrulama çalışıyor mu?",
  condition3: "2FA yedekleri ve mobil uygulama eşleştirmesini DEVRE DIŞI bırakır. 2FA'dan çıkmak için cihazın SIFIRLANMASI olması gerekir!",
  confirm: "Two Factor Authorization (2FA) Etkinleştirme",
  title: "Two Factor Authorization (2FA) Etkinleştirme"
}, deviceSettings$6 = {
  firmware: {
    newVersion: {
      label: "Mevcut sürüm"
    },
    title: "Donanım yazılımı",
    upToDate: "Cihazınız güncel",
    version: {
      label: "Versiyon"
    }
  },
  hardware: {
    sdcard: {
      false: "Takılı değil",
      label: "Mikro SD kart",
      true: "Takılı"
    },
    title: "Donanım"
  },
  loading: "Cihaz bilgisi alınıyor…",
  pairing: {
    lock: {
      false: "Devre dışı",
      label: "Two Factor Authorization (2FA)",
      true: "Etkinleştir"
    },
    mobile: {
      false: "Kapalı",
      label: "Mobil Uygulama",
      true: "Aç"
    },
    status: {
      false: "Eşleştirilmemiş",
      label: "Durum",
      true: "Eşleştirilmiş"
    },
    title: "Eşleştirme"
  },
  secrets: {
    manageBackups: "Yedekleri Yönet",
    title: "Secrets"
  }
}, deviceTampered$6 = "BitBox'ınıza kurtarma şifresi mi sağlandı? Öyleyse, kurulum işlemini durdurun ve hemen desteğe başvurun. Ekibimiz asla size hazır bir cüzdan vermez veya şifre önerileri yapmaz.", dialog$7 = {
  cancel: "İptal Et",
  confirm: "Doğrula"
}, fiat$8 = {
  default: "Varsayılan",
  setDefault: "{{code}} varsayılan olarak ayarla",
  title: "Para birimleri"
}, footer$8 = {
  appVersion: "Uygulama Sürümü:"
}, genericError$6 = "Bir hata oluştu. Herhangi bir sorunla karşılaşırsanız, lütfen uygulamayı yeniden başlatın.", goal$6 = {
  buttons: {
    create: "Yeni bir cüzdan oluştur",
    restore: "Cüzdanı yedekten geri yükle"
  },
  paragraph: "Lütfen aşağıdaki seçeneklerden birini seçin:",
  step: {
    1: {
      title: "Güvenlik bilgileri"
    },
    2: {
      description: "Bir cihaz şifresi belirleyin",
      title: "cihaz"
    },
    "3-create": {
      description: "Yeni bir cüzdan oluştur",
      title: "Cüzdan"
    },
    "3-restore": {
      description: "bir yedekten",
      title: "Geri Yükle"
    },
    "4-create": {
      title: "Özet"
    },
    "4-restore": {
      title: "Özet"
    }
  }
}, guide$7 = {
  accountDescription: {
    text: 'Hesabınıza genel bakış, mevcut bakiyenizi, gelen ve giden işlemlerinizi gösterir. " Ayarlar" sekmesindeki kılavuzumuz her hesap türü hakkında daha fazla bilgi içerir. ',
    title: "Bu sayfa bana ne gösteriyor?"
  },
  accountFiat: {
    text: "Evet. Fiat para birimlerine dönüştürmek için herhangi bir ticker'a tıklayın. Ayarlardan Fiat para birimlerini değiştirebilirsiniz.",
    title: "Diğer dönüşüm oranlarını görüntüleyebilir miyim?"
  },
  accountIncomingBalance: {
    text: "Yatırılanlar; size aktarılan ancak henüz ağ tarafından onaylanmayan tutarları gösterir.",
    title: "Yatırılanlar ne demek?"
  },
  accountInfo: {
    xpub: {
      text: `Genişletilmiş bir genel anahtar, bir hesabın tüm alıcı adreslerinin türetildiği bir kök anahtardır.
Burada Electrum veya Sentinel gibi yalnızca izlemek için olan cüzdanlarla ileri düzeyde kullanım ve birlikte çalışabilirlik için sağlanmıştır.`,
      title: "Genişletilmiş genel anahtar nedir?"
    }
  },
  accountRates: {
    text: "Kripto para kurlarını her dakika CoinGecko'dan güncelliyoruz.",
    title: "Hangi döviz kurları uygulanıyor?"
  },
  accountReload: {
    text: "Buna ihtiyacınız yok. İşlem bilgileriniz otomatik olarak güncellenir.",
    title: "İşlem geçmişini yeniden yükleyebilir miyim?"
  },
  accountSendDisabled: {
    text: 'Bakiyeniz sıfırdan fazla olduğunda "Gönder" butonu etkinleşir.',
    title: "Neden hiçbir şey gönderemiyorum {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: `Onaylar: İlk işlem yayınınız, bir madenci bir bloğa dahil edinceye kadar onaylanmaz, ardından bir onay verilir. Ağda yayınlanan her blok, işleminize başka bir onay ekler. Genel olarak, tüccarlar ve diğer ağ aktörler üç ila altı onay aldığında işlemleri gerçekleştirir.
İşlem Kimliği: Bir blok gezgininde bir işlem aramanıza izin veren benzersiz bir kimlik numarası.
Ücret: Madencilere, işlemleri onaylamalarını teşvik etmek için işlem ücreti ödenir. Daha fazla bilgi için, gönder düğmesine tıklayın.`,
    title: "İşlem detaylarındaki bilgiler neler?"
  },
  accountTransactionConfirmation: {
    text: "Ağda yayınlanan ancak henüz onaylanmayan bir işlem.",
    title: "Beklemedeki işlem nedir?"
  },
  accountTransactionLabel: {
    text: "Kripto paralarınızı aldığınız veya gönderdiğiniz adres.",
    title: "Her işlemde görüntülenen adres hangisi?"
  },
  accountTransactionTime: {
    text: "Blockchain işlem onay süresi.",
    title: "Ne zaman görüntülenir?"
  },
  appendix: {
    link: "Bizimle iletişime geçin!",
    text: "Başka bir soru?"
  },
  backups: {
    check: {
      text: "'Yedeklemeyi kontrol et', geçerli cüzdanınıza karşılık gelen çalışan bir yedeklemeniz olduğunu doğrulamanıza olanak tanır. Ayrıca hala doğru kurtarma şifresine sahip olduğunuzu doğrulamak için kullanılabilir. Ana kurtarma şifrenizi veya gizli kurtarma şifrenizi kontrol edebilirsiniz.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: "Hayır, ancak kurtarma şifrenizin cüzdanda depolanan sedden üretilmesi gerekir.",
      title: "Yedeklemeyi şifreleyebilir miyim?"
    },
    howOften: {
      text: `Yeni bir cüzdan oluşturulduğunda, yedekleme otomatik olarak oluşturulur. Yalnızca microSD kartınız kaybolursa veya hasar görürse veya yedek olarak birden fazla microSD kart kullanmak istiyorsanız, yeni bir yedekleme yapmanız gerekir.
İşlem faaliyetinden sonra yeni yedeklemeler oluşturmanıza gerek yoktur. Tüm işlem verileriniz, sizin için otomatik olarak oluşturulan tek bir yedeklemeyle yeniden oluşturulabilir.`,
      title: "Ne sıklıkla yedekleme yapmam gerekir?"
    },
    whatIsABackup: {
      text: "Mikro SD kartınızdaki seedin bir kopyası. Seed, kurtarma şifrenizle birlikte cüzdanınızı oluşturur.",
      title: "Yedek nedir?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Yedeklemeyi kontrol et' geçerli cüzdanınıza karşılık gelen çalışan bir yedeklemeniz olduğunu doğrulamanızı sağlar.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: `Hayır. Seedler şifrelenmemiş bir şekilde tutulduğundan MicroSD kartınızı güvende tutun. Seed'i şifreyle korumak istiyorsanız, "Cihazı yönet" altındaki gelişmiş ayarlardan isteğe bağlı bir şifre etkinleştirebilirsiniz.`,
      title: "Yedeklemeyi şifreleyebilir miyim?"
    },
    whatIsABackup: {
      text: "Bir microSD karttaki seed'in bir kopyası.",
      title: "Yedek nedir?"
    }
  },
  bitbox: {
    "2FA": {
      text: `2FA etkinleştirildiğinde, para harcamak için tüm işlemlerin eşleştirilmiş cep telefonunda onaylanması gerekir. Böylece şiifreli bir tek kullanımlık numara mobil uygulamaya gönderilir, orada şifresi çözülür ve Kabul Et düğmesine basıldığında BitBox'a geri döndürülür. Cihazla bu iletişim, cep telefonu ile eşleştirme sırasında kurulan bu masaüstü uygulaması arasındaki kanal üzerinden yapılır.

2FA'yı etkinleştirmeden önce cüzdanınızı yedeklediğinizden ve mobil uygulamayı eşleştirdiğinizden emin olun. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.`,
      title: "İki faktörlü doğrulama (2FA) nasıl çalışır?"
    },
    disable2FA: {
      text: "2FA'yı devre dışı bırakmak için, BitBox'ınızı sıfırlamanız ve ardından cüzdanı yedekten geri yüklemeniz gerekir. Yedeklemeye sahip microSD kartın hala olduğundan ve kurtarma şifresini hala hatırladığınızdan emin olun. Ardından 'Cihazı sıfırla' tuşuna basın. Yeni bir cihaz şifresi belirleyin ve 'Veya yedeği geri yükle'yi seçin. Cüzdanda oluşturduğunuz yedeklemeyi seçin, 'Geri Yükle'yi tıklayın ve cüzdanı oluştururken kullandığınız kurtarma şifresini girin.",
      title: "İki faktörlü doğrulamayı (2FA) nasıl devre dışı bırakabilirim?"
    },
    ejectBitbox: {
      text: "",
      title: "BitBox'ı nasıl çıkarabilirim?"
    },
    ejectSD: {
      text: "MicroSD kartı BitBox'tan istediğiniz zaman yedekleme oluşturma veya geri yükleme işlemi yapmadığınız sürece kaldırabilirsiniz.",
      title: "MicroSD kartı nasıl çıkarabilirim?"
    },
    hiddenWallet: {
      text: "Aynı cihazda, makul bir reddedilebilirlik için kullanabileceğiniz farklı bir cihaz şifresi ve kurtarma şifresiyle korunan ikinci bir cüzdandır. Aynı yedek send hem normal, hem de gizli cüzdanınız için kullanılır, bu nedenle ek bir yedekleme gerekmez.",
      title: "Gizli cüzdan nedir?"
    },
    legacyHiddenWallet: {
      text: "Önce aşağıdaki düğmeyi tıklayın (BitBox ana cihaz şifresiyle açılmışsa ve 2FA devre dışı bırakılmışsa kullanılabilir), ardından Bitbox'ınızı yeniden takıp kilidini gizli cihaz şifrenizle açın.",
      title: "Eski gizli cüzdanıma nasıl erişirim?"
    },
    pairing: {
      text: "Mobil uygulamamızı iOS veya Android için indirdikten sonra, mobil uygulama ile bu uygulama arasında güvenli bir kanal kuran görüntülenen QR kodunu tararsınız. Tarandıktan sonra mobil uygulamadaki talimatları izleyin.",
      title: "Telefonumla güvenli bir şekilde nasıl eşleştirilir"
    }
  },
  receive: {
    address: {
      text: "Size başkalarının kripto para göndermeleri için adresinizi verebilirsiniz. Sadece doğru adresi gönderdiğinizden emin olun.",
      title: "Bir adres ile ne yapabilirim?"
    },
    addressChange: {
      text: "İşlem yaptığınız anda, otomatik olarak listeye yeni bir adres eklenir, böylece her zaman kripto para almayan 20 adres bulunur.",
      title: "Adresler ne zaman değişir?"
    },
    howVerify: {
      text: `BitBox01 için soldaki kenar çubuğundaki BitBox simgesine tıklayın ve Eşleştirme bölümüne bakın. Kılavuz güncellenir ve oradaki talimatları izlemeye devam edebilirsiniz.
BitBox02 için, gönderme/alma işlemi sırasında adresleri doğrudan cihaz üzerinde doğrulayabilirsiniz.`,
      title: "Bir adresi güvenli bir şekilde nasıl doğrulayabilirim?"
    },
    why20: {
      text: "",
      title: "Neden sadece 20 adres?"
    },
    whyMany: {
      text: "Gizliliği ve güvenliği sağlamak için, aynı adresi asla iki kez vermeyin. Bir adres kullandıysanız, yeni bir adres için sağ oka tıklayın. Bir seferde 20 adede kadar adres oluşturabilirsiniz. Fatura numaraları gibi adresleri düşünün. Tüm adresler, tek yedekleme senedinden türetilir.",
      title: "Neden bu kadar çok adres var?"
    },
    whyVerify: {
      text: "Orijinal adresleri oluşturmak ve görüntülemek için bilgisayarınıza güvenmemelisiniz. Büyük bir saldırı, donanım cüzdanınızın daha savunmasız kalmasını sağlar. BitBox01'in güvenli bir şekilde doğrulama düğmesi, adresi QR kodunu da tarayabileceğiniz ve doğrulayabileceğiniz eşleştirilmiş bir cep telefonuna gönderir. BitBox02 için, adres doğrudan BitBox02 ekranında doğrulanabilir.",
      title: "Neden adresi güvenli bir şekilde doğrulamalıyım?"
    }
  },
  send: {
    fee: {
      text: `Ücret, işlem miktarına değil işlem miktarına göre belirlenir. Ücret hedefleri, seçtiğiniz her ağ önceliği için Bitcoin Core'un ücret tahmin algoritması ile hesaplanır. Aşağıdaki hedeften farklı bir değere sahiplerse gösterilirler.
Ekonomi: 24 blok (Bitcoin için yaklaşık 4 saat, Litecoin için 1 saat)
Düşük: 12 blok (Bitcoin için yaklaşık 2 saat, Litecoin için 30 dakika)
Normal: 6 blok (Bitcoin için yaklaşık 1 saat, Litecoin için 15 dakika)
Yüksek: 2 blok (Bitcoin için yaklaşık 20 dakika, Litecoin için 5 dakika)
(Bir blok Bitcoin için ortalama on dakika sürer (Litecoin'de 2.5 dakika) ve ağ yükü yukarıdaki periyotlarda önemli ölçüde değişebilir.)`,
      title: "Ücret nasıl belirlenir?"
    },
    priority: {
      text: "Ödemek istediğiniz ücret ne kadar yüksekse, işleminiz genellikle ağ tarafından daha erken onaylanır.",
      title: "Ağ önceliği nedir?"
    },
    revert: {
      text: `Bir işlem imzalanıp gönderildikten sonra (yani ağa yayınlanır), artık geri alınamaz. İmzalamadan önce işlemleri (ücret dahil) doğru bir şekilde doğrulayın!
Alıcıyı tanıyorsanız ve aynı tutarı (eksi işlem ücretlerini) size geri göndermeye istekliyse, onlara yeni bir alıcı adresi gönderebilirsiniz.`,
      title: "Bir işlemi geri alabilir miyim?"
    },
    whyFee: {
      text: `İşlemler madenci tarafından onaylanmak için yarışıyor. Madenciler ücretlerine göre Blockchain'e dahil edilecek işlemleri seçiyorlar.
Madenciler işlem tarihine oy veriyor. İşlemleri onaylayacak güvenli bir üçüncü taraf olmadığı için (Blockchain'lerin hepsinde), madenciler bilgisayar gücü gibi pahalı bir kaynaktan fedakarlık yaparak işlemleri oyluyorlar. İşlerinin bir ödülü olarak, yeni oluşturulan paraları ve içerdikleri tüm işlemlerin ücretini talep edebilirler.`,
      title: "Neden ağ ücreti var?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift sunucularını kullanmak yerine cüzdanınıza kendi tam node'larınızla güç vermek mümkündür.",
      title: "Bu nedir?"
    }
  },
  settings: {
    servers: {
      text: `Bu uygulama, güncellemeleri kontrol etmek, işlemleri yüklemek ve eşleştirilmiş mobil uygulamalara bilgi göndermek için Shift Crypto sunucuları ile iletişim kurar.
Bu uygulama aynı zamanda CoinGecko'den en son döviz kurlarını alıyor. Tüm dönüşümler yerel olarak hesaplanır, bu işleminizin miktarı ile ilgili hiçbir veri iletilmediği anlamına gelir.
Not: Ethereum ve ERC20 Tokens için Etherscan.io API'lerini kullanıyoruz.`,
      title: "Bu uygulama hangi sunucularla konuşuyor?"
    }
  },
  title: "Kılavuz",
  toggle: {
    close: "Kılavuzu kapat",
    open: "Kılavuz"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Kurtarma parolasını kullanarak cihazı sıfırlamanız ve cüzdanı bir yedekten geri yüklemeniz gerekir.",
      title: "Cihaz şifresini unuttuğumda ne yapmalıyım?"
    },
    reset: {
      text: "15 kez yanlış cihaz şifresi girin. Son birkaç deneme, cihaza uzun süre dokunmayı gerektirir.",
      title: "Cihazı nasıl sıfırlarım?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Cihaz yerleştirildiğinde bir kez yanıp sönmelidir. Etrafına doğru yerleştirildiğinden emin olun. Eğer sorun yaşıyorsanız, lütfen aşağıdaki bağlantıdan bize ulaşın.",
      title: "BitBox01 tanınmıyor"
    },
    getDevice: {
      link: {
        text: "Bir BitBox siparişi verin"
      },
      text: "Online mağazamızda bir BitBox satın alabilirsiniz:",
      title: "Nasıl bir cihazı nasıl alabilirim?"
    },
    internet: {
      text: "Evet, cüzdanı senkronize etmek, işlemleri göndermek ve en son kurları almak için bir internet bağlantısı gerekir.",
      title: "Bu uygulama internet bağlantısı gerektiriyor mu?"
    },
    lostDevice: {
      link: {
        text: "Yedekleme merkezi"
      },
      text: "Hesaplarınızı yeni bir BitBox'la veya yedekleme merkezimizde kurtarabilirsiniz.",
      title: "Cihazımı kaybettim. Şimdi ne olacak?"
    },
    useWithoutDevice: {
      text: "Ne yazık ki, şu anda bu henüz mümkün değil.",
      title: "Bir cihaz olmadan uygulamayı kullanabilir miyim?"
    },
    welcome: {
      text: "Shift Crypto tarafından İsviçre'de üretilen bu uygulamayı kullandığınız için teşekkür ederiz. Paylaşmanız gereken herhangi bir geri bildirimi takdir ediyoruz. Lütfen alttaki bağlantıyı kullanarak geri bildirimde bulunun.",
      title: "BitBoxApp'a Hoşgeldiniz!"
    }
  }
}, headerssync$6 = {
  blocksSynced: "{{blocks}} blok senkronize edildi"
}, hiddenWallet$6 = {
  info1HTML: "",
  info2HTML: "Aşağıdaki gizli cüzdanınızla ilişkilendirmek istediğiniz cihaz şifresini ve kurtarma şifresini tanımlayın. Cihaz şifresi ve kurtarma şifresi <strong>farklı</strong> birincil cüzdanınız için tanımladığınızdan emin olun",
  passwordLabel: "Gizli kurtarma şifresi",
  passwordPlaceholder: "Lütfen gizli kurtarma şifresini onaylayın",
  pinLabel: "Gizli cihaz şifresi",
  pinRepeatLabel: "Gizli cihaz şifresini tekrarla",
  pinRepeatPlaceholder: "Lütfen gizli cihaz şifresini onayla",
  success: "Gizli cüzdan başarıyla oluşturuldu. Kilidini açmak için BitBox'ınızı değiştirin."
}, initialize$6 = {
  create: "Cihaz şifresini ayarla",
  creating: "Cihaz şifresini ayarla",
  error: {
    e102: "Cihaz şifresi en az 4 karakterden oluşmalıdır."
  },
  info: {
    description1: "Cihaz şifrenizi seçin. Bu, BitBox'ınızın kilidini açmak için kullanılacaktır.",
    description2: "Sayıları, harfleri ve sembolleri kullanabilirsiniz. Daha uzun şifreler daha yüksek güvenlik sunar.",
    description3: "Cihaz şifresini kaybederseniz, cihazınızı sıfırlamanız ve cüzdan yedeklemenizi geri yüklemeniz gerekir.",
    subtitle: "Şimdi cihaz şifrenizi ayarlayacaksınız",
    title: "Cihazınız başlatılıyor"
  },
  input: {
    label: "Cihaz parolası",
    labelRepeat: "Cihaz şifresini tekrarla",
    placeholderRepeat: "Lütfen cihaz şifresini doğrulayın"
  }
}, invalidFormat$6 = "Geçersiz format", language$7 = {
  title: "Dil Seçin"
}, legacyhiddenwallet$6 = {
  disable: "Eski gizli cüzdanı devre dışı bırak",
  enable: "Eski gizli cüzdanı etkinleştir",
  successDisable: "Eski gizli cüzdanı başarıyla devre dışı bıraktınız.",
  successEnable: "Eski gizli cüzdanı başarıyla etkinleştirdi. Eski gizli cüzdanınıza erişmek için BitBox'ınızı değiştirin ve gizli cihaz şifresini girin."
}, loading$6 = "Yükleniyor…", notification$6 = {
  newTxs_one: "{{accountName}}'da yeni işlem",
  newTxs_other: "{{count}} Yeni işlem: {{accountName}}"
}, pairing$6 = {
  aborted: {
    text: "Eşleştirme işlemi mobil uygulamadan kaldırıldı.",
    title: "Kaldırıldı"
  },
  button: "Mobil Uygulamayla Eşleştir",
  confirm: "BitBox'ınızı eşleştirmek istediğinizden emin misiniz? Sonradan, cep telefonunun bir işlem gerçekleştirmesi gerektiğini unutmayın.",
  connectOnly: {
    button: "Mobil Uygulamayı Bağla",
    title: "'Yeni masaüstü uygulamasına bağlan' öğesini seçerek mobil uygulamamız ile tarayın"
  },
  error: {
    text: "Bir şeyler yanlış gitti. Lütfen tekrar başla.",
    title: "Hata"
  },
  reconnectOnly: {
    button: "Mobil Uygulamayı Yeniden Bağla"
  },
  start: {
    hideAppQRCode: "QR Kodunu Gizle",
    revealAppQRCode: "QR Kodunu Göster",
    step1: "Mobil uygulamanız yoksa, sahip olduğunuz telefona bağlı olarak Apple App Store veya Google Play Store için QR kodunu tarayabilirsiniz.",
    step2: "İOS ve Android uygulama mağazalarında 'Digital Bitbox 2FA' adı altında bulabileceğiniz mobil uygulamamız ile tarayın:"
  },
  started: {
    text: "Şimdi mobil uygulamadaki talimatları izleyin.",
    title: "Harika"
  },
  success: {
    text: "Tebrikler, BitBox'ınızı mobil uygulamayla başarıyla eşleştirdiniz!",
    title: "Başarılı"
  },
  timeout: {
    text: "Eşleştirme iki dakikanın ardından zaman aşımına uğradı. Mobil uygulamayı hala eşleştirmek istiyorsanız tekrar başlayın.",
    title: "Zaman aşımı"
  },
  title: "Mobil Eşleştirme"
}, password$6 = {
  show: "Göster {{label}}",
  warning: {
    caps: "UYARI: Büyük harf kilidi (⇪) aktif",
    paste: 'Metni yapıştırmak için "GÖSTER" butonunu etkinleştirin {{label}}"'
  }
}, random$7 = {
  button: "Rastgele Sayı Üret",
  description: "BitBox'ınız aşağıdaki {{bits}}-bit random sayıları üretti:"
}, receive$8 = {
  label: "Sizin adresiniz",
  onlyThisCoin: {
    description: "Başka token'ları almak için, onları ayarlardan etkinleştirin. Diğer token'ları yatırırsanız, erişilebilir olmayabilir.",
    warning: "Sadece bu adresle  {{coinName}} almak istediğinize emin olun"
  },
  showFull: "Cihazdaki tam adresi göster ve doğrula",
  title: "{{accountName}} Al",
  verify: "Adresi güvenli bir şekilde doğrulayın",
  verifyBitBox01: "Mobil uygulamadaki adresi doğrula",
  verifyBitBox02: "BitBox02'deki adresi doğrulayın",
  verifyInstruction: "Lütfen aşağıdaki adresin cihazınızda görüntülenen adresiyle eşleştiğini doğrulayın.",
  warning: {
    secureOutput: "Güvenli adres doğrulamasını etkinleştirmek için lütfen BitBox'ınızı mobil cihazınızla eşleştirin ve kenar çubuğundaki 'Cihazı Yönet' seçeneğine tıklayın."
  }
}, reset$6 = {
  description: "Cihazdaki tüm veriler silinecek. Buna Özel Anahtarınız da dahil!",
  notReset: "Cihazı SIFIRLAMA.",
  title: "Cihazı sıfırla",
  understand: "Bir yedeğim var ve kurtarma şifremi biliyorum",
  understandBB02: "Geçerli bir yedeğim var"
}, securityInformation$6 = {
  create: {
    description1: "Cihazınızı kurmadan önce bunu güvenli bir ortamda yapmanız önerilir.",
    description2: "Sizden iki şifre oluşturmanız istenecektir.",
    description3: "İlki <strong>cihaz parolası</strong>. Bu şifre BitBox cihazınızın kilidini açar ve daha sonra değiştirilebilir.",
    description4: "İkincisi cüzdanınızın kilidini açan <strong>kurtarma şifresi</strong>. Bu şifre daha sonra değiştirilemez.",
    description5: "Oluşturduğunuz cüzdan, sağlanan mikro SD karttaki bir dosyaya yedeklenir. Bu, acil durumda <strong>kurtarma şifrenizi</strong> kullanarak fonlarınıza ulaşmanızı sağlar.",
    title: "Güvenlik Uyarısı"
  },
  restore: {
    description1: "Yedeklemenizi saklamak için kullandığınız mikro SD kartı takmanız istenecektir.",
    description2: "Cihazınızı geri yüklemek için kurtarma şifrenizin olması gerekir. ",
    description3: "Lütfen kurtarma şifresini girerken dikkatli olun. Girdiğiniz herhangi bir şifre geçerli bir cüzdan yaratacaktır. Yanlış şifre girerseniz, beklemediğiniz bir cüzdan bakiyesi gösterilebilir.",
    title: "Güvenlik Uyarısı"
  }
}, seed$6 = {
  agreements: {
    "funds-access": "Kurtarma şifremi unutursam parama ulaşamayacağım",
    "password-change": "Kurtarma şifresini daha sonra değiştiremem",
    "password-required": "Bir cüzdanı bir yedekten geri yüklemek kurtarma şifresi gerektirir."
  },
  create: "Cüzdan Oluştur",
  creating: "Cüzdan oluşturma",
  description: "Bunu kabul ediyorum:",
  error: {
    e102: "Şifre en az 4 karakterden oluşmalıdır.",
    e200: "Cüzdan oluşturmak için BitBox'ınıza bir mikro SD kart takmanız gerekir, böylece yedekleme otomatik olarak oluşturulabilir."
  },
  info: {
    button: "Kurtarma şifresini şimdi ayarla",
    description1: "Mikro SD kartı BitBox'a takın",
    description2: "Cüzdan için bir kurtarma şifresi ayarlayın ve “Şimdi kurtarma şifresini ayarla” seçeneğini tıklayın.",
    description3: "Micro SD karta yedekleme ve kurtarma şifreniz, BitBox cihazın kaybolması veya çalınması durumunda paranızı kurtarmak için tek yöntemdir.",
    description4: "Paranızı aktarmadan kurtarma şifrenizi  değiştiremezsiniz.",
    title: "Yeni bir cüzdan oluştur"
  },
  password: {
    label: "Kurtarma şifresi",
    repeatPlaceholder: "Kurtarma şifresini tekrarla"
  },
  walletName: {
    label: "Cüzdan adı"
  }
}, seedRestore$6 = {
  error: {
    e200: "Bir cüzdanı yedekten geri yüklemek için mikro SD kart gerekir."
  },
  info: {
    description1: `Mikro SD kartı BitBox'a takın ve "Devam Et" öğesine tıklayın`,
    description2: 'Bir yedekleme seçin ve "Geri Yükle" öğesini seçin',
    description3: "Kurtarma şifresini girin",
    description4: "Yanlış bir şifrenin farklı bir cüzdan yaratacağını kabul ettiğinizi onaylamanız gerekir.",
    title: "Bir cüzdanı bir yedekten geri yükleme"
  }
}, send$8 = {
  abort: "İşlem iptal edildi.",
  address: {
    label: "Alıcı adresi",
    placeholder: "Adresi girin"
  },
  amount: {
    label: "Miktar",
    placeholder: "Miktarı girin"
  },
  button: "İmzala ve Gönder",
  coincontrol: {
    address: "Adres",
    outpoint: "Çıktı",
    title: "Çıktıdan Gönder"
  },
  confirm: {
    "selected-coins": "Seçilmiş Kripto Paralar",
    title: "İşlemi Onayla",
    total: "Toplam"
  },
  error: {
    insufficientFunds: "yetersiz bakiye",
    invalidAddress: "geçersiz adres",
    invalidAmount: "geçersiz miktar",
    invalidData: "geçersiz veri"
  },
  fee: {
    customPlaceholder: "Miktarı girin",
    label: "Ağ Ücreti",
    placeholder: "Kullanılabilir değil"
  },
  feeTarget: {
    description: {
      economy: "24 blok (Bitcoin için yaklaşık 4 saat, Litecoin için 1 saat)",
      high: "2 blok (Bitcoin için yaklaşık 20 dakika, Litecoin için 5 dakika)",
      low: "12 blok (Bitcoin için yaklaşık 2 saat, Litecoin için 30 dakika)",
      normal: "6 blok (Bitcoin için yaklaşık 1 saat, Litecoin için 15 dakika)"
    },
    estimate: "Tahmini bekleme süresi:",
    label: {
      economy: "ekonomi",
      high: "yüksek",
      low: "düşük",
      normal: "normal"
    },
    placeholder: "Hesaplanan tahmini ücret"
  },
  maximum: "Hepsini gönder",
  scanQR: "QR Kodunu Tara",
  signprogress: {
    description: "Bu, çok fazla veri içeren bir işlemdir. İşlemi tamamen imzalamak için  {{steps}} defa onaylamanız istenir.",
    label: "İlerleme"
  },
  success: "İşlem imzalandı ve gönderildi.",
  title: "Gönder {{accountName}}",
  toggleCoinControl: "Kripto para kontrolünü aç"
}, settings$7 = {
  electrum: {
    add: "Bir sunucu ekle",
    "add-server": "Ekle",
    check: "Kontrol et",
    checkFailed: "Başarısız oldu",
    checkSuccess: "Başarıyla bağlantı kuruldu {{host}}",
    checking: "Kontrol ediliyor",
    "download-cert": "Uzak sertifikayı indir",
    "remove-server": "Kaldır",
    removeConfirm: "Kaldır {{server}}?",
    reset: "Varsayılana sıfırla",
    resetConfirm: "Tüm sunucuları kaldırmak ve varsayılan sunucuları kurmak istiyor musunuz?",
    servers: "Sunucular",
    step1: "1",
    "step1-text": "Bitiş noktasını girin.",
    step2: "2",
    "step2-text": "Sunucunun sertifika zincirinden bir sertifikasını girin. Alternatif olarak, uzak sertifikayı indirin ve görsel olarak karşılaştırın.",
    step3: "3",
    "step3-text": "Bağlantınızı kontrol edin ve sunucuyu ekleyin.",
    step4: "4",
    "step4-text": "Cüzdanınızı yeniden başlatın. Varsayılan sunucuları kaldırmazsanız, kendi düğümünüz fazlalık olarak eklenir.",
    "title-btc": "Bitcoin Electrum Sunucuları",
    "title-ltc": "Litecoin Electrum Sunucuları",
    "title-tbtc": "Bitcoin Testnet Electrum Sunucuları",
    "title-tltc": "Litecoin Testnet Electrum Sunucuları"
  },
  expert: {
    coinControl: "Coin kontrolünü etkinleştir",
    electrum: {
      title: "Kendi tam node'unuza bağlayın"
    },
    setProxyAddress: "Proxy adresini ayarla",
    title: "Uzman Ayarları",
    useProxy: "Tor proxy'yi etkinleştir"
  },
  header: {
    home: "Ev"
  },
  restart: "Lütfen değişikliklerin geçerli olması için BitBoxApp’i yeniden başlatın.",
  success: "Değişikliklerin etkili olması için lütfen BitBox’un fişini çekin ve yeniden takın.",
  title: "Ayarlar"
}, setup$6 = "Cihaza Kurulum Yap", sidebar$7 = {
  device: "Cihazı Yönet",
  leave: "Ayrıl",
  settings: "Ayarlar"
}, success$d = {
  create: {
    info1: "Cüzdanınız micro SD Karta güvenli bir şekilde yedeklendi. Çıkarın ve güvenli bir yerde saklayın.",
    info2: "BitBox'un kilidini açan güvenli bir cihaz şifresi oluşturdunuz.",
    info3: "Cüzdanınız için paranızın kilidini açan ve yedeklerinizi geri yükleyen güvenli bir kurtarma şifresi oluşturdunuz.",
    summary: "İşte işlem özetiniz",
    title: "Başarılı"
  },
  getstarted: "Başlarken",
  restore: {
    summary: "Yedeklemenizden bir cüzdanı başarıyla geri yüklediniz.",
    title: "Başarılı"
  }
}, transaction$7 = {
  confirmation: "Onaylar",
  explorer: "İşlem Kimliği",
  explorerTitle: "Harici explorer'da aç",
  fee: "Ücret",
  fiatHistorical: "Tarih",
  gas: "Gas",
  pending: "Bekleyen işlem",
  size: "Boyut",
  vsize: "Sanal boyut",
  weight: "Ağırlık"
}, transactions$6 = {
  placeholder: "Henüz işlem yok."
}, unknownError$6 = "Bilinmeyen bir hata oluştu: {{errorMessage}}", unlock$6 = {
  description: "Cihazınızın kilidini açmak için cihaz şifrenizi girin.",
  error: {
    e109_normal: "Cihaz şifresi yanlış. Cihaz sıfırlanmadan önce {{remainingAttempts}} yapabilirsiniz.",
    e109_touch: "$t(unlock.error.e109_normal) Bir sonraki giriş için dokunmatik düğmeye basılı tutmanız gerektirir.",
    e113: "Birçok giriş denemesi nedeniyle, bir sonraki giriş için dokunmatik düğmeye 4 saniye basılı tutmanız gerekiyor."
  },
  input: {
    label: "Cihaz şifresi",
    placeholder: "Cihazın kilidini açmak için cihaz şifrenizi girin."
  },
  unlocking: "Kilit açılıyor"
}, upgradeFirmware$7 = {
  button: "Donanım yazılımını yükselt",
  description: "Donanım yazılımını  {{currentVersion}}'dan {{newVersion}}'a yükseltmek istiyor musunuz??",
  label: "BitBox'ınızın ürün yazılımının yükseltilmesi gerekiyor.",
  locked: " {{currentVersion}} den yükseltmek için için {{newVersion}}, lütfen uzun süre basılı tutun.",
  title: "Donanım yazılımını yükselt",
  unlocked: "Bootloader kilidi açıldı. Devam etmek için lütfen:",
  unlocked1: "Bitbox'ınızı çıkarın ve yeniden takın",
  unlocked2: "BitBox'unuz tekrar takıldığında LED yanacaktır",
  unlocked3: "LED yandığında düğmeye dokunun"
}, warning$c = {
  receivePairing: "Güvenli adres doğrulamasını etkinleştirmek için lütfen BitBox'ı eşleştirin. Kenar çubuğunda 'Cihazı Yönet' seçeneğine gidin.",
  sdcard: "Yedeklemeleri yönetmek istemediğiniz sürece, mikro SD kartı BitBox'tan ayrı saklayın.",
  sendPairing: "İşlem ayrıntılarını güvenli bir şekilde doğrulamak için lütfen BitBox'ı eşleştirin. Kenar çubuğundan 'Cihazı Yönet' seçeneğine gidin."
}, welcome$6 = {
  insertBitBox02: "Devam etmek için lütfen cihaza dokunun.",
  insertDevice: "Başlamak için lütfen cihazınızı bağlayın",
  title: "Hoşgeldiniz"
}, appTranslationsTR = {
  account: account$6,
  accountInfo: accountInfo$6,
  accountSummary: accountSummary$6,
  addAccount: addAccount$7,
  app: app$6,
  backup: backup$6,
  bb02Bootloader: bb02Bootloader$6,
  bitbox: bitbox$6,
  bitbox02Interact: bitbox02Interact$6,
  bitbox02Settings: bitbox02Settings$6,
  bitbox02Wizard: bitbox02Wizard$6,
  blink: blink$6,
  bootloader: bootloader$6,
  button: button$a,
  changePin: changePin$6,
  checkSDcard: checkSDcard$6,
  clickHere: clickHere$6,
  confirm: confirm$8,
  confirmOnDevice: confirmOnDevice$6,
  device: device$6,
  deviceLock: deviceLock$6,
  deviceSettings: deviceSettings$6,
  deviceTampered: deviceTampered$6,
  dialog: dialog$7,
  fiat: fiat$8,
  footer: footer$8,
  genericError: genericError$6,
  goal: goal$6,
  guide: guide$7,
  headerssync: headerssync$6,
  hiddenWallet: hiddenWallet$6,
  initialize: initialize$6,
  invalidFormat: invalidFormat$6,
  language: language$7,
  legacyhiddenwallet: legacyhiddenwallet$6,
  loading: loading$6,
  notification: notification$6,
  pairing: pairing$6,
  password: password$6,
  random: random$7,
  receive: receive$8,
  reset: reset$6,
  securityInformation: securityInformation$6,
  seed: seed$6,
  seedRestore: seedRestore$6,
  send: send$8,
  settings: settings$7,
  setup: setup$6,
  sidebar: sidebar$7,
  success: success$d,
  transaction: transaction$7,
  transactions: transactions$6,
  unknownError: unknownError$6,
  unlock: unlock$6,
  upgradeFirmware: upgradeFirmware$7,
  warning: warning$c,
  welcome: welcome$6
}, account$5 = {
  disconnect: "连接断开.重试中...",
  exportTransactions: "将交易导出为CSV文件并下载文件夹",
  fatalError: "出现意外错误",
  incoming: "传入",
  initializing: "正在从区块链网络中获取信息",
  reconnecting: "链接断开，尝试重新链接"
}, accountInfo$5 = {
  address: "地址",
  extendedPublicKey: "扩展公钥",
  label: "帐户信息",
  title: "帐户信息",
  verify: "请在设备上进行验证"
}, accountSummary$5 = {
  balance: "余额",
  exportSummary: "将帐户摘要导出为CSV文件并保存到下载文件夹中",
  fiatBalance: "法币余额",
  name: "账户名",
  noAccount: "还未添加账户",
  title: "帐户汇总",
  total: "总计"
}, addAccount$6 = {
  title: "添加账户"
}, app$5 = {
  upgrade: "该应用程序有新版本可用！请从 {{current}} 升级至 {{version}}。"
}, backup$5 = {
  check: {
    checking: "正在检查备份…",
    confirmTitle: "检查备份",
    notOK: "备份与钱包不匹配。",
    ok: "备份与钱包匹配。",
    password: {
      label: "恢复密码",
      placeholder: "恢复密码",
      showLabel: "恢复密码"
    },
    success: "成功验证备份：",
    title: "检查备份"
  },
  create: {
    alreadyExists: "您已经拥有一个有效备份。您想重新创建它吗？",
    fail: "创建备份失败！",
    info: "请输入当前钱包的恢复密码以进行验证。",
    name: {
      label: "备份名称",
      placeholder: "请为该备份命名"
    },
    password: {
      label: "恢复密码",
      placeholder: "请输入您的恢复密码"
    },
    title: "创建备份",
    verificationFailed: "恢复密码与当前的钱包不匹配。备份已创建。请使用“检查备份”再次验证您的恢复密码。"
  },
  description: "选择 <strong>钱包备份文件</strong>",
  insert: "请插入Micro SD卡以管理备份。",
  insertButton: "我已插入Micro SD卡",
  list: "您的microSD卡备份",
  noBackups: "此microSD卡上没有备份。",
  restore: {
    confirmTitle: "恢复已有备份",
    error: {
      e200: "找不到(无法识别到)microSD卡"
    },
    password: {
      label: "恢复密码或隐藏恢复密码",
      placeholder: "恢复密码",
      repeatPlaceholder: "重复恢复密码",
      showLabel: "恢复密码"
    },
    restoring: "正在还原备份…",
    title: "恢复",
    understand: "我知道输入错误的恢复密码会创建出另一个不同的钱包"
  },
  showMnemonic: {
    description: `系统将为您提供最多24个单词，构成您的钱包(助记词)备份。请把它们用抄写到纸上。

<strong>请勿将其数字化存储或对其进行拍照。</strong>

<strong>不要大声说出这些单词。</strong>

<strong>此备份不受密码加密保护。</strong>

抄写完成后，您将需要再次核对每个单词。`,
    title: "显示助记词"
  },
  title: "管理备份"
}, bb02Bootloader$5 = {
  abort: "不要升级-退回",
  advanced: {
    label: "高级设置",
    toggleShowFirmwareHash: "每次启动时显示固件哈希"
  },
  flipscreen: "翻转屏幕",
  orientation: "设备方向错误？",
  success: "升级成功！继续(等待) {{rebootSeconds}} 秒..."
}, bitbox$5 = {
  error: {
    e10000: "当前输入的设备密码不正确",
    e10001: "更改设备密码失败",
    e102: "密码必须包含至少4个字符",
    e112: "隐藏的设备密码不能与主设备密码相同。"
  }
}, bitbox02Interact$5 = {
  followInstructions: "请按照BitBox02上的说明进行操作。"
}, bitbox02Settings$5 = {
  deviceName: {
    current: "当前设备名称",
    input: "BitBox02 名称",
    title: "设置BitBox02的设备名称"
  }
}, bitbox02Wizard$5 = {
  attestationFailed: "设备认证失败，可能是由于在设备等待用户输入时应用程序重新启动所致。请重新连接，然后重试。",
  backup: {
    point1: "在microSD卡上选择一个备份",
    point2: "为您的设备设置密码",
    restoreText: "好的，现在让我们还原备份！",
    text1: "太棒了，您的BitBox02设备密码已设置完成，并成功创建了新钱包。现在是时候创建您的第一个备份了。请确保您的microSD卡已插入BitBox02设备中并继续。",
    text2: "请按照设备屏幕上的提示创建备份。",
    text3: "创建备份后，请取出microSD卡并将其存储在<strong>安全的地方</strong>。 microSD卡的内容不受密码保护。请勿将其插入BitBox02以外的任何其他设备中。",
    userConfirmation1: "我应该将备份存储在安全的地方。",
    userConfirmation2: "我的备份不受密码保护。任何有权访问它的人都可以访问我的钱包。",
    userConfirmation3: "如果我丢失或损坏了BitBox02设备，恢复资金的唯一方法是通过我的(私钥)备份进行恢复。",
    userConfirmation4: "如果我同时丢失或损坏了我的备份以及BitBox02设备，那么我的资金将会永远丢失。"
  },
  create: {
    button: "命名设备 & 继续",
    info: "以下是设置BitBox所要执行的基本步骤： ",
    inputTitle: "钱包名称",
    point1: "为您的设备命名",
    point2: "为您的BitBox设备设置密码",
    point3: "建立备份",
    text: "好的，让我们开始创建一个新的钱包！"
  },
  initialize: {
    passwordText: "现在，让我们为您的设备设置密码。参考以下视频指导，通过BitBox设备的边框触控功能进行密码设置。",
    passwordTitle: "为您的BitBox设置密码",
    text: "已成功配对您的BitBox02！现在，让我们进行设备的初始化。请选择您是要创建一个新的钱包，或是需要从已有(私钥)备份中恢复原来的钱包。 <strong>请确保您的BitBox02中插入了microSD卡</strong>",
    tip: "我们建议您在安全的环境中进行操作。",
    title: "初始化您的BitBox"
  },
  insertSDCard: "<strong>请确保您的BitBox02设备上已插入了microSD卡。</strong>",
  pairing: {
    failed: "未确认的配对。请重新插入您的BitBox02。",
    paired: "您已在设备上确认代码匹配。如果确认无误，则可以单击下面的按钮以继续。",
    title: "配对码验证中",
    unpaired: "已检测到新的BitBox02。请验证以下代码是否与您设备上显示的代码匹配。如果代码匹配(相同)，请轻触BitBox02显示屏上打勾选项下方的设备边框以继续。"
  },
  restoreFromMnemonic: {
    failed: "通过助记词进行的恢复失败，请重试。"
  },
  stepBackup: {
    beforeProceed: "在继续之前，请阅读以下重要的安全注意事项：",
    createBackup: "现在，您将在microSD卡上创建备份。"
  },
  stepBackupSuccess: {
    fundsSafe: "为了确保您的资金安全，请记住以下几点：",
    title: "备份已还原！"
  },
  stepConnected: {
    unlock: "输入BitBox02密码进行解锁。"
  },
  stepCreate: {
    nameLabel: "BitBox02名称",
    namePlaceholder: "我的BitBox02",
    title: "选择BitBox02名称",
    toastMicroSD: "请确保您的microSD卡已插入BitBox02中。"
  },
  stepCreateSuccess: {
    removeMicroSD: "请从BitBox02中取出microSD卡，并将其存储在安全的位置。",
    success: "您已成功创建备份。"
  },
  stepPassword: {
    title: "设置BitBox02密码",
    useControls: "使用BitBox02上的触控控件设置密码。"
  },
  stepUninitialized: {
    create: "我想设置一个新的BitBox02。",
    restore: "我想从备份中还原我的钱包。",
    restoreMicroSD: "从microSD卡还原",
    restoreMnemonic: "通过助记词还原",
    title: "设置您的BitBox02"
  },
  success: {
    text: `太棒了！您可以开始使用BitBox02了。

如需获取如何使用BitBoxApp的信息，请单击右上角的问号访问应用程序指南。`,
    title: "您已准备就绪！"
  }
}, blink$5 = {
  button: ""
}, bootloader$5 = {
  button: "立即升级固件",
  progress: "升级： {{progress}}％",
  success: "升级成功！请重新插入设备。这次，请一定不要触摸按钮。"
}, button$9 = {
  abort: "中止",
  back: "返回上一步",
  changepin: "更改设备密码",
  check: "检查备份",
  continue: "继续",
  copy: "复制",
  create: "创建",
  download: "下载",
  hiddenwallet: "创建隐藏钱包",
  next: "下一个",
  ok: "好的",
  previous: "上一个",
  receive: "接收",
  restore: "恢复",
  select: "选择",
  send: "发送",
  unlock: "解锁(设备)",
  update: "更新",
  upgrade: "升级"
}, changePin$5 = {
  newTitle: "新设备密码",
  oldLabel: "当前设备密码"
}, checkSDcard$5 = "检查microSD卡", clickHere$5 = "点击这里。", confirm$7 = {
  abortInfo: "点按 ",
  abortInfoRedText: "中止",
  approveInfo: "保持4秒 ",
  approveInfoGreenText: "确认",
  info: "在您的BitBox设备上",
  infoWhenPaired: "首先在配对的手机上，然后在您的BitBox上"
}, confirmOnDevice$5 = "请在设备上进行确认", device$5 = {
  appUpradeRequired: "您的BitBox与该桌面应用程序不兼容。请下载并安装最新版本。"
}, deviceLock$5 = {
  button: "启用双因素认证（2FA）",
  condition1: "你有备份吗？",
  condition2: "移动端app的验证功能是否正常工作？",
  condition3: "2FA禁用了备份和移动应用程序配对功能。必须进行设备复位才能退出2FA！",
  confirm: "启用双因素验证(2FA)",
  title: "启用双因素验证（2FA）"
}, deviceSettings$5 = {
  firmware: {
    newVersion: {
      label: "可用版本"
    },
    title: "固件",
    upToDate: "您的设备固件是最新的",
    version: {
      label: "版本"
    }
  },
  hardware: {
    sdcard: {
      false: "未插入",
      label: "microSD卡",
      true: "已插入"
    },
    title: "硬件信息"
  },
  loading: "检索设备信息…",
  pairing: {
    lock: {
      false: "禁用",
      label: "双因素授权（2FA）",
      true: "启用"
    },
    mobile: {
      false: "关闭",
      label: "移动端app",
      true: "打开"
    },
    status: {
      false: "无法配对",
      label: "状态",
      true: "已配对"
    },
    title: "配对中"
  },
  secrets: {
    manageBackups: "管理备份",
    title: "机密信息"
  }
}, deviceTampered$5 = "您的BitBox是否已提供恢复密码？如果是这样，请停止设置过程并立即与支持人员联系。 Shift公司绝不会为您提供现成的钱包密码或提供密码建议。", dialog$6 = {
  cancel: "取消",
  confirm: "确认"
}, fiat$7 = {
  default: "默认设置",
  setDefault: "将 {{code}} 设为默认",
  title: "货币(单位)"
}, footer$7 = {
  appVersion: "App版本"
}, genericError$5 = "发生错误。如果发现任何问题，请重新启动应用程序。", goal$5 = {
  buttons: {
    create: "创建一个新钱包",
    restore: "通过备份还原钱包"
  },
  paragraph: "请选择以下选项之一：",
  step: {
    1: {
      title: "安全信息"
    },
    2: {
      description: "设置设备密码",
      title: "设备"
    },
    "3-create": {
      description: "创建一个新钱包",
      title: "钱包"
    },
    "3-restore": {
      description: "从备份中",
      title: "恢复"
    },
    "4-create": {
      title: "摘要"
    },
    "4-restore": {
      title: "摘要"
    }
  }
}, guide$6 = {
  accountDescription: {
    text: "您的帐户概览显示您的可用余额以及收款和付款记录。我们在“设置”中的指南中提供了有关每种帐户类型的更多说明。 ",
    title: "该页面向我显示了什么？"
  },
  accountFiat: {
    text: "是。单击任何行情自动切换法定货币。您可以在设置中更改货币列表。",
    title: "可以显示其他的兑换率吗？"
  },
  accountIncomingBalance: {
    text: "正在传入(的交易)汇总了转账给您的交易金额，但这些交易尚未得到网络的确认。",
    title: "正在传入(的交易)意味着什么？"
  },
  accountInfo: {
    xpub: {
      text: `扩展公钥是帐户中所有接收地址的根密钥。
此处提供扩展公钥供高级用户使用，以及与watch-only(仅限查阅)类型的钱包进行互操作,例如Electrum或Sentinel。`,
      title: "什么是扩展公钥？"
    }
  },
  accountRates: {
    text: "我们每分钟都会通过CoinGecko更新汇率。",
    title: "使用的哪种汇率？"
  },
  accountReload: {
    text: "不需要。您的交易信息会自动更新。",
    title: "我可以重新加载交易记录吗？"
  },
  accountSendDisabled: {
    text: "当余额超过零时，将激活“发送”按钮。",
    title: "我为什么不能进行发送 {{unit}}？"
  },
  accountTransactionAttributesBTC: {
    text: `虚拟大小：决定网络费用。如果虚拟大小小于实际大小，则可以成功节省费用。
实际大小：底层区块链序列化时，实际交易的大小（以字节为单位），。
重量：隔离见证（Segwit）引入的一种新指标，用于评估交易和区块大小。每个隔离见证字节计为1(个重量单位)，其他所有字节计为4(个重量单位)。因此区块实际大小的限制(上限)不再是一兆字节(1MB)，区块大小的限制(上限)是四百万个重量单位。`,
    title: "关于Bitcoin比特币的具体交易细节？"
  },
  accountTransactionAttributesGeneric: {
    text: `确认：您的第一个交易广播尚未确认，直到矿工将其打包入一个区块中，然后再进行一个确认。网络上广播的每个区块都会为您的交易添加另一个确认。通常，商家和其他网络参与者只会用三到六个确认来结算交易。
交易ID：可让您在区块浏览器中查找交易的唯一标识号。
费用：网络向矿工支付交易费，以作为其将交易打包确认在他们开采的区块中的奖励。要了解更多信息，请单击发送按钮。`,
    title: "交易明细中的信息有哪些？"
  },
  accountTransactionConfirmation: {
    text: "交易已广播到网络中，但尚未确认。",
    title: "什么是待处理交易？"
  },
  accountTransactionLabel: {
    text: "这是您接收到的数字货币的地址或向其发送数字货币的地址。",
    title: "每笔交易显示哪个地址？"
  },
  accountTransactionTime: {
    text: "区块链交易确认时间。",
    title: "显示的是什么时间？"
  },
  appendix: {
    link: "联系我们！",
    text: "另一个问题？"
  },
  backups: {
    check: {
      text: "“检查备份”可让您验证您是否有与当前钱包相对应的有效备份。它还可以用来验证您是否拥有(记得)正确的恢复密码。您可以检查您的主要恢复密码或隐藏恢复密码。",
      title: "什么是“检查备份”？"
    },
    encrypt: {
      text: "否，但是需要您的恢复密码才能从存储的种子中获取钱包。",
      title: "我可以加密备份吗？"
    },
    howOften: {
      text: `创建新钱包后会自动生成备份。仅当microSD卡丢失或损坏，或者要使用多个microSD卡作为备份时，才需要进行新备份。
交易完成后，您无需创建新的备份。可以通过自动为您生成的单个备份重新创建所有交易数据。`,
      title: "我必须多久备份一次？"
    },
    whatIsABackup: {
      text: "它是micro SD卡上种子副本。种子和您的恢复密码一起生成了您的钱包。",
      title: "什么是备份？"
    }
  },
  backupsBB02: {
    check: {
      text: "“检查备份”可验证您是否有与当前钱包相对应的有效备份。",
      title: "什么是“检查备份”？"
    },
    encrypt: {
      text: "否。请确保Micro SD卡安全，因为卡中包含未加密的种子，该种子用于恢复您的钱包。如果希望对种子进行密码保护，可以在“管理设备”下的高级设置中启用密语功能。",
      title: "我可以加密我的备份吗？"
    },
    whatIsABackup: {
      text: "它是microSD卡上种子的副本。",
      title: "什么是备份？"
    }
  },
  bitbox: {
    "2FA": {
      text: `启用2FA后，所有交易都必须在配对手机上获得批准才能发送资产。在内部，一个经过加密的一次性号码被发送到手机app中，并进行解密，在按下接受按钮时返回到BitBox中。此与设备的通信是通过配对期间建立于移动电话和此桌面应用程序之间的频道完成的。

确保在启用2FA之前备份您的钱包并配对移动端app。一旦启用，micro SD插槽和移动端app配对将被禁用。可以通过重置BitBox来重新启用它们，该操作将位擦除设备。`,
      title: "双因素授权（2FA）是如何工作的？"
    },
    disable2FA: {
      text: "为了禁用2FA功能，您需要重置BitBox，然后从其备份中重置钱包。请确保您仍然拥有带有备份的microSD卡，并且仍记得恢复密码。然后按“重置设备”。设置新的设备密码，然后选择“或还原备份”。从钱包中选择您已创建的备份，单击“还原”，然后输入创建钱包时使用的恢复密码。",
      title: "如何禁用两因素授权（2FA）？"
    },
    ejectBitbox: {
      text: "您可以随时拔出BitBox，而不必先退出它。",
      title: "如何弹出BitBox？"
    },
    ejectSD: {
      text: "只要您不在创建或还原备份的过程中，就可以随时从BitBox中取出microSD卡。",
      title: "如何弹出microSD卡？"
    },
    hiddenWallet: {
      text: '它是同一台设备上的第二个钱包，受不同的设备密码和恢复密码保护，您可以使用这些钱包进行"合理的可否认性plausible deniability"。普通和隐藏钱包都使用相同的备份种子，因此不需要其他备份。',
      title: "什么是隐藏钱包？"
    },
    legacyHiddenWallet: {
      text: "首先单击下面的按钮（如果使用主设备密码将BitBox解锁并禁用了2FA，则可使用该按钮），然后重新插入您的Bitbox并使用隐藏的设备密码将其解锁。",
      title: "如何访问legacy隐藏钱包？"
    },
    pairing: {
      text: "下载适用于iOS或Android的移动端app后，您可以扫描显示的二维码，从而在移动app和此应用程序之间建立安全通道。扫描后，请按照移动端app中的说明进行操作。",
      title: "如何与手机安全配对"
    }
  },
  receive: {
    address: {
      text: "您可以将该地址提供给其他人，以便他们向您发送数字货币。但请务必确认您发送了正确的地址。",
      title: "地址的用途是？"
    },
    addressChange: {
      text: "一旦(上一笔)交易完成后，一个新地址会自动添加到列表中，因此始终有20个地址从未收到过任何数字货币。",
      title: "地址何时更改？"
    },
    howVerify: {
      text: `对于BitBox01，单击左侧边栏中的BitBox图标，查看“配对”部分。该指南将进行更新，您可以进一步按照说明进行操作。
对于BitBox02，您可以在发送/接收过程中直接在设备上验证地址。`,
      title: "如何安全地验证地址？"
    },
    why20: {
      text: "在启动过程中，该app会通过您的种子生成的地址，以查看这些地址下是否已接收到过资金。由于该app可以生成几乎无限数量的地址，因此可能要花费数年才能确定(该种子下所有地址的)余​​额。为了限制此(无穷)搜索，它会在看到20个从未收到资金的地址后停止。这称为是“间隙限制gap limit”，而20是事实标准，尽管地址数量是任意多个的。而这20个地址是你可以进行选择使用的。",
      title: "为什么只有20个地址？"
    },
    whyMany: {
      text: "为了维护隐私和安全，切勿两次(重复)使用相同的地址。如果您已使用过某个地址，请单击向右箭头以获取新地址。您一次最多可以生成20个地址。将地址视为发票编号。所有地址都衍生自您唯一的备份种子。",
      title: "为什么有那么多地址？"
    },
    whyVerify: {
      text: "您不应该信任您的计算机来生成和显示真实地址。它的被攻击面很大，因此计算机相比硬件钱包更容易受到攻击。对于BitBox01，用于验证地址的按钮会将地址安全地发送到配对的手机，您还可以从该手机扫描并验证QR码。对于BitBox02，可以直接在BitBox02显示屏上验证地址。",
      title: "为什么我需要对地址进行安全验证？"
    }
  },
  send: {
    fee: {
      text: `收取费用(的计算)基于交易数据大小而不是交易金额。费用标准是由Bitcoin Core的费用估算算法针对您选择的每个网络优先级计算的。如果它们的值与下面的标准值不同，则会显示它们。
经济：24个区块（比特币大约需4小时，莱特币大约需1小时）
低：12个区块（比特币大约需2小时，莱特币大约需30分钟）
一般/普通：6个区块（比特币大约需1小时，莱特币大约需15分钟）
高：2个区块（比特币大约需20分钟，莱特币大约需5分钟）
（一个区块平均需要十分钟才能被挖出（在莱特币中为2.5分钟），在上述期间网络负载可能会有很大差异。）`,
      title: "费用如何确定？"
    },
    priority: {
      text: "您愿意支付的费用越高，网络通常会更快地确认您的交易。",
      title: "网络优先级是什么？"
    },
    revert: {
      text: `一旦交易被签名并发送（即广播到网络中）后，就无法再恢复(回撤)。进行签名前请务必确认交易的正确性（包括费用）！
如果您认识收币人，并且他或她愿意将相同的金额（减去交易费用）退还给您，则可以向他们发送新的收币地址。`,
      title: "我可以逆转一个交易吗？"
    },
    whyFee: {
      text: `交易正在争夺矿工的确认。矿工根据其费用(高低)选择要打包进区块链中的交易。
矿工对交易历史进行投票。由于没有可信赖的第三方强制每人投票（这是区块链的重点），矿工通过牺牲诸如计算能力之类的昂贵资源来对交易进行投票。作为对他们工作的奖励，他们可以获得新区块产生时的奖励币以及区块中打包确认的所有交易的交易费。`,
      title: "为什么要收取网络费？"
    }
  },
  "settings-electrum": {
    what: {
      text: "可以使用您自己的全节点为你的钱包提供支持，而无需使用Shift公司的服务器。",
      title: "这是什么？"
    }
  },
  settings: {
    servers: {
      text: `该app与Shift Crypto服务器进行通信，以检查更新，加载交易并将信息发送到配对的移动端apps。
该app还从CoinGecko检索最新汇率。所有转换都是在本地计算的，这意味着不会传输有关交易金额的任何数据。
注意：对于以太坊和ERC20代币，我们使用Etherscan.io API。`,
      title: "该app与哪些服务器通信？"
    }
  },
  title: "指南",
  toggle: {
    close: "关闭指南",
    open: "指南"
  },
  unlock: {
    forgotDevicePassword: {
      text: "您必须使用恢复密码来重置设备并通过备份还原钱包。",
      title: "如果忘记了设备密码，我该怎么办？"
    },
    reset: {
      text: "输入错误的设备密码15次。最后几次尝试需要长时间触摸设备。",
      title: "如何重置设备？"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "设备插入后应闪烁一次。确保将其正确插入。如果您遇到问题，请通过以下链接与我们联系。",
      title: "我的BitBox01无法识别"
    },
    getDevice: {
      link: {
        text: "订购一个BitBox"
      },
      text: "您可以在我们的网上商店购买BitBox：",
      title: "我如何获得设备？"
    },
    internet: {
      text: "是的，需要连接网络以同步钱包，发送交易并获取最新汇率。",
      title: "这个app需要连接网络吗？"
    },
    lostDevice: {
      link: {
        text: "备份中心"
      },
      text: "您可以在新的BitBox或通过我们的备份中心进行帐户恢复。",
      title: "我丢失了设备。怎么办？"
    },
    useWithoutDevice: {
      text: "不幸的是，目前尚无法实现。",
      title: "我可以在没有设备的情况下使用该app吗？"
    },
    welcome: {
      text: "感谢您使用由瑞士Shift Crypto公司开发的此应用程序。感谢您分享的任何意见。请使用底部的链接提供反馈。",
      title: "欢迎使用BitBoxApp！"
    }
  }
}, headerssync$5 = {
  blocksSynced: "{{blocks}} 同步区块"
}, hiddenWallet$5 = {
  info1HTML: '出于"合理的可否认性plausible deniability"的目的，一个隐藏钱包可以根据 <strong>不同</strong> 设备密码+恢复密码的组合进行创建。',
  info2HTML: "设定与您的隐藏钱包相关联的设备密码和恢复密码。设备密码和恢复密码必须与您的主钱包密码 <strong>不同</strong> 。",
  passwordLabel: "隐藏恢复密码",
  passwordPlaceholder: "请确认隐藏的恢复密码",
  pinLabel: "隐藏设备密码",
  pinRepeatLabel: "重复隐藏设备的密码",
  pinRepeatPlaceholder: "请确认隐藏设备的密码",
  success: "隐藏钱包创建成功。重新插入您的BitBox以解锁。"
}, initialize$5 = {
  create: "设置设备密码",
  creating: "设置设备密码中...",
  error: {
    e102: "设备密码必须至少包含4个字符。"
  },
  info: {
    description1: "选择您的设备密码。这将用于解锁您的BitBox。",
    description2: "您可以使用数字，字母 & 符号。更长密码可以提供更高的安全性",
    description3: "如果您丢失了设备密码，则必须重置设备并还原钱包备份。",
    subtitle: "现在，您将设置设备密码",
    title: "初始化你的设备"
  },
  input: {
    label: "设备密码",
    labelRepeat: "重复设备密码",
    placeholderRepeat: "请确认设备密码"
  }
}, invalidFormat$5 = "无效的格式", language$6 = {
  title: "选择语言"
}, legacyhiddenwallet$5 = {
  disable: "禁用legacy隐藏钱包",
  enable: "启用Legacy隐藏钱包",
  successDisable: "已成功禁用legacy隐藏钱包。",
  successEnable: "成功启用legacy隐藏钱包。重新插入您的BitBox并输入隐藏的设备密码以访问legacy隐藏钱包。"
}, loading$5 = "载入中...", notification$5 = {
  newTxs_one: "{{count}} 新交易： {{accountName}}",
  newTxs_other: "{{count}} 新交易： {{accountName}}"
}, pairing$5 = {
  aborted: {
    text: "配对已在移动端app端中止。",
    title: "中止"
  },
  button: "配对移动端app",
  confirm: "您确定要配对BitBox吗？请注意配对完成后，需要通过手机进行交易操作。",
  connectOnly: {
    button: "连接移动端app",
    title: "选择菜单中“连接到新的桌面应用程序”，使用我们的移动端app移动应用程序进行扫描"
  },
  error: {
    text: "出现一些问题。请重新开始。",
    title: "错误"
  },
  reconnectOnly: {
    button: "重新连接移动端app"
  },
  start: {
    hideAppQRCode: "隐藏二维码",
    revealAppQRCode: "显示二维码",
    step1: "如果您没有移动端app，则可以根据你的手机型号扫描对应的Apple App Store或Google Play商店的二维码。",
    step2: "请使用我们的移动端app进行扫描，您可以在iOS和Android的应用程序商店中通过搜索“ Digital Bitbox 2FA”的名称找到该app："
  },
  started: {
    text: "现在，请按照移动端app上的说明进行操作。",
    title: "太棒了"
  },
  success: {
    text: "恭喜，您已成功将BitBox与移动端app配对！",
    title: "成功"
  },
  timeout: {
    text: "配对在两分钟后超时。如果您仍想配对移动端app，请重新开始。",
    title: "超时"
  },
  title: "手机配对"
}, password$5 = {
  show: "显示 {{label}}",
  warning: {
    caps: "警告：大写锁定（⇪）已启用",
    paste: "粘贴文本，启用“显示 {{label}}”"
  }
}, random$6 = {
  button: "生成随机序号",
  description: "您的BitBox产生了以下 {{bits}}位随机数："
}, receive$7 = {
  label: "你的地址",
  onlyThisCoin: {
    description: "要接收其他代币，请先在设置中启用它们。否则如果您存入其他代币，则可能无法访问它们。",
    warning: "确保只在这个地址上接收 {{coinName}} 。"
  },
  showFull: "在设备上显示并验证完整的地址",
  title: "获取 {{accountName}}",
  verify: "安全验证地址",
  verifyBitBox01: "在移动端app上验证地址",
  verifyBitBox02: "请在BitBox02设备上的验证地址",
  verifyInstruction: "请确认以下地址与设备上显示的地址匹配。",
  warning: {
    secureOutput: "请将您的BitBox与您的移动设备配对以启用安全地址验证功能。再访问侧栏中的“管理设备”选项。"
  }
}, reset$5 = {
  description: "设备上的所有数据将被删除。其中包括您的私钥！",
  notReset: "设备未重置。",
  title: "恢复出厂设置",
  understand: "我已有备份，并知道我的恢复密码",
  understandBB02: "我有一个有效的备份"
}, securityInformation$5 = {
  create: {
    description1: "设置设备之前，建议您在安全的环境中进行设置。",
    description2: "系统将要求您创建两个密码。",
    description3: "首先是 <strong>设备密码</strong> 即可解锁您的BitBox设备，该密码以后可以进行更改。",
    description4: "第二个是 <strong>恢复密码</strong> 可以解锁您的钱包。此密码以后不能更改。",
    description5: "您创建的钱包将备份到所提供的microSD卡上的文件中。可以在紧急情况下使用您的 <strong>恢复密码</strong>。",
    title: "安全信息"
  },
  restore: {
    description1: "系统将要求您插入用于存储备份的microSD卡。",
    description2: "要恢复设备，您将需要使用恢复密码。 ",
    description3: "输入恢复密码时请小心。您输入的任何密码都会创建一个有效的钱包。如果输入错误的密码，可能会看到您不期望的钱包余额。",
    title: "安全信息"
  }
}, seed$5 = {
  agreements: {
    "funds-access": "如果忘记了恢复密码，我将无法使用/取出我的资金",
    "password-change": "我以后无法更改恢复密码",
    "password-required": "需要恢复密码才能从备份中还原钱包"
  },
  create: "创建钱包",
  creating: "创建钱包中",
  description: "我理解：",
  error: {
    e102: "密码必须至少包含4个字符。",
    e200: "您需要在BitBox中插入microSD卡才能创建钱包，以此才能够进行备份的自动创建。"
  },
  info: {
    button: "立即设置恢复密码",
    description1: "将microSD卡插入BitBox",
    description2: "选择钱包的恢复密码，然后选择“立即设置恢复密码”",
    description3: "如果BitBox设备丢失或被盗，已进行备份的microSD卡和您的恢复密码是恢复资金的唯一方法。",
    description4: "在不转移资金的情况下您以后将无法更改恢复密码。",
    title: "创建一个新钱包"
  },
  password: {
    label: "找回密码",
    repeatPlaceholder: "重复恢复密码"
  },
  walletName: {
    label: "钱包名称"
  }
}, seedRestore$5 = {
  error: {
    e200: "通过备份还原钱包需要用到microSD卡。"
  },
  info: {
    description1: "将microSD卡插入BitBox，然后单击“继续”",
    description2: "选择一个备份，然后单击“还原”",
    description3: "输入恢复密码",
    description4: "您需要确认你已了解到如果输入一个错误的密码，将创建另一个不同的钱包。",
    title: "如何通过备份还原钱包"
  }
}, send$7 = {
  abort: "交易已被中止。",
  address: {
    label: "收款人地址",
    placeholder: "输入地址"
  },
  amount: {
    label: "金额",
    placeholder: "输入金额"
  },
  button: "签名并发送",
  coincontrol: {
    address: "地址",
    outpoint: "",
    title: "从输出发送"
  },
  confirm: {
    "selected-coins": "已选择的币种",
    title: "确认交易",
    total: "总计"
  },
  error: {
    insufficientFunds: "余额不足",
    invalidAddress: "无效地址",
    invalidAmount: "无效金额",
    invalidData: "无效数据"
  },
  fee: {
    customPlaceholder: "输入金额",
    label: "网络费",
    placeholder: "无法使用"
  },
  feeTarget: {
    description: {
      economy: "24个区块（Bitcoin比特币大约需4小时，Litecoin莱特币大约需1小时）",
      high: "2个区块（Bitcoin比特币大约需20分钟，Litecoin莱特币大约需5分钟）",
      low: "12个区块（Bitcoin比特币大约需2小时，Litecoin莱特币大约需30分钟）",
      normal: "6个区块（Bitcoin比特币大约需1小时，Litecoin莱特币大约需15分钟）"
    },
    estimate: "预计等待时间：",
    label: {
      economy: "经济",
      high: "高",
      low: "低",
      normal: "正常/普通"
    },
    placeholder: "正在进行费用估算…"
  },
  maximum: "发送全部",
  scanQR: "扫描二维码",
  signprogress: {
    description: "这是一个包含大量数据的交易。如要完成交易的完整签名过程，系统会要求您确认 {{steps}} 次。",
    label: "进展"
  },
  success: "交易已签名并完成发送。",
  title: "发送 {{accountName}}",
  toggleCoinControl: "切换coin控制"
}, settings$6 = {
  electrum: {
    add: "添加服务器",
    "add-server": "添加",
    check: "校验",
    checkFailed: "失败",
    checkSuccess: "成功与 {{host}}建立连接",
    checking: "检查中",
    "download-cert": "下载远程证书",
    "remove-server": "删除",
    removeConfirm: "删除 {{server}}？",
    reset: "重置为默认值",
    resetConfirm: "是否要删除所有服务器并安装默认服务器？",
    servers: "服务器",
    step1: "1",
    "step1-text": "输入endpoint",
    step2: "2",
    "step2-text": "输入服务器证书链的证书。或者下载远程证书并进行视觉对比。",
    step3: "3",
    "step3-text": "检查连接并添加服务器。",
    step4: "4",
    "step4-text": "重启钱包。如果您不删除默认服务器，您自己的节点将被添加并被作为冗余处理",
    "title-btc": "Bitcoin Electrum服务器",
    "title-ltc": "Litecoin莱特币Electrum服务器",
    "title-tbtc": "Bitcoin测试网络Electrum服务器",
    "title-tltc": "Litecoin莱特币测试网Electrum服务器"
  },
  expert: {
    coinControl: "启用coin控制",
    electrum: {
      title: "连接您自己的全节点"
    },
    setProxyAddress: "设定代理地址",
    title: "高级/专业用户设置",
    useProxy: "启用tor代理"
  },
  header: {
    home: "主页"
  },
  restart: "请重新启动BitBoxApp，以使更改生效。",
  success: "请拔出并重新插入BitBox，以使更改生效。",
  title: "设置"
}, setup$5 = "设置设备", sidebar$6 = {
  device: "管理设备",
  leave: "离开",
  settings: "设置"
}, success$c = {
  create: {
    info1: "您的钱包已安全备份到microSD卡。取出microSD卡并安全保存。",
    info2: "您已经创建了一个安全的设备密码来解锁BitBox。",
    info3: "您已为钱包创建了安全的恢复密码，该密码可解锁资金并还原备份。",
    summary: "这是您已完成事项的摘要",
    title: "成功"
  },
  getstarted: "开始吧",
  restore: {
    summary: "您已成功从备份中还原了钱包。",
    title: "成功"
  }
}, transaction$6 = {
  confirmation: "确认",
  explorer: "交易ID",
  explorerTitle: "在外部区块浏览器中打开",
  fee: "(交易)费用",
  fiatHistorical: "历史的",
  gas: "Gas",
  pending: "待处理的交易",
  size: "(区块)大小",
  vsize: "(区块)虚拟大小",
  weight: "(区块)重量"
}, transactions$5 = {
  placeholder: "尚无交易记录"
}, unknownError$5 = "出现未知错误： {{errorMessage}}", unlock$5 = {
  description: "输入您的设备密码以解锁设备",
  error: {
    e109_normal: "设备密码错误。 {{remainingAttempts}} 重设设备之前尝试会保留。",
    e109_touch: "$t(unlock.error.e109_normal）下次登录需要按住触摸按钮。",
    e113: "由于多次登录尝试，下次登录需要按住触摸按钮4秒钟。"
  },
  input: {
    label: "设备密码",
    placeholder: "输入设备密码以解锁设备"
  },
  unlocking: "解锁中..."
}, upgradeFirmware$6 = {
  button: "升级固件",
  description: "您是否要将固件版本从 {{currentVersion}}升级至 {{newVersion}}？",
  label: "您的BitBox需要固件升级。",
  locked: "从 {{currentVersion}} 升级至 {{newVersion}}，请长按(触控边框)。",
  title: "升级固件",
  unlocked: "引导加载程序已解锁。要继续，请：",
  unlocked1: "拔下并重新插入您的Bitbox",
  unlocked2: "重新插入BitBox时，LED会亮起",
  unlocked3: "LED屏幕亮起时请轻触设备的触控边框"
}, warning$b = {
  receivePairing: "请配对BitBox以启用安全地址验证。点击侧单栏中的“管理设备”。",
  sdcard: "除非要进行备份管理，否则请将microSD卡与BitBox设备分开存放。",
  sendPairing: "请配对BitBox以安全地验证交易详细信息。转到侧栏中的“管理设备”。"
}, welcome$5 = {
  insertBitBox02: "如果是BitBox02设备，请点击设备以继续。",
  insertDevice: "请链接您的设备以开始进一步操作",
  title: "欢迎"
}, appTranslationsZH = {
  account: account$5,
  accountInfo: accountInfo$5,
  accountSummary: accountSummary$5,
  addAccount: addAccount$6,
  app: app$5,
  backup: backup$5,
  bb02Bootloader: bb02Bootloader$5,
  bitbox: bitbox$5,
  bitbox02Interact: bitbox02Interact$5,
  bitbox02Settings: bitbox02Settings$5,
  bitbox02Wizard: bitbox02Wizard$5,
  blink: blink$5,
  bootloader: bootloader$5,
  button: button$9,
  changePin: changePin$5,
  checkSDcard: checkSDcard$5,
  clickHere: clickHere$5,
  confirm: confirm$7,
  confirmOnDevice: confirmOnDevice$5,
  device: device$5,
  deviceLock: deviceLock$5,
  deviceSettings: deviceSettings$5,
  deviceTampered: deviceTampered$5,
  dialog: dialog$6,
  fiat: fiat$7,
  footer: footer$7,
  genericError: genericError$5,
  goal: goal$5,
  guide: guide$6,
  headerssync: headerssync$5,
  hiddenWallet: hiddenWallet$5,
  initialize: initialize$5,
  invalidFormat: invalidFormat$5,
  language: language$6,
  legacyhiddenwallet: legacyhiddenwallet$5,
  loading: loading$5,
  notification: notification$5,
  pairing: pairing$5,
  password: password$5,
  random: random$6,
  receive: receive$7,
  reset: reset$5,
  securityInformation: securityInformation$5,
  seed: seed$5,
  seedRestore: seedRestore$5,
  send: send$7,
  settings: settings$6,
  setup: setup$5,
  sidebar: sidebar$6,
  success: success$c,
  transaction: transaction$6,
  transactions: transactions$5,
  unknownError: unknownError$5,
  unlock: unlock$5,
  upgradeFirmware: upgradeFirmware$6,
  warning: warning$b,
  welcome: welcome$5
}, account$4 = {
  disconnect: "ارتباط از دست رفته تلاش مجدد ...",
  export: "خروچی",
  exportTransactions: "خروجی گرفتن از تراکنش ها به صورت CSV و ذخیره در پوشه دانلود ها",
  fatalError: "خطای غیر منتظره.",
  incoming: "ورودی",
  initializing: "دریافت اطلاعات از بلاکچین ...",
  reconnecting: "ارتباط از دست رفته، تلاش برای اتصال مجدد ..."
}, accountInfo$4 = {
  address: "آدرس",
  extendedPublicKey: "کلید عمومی گسترش یافته",
  label: "اطلاعات حساب",
  title: "اطلاعات حساب",
  verify: "تأیید در دستگاه"
}, accountSummary$4 = {
  balance: "موجودی",
  exportSummary: "خروجی گرفتن از اطلاعات حساب در فولدر دانلودها به صورت CSV",
  fiatBalance: "موجودی به ارزهای رایج",
  name: "نام حساب",
  noAccount: "هیچ حسابی برای نمایش نیست.",
  title: "اطلاعات حساب ها",
  total: "مجموع"
}, addAccount$5 = {
  title: "افزودن حساب"
}, app$4 = {
  upgrade: "نسخه جدید برنامه موجود است. لطفا برنامه را از نسخه {{current}} به نسخه {{version}} ارتقا دهید."
}, backup$4 = {
  check: {
    checking: "درحال بررسی پشتیبان...",
    confirmTitle: "بررسی پشتیبان",
    notOK: "پشتیبان با کیف پول فعلی منطبق نیست.",
    ok: "پشتیبان با کیف پول فعلی منطبق است",
    password: {
      label: "رمزعبور بازیابی",
      placeholder: "رمزعبور بازیابی",
      showLabel: "رمزعبور بازیابی"
    },
    success: "فایل پشتیبان با موفقیت تایید شد:",
    title: "بررسی پشتیبان"
  },
  create: {
    alreadyExists: "شما یک فایل پشتیبان دارید. آیا می خواهید دوباره ساخته شود؟",
    fail: "تهیه نسخه پشتیبان با مشکل روبرو شد!",
    info: "لطفا رمزعبور بازیابی کیف پول را برای تایید وارد نمایید",
    name: {
      label: "نام پشتیبان",
      placeholder: "لطفا نامی برای پشتیبان وارد کنید"
    },
    password: {
      label: "رمزعبور بازیابی",
      placeholder: "لطفا رمزعبور بازیابی را وارد نمایدد"
    },
    title: "ایجاد پشتیبان",
    verificationFailed: "رمزعبور پشتیبان با کیف پول فعلی متفاوت است. پشتیبان گیری انجام شد. لطفا از دکمه 'بررسی پشتیبان' برای تایید رمزعبور بازیابی استفاده نمایید."
  },
  description: "<strong>فایل پشتیبان کیف پول</strong>را انتخاب نمایید.",
  insert: "لطفا برای پشتیبان گیری، حافظه microSD را وارد نمایید",
  insertButton: "حافظه microSD را وارد کردم",
  list: "نسخه های پشتیبان شما در حافظه microSD",
  noBackups: "هیچ فایل پشتیبانی در حافظه میکرو SD وجود ندارد.",
  restore: {
    confirmTitle: "بازگرداندن پشتیبان",
    error: {
      e200: "حافظه microSD پیدا نشد."
    },
    password: {
      label: "رمزعبور بازیابی یا رمزعبور بازیابی مخفی",
      placeholder: "رمزعبور بازیابی",
      repeatPlaceholder: "تکرار رمزعبور بازیابی",
      showLabel: "رمزعبور بازیابی"
    },
    restoring: "بازگرداندن پشتیبان ...",
    title: "بازیابی",
    understand: "من قبول می کنم رمزعبور بازیابی نادرست کیف پول متفاوتی ایجاد می کند"
  },
  showMnemonic: {
    description: `شما با حداکثر 24 کلمه مواجه می شوید که از پشتیبان شما دریافت شده است. آنها را روی کاغذ یادداشت نمایید.
<strong>کلمات را به صورت دیجیتالی نگهداری نکنید. ویا از آنها عکس نگیرید</strong>
<strong>کلمات را بلند نخوانید.</strong>
<strong>این پشتیبان با رمز قفل نیست.</strong>
بعد از آن از شما خواسته می شود هر کلمه را تایید نمایید.
`,
    title: "نمایش کلمات بازیابی"
  },
  title: "مدیریت پشتیبان ها"
}, bb02Bootloader$4 = {
  abort: "بروزرسانی نکن – من را برگردان",
  advanced: {
    label: "تنظیمات پیشرفته",
    toggleShowFirmwareHash: "نمایش هش سیستم عامل هر بار هنگام روشن شدن"
  },
  flipscreen: "چرخش تصویر",
  orientation: "جهت تصویر اشتباه است؟",
  success: "بروزرسانی با موفقیت انجام شد! ادامه در {{rebootSeconds}} ثانیه..."
}, bitbox$4 = {
  error: {
    e10000: "رمزعبور نادرست است.",
    e10001: "رمزعبور جایگزین نشد",
    e102: "رمزعبور حداقل باید ٨ کارکتر باشد",
    e112: "رمزعبور مخفی دستگاه نمی تواند با رمزعبور اصلی یکی باشد"
  }
}, bitbox02Interact$4 = {
  followInstructions: "لطفا طبق دستورالعمل های نمایش داده شده در BitBox02 عمل کنید."
}, bitbox02Settings$4 = {
  deviceName: {
    current: "نام دستگاه فعلی",
    input: "نام BitBox02",
    title: "تنظیم نام BitBo02"
  }
}, bitbox02Wizard$4 = {
  attestationFailed: "تأیید دستگاه انجام نشد ، که می تواند به دلیل راه اندازی مجدد برنامه در حالی که دستگاه منتظر ورود کاربر بود ، انجام شود. لطفا دوباره وصل شوید و دوباره امتحان کنید.",
  backup: {
    point1: "یک فایل پشتیبان را از حافظه microSD انتخاب نمایید",
    point2: "یک رمزعبور برای دستگاه خود تعیین نمایید",
    restoreText: "خب ، بگذارید پشتیبان را برگردانیم!",
    text1: "عالی، رمزعبور BitBox02 شما تنظیم شد و کیف پول شما ساخته شد. حالا زمان این است که یک پشتیبان تهیه نمایید. لطفا بررسی کنید حافظه microSD شما در BitBo02 شما قرار دارد و ادامه دهید.",
    text2: "لطفا دستورعمل های نمایش داده شده در صفحه نمایش دستگاه خود برای تهیه پشتیبان را دنبال کنید.",
    text3: "بعد از تهیه پشتیبان، لطفا حافظه microSD را خارج کرده و در <strong>جای امن</strong> نگهداری کنید. اطلاعات microSD رمزنگاری نشده است.  هیچ وقت آن را در دستگاه دیگری جز BitBox02 خود نگذارید",
    userConfirmation1: "من باید اطلاعات پشتیبان خود را در محل امن نگهداری کنم.",
    userConfirmation2: "پشتیبان من رمزگذاری نشده است. هرکسی که به آن دسترسی داشته باشد می تواند به کیف پول من دسترسی داشته باشد.",
    userConfirmation3: "اگر من Bitbox02 خود را خراب یا گم کنم، تنها راه بازیابی پول خود ازطریق فایل پشتیابن من است.",
    userConfirmation4: "اگر من هم پشتیبان و هم BitBox02 خودم را خراب یا گم کنم پس پول های من برای همیشه گم می شوند"
  },
  create: {
    button: "نام گذاری دستگاه و ادامه",
    info: "در اینجا اصول اولیه ای که برای راه اندازی BitBox خود انجام می دهید نمایش داده شده است: ",
    inputTitle: "نام کیف پول",
    point1: "نام گذاری دستگاه",
    point2: "تنظیم رمزعبور برای دستگاه خود",
    point3: "تهیه پشتیبان",
    text: "خب ، بیایید یک کیف پول جدید ایجاد کنیم!"
  },
  initialize: {
    passwordText: "اکنون یک رمزعبور برای دستگاه خود تنظیم کنید. برای وارد کردن و انتخاب رمزعبور از کنترل های موجود در BitBox خود استفاده کنید.",
    passwordTitle: "تنظیم رمزعبور برای BitBox خود",
    text: "با موفقیت BitBox02 شما متصل شد! اکنون بیایید دستگاه خود را راه اندازی کنیم. با انتخاب ایجاد کیف پول جدید یا بازگرداندن کیف پول از یک نسخه پشتیبان موجود شروع کنید.  لطفاً اطمینان حاصل کنید که یک کارت microSD در BitBox02 خود وارد شده است",
    tip: "توصیه می کنیم در یک محیط امن پیش بروید.",
    title: "راه اندازی BitBox خود"
  },
  insertSDCard: "<strong>لطفاً اطمینان حاصل کنید که یک حافظه microSD در BitBox02 خود قرار دارد.</strong>",
  pairing: {
    failed: "اتصال تایید نشده. لطفا BitBox02 خود را مجددا مصل کنید.",
    paired: "شما بر روی دستگاه خود تأیید کرده اید که کد مطابقت دارد. اگر این صحیح است ، می توانید با کلیک روی دکمه زیر ادامه دهید.",
    title: "کد اتصال را تأیید کنید",
    unpaired: "BitBox02 جدید شناسایی شده است. لطفاً تأیید کنید که کد زیر مطابق با آنچه در دستگاه شما نشان داده شده است مطابقت دارد. اگر کد مطابقت دارد ، زیر علامت تیک در BitBox02 خود را لمس کنید و سپس برای ادامه بر روی دکمه زیر کلیک کنید."
  },
  restoreFromMnemonic: {
    failed: "بازیابی با کلمات بازیابی انجام نشد، لطفاً دوباره امتحان کنید."
  },
  stepBackup: {
    beforeProceed: "قبل از اقدام ، لطفاً این ملاحظات امنیتی مهم را بخوانید:",
    createBackup: "اکنون یک پشتیبان در کارت microSD خود ایجاد خواهید کرد."
  },
  stepBackupSuccess: {
    fundsSafe: "برای تأمین امنیت بودجه خود ، موارد زیر را بخاطر بسپار:",
    title: "پشتیبان گیری بازیابی شد"
  },
  stepConnected: {
    unlock: "رمزعبور BitBox02 را برای باز کردن قفل وارد کنید."
  },
  stepCreate: {
    nameLabel: "نام BitBox02",
    namePlaceholder: "BitBox02 من",
    title: "نام BitBox02 را انتخاب کنید",
    toastMicroSD: "لطفاً اطمینان حاصل کنید که کارت microSD شما در BitBox02 قرار دارد."
  },
  stepCreateSuccess: {
    removeMicroSD: "لطفاً کارت microSD را از BitBox02 خود جدا کرده و آن را در یک مکان امن نگهداری کنید.",
    success: "نسخه پشتیبان خود را با موفقیت ایجاد کرده اید."
  },
  stepPassword: {
    title: "رمزعبور BitBox02 را تنظیم کنید",
    useControls: "برای تنظیم رمزعبور از کنترل های موجود در BitBox02 استفاده کنید."
  },
  stepUninitialized: {
    create: "می خواهم یک BitBox02 جدید را تنظیم کنم.",
    restore: "می خواهم کیف پول خود را از یک نسخه پشتیبان بازیابی کنم.",
    restoreMicroSD: "بازیابی از حافظه microSD",
    restoreMnemonic: "بازیابی با کلمات بازیابی",
    title: "BitBox02 خود را تنظیم کنید"
  },
  success: {
    text: `هورا! اکنون BitBox02 شما آماده استفاده است.

برای کسب اطلاعات بیشتر در مورد نحوه استفاده از BitBoxApp ، لطفاً با کلیک روی علامت سؤال در گوشه بالا سمت راست ، از راهنمای برنامه استفاده کنید.`,
    title: "شما آماده رفتن هستید!"
  }
}, blink$4 = {
  button: "چشمک زدن"
}, bootloader$4 = {
  button: "بروزرسانی سیستم عامل",
  progress: "بروزرسانی: {{progress}}%",
  success: "ارتقا موفقیت آمیز بود! لطفا دستگاه را دوباره متصل نمایید. این بار، دکمه را لمس نکنید."
}, button$8 = {
  abort: "لغو",
  back: "بازگشت",
  changepin: "تغيير رمزعبور دستگاه",
  check: "بررسی پشتیبان",
  continue: "ادامه",
  copy: "کپی",
  create: "ایجاد",
  download: "دانلود",
  hiddenwallet: "ساخت کیف پول مخفی",
  next: "بعدي",
  ok: "تاييد",
  previous: "قبلي",
  receive: "دریافت",
  restore: "بازیابی",
  select: "انتخاب",
  send: "واریز",
  unlock: "باز کردن",
  update: "بروز رسانی",
  upgrade: "ارتقاء"
}, changePin$4 = {
  newTitle: "رمزعبور جدید دستگاه",
  oldLabel: "رمزعبور فعلي دستگاه "
}, checkSDcard$4 = "بررسی حافظه microSD", clickHere$4 = "اینجا کلیک کنید.", confirm$6 = {
  abortInfo: "ضربه بزنید تا",
  abortInfoRedText: "لغو",
  approveInfo: "4 ثانیه نگه دارید تا",
  approveInfoGreenText: "تاييد ",
  info: "روی BitBox",
  infoWhenPaired: "اول بر روی موبایل و سپس BitBox"
}, confirmOnDevice$4 = "لطفاً بر روی دستگاه خود تأیید کنید.", device$4 = {
  appUpradeRequired: "BitBox شما با این برنامه سازگار نیست. لطفا آخرین نسخه را دانلود و نصب کنید."
}, deviceLock$4 = {
  button: "فعال کردن تایید دو مرحله ای (2FA)",
  condition1: "آیا پشتیبان دارین؟",
  condition2: "آیا برنامه تایید موبایل کار می کند؟",
  condition3: "تایید دو مرحله ای پشتیبان و اتصال موبایل را خاموش می کند. دستگاه برای خروج از تایید 2 مرحله ای باید ریست شود.",
  confirm: "فعال کردن تایید دو مرحله ای (2FA)",
  title: "فعال کردن تایید دو مرحله ای (2FA)"
}, deviceSettings$4 = {
  firmware: {
    newVersion: {
      label: "نسخه موجود"
    },
    title: "سیستم عامل",
    upToDate: "دستگاه شما بروز است",
    version: {
      label: "نسخه"
    }
  },
  hardware: {
    sdcard: {
      false: "قرار ندارد",
      label: "حافظه microSD",
      true: "قرار دارد"
    },
    title: "سخت افزار"
  },
  loading: "بازگرداندن اطلاعات دستگاه...",
  pairing: {
    lock: {
      false: "خاموش",
      label: "تایید دو مرحله ای (2FA)",
      true: "روشن"
    },
    mobile: {
      false: "بسته شده",
      label: "برنامه موبایل",
      true: "باز"
    },
    status: {
      false: "متصل نشده",
      label: "وضعیت",
      true: "متصل"
    },
    title: "اتصالات"
  },
  secrets: {
    manageBackups: "مدیریت پشتیبان ها",
    title: "اسرار"
  }
}, deviceTampered$4 = "آیا BitBox شما دارای رمز بازیابی است؟ اگر هست، پروسه نصب را انجام نداده و سریعا با بخش پشتیبانی تماس بگیرید. Shift هرگز به شما کیف پول از قبل ساخته شده یا رمزعبور پیشنهادی نمی دهد", dialog$5 = {
  cancel: "لغو",
  confirm: "تایید"
}, fiat$6 = {
  default: "پیش فرض",
  setDefault: "{{code}} را به عنوان پیشفرض تنظیم کنید",
  title: "ارزها"
}, footer$6 = {
  appVersion: "نسخه برنامه:"
}, genericError$4 = "یک خطا رخ داده است اگر متوجه شدید، لطفا برنامه را مجددا راه اندازی کنید.", goal$4 = {
  buttons: {
    create: "یک کیف پول جدید ایجاد کنید",
    restore: "بازگرداندن کیف پول از پشتیبان"
  },
  paragraph: "لطفا یکی از گزینه های زیر را انتخاب کنید:",
  step: {
    1: {
      title: "اطلاعات امنیتی"
    },
    2: {
      description: "رمز عبور دستگاه را تنظیم کنید",
      title: "دستگاه"
    },
    "3-create": {
      description: "یک کیف پول جدید ایجاد کنید",
      title: "كيف پول"
    },
    "3-restore": {
      description: "از یک پشتیبان",
      title: "بازیابی"
    },
    "4-create": {
      title: "خلاصه"
    },
    "4-restore": {
      title: "خلاصه"
    }
  }
}, guide$5 = {
  accountDescription: {
    text: 'نمای کلی حساب شما موجودی شما و همچنین معاملات ورودی و خروجی را نشان می دهد. راهنمای ما در "تنظیمات" درباره هر نوع حساب اطلاعات بیشتری دارد. ',
    title: "چه چیزی در این صفحه به من نمایش داده می شود؟"
  },
  accountFiat: {
    text: "بله، شما می توانید با کلیک کردن بر روی نام ارز رایج، ارز های رایج دیگر را ببینید و می توانید لیست ارز ها را در بخش تنظیمات تغییر دهید.",
    title: "آیا می توانم دیگر نرخ تبدیل را نمایش دهم؟"
  },
  accountIncomingBalance: {
    text: "دریافتی به جمع مقادیری که به شما منتقل می شود ولی هنوز توسط شبکه تایید نشده است می گویند.",
    title: "معنی دریافتی چیست؟"
  },
  accountInfo: {
    xpub: {
      text: `یک کلید عمومی گسترش یافته یک کلید ریشه است که از آن می توان تمام آدرس های دریافتی یک حساب را دریافت کرد.
این در اینجا برای استفاده پیشرفته و قابلیت همکاری با کیف پول نمایشی مانند Electrum یا Sentinel ارائه شده است.`,
      title: "کلید عمومی گسترش یافته چیست؟"
    }
  },
  accountRates: {
    text: "",
    title: "کدام نرخ استفاده می شود؟"
  },
  accountReload: {
    text: "همه اطلاعات تراکنش به صورت خودکار بروز می شود.",
    title: "چگونه می توانم سابقه تراکنش را بروز کنم؟"
  },
  accountSendDisabled: {
    text: "دکمه «ارسال» هنگامی فعال می شود که موجودی شما بیش از صفر باشد.",
    title: "چرا نمی توانم هر مقدار {{unit}} را بفرستم؟"
  },
  accountTransactionAttributesBTC: {
    text: `اندازه مجازی: برای تعیین هزینه شبکه استفاده می شود. شما با موفقیت در هزینه صرفه جویی کردید اگر کوچکتر از اندازه تراکنش باشد.
اندازه: حجم معامله واقعی در بایت زمانی که با توجه به بلوک های زیرزمینی سرویسی می شود.
وزن: با Segwit معرفی شده است، این یک متریک جدید برای ارزیابی معامله و اندازه بلوک است. هر شهود جداگانه شمرده شده به عنوان یک، هر چیز دیگری به عنوان چهار وزن واحد. به جای یک مگابایت در اندازه واقعی، محدودیت اندازه بلوک در حال حاضر ٤ میلیون وزن واحد است.`,
    title: "جزئیات معاملات بیت کوین خاص چیست؟"
  },
  accountTransactionAttributesGeneric: {
    text: `تأییدیه: هنگامی که تراکنش شما برای اولین بار پخش می شود، تأیید نخواهد شد. شما باید منتظر بمانید تا یک معدنچی به یک بلوک اضافه شود و پس از آن یک تایید داشته باشد. هر بلوک پخش شده در شبکه پس از آن تایید دیگری برای معامله شما خواهد بود. به طور کلی، بازرگانان و بازیگران شبکه دیگر تنها قبل از اینکه معامله را به عنوان معامله انجام دهند، معاملات را بین ٣-٦ تایید پذیرفته اند.
شناسه تراکنش: یک شماره شناسایی منحصر به فرد است که می تواند برای جستجوی تراکنش در جستوجوگر بلوک استفاده شود.
هزینه: استخراج کنندگان هزینه معامله را به عنوان یک انگیزه برای شامل معاملات در بلوک هایی که معدن دارند، پرداخت می کنند. برای کسب اطلاعات بیشتر، روی دکمه ارسال کلیک کنید.`,
    title: "اطلاعاتی که در جزئیات تراکنش نشان داده شده است چیست؟"
  },
  accountTransactionConfirmation: {
    text: "این تراکنشی است که به شبکه فرستاده شده و منتظر تایید آن است.",
    title: "تراکنش ،در انتظار چیست؟"
  },
  accountTransactionLabel: {
    text: "این آدرس است که در آن سکه ها را دریافت کرده اید یا سکه ها را ارسال می کنید.",
    title: "کدام آدرس برای هر تراکنش نمایش داده می شود؟"
  },
  accountTransactionTime: {
    text: "زمانی که تراکنش در بلاکچین تایید شود.",
    title: "چه زمانی نمایش داده می شود؟"
  },
  appendix: {
    link: "ارتباط با ما",
    text: "سوال دیگر؟"
  },
  backups: {
    check: {
      text: "«بررسی پشتیبان» به شما اجازه می دهد تا مطمعن شوید که پشتیبان تهیه شده مربوط به کیف پول فعلی شما سالم است. همچنین می توانید رمزعبور بازیابی خود را بررسی کنید. شما می توانید رمزعبور بازیابی اصلی یا رمزعبور بازیابی مخفی خود را بررسی کنید.",
      title: '"بررسی پشتیبان" چیست؟'
    },
    encrypt: {
      text: "خیر، برای بازگرداندن کیف پول از کلمات ذخیره شده رمزعبور بازیابی شما احتیاج است.",
      title: "آیا می توانم پشتیبان را رمزگذاری کنم؟"
    },
    howOften: {
      text: `زمانی که کیف پول جدید ساخته می شود پشتیبان به صورت خودکار تولید می شود. شما فقط زمانی پشتیبان جدید تهیه می کنید اگر حافظه microSD را گم کرده باشید یا خراب شده باشد، یا اگر می خواهید بر روی حافظه های microSD متعدد پشتیبان داشته باشید.
شما احتیاجی به پشتیبان گیری بعد از انجام معامله ندارید. همه اطلاعات معاملات شما می توانند با یک پشتیبان که به صورت خودکار برای شما تهیه شده بازگردانده شوند.`,
      title: "چند بار باید یک نسخه پشتیبان تهیه کنم؟"
    },
    whatIsABackup: {
      text: "این یک نسخه از کلمات در کارت حافظه میکرو SD است. کلمات به همراه رمزعبور بازیابی کیف پول شما را ایجاد می کند.",
      title: "پشتیبان چیست؟"
    }
  },
  backupsBB02: {
    check: {
      text: '"بررسی نسخه پشتیبان" به شما امکان می دهد تا اطمینان حاصل کنید که یک نسخه پشتیبان مربوط به کیف پول فعلی خود دارید.',
      title: "'بررسی نسخه پشتیبان' چیست؟"
    },
    encrypt: {
      text: 'خیر.  لطفاً کارت حافظه microSD را ایمن نگه دارید ، زیرا شامل کلمات بازیابی رمزنگاری نشده برای بازیابی کیف پول شما است. اگر می خواهید با گذرواژه از کلمات بازیابی خود محافظت کنید ، می توانید یک عبارت عادی را در تنظیمات پیشرفته تحت "مدیریت دستگاه" فعال کنید.',
      title: "آیا می توانم نسخه پشتیبان را رمزگذاری کنم؟"
    },
    whatIsABackup: {
      text: "این یک کپی از کلمات بازیابی در کارت microSD است.",
      title: "نسخه پشتیبان چیست؟"
    }
  },
  bitbox: {
    "2FA": {
      text: `زمانی که تایید دو مرحله ای فعال است، برای خرج کردن سکه ها همه معاملات باید با موبایل متصل شده تایید شوند. در پشت برنامه، یک شماره یک بار مصرف قفل گذاری شده به موبایل ارسال می شود، قفل باز می شود، و زمانی که کلید قبول را می زنید شماره برای BitBox بر می گردد. این ارتباط با دستگاه از طریق کانال بین موبایل و این برنامه کامپیوتری درهنگام اتصال ایجاد شده انجام می شود.

مطمئن شوید قبل از فعال کردن تایید 2 مرحله ای از کیف پول خود پشتیبان تهیه کنید و موبایل خود را متصل کنید. پس از فعال کردن حافظه میکرو SD و اتصال برنامه موبایل غیر فعال  می شود. آنها با بازنشانی BitBox که دستگاه را پاک می کند، می تواند دوباره فعال شود.`,
      title: "تایید دو مرحله ای (2ّFA) چگونه کار می کند؟"
    },
    disable2FA: {
      text: 'برای غیر فعال کردن تایید دو مرحله ای، شما نیاز به بازنشانی BitBox خود و سپس بازگرداندن کیف پول از پشتیبان. اطمینان حاصل نمایید که در حافظه میکرو SD پشتیبان داشته باشیدو همچنان رمز عبور بازیابی را به یاد داشته باشید. سپس "بازنشانی دستگاه" را فشار دهید. رمز عبور جدید دستگاه را وارد نمایید و گزینه  "یا بازگرداندن پشتیبان" را انتخاب کنید. پشتیبان کیف پول را انتخاب کنید، "بازگرداندن" را کلیک کنید و رمز عبور بازگرداندن که زمان ساخت کیف پول وارد کردید را وارد کنید.',
      title: "چگونه می توانم تایید دو مرحله ای را خاموش کنم؟"
    },
    ejectBitbox: {
      text: "شما می توانید BitBox را در هر زمان بدون نیاز به اولیای خود بکشید.",
      title: "چگونه می توانم BitBox را جدا کنم؟"
    },
    ejectSD: {
      text: "شما می توانید کارت microSD را از BitBox در هر زمانی که شما در حال ایجاد یا بازگرداندن پشتیبان نیستید حذف کنید.",
      title: "چگونه می توانم کارت microSD را حذف کنم؟"
    },
    hiddenWallet: {
      text: "این یک کیف پول دوم در همان دستگاه محافظت شده با یک رمز عبور دستگاه دیگر و بازیابی رمز عبور است که شما می توانید برای واکنش قابل اعتماد استفاده کنید. همان بوت پشتیبان برای هر دو کیف پول عادی و پنهان شما استفاده می شود، بنابراین هیچ پشتیبان اضافی لازم نیست.",
      title: "کیف پول مخفی چیست؟"
    },
    legacyHiddenWallet: {
      text: "اول باید روی دکمه زیر کلیک کنید (در صورتی دکمه فعال است که BitBox با رمزعبور اصلی دستگاه باز باشد و تایید دو مرحله ای غیر فعال باشد، فعال است)، سپس BitBox را دوباره متصل کنید و با رمزعبور مخفی دستگاه باز نمایید.",
      title: "چگونه می توانم به کیف پول legacy مخفی دسترسی داشته باشم؟"
    },
    pairing: {
      text: "بعد از نصب برنامه موبایل ما برای IOS یا Android، شما کد QR نمایش داده شده را اسکن می کنید. که اتصال امن بین برنامه موبایل و این برنامه ایجاد می کند. پس از اسکن، دستورالعمل های برنامه موبایل را دنبال کنید.",
      title: "چگونه اتصال امن با موبایل خود داشته باشید"
    }
  },
  receive: {
    address: {
      text: "آدرس را به دیگران بدهید تا به شما مقداری سکه بدهند. فقط مطمئن شوید ادرس را به درستی ارسال می کنید.",
      title: "با یک آدرس چه کار کنم؟"
    },
    addressChange: {
      text: "به محض اینکه یک آدرس در یک تراکنش استفاده می شود، آدرس جدید به لیست اضافه می شود تا آن را جایگزین کند. همیشه ٢٠ آدرس استفاده نشده موجود در لیست وجود دارد.",
      title: "چه وقت آدرس تغییر می کند؟"
    },
    howVerify: {
      text: `برای BitBox01، روی آیکون BitBox در نوار کناری سمت چپ کلیک کنید و بخش جفت شدن را ببینید. راهنمای به روز می شود و شما می توانید به دنبال دستورالعمل ها از آنجا ادامه دهید.
برای BitBox02، شما می توانید آدرس ها را بصورت مستقیم بر روی دستگاه هنگام دریافت و ارسال تایید کنید.`,
      title: "چگونه می توانم یک آدرس را به صورت ایمن تأیید کنم؟"
    },
    why20: {
      text: 'در هنگام راه اندازی برنامه آدرس هایی را که از دانه شما گرفته می شود ، ایجاد می کند تا ببیند که آیا تراکنش دریافت کرده اند یا خیر. از آنجا که برنامه می تواند تعداد نامحدودی آدرس را ایجاد می کند ، می تواند سالها برای تعیین موجودی زمان صرف کند. برای محدود کردن این جستجو ، پس از مشاهده 20 نشانی که هرگز تراکنش دریافت نکرده اند ، متوقف می شود. این "حد فاصله" است و 20 استاندارد بالفعل است که هر چند تعداد دلخواه است. این 20 نشانی است که می توانید انتخاب کنید.',
      title: "چرا فقط 20 آدرس؟"
    },
    whyMany: {
      text: "برای حفظ حریم خصوصی و امنیت، شما نباید از یک آدرس دو بار استفاده نمایید. بر روی فلش سمت راست کلیک کنید تا آدرس جدید برای هدف دیگری بگیرید. شما می توانید ٢٠ آدرس در  لحظه بسازید. آدرس ها را مانند شماره فاکتور در نظر بگیرید. همه آدرس ها از seed پشتیبان شما تهیه شده اند.",
      title: "چرا آدرس های زیادی وجود دارد؟"
    },
    whyVerify: {
      text: "یکی از دلایل خرید کیف پول سخت افزاری مانند BitBox این است که شما نباید به دلیل سطح حمله بزرگ خود به کامپیوتر خود اعتماد کنید. در نتیجه، شما نباید به کامپیوتر خود اعتماد کنید تا آدرس های معتبر تولید و نمایش داده شود. این دکمه برای تایید ایمن آدرس BitBox را مجبور به ارسال آدرس به تلفن همراه متصل شده می کند، که از آن شما می توانید کد QR را اسکن و تایید نمایید. برای BitBox02 آدرس می تواند تایید شود بر روی صفحه نمایش BitBox02",
      title: "چرا باید آدرس ایمن را تأیید کنم؟"
    }
  },
  send: {
    fee: {
      text: `هزینه براساس اندازه داده های تراکنش و نه مقدار آن است. اهداف هزینه توسط الگوریتم تخمین هزینه هسته Bitcoin برای هر اولویت شبکه ای که انتخاب کرده اید محاسبه می شود. آنها نشان داده شده اند اگر ارزش دیگری از هدف زیر داشته باشند.
اقتصاد: ٢٤ بلوک (حدود ٤ ساعت برای Bitcoin، ١ ساعت برای Litecoin)
کم: ١٢ بلوک (حدود ٢ ساعت برای Bitcoin، ٣٠ دقیقه برای Litecoin)
عادی: ٦ بلوک (حدود ١ ساعت برای Bitcoin، ١٥ دقیقه برای Litecoin)
بالا: ٢ بلوک (حدود ٢٠ دقیقه برای Bitcoin، ٥ دقیقه برای Litecoin)
(یک بلاک برای Bitcoin به طور متوسط ١٠ دقیقه طول می کشد (٢.٥ دقیقه در Litecoin) برای استخراج و بار شبکه ممکن است به طور قابل توجهی در دوره های بالا متفاوت باشد.)`,
      title: "هزینه تراکنش چگونه تعیین می شود؟"
    },
    priority: {
      text: "هر چه هزینه بالاتری پرداخت کنید، معاملات شما توسط شبکه سریع تر تایید می شود.",
      title: "اولویت شبکه چیست؟"
    },
    revert: {
      text: `هنگامی که یک معامله امضا و ارسال می شود(یعنی در شبکه پخش می شود)، دیگر نمی توان برگرداند. قبل از امضای معامله با دقت معامله (حتی هزینه) را بررسی کنید.
اگر می دانید گیرنده مایل به ارسال همان مقدار (منهی هزینه تراکنش) است، شما می توانید آدرس دریافت جدید به آنها بدهید.`,
      title: "آیا می توانم تراکنش را بازگردانم؟"
    },
    whyFee: {
      text: `معاملات در حال رقابت برای تایید شدن توسط ماینر ها هستند. ماینرها معاملات را براساس هزینه آنها انتخاب می کنند تا در بلاکچین قرار بگیرند.
ماینرها براساس تاریخچه معاملات رای می دهند. از آنجایی که هیچ شخص سومقابل اعتمادی برای اجرای یک رای برای هر نفر (که پایه و اساس بلاک چین ها است) وجود ندارد، ماینرها با به خطر انداختن منابع هزینه ای مانند قدرت محاسبات، به معاملات رای میدهند. به عنوان پاداش کار خود، آنها می توانند سکه های تازه ایجاد شده و هزینه تمام معاملات موجود را دریافت کنند.`,
      title: "چرا هزینه ی شبکه وجود دارد؟"
    }
  },
  "settings-electrum": {
    what: {
      text: "به جای استفاده از سرورهای Shift، ممکن است کیف پول خود را با کد های کامل خود فعال کنید.",
      title: "این چیه؟"
    }
  },
  settings: {
    servers: {
      text: `این برنامه با سرورهای Shift Crypto برای برسی بروزرسانی، دریافت معملات و ارسال اطلاعات به برنامه موبایل متصل شده در ارتباط است. علاوه بر این آخرین نرخ ارز تبدیل را از سابت CoinGecko دریافت می کند. (تبدیل به صورت محلی محاسبه می شود، هیچ مبلغی از شما ارسال نمی شود.)
توجه: برای توکن های Ethereum و ERC20 ، ما از API های Etherscan.io استفاده می کنیم.`,
      title: "کدام سرور با این برنامه صحبت می کند؟"
    }
  },
  title: "راهنما",
  toggle: {
    close: "بستن راهنما",
    open: "راهنما"
  },
  unlock: {
    forgotDevicePassword: {
      text: "شما باید دستگاه را بازنشانی کنید و کیف پول را با استفاده از رمزعبور بازیابی بازگردانید.",
      title: "اگر رمز عبور دستگاه را فراموش کرده ام چه کاری انجام دهم؟"
    },
    reset: {
      text: "رمز عبور دستگاه اشتباه را ١٥ بار وارد کنید چندین تلاش اخیر نیاز به لمس طولانی در دستگاه دارد.",
      title: "چگونه دستگاه را بازنشانی کنم؟"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "چراغ دستگاه در زمان اتصال باید یک بار چشمک بزن. اطمینان حاصل فرمایید که دستگاه از راه درست وارد شده است. اگر شما با مشکل روبرو شدید، لطفا از طریق لینک زیر با ما در ارتباط باشید.",
      title: "BitBox01 من شناسایی نشده است"
    },
    getDevice: {
      link: {
        text: "سفارش BitBox"
      },
      text: "شما می توانید BitBox را در فروشگاه آنلاین ما خریداری کنید:",
      title: "چگونه مي توانم يك دستگاه بگيرم؟"
    },
    internet: {
      text: "بله، اتصال اینترنت برای همگام سازی کیف پول لازم است، ارسال معاملات و بازیابی آخرین نرخ ارز.",
      title: "آيا اين برنامه به اينترنت نياز دارد؟"
    },
    lostDevice: {
      link: {
        text: "مرکز پشتیبان گیری"
      },
      text: "شما می توانید حساب های خود را در BitBox جدید یا مرکز پشتیبان گیری خود بازیابی کنید.",
      title: "دستگاه خود را از دست دادم حالا چی؟"
    },
    useWithoutDevice: {
      text: "متأسفانه این هنوز در حال حاضر امکان پذیر نیست.",
      title: "آيا مي توانم  اين برنامه را بدون دستگاه استفاده كنم؟"
    },
    welcome: {
      text: "با تشکر از استفاده شما از این برنامه، که توسط Shift Crypto واقع در سویس، ساخته شده است. این هنوز نسخه بتا است و بابت هر نظری که با ما به اشتراک می گذارید قدر دانیم. لطفا با استفاده از لینک زیر بازخورد خود را برای ما ارسال نمایید.",
      title: "به برنامه BitBox خوش آمدید!"
    }
  }
}, headerssync$4 = {
  blocksSynced: "{{blocks}} بلوک همگام سازی شده است"
}, hiddenWallet$4 = {
  info1HTML: "برای اهداف معتبر قابل اعتماد، یک کیف پول پنهان را می توان بر اساس یک رمز عبور دستگاه،  متفاوت  + رمز عبور بازیابی ترکیب کرد.",
  info2HTML: "رمزعبور دستگاه و رمزعبور بازیابی که شما می خواهید با کیف پول پنهان خود مرتبط کنید تعیین کنید. رمزعبور دستگاه و رمزعبور بازیابی باید <strong>متفاوت</strong> با مواردی باشد که برای کیف پول اصلی وارد کردید.",
  passwordLabel: "رمز عبور بازیابی پنهان",
  passwordPlaceholder: "لطفا رمز عبور بازیابی پنهان را تایید کنید",
  pinLabel: "رمز عبور دستگاه مخفی",
  pinRepeatLabel: "رمز عبور دستگاه پنهان را تکرار کنید",
  pinRepeatPlaceholder: "لطفا رمز عبور دستگاه مخفی را تأیید کنید",
  success: "کیف پول مخفی با موفقیت ایجاد شد BitBox خود را دوباره متصل کنید تا آن را باز کنید."
}, initialize$4 = {
  create: "رمز عبور دستگاه را تنظیم کنید",
  creating: "تنظیم گذرواژه دستگاه ...",
  error: {
    e102: "گذرواژه دستگاه باید حداقل ٤ کاراکتر داشته باشد."
  },
  info: {
    description1: "گذرواژه دستگاهتان را انتخاب کنید این برای باز کردن BitBox شما مورد استفاده قرار می گیرد.",
    description2: "شما می توانید از اعداد، حروف استفاده کنید. رمزهای طولانی امنیت بیشتری دارد.",
    description3: "اگر گذرواژه دستگاه را از دست بدهید، مجبورید دستگاه خود را بازنشانی کنید و پشتیبانگیری کیف پول خود را بازگردانید.",
    subtitle: "اکنون رمز عبور دستگاه خود را تنظیم می کنید",
    title: "راه اندازی دستگاه"
  },
  input: {
    label: "گذرواژه دستگاه",
    labelRepeat: "رمز عبور دستگاه را تکرار کنید",
    placeholderRepeat: "لطفا گذرواژه دستگاه را تأیید کنید"
  }
}, invalidFormat$4 = "فرمت نامعتبر", language$5 = {
  title: "زبان مورد نظر را انتخاب كنيد"
}, legacyhiddenwallet$4 = {
  disable: "غیر فعال کردن کیف پول legacy مخفی",
  enable: "فعال کردن کیف پول legacy مخفی",
  successDisable: "با موفقیت کیف پول legacy مخفی غیر فعال شد",
  successEnable: "با موفقیت کیف پول legacy مخفی فعال شد. BitBox را دوباره متصل نمایید و رمز عبور مخفی دستگاه را برای دسترسی به کیف پول legacy مخفی وارد کنید."
}, loading$4 = "در حال بارگذاری…", notification$4 = {
  newTxs_one: "{{count}} معاملات جدید در: {{accountName}}"
}, pairing$4 = {
  aborted: {
    text: "اتصال توسط برنامه موبایل قطع شده است.",
    title: "لغو شد"
  },
  button: "اتصال به برنامه موبایل",
  confirm: "آیا مطمعن هستید که BitBox  خود را به تلفن همراه متصل نمایید؟ این را بدانید که بعدا شما تلفن همراه را برای تایید تراکنش احتیاج دارید",
  connectOnly: {
    button: "اتصال به برنامه موبایل",
    title: "با انتخاب گزینه «اتصال با برنامه کامپیوتری جدید» در منوی برنامه موبایلی ما اسکن نمایید."
  },
  error: {
    text: "چیزی اشتباه شد لطفا دوباره سعی کنید",
    title: "خطا"
  },
  reconnectOnly: {
    button: "اتصال مجدد با برنامه موبایل"
  },
  start: {
    hideAppQRCode: "مخفی کردن کد QR",
    revealAppQRCode: "نمایش کد QR",
    step1: "اگر شما برنامه تلفن همراه را ندارید، می توانید کد QR برای اپل App Store یا فروشگاه Google Play را بسته به کدام گوشی داشته باشید اسکن نمایید.",
    step2: 'اسکن با برنامه تلفن همراه ما، که شما می توانید تحت نام "Digital Bitbox 2FA" در فروشگاه برنامه برای iOS و Android پیدا کنید:'
  },
  started: {
    text: "لطفا اکنون دستورالعمل های برنامه موبایل را دنبال کنید.",
    title: "عالی"
  },
  success: {
    text: "تبریک می گوییم، شما با موفقیت BitBox خود را به برنامه موبایل متصل کردید!",
    title: "موفقیت"
  },
  timeout: {
    text: "متصل شدن پس از دو دقیقه به پایان رسید. اگر هنوز می خواهید برنامه موبایل را متصل کنید، دوباره سعی کنید.",
    title: "وقفه"
  },
  title: "اتصال تلفن همراه"
}, password$4 = {
  show: "نمایش {{label}}",
  warning: {
    caps: "هشدار: کلید Caps lock (⇪) فعال است",
    paste: 'برای جاگذاری، "نمایش {{label}}" را فعال نمایید.'
  }
}, random$5 = {
  button: "تولید شماره تصادفی",
  description: "BitBox شما این شماره {{bits}}-بیت زیر را تولید کرد:"
}, receive$6 = {
  label: "آدرس شما",
  onlyThisCoin: {
    description: "برای دریافت توکن های دیگر ، آنها را در تنظیمات فعال کنید. اگر توکن های دیگری را به آنها واریز می کنید ، ممکن است در دسترس نباشند.",
    warning: "اطمینان حاصل فرمایید که فقط {{coinName}} را با این آدرس دریافت کنید."
  },
  showFull: "نمایش و تأیید آدرس کامل روی دستگاه",
  title: "دریافت {{accountName}}",
  verify: "تایید ایمن آدرس",
  verifyBitBox01: "آدرس را در برنامه تلفن همراه تأیید کنید",
  verifyBitBox02: "آدرس را در BitBox02 تأیید کنید",
  verifyInstruction: "لطفا بررسی کنید آدرس را با آدرس نمایش داده شده در موبایل شما یکی است.",
  warning: {
    secureOutput: "لطفا BitBox خود را با موبایل خود متصل کنید تا تایید ایمن آدرس فعال شود. از طریق نوار کناری به صفحه 'مدیریت دستگاه' بروید."
  }
}, reset$4 = {
  description: "تمام داده ها در دستگاه حذف خواهند شد. این شامل کلید خصوصی شما می شود!",
  notReset: "تنظیم مجدد دستگاه انجام نمی شود.",
  title: "تنظیم مجدد دستگاه",
  understand: "من یک نسخه پشتیبان تهیه کرده ام و رمز عبور بازیابی را می دانم",
  understandBB02: "من یک پشتیبان معتبر دارم"
}, securityInformation$4 = {
  create: {
    description1: "قبل از تنظیم دستگاه خود، توصیه می شود این کار را در یک محیط امن انجام دهید.",
    description2: "از شما خواسته می شود که دو کلمه عبور ایجاد کنید.",
    description3: "اولی  رمز عبور دستگاه  است که دستگاه BitBox شما را باز میکند و بعدا می توانید آن را تغییر دهید.",
    description4: "دومی  رمز عبور بازیابی است که قفل کیف پول را باز می کند. این رمزعبور بعدا قابل تغییر نیست",
    description5: "زمانی که کیف پول را می سازید، یک فایل پشتیبان در حافظه microSD ساخته می شود. این می تواند در شرایط اضطراری برای بازیابی کیف پول شما با استفاده از  رمزعبور بازیابی  شما استفاده شود.",
    title: "اطلاعات امنیتی"
  },
  restore: {
    description1: "از شما درخواست می شود که حافشه microSD که بر روی آن پشتیبان گیری کردید را قرار دهید.",
    description2: "برای بازگرداندن دستگاه شما به رمز عبور بازیابی نیاز خواهید داشت.",
    description3: "لطفا هنگام وارد کردن رمزعبور بازیابی مراقب باشید. هر مرزعبوری که وارد می کنید کیف پول معتبر ایجاد می کند. اگر شما رمزعبور اشتباه را وارد کردید ممکن است شما موجودی که انتظار ندارید را ببینید.",
    title: "اطلاعات امنیتی"
  }
}, seed$4 = {
  agreements: {
    "funds-access": "اگر رمز عبور بازیابی را فراموش کرده ام، نمیتوانم به موجودی خود دسترسی پیدا کنم",
    "password-change": "نمیتوانم پسورد بازیابی را تغییر دهم",
    "password-required": "رمز عبور بازیابی برای بازگرداندن کیف پول از یک پشتیبان نیاز است"
  },
  create: "ایجاد کیف پول",
  creating: "درحال یجاد کیف پول",
  description: "من متوجه هستم:",
  error: {
    e102: "گذرواژه باید حداقل ٨ کاراکتر داشته باشد.",
    e200: "شما نیاز به قراردادن حافظه microSD در BitBox برای ساخت کیف پول دارید، تا بتواند به صورت خودکار پشتیبان گیری انجام شود."
  },
  info: {
    button: "تنظیم رمز بازیابی",
    description1: "حافظه microSD را داخل BitBox قرار دهید",
    description2: 'رمزعبور کیف پول را انتخاب نمایید و سپس "تنظیم رمز بازیابی" را انتخاب کنید.',
    description3: "پشتیبان گیری در حافظه microSD و رمزعبور بازیابی تنها راه برگرداندن حساب های خود در زمان گم کردن یا دزدیده شدن دستگاه BitBox است.",
    description4: "بعدا نمیتوانید رمزعبور بازیابی خود را بدون انتقال وجوه خود تغییر دهید.",
    title: "ساخت کیف پول جدید"
  },
  password: {
    label: "رمز عبور بازیابی",
    repeatPlaceholder: "رمز عبور بازیابی را تکرار کنید"
  },
  walletName: {
    label: "نام كيف پول"
  }
}, seedRestore$4 = {
  error: {
    e200: "بازگرداندن کیف پول از یک پشتیبان نیاز به کارت microSD دارد."
  },
  info: {
    description1: "کارت microSD را داخل BitBox قرار دهید و روی «ادامه» کلیک کنید.",
    description2: 'یک نسخه پشتیبان را انتخاب کنید و روی "بازیابی" کلیک کنید',
    description3: "رمز عبور بازیابی را وارد کنید",
    description4: "شما باید تأیید کنید که رمز عبور اشتباه یک کیف پول متفاوت را ایجاد می کند.",
    title: "چگونه یک کیف پول را از یک نسخه پشتیبان تهیه کنید"
  }
}, send$6 = {
  abort: "تراکنش لغو شد.",
  address: {
    label: "آدرس گیرنده",
    placeholder: "آدرس را وارد کنید"
  },
  amount: {
    label: "مقدار",
    placeholder: "مقدار را وارد کنید"
  },
  button: "امضا و ارسال",
  coincontrol: {
    address: "آدرس",
    outpoint: "ارزیابی",
    title: "ارسال از خروجی"
  },
  confirm: {
    "selected-coins": "سکه های انتخاب شده",
    title: "تأیید تراکنش",
    total: "جمع"
  },
  error: {
    insufficientFunds: "موجودی کافی نیست",
    invalidAddress: "آدرس نامعتبر",
    invalidAmount: "مبلغ نامعتبر",
    invalidData: "داده های نامعتبر"
  },
  fee: {
    customPlaceholder: "مقدار را وارد کنید",
    label: "هزینه شبکه",
    placeholder: "در دسترس نیست"
  },
  feeTarget: {
    description: {
      economy: "٢٤ بلوک (حدود ٤ ساعت برای Bitcoin، ١ ساعت برای Litecoin)",
      high: "٢ بلوک (حدود ٢٠ دقیقه برای Bitcoin، ٥ دقیقه برای Litecoin)",
      low: "١٢ بلوک (حدود ٢ ساعت برای Bitcoin، ٣٠ دقیقه برای Litecoin)",
      normal: "٦ بلوک (حدود ١ ساعت برای Bitcoin، ١٥ دقیقه برای Litecoin)"
    },
    estimate: "زمان انتظار تخمینی:",
    label: {
      economy: "اقتصاد",
      high: "زیاد",
      low: "کم",
      normal: "متوسط"
    },
    placeholder: "محاسبه تخمین هزینه ..."
  },
  maximum: "ارسال همه",
  scanQR: "اسکن کد QR",
  signprogress: {
    description: "این معامله ای است که حاوی اطلاعات زیادی است. برای به طور کامل امضا کردن معامله، از شما خواسته می شود {{steps}} بار تأیید شود.",
    label: "پیشرفت"
  },
  success: "معامله امضا و ارسال شد .",
  title: "ارسال {{accountName}}",
  toggleCoinControl: "کنترل سکه را تغییر دهید"
}, settings$5 = {
  electrum: {
    add: "افزودن سرور",
    "add-server": "افزودن",
    check: "بررسی",
    checkFailed: "ناموفق",
    checkSuccess: "اتصال به {{host}} با موفقیت انجام شد.",
    checking: "بررسی",
    "download-cert": "دریافت گواهینامه از راه دور",
    "remove-server": "حذف",
    removeConfirm: "حذف {{server}}؟",
    reset: "تنظیم مجدد به حالت پیش فرض",
    resetConfirm: "آیا شما می خواهید همه سرور ها را حذف و سرور های پیشفرض نصب شوند؟",
    servers: "سرور ها",
    step1: "١",
    "step1-text": "نقطه پایانی را وارد کنید",
    step2: "٢",
    "step2-text": "یک گواهی از زنجیره گواهی سرور را وارد کنید. در کنار آن گواهی دسترسی از راه دور را دانلود کنید و چشمی مقایسه کنید.",
    step3: "٣",
    "step3-text": "اتصال را بررسی کنید و سرور را اضافه کنید.",
    step4: "٤",
    "step4-text": "راه اندازی مجدد کیف پول اگر شما سرورهای پیش فرض را حذف نکنید، گره مخصوص شما به عنوان افزونه افزوده خواهد شد.",
    "title-btc": "سرورهای Bitcoin Electrum",
    "title-ltc": "سرورهای Litecoin Electrum",
    "title-tbtc": "سرورهای تست Bitcoin Electrum ",
    "title-tltc": "سرورهای تست Litecoin Electrum "
  },
  expert: {
    coinControl: "کنترل سکه را فعال کنید",
    electrum: {
      title: "گره کامل خود را وصل کنید"
    },
    setProxyAddress: "آدرس پراکسی را تنظیم کنید",
    title: "تنظیمات پیشرفته",
    useProxy: "فعال کردن پراکسی Tor"
  },
  header: {
    home: "خانه"
  },
  restart: "لطفا برنامه BitBox را دوباره اجرا فرمایید تا تغییرات اجرا شون.",
  success: "لطفا BitBox را جدا کنید و متصل کنید تا تغییرات اعمال شوند.",
  title: "تنظیمات"
}, setup$4 = "راه اندازی دستگاه", sidebar$5 = {
  device: "مدیریت دستگاه",
  leave: "ترک",
  settings: "تنظیمات"
}, success$b = {
  create: {
    info1: "کیف پول شما در حافظه microSD با موفقیت پشتیبان گیری شد. آن را جدا کنید و در مکان امن نگهداری کنید.",
    info2: "شما یک رمزعبور امن دستگاه ایجاد کرده اید که BitBox را باز می کند.",
    info3: "شما رمزعبور بازیابی امن برای کیف پول خود را ایجاد کرده اید که حساب های خود را باز کرده و پشتیبان های خود را بازیابی کنید.",
    summary: "در اینجا خلاصه ای از آنچه شما انجام داده اید",
    title: "موفقیت"
  },
  getstarted: "شروع کنید",
  restore: {
    summary: "شما با موفقیت کیف پول را از پشتیبان بازگرداندید.",
    title: "موفقیت"
  }
}, transaction$5 = {
  confirmation: "تاییدیه ها",
  explorer: "شماره تراکنش",
  explorerTitle: "باز کردن در جستجوگر بلوک خارجی",
  fee: "هزینه",
  fiatHistorical: "تاریخی",
  gas: "گاز",
  pending: "تراکنش در انتظار",
  size: "اندازه",
  vsize: "اندازه مجازی",
  weight: "وزن"
}, transactions$4 = {
  placeholder: "هیچ تراکنشی وجود ندارد."
}, unknownError$4 = "یک خطای ناشناخته رخ داده است: {{errorMessage}}", unlock$4 = {
  description: "رمزعبور دستگاه را وارد نمایید تا دستگاه باز شود.",
  error: {
    e109_normal: "رمزعبور دستگاه اشتباه است. {{remainingAttempts}} تلاش باقی مانده قبل از ریست شدن دستگاه.",
    e109_touch: "$t(unlock.error.e109_normal) ورود بعدی نیاز به نگه داشتن اثر انگشت می باشد",
    e113: "بدلیل ورود ها متداول، ورود بعدی نیاز به نگه داشتن دکمه اثر انگشت برای 4 ثانیه می باشد."
  },
  input: {
    label: "رمز دستگاه",
    placeholder: "براي باز كردن قفل دستگاه رمز دستگاه را وارد كنيد "
  },
  unlocking: "قفل در حال باز شدن است"
}, upgradeFirmware$5 = {
  button: "ارتقاء سیستم عامل",
  description: "آیا می خواهید سیستم عامل از نسخه {{currentVersion}} به نسخه {{newVersion}} ارتقا یابد",
  label: "BitBox نیاز به ارتقا سیستم عامل دارد.",
  locked: "برای ارتقا از نسخه {{currentVersion}} به نسخه {{newVersion}}، لطفا دکمه لمسی را نگه دارید.",
  title: "ارتقا سیستم عامل",
  unlocked: "قفل bootloader باز شد. برای ادامه، لطفا :",
  unlocked1: "Bitbox را جدا کرده و دوباره وصل نمایید",
  unlocked2: "هنگامی که BitBox شما دوباره وصل می شود، LED روشن می شود",
  unlocked3: "هنگامی که چراغ ال ای دی روشن شد،روی دکمه لمسی ضربه بزنید"
}, warning$a = {
  receivePairing: "لطفا BitBox را برای فعال کردن تأیید ایمن آدرس به گوشی خود متصل کنید. برای این کار به «مدیریت دستگاه» در نوار کناری بروید.",
  sdcard: "حافظه microSD را جدا از BitBox نگهداری کنید، مگر اینکه بخواهید مدیریت پشتیبان را انجام دهید.",
  sendPairing: "لطفا BitBox را برای تأیید ایمن جزئیات معامله جفت کنید. به «مدیریت دستگاه» در نوار کناری بروید"
}, welcome$4 = {
  insertBitBox02: "برای ادامه BitBox02 ، لطفاً روی دستگاه ضربه بزنید.",
  insertDevice: "لطفا دستگاه خود را برای شروع وصل کنید",
  title: "خوش آمديد"
}, appTranslationsFA = {
  account: account$4,
  accountInfo: accountInfo$4,
  accountSummary: accountSummary$4,
  addAccount: addAccount$5,
  app: app$4,
  backup: backup$4,
  bb02Bootloader: bb02Bootloader$4,
  bitbox: bitbox$4,
  bitbox02Interact: bitbox02Interact$4,
  bitbox02Settings: bitbox02Settings$4,
  bitbox02Wizard: bitbox02Wizard$4,
  blink: blink$4,
  bootloader: bootloader$4,
  button: button$8,
  changePin: changePin$4,
  checkSDcard: checkSDcard$4,
  clickHere: clickHere$4,
  confirm: confirm$6,
  confirmOnDevice: confirmOnDevice$4,
  device: device$4,
  deviceLock: deviceLock$4,
  deviceSettings: deviceSettings$4,
  deviceTampered: deviceTampered$4,
  dialog: dialog$5,
  fiat: fiat$6,
  footer: footer$6,
  genericError: genericError$4,
  goal: goal$4,
  guide: guide$5,
  headerssync: headerssync$4,
  hiddenWallet: hiddenWallet$4,
  initialize: initialize$4,
  invalidFormat: invalidFormat$4,
  language: language$5,
  legacyhiddenwallet: legacyhiddenwallet$4,
  loading: loading$4,
  notification: notification$4,
  pairing: pairing$4,
  password: password$4,
  random: random$5,
  receive: receive$6,
  reset: reset$4,
  securityInformation: securityInformation$4,
  seed: seed$4,
  seedRestore: seedRestore$4,
  send: send$6,
  settings: settings$5,
  setup: setup$4,
  sidebar: sidebar$5,
  success: success$b,
  transaction: transaction$5,
  transactions: transactions$4,
  unknownError: unknownError$4,
  unlock: unlock$4,
  upgradeFirmware: upgradeFirmware$5,
  warning: warning$a,
  welcome: welcome$4
}, account$3 = {
  disconnect: "Conexión perdida. Reintentando... ",
  export: "Exportar ",
  exportTransactions: "Exportar transacciones a la carpeta de descargas como archivo CSV",
  fatalError: "Ha habido un error inesperado.",
  incoming: "Entrante",
  initializing: "Obteniendo información de la blockchain ...",
  maybeProxyError: "Tor Proxy activado. Asegúrese de que su Tor proxy está funcionando correctamente, o desactive la configuración del proxy.",
  reconnecting: "Conexión perdida, reconectando...",
  syncedAddressesCount: "Escaneado {{count}} direcciones"
}, accountInfo$3 = {
  address: "Dirección",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Crypto",
    information: {
      looksEmpty: "Parece que esta cartera está vacía.",
      start: "Comience depositando algunas monedas en la cartera o comprando directamente a través de la BitBoxApp."
    }
  },
  extendedPublicKey: "Clave pública extendida",
  label: "Información de la cuenta",
  scriptType: "Tipo de script",
  title: "Información de la cuenta",
  verify: "Verificar en el dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Ver clave pública extendida legacy P2PKH",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Native Segwit",
    "p2wpkh-p2sh": "Ver clave pública extendida antiguo Segwit"
  },
  xpubTypeInfo: "Actualmente mostrando {{scriptType}} clave pública extendida ({{current}} de {{numberOfXPubs}})"
}, accountSummary$3 = {
  availableBalance: "Saldo disponible",
  balance: "Saldo",
  exportSummary: "Resumen de cuentas de exportación a la carpeta de descargas como archivo CSV",
  fiatBalance: "Saldo de Fiat",
  name: "Nombre de cuenta",
  noAccount: "No hay cuentas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Mi portfolio",
  total: "Total",
  transactionHistory: "Historial de operaciones"
}, addAccount$4 = {
  chooseName: {
    nextButton: "Añadir cuenta",
    step: "Nombre de la cuenta",
    title: "Nombre de su cuenta"
  },
  selectCoin: {
    nextButton: "Siguiente",
    step: "Elija moneda",
    title: "Elija cryptomoneda"
  },
  success: {
    addAnotherAccount: "Añadir otra cuenta",
    message: "<strong>{{accountName}}</strong> ha sido ahora añadida a sus cuentas.",
    nextButton: "Hecho",
    step: "Finalizado",
    title: "Cuenta añadida"
  },
  title: "Añadir cuenta"
}, aopp$2 = {
  addressRequest: "{{host}} está solicitando una dirección de recepción.",
  addressRequestWithLogo: "está solicitando una dirección de recepción",
  banner: "Solicitud de dirección en curso. Conecte su dispositivo para continuar.",
  errorTitle: "Error durante la solicitud de dirección",
  labelAddress: "Dirección",
  labelMessage: "Mensaje",
  reverifyInfoText: "Verifique la dirección",
  signing: "Para proceder, firme el mensaje en su BitBox02",
  success: {
    message: "Proceder con {{host}}",
    title: "Dirección enviada con éxito"
  },
  syncing: "Sincronizando la cuenta, por favor espere.",
  title: "Solicitud de dirección"
}, app$3 = {
  upgrade: "Una nueva versión de esta aplicación está disponible! Por favor actualiza desde {{current}} a {{version}}."
}, auth$3 = {
  authButton: "Autentificar",
  title: "Por favor, autentifíquese para continuar"
}, backup$3 = {
  check: {
    checking: "Comprobando copia de seguridad ...",
    confirmTitle: "Comprobar la copia de seguridad",
    notOK: "Copia de seguridad NO coincide con el monedero.",
    ok: "Copia de seguridad coincide con el monedero.",
    password: {
      label: "Contraseña de recuperación",
      placeholder: "Contraseña de recuperación",
      showLabel: "contraseña de recuperación"
    },
    success: "Copia de seguridad verificada con éxito:",
    title: "Comprobar la copia de seguridad"
  },
  create: {
    alreadyExists: "Ya tienes una copia de seguridad válida. ¿Quieres volverla a crear?",
    fail: "La creación de la copia de seguridad ha FALLADO!",
    info: "Por favor ingresa la contraseña de recuperación del monedero actual para su verificación.",
    name: {
      label: "Nombre de la copia de seguridad",
      placeholder: "Por favor pon el nombre de la copia de seguridad"
    },
    password: {
      label: "Contraseña de recuperación",
      placeholder: "Por favor ingresa tu contraseña de recuperación"
    },
    title: "Crea copia de seguridad",
    verificationFailed: "La contraseña de recuperación NO COINCIDE con el monedero actual. La copia de seguridad ha sido creada. Por favor utiliza 'Comprueba copia de seguridad' para verificar tu contraseña de recuperación nuevamente."
  },
  description: "Selecciona <strong>archivo de copia de seguridad del monedero</strong>",
  insert: "Por favor, inserta la tarjeta micro SD para administrar las copias de seguridad.",
  insertButton: "He insertado la tarjeta micro SD",
  list: "Tus copias de seguridad en la microSD",
  noBackups: "No hay copias de seguridad en esta tarjeta microSD.",
  restore: {
    confirmTitle: "Recupera copia de seguridad",
    error: {
      e200: "Tarjeta SD no encontrada",
      general: "Error restaurando copia de seguridad"
    },
    password: {
      label: "Contraseña de recuperación o contraseña de recuperación oculta",
      placeholder: "Contraseña de recuperación",
      repeatPlaceholder: "Repita la contraseña de recuperación",
      showLabel: "Contraseña de recuperación"
    },
    restoring: "Restaurando copia de seguridad ...",
    selectedBackup: "<strong>{{backupName}}</strong> creada en {{createdDateTime}} será restaurada.",
    title: "Restaurar",
    understand: "Entiendo que una contraseña de recuperación incorrecta creará un monedero diferente"
  },
  showMnemonic: {
    description: `Se le presentarán sus palabras de recuperación, que constituyen una copia de seguridad de su cartera. Escríbalas en un papel..

<strong>No las almacenes digitalmente ni le tomes fotos.</strong>

<strong>No las diga en voz alta.</strong>

<strong>Esta copia de seguridad no está protegida por una contraseña.</strong>

A continuación, se le pedirá que confirme cada palabra. `,
    title: "Muestra las claves de recuperación",
    warning: "<strong>Nunca compartas tus palabras de recuperación con nadie.</strong> Tus palabras de recuperación dan acceso completo a tu billetera. Si alguien te pide tus palabras de recuperación, es un estafador, ¡no las compartas! "
  },
  title: "Administrar copias de seguridad"
}, bb02Bootloader$3 = {
  abort: "No actualices - vuelve atrás",
  abort_noUpgrade: "Llévame atrás",
  advanced: {
    label: "Configuración avanzada",
    toggleShowFirmwareHash: "Mostrar el hash del firmware en cada inicio"
  },
  flipscreen: "Gira la foto en la pantalla",
  orientation: "¿Está el dispositivo orientado de manera incorrecta?",
  success: "Actualizado con éxito! Continuando en {{rebootSeconds}} segundos...",
  success_install: "¡Instalación satisfactoria! Continúa en {{rebootSeconds}} segundos..."
}, bitbox$3 = {
  error: {
    e10000: "Contraseña del dispositivo actual incorrecta.",
    e10001: "Error al reemplazar la contraseña del dispositivo",
    e102: "La contraseña debe contener al menos 4 caracteres.",
    e112: "La contraseña oculta del dispositivo no puede ser la misma que la contraseña principal del dispositivo."
  }
}, bitbox02Interact$3 = {
  confirmDate: "Confirma la fecha de hoy en tu BitBox02",
  confirmDateText: "Esta fecha se utilizará para crear tu copia de seguridad.",
  confirmName: "Confirma el nombre en tu BitBox02",
  confirmWords: "Escriba la {{amount}} de palabras recuperación de su BitBox02",
  confirmWordsText: "Después el BitBox02 te pedirá que confirmes cada palabra para verificar que la copia de seguridad es correcta.",
  followInstructions: "Por favor, sigue las instrucciones en tu BitBox02",
  followInstructionsMnemonic: "Sigue las instrucciones de tu BitBox02 para introducir las palabras de recuperación de tu copia de seguridad y restaurar tu billetera.",
  followInstructionsMnemonicTitle: "Restaurar desde las palabras de recuperación"
}, bitbox02Settings$3 = {
  deviceName: {
    current: "Nombre del dispositivo actual",
    error: "No se ha podido establecer el nombre del dispositivo",
    error_104: "La confirmación del nombre del dispositivo fue abortada en el dispositivo.",
    input: "Nombre de la BitBox02",
    placeholder: "Nuevo nombre del dispositivo",
    title: "Establece el nombre de la BitBox02"
  },
  gotoStartupSettings: {
    description: "Esto reiniciará tu BitBox02 y entrará en la configuración de inicio.",
    title: "Ir a configuración de inicio"
  }
}, bitbox02Wizard$3 = {
  advanced: {
    button: "Opciones avanzadas",
    outOfDate: "Firmware obsoleto para esta función",
    seed12WordInfo: "Tenga en cuenta que el número de palabras no se puede cambiar después de crear la billetera.",
    seed12WordLabel: "Crear semilla de 12 palabras en lugar de 24 palabras",
    seed12WordText: "Predeterminadamente, la BitBox02 utiliza una semilla de 24 palabras. Ambas longitudes de semilla son seguras contra la fuerza bruta en la práctica. Algunos usuarios pueden preferir la conveniencia de la semilla de 12 palabras.",
    skipSDCardLabel: "Omitir la copia de seguridad de la tarjeta microSD y escribir las palabras de recuperación en su lugar",
    skipSDCardText: "Siempre tienes la opción de crear una copia de seguridad de la tarjeta microSD o escribir tus palabras de recuperación después de la configuración. Esto se puede hacer desde los ajustes.",
    title: "Opciones avanzadas de copia de seguridad"
  },
  attestationFailed: "La comprobación genuina del dispositivo ha fallado, que puede ser debido al reinicio de la aplicación mientras el dispositivo estaba esperando la interacción por parte del usuario. Por favor conecte de nuevo y inténtelo otra vez. Por favor contacte con support@bitbox.swiss si el error persiste.",
  backup: {
    point1: "Selecciona una copia de seguridad de la tarjeta microSD",
    point2: "Establece una contraseña para su dispositivo",
    restoreText: "Ok, restablezcamos una copia de seguridad!",
    text1: "Genial, has establecido la contraseña de tu BitBox02 y tu billetera se ha creado. Ahora es momento de crear tu primera copia de seguridad (backup). Por favor asegúrate de que tu tarjeta microSD se haya introducido en tu BitBox02 y continua.",
    text2: "Por favor sigue las instrucciones que aparecen en la pantalla de tu dispositivo para crear la copia de seguridad. ",
    text3: "Después de que tu copia de seguridad se haya creado, por favor extrae la tarjeta microSD y guárdala en un <strong>lugar seguro</strong>. El contenido de la tarjeta microSD no está protegido con contraseña. Nunca la insertes en ningún otro dispositivo que no sea tu BitBox02. ",
    userConfirmation1: "Debo guardar mi copia de seguridad en un lugar seguro.",
    userConfirmation2: "Mi copia de seguridad no está protegida por contraseña. Cualquiera con acceso a ella tiene acceso a mi billetera.",
    userConfirmation3: "Si pierdo o daño mi BitBox02, la única forma de recuperar mis fondos es recuperar mi billetera desde mi copia de seguridad.",
    userConfirmation4: "En caso de perder o dañar tanto mi copia de seguridad como mi BitBox02, mis fondos se habrán perdido.",
    userConfirmation5: "No debería insertar mi copia de seguridad de la tarjeta microSD en el ordenador, teléfono, impresora o en ningún otro dispositivo que no sea BitBox02.",
    userConfirmation5mnemonic: "No debo poner mis palabras de recuperación en un computador, teléfono, impresora o cualquier otro dispositivo que no sea un BitBox02."
  },
  create: {
    button: "Dale un nombre al dispositivo y continua",
    info: "Aquí están los pasos básicos que seguirás para instalar tu BitBox:",
    inputTitle: "Nombre del monedero",
    point1: "Dale un nombre a tu dispositivo",
    point2: "Establece una contraseña para su dispositivo",
    point3: "Crea una copia de seguridad",
    text: "Ok, creemos un nueva billetera!"
  },
  createBackupAborted: "Creación de copia de seguridad abortada.",
  createBackupFailed: "Creación de copia de seguridad fallida, vuelve a intentarlo.",
  initialize: {
    passwordText: "Ahora establezcamos una contraseña para tu dispositivo. Utiliza los controles en tu BitBox para introducir y escoger una contraseña.",
    passwordTitle: "Establece una contraseña para tu BitBox",
    text: "Tu BitBox02 se ha conectado con éxito! Ahora vamos a iniciar tu dispositivo. Empecemos seleccionando crear una billetera nueva o restablecer una billetera desde una copia de seguridad existente.<strong>Por favor asegúrate de tener una tarjeta microSD introducida en tu BitBox02</strong>",
    tip: "Te recomendamos que continuas en un entorno seguro.",
    title: "Inicia tu BitBox"
  },
  insertSDCard: "<strong>Por favor asegúrate de haber introducido una tarjeta microSD en tu BitBox02.</strong>",
  noPasswordMatch: "Las contraseñas no coinciden, por favor, vuelve a intentarlo.",
  pairing: {
    failed: "Conexión no confirmada. Por favor vuelve a conectar tu BitBox02.",
    paired: "Has confirmado el siguiente código en tu dispositivo.  Por favor continua.",
    title: "Comprueba el código de conexión.",
    unpaired: "Se ha detectado un BitBox02 no emparejado. Verifique que el código de emparejamiento coincida con lo que se muestra en su BitBox02. "
  },
  restoreFromMnemonic: {
    e104: "Se canceló la restauración desde las palabras de recuperación.",
    failed: "El restablecimiento desde tu clave de recuperación ha fallado, por favor vuelve a intentarlo."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, por favor lee estas importantes consideraciones de seguridad:",
    createBackup: "Ahora crearás una copia de seguridad en tu tarjeta microSD.",
    createBackupMnemonic: "Ahora escribirás las palabras de recuperación."
  },
  stepBackupSuccess: {
    fundsSafe: "Para mantener seguros tus fondos, por favor recuerda lo siguiente:",
    title: "Copia de seguridad restablecida!"
  },
  stepConnected: {
    unlock: "Introduce la contraseña de tu BitBox02 para desbloquearla."
  },
  stepCreate: {
    description: "Este nombre es utilizado como el nombre del dispositivo y el de la copia de seguridad.",
    nameLabel: "Nombre de la BitBox02",
    namePlaceholder: "Mi BitBox02",
    title: "Selecciona el nombre de la BitBox02",
    toastMicroSD: "Por favor, inserte su tarjeta microSD en su BitBox02 que se utilizará para almacenar una copia de seguridad de la billetera."
  },
  stepCreateSuccess: {
    removeMicroSD: "Por favor, extrae la tarjeta microSD de tu BitBox02 y guárdala en un lugar seguro. ",
    storeMnemonic: "Guarde sus palabras de recuperación en un lugar seguro",
    success: "Ha creado su copia de seguridad con éxito."
  },
  stepInsertSD: {
    insertSDCard: "Por favor, introduce una microSD en tu BitBox02 para continuar.",
    insertSDcardTitle: "Introduce la tarjeta microSD"
  },
  stepPassword: {
    e104: "Se canceló la configuración de la contraseña.",
    title: "Establece la contraseña de tu BitBox02",
    useControls: "Utiliza los controles de tu BitBox02 para establecer la contraseña."
  },
  stepUninitialized: {
    create: "Quiero configurar una nueva BitBox02.",
    restore: "Quiero recuperar mi billetera desde una copia de seguridad.",
    restoreMicroSD: "Recupera desde una tarjeta microSD",
    restoreMnemonic: "Restaurar desde las palabras de recuperación",
    title: "Instala tu BitBox02"
  },
  success: {
    text: `Perfecto! Tu BitBox02 está lista para ser usada. 

Para más información sobre cómo usar la BitBoxApp, por favor utiliza la guía in-app haciendo clic en el signo de interrogación de la esquina superior derecha. `,
    title: "Estas preparado para usar la billetera BitBox."
  }
}, blink$3 = {
  button: "Parpadeo"
}, bootloader$3 = {
  button: "Actualiza ahora el firmware",
  button_install: "Instalar el nuevo firmware ahora",
  progress: "Actualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Actualización completada! Por favor, vuelva a conectar el dispositivo. Esta vez, no toque el botón."
}, button$7 = {
  abort: "Cancel",
  back: "Atrás",
  buy: "Compra",
  changepin: "Cambia contraseña del dispositivo",
  check: "Comprobar la copia de seguridad",
  continue: "Continua",
  copy: "Copia",
  create: "Crea",
  dismiss: "Descartar",
  done: "Hecho",
  download: "Descarga",
  hiddenwallet: "Crea el monedero oculto",
  next: "Siguiente",
  ok: "OK",
  previous: "Anterior",
  receive: "Recibe",
  restore: "Restaurar",
  select: "Selecciona",
  send: "Envía",
  unlock: "Desbloquea",
  update: "Actualiza",
  upgrade: "Actualizar"
}, buy$4 = {
  exchange: {
    bankTransfer: "Transferencia bancaria",
    bestDeal: "La mejor oferta",
    creditCard: "Tarjeta de crédito",
    fast: "Rápido",
    fee: "tarifa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferencia bancaria: {{fee}}%%.",
          creditDebitCard: "Tarjeta de crédito/débito: {{fee}}%%.",
          learnMore: "Más información sobre Moonpay",
          title: "Tasas"
        },
        fullCurrenciesList: "Consulte aquí la lista completa de monedas",
        payment: {
          asteriskText: "* No disponible para residentes en EE.UU.",
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            pix: "PIX (transacciones BR sólo en Brasil)",
            sepa: "SEPA y SEPA Instant (sólo transacciones en euros en países SEPA)",
            uk: "Pagos rápidos en el Reino Unido (transacciones en GBP sólo en el Reino Unido)"
          },
          creditDebitCard: "Tarjeta de crédito/débito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa y Maestro"
          },
          learnMore: "Ver más detalles sobre los métodos de pago",
          title: "Formas de pago"
        },
        supportedCurrencies: "Compatible con las principales monedas fiduciarias: USD, EUR, CHF y más."
      },
      pocket: {
        fees: {
          info: "Transferencia bancaria: {{fee}}% ",
          title: "Tasas"
        },
        learnMore: "Más información sobre Pocket",
        payment: {
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            sepa: "SEPA y SEPA Instant (sólo transacciones en euros en países SEPA)",
            sic: "Swiss Interbank Clearing (transacciones en CHF solo en CH/LI)",
            uk: "UK Faster Payments (transacciones en GBP sólo en el Reino Unido)"
          },
          bankTransferReccuring: "¿Cómo configurar compras recurrentes con una orden permanente? ",
          title: "Formas de pago"
        },
        supportedCurrencies: "Admite monedas europeas: EUR, GBP y CHF. ",
        verification: {
          info: "Solo requiere verificación de identidad por encima de los puntos de inicio diarios y anuales. ",
          link: "Encuentre los puntos de inicio actuales aquí ",
          title: "Verificación de identidad "
        }
      },
      region: {
        title: "Seleccione la región en la que está registrada su cuenta bancaria para ver las opciones disponibles."
      }
    },
    noExchanges: "Lo sentimos, no hay intercambios disponibles en esta región.",
    region: "Región",
    selectRegion: "No especificado",
    title: "Comprar {{nombre}}"
  },
  info: {
    continue: "Acepta y continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nos asociamos con MoonPay para ofrecerte una forma sencilla de comprar {{name}} directamente con BitBoxApp. Con unos pocos clics.  ",
        "MoonPay es una plataforma que hace fácil y rápida la compra de {{name}} en más de 160 países."
      ],
      payment: {
        details: "Puedes comprar {{name}} inmediatamente a través de MoonPay con los siguientes métodos de pago. Los pedidos con tarjeta de crédito o débito son inmediatos y prácticos, pero más caros debido al mayor riesgo de retrocesos de cargos a tarjetas. Recomendamos utilizar la opción de transferencia bancaria para grandes cantidades. La tarifa mínima es de 4 EUR.",
        footnote: "Tenga en cuenta que los tipos de cambio de MoonPay pueden diferenciarse de los utilizados en BitBoxApp, lo que se nota en cantidades ligeramente diferentes.",
        table: {
          "1_description": "Tarifa baja, puede tardar 3 días laborales",
          "1_method": "Transferencias bancarias (SEPA)",
          "2_description": "Tarifas altas pero inmediato y rápido",
          "2_method": "Tarjetas de crédito & débito",
          description: "Descripción",
          fee: "Comisión",
          method: "Metodo"
        },
        title: "Métodos de pago y tarifas"
      },
      privacyPolicy: "MoonPay política de privacidad",
      protection: {
        description: "BitBoxApp no ​​recopila ningún dato al comprar {{name}}, los fondos entrantes se tratan como una transacción normal. MoonPay necesita recoger algunos datos personales para operar. Su Política de privacidad explica en detalle cómo se manejan esos datos.",
        descriptionGeneric: "BitBoxApp no recopila ningún dato cuando se compra {{name}}, los fondos entrantes se tratan como una transacción normal. Sin embargo, las bolsas asociadas necesitan recopilar cierta información para operar. Consulta sus respectivas políticas de privacidad para ver con más detalle cómo se gestionan los datos.",
        title: "Protección de Datos"
      },
      security: {
        description: `Cuando compras {{name}} por MoonPay, utilizas un servicio externo. Este servicio está fuera del alcance de la modelación de riesgos de seguridad BitBox02 y depende de la seguridad y protección del entorno en el que se ejecuta el software BitBoxApp.

`,
        descriptionGeneric: "Cuando compras {{name}} a través de una casa de cambio asociada, estás utilizando un servicio externo. Este servicio está fuera del alcance del modelo de amenazas de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp.",
        link: "Modelación de riesgos",
        title: "Modelo de seguridad"
      },
      title: "Bienvenido. Estas en el sitio correcto para comprar {{name}}"
    },
    next: "Siguiente",
    selectLabel: "Elige tu cuenta",
    selectPlaceholder: "Seleccione una moneda",
    skip: "No mostrar de nuevo",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Política de privacidad de Pocket",
      p1: "La BitBoxApp no recoge ningún dato al comprar bitcoin, los fondos entrantes se tratan como una transacción normal. Pocket necesita recoger algunos datos personales para funcionar. Su Política de Privacidad explica en detalle cómo se manejan esos datos.",
      title: "Protección de datos"
    },
    kyc: {
      link: "Preguntas más frecuentes de Pocket",
      p1: "Pocket intenta reducir al mínimo los requisitos de identificación. Para compras inferiores a 950 EUR (1000 CHF) al día, no se requieren documentos adicionales. Para compras superiores a esta cantidad, tendrás que programar una llamada con Pocket para completar el proceso KYC/AML necesario.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puedes comprar bitcoin instantáneamente con Pocket a través de una transferencia bancaria SEPA. La comisión es del 1,5% y el bitcoin se deposita en su BitBox lo antes posible después de que Pocket reciba la transferencia bancaria (normalmente en el mismo día).",
      p2: "Tenga en cuenta que los tipos de cambio de Pocket pueden diferir de los utilizados en la BitBoxApp, dando lugar a importes ligeramente diferentes.",
      title: "Formas de pago y tasas"
    },
    previousTransactions: "El historial de transacciones de esta cuenta no está vacío. Compartir esta cuenta hará que todas sus transacciones pasadas y futuras sean visibles para Pocket. ¿Proceder de todos modos?",
    security: {
      link: "Modelo de amenazas a la seguridad BitBox02",
      p1: "Cuando compras bitcoin a través de Pocket, estás utilizando un servicio externo. Este servicio está fuera del alcance del modelo de amenaza de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp. Sin embargo, trabajamos juntos para mejorar la seguridad utilizando un mecanismo de autenticación de dos factores para verificar la dirección a la que estás recibiendo.",
      title: "Modelo de seguridad"
    },
    usedAddress: "La dirección {{address}} ya ha sido utilizada, por favor comience de nuevo con una nueva dirección.",
    verifyBitBox02: "Compruebe que la dirección que ha recibido por correo electrónico coincide con la que aparece en su Bitbox. Si es posible, debería abrir el correo electrónico en un segundo dispositivo para mayor seguridad. ",
    welcome: {
      p1: "Nos asociamos con Pocket para ofrecerte una forma sencilla de comprar bitcoin directamente dentro de la BitBoxApp. Es sólo un par de clics.",
      p2: "Pocket es una plataforma suiza que facilita y agiliza la compra de bitcoins en la mayor parte de Europa (en cualquier lugar donde se admitan transferencias bancarias SEPA).",
      p3: "Con Pocket, también puede hacer compras periódicas a través de órdenes bancarias permanentes, por lo que puede hacer DCA (dollar-cost averaging) con facilidad.",
      title: "Bienvenido a su ventanilla única para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
}, changePin$3 = {
  newTitle: "Nueva contraseña del dispositivo",
  oldLabel: "Contraseña actual del dispositivo"
}, chart$4 = {
  dataMissing: "Recopilando tus datos históricos. Permanece atento.",
  dataOldTimestamp: "Actualización de los tipos de cambio históricos. El gráfico no muestra datos después de {{time}}.",
  dataUpdating: "actualizando datos",
  filter: {
    all: "Todo",
    month: "Mes",
    week: "Semana",
    year: "Año"
  }
}, checkSDcard$3 = "comprobando tarjeta micro SD", clickHere$3 = "Haz clic aquí.", confirm$5 = {
  abortInfo: "Toque para ",
  abortInfoRedText: "Cancel",
  approveInfo: "Mantenga 4+ segundos para ",
  approveInfoGreenText: "confirma",
  info: "Continua en tu Bitbox",
  infoWhenPaired: "Primero en el móvil sincronizado y luego tu BitBox"
}, confirmOnDevice$3 = "Por favor confirma en tu dispositivo.", connectKeystore$3 = {
  promptNoName: "Por favor conecta tu BitBox02 para continuar",
  promptWithName: 'Por favor, conecta tu BitBox02 llamada "{{nombre}}" para continuar '
}, darkmode$3 = {
  toggle: "Modo oscuro"
}, device$3 = {
  appUpradeRequired: "Tu BitBox no es compatible con esta aplicación de escritorio. Por favor descarga e instale la última versión.",
  keystoreConnected: "Billetera conectada"
}, deviceLock$3 = {
  button: "Activa autorización de dos factores (2FA)",
  condition1: "¿Tienes una copia de seguridad?",
  condition2: "¿Funciona la verificación de la aplicación móvil?",
  condition3: "2FA DESACTIVA las copias de seguridad y la sincronización con las aplicaciones móviles. El dispositivo debe ser REINICIADO para salir de 2FA!",
  confirm: "Activa autorización de dos factores (2FA)",
  title: "Activa autorización de dos factores (2FA)"
}, deviceSettings$3 = {
  backups: {
    manageBackups: {
      description: "Crea o verifica la copia de seguridad de tu tarjeta microSD."
    },
    showRecoveryWords: {
      description: "Mostrar y verificar palabras de recuperación."
    },
    title: "Copias de seguridad"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp comprueba si tu dispositivo es auténtico."
    },
    deviceName: {
      description: "Cambia el nombre de tu dispositivo."
    },
    rootFingerprint: {
      description: "La huella raíz es un identificador único para la billetera actualmente en uso. Puede ayudarte a distinguir entre diferentes billeteras si utilizas frases de contraseña."
    },
    securechip: {
      description: "El modelo del chip seguro."
    },
    title: "Información del dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Restablece tu dispositivo a los valores de fábrica. ¡Esto borra la billetera de tu BitBox02!",
      title: "Restablecimiento de fábrica"
    },
    goToStartupSettings: {
      description: "Entra en el bootloader de la BitBox02. Puedes activar el hash del firmware desde aquí."
    },
    passphrase: {
      description: "",
      title: "Contraseña"
    }
  },
  firmware: {
    firmwareVersion: "Versión del firmware",
    newVersion: {
      label: "Versión disponible"
    },
    title: "Firmware",
    upToDate: "Tu dispositivo está actualizado.",
    upgradeAvailable: "Nueva actualización disponible",
    version: {
      label: "Versión"
    }
  },
  hardware: {
    attestation: {
      false: "Error en la comprobación de autenticidad",
      label: "Comprobación de autenticidad",
      true: "Su BitBox02 es auténtico"
    },
    sdcard: {
      false: "No insertado",
      label: "Tarjeta micro SD",
      true: "Insertado"
    },
    securechip: "Chip de seguridad",
    title: "Hardware"
  },
  loading: "Recuperando información del dispositivo ...",
  pairing: {
    lock: {
      false: "Desactivado",
      label: "Autorización de dos factores (2FA)",
      true: "Activado"
    },
    mobile: {
      false: "Cerrado",
      label: "Aplicación móvil",
      true: "Abre"
    },
    status: {
      false: "No sincronizado",
      label: "Estado",
      true: "Sincronizado"
    },
    title: "Sincronización"
  },
  secrets: {
    manageBackups: "Administrar copias de seguridad",
    title: "Seguridad"
  }
}, deviceTampered$3 = "¿Tu BitBox ha sido suministrado con una contraseña de recuperación? Si es así, detenga el proceso de configuración y ponte en contacto con el servicio de asistencia inmediatamente. Shift nunca te dará una billetera confeccionado ni hará recomendaciones de contraseña.", dialog$4 = {
  cancel: "Cancela",
  confirm: "Confirma",
  confirmTitle: "Confirmación"
}, error$4 = {
  accountAlreadyExists: "La cuenta ya existe.",
  accountLimitReached: "No se puede añadir la cuenta. El número máximo de cuentas para esta moneda ha sido alcanzado.",
  aoppCallback: "Ha habido un error entregando la dirección a{{host}}.",
  aoppInvalidRequest: "Solicitud inválida.",
  aoppNoAccounts: "No hay cuentas disponibles.",
  aoppSigningAborted: "Solicitud de propiedad de la dirección cancelada.",
  aoppUnknown: "Un error desconocido ha ocurrido.",
  aoppUnsupportedAsset: "El activo no es soportado.",
  aoppUnsupportedFormat: "No hay cuentas disponibles que soporten el formato de direcciones solicitado.",
  aoppUnsupportedKeystore: "El dispositivo conectado no puede firmar mensajes para este activo.",
  aoppVersion: "Versión desconocida.",
  wrongKeystore: "Se ha conectado una billetera incorrecta. Por favor, asegúrese de insertar el dispositivo correcto que coincida con esta cuenta.",
  wrongKeystore2: " Si utiliza la frase de contraseña opcional, asegúrese de haber introducido la frase de contraseña correcta para la cuenta."
}, fiat$5 = {
  default: "predeterminado",
  setDefault: "Establecer {{code}} predeterminado",
  title: "Monedas"
}, footer$5 = {
  appVersion: "Versión de app:"
}, generic$4 = {
  enabled_false: "Desactivado",
  enabled_true: "Activado"
}, genericError$3 = "Ocurrió un error. Si observa algún problema, por favor reinicie la aplicación.", goal$3 = {
  buttons: {
    create: "Crear una billetera nueva",
    restore: "Restaurar una billetera desde una copia de seguridad"
  },
  paragraph: "Por favor, selecciona una de las siguientes opciones:",
  step: {
    1: {
      title: "Información de seguridad"
    },
    2: {
      description: "Establece una contraseña del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crear una billetera nueva",
      title: "Billetera"
    },
    "3-restore": {
      description: "desde una copia de seguridad",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumen"
    },
    "4-restore": {
      title: "Resumen"
    }
  }
}, guide$4 = {
  accountDescription: {
    text: "Este es el resumen de tu cuenta. Muestra las transacciones entrantes y salientes. El saldo se muestra para cada cuenta por separado. Consulta la guía de configuración para obtener más información sobre los diferentes tipos de cuentas.",
    title: "¿Qué me muestra esta página?"
  },
  accountFiat: {
    text: "Sí. Puedes hacer clic en cualquier ticker para rotar a través de varias monedas fiat. También puedes cambiar la lista de monedas en la configuración.",
    title: "¿Puedo mostrar otros tipos de cambio?"
  },
  accountIncomingBalance: {
    text: '"Entrante" resume los importes transferidos pero que todavía no han sido confirmados por la red.',
    title: '¿Qué significa "Entrante"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: `Cada xpub está relacionada con el "Tipo" mostrado: tanto "Native Segwit (bech32)", "Wrapped Segwit" como "Taproot" (Bitcoin only). Estos son tipos de script utilizados por {{coinName}}. La BitBoxApp las combina, soportando múltiples tipos de script en la misma cuenta. Porque cada tipo de script proporciona una xpub diferente, hay múltiples xpubs por cuenta.

Si constantemente recibe en la dirección por defecto (Native Segwit), solo necesita la "bech32" xpub. Sin embargo, si también recibe fondos en "Wrapped Segwit" o "Taproot", también necesitara utilizar las claves públicas extendidas de "Wrapped Segwit" y "Taproot" respectivamente.`,
      title: "¿Porqué hay múltiples xpubs?"
    },
    privacy: {
      text: `Para esta cuenta específica, la clave pública extendida revela todo el historial financiero, el balance en la cuenta, y todas las transacciones futuras. Pero el xpub no permite que nadie gaste tus monedas.

Si le proporcionas una xpub a alguien, deberás tener en cuenta que esa persona o empresa pueden ver otras transacciones de la misma cuenta. Por lo tanto, es una buena idea utilizar esa cuenta solamente con ese propósito y guardar otros fondos en cuentas diferentes.`,
      title: "¿Necesito guardar mi xpub en secreto?"
    },
    verify: {
      text: "Si, siempre es una buena idea hacer una doble verificación de tu xpub. Si alguien va a generar direcciones a partir de esta xpub para mandarte dinero, esto es especialmente importante. Tendrá que verificarla en el dispositivo para asegurarse que esa xpub le pertenece; en caso contrario, todos los fondos podrían ir a direcciones incorrectas.",
      title: "¿Necesito verificar la xpub en el dispositivo?"
    },
    xpub: {
      text: `Una clave pública extendida (xpub) es una clave raíz de la cual se obtienen todas las direcciones de recepción de una cuenta.
Se proporciona para uso avanzado e interoperabilidad con billeteras watch-only, como Electrum o Sentinel. Si recibe otro tipo de direcciones, por favor importe todos los formatos de xpub en la billetera watch-only para poder visualizar todas las monedas.
Tenga en cuenta que, las billeteras de terceros puede que no soporten Taproot xpubs todavía.`,
      title: "¿Qué es una clave pública extendida?"
    }
  },
  accountRates: {
    text: "Los tipos de cambio se actualizan cada minuto desde CoinGecko.",
    title: "¿Qué tipo de cambio se utiliza?"
  },
  accountReload: {
    text: "No hace falta. Toda la información de las transacciones se actualiza automáticamente.",
    title: "¿Puedo recargar el historial de transacciones?"
  },
  accountSendDisabled: {
    text: 'El botón "Enviar" se activa cuando tu saldo es mayor que cero.',
    title: "¿Por qué no puedo enviar ningún {{unit}}?"
  },
  accountSummaryAmount: {
    text: `La cantidad total es la suma de todas tus cuentas criptográficas. Los tipos de cambio se consiguen de coingecko.com.

Nota: Si usas MyEtherWallet para tokens no admitidos en BitBoxApp, no se incluirán en la cantidad que se muestra.`,
    title: "¿Cómo se calcula la suma total?"
  },
  accountSummaryDescription: {
    text: "Aquí puede ver el rendimiento de tu billetera a lo largo del tiempo. Debajo del gráfico se muestra un resumen de sus cuentas criptográficas individuales.",
    title: "¿Qué me muestra esta página?"
  },
  accountTransactionAttributesBTC: {
    text: `Tamaño virtual: se utiliza para determinar la tarifa de la red. Habrás ahorrado con éxito en comisiones si son más pequeñas que la transacción.
Tamaño: Tamaño real de la transacción en bytes cuando se presenta por entregas de acuerdo con la blockchain por debajo.
Peso: Introducido con Segwit, es una nueva métrica para evaluar los tamaños de transacción y bloque. Cada byte testigo segregado cuenta como uno, todo lo demás como cuatro unidades de peso. En lugar de un megabyte en tamaño real, el límite de tamaño de bloque ahora es de cuatro millones de unidades de peso.`,
    title: "Detalles de la transacción relacionados con Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: `Confirmaciones: Cuando tu transacción se transmita por primera vez, no se confirmará. Tienes que esperar a que un minero lo incluya en un bloque, después de lo cual tendrá 1 confirmación. Desde ese momento, cada bloque transmitido en la red agregará otra confirmación a tu transacción. En general, los comerciantes y otros actores de la red solo aceptarán transacciones con confirmaciones de entre 3-6 antes de considerar la transacción como liquidada.
ID de transacción: un número de identificación único que se puede usar para buscar una transacción en un explorador de bloques.
Cuota: los mineros reciben una tarifa de transacción como incentivo para incluir las transacciones en los bloques que explotan. Para obtener más información, haz clic en el botón enviar.`,
    title: "¿Cuál es la información que se muestra en los detalles de la transacción?"
  },
  accountTransactionConfirmation: {
    text: "Esta es una transacción que se ha transmitido a la red y espera ser confirmada.",
    title: "¿Qué es una transacción pendiente?"
  },
  accountTransactionLabel: {
    text: `Es la dirección donde recibiste o enviaste tus monedas. 
Una dirección codifica cómo (y por lo tanto, por quién) se pueden gastar las monedas.`,
    title: "¿Qué dirección se muestra para cada transacción?"
  },
  accountTransactionTime: {
    text: "El tiempo que la transacción ha sido confirmada en el blockchain.",
    title: "¿Qué hora se muestra?"
  },
  accounts: {
    howManyAccounts: {
      text: `Bitcoin y Litecoin pueden tener una cantidad arbitraria de cuentas. Después de cinco cuentas, sólo se puede añadir otra cuenta si se ha utilizado la anterior. 
Otras monedas pueden tener un máximo de cinco cuentas.`,
      title: "¿Cuántas cuentas puedo crear?"
    },
    howtoAddTokens: {
      text: 'Tokens que utilicen el estándar ERC20 están conectados a una cuenta específica de Ethereum. Para permitir o inutilizar un token en particular, abra la ventana de "Administrar cuentas", despliegue su cuenta Ethereum y active o desactive su token deseado.',
      title: "¿Cómo puedo añadir tokens adicionales?"
    },
    moveFunds: {
      text: "Si. Pero porque las cuentas son independientes, necesitará enviar los fondos utilizando una transacción normal.",
      title: "¿Puedo mover fondos entre cuentas?"
    },
    recoverAccounts: {
      text: "Si. La BitBoxApp crea cuentas utilizando estándares muy establecidos compatibles con la mayoría de otras carteras crypto.",
      title: "¿Puedo recuperar mis cuentas de otras carteras?"
    },
    whatAreAccounts: {
      text: "Su cartera puede administrar cuentas de la misma moneda. Las cuentas son útiles cuando se quiere guardar los fondos de forma separada.",
      title: "¿Qué son las cuentas?"
    },
    whatIsRememberWallet: {
      text: `Activando "Recordar billetera" podrás ver las cuentas de esta billetera en la BitBoxApp incluso cuando la BitBox02 no esté conectada. Esto te permite comprobar tu saldo y portafolio siempre que quieras. La BitBox02 necesita estar conectada y desbloqueada para enviar o recibir monedas.

Desactivar "Recordar billetera" requiere que conectes la BitBox02 respectiva (o frase de contraseña) para ver esas cuentas en la BitBoxApp.`,
      title: '¿Qué ocurre cuando activo/desactivo "Recordar billetera"?'
    },
    whyIsThisUseful: {
      text: 'Las cuentas son geniales para la gestión de fondos para diferentes personas o propósitos porque están separados. También puede compartir la "clave pública extendida" de una cuenta sin revelar nada sobre las otras cuentas. Esto permite recibir fondos repetidamente sin reutilizar direcciones, tanto para recibir su salario o comprar crypto de forma habitual.',
      title: "¿Porqué es esto útil?"
    }
  },
  appendix: {
    link: "¡Contacta con nosotros!",
    text: "¿Otra pregunta?"
  },
  backups: {
    check: {
      text: '"Comprobar copia de seguridad" te permite verificar que tienes una copia de seguridad operativa correspondiente a tu monedero actual. También se puede usar para verificar que todavía tienes la contraseña de recuperación correcta. Puedes verificar tu contraseña de recuperación principal o tu contraseña de recuperación oculta.',
      title: "¿Qué es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: "No, pero necesitas tu contraseña de recuperación para obtener el monedero de la semilla guardada.",
      title: "¿Puedo encriptar la copia de seguridad?"
    },
    howOften: {
      text: `La copia de seguridad se genera automáticamente cuando se crea un nuevo monedero. Sólo tienes que hacer una nueva copia de seguridad si tu tarjeta micro SD está perdida o dañada, o si quieres usar varias tarjetas micro SD como copias de seguridad.
No es necesario crear nuevas copias de seguridad después de la actividad de transacción. Todos tus datos de transacción pueden ser recreados por tu única copia de seguridad que se generó automáticamente para ti.`,
      title: "¿Con qué frecuencia tengo que hacer una copia de seguridad?"
    },
    whatIsABackup: {
      text: "Esto es una copia de la semilla en una tarjeta micro SD. La semilla junto con tu contraseña de recuperación genera tu monedero.",
      title: "¿Qué es una copia de seguridad?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Comprobar copia de seguridad' te permite verificar que tienes una copia de seguridad funcional y que corresponde a tu monedero actual.",
      title: "¿Qué es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: 'No. Por favor mantén la microSD en un lugar seguro porque contiene la semilla para recuperar tu monedero sin encriptar. Si deseas proteger con contraseña tu semilla, puedes activar una frase de contraseña (passphrase) opcional en los ajustes, debajo de "Ajustes del dispositivo". ',
      title: "¿Puedo encriptar la copia de seguridad?"
    },
    whatIsABackup: {
      text: "Es una copia de la semilla en la tarjeta microSD.",
      title: "¿Qué es una copia de seguridad?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Cuando 2FA está habilitado, todas las transacciones deben aprobarse en el teléfono móvil sincronizado para poder gastar monedas. Técnicamente, se envía un número encriptado de un solo uso a la aplicación móvil, donde se descifra y se devuelve al BitBox al presionar el botón Aceptar. Esta comunicación con el dispositivo se realiza a través del canal entre el teléfono móvil y esta aplicación de escritorio establecida durante la sincronización.

Asegúrate de hacer una copia de seguridad de tu monedero y sincroniza la aplicación móvil antes de habilitar 2FA. Una vez habilitado, las sincronizaciones entre la ranura micro SD y las aplicaciones móviles se deshabilitan. Se pueden volver a habilitar reiniciando el BitBox, algo que borrará el dispositivo.`,
      title: "¿Cómo funciona la autorización de dos factores (2FA)?"
    },
    disable2FA: {
      text: `Para deshabilitar 2FA, debes restablecer su BitBox y luego restaurar el monedero desde su copia de seguridad. Asegúrate de que todavía tienes la tarjeta micro SD con la copia de seguridad y que aún recuerdas la contraseña de recuperación. Luego pulsa 'Restablecer dispositivo'. Establece una nueva contraseña de dispositivo y elija 'O restaurar una copia de seguridad'. Selecciona la copia de seguridad que has hecho del monedero, haz clic en "Restaurar" e ingresa la contraseña de recuperación que utilizaste al crear el monedero.`,
      title: "¿Cómo puedo desactivar la autorización de dos factores (2FA)?"
    },
    ejectBitbox: {
      text: "Puedes desconectar el BitBox en cualquier momento sin tener que expulsarlo primero.",
      title: "¿Cómo puedo expulsar el BitBox?"
    },
    ejectSD: {
      text: "Puedes retirar la tarjeta micro SD de BitBox en cualquier momento siempre que no esté en el proceso de crear o restaurar una copia de seguridad.",
      title: "¿Cómo puedo expulsar la tarjeta micro SD?"
    },
    hiddenWallet: {
      text: "Es un segundo monedero en el mismo dispositivo protegido por una contraseña de dispositivo y una contraseña de recuperación diferentes, que puedes usar para una negación creíble. La misma semilla de copia de seguridad se usa para tu monedero normal y oculto, por lo que no se requiere una copia de seguridad adicional.",
      title: "¿Qué es un monedero oculto?"
    },
    legacyHiddenWallet: {
      text: "Primero haz clic en el botón de abajo (disponible si el BitBox está desbloqueado con la contraseña del dispositivo principal y la 2FA está desactivada), luego vuelve a conectar su Bitbox y desbloquea con la contraseña oculta del dispositivo.",
      title: "¿Cómo accedo el monedero oculto heredado?"
    },
    pairing: {
      text: "Después de haber descargado nuestra aplicación móvil para iOS o Android, escanea el código QR mostrado, que establece un canal seguro entre la aplicación móvil y esta aplicación. Una vez escaneado, sige las instrucciones en la aplicación móvil.",
      title: "Cómo sincronizo de forma segura con mi teléfono"
    }
  },
  cointracking: {
    text: `Haga click en el botón "Exportar" y abra la carpeta de descargas donde encontrará el CSV exportado.
A continuación haga click en el enlace de abajo, cargue su archivo BitBox CSV e importe los datos para ser utilizados por su gestor de CoinTracking y crear sus informes fiscales.`,
    title: "¿Cómo importar mis transacciones a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Más información sobre el control de autenticidad"
      },
      text: "La BitBoxApp realiza una comprobación de atestación en la BitBox02 para verificar si el dispositivo es genuino. La comprobación se realiza localmente y no se conecta a ningún servidor.",
      title: "¿Cómo funciona el control de autenticidad?"
    },
    name: {
      text: "Este es el nombre de tu wallet y de la copia de seguridad. El nombre se utiliza para futuras copias de seguridad y se puede utilizar para ayudar a distinguir entre diferentes billeteras. Se puede cambiar en cualquier momento, pero ten en cuenta que las copias de seguridad realizadas antes del cambio seguirán utilizando el nombre anterior.",
      title: "¿Para qué se utiliza el nombre BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Más información sobre el chip seguro"
      },
      text: "Esta información muestra el número de modelo del chip seguro, el chip más actualizado es ATECC608B con características de seguridad mejoradas en comparación con los modelos anteriores.",
      title: "¿Por qué mostrar el modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Puedes dar la dirección a otras personas para que te envíen monedas. Solo tienes que asegurarte de que envíen a la dirección correcta.",
      title: "¿Qué hago con una dirección?"
    },
    addressChange: {
      text: "En cuanto se utilice una dirección en una transacción, se agrega una nueva dirección a la lista para reemplazarla. Siempre habrá 20 direcciones no utilizadas disponibles en la lista.",
      title: "¿Cuándo cambian las direcciones?"
    },
    addressFormats: {
      text: `Por defecto, el tipo de dirección es Native Segwit. Esta dirección es ampliamente adoptada por otras carteras/exchanges y proporciona las mejores comisiones para las transacciones del día a día. En cambio, se puede elegir enviar a Taproot (Bitcoin Only), que es el último tipo de direcciones, pero puede que no sea ampliamente soportada todavía. Como alternativa, si tiene complicaciones enviando a Native Segwit (el tipo de dirección por defecto), puede intentar cambiar al antiguo tipo de dirección Wrapped Segwit que puede ser compatible con mas carteras/exchanges.
`,
      title: '¿Cuándo utilizar "cambio de tipo de dirección"?'
    },
    howVerify: {
      text: `Para la BitBox01, haz clic en el icono BitBox en la barra lateral de la izquierda y revisa las opciones de emparejamiento. Esta guía se actualizará y podrás seguir las nuevas instrucciones desde allí.
Para la BitBox02, puedes verificar las direcciones directamente en tu dispositivo durante el proceso de envío y recepción. `,
      title: "¿Cómo puedo verificar una dirección de forma segura?"
    },
    plugout: {
      text: "No, una vez ha enviado las monedas a su dirección de BitBox, no tendrá que dejar su BitBox enchufada. Puede desconectar su BitBox cuando quiera.",
      title: "¿Necesito dejar conectada mi BitBox mientras recibo?"
    },
    why20: {
      text: 'Durante la inicialización, la app genera direcciones derivadas de tu semilla para ver si han recibido fondos. Como la app puede generar un número casi infinito de direcciones, se podría pasar años determinando el saldo. Para limitar esta búsqueda se para después de encontrar 20 direcciones que nunca han recibido fondos. Esto es un "intervalo límite" y  20 es el estándar de-facto aunque el número es arbitrario. Estas son las 20 direcciones que puedes escoger.',
      title: "¿Por qué solo 20 direcciones?"
    },
    whyMany: {
      text: "Por razones de privacidad y seguridad, nunca debes utilizar la misma dirección dos veces. Haz clic en 'Siguiente' para obtener una nueva dirección para un propósito diferente. Puedes generar hasta 20 direcciones a la vez. Todas las direcciones se derivan de tu semilla única de la copia de seguridad.",
      title: "¿Por qué hay tantas direcciones?"
    },
    whyVerify: {
      text: "Una de las razones por las que comprar una cartera de hardware como la BitBox es que no debes confiar en tu ordenador debido a sus numerosos vectores de ataque. No debes confiar en que tu ordenador genere y muestre direcciones auténticas. El botón para verificar la dirección de manera segura hace que BitBox envíe la dirección a un teléfono móvil sincronizado, desde el cual también puedes escanear y verificar el código QR.",
      title: "¿Por qué debo verificar la dirección de forma segura?"
    }
  },
  send: {
    change: {
      text: "El cambio será devuelto a una dirección Taproot si al menos tiene un UTXO Taproot. Si utiliza coin control, el cambio será devuelto a una dirección Taproot si al menos hay un Taproot UTXO entre los UTXOs seleccionados. En el resto de casos, el cambio será devuelto a una dirección Native Segwit.",
      title: "¿Cómo se determina la dirección de cambio?"
    },
    fee: {
      text: `La tarifa se basa en el tamaño de los datos de la transacción y no en su cantidad. Los objetivos de tiempo de la tarifa se calculan mediante el algoritmo de estimación de tarifa de Bitcoin Core para cada prioridad de red que elijas. Serán mostrados si tienen un valor diferente del siguiente objetivo.
Económico: 24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)
Bajo: 12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)
Normal: 6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)
Alto: 2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)
(Un bloque de Bitcoin tarda un promedio diez minutos para que se mine (2.5 minutos en Litecoin), y la congestión de la red puede hacer variar considerablemente los períodos arriba mencionados).`,
      title: "¿Cómo se determina la comisión?"
    },
    plugout: {
      text: "No, una vez ya ha realizado la transacción, no necesita dejar su BitBox conectada. Puede desconectar su BitBox cuando quiera.",
      title: "¿Necesito dejar mi BitBox conectada mientras envío?"
    },
    priority: {
      text: "Cuanto mayor sea la comisión que estás dispuesto a pagar, más rápido se confirmará tu transacción por la red.",
      title: "¿Cuál es la prioridad de la red?"
    },
    revert: {
      text: `Una vez que se firma y se envía una transacción (que se transmite a la red), ya no puede revertirse. ¡Verifica las transacciones (también la comisión) correctamente antes de firmar!
Si conoces al destinatario y él o ella está dispuesto a enviarte la misma cantidad de vuelta (menos los cargos por transacción), puedes entonces enviarle una nueva dirección de recepción.`,
      title: "¿Puedo revertir una transacción?"
    },
    whyFee: {
      text: `Las transacciones compiten para ser confirmadas por un minero. Los mineros eligen las transacciones que se incluirán en la blockchain en función de tu tarifa.
Los mineros votan sobre el historial de las transacciones. Dado que no hay un tercero de confianza para imponer un voto por persona (que es el eje central de las blockchains), los mineros votan sobre las transacciones sacrificando un recurso caro como la potencia de cálculo. Como recompensa por su trabajo, pueden reclamar monedas recién creadas y la tarifa de todas las transacciones que incluyeron.`,
      title: "¿Por qué hay una tarifa de red?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Si solo tiene la intención de conectarse a tu nodo cuando esté en la misma red (por ejemplo, la red wifi de tu hogar), entonces es suficiente usar la comunicación de red regular.
En este caso, es recomendable que el servidor Electrum proporcione un certificado TLS para encriptar la comunicación.
Si tu intención es conectarse a tu nodo desde cualquier lugar, usar Tor es la mejor opción. En ese caso, no es necesario ningún certificado TLS.

`,
      title: "Debo usar Clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guía para conectar tu nodo"
      },
      text: "Para el tutorial competo, por favor visita nuestra guía: ",
      title: "¿Como conecto mi BitBoxApp con mi nodo?"
    },
    options: {
      text: `Hay varias opciones para usar su propio nodo, como comprar un dispositivo terminado, construir el tuyo propio o usar Bitcoin Core.
Si quieres conectar tu BitBoxApp a tu nodo, asegúrate de que ejecutas un servidor Electrum. Este es un programa que permite que una app del monedero se comunica con su nodo completo.
Las opciones  incluyencompatibles Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).`,
      title: "¿Qué opciones existen para ejecutar un nodo?"
    },
    tor: {
      text: `Tor significa 'The Onion Router', es un software gratuito y de fuente abierta que ofrece muchos beneficios de privacidad. Es muy útil cuando se usa Bitcoin.
Si tienes la intención de conectarte a su nodo a través de Tor, asegúrate de que Tor esté instalado en tu ordenador y luego activa Tor Proxy en la configuración de BitBoxApp.
En la mayoría de los sistemas operativos, hay dos formas de ejecutar Tor:
1. Tor Browser: descarga y abre el Tor Browser. Esto permitirá que BitBoxApp se conecte a la red Tor configurando el puerto 9150 en la configuración del proxy Tor.
2. Servicio Tor en segundo plano: instala el Tor daemon, que siempre se usa en segundo plano. BitBoxApp puede conectarse configurando el puerto 9050 en la configuración del proxy Tor.

`,
      title: "¿Que es un Tor, Tor proxy y en que puerto lo debería usar?"
    },
    what: {
      text: "Es posible conectar tu wallet a tu propio nodo completo Bitcoin en vez de utilizar los servidores Shift.",
      title: "¿Qué es esto?"
    },
    why: {
      text: `No es necesario ejecutar su propio nodo, pero mejora la privacidad y reduce la necesidad de confiar en los demás.
En primer lugar, significa que estás utilizando Bitcoin de forma más privada, ya que BitBoxApp no ​​se conectará a nuestros servidores para recuperar su historial de transacciones; en su lugar, obtendrá esa información de su propio nodo.
En segundo lugar, ejecutar tu propio nodo significa que tu nodo verifica todas las transacciones por sí mismo, asegurándose de que se cumplan las reglas de consenso.`,
      title: "¿Por qué debería ejecutar mi propio nodo?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" para abreviar) es la unidad más pequeña de Bitcoin. Un Satoshi es la cienmillonésima parte de un bitcoin (0,00000001 BTC). Debe su nombre al creador de Bitcoin, Satoshi Nakamoto.',
      title: "¿Qué es un Satoshi?"
    },
    servers: {
      text: `Esta aplicación se comunica con los servidores de Shift Crypto para buscar actualizaciones, cargar transacciones y enviar información a aplicaciones móviles sincronizadas.
Además, recupera los últimos tipos de cambio de CoinGecko. Todas las conversiones se calculan de forma local lo que significa que no se envían las cantidades que uno tiene a ningún servidor. 
Nota: Para Ethereum y tokens ERC20, utilizamos la API de Etherscan.io`,
      title: "¿Con qué servidores se comunica esta aplicación?"
    }
  },
  title: "Guía",
  toggle: {
    close: "Cerrar la guía",
    open: "Guía"
  },
  trackingModePortfolioChart: {
    text: "En el ordenador de sobremesa, sitúe el cursor sobre el gráfico. En móvil, mantén el dedo sobre el gráfico y arrástralo horizontalmente.",
    title: "¿Cómo ver los valores históricos en el gráfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Debe restablecer el dispositivo y recuperar el mondero desde una copia de seguridad, utilizando la contraseña de recuperación.",
      title: "¿Qué hago si olvido la contraseña del dispositivo?"
    },
    reset: {
      text: "Introduzca una contraseña de dispositivo incorrecta 15 veces. Los últimos intentos requieren mantener pulsado el dispositivo .",
      title: "¿Cómo reinicio el dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `El dispositivo debe parpadear una vez se haya insertado. Asegúrese de que se inserta de la manera correcta. Si tiene problemas, por favor contáctenos a través del siguiente enlace.
La BitBox01 no es soportada en los móviles/celulares. Por favor utilice la BitBoxApp de escritorio para conectar su BitBox01.`,
      title: "Mi dispositivo no está reconocido"
    },
    getDevice: {
      link: {
        text: "Encargue un BitBox"
      },
      text: "Puedes comprar un BitBox en nuestra tienda online:",
      title: "¿Cómo puedo obtener un dispositivo?"
    },
    internet: {
      text: "Sí, se necesita una conexión a Internet para sincronizar el monedero, enviar transacciones y recuperar los últimos tipos de cambio.",
      title: "¿Esta aplicación requiere conexión a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de respaldo (backup)"
      },
      text: "Puede recuperar sus cuentas en un nuevo BitBox o con nuestro centro de copia de seguridad.",
      title: "Perdí mi dispositivo. ¿Ahora qué?"
    },
    useWithoutDevice: {
      text: "Lamentablemente, esto todavía no es posible en este momento.",
      title: "¿Puedo usar la aplicación sin un dispositivo?"
    },
    welcome: {
      text: "Gracias por utilizar esta aplicación creada por Shift Crypto en Suiza. Todavía está en beta y agradecemos cualquier comentario que tenga que compartir. Por favor, de su opinión utilizando el enlace en la parte inferior.",
      title: "¡Bienvenido a la aplicación de BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si estás usando un nuevo teléfono/ordenador con la BitBoxApp, entonces tendrás que conectarte de nuevo a la DApps. A continuación, verá sus monedas en la dapp de nuevo como de costumbre.",
      title: "No veo mis conexiones previas."
    },
    supportedNetworks: {
      text: "Actualmente, sólo Ethereum mainnet es compatible utilizando WalletConnect en la BitBoxApp. Para utilizar otras cadenas compatibles con EVM, por favor utilice la extensión de navegador Rabby wallet.",
      title: "¿Qué redes son compatibles?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect es un protocolo de comunicación para aplicaciones web3. Permite conectarse cómodamente a DApps basadas en Ethereum y billeteras web sin necesidad de utilizar una app de terceros, lo que resulta especialmente útil para los usuarios de Android de la BitBoxApp.",
      title: "¿Qué es WalletConnect?"
    }
  }
}, headerssync$3 = {
  blocksSynced: "{{blocks}} bloques sincronizados"
}, hiddenWallet$3 = {
  info1HTML: "Para fines de negación plausible, se puede crear un monedero oculto basada en una <strong>diferente</strong> combinación de contraseña de recuperación y contraseña del dispositivo.",
  info2HTML: "Defina la contraseña del dispositivo y la contraseña de recuperación que quieres asociar con su monedero oculto a continuación. La contraseña del dispositivo y la contraseña de recuperación deben ser <strong>diferentes</strong> de los que has definido para tu monedero principal.",
  passwordLabel: "Contraseña de recuperación oculta",
  passwordPlaceholder: "Por favor confirma la contraseña de recuperación oculta",
  pinLabel: "Contraseña oculta del dispositivo",
  pinRepeatLabel: "Repita la contraseña del dispositivo oculto",
  pinRepeatPlaceholder: "Por favor confirma la contraseña oculta del dispositivo",
  success: "Monedero oculto creado con éxito. Vuelve a enchufar tu BitBox para desbloquearlo."
}, initialize$3 = {
  create: "Establece contraseña del dispositivo",
  creating: "Configuración de la contraseña del dispositivo ...",
  error: {
    e102: "La contraseña del dispositivo debe constar de al menos 4 caracteres."
  },
  info: {
    description1: "Elije la contraseña de tu dispositivo. Esto se utilizará para desbloquear su BitBox.",
    description2: "Puedes usar números, letras y símbolors. Las contraseñas largas ofrecen mayor seguridad.",
    description3: "Si pierdes la contraseña del dispositivo, tendrás que restablecer tu dispositivo y recuperar la copia de seguridad de su monedero.",
    subtitle: "Ahora configurará la contraseña de su dispositivo.",
    title: "Iniciando su dispositivo"
  },
  input: {
    label: "Contraseña del dispositivo",
    labelRepeat: "Repita la contraseña del dispositivo",
    placeholderRepeat: "Por favor confirma la contraseña del dispositivo"
  }
}, invalidFormat$3 = "Formato inválido", language$4 = {
  title: "Selecciona el idioma"
}, legacyhiddenwallet$3 = {
  disable: "Desactiva monedero oculto heredado",
  enable: "Activa monedero oculto heredado",
  successDisable: "Se desactivó con éxito el legado del monedero oculto.",
  successEnable: "El monedero oculto heredado se habilitó con éxito. Vuelva a enchufar su BitBox e ingresa la contraseña del dispositivo oculto para acceder al monedero oculto heredado."
}, loading$3 = "cargando…", manageAccounts$2 = {
  accountHidden: "Esta cuenta ha sido ocultada de tus cuentas de sólo vigilancia. Para volver a verla, conecta tu BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nombre de cuenta",
  noAccounts: "No se han encontrado cuentas",
  settings: {
    hideTokens: "Ocultar tokens",
    showTokens: "Mostrar tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Añadir y mostrar/ocultar cuentas",
  title: "Administrar cuentas",
  watchAccount: "Cuenta de vigilancia",
  watchAccountDescription: "Esta cuenta forma parte de tus cuentas de vigilancia. Puedes ocultarla de tus cuentas de solo vigilancia utilizando el conmutador."
}, mobile$3 = {
  usingMobileDataWarning: `Uso de datos móviles: esta aplicación puede descargar hasta unos cientos de megabytes de datos de blockchain después de desbloquear una cuenta. Por favor, conéctate a una red Wi-Fi para evitar el uso de datos móviles. Después de descartarlo, este mensaje no se mostrará nuevamente.

`
}, newSettings$2 = {
  about: {
    appVersion: {
      title: "Versión de la aplicación"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloquea el acceso a la aplicación con bloqueo de pantalla/huella dactilar.",
      title: "Bloqueo de pantalla"
    },
    coinControl: {
      description: ""
    },
    customFees: {
      description: "Le permite introducir su propia tarifa al enviar."
    },
    torProxy: {
      description: "Conéctate a través de Tor para mejorar la privacidad."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Estas monedas adicionales se pueden cambiar a través de la página de su cuenta.",
      title: "Divisas activas"
    },
    darkmode: {
      description: "Ver la BitBoxApp en modo oscuro."
    },
    defaultCurrency: {
      description: "Selecciona tu moneda predeterminada",
      title: "Moneda predeterminada"
    },
    enableWallet: {
      description: "Deshabilitar tu cuenta significa que no aparecerá en la barra lateral ni en la billetera. Siempre puedes volver a activarla desde aquí. Las monedas de esta cuenta no se verán afectadas y permanecerán seguras.",
      title: "Activar/desactivar billetera"
    },
    hideAmounts: {
      description: "Muestra un conmutador para ocultar tu saldo y los importes para mejorar tu privacidad cuando utilices la aplicación en público.",
      hideAmounts: "Ocultar importes",
      showAmounts: "Mostrar importes",
      title: "Permitir ocultar importes"
    },
    language: {
      description: "Qué idioma quieres que utilice la BitBoxApp.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Recuerde la billetera",
      warning: "Esto eliminará tu billetera recordada. Para verlo de nuevo, necesitará conectar la BitBox02 para esta billetera. Las monedas de esta billetera no se verán afectadas. ¿Desea continuar?",
      warningTitle: "Desactivar recuerde la billetera"
    },
    toggleSats: {
      description: "Habilitar o deshabilitar Satoshis."
    }
  }
}, note$4 = {
  input: {
    description: "(opcional)",
    placeholder: "añade nota"
  },
  title: "Nota"
}, notification$3 = {
  newTxs_one: "Nueva transacción en: {{accountName}}",
  newTxs_other: "{{count}} nuevas transacciones en: {{accountName}}"
}, pairing$3 = {
  aborted: {
    text: "La sincronización ha sido cancelada desde la aplicación móvil.",
    title: "Abortado"
  },
  button: "Sincronizar aplicación móvil",
  confirm: "¿Estás seguro de que quieres sincronizar su BitBox? Ten en cuenta que después, se necesitará el teléfono móvil para realizar una transacción.",
  connectOnly: {
    button: "Conectar aplicación móvil",
    title: "Escanea con nuestra aplicación móvil seleccionando el elemento de menú 'Conectar a la nueva aplicación de escritorio'"
  },
  error: {
    text: "Algo salió mal. Por favor empieza de nuevo.",
    title: "Error"
  },
  pullFailed: {
    text: "Ha habido un error recibiendo un mensaje de tu móvil a través del relay server.  Éste puede estar sin conexión, por favor contacte al soporte técnico.",
    title: "Solicitud fallida"
  },
  reconnectOnly: {
    button: "Volver a conectar la aplicación móvil"
  },
  scanningFailed: {
    text: "El móvil no ha podido escanear el mensaje con éxito. Por favor inténtalo de nuevo.",
    title: "Escaneo fallido"
  },
  start: {
    hideAppQRCode: "Ocultar código QR",
    revealAppQRCode: "Mostrar código QR",
    step1: "Si no tiene la aplicación móvil, puede escanear el código QR para la App Store de Apple o la Play Store de Google, según el teléfono que tengas.",
    step2: "Escanee con nuestra aplicación móvil, que puede encontrar bajo el nombre 'Digital Bitbox 2FA' en las tiendas de aplicaciones para iOS y Android:"
  },
  started: {
    text: "Ahora sige por favor las instrucciones en la aplicación móvil.",
    title: "Genial"
  },
  success: {
    text: "¡Enhorabuena, has sincronizado su BitBox con la aplicación móvil!",
    title: "Éxito"
  },
  timeout: {
    text: "La sincronización expiró después de dos minutos. Empieza de nuevo si aún quieres sincronizar la aplicación móvil.",
    title: "Se acabó el tiempo"
  },
  title: "Sincronización móvil"
}, passphrase$2 = {
  considerations: {
    button: "Consideraciones de la copia de seguridad",
    message: `La frase de contraseña añade una capa de protección a tu billetera de copia de seguridad (de la tarjeta microSD o palabras de recuperación). Si alguien tiene acceso a tu copia de seguridad, también necesitará la frase de contraseña para acceder a tu billetera. 


Sin embargo, esto significa que necesitarás <strong>tanto la frase de contraseña como la copia de seguridad de tu billetera</strong> para restaurar tu billetera con la frase de contraseña, en caso de que tu BitBox02 se pierda o se rompa. Si olvidas o pierdes tu contraseña, perderás el acceso a todas las monedas de esa billetera.

Cuando almacenes tu frase de contraseña, considera ponerla en un lugar distinto a la de tu copia de seguridad. De este modo, si alguien encuentra la copia de seguridad, no encontrará también la frase de contraseña.`,
    title: "Consideraciones de la copia de seguridad"
  },
  disable: "Desactivar passphrase",
  disableInfo: {
    button: "Desactivar",
    message: `Tras desactivar la passphrase, no se le volverá a preguntar para que introduzca una passphrase tras desbloquear su BitBox02. Por lo que entrara en su cartera por defecto.
Cualquier moneda de su cartera con passphrase seguirá estando en esa cartera, sin embargo no tendrá acceso a ella porque tras desbloquear su BitBox02, abrirá su cartera por defecto.
Para acceder a su cartera con passphrase de nuevo, simplemente vuelva a activar la opción de passphrase e introduzca la passphrase correcta tras desbloquear la BitBox02.
<strong>Consejo:</strong> Puede seguir entrando en su cartera original dejando la passphrase vacía.`
  },
  enable: "Activar passphrase",
  error: {
    e104: "El cambio en la característica de passphrase fue abortado."
  },
  how: {
    button: "Cómo se ve",
    message: `Una passphrase no funciona como una contraseña a las que estamos habituados. Si se equivoca en un carácter de su passphrase, no será notificado. Esto es porque <strong>cada passphrase crea una cartera diferente y válida al mismo tiempo</strong>. Esto significa que se pueden utilizar tantas pasprases como carteras se deseen. Pero solo se puede acceder a cada cartera cuando se introduce su passphrase correspondiente.
Cuando conecte su BotBox02, será preguntado por su contraseña como siempre. Después, se le solicitará que introduzca la passphrase en el dispositivo.
Tras introducir la passphrase, se le mostrará la passphrase que ha introducido. Esto es para confirmar que ha sido introducida correctamente.`,
    title: "Como funciona"
  },
  intro: {
    message: `Una passphrase proporciona una capa de seguridad por encima de su cartera.
Aprendamos cómo funciona.`,
    title: "Configurar passphrase"
  },
  progressDisable: {
    message: "Confirme en su BitBox que quiere <strong>desactivar</strong> la opción de passphrase.",
    title: "Confirme en el dispositivo"
  },
  progressEnable: {
    message: "Confirme en su BitBox que quiere <strong>activar</strong> la opción de passphrase.",
    title: "Confirme en el dispositivo"
  },
  successDisabled: {
    message: `Passphrase opcional <strong>activada satisfactoriamente</strong>!
A partir de ahora se le solicitara introducir una passphrase.`,
    messageEnd: "Por favor vuelva a conectar ahora su BitBox02.",
    title: "Passphrase activado"
  },
  successEnabled: {
    message: `Passphrase opcional <strong>desactivada satisfactoriamente</strong>!
A partir de ahora no se le solicitará introducir una passphrase.`,
    messageEnd: "Por favor vuelva a conectar su BitBox02 ahora.",
    tips: "Consejos",
    tipsList: [
      "Le sugerimos enviar una pequeña cantidad a su cartera con passphrase primero. Después desconecte y vuelva a conectar la BitBox02 e introduzca su contraseña y su passphrase. Si ha introducido la passphrase correctamente, debería ver las monedas en su cartera.",
      "Si quiere entrar en su cartera original sin passphrase, puede seguir haciéndolo no introduciendo nada cuando le solicite introducir la passphrase. O puede desactivar la característica de passphrase."
    ],
    title: "Passphrase desactivada"
  },
  summary: {
    button: "Activar passphrase",
    title: "Resumen",
    understand: "Entiendo como funciona la passphrase y sus riesgos asociados.",
    understandList: [
      "La passphrase es una capa adicional de seguridad por encima de su copia de seguridad.",
      "Introducir un passphrase diferente siempre generará carteras diferentes.",
      "Para restaurar su cartera necesita <strong>tanto la passphrase como la copia de seguridad</strong>.",
      "Si olvidas tu frase de contraseña, ya no podrás <strong>acceder a tus monedas</strong>."
    ]
  },
  what: {
    button: "Aprenda como funciona",
    message: `Una billetera se crea (deriva) a partir de un número aleatorio muy grande, también conocido como semilla. Esta semilla se crea cuando configuras por primera vez tu BitBox02 y se respalda con la tarjeta microSD o las palabras de recuperación. Cualquiera que tenga acceso a la semilla tiene control total sobre los fondos de esa billetera.

Una frase de contraseña es un <strong>secreto opcional</strong>, añadido a la semilla. Cuando se utiliza una frase de contraseña, cada frase de contraseña crea una nueva billetera basada en la semilla + frase de contraseña (secreto opcional). Una frase de contraseña puede ser cualquier cosa: letras, palabras, caracteres especiales o incluso puede estar vacía. De hecho, la billetera predeterminadamente se deriva de la semilla + frase de contraseña vacía.

La frase de contraseña forma parte del estándar BIP39, lo que significa que es compatible con todos las billeteras que admitan el mismo estándar.`,
    title: "¿Qué es una passphrase?"
  },
  why: {
    button: "Porqué utilizar una passphrase",
    message: `La BitBox02 protege la semilla contra la extracción desde el propio dispositivo, pero la copia de seguridad (tarjeta microSD o palabras de recuperación) da acceso completo a la billetera. ¡Por eso debe guardarse en un lugar seguro!


Dado que una frase de contraseña crea una nueva billetera utilizando tu semilla existente, la billetera con frase de contraseña requiere tanto tu <strong>reserva de seguridad</strong> COMO tu frase de contraseña para restaurarla. La ventaja de esto es que si alguien encuentra tu copia de seguridad, seguirá necesitando la frase de contraseña para acceder a la billetera con la frase de contraseña.


Además, la función de la frase de contraseña permite crear varias billeteras en el mismo dispositivo, o "billeteras ocultas", además del predeterminado.`,
    title: "¿Porqué utilizar una passphrase?"
  }
}, password$3 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "AVISO: el bloqueo de mayúsculas (⇪) está activado",
    paste: 'para pegar texto, activa "MOSTRAR {{label}}"'
  }
}, random$4 = {
  button: "Generar número aleatorio",
  description: "Tu BitBox ha generado el siguiente número aleatorio de {{bits}} bits:"
}, receive$5 = {
  changeScriptType: "Tipo de dirección del cambio",
  label: "Tu dirección",
  onlyThisCoin: {
    description: "Para recibir otros tokens, por favor actívalos en la configuración. Si depositas otros tokens, podrían no ser accesibles. ",
    warning: "Asegúrate de recibir solo {{coinName}} en esta dirección."
  },
  scriptType: {
    p2tr: "Taproot (Nuevo formato)",
    p2wpkh: "Native Segwit (por defecto)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatible)"
  },
  selectAccount: "Seleccionar cuenta ",
  showFull: "Muestra y verifica la dirección completa en el dispositivo",
  taprootWarning: "Nota: Taproot es una nueva característica de Bitcoin y todavía no es ampliamente aceptada. Los fondos recibidos en direcciones Taproot pueden no ser mostradas en carteras de terceros. Muchas carteras y exchanges no pueden enviar a direcciones Taproot.",
  title: "Recibe {{accountName}}",
  verify: "Verificar la dirección de forma segura",
  verifyBitBox01: "Verifica la dirección completa en la app móvil",
  verifyBitBox02: "Verifica la dirección en la BitBox02",
  verifyInstruction: "Por favor, verifica que esta dirección encaja con la de tu dispositivo.",
  warning: {
    secureOutput: "Por favor, sincroniza su BitBox con tu dispositivo móvil para activar la verificación segura de la dirección. Ve a 'Administrar dispositivo' en la barra lateral."
  }
}, reset$3 = {
  description: "Todos los datos serán borrados de este dispositivo. ¡Eso incluye tu clave privada!",
  notReset: "Dispositivo NO reseteado.",
  title: "Resetear dispositivo de fábrica",
  understand: "Tengo una copia de seguridad y conozco mi contraseña de recuperación",
  understandBB02: "Tengo una copia de seguridad válida"
}, securityInformation$3 = {
  create: {
    description1: "Antes de configurar su dispositivo, se recomienda que lo hagas en un entorno seguro.",
    description2: "Se le pedirá que crea dos contraseñas.",
    description3: "La primera es la <strong>contraseña del dispositivo</strong> que desbloquea su dispositivo BitBox y puede cambiarse más tarde.",
    description4: "El segundo es el <strong>contraseña de recuperación</strong> que desbloquea tu monedero. Esta contraseña no se puede cambiar más tarde.",
    description5: "Se realizará una copia de seguridad del monedero que creaste en un archivo de la tarjeta micro SD proporcionada. Esto se puede usar en una emergencia para recuperar tus fondos usando tu <strong>contraseña de recuperación</strong>.",
    title: "Información de seguridad"
  },
  restore: {
    description1: "Se te pedirá que insertes la tarjeta micro SD que utilizó para guardar su copia de seguridad.",
    description2: "Para recuperar tu dispositivo necesitarás tu contraseña de recuperación. ",
    description3: "Por favor ten cuidado al ingresar la contraseña de recuperación. Cualquier contraseña que ingreses creará un monedero válida. Si introduces la contraseña incorrecta, es posible que ves un saldo del monedero que no esperas.",
    title: "Información de seguridad"
  }
}, seed$3 = {
  agreements: {
    "funds-access": "NO podré acceder a mis fondos si olvido mi contraseña de recuperación",
    "password-change": "NO puedo cambiar la contraseña de recuperación más tarde",
    "password-required": "La contraseña de recuperación es necesaria para restaurar un monedero desde una copia de seguridad"
  },
  create: "Crea monedero",
  creating: "Creando monedero",
  description: "Entiendo que:",
  error: {
    e102: "La contraseña debe contener al menos 4 caracteres.",
    e200: "Debe insertar una tarjeta micro SD en su BitBox para crear un mondero, de modo que se pueda crear una copia de seguridad automáticamente."
  },
  info: {
    button: "Establecer contraseña de recuperación ahora",
    description1: "Inserta la tarjeta micro SD en el BitBox",
    description2: 'Elija una contraseña de recuperación para el monedero y seleccione "Establecer contraseña de recuperación ahora"',
    description3: "La copia de seguridad en la tarjeta micro SD y su contraseña de recuperación es el único método para recuperar sus fondos en caso de pérdida o robo del dispositivo BitBox.",
    description4: "No puede cambiar su contraseña de recuperación más adelante sin transferir sus fondos.",
    title: "Crear una cartera nueva"
  },
  password: {
    label: "Contraseña de recuperación",
    repeatPlaceholder: "Repita la contraseña de recuperación"
  },
  walletName: {
    label: "Nombre del monedero"
  }
}, seedRestore$3 = {
  error: {
    e200: "La recuperación de un monedero a partir de una copia de seguridad requiere la tarjeta micro SD."
  },
  info: {
    description1: 'Inserta la tarjeta micro SD en el BitBox y haga clic en "Continuar"',
    description2: 'Elija una copia de seguridad y haga clic en "Restablecer"',
    description3: "Ingresa la contraseña de recuperación",
    description4: "Debes confirmar para entender que una contraseña incorrecta creará una cartera diferente.",
    title: "Cómo restaurar un monedero desde una copia de seguridad"
  }
}, send$5 = {
  abort: "La transacción ha sido cancelada.",
  address: {
    label: "Dirección del receptor",
    placeholder: "Introduce dirección!"
  },
  amount: {
    label: "Cantidad",
    placeholder: "Introduzca la cantidad"
  },
  availableBalance: "Saldo disponible",
  button: "Revisar ",
  coincontrol: {
    address: "Dirección",
    outpoint: "Anotar",
    title: "Enviar desde salida"
  },
  confirm: {
    "selected-coins": "Monedas seleccionadas",
    title: "Confirma y envía la transacción",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que no tiene suficiente Ether para pagar esta transacción ERC20. Por favor, asegúrese de que tiene suficiente Ether en su wallet.",
    feeTooLow: "La tarifa de red es demasiado baja",
    feesNotAvailable: "No se pueden estimar las tarifas de red",
    insufficientFunds: "fondos insuficientes",
    invalidAddress: "dirección inválida",
    invalidAmount: "Cantidad inválida",
    invalidData: "Datos inválidos"
  },
  fee: {
    customPlaceholder: "Introduzca la cantidad",
    label: "Tarifa de red",
    placeholder: "No disponible"
  },
  feeTarget: {
    customLabel: "Tarifa de red",
    customLabel_eth: "Precio del Gas",
    description: {
      economy: "24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)",
      economy_eth: "30 minutos o menos",
      economy_ltc: "1 hora (24 bloques)",
      high: "2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)",
      high_eth: "30 segundos o menos",
      high_ltc: "5 minutos (2 bloques)",
      low: "12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)",
      low_eth: "5 minutos o menos",
      low_ltc: "30 minutos (12 bloques)",
      normal: "6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)",
      normal_eth: "2 minutos o menos",
      normal_ltc: "15 minutos (6 bloques)"
    },
    estimate: "Tiempo de espera estimado:",
    label: {
      custom: "A medida",
      economy: "Económico",
      high: "Alto",
      low: "Bajo",
      normal: "Normal"
    },
    placeholder: "Calculando la tarifa de red..."
  },
  maximum: "Enviar todo",
  maximumSelectedCoins: "Enviar monedas seleccionadas",
  noFeeTargets: "Las estimaciones de tarifas no están disponibles actualmente. Vuelva a intentarlo más tarde o introduzca una tarifa personalizada.",
  priority: "Prioridad",
  scanQR: "Escanear código QR",
  signprogress: {
    description: "Esta es una transacción que contiene una gran cantidad de datos. Para firmar en su totalidad la transacción, se le pedirá que confirme {{steps}} veces.",
    label: "En curso"
  },
  success: "La transacción ha sido firmada y enviada.",
  title: "Envía {{accountName}}",
  toggleCoinControl: "Activar/Desactivar control de monedas/UTXO",
  transactionDetails: "Detalles de la transacción"
}, settings$4 = {
  about: "Acerca de",
  accounts: "Cuentas",
  advancedSettings: "Configuración avanzada",
  appearance: "Apariencia",
  electrum: {
    add: "Añadir un servidor",
    "add-server": "Añadir",
    check: "Comprobar",
    checkFailed: "Falló",
    checkSuccess: "La conexión establecida con éxito a {{host}}",
    checking: "Comprobación",
    "download-cert": "Descarga certificado remoto",
    "remove-server": "Elimina",
    removeConfirm: "Eliminar {{server}}?",
    reset: "Restablecer a predeterminados",
    resetConfirm: "¿Desea eliminar todos los servidores e instalar los servidores predeterminados?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Introduzca el punto final.",
    step2: "2",
    "step2-text": "Introduzca un certificado de la cadena de certificados del servidor. Alternativamente, descarga el certificado remoto y compárelo visualmente.",
    "step2-text-tcp": "Puedes omitir este paso si no quieres utilizar TLS.",
    step3: "3",
    "step3-text": "Comprueba la conexión y añade el servidor.",
    step4: "4",
    "step4-text": "Reinicia el monedero. Si no eliminas los servidores predeterminados, tu propio nodo se agregará como redundancia.",
    "title-btc": "Servidores de Bitcoin Electrum",
    "title-ltc": "Servidores de Litecoin Electrum",
    "title-tbtc": "Servidores de Bitcoin Testnet Electrum",
    "title-tltc": "Servidores de Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activa control de monedas",
    electrum: {
      description: "Puedes conectarte a tu propio nodo Electrum completo.",
      title: "Conecta tu propio nodo completo"
    },
    fee: "Activar tarifas de red personalizadas",
    setProxyAddress: "Establece dirección proxy",
    title: "Configuración avanzada",
    useProxy: "Activar tor proxy",
    useSats: "Mostrar valores BTC en Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nueva actualización disponible",
    title: "Información",
    "up-to-date": "Su aplicación está actualizada",
    version: "Versión del App"
  },
  restart: "Por favor, reinicia la BitBoxApp para que los cambios tengan efecto.",
  services: {
    title: "Servicios"
  },
  success: "Por favor desenchufa y vuelva a enchufar el BitBox para que los cambios surjan efecto.",
  title: "Ajustes"
}, setup$3 = "Dispositivo de configuración", sidebar$4 = {
  buy: "Compra criptomoneda",
  device: "Administra dispositivo",
  leave: "Salir",
  settings: "Ajustes"
}, success$a = {
  create: {
    info1: "Su monedero se ha respaldado de manera segura en la tarjeta micro SD. Retírelo y guárdalo en un lugar seguro. ",
    info2: "Has creado una contraseña de dispositivo seguro que desbloquea el BitBox.",
    info3: "Has creado una contraseña de recuperación segura para su monedero que desbloquea sus fondos y recupera sus copias de seguridad.",
    summary: "Aquí hay un resumen de lo que has hecho.",
    title: "Éxito"
  },
  getstarted: "Empieza",
  restore: {
    summary: "Has restaurado con éxito un monedero de su copia de seguridad.",
    title: "Éxito"
  }
}, transaction$4 = {
  confirmation: "Confirmaciones",
  details: {
    activity: "Actividades",
    address: "Dirección",
    amount: "Cantidad",
    date: "Fecha",
    fiat: "Fiat",
    fiatAmount: "Cantidad Fiat",
    fiatAtTime: "Fiat en el momento de la transacción",
    status: "Estado",
    type: "Tipo"
  },
  explorer: "ID de transacción",
  explorerTitle: "Abrir en el bloque externo Explorer",
  fee: "Tarifa de red",
  fiatHistorical: "Historial",
  gas: "Gas",
  note: {
    edit: "Edita nota",
    save: "Guarda nota"
  },
  pending: "Transacción pendiente",
  size: "Tamaño",
  status: {
    complete: "Acabado",
    failed: "Falló",
    pending: "Pendiente"
  },
  tx: {
    received: "Recibido a",
    sent: "Enviado a"
  },
  vsize: "Tamaño virtual",
  weight: "Peso"
}, transactions$3 = {
  errorLoadTransactions: "Se ha producido un error al cargar las transacciones",
  placeholder: "Sin transacciones todavía."
}, unknownError$3 = "Ocurrió un error desconocido: {{errorMessage}}", unlock$3 = {
  description: "Ingresa la contraseña de tu dispositivo para desbloquear el dispositivo.",
  error: {
    e109_normal: "Contraseña incorrecta del dispositivo. {{remainingAttempts}} intentos permanecen antes de que el dispositivo se reinicie.",
    e109_touch: "$t(unlock.error.e109_normal) El siguiente inicio de sesión requiere mantener presionado el botón táctil.",
    e113: "Debido a muchos intentos de inicio de sesión, el siguiente inicio de sesión requiere mantener presionado el botón táctil durante 4 segundos."
  },
  input: {
    label: "Contraseña del dispositivo",
    placeholder: "Ingresa la contraseña de tu dispositivo para desbloquear el dispositivo"
  },
  unlocking: "Desbloqueando..."
}, upgradeFirmware$4 = {
  button: "Actualización de firmware",
  description: "¿Quieres actualizar el Firmware de la versión {{currentVersion}} a {{newVersion}}?",
  label: "Se requiere una actualización de firmware para tu BitBox.",
  locked: "Para actualizar desde {{currentVersion}} a {{newVersion}}, por favor haz un toque largo.",
  title: "Actualización de firmware",
  unlocked: "El gestor de arranque está desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecta y vuelva a conectar su Bitbox",
  unlocked2: "El LED se encenderá cuando su BitBox se vuelva a enchufar.",
  unlocked3: "Toque el botón táctil cuando el LED se encienda"
}, walletConnect$4 = {
  connect: {
    button: "Conectar",
    dappLabel: "Introduzca la dirección URI de la aplicación ",
    invalidPairingUri: "Uri de emparejamiento no válido"
  },
  dashboard: {
    allSessions: "Todas las sesiones",
    disclaimer: "Walletconnect es un protocolo para conectarse a dapps basadas en Ethereum. Estas dapps están gestionadas por servicios de terceros, así que conéctate solo a dapps en las que confíes y asegúrate de saber siempre lo que estás firmando al realizar una transacción.",
    newConnection: "Nueva conexión",
    noConnectedSessions: "Actualmente no hay cuentas conectadas a ninguna dapps."
  },
  invalidPairingChain: "Error al aprobar el emparejamiento. Asegúrese de utilizar una de las cadenas admitidas: {{cadenas}}",
  pairingRequest: {
    approve: "Aprobar conexión",
    reject: "Rechazar",
    title: "Nueva solicitud de conexión de"
  },
  pairingSuccess: "Dapp conectada con éxito. Puede continuar en el sitio web de la dapp.",
  signingRequest: {
    account: "Cuenta",
    chain: "Cadena",
    dapp: "Dapp",
    data: "Datos",
    dataParsingError: "Error al analizar los datos",
    decodeError: "No se ha podido descodificar el mensaje",
    method: {
      sendTransaction: "Firmar y enviar la transacción",
      signMessage: "Firmar el mensaje",
      signTransaction: "Firmar la transacción",
      signTypedData: "Firmar los datos escritos"
    },
    successfullySigned: "Solicitud firmada con éxito",
    walletConnectRequest: "Solicitud de WalletConnect"
  },
  useNewUri: "Este URI ya ha sido utilizado para intentar una conexión. Por favor, utilice un nuevo URI.",
  walletConnect: "WalletConnect"
}, warning$9 = {
  receivePairing: "Por favor, sincroniza el BitBox para activar la verificación segura de la dirección. Ve a 'Administrar dispositivo' en la barra lateral.",
  sdcard: "Manten la tarjeta micro SD guardada aparte del BitBox, a menos que desee administrar las copias de seguridad.",
  sendPairing: "Por favor, sincroniza el BitBox para verificar con seguridad los detalles de la transacción. Vaya a 'Administrar dispositivo' en la barra lateral."
}, welcome$3 = {
  connect: "Conecta tu BitBox02",
  getStarted: "Vamos a comenzar instalando el firmware en su BitBox02.",
  insertBitBox02: "Si estás usando BitBox02, por favor toca el dispositivo para continuar.",
  insertDevice: "Por favor conecta tu dispositivo para comenzar",
  title: "Bienvenido"
}, appTranslationsES = {
  account: account$3,
  accountInfo: accountInfo$3,
  accountSummary: accountSummary$3,
  addAccount: addAccount$4,
  aopp: aopp$2,
  app: app$3,
  auth: auth$3,
  backup: backup$3,
  bb02Bootloader: bb02Bootloader$3,
  bitbox: bitbox$3,
  bitbox02Interact: bitbox02Interact$3,
  bitbox02Settings: bitbox02Settings$3,
  bitbox02Wizard: bitbox02Wizard$3,
  blink: blink$3,
  bootloader: bootloader$3,
  button: button$7,
  buy: buy$4,
  changePin: changePin$3,
  chart: chart$4,
  checkSDcard: checkSDcard$3,
  clickHere: clickHere$3,
  confirm: confirm$5,
  confirmOnDevice: confirmOnDevice$3,
  connectKeystore: connectKeystore$3,
  darkmode: darkmode$3,
  device: device$3,
  deviceLock: deviceLock$3,
  deviceSettings: deviceSettings$3,
  deviceTampered: deviceTampered$3,
  dialog: dialog$4,
  error: error$4,
  fiat: fiat$5,
  footer: footer$5,
  generic: generic$4,
  genericError: genericError$3,
  goal: goal$3,
  guide: guide$4,
  headerssync: headerssync$3,
  hiddenWallet: hiddenWallet$3,
  initialize: initialize$3,
  invalidFormat: invalidFormat$3,
  language: language$4,
  legacyhiddenwallet: legacyhiddenwallet$3,
  loading: loading$3,
  manageAccounts: manageAccounts$2,
  mobile: mobile$3,
  newSettings: newSettings$2,
  note: note$4,
  notification: notification$3,
  pairing: pairing$3,
  passphrase: passphrase$2,
  password: password$3,
  random: random$4,
  receive: receive$5,
  reset: reset$3,
  securityInformation: securityInformation$3,
  seed: seed$3,
  seedRestore: seedRestore$3,
  send: send$5,
  settings: settings$4,
  setup: setup$3,
  sidebar: sidebar$4,
  success: success$a,
  transaction: transaction$4,
  transactions: transactions$3,
  unknownError: unknownError$3,
  unlock: unlock$3,
  upgradeFirmware: upgradeFirmware$4,
  walletConnect: walletConnect$4,
  warning: warning$9,
  welcome: welcome$3
}, account$2 = {
  disconnect: "Povezava je prekinjena. Poizkušam ponovno...",
  export: "Izvoz",
  exportTransactions: "Izvozite transakcije v CSV datoteko in odložite v lokalno mapo.",
  fatalError: "Ups, nepričakovana napaka",
  incoming: "Dohodni",
  initializing: "Pridobivam podatke iz verige blokov...",
  maybeProxyError: "Tor proxy omogočen. Prepričajte se, da Tor proxy deluje pravilno, ali onemogočite proxy.",
  reconnecting: "Povezava je prekinjena, poizkušam s ponovno vzpostavitvijo...",
  syncedAddressesCount: "Prešteto št. naslovov: {{count}}"
}, accountInfo$2 = {
  address: "Naslov",
  buyCTA: {
    buy: "Kupi",
    buyCrypto: "Kupi kripto",
    information: {
      looksEmpty: "Denarnica je prazna.",
      start: "Začnite tako, da pošljete nekaj kovancev v denarnico ali jih kupite neposredno v aplikaciji BitBoxApp."
    }
  },
  extendedPublicKey: "Razširjen javni ključ",
  label: "Podatki o računu",
  scriptType: "Tip skripte",
  title: "Podatki o računu",
  verify: "Potrdi na napravi",
  xpubTypeChangeBtn: {
    p2pkh: "Ogled razširjenega javnega ključa P2PKH",
    p2tr: "Oglejte Taproot",
    p2wpkh: "Ogled Native Segwit",
    "p2wpkh-p2sh": "Ogled razširjenega javnega ključa P2SH"
  },
  xpubTypeInfo: "Prikazan je {{scriptType}} razširjen javni ključ ({{current}} od {{numberOfXPubs}})"
}, accountSummary$2 = {
  availableBalance: "Razpoložljivo stanje",
  balance: "Stanje",
  exportSummary: "Izvozi povzetek računa v mapo za prenos, kot datoteko CSV",
  fiatBalance: "Stanje v fiat valuti",
  name: "Ime računa",
  noAccount: "Ni računov za prikaz.",
  subtotalWithCoinName: "Skupaj ({{coinName}})",
  title: "Moj portfelj",
  total: "Skupaj",
  transactionHistory: "Zgodovina transakcij"
}, addAccount$3 = {
  chooseName: {
    nextButton: "Dodaj račun",
    step: "Poimenuj račun",
    title: "Poimenuj račun"
  },
  selectCoin: {
    nextButton: "Naprej",
    step: "Izberi kovanec",
    title: "Izberi kriptovaluto"
  },
  success: {
    addAnotherAccount: "Dodajte nov račun",
    message: "<strong> {{accountName}} </strong> je zdaj dodan med vaše račune.",
    nextButton: "OK",
    step: "Zaklljučeno",
    title: "Račun dodan"
  },
  title: "Dodajte račun"
}, aopp$1 = {
  addressRequest: "{{host}} zahteva naslov prejemnika.",
  addressRequestWithLogo: "zahteva naslov prejemnika",
  banner: "Zahteva po naslovu je v teku.",
  errorTitle: "Napaka med zahtevo za naslov",
  labelAddress: "Naslov",
  labelMessage: "Sporočilo",
  reverifyInfoText: "Potrdite naslov",
  signing: "Za nadaljevanje podpišite sporočilo na napravi",
  success: {
    message: "Nadaljujte na {{host}}",
    title: "Naslov uspešno poslan"
  },
  syncing: "Počakajte trenutek, poteka sinhronizacija računa.",
  title: "Zahteva za naslov"
}, app$2 = {
  upgrade: "Na voljo je nova verzija te aplikacije! Prosimo vas, da jo nadgradite iz verzije  {{current}} na {{version}}."
}, auth$2 = {
  authButton: "Potrdi",
  title: "Za nadaljevanje potrdite"
}, backup$2 = {
  check: {
    checking: "Preverjam varnostno kopijo...",
    confirmTitle: "Preverite varnostno kopijo",
    notOK: "Varnostna kopija se NE ujema s trenutno denarnico.",
    ok: "Varnostna kopija se ujema z denarnico.",
    password: {
      label: "Geslo za obnovo varnostne kopije",
      placeholder: "Geslo za obnovo varnostne kopije",
      showLabel: "geslo za obnovo varnostne kopije"
    },
    success: "Varnostna kopija uspešno preverjena:",
    title: "Preverite varnostno kopijo"
  },
  create: {
    alreadyExists: "Veljavno varnostno kopijo že imate. Ali jo ponovno želite ustvariti?",
    fail: "Ustvarjanje varnostne kopije NI uspelo!",
    info: "Prosimo vnesite geslo za obnovo trenutne denarnice za potrditev.",
    name: {
      label: "Ime varnostne kopije",
      placeholder: "Poimenujte varnostno kopijo"
    },
    password: {
      label: "Obnovitveno geslo",
      placeholder: "Prosimo vnesite obnovitveno geslo"
    },
    title: "Ustvarite varnostno kopijo - backup",
    verificationFailed: 'Obnovitveno geslo se NE ujema s trenutno denarnico. Varnostna kopija je bila ustvarjena. Prosimo uporabite "Preverite varnostno kopijo" da potrdite geslo za obnovo.'
  },
  description: "Izberite <strong>datoteko z varnostno kopijo denarnice</strong>",
  insert: "Prosimo vstavite microSD kartico za upravljanje z varnostnimi kopijami.",
  insertButton: "Vstavil sem microSD kartico",
  list: "Varnostne kopije na microSD kartici",
  noBackups: "Na tej microSD kartici ni varnostnih kopij.",
  restore: {
    confirmTitle: "Obnovite varnostno kopijo",
    error: {
      e200: "MicroSD kartica ni bila zaznana",
      general: "Napaka pri obnovitvi varnostne kopije"
    },
    password: {
      label: "Geslo za obnovitev ali skrito geslo za obnovitev varnostne kopije",
      placeholder: "Geslo za obnovitev",
      repeatPlaceholder: "Ponovite geslo za obnovitev",
      showLabel: "Geslo za obnovitev"
    },
    restoring: "Obnavljanje varnostne kopije ...",
    selectedBackup: "<strong>{{backupName}}</strong> ustvarjen {{createdDateTime}} bo obnovljen.",
    title: "Obnovi",
    understand: "Razumem, da bo nepravilno geslo za obnovitev ustvarilo drugo, novo denarnico"
  },
  showMnemonic: {
    description: `Prikazano vam bo do 24 besed, ki tvorijo varnostno kopijo denarnice. Zapišite jih na papir.

<strong>Ne hranite jih digitalno in jih ne fotografirajte.</strong>

<strong>Ne izgovarjajte besed na glas.</strong>

<strong>Ta varnostna kopija ni zaščitena z geslom.</strong>

Po končanem prikazu besed boste morali vsako še potrditi na napravi.`,
    title: "Prikaži seznam besed",
    warning: "<strong>Nikoli ne delite obnovitvenih besed z nikomer.</strong> Te besede omogočajo popoln dostop do vaše denarnice. Če vas kdo sprašuje po teh besedah, gre zelo verjetno za prevaro. Ne delite jih z neznanci!"
  },
  title: "Upravljanje varnostnih kopij"
}, bb02Bootloader$2 = {
  abort: "Ne nadgradi - vrni me nazaj",
  abort_noUpgrade: "Vrni me nazaj",
  advanced: {
    label: "Napredne nastavitve",
    toggleShowFirmwareHash: "Ob zagonu vedno prikaži binarno vrednost strojne programske opreme (firmware hash)"
  },
  flipscreen: "Obrnite sliko na zaslonu",
  orientation: "Je zaslon na napravi obrnjen v napačno smer?",
  success: "Nadgradnja uspešna! Nadaljevanje v {{rebootSeconds}} sekundah...",
  success_install: "Namestitev uspešna! Nadaljevanje v {{rebootSeconds}} sekundah..."
}, bitbox$2 = {
  error: {
    e10000: "Trenutno geslo naprave je napačno.",
    e10001: "Gesla naprave ni bilo mogoče zamenjati",
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e112: "Geslo skrite denarnice ne more biti enako kot geslo glavne denarnice."
  }
}, bitbox02Interact$2 = {
  confirmDate: "Potrdite današnji datum na BitBox02",
  confirmDateText: "Vnešen datum bo uporabljen za kreiranje varnostne kopije.",
  confirmName: "Potrdite ime na zaslonu BitBox02",
  confirmWords: "Zapišite si {{amount}} obnovitvenih besed iz vašega BitBoxa",
  confirmWordsText: "Po tem koraku BitBox02 zahteva potrditev vsake besede na zaslonu, da se prepričate, da ste varnostno kopijo zapisali pravilno.",
  followInstructions: "Prosimo upoštevajte navodila na zaslonu naprave.",
  followInstructionsMnemonic: "Upoštevajte navodila za obnovitev iz seznama besed na napravi in obnovite denarnico.",
  followInstructionsMnemonicTitle: "Obnovi iz seznama besed"
}, bitbox02Settings$2 = {
  deviceName: {
    current: "Trenutno ime naprave",
    error: "Imena naprave ni bilo mogoče nastaviti",
    error_104: "Potrditev imena je bilo prekinjeno na napravi",
    input: "Novo ime",
    placeholder: "Novo ime naprave",
    title: "Nastavite ime tej napravi"
  },
  gotoStartupSettings: {
    description: "To bo znova zagnalo vaš BitBox02 in začelo nastavitev zagona.",
    title: "Pojdite na začetne nastavitve"
  }
}, bitbox02Wizard$2 = {
  advanced: {
    button: "Napredne možnosti",
    outOfDate: "Strojna programska oprema (firmware) je prestara za to funkcijo",
    seed12WordInfo: "Število besed kasneje ni možno spremeniti.",
    seed12WordLabel: "Ustvari 12 besedno seme namesto 24 besednega",
    seed12WordText: "BitBox privzeto uporablja 24 besedno seme. Na voljo je tudi 12 besedno seme. Obe podprti dolžini semena sta dovolj varni proti strojnemu uganjevanju (brute force). ",
    skipSDCardLabel: "Ne ustvari varnostne kopije na micro SD kartico ampak prikaži semenske besede",
    skipSDCardText: "Kasneje lahko vedno ustvarite varnostno kopijo na micro SD kartico ali ponovno prikažete semenske besede. To opcijo najdete v Nastavitvah.",
    title: "Napredne možnosti arhivske kopije"
  },
  attestationFailed: "Preverjanje ni uspelo, kar je lahko posledica ponovnega zagona aplikacije, medtem ko je naprava čakala na uporabniški vnos (dotik). Napravo znova vklopite in poskusite znova. Če težava ne izgine, se obrnite na support@bitbox.swiss (v angleščini).",
  backup: {
    point1: "Izberite varnostno kopijo na microSD kartici",
    point2: "Nastavite geslo za svojo napravo",
    restoreText: "Ok, obnovimo varnostno kopijo!",
    text1: "Super, vaše geslo za BitBox02 je zdaj nastavljeno in denarnica je ustvarjena. Zdaj je čas, da ustvarite prvo varnostno kopijo. Prepričajte se, da je microSD kartica vstavljena v BitBox02 in nato nadaljujte.",
    text2: "Če želite ustvariti varnostno kopijo, sledite navodilom na zaslonu naprave.",
    text3: "Ko ustvarite varnostno kopijo, odstranite microSD kartico in jo shranite na <strong>varno lokacijo</strong>. Vsebina kartice ni zaščitena z geslom. Nikoli je ne vstavite v nobeno drugo napravo, razen v vaš BitBox02.",
    userConfirmation1: "Varnostno kopijo je potrebno hraniti na varnem mestu",
    userConfirmation2: "Moja varnostna kopija ni zaščitena z geslom. Vsak, ki ima dostop do nje, lahko dostopa do moje denarnice.",
    userConfirmation3: "Če izgubim ali poškodujem svoj BitBox02, je edini način, da povrnem svoja sredstva, obnovitev iz varnostne kopije.",
    userConfirmation4: "Če izgubim ali poškodujem tako varnostno kopijo kot svoj BitBox02, so moja sredstva izgubljena.",
    userConfirmation5: "Ustvarjeno varnostno kopijo na microSD kartici ne smem vtakniti v PC, telefon, tiskalnik ali katero koli drugo napravo razen v BitBox02.",
    userConfirmation5mnemonic: "Semenskih besed NE bom vpisoval v računalnike, telefone, tablice ali katere koli druge naprave, kot le v BitBox02."
  },
  create: {
    button: "Poimenujte napravo in nadaljujte",
    info: "To so osnovni koraki, ki jih boste izvedli za nastavitev BitBoxa: ",
    inputTitle: "Ime denarnice",
    point1: "Poimenujte napravo",
    point2: "Izberite si geslo za svojo napravo",
    point3: "Ustvarite varnostno kopijo",
    text: "Ok, pa ustvarimo novo denarnico!"
  },
  createBackupAborted: "Kreiranje varnostne kopije je prekinjeno.",
  createBackupFailed: "Ustvarjanje varnostne kopije ni uspelo, poskusite znova.",
  initialize: {
    passwordText: "Zdaj pa določite geslo za vašo napravo. Za vnos in izbiro gesla uporabite kontrolne drsnike na BitBoxu.",
    passwordTitle: "Nastavite geslo za vaš BitBox",
    text: "Seznanjanje je bilo uspešno! Zdaj pa pripravimo vašo napravo. Začnite z ustvarjanjem nove denarnice ali obnovitvijo denarnice iz obstoječe varnostne kopije. <strong>Prepričajte se, da imate v BitBox02 vstavljeno microSD kartico </strong>",
    tip: "Priporočamo vam, da te postopke opravite v varnem in zasebnem okolju.",
    title: "Zaženite in nastavite BitBox02"
  },
  insertSDCard: "<strong>Prepričajte se, da imate v BitBox02 vstavljeno microSD kartico.</strong>",
  noPasswordMatch: "Gesli se nista ujemali. Poskusite znova.",
  pairing: {
    failed: "Seznanjanje je bilo prekinjeno. Ponovno priklopite BitBox02.",
    paired: "Na napravi ste potrdili, da se koda ujema. Prosimo nadaljujte.",
    title: "Potrditev seznanitvene kode",
    unpaired: "Zaznana je bila nova BitBox02 naprava. Preverite, ali se prikazana koda ujema s tisto na zaslonu naprave."
  },
  restoreFromMnemonic: {
    e104: "Ponastavitev iz semenskih besed je bilo ustavljeno.",
    failed: "Obnova iz seznama besed ni uspela. Poskusite znova."
  },
  stepBackup: {
    beforeProceed: "Pred nadaljevanjem preberite naslednje pomembne varnostne vidike:",
    createBackup: "Zdaj boste ustvarili varnostno kopijo na microSD kartici .",
    createBackupMnemonic: "Zdaj zapišite semenske besede na papir ali jeklo"
  },
  stepBackupSuccess: {
    fundsSafe: "Če želite ohraniti sredstva varna, upoštevajte naslednje:",
    title: "Varnostna kopija obnovljena!"
  },
  stepConnected: {
    unlock: "Vnesite izbrano geslo, kot ponazarja video"
  },
  stepCreate: {
    description: "To ime je uporabljeno kot ime naprave in ime varnostne kopije.",
    nameLabel: "Vnesite željeno ime naprave",
    namePlaceholder: "Moj BitBox02",
    title: "Izberite ime za vaš BitBox02",
    toastMicroSD: "Vstavite microSD kartico v BitBox02. Na njo bo zapisana varnostna kopija denarnice."
  },
  stepCreateSuccess: {
    removeMicroSD: "Odstranite microSD kartico z naprave in jo shranite na varno mesto.",
    storeMnemonic: "Predlagamo, da shranite te obnovitvene besede na varno lokacijo",
    success: "Uspešno ste ustvarili varnostno kopijo."
  },
  stepInsertSD: {
    insertSDCard: "Vstavite microSD kartico v BitBox02.",
    insertSDcardTitle: "Vstavite microSD kartico"
  },
  stepPassword: {
    e104: "Nastavitev gesla je bila prekinjena.",
    title: "Nastavite geslo za BitBox02",
    useControls: "S pomočjo drsnikov na robu naprave si nastavite geslo."
  },
  stepUninitialized: {
    create: "Želim postaviti nov BitBox02.",
    restore: "Želim obnoviti denarnico iz varnostne kopije.",
    restoreMicroSD: "Obnovi iz microSD kartice",
    restoreMnemonic: "Obnovi iz seznama besed",
    title: "Nastavite svoj BitBox02"
  },
  success: {
    text: `Bravo! Vaš BitBox02 je zdaj pripravljen za uporabo.

Za dodatne informacije o uporabi aplikacije BitBoxApp uporabite vodnik. Na voljo je s klikom na vprašaj v zgornjem desnem kotu.`,
    title: "Zdaj ste pripravljeni za delo z BitBox denarnico!"
  }
}, blink$2 = {
  button: "Sproži utripanje na napravi"
}, bootloader$2 = {
  button: 'Nadgradi "firmware"',
  button_install: "Namestite firmware",
  progress: "Nadgrajujem: {{progress}}%",
  progress_install: "Nameščanje: {{progress}}%",
  success: "Nadgradnja uspešna! Izključite in ponovno priključite napravo v USB režo. Tokrat se ne dotikajte gumba."
}, button$6 = {
  abort: "Prekini",
  back: "Nazaj",
  buy: "Kupi",
  changepin: "Spremenite geslo naprave",
  check: "Preverite varnostno kopijo",
  continue: "Nadaljujte",
  copy: "Kopiraj",
  create: "Ustvari",
  dismiss: "Zavrnite",
  done: "Potrdi izbiro",
  download: "Prenesi",
  hiddenwallet: "Ustvarite skrito denarnico",
  next: "Naprej",
  ok: "OK",
  previous: "Nazaj",
  receive: "Prejmi",
  restore: "Obnovi",
  select: "Izberite",
  send: "Pošlji",
  unlock: "Odklenite denarnico",
  update: "Osveži",
  upgrade: "Nadgradi"
}, buy$3 = {
  exchange: {
    bankTransfer: "Bančno nakazilo",
    bestDeal: "Najboljša ponudba",
    creditCard: "Kreditna karica",
    fast: "Hitro",
    fee: "provizija",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bančno nakazilo: {{fee}}%",
          creditDebitCard: "Kreditna/debetna kartica: {{fee}}%",
          learnMore: "Več o storitvi MoonPay",
          title: "Provizije"
        },
        fullCurrenciesList: "Tu je na voljo seznam vseh valut",
        payment: {
          asteriskText: "* Ni na voljo za rezidente ZDA",
          bankTransfer: "Bančno nakazilo*",
          bankTransferDetails: {
            pix: "PIX (BR transakcije, samo v Braziliji)",
            sepa: "SEPA in SEPA Instant (samo EUR transakcije v državah SEPA)",
            uk: "UK Faster Payments (samo GBP transakcije v Združenem kraljestvu)"
          },
          creditDebitCard: "Kreditna/debetna kartica",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa in Maestro"
          },
          learnMore: "Oglejte si podrobnosti o načinih plačila",
          title: "Načini plačila"
        },
        supportedCurrencies: "Podpira vse glavne fiat valute: USD, EUR, CHF in druge"
      },
      pocket: {
        fees: {
          info: "Bančno nakazilo: {{fee}}%",
          title: "Provizije"
        },
        learnMore: "Več o storitvi Pocket",
        payment: {
          bankTransfer: "Bančno nakazilo",
          bankTransferDetails: {
            sepa: "SEPA in SEPA instant (transakcije v EUR znotraj SEPA podprtih držav)",
            sic: "Švicarska medbančna poravnava (samo za transakcije v CHF v CH/LIE)",
            uk: "UK Faster Payments (samo transakcije v GBP v UK)"
          },
          bankTransferReccuring: "Kako nastavimo ponavljajoče nakupe z enim naročilom?",
          title: "Načini plačila"
        },
        supportedCurrencies: "Podpira evropske valute: EUR, GBP in CHF",
        verification: {
          info: "Preverjanje identitete je zahtevano le nad dnevnim in letnim limitom.",
          link: "Trenutni limiti",
          title: "Preverjanje identitete"
        }
      },
      region: {
        title: "Izberite regijo, v kateri je registriran vaš bančni račun, da vidite možnosti, ki so vam na voljo."
      }
    },
    noExchanges: "V tej regiji žal ni razpoložljivih menjalnic.",
    region: "Regija",
    selectRegion: "Ni navedeno",
    title: "Kupi {{name}}"
  },
  info: {
    continue: "Potrdi in nadaljuj",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "V sodelovanju z MoonPay vam ponujamo možnost nakupa {{name}} neposredno znotraj BitBoxApp. S samo nekaj kliki.",
        "MoonPay je regulirana platforma za finančne storitve, ki omogoča preprost in hiter nakup {{name}} v več kot 160 državah"
      ],
      payment: {
        details: "{{name}} je možno kupiti takoj prek storitve MoonPay z naslednjimi načini plačila. Plačila s kreditno ali debetno kartico so takojšnja in priročna, vendar dražja. Za večje zneske priporočamo uporabo bančnega nakazila. Minimalna pristojbina je 4 EUR.",
        footnote: "Menjalni tečaji storitve MoonPay se lahko razlikujejo od tistih, ki se uporabljajo v BitBoxApp.",
        table: {
          "1_description": "Najnižja provizija, lahko traja do 3 delovne dni",
          "1_method": "Bančno nakazilo (SEPA)",
          "2_description": "Višja provizija a takojšnja izvršitev",
          "2_method": "Kreditna ali debetna kartica",
          description: "Opis",
          fee: "Provizija",
          method: "Način plačila"
        },
        title: "Načini plačila in provizije"
      },
      privacyPolicy: "Politika zasebnosti storitve MoonPay",
      protection: {
        description: `BitBoxApp ne zbira nobenih podatkov ob nakupu preko MoonPay. 
Prilivi se obravnavajo in so prikazani kot običajna transakcija. MoonPay za svoje delovanje zbira nekaj osebnih podatkov. Njihova politika zasebnosti podrobno pojasnjuje, kako ravna s temi podatki.`,
        descriptionGeneric: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu {{name}}, vhodna sredstva se obravnavajo kot običajna transakcija. Pričakujemo, da morajo partnerske borze zbrati nekaj vaših informacij za njihovo poslovanje. Oglejte si njihove pravilnike o zasebnosti, da vidite kako postopajo z vašimi podatki.",
        title: "Zaščita podatkov"
      },
      security: {
        description: "Za nakup {{name}} preko MoonPay uporabljate zunanjo storitev. Ta storitev ne sodi v obseg zaščite, ki jo nudi BitBox02 in temelji na varnosti in zaščiti okolja, v katerem deluje programska oprema BitBoxApp.",
        descriptionGeneric: "Pojasnilo: Ko uporabite partnerske menjalnice za nakup {{name}}, uporabljate zunanjo storitev. Le-ta ni del naše varnostne politike in ni del zaščite, ki jo ponuja BitBox02 temveč je odvisna od okolja (operacijski sistem, omrežje) na katerem uporabljate BitBoxApp.",
        link: "Več o varni uporabi",
        title: "Model varnostnega sistema"
      },
      title: "Dobrodošli! Ste na pravem na mestu za nakup {{name}}"
    },
    next: "Naprej",
    selectLabel: "Izberite svoj račun",
    selectPlaceholder: "Izberi kovanec",
    skip: "Ne prikazuj več",
    title: "Kupi  {{name}}"
  },
  pocket: {
    data: {
      link: "Varovanje zasebnosti storitve Pocket",
      p1: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu bitcoina, vhodna sredstva se obravnavajo kot običajna transakcija. Pocket mora za svoje delovanje zbrati nekaj vaših osebnih podatkov. Njihov pravilnik o zasebnosti podrobno pojasnjuje, kako ravnajo s temi podatki.",
      title: "Varovanje podatkov"
    },
    kyc: {
      link: "Preberite FAQ (odgovore na pogosta vprašanja) storitve Pocket",
      p1: "Storitev Pocket skuša število postopkov za KYC (know-your-customer; prepoznavo kupca) opraviti v najmanjši možni meri. Za nakupe pod 1000 CHF na dan dodatni dokumenti niso potrebni. Za nakupe nad tem zneskom se boste morali dogovoriti za klic z družbo Pocket, da opravite potreben postopek KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin lahko zelo hitro kupite s storitvijo Pocket z bančnim nakazilom tipa SEPA. Provizija znaša 1,5 %, bitcoin pa se v vašo denarnico nakaže takoj, ko Pocket prejme vaše bančno nakazilo (običajno v istem dnevu).",
      p2: "Upoštevajte, da se lahko menjalni tečaji v aplikaciji BitBoxApp razlikujejo od menjalnih tečajev v aplikaciji Pocket, zaradi česar so zneski nekoliko drugačni.",
      title: "Načini plačila in provizije"
    },
    previousTransactions: "Zgodovina transakcij tega računa ni prazna. Če boste ta račun delili, bodo vse pretekle in prihodnje transakcije na njem vidne storitvi Pocket. Ali vseeno nadaljujete?",
    security: {
      link: "Model varnosti in zaščite BitBox02",
      p1: `Ob nakupu bitcoina preko storitve Pocket, uporabljate zunanjo storitev. Le-ta je izven zaščite, ki jo nudi BitBox02. Varnost in zaščita sta odvisna od okolja v katerem uporabljate BitBoxApp. 
Skupaj s storitvijo Pocket delujemo na način, da z dvofaktorsko avtentikacijo preverjamo naslov na katerega prejemate bitcoin.`,
      title: "Varnostni model storitve Pocket"
    },
    usedAddress: "Naslov {{address}} je bil že uporabljen. Prosimo začnite ponovno.",
    verifyBitBox02: "Preverite, ali se naslov, ki ste ga prejeli po e-pošti, ujema z naslovom, prikazanim na napravi. Še bolj varno je, da e-poštno sporočilo odprete in preberete v drugi napravi, če je to mogoče.",
    welcome: {
      p1: "S storitvijo Pocket sodelujemo, da bi vam omogočili enostaven način nakupa bitcoina neposredno v BitBoxApp. V le nekaj klikih.",
      p2: "Pocket je Švicarska platforma ki omogoča hiter in enostaven nakup bitcoina v večini Evropskih držav.",
      p3: "S storitvijo Pocket lahko enostavno vzpostavite redni intervalni nakup bitcoina s pomočjo rednih bančnih nakazil. T.i. DCA (dollar-cost averaging) ",
      title: "Dobrodošli na pravem mestu za nakup bitcoinov"
    }
  },
  title: "Kupi {{name}}"
}, changePin$2 = {
  newTitle: "Novo geslo naprave",
  oldLabel: "Trenutno geslo naprave"
}, chart$3 = {
  dataMissing: "Še vedno pridobivamo informacije. Poskusite znova čez nekaj minut. Čiči pa čaki™",
  dataOldTimestamp: "Nalagamo tečaje. Graf ne prikazuje vrednosti po {{time}}.",
  dataUpdating: "posodabljam...",
  filter: {
    all: "Vse",
    month: "Mesec",
    week: "Teden",
    year: "Leto"
  }
}, checkSDcard$2 = "preverjanje microSD kartice", clickHere$2 = "Kliknite tukaj.", confirm$4 = {
  abortInfo: "Hiter dotik za ",
  abortInfoRedText: "prekinitev",
  approveInfo: "Dotaknite se gumba za vsaj 4 sekunde ",
  approveInfoGreenText: " za potrditev",
  info: "Nadaljujte na BitBoxu.",
  infoWhenPaired: "Najprej na seznanjeni mobilni napravi in ​​nato na BitBoxu"
}, confirmOnDevice$2 = "Nadgradnjo potrdite na BitBox-u", connectKeystore$2 = {
  promptNoName: "Za nadaljevanje priklopite BitBox02",
  promptWithName: 'Za nadaljevanje priklopite vaš BitBox02 z imenom "{{name}}"'
}, darkmode$2 = {
  toggle: "Temen način"
}, device$2 = {
  appUpradeRequired: "BitBox ni združljiv s to verzijo namizne aplikacije. Prenesite in namestite najnovejšo različico."
}, deviceLock$2 = {
  button: "Omogočite dvofaktorsko avtentikacijo (2FA)",
  condition1: "Imate varnostno kopijo?",
  condition2: "Ali deluje preverjanje v mobilni aplikaciji?",
  condition3: "2FA ONEMOGOČA varnostne kopije in seznanjanje z mobilno aplikacijo. Naprava mora biti resetirana za izhod iz dvofaktorskega (2FA) načina!",
  confirm: "Omogočite dvofaktorsko avtentikacijo (2FA)",
  title: "Omogočite dvofaktorsko avtentikacijo (2FA)"
}, deviceSettings$2 = {
  backups: {
    manageBackups: {
      description: "Prikaži in preveri varnostno kopijo na Micro SD kartici."
    },
    showRecoveryWords: {
      description: "Prikaži in potrdi semenske besede."
    },
    title: "Varnostne kopije"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp preverja, če je naprava avtentična."
    },
    deviceName: {
      description: "Spremenite ime naprave"
    },
    rootFingerprint: {
      description: "Korenski prstni odtis je unikaten identifikator denarnice, ki je trenutno v uporabi. Če uporabljate frazemska gesla (passphrases), vam lahko pomaga pri razlikovanju med različnimi denarnicami."
    },
    securechip: {
      description: "Model varnega čipa"
    },
    title: "Informacije o napravi"
  },
  expert: {
    factoryReset: {
      description: "Ponastavite napravo na tovarniške nastavitve. Ta postopek izbriše denarnico na BitBoxu.",
      title: "Tovarniška nastavitev"
    },
    goToStartupSettings: {
      description: 'Vstopite v način "bootloader" na napravi. S tem lahko omogočite prikaz zgoščene vrednosti strojne programske opreme (firmware hash).'
    },
    passphrase: {
      description: "Vklopi ali izklopi možnost geselske fraze",
      title: "Geselska fraza"
    }
  },
  firmware: {
    firmwareVersion: "Različica strojne programske opreme (firmware)",
    newVersion: {
      label: "Razpoložljiva različica"
    },
    title: "Verzija strojne programske opreme (firmware)",
    upToDate: "Vaša naprava je posodobljena",
    upgradeAvailable: "Na voljo je nova nadgradnja",
    version: {
      label: "Različica"
    }
  },
  hardware: {
    attestation: {
      false: "Preverjanje pristnosti ni uspelo",
      label: "Preverjanje pristnosti",
      true: "BitBox02 je pristen!"
    },
    sdcard: {
      false: "Ni vstavljena",
      label: "microSD kartica",
      true: "Vstavljena"
    },
    securechip: "Verzija varnega čipa",
    title: "Naprava"
  },
  loading: "Pridobivam informacije o napravi ...",
  pairing: {
    lock: {
      false: "Onemogočeno",
      label: "Dvo faktorska avtentikacija (2FA)",
      true: "Omogočeno"
    },
    mobile: {
      false: "Zaprto",
      label: "Mobilna aplikacija",
      true: "Odpri"
    },
    status: {
      false: "Ni uparjen",
      label: "Status",
      true: "Uparjen"
    },
    title: "Seznanjanje (uparitev)"
  },
  secrets: {
    manageBackups: "Upravljanje varnostnih kopij",
    title: "Varnost"
  }
}, deviceTampered$2 = `Ali ste prejeli BitBox skupaj z geslom za obnovitev?
Če je tako, takoj zaustavite postopek namestitve in stopite v stik z nami.
Shift nikoli ne izroča pred-pripravljene denarnice ali pred pripravljenih gesel.`, dialog$3 = {
  cancel: "Nazaj",
  confirm: "Potrdite",
  confirmTitle: "Potrditev"
}, error$3 = {
  accountAlreadyExists: "Ta račun že obstaja.",
  accountLimitReached: "Novega računa ni mogoče dodati. Doseženo je največje število računov za ta kovanec.",
  aoppCallback: "Napaka pri dostavi naslova do {{host}}.",
  aoppInvalidRequest: "Napačna poizvedba",
  aoppNoAccounts: "Nobenega računa ni na razpolago.",
  aoppSigningAborted: "Aopp postopek preklican",
  aoppUnknown: "Neznana napaka...",
  aoppUnsupportedAsset: "Izbrano sredstvo ni podprto.",
  aoppUnsupportedFormat: "Na voljo ni računov, ki podpirajo zahtevano obliko naslova.",
  aoppUnsupportedKeystore: "Povezana naprava ne more podpisati sporočil za to sredstvo",
  aoppVersion: "Neznana različica",
  wrongKeystore: "Priključena je napačna denarnica. Vstavite pravo napravo BitBox02, ki ustreza temu računu.",
  wrongKeystore2: "Če uporabljate frazemsko geslo (passphrase), se prepričajte, da ste ga pravilno vnesli za ta račun."
}, fiat$4 = {
  default: "Privzeto",
  setDefault: "Nastavite {{code}} kot privzeto",
  title: "Valute"
}, footer$4 = {
  appVersion: "Različica aplikacije:"
}, generic$3 = {
  enabled_false: "Onemogočeno",
  enabled_true: "Omogočeno"
}, genericError$2 = "Pojavila se je napaka. Če opazite kakršne koli težave, znova zaženite aplikacijo.", goal$2 = {
  buttons: {
    create: "Ustvarite novo denarnico",
    restore: "Obnovite denarnico iz varnostne kopije"
  },
  paragraph: "Izberite eno od naslednjih možnosti:",
  step: {
    1: {
      title: "Varnostne informacije"
    },
    2: {
      description: "Ustvarite geslo naprave",
      title: "Naprava"
    },
    "3-create": {
      description: "Ustvarite novo denarnico",
      title: "Denarnica"
    },
    "3-restore": {
      description: "iz varnostkopije",
      title: "Obnovi"
    },
    "4-create": {
      title: "Povzetek"
    },
    "4-restore": {
      title: "Povzetek"
    }
  }
}, guide$3 = {
  accountDescription: {
    text: "To je pregled vašega računa. Prikazuje dohodne in odhodne transakcije. Stanje je prikazano za vsak račun posebej. Oglejte si pomoč v Nastavitvah, če želite izvedeti več o različnih vrstah računov.",
    title: "Kaj mi prikazuje ta stran?"
  },
  accountFiat: {
    text: "Seveda, kliknite na oznako valute in jo zamenjate. V nastavitvah lahko določate seznam valut, ki se prikazujejo tu.",
    title: "Ali lahko preverim vrednost v drugih fiat valutah?"
  },
  accountIncomingBalance: {
    text: "Tu je zbrana vsota zneskov, ki se prenašajo na vaš račun, vendar jih omrežje še ni potrdilo.",
    title: "Kaj pomeni dohodni?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Vsak xpub (razširjen javni ključ) je vezan na prikazan tip naslova: "Native Segwit (bech32)", "Wrapped Segwit" ali "Taproot" (samo za Bitcoin). To so vrste skript, ki jih uporablja {{coinName}}. Aplikacija BitBoxApp jih združuje in podpira več vrst skript na istem računu. Ker vsaka vrsta skripta daje drugačen xpub, je na računu več xpubov.

Če sredstva stalno prejemate na privzeti naslov (Native Segwit), potrebujete samo "bech32" xpub. Če pa sredstva prejemate tudi na tip naslova "Wrapped Segwit" ali "Taproot", morate uporabiti tudi razširjene javne ključe "Wrapped Segwit" oziroma "Taproot".`,
      title: "Zakaj je tu več xpub-ov?"
    },
    privacy: {
      text: `xpub ali razširjen javni ključ za določen račun, razkriva celotno finančno zgodovino tega računa: transakcije v preteklosti, stanje računa in prihodnje transakcije. Dostop do xpub-a pa nikomur ne omogoča premika vaših kovancev.

V kolikor nekomu posredujete xpub se morate zavedati, da lahko ta oseba ali podjetje vidi vse dogajanje na temu računu (za vsak naslov tega računa). Premislite torej katera in koliko sredstev boste upravljali na računu, ki ga dajete nekomu na vpogled.`,
      title: "Ali moram svoje xpub-e ohraniti zasebne in na varnem?"
    },
    verify: {
      text: "Da, vedno je dobro dvakrat preveriti xpub. Če bo nekdo drug iz tega xpub-a ustvaril naslove za prejemanje in vam pošiljal denar, je to še posebej pomembno. Preveriti ga morate na napravi, da se prepričate, da ta xpub pripada vam. V nasprotnem primeru bi lahko vsa sredstva šla na napačne naslove (ki si jih morda ne lastite vi).",
      title: "Ali moram preveriti xpub na napravi?"
    },
    xpub: {
      text: `Razširjeni javni ključ (xpub) je osnovni ključ, iz katerega izhajajo vsi prejemni naslovi računa.
Tu jih prikazujemo za namene napredne uporabe, kot na primer za uporabo v opazovalnih denarnicah (watch only wallets), kot sta Electrum ali Sentinel. Če imate prejeme sredstev na različne tipe naslovov, uporabite "xpub" vseh tipov naslovov, da jih boste lahko videli vse svoje kovance v teh denarnicah.

Pozor, nekatere denarnice še ne podpirajo vseh tipov naslovov, kot je npr Taproot.`,
      title: "Kaj je razširjeni javni ključ?"
    }
  },
  accountRates: {
    text: "Menjalni tečaji se vsako minuto posodobijo s strani CoinGecko.",
    title: "Od kod izvirajo prikazani menjalni tečaji?"
  },
  accountReload: {
    text: "Vsi podatki o transakcijah se posodabljajo samodejno.",
    title: "Kako lahko ponovno naložim zgodovino transakcij?"
  },
  accountSendDisabled: {
    text: "Gumb »Pošlji« se aktivira, ko je stanje večje od nič.",
    title: "Zakaj ne morem poslati nobenega {{unit}}?"
  },
  accountSummaryAmount: {
    text: `Skupni znesek je vsota vseh vaših kripto računov. Menjalni tečaji so na voljo na spletnem mestu coingecko.com.

Opomba: Če MyEtherWallet uporabljate za žetone, ki jih BitBoxApp ne podpira, ti ne bodo vključeni v prikazani znesek.`,
    title: "Kako se izračunava skupni znesek?"
  },
  accountSummaryDescription: {
    text: "Tu si lahko ogledate gibanje vašega skupnega portfelja skozi čas. Povzetek posameznih računov je prikazan pod grafom.",
    title: "Kaj prikazuje ta stran?"
  },
  accountTransactionAttributesBTC: {
    text: `Virtualna velikost: Uporablja se za določanje omrežnine. Na omrežnini ste uspešno prihranili, ko je ta manjša od velikosti transakcije.
Velikost: Dejanska velikost transakcije v bajtih, ko je serializirana glede na izbrano verigo blokov.
Teža: Uvedena s sistemom Segwit, je nova metrika za ovrednotenje velikosti transakcij in blokov. Vsak bajt "segregated witness" šteje kot ena, vsi ostali kot štiri enote teže. Namesto enega megabajta dejanske velikosti je zdaj nova omejitev velikosti blokov na štiri milijone enot teže.`,
    title: "Kako je s podatki o Bitcoin transakcijah?"
  },
  accountTransactionAttributesGeneric: {
    text: `Potrditve: Ko se transakcija objavi v omrežju, je sprva nepotrjena. Počakati je potrebno da jo nek rudar vključi v blok in s tem potrdi (rudari). Po tem bo imela transakcija 1 (eno) potrditev. Vsak novi blok, ki se objavi v omrežju s to transakcijo, doda še eno potrditev. V splošnem velja, da trgovci in drugi prejemniki, kot dokončne sprejemajo samo transakcije s 3 do 6 potrditvami.
ID transakcije: Unikatna identifikacijska številka transakcije, ki jo lahko uporabite za iskanje v raziskovalcih verige blokov.
Omrežnina: Rudarjem se plača omrežnina (provizija), kot spodbuda za vključitev transakcij v bloke, ki jih rudarijo oz izračunavajo.
Če želite izvedeti več, kliknite gumb Pošlji.`,
    title: "Kaj je prikazano v podatkih o transakcijah?"
  },
  accountTransactionConfirmation: {
    text: "To je transakcija, ki je že objavljena v omrežju, vendar še ni potrjena.",
    title: "Kaj je nepotrjena transakcija?"
  },
  accountTransactionLabel: {
    text: "To je naslov, na katerega ste prejeli kovance ali iz njega kovance poslali.",
    title: "Kateri naslov je prikazan za vsako transakcijo?"
  },
  accountTransactionTime: {
    text: "Zabeležen čas, ko je transakcija potrjena v verigi blokov (v blockchainu).",
    title: "Kateri čas je prikazan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Za Bitcoin in Litecoin lahko odprete več računov. Po petih odprtih računih, lahko dodate novega le če je zadnji že v uporabi. Pri vseh preostalih kovancih podpiramo največ pet računov.",
      title: "Koliko računov lahko ustvarim?"
    },
    howtoAddTokens: {
      text: "Žetoni, ki uporabljajo standard ERC20, so vezani na določen Ethereum račun. Če želite omogočiti ali onemogočiti določen žeton, odprite »Upravljanje računov«, razširite račun Ethereum in vklopite ali izklopite želeni žeton.",
      title: "Kako lahko dodam dodatne žetone?"
    },
    moveFunds: {
      text: "Lahko a z običajno transakcijo, iz enega naslova na drugega. Računi so neodvisni med seboj, zato drugačna pot ni mogoča.",
      title: "Ali je možno premikati sredstva med računi?"
    },
    recoverAccounts: {
      text: "Da. BitBoxApp ustvarja račune z uveljavljenimi standardi, združljivimi z večino drugih kripto denarnic.",
      title: "Ali lahko obnovim račune na drugih denarnicah?"
    },
    whatAreAccounts: {
      text: "Vaša denarnica lahko upravlja več računov istega kovanca. Računi so koristni, če želite sredstva hraniti ločeno.",
      title: "Kaj so računi?"
    },
    whyIsThisUseful: {
      text: 'Računi so odlični za upravljanje sredstev za različne ljudi ali namene, ker so ločeni. Svoj "razširjeni javni ključ" računa lahko delite, ne da bi razkrili česarkoli o svojih drugih računih. To vam omogoča večkratno prejemanje sredstev brez ponovne uporabe naslovov, na primer prejemanja plače ali rednega nakupa kriptovalut.',
      title: "Zakaj je to uporabno?"
    }
  },
  appendix: {
    link: "Kontaktirajte nas!",
    text: "Imate še kakšno vprašanje?"
  },
  backups: {
    check: {
      text: "»Preverba varnostne kopije« služi preverjanju, ali imate pravilno ustvarjeno in aktualno varnostno kopijo, ki ustreza vaši trenutni denarnici. To uporabite tudi za preverjanje vašega gesla za obnovitev.",
      title: 'Kaj je "Preverba varnostne kopije"?'
    },
    encrypt: {
      text: "Ne, vendar je geslo za obnovo potrebno za pridobitev denarnice iz shranjenega semena.",
      title: "Ali lahko kriptiram varnostno kopijo?"
    },
    howOften: {
      text: `Varnostna kopija se ustvari samodejno, ko ustvarite novo denarnico. Novo varnostno kopijo morate ustvariti le v primeru, če je vaša microSD kartica z aktualno varnostno kopijo izgubljena, poškodovana ali če želite več varnostnih kopij.
Po posameznih transakcijah vam ni treba ustvarjati novih varnostnih kopij! 
Vse transakcije, ki ste jih naredili po kreiranju varnostne kopije, lahko obnovite z eno samo varnostno kopijo.`,
      title: "Kako pogosto moram narediti varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena ki jo naprava shrani na microSD kartico. Seme, skupaj z vašim geslom za obnovitev, ustvari denarnico.",
      title: "Kaj je varnostna kopija?"
    }
  },
  backupsBB02: {
    check: {
      text: "To preverjanje vam omogoča, da ugotovite, ali imate delujočo varnostno kopijo, ki ustreza trenutni denarnici.",
      title: 'Kaj je "Preveri varnostne kopije"?'
    },
    encrypt: {
      text: "Ne. Prosimo, hranite microSD kartico na varnem mestu, saj vsebuje nešifrirano seme (seed) za obnovitev denarnice. Če želite zaščititi svoje seme z geselsko frazo, jo lahko omogočite v naprednih nastavitvah v razdelku Upravljanje naprave.",
      title: "Ali lahko šifriram varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena na microSD kartici.",
      title: "Kaj je varnostna kopija?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Ko je 2FA omogočena, je potrebno na uparjenem telefonu odobriti vse izvedene transakcije, da bi premaknili kovance. 
V ozadju se kriptirana unikatna vrednost pošlje v aplikacijo na telefonu, se tam dešifrira in ko pritisnete gumb "Sprejmi" se vrne v BitBox. Komunikacija z napravo se izvaja preko kanala, ki je bil vzpostavljen med uparjevanjem s telefonom, in to namizno aplikacijo.

POZOR: Predno omogočite 2FA, bodite pozorni, da varnostno kopirate svojo denarnico in uparite telefon. Ko je 2FA omogočena, je namreč microSD kartica onemogočena in uparjevanje s telefonom ni možno. To dvoje lahko znova omogočite le po ponastavitvi BitBox01, ki izbriše napravo (in s tem denarnico)!`,
      title: "Kako deluje dvofaktorska avtentikacija (2FA)?"
    },
    disable2FA: {
      text: `Če želite onemogočiti 2FA, morate ponastaviti (resetirati) in s tem izbrisati denarnico na BitBox-u in jo nato obnoviti iz varnostne kopije. Prepričajte se, da imate še vedno microSD kartico z varnostno kopijo in shranjeno veljavno in pravilno geslo za obnovo te denarnice.
Šele nato pritisnite »Ponastavi napravo«. Nastavite novo geslo naprave in izberite »Obnovite varnostno kopijo«. Izberite pravo varnostno kopijo, ki ste jo naredili iz denarnice, kliknite »Obnovi« in vnesite geslo za obnovitev, ki ste ga kreirali pri ustvarjanju denarnice.`,
      title: "Kako onemogočim dvo faktorsko avtentikacijo (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox lahko izklopite kadarkoli oz. iztaknete iz USB vhoda.",
      title: "Kako lahko odklopim BitBox?"
    },
    ejectSD: {
      text: "MicroSD lahko odstranite iz BitBoxa kadarkoli, razen, ko ste v procesu ustvarjanja ali obnavljanja varnostne kopije.",
      title: "Kdaj lahko odstranim microSD kartico?"
    },
    hiddenWallet: {
      text: "Gre za drugo denarnico na isti napravi, zaščiteno z različnim geslom naprave in obnovitvenim geslom, ki ga lahko uporabite za verodostojno zanikanje. Enako rezervno seme se uporablja za normalno in skrito denarnico, zato dodatna varnostna kopija ni potrebna.",
      title: "Kaj je skrita denarnica?"
    },
    legacyHiddenWallet: {
      text: "Najprej kliknite spodnji gumb (na voljo le, če je BitBox odklenjen z glavnim geslom naprave in je 2FA onemogočen), nato ponovno vklopite Bitbox in ga odklenite s svojim alternativnim geslom naprave.",
      title: "Kako dostopam do skrite denarnice?"
    },
    pairing: {
      text: "Ko naložite našo mobilno aplikacijo za iOS ali Android, skenirajte prikazano QR kodo, ki vzpostavi varen kanal med mobilno aplikacijo in to aplikacijo. Poskenirajte in sledite navodilom v mobilni aplikaciji.",
      title: "Kako varno uparite BitBox01 s telefonom"
    }
  },
  cointracking: {
    text: 'Kliknite gumb "Izvozi" in odprite mapo za prenose, v kateri boste našli izvoz v .CSV datoteki. Nato kliknite spodnjo povezavo, naložite to .CSV datoteko in uvozite podatke, da jih boste lahko uporabili za storitev CoinTracking in za pripravo davčnih poročil (samo za določene države!).',
    title: "Kako uvozim svoje transakcije v storitev CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Preberite si več o preverjanju pristnosti"
      },
      text: "Aplikacija BitBoxApp opravi preverjanje pristnosti na napravi BitBox02, da preveri, ali je naprava originalna. Preverjanje se opravi lokalno in brez povezave z zunanjim strežnikom.",
      title: "Kako poteka preverjanje pristnosti?"
    },
    name: {
      text: "To je ime vaše denarnice in varnostne kopije. Ime se uporablja za prihodnje varnostne kopije in se lahko uporablja za lažje razlikovanje med različnimi denarnicami. Spremenite ga lahko kadar koli, vendar upoštevajte, da bodo varnostne kopije, izdelane pred spremembo, še vedno uporabljale prejšnje ime.",
      title: "Za kaj se uporablja ime denarnice BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Preberite več o varnem čipu"
      },
      text: "Ker je verzija čipa dobra informacija o varnosti naprave. Najsodobnejši čip je ATECC608B z izboljšanimi varnostnimi funkcijami v primerjavi s starejšimi modeli.",
      title: "Zakaj prikazujemo model varnega čipa?"
    }
  },
  receive: {
    address: {
      text: `Pošljite ali predajte ga drugim, da vam lahko nanj pošiljajo kovance.
Priporočamo, da se s prejemnikom naslova prepričate, da je prejel enak naslov, kot ste mu ga poslali. Obstaja namreč možnost, da na poti do prejemnika naslova programska oprema zamenjala naslov s svojim.`,
      title: "Kaj lahko počnem z naslovom?"
    },
    addressChange: {
      text: "Takoj, ko opravite transakcijo, se na seznam samodejno doda nov naslov. Tako je vedno na voljo 20 naslovov, ki še nikoli niso prejeli nobenega kovanca.",
      title: "Kdaj se naslovi spremenijo?"
    },
    addressFormats: {
      text: `Privzet tip naslova je "Native Segwit" t.i. bech32 tip naslova. Podprt je že v mnogih drugih denarnicah in menjalnicah, saj ponuja najnižje provizije na transakcije. Poleg tega, lahko izbirate še med drugimi tipi naslovov. Novejši je Taproot (velja samo za Bitcoin), starejši pa "Wrapped Segwit".
`,
      title: "Kdaj uporabiti »Spremenite tip naslova«?"
    },
    howVerify: {
      text: `Če imate BitBox01 kliknite ikono BitBox na stranskem stolpcu na levi strani in glejte poglavje seznanitve. Vodnik se bo posodobil in od tam lahko nadaljujete po navodilih.
Z BitBox02 lahko med postopkom pošiljanja/prejemanja preverite naslove neposredno na napravi.`,
      title: "Kako lahko varno preverim naslov?"
    },
    plugout: {
      text: "Ne, BitBox lahko odklopite. Ko pošljete kovance na naslov generiran z BitBox02, vam naprave ni treba pustiti priključene v računalnik ali telefon.",
      title: "Je potrebno imeti BitBox02 priklopljen vse dokler ne prejmem sredstev?"
    },
    why20: {
      text: `Med zagonom aplikacija ustvari naslove, pridobljene iz vašega semena, in preveri, ali so prejeli sredstva. Aplikacija lahko ustvari skoraj neskončno število naslovov in bi lahko porabila leta, da določi pravo stanje za vsak naslov.
Da omejimo čas iskanja, se prikaz ustavi po prvih 20 najdenih naslovov, ki nikoli niso prejeli sredstev. To je namenska omejitev in 20 je de-facto standard, čeprav je število poljubno. To je 20 naslovov, med katerimi lahko izbirate.`,
      title: "Zakaj le 20 naslovov?"
    },
    whyMany: {
      text: `Za ohranjanje vaše zasebnosti in varnosti nikoli ne uporabite istega naslova dvakrat. 
Če ste že uporabili naslov, kliknite na puščico v desno za nov naslov. Naenkrat lahko ustvarite do 20 naslovov. Na naslove lahko gledate, kot na številke izdanih računov. Vsi naslovi so pridobljeni iz istega semena.`,
      title: "Zakaj toliko naslovov?"
    },
    whyVerify: {
      text: `Vašemu računalniku ne zaupajte, da ustvarja in prikazuje pristne naslove. Zaradi velike kompleksnosti je bistveno lažja tarča in bolj občutljiv kot denarnica s strojno opremo. 
Za BitBox01 - gumb za preverjanje naslova varno pošlje naslov na seznanjen mobilni telefon, iz katerega lahko tudi skenirate in preverite QR kodo. 
Na BitBox02 lahko naslov preverite neposredno na zaslonu.`,
      title: "Zakaj moram varno preveriti naslov?"
    }
  },
  send: {
    change: {
      text: "Višek (change) bo vrnjen na naslov Taproot, če imate vsaj en Taproot UTXO (Taproot naslov z nekaj sredstvi). Če uporabljate nadzor kovancev, bo sprememba vrnjena na Taproot naslov, če je med izbranimi UTXO vsaj en tipa Taproot. V vseh drugih primerih se sprememba vrne na Native Segwit (bech32) naslov.",
      title: "Kako je definirano vračilo viškov?"
    },
    fee: {
      text: `Omrežnina (ali prostovoljni prispevek rudarjem, provizija) temelji na velikosti podatkov v transakciji in ne na njenem znesku. Ciljne omrežnine se izračunajo po algoritmu za ocenjevanje omrežnin Bitcoin Core glede na izbrano prioriteto. Prikažejo se, če imajo drugačno vrednost od spodnjih.
Varčna: 24 blokov (približno 4 ure za Bitcoin, 1 ura za Litecoin)
Nizka: 12 blokov (približno 2 uri za Bitcoin, 30 minut za Litecoin)
Običajna: 6 blokov (približno 1 ura za Bitcoin, 15 minut za Litecoin)
Visoka: 2 bloka (približno 20 minut za Bitcoin, 5 minut za Litecoin)
(Izračun bloka v Bitcoin omrežju traja v povprečju deset minut in 2,5 minute za Litecoin. Obremenitev omrežja in s tem omrežnine se lahko v zgornjih obdobjih močno razlikujejo.)`,
      title: "Kako se določi vrednost omrežnine?"
    },
    plugout: {
      text: "Ne, ko enkrat opravite prenos sredstev (transakcijo), vam BitBoxa ni treba imeti več priklopljenega. Lahko jo izključite.",
      title: "Ali moram imeti BitBox priklopljen ves čas pošiljanja?"
    },
    priority: {
      text: "Višjo omrežnino, ki ste jo pripravljeni plačati, hitreje bo vaša transakcija potrjena v omrežju.",
      title: "Kakšna je prednost omrežja?"
    },
    revert: {
      text: `Ko je transakcija podpisana in poslana (tj. predvajana v omrežje), je ni več mogoče razveljaviti. Pred podpisom torej preverite transakcije (vključno s provizijo)!
Če prejemnika poznate in vam je pripravljen poslati isti znesek (minus transakcijske provizije), mu lahko pošljete nov naslov za prejem kovancev.`,
      title: "Ali lahko povrnem transakcijo?"
    },
    whyFee: {
      text: `S prispevkom oz. omrežnino, ki jo prinašajo, transakcije med seboj tekmujejo, da jih potrdi rudar. Rudarji praviloma najprej izberejo tiste transakcije, ki jim prinašajo višje omrežnine (provizije).
Bitcoin rudarji lahko za nagrado za opravljeno računsko delo poberejo omrežnine, plačane pri transakcijah, ki jih potrdijo, skupaj z novo nastalimi bitcoini. Rudarjenje je specializiran in konkurenčen trg, kjer se nagrade delijo glede na število opravljenih izračunov. `,
      title: "Zakaj obstaja omrežnina?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Če se želite s svojim vozliščem (full node) povezati le, ko ste v istem omrežju (npr. domači wifi), zadostuje uporaba običajne omrežne komunikacije.
V tem primeru je priporočljivo, da strežnik Electrum zagotovi potrdilo TLS za šifriranje komunikacije.
Če se nameravate s svojim vozliščem povezati od kjer koli drugje, je boljša možnost uporaba omrežja Tor. V tem primeru ni potrebno potrdilo TLS.`,
      title: "Ali naj uporabim nešifrirano povezavo TCP, TLS ali Tor?"
    },
    instructions: {
      link: {
        text: "Vodnik za povezavo lastnega vozlišča"
      },
      text: "Za obširnejša navodila obiščite naš vodič (v angleščini):",
      title: "Kako povežem BitBoxApp s svojim polnim vozliščem?"
    },
    options: {
      text: `Obstaja več možnosti za postavitev lastnega vozlišča, kot na primer nakup končanega izdelka, ki je namenjen le temu, izdelava lastnega ali zagon programja Bitcoin Core na računalniku.
Če želite BitBoxApp povezati s svojim vozliščem, se prepričajte, da na njem teče tudi strežnik Electrum. To je namenski program, ki aplikaciji denarnice (kot je BitBoxApp) omogoča komunikacijo s polnim vozliščem.
Podprte možnosti vključujejo programje Electrs, Electrum Personal Server (EPS) ali Bitcoin Wallet Tracker (BTW).`,
      title: "Kakšne možnosti obstajajo za zagon/nakup vozlišča?"
    },
    tor: {
      text: `Tor pomeni 'The Onion Router', ki je brezplačna in odprtokodna programska oprema, ki ponuja višjo stopnjo zasebnosti in je še posebej uporabna pri uporabi Bitcoina.
Če se nameravate povezati s vozliščem prek omrežja Tor, se prepričajte, da je Tor nameščen na računalniku in nato v nastavitvah BitBoxApp omogočite Tor Proxy.
V večini operacijskih sistemov obstaja dva načina dostopa do Tor-a:
1. Brskalnik Tor: prenesite in odprite brskalnik Tor. To bo omogočilo BitBoxApp, da se poveže z omrežjem Tor. V nastavitvah vpišite vrata (port) 9150 v nastavitvah za proxy strežnik.
2. To v ozadju: Namestite demon Tor, ki vedno deluje v ozadju operacijskega sistema. Nato se lahko BitBoxApp poveže preko Tor-a z nastavitvijo vrat 9050 v nastavitvah za proxy strežnik.`,
      title: 'Kaj je Tor, Tor proxy in kater "port" naj uporabim?'
    },
    what: {
      text: "Denarnico lahko povežete s svojim polnim vozliščem, namesto da uporabljate strežnike podjetja Shift.",
      title: "Kaj je to?"
    },
    why: {
      text: `Vzdrževanje lastnega vozlišča ni potrebno, izboljša pa zasebnost in zniža potrebo po zaupanju drugim.
Prvič, to pomeni, da bolj zasebno uporabljate Bitcoin (omrežje), saj se BitBoxApp ne bo povezal z našimi strežniki, da bi prejel vašo zgodovino transakcij; namesto tega bo podatke prejel od vašega vozlišča.
Drugič, imeti lastno vozlišče pomeni, da vozlišče samo preverja vse transakcije in poskrbi, da so pravila omrežja Bitcoin za vas uveljavljena.`,
      title: "Zakaj naj poganjam svoje vozlišče?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (satoši, krajše sat) je najmanjša enota Bitcoina. En satoši je stomilijonska enota bitcoina (0,00000001 BTC). Ime je dobila po avtorju Bitcoina, Satoshiju Nakamotu.",
      title: "Kaj je Satoshi?"
    },
    servers: {
      text: `Ta aplikacija komunicira s strežniki podjetja Shift Crypto AG, da preveri posodobitve, naloži transakcije in pošilja informacije v uparjene mobilne aplikacije.
Aplikacija pridobiva najnovejše tečaje pri CoinGecko. Vse konverzije so izračunane lokalno, kar pomeni, da se podatki o znesku vaše transakcije nikoli ne pošljejo ven iz aplikacije.
Opomba: Za Ethereum in ERC20 žetone uporabljamo API-je Etherscan.io.`,
      title: "S katerimi strežniki govori ta aplikacija?"
    }
  },
  title: "Vodič vam v pomoč",
  toggle: {
    close: "Zapri",
    open: "Pomoč"
  },
  trackingModePortfolioChart: {
    text: "V namizni aplikaciji pojdite z miško čez graf. V mobilni aplikaciji, pritisnite na grafi in podrsajte po njem levo ali desno.",
    title: "Kako preverim vrednosti na grafu za določen dan?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Ponastaviti morate napravo (reset) in obnoviti denarnico iz varnostne kopije z geslom za obnovitev.",
      title: "Kaj lahko storim, če pozabim geslo naprave?"
    },
    reset: {
      text: "Vnesite napačno geslo naprave 15-krat. V zadnjih nekaj poskusih je potreben dolg dotik naprave.",
      title: "Kako ponastavim napravo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Ko jo vstavite, naprava utripne enkrat. Prepričajte se, da je pravilno obrnjena v USB reži. Če imate težave, nas kontaktirajte preko spodnje povezave.

BitBox01 ni podprt v mobilni aplikaciji. Za povezavo z BitBox01 uporabite BitBoxApp na namizju.`,
      title: "Moj BitBox01 ni prepoznan"
    },
    getDevice: {
      link: {
        text: "Naročite BitBox"
      },
      text: "BitBox lahko kupite v naši spletni trgovini (link spodaj) ali pri naših partnerjih.",
      title: "Kje lahko kupim BitBox?"
    },
    internet: {
      text: "Da, internetna povezava je potrebna za sinhronizacijo denarnice, za pošiljanje transakcij in pridobivanje menjalnih tečajev.",
      title: "Ali ta aplikacija zahteva internetno povezavo?"
    },
    lostDevice: {
      link: {
        text: "Varnostne kopije"
      },
      text: "Vaša sredstva lahko enostavno obnovite z novo BitBox denarnico ali z drugo BIP39 napravo. V pomoč smo spisali postopek v članku:",
      title: "Izgubil sem napravo. Kaj pa zdaj?"
    },
    useWithoutDevice: {
      text: "Na žalost to trenutno še ni mogoče.",
      title: "Ali lahko aplikacijo uporabljam brez BitBoxa?"
    },
    welcome: {
      text: `Podjetje Shift Crypto iz Švice se vam zahvaljuje, ker uporabljate BitBoxApp. 
Vaše predloge za izboljšavo zelo cenimo in si jih želimo. Vaš odziv pričakujemo na povezavi na dnu.`,
      title: "Pozdravljeni v aplikaciji BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Če uporabljate nov telefon ali računalnik z aplikacijo BitBoxApp, se boste morali ponovno povezati z DApps. Svoje kovance boste nato ponovno videli v izbranih DApp kot običajno.",
      title: "Mojih prejšnjih povezav ne vidim."
    },
    supportedNetworks: {
      text: "V BitBoxApp je trenutno z WalletConnect podprto le Ethereum omrežje. Za uporabo drugih verig, združljivih z EVM, uporabite storitev Rabby v brskalniku (browser extension wallet).",
      title: "Katera omrežja so podprta?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikacijski protokol za web3 aplikacije. Omogoča vam priročno povezavo z decentraliziranimi avtonomnimi aplikacijami (DApps) in spletnimi denarnicami, ki temeljijo na Ethereumu, brez uporabe aplikacije tretje osebe. To je še posebej uporabno za uporabnike aplikacije BitBoxApp na Androidu.",
      title: "Kaj je WalletConnect?"
    }
  }
}, headerssync$2 = {
  blocksSynced: "{{blocks}} sinhroniziranje blokov"
}, hiddenWallet$2 = {
  info1HTML: "Za namene verodostojnega zanikanja (obstoja prave denarnice) lahko ustvarite skrito denarnico na podlagi <strong>drugačne (alternativne)</strong> kombinacije gesla in gesla za obnovitev varnostne kopije. ",
  info2HTML: "Določite geslo naprave in geslo za obnovitev, ki ju želite povezati s spodnjo skrito denarnico. To geslo naprave in geslo za obnovitev morata biti <strong> drugačna </strong> od tistih, ki ste ju določili za primarno denarnico.",
  passwordLabel: "Skrito geslo za obnovitev",
  passwordPlaceholder: "Potrdite skrito geslo za obnovitev",
  pinLabel: "Geslo za skrito denarnico",
  pinRepeatLabel: "Ponovite geslo skrite denarnice",
  pinRepeatPlaceholder: "Prosimo potrdite geslo skrite denarnice",
  success: "Skrita denarnica je bila uspešno ustvarjena. Iztaknite in ponovno vtaknite BitBox v USB vhod, da jo odklenete."
}, initialize$2 = {
  create: "Ustvarite geslo naprave",
  creating: "Kreiram geslo naprave ...",
  error: {
    e102: "Geslo naprave mora vsebovati najmanj 4 znake."
  },
  info: {
    description1: "Vpišite novo geslo naprave. To bo uporabljeno za odklepanje BitBox-a.",
    description2: "Uporabite lahko številke, črke in simbole. Daljša gesla so varnejša.",
    description3: "Če izgubite geslo naprave, boste morali ponastaviti napravo in obnoviti varnostno kopijo denarnice.",
    subtitle: "Zdaj boste vpisali novo geslo naprave",
    title: "Izvaja se prvi zagon vaše naprave"
  },
  input: {
    label: "Geslo naprave",
    labelRepeat: "Ponovite geslo naprave",
    placeholderRepeat: "Prosimo, potrdite geslo naprave"
  }
}, invalidFormat$2 = "Neveljavna oblika", language$3 = {
  title: "Izberite jezik"
}, legacyhiddenwallet$2 = {
  disable: "Onemogoči starejšo skrito denarnico (legacy wallet)",
  enable: "Omogoči skrito denarnico starejšega formata (legacy)",
  successDisable: "Skita denarnica bitcoin računa starejše generacije je onemogočena.",
  successEnable: "Skrita denarnica starejšega formata je uspešno omogočena. Znova priključite svoj BitBox in skrbno vnesite geslo naprave za dostop do starejše skrite denarnice."
}, loading$2 = "nalaganje…", manageAccounts$1 = {
  accountHidden: "Ta račun je bil skrit in ga ni več na seznamu opazovalnih računov. Če ga želite videti ponovno, priklopite vaš Bitbox02.",
  editAccount: "Uredi",
  editAccountNameTitle: "Uredi ime računa",
  noAccounts: "ni računov",
  settings: {
    hideTokens: "Skrij žetone",
    showTokens: "Prikaži žetone ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Dodajaj in aktiviraj/deaktiviraj račune",
  title: "Upravljanje računov",
  watchAccount: "Opazovalni račun",
  watchAccountDescription: "Ta račun je del vaših opazovalnih računov. Z drsnikom ga lahko skrijete."
}, mobile$2 = {
  usingMobileDataWarning: `Uporaba podatkov na mobilni napravi: ta aplikacija lahko po odklepanju računa naloži do nekaj sto megabajtov podatkov. Če želite preprečiti uporabo mobilnih podatkov, se povežite z Wi-Fi omrežjem. 
To sporočilo ne bo več prikazano, če ga ugasnete.`
}, newSettings$1 = {
  about: {
    appVersion: {
      title: "Verzija aplikacije"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Prepreči dostop do aplikacije z zaklepom zaslona.",
      title: "Zaklep zaslona"
    },
    coinControl: {
      description: "Za večjo stopnnjo zasebnosti izberite kateri UTXO naj bo del transakcije."
    },
    customFees: {
      description: "To vam omogoča vnos poljubne višine provizije za transakcijo."
    },
    torProxy: {
      description: "Povežite se preko Tor omrežja za več zasebnosti."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Te dodatne valute lahko izmenjujoče prikazujete na strani računov.",
      title: "Aktivne valute"
    },
    darkmode: {
      description: "BitBoxApp v temnem načinu"
    },
    defaultCurrency: {
      description: "Izberite privzeto valuto",
      title: "Privzeta valuta"
    },
    hideAmounts: {
      description: "Prikaže preklopnik za skrivanje stanja in zneskov, za vašo večjo zasebnost, ko aplikacijo uporabljate na javnem mestu.",
      hideAmounts: "Skrij zneske",
      showAmounts: "Prikaži zneske",
      title: "Dovoli skrivanje zneskov"
    },
    language: {
      description: "Izberite jezik, ki ga želite uporabiti v BitBoxApp-u.",
      title: "Jezik"
    },
    toggleSats: {
      description: "Prikažite ali skrijte Satošije (sats)."
    }
  }
}, note$3 = {
  input: {
    description: "(opcijsko)",
    placeholder: "Dodaj opombo"
  },
  title: "Opomba"
}, notification$2 = {
  newTxs_one: "{{count}} novih transakcij na: {{accountName}}",
  newTxs_other: "{{count}} novih transakcij na: {{accountName}}"
}, pairing$2 = {
  aborted: {
    text: "Uparjanje je bilo prekinjeno s strani mobilne aplikacije.",
    title: "Prekinjeno"
  },
  button: "Uparite z mobilno aplikacijo",
  confirm: "Ali ste prepričani, da želite upariti svoj BitBox? Upoštevajte, da je po uparitvi mobilni telefon vedno potreben za izvedbo transakcije.",
  connectOnly: {
    button: "Povežite z mobilno aplikacijo",
    title: "Skenirajte z našo mobilno aplikacijo tako, da izberete menijsko točko »Connect to new desktop app«"
  },
  error: {
    text: "Nekaj ​​je šlo narobe. Prosimo, začnite znova.",
    title: "Napaka"
  },
  pullFailed: {
    text: "Sporočila iz mobilnega telefona ni bilo mogoče pridobiti prek relejskega strežnika. Strežnik je morda brez povezave. Prosimo, obrnite se na podporo.",
    title: "Parjenje ni uspelo"
  },
  reconnectOnly: {
    button: "Ponovno vzpostavite povezavo z mobilno aplikacijo"
  },
  scanningFailed: {
    text: "Mobilnik ni uspešno skeniral sporočila. Prosimo poskusite ponovno.",
    title: "Skeniranje ni uspelo"
  },
  start: {
    hideAppQRCode: "Skrij kodo QR",
    revealAppQRCode: "Prikaži QR kodo",
    step1: "Če mobilne aplikacije še nimate, lahko skenirate QR kodo za Apple App Store ali Google Play Store, odvisno od tega, kateri telefon imate.",
    step2: "Skenirajte z našo mobilno aplikacijo, ki jo najdete pod imenom „Digital Bitbox 2FA“ v trgovinah z aplikacijami za iOS in Android:"
  },
  started: {
    text: "Prosimo sledite navodilom v mobilni aplikaciji.",
    title: "Super"
  },
  success: {
    text: "Čestitamo, uspešno ste uparili BitBox z mobilno aplikacijo!",
    title: "Uspelo je!"
  },
  timeout: {
    text: "Seznanitev je potekla po dveh minutah. Začnite znova, če želite BitBox še vedno upariti z mobilno aplikacijo.",
    title: "Odmor"
  },
  title: "Mobilno seznanjanje"
}, passphrase$1 = {
  considerations: {
    button: "",
    message: `Geselska fraza zagotavlja dodaten nivo zaščite varnostni kopiji vaše denarnice (bodisi na microSD kartici ali 24 besedam). Če nekdo pridobi dostop do vaše varnostne kopije (na kartici ali besede), bo za dostop do vaše denarnice potreboval tudi geselsko frazo.

To pa pomeni, da boste potrebovali <strong>oboje - geselsko frazo in varnostno kopijo denarnice</strong>, da bi obnovili tako zaščiteno denarnico, če se vaš BitBox02 pokvari ali ga izgubite. Če pozabite ali izgubite to geslo, boste izgubili dostop do vseh kovancev v tej denarnici!

Geselsko frazo shranjujte ločeno od varnostne kopije. S tem preprečite vdor v denarnico, če nekdo najde le njeno varnostno kopijo.`,
    title: "Razmislek o varnostni kopiji"
  },
  disable: "Onemogoči geselsko frazo",
  disableInfo: {
    button: "Izklopi",
    message: `Po izklopu geselske fraze, vas BitBox ob odklepu ne bo več spraševal po njej. S tem boste vstopili v privzeto denarnico.

Vsi kovanci v denarnici, zaščiteni z izbrano geselsko frazo, bodo še vedno v tej denarnici, vendar do njih ne boste mogli dostopati, saj boste po odklepanju naprave odprli svojo privzeto denarnico.

Da bi znova odprli denarnico, ki je zaščitena z geselsko frazo, enostavno ponovno omogočite to funkcijo in vnesite izbrano geselsko frazo na BitBox02.

<strong>Namig:</strong> Kljub temu lahko dostopate do privzete denarnice, le geselske fraze ne vtipkavajte ob vstopu v BitBox.`
  },
  enable: "Omogoči geselsko frazo",
  error: {
    e104: "Sprememba geselske fraze je bila prekinjena..."
  },
  how: {
    button: "Kako izgleda",
    message: `Geselska fraza ne deluje tako kot "navadno" geslo, ki ste ga vajeni. Če se ob vnosu geselske fraze zatipkate, na napako NE boste opozorjeni. To pa zato, ker <strong>vsaka geselska fraza ustvari različno a veljavno denarnico</strong>. To pomeni, da lahko uporabljate več geselskih fraz za več denarnic na BitBox02. Vse te denarnice so na BitBox02 dostopne le po vsakokratnem vnosu ustrezne geselske fraze.

Ob priključitvi naprave BitBox02 boste, kot običajno, pozvani k vpisu gesla naprave. Nato boste morali v napravo vnesti še geselsko frazo.

Po vnosu fraze se vam bo ta prikazala na zaslonu. Tako boste lahko potrdili, da ste jo vnesli pravilno oz. da ste vnesli željeno.
`,
    title: "Kako deluje"
  },
  intro: {
    message: `Geselska fraza zagotavlja dodatni nivo varnosti za vašo denarnico.
Spoznajmo, kako deluje.`,
    title: "Vnesite željeno geselsko frazo"
  },
  progressDisable: {
    message: "Na BitBoxu potrdite, da želite <strong>onemogočiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  progressEnable: {
    message: "Na BitBoxu potrdite, da želite <strong>omogočiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  successDisabled: {
    message: `Geselska fraza <strong>uspešno omogočena</strong>!
Odslej jo boste vselej vnašali v napravo.`,
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    title: "Geselska fraza omogočena"
  },
  successEnabled: {
    message: `Geselska fraza <strong>uspešno onemogočena</strong>!
Naprava vas po njej ne bo več spraševala ob odklepanju.`,
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    tips: "Namigi",
    tipsList: [
      "Priporočamo, da v denarnico zaščiteno s frazo najprej pošljete majhen znesek. Nato BitBox ponovno priklopite in vnesite geslo ter frazo. Če vse vnesete pravilno, boste lahko videli in upravljali kovance na tej denarnici.   ",
      "Če želite dostopati do privzete denarnice, nezaščitene z geselsko frazo, to še vedno lahko storite tako, da preskočite korak, ko vas BitBox povabi k vnosu faze."
    ],
    title: "Geselska fraza onemogočena"
  },
  summary: {
    button: "Omogočite geselsko frazo",
    title: "Povzetek",
    understand: "Razumem kako deluje geselska fraza in vsa povezana tveganja.",
    understandList: [
      "Geselska fraza je dodaten nivo zaščite za varnostno kopijo.",
      "Če vnesete različno geselsko frazo, boste vedno ustvarili različno denarnico.",
      "Za obnovitev denarnice potrebujete <strong>oboje, geselsko frazo in varnostno kopijo</strong>.",
      "Če pozabite ali izgubite svojo geselsko frazo, <strong>izgubite dostop do svojih kovancev.</strong>"
    ]
  },
  what: {
    button: "Spoznajte kako to deluje",
    message: `Denarnica je ustvarjena (pridobljena) iz zelo velikega naključnega števila, znanega tudi kot seme (seed). To seme je ustvarjeno ob prvi nastavitvi naprave BitBox02 in je varnostno kopirano na microSD kartici ali z 24 besedami. Vsakdo, ki ima dostop do semena, ima popoln nadzor nad sredstvi v tej denarnici.

Geselska fraza ali passphrase je <strong>opcijska skrivnost</strong>, ki je dodana semenu. Pri uporabi geselske fraze vsaka ustvari novo denarnico na podlagi preračuna semena + geselske fraze. Geselska fraza je lahko karkoli: črke, besede, posebni znaki ali pa je lahko celo prazna. Privzeta denarnica dejansko izhaja iz semena + prazne fraze.

"Passphrase" ali geselska fraza je del BIP39 priporočila, kar pomeni, da je kompatibilna z vsemi denarnicami, ki sledijo temu priporočilu (ali kvazi standardu)`,
    title: "Kaj je geselska fraza?"
  },
  why: {
    button: "Zakaj uporabiti geselsko frazo?",
    message: `BitBox02 varuje seme (skrivnost, ki jo ustvari) pred odtujitvijo (kopiranjem) iz same naprave, vendar varnostna kopija (na microSD kartici ali izpis 24 besed) omogoča popoln dostop do denarnice. Zato jo je treba hraniti na varnem mestu!

Ker geselska fraza ustvari novo denarnico z uporabo vašega obstoječega semena, denarnica zaščitena s frazo za obnovo zahteva oboje <strong>varnostno kopijo in geselsko frazo</strong>. Prednost tega je, da če nekdo najde vašo varnostno kopijo (v obliki 24 besed ali na microSD kartici), za dostop do kovancev še vedno potrebuje geselsko frazo.

Poleg tega lahko z uporabo več geselskih fraz na enem BitBox-u upravljate mnogo med seboj ločenih denarnic!`,
    title: "Zakaj uporabiti geselsko frazo?"
  }
}, password$2 = {
  show: "Prikaži {{label}}",
  warning: {
    caps: "OPOZORILO: Vklopljene imate VELIKE ČRKE (⇪)",
    paste: 'da prilepite besedilo, omogočite "PRIKAŽI {{label}}"'
  }
}, random$3 = {
  button: "Ustvari naključno število",
  description: "BitBox je ustvaril {{bits}}-bitno naključno število:"
}, receive$4 = {
  changeScriptType: "Spremenite tip naslova",
  label: "Vaš naslov",
  onlyThisCoin: {
    description: "Če želite prejemati druge podprte žetone, jih omogočite v nastavitvah. Če na naslove, ki so na voljo nakažete/pošljete nepodprte žetone, zelo verjetno ne bodo vidni/ dostopni.",
    warning: "Prepričajte se, da na ta naslov prejemate le {{coinName}}."
  },
  scriptType: {
    p2tr: "Taproot (najnovejša oblika)",
    p2wpkh: "Native Segwit (privzeto)",
    "p2wpkh-p2sh": "Wrapped Segwit (starejši tip)"
  },
  selectAccount: "Izberite račun",
  showFull: "Pokaži in preveri polni naslov na napravi",
  taprootWarning: "Opomba: Taproot je nov tip Bitcoin naslova, ki ni še povsod podprt. Sredstva, prejeta na Taproot naslov, morda ne bodo vidna v drugih denarnicah s katerim dostopate do svoje naprave. Številne denarnice in menjalnice še niso zmožne poslati na Taproot naslove.",
  title: "Prejmi {{accountName}}",
  verify: "Skrbno preverite naslov",
  verifyBitBox01: "Preverite naslov v mobilni aplikaciji",
  verifyBitBox02: "Preverite naslov na BitBox02",
  verifyInstruction: "Preverite, da se prikazan naslov ujema s tistim, ki je prikazan na BitBoxu in to potrdite na napravi.",
  warning: {
    secureOutput: "Prosimo, uparite BitBox z mobilno aplikacijo, da omogočite varno preverjanje naslovov. Pojdite na »Upravljanje naprave« v stranski vrstici."
  }
}, reset$2 = {
  description: "Vsi podatki na napravi bodo izbrisani. To vključuje vaš zasebni ključ!",
  notReset: "Naprava NI ponastavljena.",
  title: "Ponastavi napravo (reset)",
  understand: "Imam varnostno kopijo in poznam geslo za njeno obnovitev",
  understandBB02: "Imam veljavno varnostno kopijo"
}, securityInformation$2 = {
  create: {
    description1: "Priporočamo, da prvo nastavitev naprave izvedete v varnem okolju, kjer vas nihče ne opazuje in ne more beležiti vnašanja gesla.",
    description2: "Od vas se bo zahtevalo, da ustvarite dve gesli.",
    description3: "Prvo je <strong> geslo naprave</strong>, ki odklene vaš BitBox (napravo). Pozneje ga lahko spremenite.",
    description4: "Drugo je <strong>geslo za obnovitev</strong>, ki odklene vašo denarnico. Tega gesla kasneje ni mogoče spremeniti!",
    description5: "Ko ustvarite denarnico, bo ta shranjena v datoteko na microSD kartico. To lahko uporabite v nujnih primerih za povrnitev sredstev s pomočjo  <strong>gesla za obnovitev</strong>.",
    title: "Pomembne informacije"
  },
  restore: {
    description1: "Vstaviti boste morali microSD kartico, ki ste jo uporabili za shranjevanje varnostne kopije.",
    description2: "Če želite obnoviti denarnico, boste potrebovali geslo za obnovitev.",
    description3: "Bodite previdni in natančni pri vnosu gesla. Vsako geslo, ki ga vnesete, bo ustvarilo novo veljavno denarnico. Če vnesete napačno geslo, se vam bo verjetno prikazalo stanje denarnice, ki ga ne pričakujete.",
    title: "Varnostne informacije"
  }
}, seed$2 = {
  agreements: {
    "funds-access": "da ostanem BREZ DOSTOPA do svojih sredstev, če pozabim to geslo!",
    "password-change": "pozneje NI MOŽNO spremeniti gesla za obnovitev!",
    "password-required": "Obnovitveno geslo je potrebno za obnovitev denarnice iz varnostne kopije"
  },
  create: "Ustvari denarnico",
  creating: "Ustvarjanje denarnice",
  description: "Razumem da:",
  error: {
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e200: "Za kreiranje nove denarnice morate v BitBox vstaviti microSD kartico. S tem omogočite samodejno kreiranje varnostne kopije."
  },
  info: {
    button: "Zdaj nastavite geslo za obnovo denarnice",
    description1: "Vstavite microSD kartico v BitBox",
    description2: 'Ustvarite geslo za obnovitev denarnice in izberite "Nastavi geslo za obnovitev"',
    description3: "Varnostna kopija na microSD kartici in geslo za obnovitev je edina metoda za povrnitev sredstev v primeru izgubljenega, uničenega ali ukradene denarnice BitBox01.",
    description4: "Pozneje ni možno spremeniti gesla za obnovitev brez prenosa sredstev.",
    title: "Ustvarite novo denarnico"
  },
  password: {
    label: "Geslo za obnovitev",
    repeatPlaceholder: "Ponovite geslo za obnovitev"
  },
  walletName: {
    label: "Ime denarnice"
  }
}, seedRestore$2 = {
  error: {
    e200: "Obnova oz. priklic denarnice iz varnostne kopije zahteva microSD kartico."
  },
  info: {
    description1: 'Vstavite microSD kartico v BitBox in kliknite "Nadaljujte"',
    description2: "Izberite varnostno kopijo in kliknite »Obnovi«",
    description3: "Vnesite geslo za obnovo",
    description4: "Potrdite, da razumete, da bo napačno geslo ustvarilo drugo, novo denarnico.",
    title: "Kako obnoviti denarnico iz varnostne kopije"
  }
}, send$4 = {
  abort: "Transakcija je bila prekinjena.",
  address: {
    label: "Naslov prejemnika",
    placeholder: "Vnesite naslov"
  },
  amount: {
    label: "Znesek",
    placeholder: "Vnesite znesek"
  },
  availableBalance: "Razpoložljivo stanje",
  button: "Podpiši in pošlji",
  coincontrol: {
    address: "Naslov",
    outpoint: "",
    title: "Pošlji iz (output):"
  },
  confirm: {
    "selected-coins": "Izbrani kovanci",
    title: "Potrdite in pošljite transakcijo",
    total: "Skupaj"
  },
  error: {
    erc20InsufficientGasFunds: "Kot kaže na vašem računu ni dovolj ETH za plačilo transakcije za premik ERC02 žetona. Poskrbite za zadostno količino ETH na vašem Ethereum računu.",
    feeTooLow: "Omrežnina je prenizka",
    feesNotAvailable: "Provizije ni moč oceniti",
    insufficientFunds: "nezadostna sredstva",
    invalidAddress: "neveljaven naslov",
    invalidAmount: "neveljaven znesek",
    invalidData: "neveljavni podatki"
  },
  fee: {
    customPlaceholder: "Vnesite znesek",
    label: "Omrežnina",
    placeholder: "Ni na voljo"
  },
  feeTarget: {
    customLabel: "Stopnja provizije",
    customLabel_eth: "Vrednost Gas-a",
    description: {
      economy: "4 ure (24 blokov)",
      economy_eth: "30 minut ali manj",
      economy_ltc: "1 ura (24 blokov)",
      high: "20 minut (2 bloka)",
      high_eth: "30 sekund ali manj",
      high_ltc: "5 minut (2 bloka)",
      low: "2 uri (12 blokov)",
      low_eth: "5 minut ali manj",
      low_ltc: "30 minut (12 blokov)",
      normal: "1 ura (6 blokov)",
      normal_eth: "2 minuti ali manj",
      normal_ltc: "15 minut (6 blokov)"
    },
    estimate: "Predviden čas potrditve:",
    label: {
      custom: "Po meri",
      economy: "Ekonomična",
      high: "Visoka",
      low: "Nizka",
      normal: "Normalna"
    },
    placeholder: "Preračunavam..."
  },
  maximum: "Pošlji vse",
  maximumSelectedCoins: "Pošlji izbrane kovance",
  noFeeTargets: "Generirane provizije trenutno niso dostopne. Prosimo poizkusite ponovno ali vnesite poljubno višino provizije.",
  priority: "Omrežnina",
  scanQR: "Skenirajte QR kodo",
  signprogress: {
    description: "Ta transakcija vsebuje veliko podatkov. Če želite v celoti podpisati transakcijo, boste morali potrditi {{steps}} krat.",
    label: "V teku"
  },
  success: "Transakcija je bila podpisana in poslana.",
  title: "Pošlji {{accountName}}",
  toggleCoinControl: "Odpri nadzor nad kovanci",
  transactionDetails: "Podrobnosti transakcije"
}, settings$3 = {
  about: "O nastavitvah",
  accounts: "Računi",
  advancedSettings: "Napredne nastavitve",
  appearance: "Izgled",
  electrum: {
    add: "Dodaj strežnik",
    "add-server": "Dodaj",
    check: "Preveri",
    checkFailed: "Ni uspelo",
    checkSuccess: "Uspelo je vzpostaviti povezavo do {{host}}",
    checking: "Preverjam",
    "download-cert": "Prenesite oddaljeni certifikat",
    "remove-server": "Odstrani",
    removeConfirm: "Odstrani {{server}}?",
    reset: "Ponastavi na privzeto",
    resetConfirm: "Ali želite odstraniti vse strežnike in namestiti privzete strežnike?",
    servers: "Strežniki",
    step1: "1",
    "step1-text": "Vnesite končno točko.",
    step2: "2",
    "step2-text": "Vnesite certifikat strežniške verige potrdil. Lahko pa prenesete oddaljeno potrdilo in ga vizualno primerjate.",
    "step2-text-tcp": "Ta korak lahko preskočite, če ne želite uporabljati TLS.",
    step3: "3",
    "step3-text": "Preverite povezavo in dodajte strežnik.",
    step4: "4",
    "step4-text": "Znova zaženite denarnico. Če ne odstranite privzetih strežnikov, bo vaše lastno vozlišče dodano kot redundančno.",
    "title-btc": "Strežniki Bitcoin Electrum-a",
    "title-ltc": "Strežniki Litecoin Electrum-a",
    "title-tbtc": "Strežniki Bitcoin Testnet Electrum-a",
    "title-tltc": "Strežniki Litecoin Testnet Electrum-a"
  },
  expert: {
    coinControl: "Omogoči nadzor nad kovanci (Coin control)",
    electrum: {
      description: "Povežete lahko svoje Electrum vozlišče.",
      title: "Povežite svoje polno vozlišče"
    },
    fee: "Omogoči provizije po meri",
    setProxyAddress: "Nastavite naslov proxy strežnika",
    title: "Napredne nastavitve",
    useProxy: "Omogoči tor proxy",
    useSats: "Prikaži vrednosti v Satoshi-jih"
  },
  header: {
    home: "Domov"
  },
  info: {
    "out-of-date": "Na voljo je nova nadgradnja",
    title: "Info",
    "up-to-date": "Aplikacija je posodobljena",
    version: "Verzija aplikacije"
  },
  restart: "Znova zaženite BitBoxApp, da spremembe začnejo veljati.",
  services: {
    title: "Storitve"
  },
  success: "Iztaknite in ponovno vtaknite BitBox v USB, da začnejo veljati ustvarjene spremembe.",
  title: "Nastavitve"
}, setup$2 = "Nastavitev naprave", sidebar$3 = {
  buy: "Kupite kripto",
  device: "Upravljanje naprave",
  leave: "Zapusti",
  settings: "Nastavitve"
}, success$9 = {
  create: {
    info1: `Vaša denarnica je arhivirana na microSD kartico. 
Odstranite jo in jo varno shranite.`,
    info2: "Ustvarili ste varno geslo, ki odklene BitBox.",
    info3: "Ustvarili ste varno geslo za obnovitev denarnice, ki odklene sredstva in obnovi varnostne kopije.",
    summary: "Preberite povzetek storjenega:",
    title: "Uspelo je!"
  },
  getstarted: "Začnite",
  restore: {
    summary: "Uspešno ste obnovili denarnico.",
    title: "Uspelo je!"
  }
}, transaction$3 = {
  confirmation: "Št. potrditev",
  details: {
    activity: "Dejavnost",
    address: "Naslov",
    amount: "Znesek",
    date: "Datum",
    fiat: "V fiat valuti",
    fiatAmount: "Znesek v fiat valuti",
    fiatAtTime: "Vrednost v času transakcije",
    status: "Stanje",
    type: "Tip"
  },
  explorer: "ID transakcije",
  explorerTitle: "Odpri v zunanjem raziskovalcu",
  fee: "Omrežnina",
  fiatHistorical: "Zgodovinsko",
  gas: "Gas",
  note: {
    edit: "Uredi opombo",
    save: "Shrani opombo"
  },
  pending: "Nedokončana transakcija",
  size: "Velikost",
  status: {
    complete: "Zaključeno",
    failed: "Ni uspelo",
    pending: "V teku"
  },
  tx: {
    received: "Prejeto na",
    sent: "Poslano na"
  },
  vsize: "Virtualna velikost",
  weight: "Utež"
}, transactions$2 = {
  errorLoadTransactions: "Napaka pri nalaganju transakcij.",
  placeholder: "Ni transakcij."
}, unknownError$2 = "Prišlo je do neznane napake: {{errorMessage}}", unlock$2 = {
  description: "Vnesite geslo, da odklenete napravo.",
  error: {
    e109_normal: "Napačno geslo naprave. Št. poskusov pred ponastavitvijo naprave: {{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) Naslednja prijava zahteva daljše držanje gumba na dotik.",
    e113: "Zaradi prevelikega števila poskusov prijave, morate za novo prijavo pridržati tipko za dotik vsaj 4 sekunde."
  },
  input: {
    label: "Geslo naprave",
    placeholder: "...vnesite tukaj."
  },
  unlocking: "Odklepanje..."
}, upgradeFirmware$3 = {
  button: "Nadgradite strojno programsko opremo",
  description: "Ali želite nadgraditi strojno programsko opremo iz različice {{currentVersion}} na {{newVersion}}?",
  label: "Vaš BitBox zahteva nadgradnjo strojne programske opreme.",
  locked: "Za nadgradnjo z {{currentVersion}} na {{newVersion}}, izvedite dolg pritisk na LED lučko.",
  title: "Nadgradite strojno programsko opremo",
  unlocked: "Zaganjalnik (bootloader) je odklenjen. Če želite nadaljevati:",
  unlocked1: "Iztaknite in ponovno priključite svoj Bitbox",
  unlocked2: "Ko bo BitBox01 ponovno priključen bo zasvetila LED lučka",
  unlocked3: "Ko zasveti LED lučka, se jo dotaknite"
}, walletConnect$3 = {
  connect: {
    button: "Poveži",
    dappLabel: "Vnesi URI naslov za DApp",
    invalidPairingUri: "Napačen povezovalni URI"
  },
  dashboard: {
    allSessions: "Vse seje",
    disclaimer: "WalletConnect je protokol za povezavo z decentraliziranimi avtonomnimi aplikacijami (Dapps), ki temeljijo na Ethereumu. Te Dapps-e upravljajo tretje oseb (in ne Shift Crypto ali WalletConnect), zato se povežite le s tistimi, ki jim zaupate, in se prepričajte, da vedno veste, kaj podpisujete, ko opravljate transakcijo.",
    newConnection: "Nova povezava",
    noConnectedSessions: "Noben račun ni povezan s katero od DApp-ov"
  },
  invalidPairingChain: "Napaka pri potrditvi povezave. Prepričajte se, da uporabljate eno od podprtih verig: {{chains}}",
  pairingRequest: {
    approve: "Potrdi povezavo",
    reject: "Zavrni",
    title: "Zahteva za novo povezavo od"
  },
  pairingSuccess: "DApp je uspešno povezana. Nadaljujete lahko na spletni strani te DApp.",
  signingRequest: {
    account: "Račun",
    chain: "Omrežje",
    dapp: "Dapp",
    data: "Podatki",
    dataParsingError: "Podatkov nismo uspeli razčleniti",
    decodeError: "Sporočila nismo uspeli dekodirati",
    method: {
      sendTransaction: "Podpiši in pošlji transakcijo",
      signMessage: "Podpiši sporočilo",
      signTransaction: "Podpiši transakcijo",
      signTypedData: "Podpiši vnesene podatke"
    },
    successfullySigned: "Zahteva je uspešno podpisana",
    walletConnectRequest: "WalletConnect zahteva "
  },
  useNewUri: "Ta URI je bil že uporabljen za poskus vzpostavitve povezave. Uporabite nov URI.",
  walletConnect: "WalletConnect"
}, warning$8 = {
  receivePairing: "Prosimo, da seznanite BitBox01 s pametnim telefonom, da si omogočite varno preverjanje naslovov. Pojdite na »Upravljanje naprave« v stranski vrstici.",
  sdcard: "MicroSD kartico hranite ločeno od BitBoxa, razen ko upravljate z varnostnimi kopijami.",
  sendPairing: `Za varno preverjanje podrobnosti o transakcijah seznanite BitBox
z mobilno napravo. Pojdite na »Upravljanje naprave« v stranski vrstici.`
}, welcome$2 = {
  connect: "Vklopi BitBox02",
  getStarted: "Začnimo z namestitvijo strojne programske opreme (firmware)",
  insertBitBox02: "Na BitBox02 se dotaknite željene strani zaslona. ",
  insertDevice: "Za začetek, priključite denarnico",
  title: "Dobrodošli"
}, appTranslationsSL = {
  account: account$2,
  accountInfo: accountInfo$2,
  accountSummary: accountSummary$2,
  addAccount: addAccount$3,
  aopp: aopp$1,
  app: app$2,
  auth: auth$2,
  backup: backup$2,
  bb02Bootloader: bb02Bootloader$2,
  bitbox: bitbox$2,
  bitbox02Interact: bitbox02Interact$2,
  bitbox02Settings: bitbox02Settings$2,
  bitbox02Wizard: bitbox02Wizard$2,
  blink: blink$2,
  bootloader: bootloader$2,
  button: button$6,
  buy: buy$3,
  changePin: changePin$2,
  chart: chart$3,
  checkSDcard: checkSDcard$2,
  clickHere: clickHere$2,
  confirm: confirm$4,
  confirmOnDevice: confirmOnDevice$2,
  connectKeystore: connectKeystore$2,
  darkmode: darkmode$2,
  device: device$2,
  deviceLock: deviceLock$2,
  deviceSettings: deviceSettings$2,
  deviceTampered: deviceTampered$2,
  dialog: dialog$3,
  error: error$3,
  fiat: fiat$4,
  footer: footer$4,
  generic: generic$3,
  genericError: genericError$2,
  goal: goal$2,
  guide: guide$3,
  headerssync: headerssync$2,
  hiddenWallet: hiddenWallet$2,
  initialize: initialize$2,
  invalidFormat: invalidFormat$2,
  language: language$3,
  legacyhiddenwallet: legacyhiddenwallet$2,
  loading: loading$2,
  manageAccounts: manageAccounts$1,
  mobile: mobile$2,
  newSettings: newSettings$1,
  note: note$3,
  notification: notification$2,
  pairing: pairing$2,
  passphrase: passphrase$1,
  password: password$2,
  random: random$3,
  receive: receive$4,
  reset: reset$2,
  securityInformation: securityInformation$2,
  seed: seed$2,
  seedRestore: seedRestore$2,
  send: send$4,
  settings: settings$3,
  setup: setup$2,
  sidebar: sidebar$3,
  success: success$9,
  transaction: transaction$3,
  transactions: transactions$2,
  unknownError: unknownError$2,
  unlock: unlock$2,
  upgradeFirmware: upgradeFirmware$3,
  walletConnect: walletConnect$3,
  warning: warning$8,
  welcome: welcome$2
}, account$1 = {
  disconnect: "...החיבור אבד. מנסה שוב",
  export: "ייצוא",
  exportTransactions: "יצא עסקאות כקובץ רשומות לתיקיית ההורדות",
  fatalError: ".אירעה שגיאה לא צפויה",
  incoming: "נכנס",
  initializing: "מייבא נתונים מהבלוקצ׳יין..",
  reconnecting: "...החיבור אבד, מנסה להתחבר מחדש",
  syncedAddressesCount: "כתובות {{count}} סורק"
}, accountInfo$1 = {
  address: "כתובת",
  extendedPublicKey: "מפתח ציבורי מורחב",
  label: "פרטי חשבון",
  title: "פרטי חשבון",
  verify: "אמת עם ההתקן"
}, accountSummary$1 = {
  availableBalance: "יתרה זמינה",
  balance: "יתרה",
  exportSummary: "ייצא סיכום חשבונות כקובץ רשומות לתיקיית ההורדות",
  fiatBalance: "יתרה במטבע פיאט",
  name: "שם חשבון",
  noAccount: "אין חשבונות להצגה",
  title: "סיכום חשבונות",
  total: "סכום סופי",
  transactionHistory: "היסטוריית עסקאות"
}, addAccount$2 = {
  title: "הוספת חשבון"
}, app$1 = {
  upgrade: "גרסה חדשה של תכנה זו זמינה! אנא עדכן מ{{current}} ל{{version}}"
}, backup$1 = {
  check: {
    checking: "...בודק גיבוי",
    confirmTitle: "בדיקת גיבוי",
    notOK: ".הגיבוי לא תואם את הארנק",
    ok: ".הגיבוי תואם את הארנק",
    password: {
      label: "סיסמת שיחזור",
      placeholder: "סיסמת שיחזור",
      showLabel: "סיסמת שיחזור"
    },
    success: ":גיבוי אומת בהצלחה",
    title: "בדיקת גיבוי"
  },
  create: {
    alreadyExists: "?ברשותך גיבוי תקין. האם ליצור חדש כעת",
    fail: "!יצירת הגיבוי לא הצליחה",
    info: ".אנא הזן את סיסמת הגיבוי של ארנק זה לצורך אימות",
    name: {
      label: "שם הגיבוי",
      placeholder: "אנא תן שם לגיבוי"
    },
    password: {
      label: "סיסמת שיחזור",
      placeholder: "אנא הזן את סיסמת שיחזור"
    },
    title: "יצירת גיבוי",
    verificationFailed: ".סיסמת השחזור אינה תואמת את הארנק הנוכחי. גיבוי נוצר. אנא בדוק את סיסמת השיחזור שוב"
  },
  description: "בחר <strong>קובץ גיבוי לארנק</strong>",
  insert: "אנא הכנס כרטיס זיכרון בכדי לנהל גיבויים",
  insertButton: "הכנסתי את כרטיס הזיכרון",
  list: "גיבויי כרטיס הזיכרון שלך",
  noBackups: "כרטיס הזיכרון אינו מכיל גיבויים",
  restore: {
    confirmTitle: "שיחזור גיבוי",
    error: {
      e200: "כרטיס זיכרון לא נמצא",
      general: "שגיאה בשיחזור הגיבוי"
    },
    password: {
      label: "סיסמת שיחזור או סיסמת שיחזור מוסתרת",
      placeholder: "סיסמת שיחזור",
      repeatPlaceholder: "חזור פעם נוספת על סיסמת השיחזור",
      showLabel: "סיסמת שיחזור"
    },
    restoring: "...משחזר גיבוי",
    title: "שיחזור",
    understand: "אני מבין שסיסמת שחזור שגויה תיצור ארנק שונה"
  },
  showMnemonic: {
    description: `.כעת יוצגו 24 מילים, המייצגות גיבוי לארנק. רשום אותם על דף נייר

<strong>אל תאחסן אותם ברשת או תצלם אותם</strong>
<strong>אל תאמר מילים אלו בקול</strong>
<strong>הגיבוי אינו מאובטח בסיסמה</strong>

.לאחר מכן, תתבקש לאשר כל מילה`,
    title: "mnemonic seed -הצג"
  },
  title: "נהל גיבויים"
}, bb02Bootloader$1 = {
  abort: "אל תשדרג - קח אותי חזרה",
  advanced: {
    label: "הגדרות מתקדמות",
    toggleShowFirmwareHash: "הצג את גיבוב הקושחה בכל הדלקה "
  },
  flipscreen: "הפוך מסך",
  orientation: "?ההתקן מכוון בכיוון שגוי",
  success: "...עדכון צלח! ממשיך בעוד {{rebootSeconds}} שניות"
}, bitbox$1 = {
  error: {
    e10000: ".סיסמה שגויה עבור התקן נוכחי",
    e10001: "החלפת סיסמת התקן נכשלה",
    e102: ".הסיסמה חייבת להיות בת 4 תווים לפחות",
    e112: ".סיסמת התקן חבויה לא יכולה להיות זהה לסיסמת התקן ראשית"
  }
}, bitbox02Interact$1 = {
  confirmDate: "אשר את התאריך של היום בביטבוקס02",
  confirmDateText: ".התאריך ישמש ליצירת הגיבוי",
  confirmName: "אשר את השם בביטבוקס02",
  followInstructions: "אנא התקדם לפי הוראות בביטבוקס02",
  followInstructionsMnemonic: "mnemonic seed -המשך עם ההוראות לפי המופיע בביטבוקס02 שלך כדי לשחזר מ"
}, bitbox02Settings$1 = {
  deviceName: {
    current: "שם התקן נוכחי",
    input: "שם ביטבוקס02",
    placeholder: "שם התקן חדש",
    title: "קבע שם לביטבוקס02"
  }
}, bitbox02Wizard$1 = {
  attestationFailed: ".תעודת ההתקן נכשלה, זה יכול לנבוע מההפעלה מחודשת של היישום בזמן שהמכשיר חיכה לקלט מהמשתמש. התחבר מחדש ונסה שוב",
  backup: {
    point1: "בחר גיבוי מכרטיס הזיכרון",
    point2: "קבע סיסמה להתקן",
    restoreText: "!אוקי, משחזר מהגיבוי",
    text1: ".נהדר, הסיסמה לביטבוקס02 נקבעה והארנק נוצר. כעת זה הזמן ליצור את הגיבוי הראשון. אנא וודא שכרטיס הזיכרון נמצא בתוך הביטבוקס02 ולאחר-מכן המשך",
    text2: "אנא עקוב אחר ההוראות המופיעות על גבי מסך ההתקן בכדי ליצור גיבוי",
    text3: ".לאחר שהגיבוי נוצר, אנא הסר את כרטיס הזיכרון ואחסן את זה <strong>במקום בטוח</strong>. המידע המוכל בכרטיס הזיכרון אינו מוגן בסיסמה. לעולם אל תכניס את כרטיס הזיכרון לביטבוקס02 שאינו שלך",
    userConfirmation1: ".אני אמור לשמור על הגיבוי במקום מאובטח",
    userConfirmation2: ".הגיבוי שלי אינו מוגן בסיסמה. כל אחד עם גישה לגיבוי יכול לגשת לארנק שלי",
    userConfirmation3: ".אם אאבד או שהביטבוקס02 יפגע, הדרך היחידה לשחזר את הנכסים היא באמצעות הגיבוי שלי",
    userConfirmation4: ".אם אאבד או יפגעו, ביטבוקס02 והגיבוי, כל הנכסים יאבדו",
    userConfirmation5: "אני לא אמור להכניס את כרטיס הזיכרון לשום מחשב, פלאפון, מדפסת או מכשיר אחר מלבד לארנק"
  },
  create: {
    button: "הזן שם להתקן והמשך",
    info: ":מספר צעדים בסיסיים בהגדרת ההתקן",
    inputTitle: "שם ארנק",
    point1: "הזן שם להתקן",
    point2: "הזן סיסמה להתקן",
    point3: "צור גיבוי",
    text: "!אוקיי, בואו ניצור ארנק חדש"
  },
  createBackupFailed: ".יצירת גיבוי נכשלה, נסה שוב",
  initialize: {
    passwordText: ".עכשיו נקבע סיסמה להתקן. השתמש בחיישני הביטבוקס כדי לבחור סיסמה",
    passwordTitle: "קבע סיסמה לביטבוקס שלך",
    text: "צימוד התקן נוצר בהצלחה! כעת יש לאתחל את הביטבוקס02. התחל בבחירת יצירת ארנק חדש או שיחזור מתוך גיבוי קיים. <strong>אנא וודא כי הכנסת את כרטיס הזיכרון לביטבוקס02</strong>",
    tip: ".אנו ממליצים שתמשיך במקום בטוח",
    title: "אתחל את ההתקן"
  },
  insertSDCard: "<strong>אנא וודא שכרטיס הזיכרון נמצא בתוך הביטבוקס02</strong>",
  noPasswordMatch: ".סיסמאות לא תואמות, אנא נסה שוב",
  pairing: {
    failed: ".צימוד לא אושר. חבר מחדש את הביטבוקס02",
    paired: ".אישרת כי הצופן זהה בהתקן. אם זה נכון, אתה יכול להמשיך בלחיצה על הכפתור מטה",
    title: "אמת צופן צימוד",
    unpaired: ".ביטבוקס02 חדש זוהה. אנא אמת שהצופן תואם לזה המוצג על המסך. אם הצופן זהה, גע בלחצן האישור ולחץ על הכפתור מטה כדי להמשיך"
  },
  restoreFromMnemonic: {
    failed: ".נכשל, אנא נסה שוב mnemonic seed -שיחזור מ"
  },
  stepBackup: {
    beforeProceed: ":לפני שתמשיך, אנא קרא את שיקולי האבטחה החשובים הבאים",
    createBackup: ".גיבוי לא יווצר בכרטיס הזיכרון"
  },
  stepBackupSuccess: {
    fundsSafe: ":על-מנת לאבטח את הנכסים, זכור",
    title: "!הגיבוי שוחזר"
  },
  stepConnected: {
    unlock: "הזן את סיסמת הביטבוקס02 כדי לבטל נעילה"
  },
  stepCreate: {
    nameLabel: "שם ביטבוקס02",
    namePlaceholder: "הביטבוקס02 שלי",
    title: "בחר שם לביטבוקס02",
    toastMicroSD: ".אנא וודא כי כרטיס הזיכרון נמצא בתוך הביטבוקס02"
  },
  stepCreateSuccess: {
    removeMicroSD: ".אנא הסר את כרטיס הזיכרון מהביטבוקס02 ואחסן אותו במקום בטוח",
    success: ".יצרת בהצלחה גיבוי"
  },
  stepInsertSD: {
    insertSDCard: ".אנא הכנס כרטיס זיכרון לתוך הביטבוקס02 כדי להמשיך",
    insertSDcardTitle: ".הכנס כרטיס זיכרון"
  },
  stepPassword: {
    title: "קבע סיסמה לביטבוקס02",
    useControls: ".השתמש בפקדים כדי לקבוע סיסמה לביטבוקס02"
  },
  stepUninitialized: {
    create: ".אני מעוניין להגדיר ביטבוקס02 חדש",
    restore: ".אני רוצה לשחזר את הארנק שלי מגיבוי",
    restoreMicroSD: "שחזר מכרטיס זיכרון",
    restoreMnemonic: "mnemonic seed -שיחזור",
    title: "הגדר את הביטבוקס02 שלך"
  },
  success: {
    text: `.הידד! הביטבוקס02 שלך מוכן לשימוש

.בשביל מידע נוסף כיצד להשתמש בתכנה, השתמש במדריך המובנה בלחיצת על כפתור השאלה בפינה הימנית העליונה`,
    title: "!אתה מוכן להמשיך"
  }
}, blink$1 = {
  button: "הבהוב"
}, bootloader$1 = {
  button: "שדרג קושחה עכשיו",
  progress: "%משדרג: {{progress}}",
  success: ".שודרג בהצלחה! אנא חבר מחדש את ההתקן. הפעם, אל תגע בכפתור"
}, button$5 = {
  abort: "בטל",
  back: "חזור",
  buy: "קנה",
  changepin: "החלף סיסמת התקן",
  check: "בדוק גיבוי",
  continue: "המשך",
  copy: "העתק",
  create: "צור",
  download: "הורד",
  hiddenwallet: "צור ארנק מוסתר",
  next: "הבא",
  ok: "בסדר",
  previous: "הקודם",
  receive: "קבל",
  restore: "שחזר",
  select: "בחר",
  send: "שלח",
  unlock: "בטל נעילה",
  update: "עדכן",
  upgrade: "שדרג"
}, buy$2 = {
  title: "קנה {{name}}"
}, changePin$1 = {
  newTitle: "סיסמת התקן חדשה",
  oldLabel: "סיסמת התקן נוכחית"
}, chart$2 = {
  dataMissing: "אנחנו עדיין אוספים נתונים, נסה בעוד מספר דקות פעם נוספת",
  dataUpdating: "...מעדכן נתונים",
  filter: {
    all: "הכל",
    month: "חודש",
    week: "שבוע",
    year: "שנה"
  }
}, checkSDcard$1 = "בודק כרטיס זיכרון", clickHere$1 = ".לחץ כאן", confirm$3 = {
  abortInfo: "הקש כדי",
  abortInfoRedText: "לבטל",
  approveInfo: "החזק 4+ שניות כדי",
  approveInfoGreenText: "לאשר",
  info: ".המשך בביטבוקס",
  infoWhenPaired: "תחילה במכשיר המוצמד ואז בביטבוקס"
}, confirmOnDevice$1 = ".אנא אשר בהתקן שלך", device$1 = {
  appUpradeRequired: ".הביטבוקס שלך אינו נתמך על-ידי היישום. הורד והתקן את הגרסה האחרונה"
}, deviceLock$1 = {
  button: "אשר אימות דו-שלבי",
  condition1: "?יש ברשותך גיבוי",
  condition2: "?האם האימות בידי היישום עובד",
  condition3: "אימות דו-שלבי משבית גיבויים וצימוד למכשיר נייד. ההתקן חייב להתאתחל בכדי לצאת מאימות דו-שלבי",
  confirm: "אפשר אימות דו-שלבי",
  title: "אפשר אימות דו-שלבי"
}, deviceSettings$1 = {
  firmware: {
    newVersion: {
      label: "גרסה זמינה"
    },
    title: "קושחה",
    upToDate: "ההתקן שלך מעודכן",
    version: {
      label: "גרסה"
    }
  },
  hardware: {
    sdcard: {
      false: "לא הוכנס",
      label: "כרטיס זיכרון",
      true: "הכנס"
    },
    title: "תכנה"
  },
  loading: "מאחזר מידע על התקן",
  pairing: {
    lock: {
      false: "בטל",
      label: "אימות דו-שלבי",
      true: "אפשר"
    },
    mobile: {
      false: "סגור",
      label: "יישום נייד",
      true: "פתח"
    },
    status: {
      false: "לא צומד",
      label: "מצב",
      true: "צומד"
    },
    title: "מצמיד"
  },
  secrets: {
    manageBackups: "נהל גיבויים",
    title: "סודות"
  }
}, deviceTampered$1 = ".הביטבוקס שלך סופק עם סיסמת שיחזור? אם כן, עצור מיד את התהליך וצור קשר עם התמיכה. החברה לעולם לא תספק ארנק מוגדר או תמליץ על סיסמאות", dialog$2 = {
  cancel: "בטל",
  confirm: "אשר",
  confirmTitle: "אישור"
}, fiat$3 = {
  default: "ברירת מחדל",
  setDefault: "הגדר {{code}} כברירת מחדל",
  title: "מטבעות"
}, footer$3 = {
  appVersion: "גרסת תכנה:"
}, generic$2 = {
  enabled_false: "מושבת",
  enabled_true: "מופעל"
}, genericError$1 = "שגיאה התרחשה. אם אתה מבחין בחריגות, התחל מחדש את התכנה.", goal$1 = {
  buttons: {
    create: "צור ארנק חדש",
    restore: "שחזר ארנק מגיבוי"
  },
  paragraph: "בחר אחת מהאפשרויות הבאות:",
  step: {
    1: {
      title: "מידע אודות אבטחה"
    },
    2: {
      description: "קבע סיסמת התקן",
      title: "התקן"
    },
    "3-create": {
      description: "צור ארנק חדש",
      title: "ארנק"
    },
    "3-restore": {
      description: "מגיבוי",
      title: "שיחזור"
    },
    "4-create": {
      title: "סיכום"
    },
    "4-restore": {
      title: "סיכום"
    }
  }
}, guide$2 = {
  accountDescription: {
    text: ".סקירת החשבון שלך מציגה את היתרה הזמינה שלך כמו גם עסקאות נכנסות ויוצאות. המדריך שלנו ב'הגדרות 'כולל מידע נוסף על כל סוג חשבון",
    title: "?מה עמוד זה מציג לי"
  },
  accountFiat: {
    text: ".כן. לחץ על השער ההמרה כדי לעבור למטבע פיאט אחר. ניתן לשנות את רשימת המטבעות בהגדרות",
    title: "?האם אוכל להציג שיעורי המרה אחרים"
  },
  accountIncomingBalance: {
    text: ".סכומים המתקבלים לארנק שלך אל טרם אושרו ברשת",
    title: "?למה הכוונה במתקבלים"
  },
  accountInfo: {
    xpub: {
      text: `.מפתח ציבורי מורחב הוא מקור כל כתובות הקבלה של המשתמש
.המפתח מסופק פה לשימוש מתקדם ושיתוף עם ארנקי תצוגה בלבד, כמו אלקטרום או סנטינל`,
      title: "?מה זה מפתח ציבורי מורחב"
    }
  },
  accountRates: {
    text: "אנחנו מעדכנים את שערי החליפין אחת לדקה לפי קריפטו-קומפר.",
    title: "?אילו שערי חליפין חלים"
  },
  accountReload: {
    text: ".אין צורך. פרטי העסקה שלך מתעדכנים אוטומטית",
    title: "?אני יכול לטעון מחדש את היסטוריית העסקאות"
  },
  accountSendDisabled: {
    text: ".כפתור 'שלח' זמין כשהיתרה גדולה מאפס",
    title: "?מדוע אני לא יכול לשלוח עד {{unit}}"
  },
  accountSummaryAmount: {
    text: `coingecko.com הסכום הסופי הוא סכימת כל חשבונות הקריפטו שלך. שערי המרה נלקחים מ

לאסימונים שלא נתמכים בתכנה זו, הם לא יכללו בכמות המוצגת MyEtherWallet הערה: אם אתה משתמש ב

`,
    title: "?כיצד הכמות הסופית מחושבת"
  },
  accountSummaryDescription: {
    text: "כאן תוכל לראות את ביצועי תיק ההשקעות שלך לאורך זמן. סיכום של ארנקי הקריפטו שלך מוצגים תחת טבלה זו",
    title: "?מה עמוד זה מראה לי"
  },
  accountTransactionAttributesBTC: {
    text: `.גודל וירטואלי: קובע את דמי הרשת. חסכת בהצלחה בעמלות אם הוא קטן מגודל העסקה
.גודל: גודל עסקה בפועל בבתים בהמשכים לפי הבלוקצ׳יין הבסיסי
.כדי להעריך גדלים של עסקאות וחסימה. כל ביי עד מופרד נחשב לאחת, וכל השאר כארבע יחידות משקל. במקום מגה-בייט אחת בגודל בפועל, מגבלת גודל החסימה היא כעת ארבעה מיליון יחידות משקל SegWit משקל: ערך חדש שהוצג עם`,
    title: "?מה לגבי פרטים מדוייקים של עסקת ביטקויין"
  },
  accountTransactionAttributesGeneric: {
    text: `.אישורים: שידור העסקה שלך אינו מאושר עד שכורה יכלול אותו בבלוק, שלאחריו יש אישור אחד. כל בלוק המשודר ברשת מוסיף אישור נוסף לעסקה שלך. בדרך כלל סוחרים ומשתמשים אחרים ברשת יאשרו עסקאות רק בין שלוש לשש אישורים
.מזהה עסקה: מספר זיהוי ייחודי המאפשר לחפש עסקה בחוקר בלוקים
.עמלה: לכורים משולמים עמלת עסקה כתמריץ לכלול עסקאות בגושים שהם מכורים. למידע נוסף, לחץ על כפתור שלח`,
    title: "?מה הם האישורים בפרטי העסקה"
  },
  accountTransactionConfirmation: {
    text: ".עסקה ששודרה לרשת אך טרם אושרה",
    title: "?מה היא עסקה בהמתנה"
  },
  accountTransactionLabel: {
    text: ".זו היא הכתובת אליה התקבלו או נשלחו ממנה מטבעות",
    title: "?מה היא הכתובת המוצגת לכל עסקה"
  },
  accountTransactionTime: {
    text: ".שעת אישור ביצוע העסקה לפי הבלוקצ׳יין",
    title: "?מה הוא הזמן המוצג"
  },
  appendix: {
    link: "צור עימנו קשר",
    text: "שאלה נוספת?"
  },
  backups: {
    check: {
      text: ".בדיקת גיבוי' מאפשר לך לאשר כי ברשותך גיבוי תקין המגיב לארנק הנוכחי שלך. בדיקה זו גם מוודאת שיש ברשותך את סיסמת השיחזור הנכונה. באפשרותך לבדוק את סיסמת השיחזור הראשית או סיסמת השיחזור המוסתרת'",
      title: "'מה זה 'בדיקת גיבוי"
    },
    encrypt: {
      text: ".המאוחסן Seed -לא, אך סיסמת השחזור שלך נדרשת כדי להפיק את הארנק מה",
      title: "?האם ניתן להצפין את הגיבוי"
    },
    howOften: {
      text: `.הגיבוי נוצר באופן אוטומטי כשארנק חדש נוצר. עלייך ליצור גיבוי חדש רק אם כרטיס הזיכרון אבד או ניזוק, או אם ברצטנך להחזיק מספר עותקים לגיבוי
.אין צורך ליצור גיבוי אחרי עסקאות. כל נתוני העסקאות נוצרים מחדש באמעצות הגיבוי שנוצר אוטומטית בשבילך`,
      title: "?באיזו תדירות עלי לבצע גיבוי"
    },
    whatIsABackup: {
      text: ".עם סיסמת השיחזור יוצרים את הארנק שלך Seed -על גבי כרטיס הזיכרון. ה Seed -זהו העתק של ה",
      title: "?מה זה גיבוי"
    }
  },
  backupsBB02: {
    check: {
      text: ".בדיקת גיבוי' מאפשר לך לאשר כי ברשותך גיבוי תקין המגיב לארנק הנוכחי שלך'",
      title: "?'מה זה 'בדיקת גיבוי"
    },
    encrypt: {
      text: '.באמצעות סיסמה, תוכל לאפשר ביטוי סיסמא אופציונאלי בהגדרות המומחה תחת "נהל מכשיר״ Seed -הלא מוצפן כדי לשחזר את הארנק. אם ברצונך להגן על ה Seed -לא. אנא שמור על בטיחות כרטיס הזיכרון, מכיוון שהוא מכיל את ה',
      title: "?האם ניתן להצפין את הגיבוי"
    },
    whatIsABackup: {
      text: ".על גבי כרטיס הזיכרון Seed -זה הוא העתק של ה",
      title: "?מה זה גיבוי"
    }
  },
  bitbox: {
    "2FA": {
      text: `.כאשר אימות דו-שלבי מופעל, יש לאשר את כל העסקאות בטלפון הנייד המוצמד כדי לשלוח מטבעות. מתחת ל״פני השטח״ נשלח לאפליקציה הסלולרית מספר מוצפן לשימוש חד-פעמי, מפוענח שם, ומוחזר לביטבוקס בעת לחיצה על כפתור קבל. תקשורת זו עם המכשיר נעשית דרך הערוץ שבין הטלפון הנייד לבין אפליקציית שולחן העבודה הזו שנוצרה במהלך ההצמדה

.הקפד לגבות את הארנק שלך ולשייך את האפליקציה לנייד לפני שתפעיל את האימות הדו-שלבי. לאחר ההפעלה, חריץ כרטיס הזיכרון והתאמת היישום לנייד מושבתים. ניתן להפעיל אותם מחדש על ידי איפוס הביטבוקס שמוחק את המכשיר`,
      title: "?איך אימות דו-שלבי עובד"
    },
    disable2FA: {
      text: "על-מנת לבטל את האימות הדו-שלבי, עלייך לאתחל מחדש את הביטבוקס ולאחר מכן לשחזר את הארנק מהגיבוי. אנא וודא כי יש ברשותך את כרטיס הזיכרון עם הגיבוי ושהינך זוכר את סיסמת השיחזור. לאחר מכן לחץ 'אפס התקן'. הגדר סיסמת התקן חדשה ובחר באפשרות 'או שחזר מגיבוי'. בחר את הגיבוי שיצרת לארנק ולחץ 'שחזר' והזן את סיסמת השיחזור שהשתמשת בה בכדי ליצור את הארנק.",
      title: "?איך אני יכול להשבית את האימות הדו-שלבי"
    },
    ejectBitbox: {
      text: ".ניתוק הביטבוקס אפשרי בכל שלב",
      title: "?כיצד ניתן לנתק את הביטבוקס"
    },
    ejectSD: {
      text: ".הסרת כרטיס הזיכרון מהביטבוקס אפשרית בכל שלב, מלבד כאשר בתהליך או ביצירת גיבוי",
      title: "?כיצד ניתן לנתק את כרטיס הזיכרון"
    },
    hiddenWallet: {
      text: ".גיבוי משמש לארנק הרגיל והחבוי שלך, כך שלא נדרש גיבוי נוסף Seed -זהו ארנק שני על אותו התקן, מוגן באמצעות סיסמת התקן ושיחזור שונה עם אותו",
      title: "?מה הוא ארנק מוסתר"
    },
    legacyHiddenWallet: {
      text: ".תחילה הקש על הכפתור מטה (זמין אם הביטבוקס לא נעול עם הסיסמת ההתקן הראשית ואימות דו-שלבי מושבת), לאחר מכן חבר את הביטבוקס מחדש ותבטל את הנעילה עם סיסמת ההתקן הסודית",
      title: "?כיצד לגשת לארנק מוסתר מהדור הקודם"
    },
    pairing: {
      text: `.המגדיר ערוץ מאובטח בין המכשיר היישום לתכנה, QRלאחר הורדת יישום הנייד שלנו לאייפון או לאנדראודי, תסרוק את צופן ה 
.לאחר הסריקה, עקוב אחר ההוראות ביישום הנייד`,
      title: "כיצד לצמד באופן מאובטח את מכשיר הפלאפון"
    }
  },
  receive: {
    address: {
      text: "באפשרותך לתת את הכתובת לאחרים בכדי לשלוח לך מטבעות. תוודא שאתה שולח את הכתובת הנכונה",
      title: "?מה אני עושה עם כתובת"
    },
    addressChange: {
      text: ".ברגע שעסקה מתבצעת, כתובת חדשה נוצרת ומוספת לרשימה, כך שתמיד יש ברשותך 20 כתובות שמעולם לא קיבלו מטבעות",
      title: "?מתי כתובות משתנות"
    },
    addressFormats: {
      text: "כברירת מחדל, ארנק הביטבוקס משתמש בכתובות מהסוג החדש ביותר. אם קיימת בעיה בשימוש בסוג כתובות אלו, ניתן ללחוץ על שינוי סוג הכתובות לסוג הקודם",
      title: "?מה ההבדלים בין כתובות מהדור הקודם לדור החדש"
    },
    howVerify: {
      text: `בביטבוקס01, לחץ על סמל הביטבוקס בתפריט בצד שמאל וחפש את הגדרת הצימוד. המדריך יתעדכן ותוכל להמשיך במעקב אחרי ההוראות משם
בביטבוקס02, תוכל לאשר את הכתובת ישירות מההתקן בזמן תהליך השליחה או הקבלה`,
      title: "?כיצד אני יכול לאמת בבטחה כתובת"
    },
    why20: {
      text: '.כדי לראות אם קיבלו כספים. מכיוון שהאפליקציה יכולה לייצר מספר אינסופי כמעט של כתובות, היא עשויה להקדיש שנים לקביעת היתרה. כדי להגביל חיפוש זה הוא מפסיק לאחר שהוא רואה 20 כתובות שמעולם לא קיבלו כספים. זהו "גבול הפער" ו- 20 הוא תקן דה-פקטו אם כי המספר הוא שרירותי. אלה 20 הכתובות בהן תוכלו לבחור Seed -במהלך האיתול, היישום מייצר כתובות הנגזרות מה',
      title: "?מדוע רק 20 כתובות"
    },
    whyMany: {
      text: ".הגיבוי היחיד שלך Seed -כדי לשמור על פרטיות וביטחון, לעולם אל תמסור את אותה כתובת פעמיים. אם השתמשת בכתובת, לחץ על החץ ימינה לקבלת כתובת חדשה. אתה יכול ליצור עד 20 כתובות בכל פעם. חשוב על כתובות כמו מספרי חשבוניות. כל הכתובות נגזרות מ",
      title: "?מדוע מספר רב כל-כך של כתובות"
    },
    whyVerify: {
      text: "אין לסמוך על המחשב שלך כדי ליצור ולהציג כתובות אותנטיות. מחשב המחובר לרשת הופך אותו לפגיע באופן משמעותי יותר מארנק חומרה. עבור ביטבוקס01, הכפתור לאימות הכתובת שולח את הכתובת בצורה בטוחה לטלפון הנייד המוצמד, ממנו תוכלו לסרוק ולאמת את צופן ה״קיו-אר״. לגבי ביטבוקס02, ניתן לאמת את הכתובת ישירות על גבי מסך הביטבוקס02",
      title: "מדוע עליי לאמת את הכתובת בצורה מאובטחת?"
    }
  },
  send: {
    fee: {
      text: `.העמלה מבוססת על גודל נתוני העסקה ולא על גובהם. יעדי העמלות מחושבים על ידי אלגוריתם הערכת העמלות של ליבת הביטקוין לכל עדיפות ברשת שבחרת. הם מוצגים אם יש להם ערך שונה מהיעד למטה
(חסכוני: 24 בלוקים (בערך 4 שעות לביטקוין, שעה עבור לייטקויין
(נמוך: 12 בלוקים (בערך שעתיים לביטקוין, 30 דקות עבור לייטקויין
(רגיל: 6 בלוקים (כשעה לביטקוין, 15 דקות עבור לייטקויין
(גבוה: 2 חסימות (בערך 20 דקות לביטקוין, 5 דקות עבור לייטקויין
לבלוק לוקח עשר דקות בממוצע לביטקוין (2.5 דקות בלייטקויין) ועומס הרשת עשוי להשתנות במידה ניכרת בתקופות שלעיל`,
      title: "?כיצד העמלה נקבעת"
    },
    priority: {
      text: ".ככל שהעמלה אותה תהיה מוכן לשלם תהיה גבוהה יותר, כך העסקה תאושר מהר יותר ברשת",
      title: "?מה היא עדיפות הרשת"
    },
    revert: {
      text: `!מרגע שעסקה נחתמה ונשלחה לרשת, אין אפשרות לבטלה. אשר את העסקאות (כולל עמלה) היטב לפני החתימה
.אם אתה מכיר את המען והוא או היא מעוניים להשיב את הסכום (פחות עמלה העסקה) בחזרה אלייך, תוכל לשלוח להם כתובת חדשה לקבלה`,
      title: "?האם אוכל לבטל עסקה"
    },
    whyFee: {
      text: `.עסקאות מתמודדות עם אישור הכורה. כורים בוחרים בעסקאות שייכללו בבלוקצ׳יין בהתבסס על עמלתם
כורים מצביעים על היסטוריית העסקאות. מכיוון שאין גורם שלישי מהימן אשר יאכוף קול אחד לאדם (וזה כל העניין של מחסומי חסימות), כורים מצביעים על עסקאות בכך שהם מקריבים משאב יקר כמו כוח מחשוב. כפרס על עבודתם, הם יכולים לתבוע מטבעות חדשים שנוצרו ואת שכר הטרחה של כל העסקאות שהם כללו`,
      title: "?מדוע יש עמלת רשת"
    }
  },
  "settings-electrum": {
    connection: {
      text: `אם ברצונך להתחבר לצומת רק כאשר אתה על אותה רשת (לדוגמה, רשת הוויפי הביתית), שימוש בתקשורת רגילה מספיק
במקרה שכזה, מומלץ ששרת האלקום יספק אישור טי.אל.אס להצפנת התקשורת
אם ברצונך להתחבר לצומת שלך מכל מקום, שימוש בתור מומלץ יותר. אין צורך באישור טי.אל.אס במקרה זה`,
      title: "?האם עלי להשתמש בתור, טי.אל.אס או טי.סי.פי"
    },
    instructions: {
      link: {
        text: "מדריך לחיבור לצומת שלך"
      },
      text: ":למדריך המלא, בקר בעמוד ההדרכה",
      title: "?כיצד אני מחבר את תכנת הארנק לצומת המלא שלי"
    },
    options: {
      text: `קיימות מספר דרכים להריץ צומת מלא. ניתן לקנות מוצר מוגמר, לבנות אחד לבד או להריץ ליבת ביטקוין
אם ברצונך לחבר את תכנת הארנק לצומת שלך, וודא כי הוא מריץ שרת אלקטרום. זו תכנה ייעודית המאפשרת לארנק תקשורת לצומת המלא שלך
תכנות אפשריות הינן אלקטרס, שרת אלקטרום פרטי או טראקר`,
      title: "?אילו אופציות קיימות להרצת צומת"
    },
    tor: {
      text: `תור הינה תכנית קוד פתוח חינמית המאפשרת המון יתרונות פרטיות, במיוחד שימושי בשימוש בביטקוין. אם בכוונתך להתחבר לצומת שלך באמצעות תור, וודא שתור מותקן על המחשב ואפשר את תור פרוקסי בהגדרות התכנה. ברב מערכות ההפעלה קיימות שתי אפשריות להרצת תומר:
הראשונה - להוריד דפדפן תור ולהתחבר לרשת באמצעות פורט 9150
השניה - הרצת שירותי תור ברקע
תכנת הארנק תוכל כך להתחבר באמצעות פורט 9050 בהגדרות התכנה`,
      title: "?מה זה תור, פרוקסי תור ובאיזה פורט עלי להשתמש"
    },
    what: {
      text: "קיימת אפשרות להפעיל את הארנק שלך בעזרת צומת במקום להשתמש בשרתי החברה",
      title: "?מה זה"
    },
    why: {
      text: "הרצת צומת משלך אינה הכרחית אך משפרת את הפרטיות ומורידה את הצורך בלסמוך על אחרים. ראשית, זה אומר שתשתמש בביטקוין בצורה פרטית יותר, שכן התכנה לא תתחבר לשרתים שלנו - ההיסטוריה תלקח מהצומת שלך. שנית, הרצת צומת משמעותה וידוא כל הטרנזקציות בעצמך.",
      title: "?מדוע שאריץ צומת מלא משלי"
    }
  },
  settings: {
    servers: {
      text: `כדי לבדוק עדכונים, לטעון עסקאות ולשלוח מידע לאפליקציות סלולריות מותאמות Shift Crypto -יישום זה מתקשר עם שרתי
 האפליקציה מאחזרת גם את שערי החליפין האחרונים מהפלטפורמה של קריפטו-קומפר
,כל ההמרות מחושבות באופן מקומי, כלומר לא מועברים אי פעם נתונים על סכום העסקה שלך
.Etherscan.io APIs -אנחנו משתמשים ב ERC20 -בשביל מטבעות אית׳ריום ו`,
      title: "?עם אילו שרתים התכנה מתקשרת"
    }
  },
  title: "מדריך",
  toggle: {
    close: "סגור מדריך",
    open: "מדריך"
  },
  unlock: {
    forgotDevicePassword: {
      text: ".עלייך לאתחל מחדש את ההתקן ולשחזר את הארנק מגיבוי, באמצעות סיסמת השיחזור",
      title: "?מה לעשות אם שכחתי את סיסמת ההתקן"
    },
    reset: {
      text: ".הזן סיסמה שגויה 15 פעמים. הנסיונות האחרונים דורשים מגע ארוך יותר על ההתקן",
      title: "?כיצד אני מאתחל את ההתקן"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "ההתקן אמור להבהב פעם אחת כשמוכנס. וודא כי הכנסת בצד הנכון. אם קיימת בעיה, אנא צור קשר באמצעות הקישור למטה",
      title: "התקן הביטבוקס01 שלי לא מזוהה"
    },
    getDevice: {
      link: {
        text: "הזמן התקן ביטבוקס"
      },
      text: ":באפשרותך לרכוש התקן ביטבוקס בחנות המקוונת",
      title: "?כיצד אני יכול להשיג התקן"
    },
    internet: {
      text: "כן, חיבור לאינטרנט נדרש כדי לסנכרן את הארנק, להוציא עסקאות ולחזר שערי חליפין עדכניים",
      title: "האם התכנה דורשת חיבור לאינטרנט?"
    },
    lostDevice: {
      link: {
        text: "מרכז הגיבויים"
      },
      text: "באפשרותך לשחזר את חשבונותך באמצעות התקן ביטבוקס חדש או במרכז הגיבויים",
      title: "?איבדתי את ההתקן. מה עכשיו"
    },
    useWithoutDevice: {
      text: ".לצערנו, זה לא אפשרי כרגע",
      title: "?האם ניתן להשתמש בתכנה ללא התקן"
    },
    welcome: {
      text: `תודה על השימוש בתכנה שנבנתה ע״י שיפט קריפטו בשוויץ
אנחנו מעריכים כל משוב, ניתן לרשום לנו בקישור למטה`,
      title: "!ברוך הבא לתכנת הביטבוקס"
    }
  }
}, headerssync$1 = {
  blocksSynced: "{{blocks}} בלוקים הסתנכרנו"
}, hiddenWallet$1 = {
  info1HTML: ".<strong>שונות</strong>למטרות חשאיות ופרטיות, ארנק פרטי יווצר על בסיס שילוב סיסמת התקן + סיסמת שיחזור",
  info2HTML: ".הגדר את סיסמת ההתקן וסיסמת השיחזור שברצונך לשייך לארנק הסודי שמתחת. סיסמת ההתקן והשיחזור חייבות להיות <strong>שונות</strong> מאלו שהגדרת לארנק הראשי שלך",
  passwordLabel: "סיסמת שחזור מוסתרת",
  passwordPlaceholder: "נא אשר את סיסמת השחזור המוסתרת",
  pinLabel: "סיסמת התקן מוסתרת",
  pinRepeatLabel: "חזור על סיסמת ההתקן המוסתרת",
  pinRepeatPlaceholder: "נא אשר את סיסמת ההתקן המוסתרת",
  success: ".ארנק מוסתר נוצר בהצלחה. חבר מחדש את התקן הביטבוקס כדי לבטל את נעילתו"
}, initialize$1 = {
  create: "קבע סיסמת התקן",
  creating: "...קובע סיסמת התקן",
  error: {
    e102: ".סיסמת ההתקן חייבת להכיל לפחות 4 תווים"
  },
  info: {
    description1: ".בחר את סיסמת ההתקן. סיסמה זו תשמש אותך בביטול נעילת הביטבוקס",
    description2: ".באפשרותך להשתמש במספרים, תווים וסימנים. סיסמאות ארוכות הינן בטוחות יותר",
    description3: ".אם סיסמת ההתקן תאבד, עלייך לבצע איתחול ושיחזור של גיבוי הארנק",
    subtitle: "כעת תגדיר את סיסמת ההתקן שלך",
    title: "מאתחל את ההתקן"
  },
  input: {
    label: "סיסמת התקן",
    labelRepeat: "חזור על סיסמת ההתקן",
    placeholderRepeat: "נא אשר את סיסמת ההתקן"
  }
}, invalidFormat$1 = "תצורה שגויה", language$2 = {
  title: "בחר שפה"
}, legacyhiddenwallet$1 = {
  disable: "השבת כתובת קדומה של ארנק מוסתר",
  enable: "הפעל כתובת קדומה של ארנק מוסתר",
  successDisable: "השבתת כתובת קדומה של ארנק מוסתר הצליחה",
  successEnable: "הפעלת כתובת קדומה של ארנק מוסתר הצליחה. חבר מחדש את הביטבוקס והזן את סיסמת ההתקן המוסתר בכדי לגשת לכתובת הארנק המוסתר הקדומה"
}, loading$1 = "...טוען", mobile$1 = {
  usingMobileDataWarning: `.כדי להימנע משימוש בנתונים ניידים WiFi-שימוש בנתונים ניידים: יישום זה עשוי להוריד עד כמה מאות מגה-בייט של נתוני כותרות מהבלוקצ׳יין לאחר ביטול נעילת חשבון. אנא התחבר ל
.לאחר הביטול, הודעה זו לא תוצג שוב`
}, note$2 = {
  input: {
    description: "אופציונאלי",
    placeholder: "...הוסף הערה"
  },
  title: "הערה"
}, notification$1 = {
  newTxs_one: "{{count}} עסקה חדשה ב: {{accountName}}",
  newTxs_other: "{{count}} עסקה חדשה ב: {{accountName}}"
}, pairing$1 = {
  aborted: {
    text: ".הצימוד בוטל על-ידי יישום הנייד",
    title: "בוטל"
  },
  button: "הצמד ליישום הנייד",
  confirm: ".אתה בטוח שברצונך לצמד את הביטבוקס שלך? שים לב כי לאחר מכן, הנייד יידרש כדי לבצע עסקאות",
  connectOnly: {
    button: "חבר יישום נייד",
    title: "'סרוק באמצעות היישום הנייד שלנו, על-ידי בחירה בתפריט ב'חבר תכנה חדשה"
  },
  error: {
    text: ".משהו השתבש. התחל מחדש",
    title: "שגיאה"
  },
  pullFailed: {
    text: ".משיכת הודעה מהנייד שלך נכשלה דרך שרת הממסרים. שרת הממסר עשוי להיות במצב לא מקוון, אנא צור קשר עם התמיכה",
    title: "משיכה נכשלה"
  },
  reconnectOnly: {
    button: "חבר מחדש את יישום הנייד"
  },
  scanningFailed: {
    text: ".הנייד לא הצליח לסרוק את ההודעה בהצלחה. נסה שוב",
    title: "סריקה נכשלה"
  },
  start: {
    hideAppQRCode: "QR הסתר צופן",
    revealAppQRCode: "QR הצג צופן",
    step1: ".לחנות של אפל או גל גוגל, תלוי במכשיר הפלאפון שלך QR אם אין ברשותך את היישום הנייד, תוכל לסרוק צופן",
    step2: "Digital BitBox 2FA -סרוק באמצעות היישום הנייד, הניתן למציאה בחנות היישומים של אפל או אנדרואיד תחת השם"
  },
  started: {
    text: "כעת, עקוב אחר ההוראות ביישום הנייד",
    title: "נהדר"
  },
  success: {
    text: "!מזל טוב, הצמדת בהצלחה את התקן הביטבוקס שברשותך עם היישום הנייד",
    title: "הצלחה"
  },
  timeout: {
    text: "זמן הצימוד נגמר לאחר שתי דקות. התחל שוב אם ברצונך לצמד עם היישום הנייד",
    title: "הזמן תם"
  },
  title: "צימוד לנייד"
}, password$1 = {
  show: "הצג {{label}}",
  warning: {
    caps: "אזהרה: קאפסלוק (⇪) מופעל",
    paste: "״בכדי להדביק תמליל, אפשר ״הצג {{label}}"
  }
}, random$2 = {
  button: "צור מספר אקראי",
  description: ":הביטבוקס שלך יצר מספר של {{bits}}-ביטים אקראי"
}, receive$3 = {
  label: "כתובתך",
  onlyThisCoin: {
    description: ".בכדי לקבל אסימונים אחרים, אפשר אותם בהגדרות. אם תפקיד אסימונים שונים, ייתכן שהם לא יהיו נגישים",
    warning: ".וודא כי אתה מקבל {{coinName}} בלבד בכתובת זו"
  },
  showFull: "הראה ואמת כתובת מלאה בהתקן",
  title: "קבל {{accountName}}",
  verify: "וודא כתובת בצורה מאובטחת",
  verifyBitBox01: "וודא כתובת ביישום הנייד",
  verifyBitBox02: "וודא כתובת בביטבוקס02",
  verifyInstruction: ".אנא וודא אם הכתובת הבאה תואמת את הכתובת המוצגת על גבי ההתקן שלך",
  warning: {
    secureOutput: ".אנא צמד את הביטבוקס שלך עם היישום הנייד בכדי לאבטח וידוא הכתובת. השתמש ב'נהל התקנים' בתפריט הצד"
  }
}, reset$1 = {
  description: "!כל המידע שבהתקן יימחק, זה כולל את המפתח הפרטי שלך",
  notReset: ".התקן לא אופס",
  title: "שיחזור הגדרות יצרן",
  understand: "יש ברשותי גיבוי וסיסמת שיחזור",
  understandBB02: "יש ברשותי גיבוי תקין"
}, securityInformation$1 = {
  create: {
    description1: ".אנו ממליצים שתגדיר את המכשיר סביבה בטוחה, כלומר הרחק מאנשים אחרים שעלולים לראות את הסיסמה שתבחר",
    description2: ".תתבקש ליצור שתי סיסמאות",
    description3: ".הראשונה הינה <strong>סיסמת ההתקן</strong> שתבטל את נעילת התקן הביטבוקס שלך וניתנת לשינוי מאוחר יותר",
    description4: ".השנייה הינה <strong>סיסמת השיחזור</strong>שמבטלת את נעילת הארנק שלך. סיסמה זו לא יכולה להשתנות מאוחר יותר",
    description5: "הארנק ייצור קובץ גיבוי על גבי כרטיס הזיכרון שסופק. ניתן להשתמש בו במקרה חירום בכדי לשחזר את הנכסים באמצעות <strong>סיסמת השיחזור</strong>",
    title: "מידע אודות אבטחה"
  },
  restore: {
    description1: ".תתבקש להכניס את כרטיס הזיכרון שעליו מאוחסן הגיבוי",
    description2: "בכדי לשחזר את ההתקן, תצטרך את סיסמת השיחזור",
    description3: ".אנא שים לב כאשר אתה מזין את סיסמת השיחזור. כל סיסמה שתזין תיצור ארנק תקין. אם תזין סיסמה שגויה יוצג בפנייך ארנק עם יתרה שלא ציפית לה",
    title: "מידע אודות אבטחה"
  }
}, seed$1 = {
  agreements: {
    "funds-access": "אני לא אוכל לגשת לנכסים שלי אם אשכח את סיסמת השיחזור",
    "password-change": "אני לא יכול לשנות את סיסמת השחזור מאוחר יותר",
    "password-required": "סיסמת השיחזור נחוצה לכדי לשחזר ארנק מהגיבוי"
  },
  create: "צור ארנק",
  creating: "יוצר ארנק",
  description: ":אני מבין ש",
  error: {
    e102: ".הסיסמה חייבת להכין לפחות 4 תווים",
    e200: ".עלייך להכניס כרטיס זיכרון להתקן הביטבוקס, על-מנת ליצור ארנק, כדי שגיבוי יווצר אוטומטי"
  },
  info: {
    button: "קבע סיסמת שיחזור כעת",
    description1: "הכנס כרטיס זיכרון להתקן הביטבוקס",
    description2: "״בחר סיסמת שיחזור לארנק וסמן ״הגדר סיסמת שיחזור כעת",
    description3: ".הגיבוי באמצעות כרטיס הזיכרון וסיסמת השיחזור הן הדרכים היחידות לשחזר את הנכסים, במקרה של אובדן או גניבת התקן ביטבוקס",
    description4: ".אין באפשרותך לשנות את סיסמת השיחזור בהמשך, מבלי לשנע את נכסייך",
    title: "צור ארנק חדש"
  },
  password: {
    label: "סיסמת שיחזור",
    repeatPlaceholder: "חזור על סיסמת השיחזור"
  },
  walletName: {
    label: "שם ארנק"
  }
}, seedRestore$1 = {
  error: {
    e200: ".בשיחזור ארנק מגיבוי נדרש כרטיס הזיכרון"
  },
  info: {
    description1: "״הכנס את כרטיס הזיכרון להתקן הביטבוקס ולחץ ״המשך",
    description2: "״בחר גיבוי ולחץ ״שחזר",
    description3: "הקש את סיסמת השיחזור",
    description4: ".עליך לאשר כדי הבנת שסיסמה שגויה תיצור ארנק שונה",
    title: "כיצד לשחזר ארנק מגיבוי"
  }
}, send$3 = {
  abort: "העסקה בוטלה",
  address: {
    label: "כתובת מען",
    placeholder: "הכנס כתובת"
  },
  amount: {
    label: "סכום",
    placeholder: "הכנס סכום"
  },
  availableBalance: "יתרה זמינה",
  button: "סקירה",
  coincontrol: {
    address: "כתובת",
    outpoint: "נקודת יציאה",
    title: "שלח מהפלט"
  },
  confirm: {
    "selected-coins": "מטבעות נבחרים",
    title: "אשר ובצע עסקה",
    total: "סכום סופי"
  },
  error: {
    feeTooLow: "עמלה נמוכה מדי",
    insufficientFunds: "אין די כספים",
    invalidAddress: "כתובת שגויה",
    invalidAmount: "סכום שגוי",
    invalidData: "מידע שגוי"
  },
  fee: {
    customPlaceholder: "הכנס סכום",
    label: "עמלת רשת",
    placeholder: "לא זמין"
  },
  feeTarget: {
    description: {
      economy: "(בלוקים: 24 (סביב ה4 שעות לביטקויין, שעה ללייטקויין",
      economy_ltc: "(שעה (24 בלוקים",
      high: "(בלוקים: 2 (סביב ה20 דקות לביטקויין, 5 דקות ללייטקויין",
      high_ltc: "(חמש דקות (2 בלוקים",
      low: "(בלוקים: 12 (סביב השעתיים לביטקויין, 30 דקות ללייטקויין",
      low_ltc: "(חצי שעה (12 בלוקים",
      normal: "(בלוקים: 6 (סביב השעה לביטקויין, רבע שעה ללייטקויין",
      normal_ltc: "(רבע שעה (6 בלוקים"
    },
    estimate: ":זמן המתנה משוער",
    label: {
      custom: "מותאם",
      economy: "חסכוני",
      high: "גבוה",
      low: "נמוך",
      normal: "רגיל"
    },
    placeholder: "...מחשב הערכת עמלה"
  },
  maximum: "שלח הכל",
  priority: "עדיפות",
  scanQR: "QR סרוק צופן",
  signprogress: {
    description: ".עסקה זו כוללת המון מידע. כדי לחתום על עסקה זו לחלוטין, תתבקש לאשר {{steps}} פעמים",
    label: "התקדמות"
  },
  success: "העסקה נחתמה ונשלחה",
  title: "שלח {{accountName}}",
  toggleCoinControl: "הפעל שליטת מטבע",
  transactionDetails: "פרטי עסקה"
}, settings$2 = {
  electrum: {
    add: "הוסף שרת",
    "add-server": "הוסף",
    check: "בדוק",
    checkFailed: "נכשל",
    checkSuccess: "חיבור נוצר בהצלחה ל{{host}}",
    checking: "בודק",
    "download-cert": "הורד אישור מרחוק",
    "remove-server": "הסר",
    removeConfirm: "?הסר {{server}}",
    reset: "אתחל לברירת מחדל",
    resetConfirm: "?האם ברצונך למחוק את כל השרתים ולהתקין את שרתי ברירת המחדל",
    servers: "שרתים",
    step1: "1",
    "step1-text": "הכנס נקודת קצה",
    step2: "2",
    "step2-text": "הזן אישור של שרשרת האישורים של השרת. לחלופין, הורד את האישור המרוחק והשווה אותו חזותית",
    "step2-text-tcp": "TLS -שלב זה ניתן למעבר אם אינך מעוניין להשתמש בפרוטוקול",
    step3: "3",
    "step3-text": "בדוק את החיבור והוסף את השרת",
    step4: "4",
    "step4-text": "אתחל מחדש את הארנק. אם לא תסיר את שרתי ברירת המחדל, הצומת שלך יתווסף כיתירות",
    "title-btc": "שרתי ביטקוין אלקטרום",
    "title-ltc": "שרתי לייטקויין אלקטרום",
    "title-tbtc": "Bitcoin Testnet Electrum שרתי",
    "title-tltc": "Litecoin Testnet Electrum שרתי"
  },
  expert: {
    coinControl: "אפשר ניהול מטבע",
    electrum: {
      title: "חבר את הצומת המלא שלך"
    },
    fee: "אפשר ניהול עמלות",
    setProxyAddress: "קבע כתובת פרוקסי",
    title: "הגדרות מתקדמות",
    useProxy: "הפעל פרוקסי תור"
  },
  header: {
    home: "בית"
  },
  restart: ".אתחל מחדש את התכנה בכדי שהשינויים יתממשו",
  services: {
    title: "שירותים"
  },
  success: ".נתק וחבר מחדש את ההתקן בכדי שהשינויים יתממשו",
  title: "הגדרות"
}, setup$1 = "הגדר התקן", sidebar$2 = {
  device: "נהל התקן",
  leave: "עזוב",
  settings: "הגדרות"
}, success$8 = {
  create: {
    info1: "הארנק שלך גובה באופן מאובטח לכרטיס הזיכרון. הסר ושמור אותו בבטחה.",
    info2: "יצרת סיסמת מאובטחת להתקן אשר מבטלת את נעילתו.",
    info3: ".יצרת סיסמת שיחזור מאובטחת לארנק שלך, כזו המאפשרת פתיחה ושיחזור כל הנכסים מהגיבוי",
    summary: "הנה סיכום של מה שעשית",
    title: "הצלחה"
  },
  getstarted: "התחל",
  restore: {
    summary: ".שיחזרת בהצלחה ארנק מתוך הגיבוי",
    title: "הצלחה"
  }
}, transaction$2 = {
  confirmation: "אישורים",
  details: {
    activity: "פעילות",
    address: "כתובת",
    amount: "כמות",
    date: "תאריך",
    fiat: "פיאט",
    fiatAmount: "כמות פיאט",
    status: "מצב",
    type: "סוג"
  },
  explorer: "מזהה עסקה",
  explorerTitle: "פתח בחוקר בלוקים חיצוני",
  fee: "עמלה",
  fiatHistorical: "היסטורי",
  gas: "גז",
  note: {
    edit: "ערוך הערה",
    save: "שמור הערה"
  },
  pending: "עסקה ממתינה",
  size: "גודל",
  status: {
    complete: "הושלם",
    failed: "נכשל",
    pending: "ממתין"
  },
  tx: {
    received: "קבל אל",
    sent: "שלח ל"
  },
  vsize: "גודל וירטואלי",
  weight: "משקל"
}, transactions$1 = {
  placeholder: ".אין עסקאות עדיין"
}, unknownError$1 = "שגיאה לא ידועה התרחשה: {{errorMessage}}", unlock$1 = {
  description: ".הזן את סיסמת ההתקן בכדי לבטל את נעילתו",
  error: {
    e109_normal: ".סיסמת התקן שגויה. {{remainingAttempts}} נסיונות נותרו לפני מחיקת ההתקן",
    e109_touch: ".$t(unlock.error.e109_normal) ההתחברות הבאה תדרוש החזקה של מקש המגע",
    e113: ".עקב נסיונות רבים, ההתחברות הבאה דורשת החזקה של מקש המגע למשך 4 שניות"
  },
  input: {
    label: "סיסמת ההתקן",
    placeholder: "הזן את סיסמת ההתקן כדי לבטל את נעילתו"
  },
  unlocking: "...מבטל נעילה"
}, upgradeFirmware$2 = {
  button: "עדכון קושחה",
  description: "?אתה מעוניין לשדרג את הקושחה מ{{currentVersion}} ל{{newVersion}}",
  label: "ההתקן שלך דורש עדכון קושחה",
  locked: "כדי לשדרג מ{{currentVersion}} ל{{newVersion}}}, גע לחיצה ארוכה",
  title: "עדכן קושחה",
  unlocked: ":האיתחול נעול. כדי להמשיך",
  unlocked1: "נתק וחבר מחדש את ההתקן",
  unlocked2: "נורית הלד תדלק בביטבוקס שלך כשהוא יחובר בחזרה",
  unlocked3: "גע במקש המגע כשמנורת הלד נדלקת"
}, warning$7 = {
  receivePairing: ".הצמד את הביטבוקס שלך על-מנת לאפשר ווידוא עסקאות באופן בטוח. בחר ב'נהל התקן' בתפריט הצד",
  sdcard: "שמור על כרטיס הזיכרון הרחק מההתקן, אלמלא אתה מעוניין לנהל את הגיבויים",
  sendPairing: ".הצמד את הביטבוקס שלך על-מנת לאמת פרטי עסקאות. בחר ב'נהל התקן' בתפריט הצד"
}, welcome$1 = {
  insertBitBox02: "גע בהתקן כדי להמשיך",
  insertDevice: "חבר את ההתקן בכדי להתחיל",
  title: "ברוך הבא"
}, appTranslationsHE = {
  account: account$1,
  accountInfo: accountInfo$1,
  accountSummary: accountSummary$1,
  addAccount: addAccount$2,
  app: app$1,
  backup: backup$1,
  bb02Bootloader: bb02Bootloader$1,
  bitbox: bitbox$1,
  bitbox02Interact: bitbox02Interact$1,
  bitbox02Settings: bitbox02Settings$1,
  bitbox02Wizard: bitbox02Wizard$1,
  blink: blink$1,
  bootloader: bootloader$1,
  button: button$5,
  buy: buy$2,
  changePin: changePin$1,
  chart: chart$2,
  checkSDcard: checkSDcard$1,
  clickHere: clickHere$1,
  confirm: confirm$3,
  confirmOnDevice: confirmOnDevice$1,
  device: device$1,
  deviceLock: deviceLock$1,
  deviceSettings: deviceSettings$1,
  deviceTampered: deviceTampered$1,
  dialog: dialog$2,
  fiat: fiat$3,
  footer: footer$3,
  generic: generic$2,
  genericError: genericError$1,
  goal: goal$1,
  guide: guide$2,
  headerssync: headerssync$1,
  hiddenWallet: hiddenWallet$1,
  initialize: initialize$1,
  invalidFormat: invalidFormat$1,
  language: language$2,
  legacyhiddenwallet: legacyhiddenwallet$1,
  loading: loading$1,
  mobile: mobile$1,
  note: note$2,
  notification: notification$1,
  pairing: pairing$1,
  password: password$1,
  random: random$2,
  receive: receive$3,
  reset: reset$1,
  securityInformation: securityInformation$1,
  seed: seed$1,
  seedRestore: seedRestore$1,
  send: send$3,
  settings: settings$2,
  setup: setup$1,
  sidebar: sidebar$2,
  success: success$8,
  transaction: transaction$2,
  transactions: transactions$1,
  unknownError: unknownError$1,
  unlock: unlock$1,
  upgradeFirmware: upgradeFirmware$2,
  warning: warning$7,
  welcome: welcome$1
}, account = {
  disconnect: "Connessione interrotta. Riprovo...",
  export: "Esporta",
  exportTransactions: "Esporta transazioni in formato CSV nella cartella download",
  fatalError: "Si è verificato un errore inatteso",
  incoming: "In entrata",
  initializing: "Raccolgo informazioni dalla blockchain",
  maybeProxyError: "Proxy Tor attivato. Assicurati che il tuo proxy Tor funzioni correttamente, oppure disabilita l'impostazione del proxy.",
  reconnecting: "Connessione persa, provo a riconnettermi...",
  syncedAddressesCount: "{{count}} indirizzi letti"
}, accountInfo = {
  address: "Indirizzo",
  buyCTA: {
    buy: "Acquista {{unit}}",
    buyCrypto: "Acquista cryptovalute",
    information: {
      looksEmpty: "Sembra che il portafoglio sia vuoto.",
      start: "Iniziate depositando alcune valute nel portafoglio o acquistando direttamente nella BitBoxApp."
    }
  },
  extendedPublicKey: "Chiave pubblica estesa",
  label: "Informazioni sull'account",
  scriptType: "Tipo di script",
  title: "Informazioni sull'account",
  verify: "Verifica sul dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizza la chiave pubblica estesa di P2PKH",
    p2tr: "Visualizza Taproot",
    p2wpkh: "Visualizza Native Segwit",
    "p2wpkh-p2sh": "Visualizza la chiave pubblica estesa Segwit più vecchia"
  },
  xpubTypeInfo: "Attualmente viene visualizzata la chiave pubblica estesa {{scriptType}} ({{current}} di {{numberOfXPubs}})"
}, accountSummary = {
  availableBalance: "Saldo disponibile",
  balance: "Saldo",
  exportSummary: "Esporta il riepilogo dell'account in formato CSV nella cartella download",
  fiatBalance: "Saldo fiat",
  name: "Nome account",
  noAccount: "Non ci sono account da mostrare",
  subtotalWithCoinName: "Totale ({{coinName}})",
  title: "Il mio portafoglio",
  total: "Totale",
  transactionHistory: "Storico transazioni"
}, addAccount$1 = {
  chooseName: {
    nextButton: "Aggiungi account",
    step: "Nome dell'account",
    title: "Assegna un nome all'account"
  },
  selectCoin: {
    nextButton: "Avanti",
    step: "Seleziona valuta",
    title: "Seleziona cryptovaluta"
  },
  success: {
    addAnotherAccount: "Aggiungi un nuovo account",
    message: "<strong>{{accountName}}</strong> è stato aggiunto ai tuoi account.",
    nextButton: "Fatto",
    step: "Finito",
    title: "Account aggiunto"
  },
  title: "Aggiungi account"
}, aopp = {
  addressRequest: "{{host}} richiede un indirizzo di ricezione.",
  addressRequestWithLogo: `richiede un indirizzo di ricezione
`,
  banner: "Richiesta dell'indirizzo in corso",
  errorTitle: "Errore durante la richiesta dell'indirizzo",
  labelAddress: "Indirizzo",
  labelMessage: "Messaggio",
  reverifyInfoText: "Verifica indirizzo",
  signing: `Per procedere, firmare il messaggio sul BitBox02
`,
  success: {
    message: "Continua su {{host}}",
    title: "Indirizzo inviato con successo"
  },
  syncing: `Sincronizzazione dell'account, attendere prego.
`,
  title: "Richiesta di indirizzo"
}, app = {
  upgrade: "E' disponibile una nuova versione di questa app! Aggiorna dalla {{current}} alla {{version}}."
}, auth$1 = {
  authButton: "Autenticati",
  title: "Autenticati per continuare"
}, backup = {
  check: {
    checking: "Sto verificando backup...",
    confirmTitle: "Verifica backup",
    notOK: "Il backup NON combacia con il portafoglio.",
    ok: "Il backup combacia con il portafoglio.",
    password: {
      label: "Password di recupero",
      placeholder: "Password di recupero",
      showLabel: "password di recupero"
    },
    success: "Back verificato con successo:",
    title: "Verifica backup"
  },
  create: {
    alreadyExists: "Hai già un backup valido. Vuoi ricrearlo?",
    fail: "Creazione backup FALLITA!",
    info: "Inserisci la password di recupero del portafoglio attuale per la verifica.",
    name: {
      label: "Nome del backup",
      placeholder: "Assegna un nome al backup"
    },
    password: {
      label: "Password di recupero",
      placeholder: "Inserisci la tua password di recupero"
    },
    title: "Crea backup",
    verificationFailed: "La password di recupero NON corrisponde al portafoglio attuale. Il backup è stato creato. Per favore usa 'Controlla backup' per verificare di nuovo la tua password di recupero."
  },
  description: "Scegli <strong>il file di backup del wallet</strong>",
  insert: "Inserisci la carta microSD per gestire i backup.",
  insertButton: "Ho inserito la carta microSD",
  list: "I tuoi backup sulla carta microSD",
  noBackups: "Non ci sono backup su questa carta microSD",
  restore: {
    confirmTitle: "Ripristina backup",
    error: {
      e200: "Carta microSD non trovata",
      general: "Errore nel ripristino del backup"
    },
    password: {
      label: "Password di recupero o password di recupero nascosta",
      placeholder: "Password di recupero",
      repeatPlaceholder: "Ripeti password di recupero",
      showLabel: "Password di recupero"
    },
    restoring: "Ripristino backup...",
    selectedBackup: "<strong>{{backupName}}</strong> creato in data {{createdDateTime}} verrà ripristinato.",
    title: "Ripristina",
    understand: "Capisco che una password di recupero errata creerà un portafoglio diverso"
  },
  showMnemonic: {
    description: `Ti verranno mostrate le parole di recupero, che formano un backup del tuo portafoglio. Scrivile su carta.

<strong>Non custodirle digitalmente e non fotografarle.</strong>

<strong>Non pronunciare le parole ad alta voce.</strong>

<strong>Questo backup non è protetto da password.</strong>

In seguito ti sarà richiesto di confermare ogni parola.`,
    title: "Mostra le parole di recupero",
    warning: "<strong>Non condividere le tue parole di recupero con nessuno.</strong> Le parole di recupero danno pieno accesso al tuo portafogli. Se qualcuno ti chiede le tue parole di recupero, vuole truffarti. Non condividerle!"
  },
  title: "Gestisci i backup"
}, bb02Bootloader = {
  abort: "Non aggiornare - riportami indietro",
  abort_noUpgrade: "Indietro",
  advanced: {
    label: "Impostazioni avanzate",
    toggleShowFirmwareHash: "Mostrami l'hash del firmware ogni volta all'avvio"
  },
  flipscreen: "Capovolgi schermo",
  orientation: "Orientamento del dispositivo sbagliato?",
  success: "Aggiornamento riuscito! Passo successivo in {{rebootSeconds}} secondi...",
  success_install: "Installazione riuscita! Continua tra {{rebootSeconds}} secondi..."
}, bitbox = {
  error: {
    e10000: "Password errata per questo dispositivo",
    e10001: "Impossibile sostituire la password del dispositivo",
    e102: "La password deve essere di almeno 4 caratteri.",
    e112: "La password nascosta non può essere uguale alla password principale del dispositivo."
  }
}, bitbox02Interact = {
  confirmDate: "Conferma la data di oggi sul tuo BitBox02",
  confirmDateText: "Questa data sarà usata per creare il tuo backup.",
  confirmName: "Conferma il nome sul BitBox02",
  confirmWords: "Prendi nota delle {{amount}} parole di recupero dal tuo BitBox02",
  confirmWordsText: "In seguito il BitBox02 ti chiederà di confermare ogni parola per verificare la correttezza del tuo backup.",
  followInstructions: "Segui le istruzioni sul tuo BitBox02",
  followInstructionsMnemonic: "Segui le istruzioni sul tuo BitBox02 per ripristinare utilizzando le parole di recupero.",
  followInstructionsMnemonicTitle: `Ripristina da parole di recupero
`
}, bitbox02Settings = {
  deviceName: {
    current: "Nome attuale del dispositivo",
    error: "Non è stato possibile configurare il nome del dispositivo",
    error_104: "La conferma del nome del dispositivo è stata abortita sul dispositivo.",
    input: "Nome del BitBox02",
    placeholder: "Nuovo nome del dispositivo",
    title: "Imposta il nome del BitBox02"
  },
  gotoStartupSettings: {
    description: "Questo riavvia il BitBox02 e inizializza le impostazioni di avvio.",
    title: `Vai alle impostazioni di avvio
`
  }
}, bitbox02Wizard = {
  advanced: {
    button: "Opzioni avanzate",
    outOfDate: "Firmware non aggiornato per questa funzionalità",
    seed12WordInfo: "Attenzione, il numero di parole non potrà essere modificato dopo la creazione del portafogli.",
    seed12WordLabel: "Crea un seed da 12 parole invece di 24",
    seed12WordText: "Il BitBox02 di default usa un seed da 24 parole. All'atto pratico, entrambe le lunghezze del seed sono sicure contro attacchi di tipo brute force. Alcuni utenti potrebbero preferire la comodità di un seed da 12 parole.",
    skipSDCardLabel: "Salta il backup su microSD e sostituiscilo annotando le parole di recupero",
    skipSDCardText: "Hai sempre l'opzione di creare un backup su microSD o annotare le parole di recupero dopo il setup. Puoi farlo dalle impostazioni.",
    title: "Opzioni di backup avanzate"
  },
  attestationFailed: "L'attestazione del dispositivo non è riuscita. Ciò potrebbe essere dovuto al riavvio dell'app mentre il dispositivo stava aspettando l'input dell'utente. Si prega di ricollegarsi e riprovare. Contattare support@bitbox.swiss se l'errore persiste.",
  backup: {
    point1: "Scegli un backup sulla carta microSD",
    point2: "Imposta una password per il tuo dispositivo",
    restoreText: "Ok, ripristiniamo un backup!",
    text1: "Bene, la tua password di BitBox02 è ora impostata e il portafoglio creato. Ora è il momento di creare il tuo primo backup. Assicurati che la tua scheda microSD sia inserita nel tuo BitBox02 e continua.",
    text2: "Segui le istruzioni sullo schermo del tuo dispositivo per creare un backup.",
    text3: "Dopo che il backup è stato creato, rimuovi la scheda microSD e conservala in un luogo <strong>sicuro</strong>. Il contenuto della scheda microSD non è protetto da password. Non inserirla mai in nessun altro dispositivo che non sia il tuo BitBox02.",
    userConfirmation1: "Devo conservare il backup in un luogo sicuro.",
    userConfirmation2: "Il backup non è protetto da una password. Chiunque abbia accesso ad esso può accedere anche al mio portafoglio.",
    userConfirmation3: "Se perdo o danneggio il mio BitBox02, l'unico modo per recuperare i miei fondi è ripristinare il backup.",
    userConfirmation4: "Se perdo o danneggio sia il backup che il dispositivo BitBox02, i miei fondi andranno persi.",
    userConfirmation5: "Non devo inserire il mio backup su scheda microSD in un computer, telefono, stampante o qualsiasi altro dispositivo che non sia un BitBox02.",
    userConfirmation5mnemonic: "Non devo inserire le mie parole di recupero in un computer, telefono, stampante o altro dispositivo diverso da BitBox02."
  },
  create: {
    button: "Assegnare un nome al dispositivo e continuare",
    info: "Ecco i passaggi necessari per configurare il tuo BitBox: ",
    inputTitle: "Nome del portafoglio",
    point1: "Dai un nome al tuo dispositivo",
    point2: "Imposta una password per il tuo dispositivo",
    point3: "Crea un backup",
    text: "Bene, ora creiamo un nuovo portafoglio!"
  },
  createBackupAborted: "Creazione del backup interrotta.",
  createBackupFailed: "Creazione del backup fallita. Riprovare.",
  initialize: {
    passwordText: "Ora impostiamo la password del dispositivo. Usa i controlli sul tuo BitBox per scegliere i caratteri della password.",
    passwordTitle: "Imposta la password per il tuo BitBox",
    text: "BitBox02 abbinato con successo! Ora inizializziamo il tuo dispositivo. Inizia scegliendo se creare un nuovo portafoglio o ripristinare un portafoglio da un backup esistente. <strong>Assicurati di avere una scheda microSD inserita nel tuo BitBox02</strong>",
    tip: "Ti consigliamo di procedere in un luogo sicuro.",
    title: "Inizializza il tuo BitBox"
  },
  insertSDCard: "<strong>Assicurati di aver inserito la scheda microSD nel tuo BitBox02.</strong>",
  noPasswordMatch: "Le password non corrispondono. Riprovare.",
  pairing: {
    failed: "Abbinamento non confermato. Ricollega il tuo BitBox02.",
    paired: "Hai confermato il seguente codice sul tuo dispositivo. Puoi continuare.",
    title: "Verifica il codice di abbinamento",
    unpaired: "È stato rilevato un nuovo BitBox02. Si prega di verificare che il seguente codice corrisponda a quello mostrato sul tuo dispositivo. Se il codice corrisponde, tocca sotto il segno di spunta sul tuo BitBox02 e poi clicca sul pulsante qui sotto per continuare."
  },
  restoreFromMnemonic: {
    e104: "Il ripristino tramite parole di recupero è stato cancellato.",
    failed: "Ripristino con parole di recupero non riuscito. Riprovare."
  },
  stepBackup: {
    beforeProceed: "Prima di procedere, leggi queste importanti considerazioni sulla sicurezza:",
    createBackup: "Ora si procede a creare un backup sulla scheda microSD.",
    createBackupMnemonic: "Scrivi le parole di recupero."
  },
  stepBackupSuccess: {
    fundsSafe: "Per tenere i tuoi fondi al sicuro, ricordati quanto segue:",
    title: "Backup ripristinato!"
  },
  stepConnected: {
    unlock: "Inserisci la password del BitBox02 per sbloccare."
  },
  stepCreate: {
    description: "Questo nome viene utilizzato come nome del dispositivo e per il backup.",
    nameLabel: "Nome del BitBox02",
    namePlaceholder: "Il mio BitBox02",
    title: "Scegli il nome del BitBox02",
    toastMicroSD: "Inserisci nel tuo BitBox02 la scheda microSD che sarà utilizzata per salvare un backup del tuo portafogli."
  },
  stepCreateSuccess: {
    removeMicroSD: "Rimuovere la scheda microSD dal BitBox02 e conservarla in un luogo sicuro.",
    storeMnemonic: "Custodisci le tue parole di recupero in un posto sicuro",
    success: "Il backup è stato creato con successo."
  },
  stepInsertSD: {
    insertSDCard: "Inserisci la scheda microSD nel BitBox02 per continuare.",
    insertSDcardTitle: "Inserire la scheda microSD"
  },
  stepPassword: {
    e104: "L'impostazione della password è stata cancellata.",
    title: "Impostare la password del BitBox02",
    useControls: "Usa i controlli sul tuo BitBox02 per impostare la password."
  },
  stepUninitialized: {
    create: "Vorrei configurare un nuovo BitBox02.",
    restore: "Vorrei ripristinare il mio portafoglio da un backup.",
    restoreMicroSD: "Ripristina dalla scheda microSD",
    restoreMnemonic: "Ripristina utilizzando le parole di recupero",
    title: "Configurare il BitBox02"
  },
  success: {
    text: `Urrà! Il tuo BitBox02 è ora pronto all'uso. 

Per ulteriori informazioni su come utilizzare la BitBoxApp, si prega di utilizzare la guida in-app cliccando sul punto di domanda in alto a destra.`,
    title: "Pronti a partire!"
  }
}, blink = {
  button: "Lampeggia"
}, bootloader = {
  button: "Aggiornare il firmware",
  button_install: "Installa il firmware adesso",
  progress: "Aggiornamento: {{progress}}%",
  progress_install: `Installazione: {{progress}}%
`,
  success: "Aggiornamento riuscito! Ricollegare il dispositivo. Questa volta non toccare il pulsante."
}, button$4 = {
  abort: "Interrompere",
  back: "Indietro",
  buy: "Acquista",
  changepin: "Cambia la password del dispositivo",
  check: "Verifica il backup",
  continue: "Continua",
  copy: "Copia",
  create: "Creare",
  dismiss: "Sospendi",
  done: "Fatto",
  download: "Scarica",
  hiddenwallet: "Crea un portafoglio nascosto",
  next: "Successivo",
  ok: "OK",
  previous: "Precedente",
  receive: "Ricevi",
  restore: "Ripristina",
  select: "Selezionare",
  send: "Invia",
  unlock: "Sblocca",
  update: "Aggiorna",
  upgrade: "Aggiorna"
}, buy$1 = {
  exchange: {
    bankTransfer: "Bonifico bancario",
    bestDeal: "Miglior prezzo",
    creditCard: "Carta di credito",
    fast: "Rapido",
    fee: "commissione",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bonifico Bancario: {{fee}}%",
          creditDebitCard: "Carta di debito/credito: {{fee}}%",
          learnMore: "Scopri di più su Moonpay",
          title: "Commissioni"
        },
        fullCurrenciesList: "Vedi la lista completa di valute qui",
        payment: {
          asteriskText: "* Non disponibile per i residenti in US",
          bankTransfer: "Bonifico bancario*",
          bankTransferDetails: {
            pix: "PIX (Transazioni BR esclusivamente in Brasile)",
            sepa: "SEPA e SEPA istantaneo (transazioni EUR esclusivamente in Paesi SEPA)",
            uk: "UK Faster Payments (transazioni GBP esclusivamente in UK)"
          },
          creditDebitCard: "Carta di credito/debito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Vedi più dettagli sui metodi di pagamento",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta tutte le principali valute fiat: USD, EUR, CHF, and altre."
      },
      pocket: {
        fees: {
          info: "Bonifico bancario: {{fee}}%",
          title: "Commissioni"
        },
        learnMore: "Scopri di più su Pocket",
        payment: {
          bankTransfer: "Bonifico bancario",
          bankTransferDetails: {
            sepa: "SEPA e SEPA istantaneo (per le transazioni in EUR nei Paesi SEPA)",
            sic: "Swiss Interbank Clearing (per le transazioni in CHF in CH/LI)",
            uk: "UK Faster Payments (per le transazioni GBP in UK)"
          },
          bankTransferReccuring: "Come impostare degli acquisti ricorrenti tramite un ordine permanente?",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta le seguenti valute Europee: EUR, GBP e CHF",
        verification: {
          info: "Richiede una verifica dell'identità solamente al di sopra delle soglie giornaliere ed annuali",
          link: "Trova le soglie aggiornate qui",
          title: "Verifica dell'identità"
        }
      },
      region: {
        title: "Selezione il Paese in cui hai registrato il tuo conto bancario per vedere le opzioni disponibili per te."
      }
    },
    noExchanges: "Mi dispiace, non ci sono exchange disponibili in questo Paese",
    region: "Paese",
    selectRegion: "Non specificato",
    title: "Compra {{name}}"
  },
  info: {
    continue: "Accetta e continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Siamo una partnership MoonPay per offrirti un modo semplice per comprare {{name}} direttamente all'interno della BitBoxApp. Bastano pochi click.",
        "MoonPay è una piattaforma che rende comprare {{name}} facile e veloce in oltre 160 paesi."
      ],
      payment: {
        details: "Puoi comprare {{name}} istantaneamente tramite MoonPay con i seguenti metodi di pagamento. Gli ordini con carta di credito o di debito sono immediati e convenienti, ma più costosi a causa del maggior rischio di chargeback. Raccomandiamo di usare l'opzione del bonifico bancario per importi maggiori. La tariffa minima è di 4 USD/EUR o equivalente.",
        footnote: "Si prega di notare che i tassi di cambio di MoonPay possono differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
        table: {
          "1_description": "Tariffe più basse, possono richiedere fino a 3 giorni lavorativi",
          "1_method": "Trasferimenti bancari (SEPA)",
          "2_description": "Commissioni più alte, ma veloce ed istantaneo",
          "2_method": "Carte di debito e credito",
          description: "Descrizione",
          fee: "Commissione",
          method: "Metodo"
        },
        title: "Metodi di pagamento e commissioni"
      },
      privacyPolicy: "Privacy policy di MoonPay",
      protection: {
        description: "La BitBoxApp non raccoglie alcun dato quando si acquista {{name}} ed i fondi in entrata sono trattati come una normale transazione. MoonPay ha bisogno di raccogliere alcuni dati personali per operare. La loro privacy policy spiega in dettaglio come questi dati vengono gestiti.",
        descriptionGeneric: "BitBoxApp non registra nessun dato durante l'acquisto di {{name}}, i fondi in entrata sono trattati come comuni transazioni. Ciò nonostante, gli exchange partner hanno bisogno di alcune informazioni per poter operare. Fai riferimento alle rispettive privacy policy per verificare come i dati vengono gestiti.",
        title: "Protezione dei dati"
      },
      security: {
        description: `Quando acquisti {{name}} tramite MoonPay, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione.`,
        descriptionGeneric: `Quando acquisti {{name}} tramite un exchange partner, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione.`,
        link: "Security threat model",
        title: "Security model"
      },
      title: "Benvenuto nel tuo sportello unico per l'acquisto di {{name}}"
    },
    next: "Prossimo",
    selectLabel: "Scegli un account",
    selectPlaceholder: "Seleziona una valuta",
    skip: "Non mostrare più",
    title: "Acquista {{name}}"
  },
  pocket: {
    data: {
      link: "Privacy policy di Pocket",
      p1: "BitBoxApp non registra nessun dato durante l'acquisto di Bitcoin, i fondi in entrata sono trattati come comuni transazioni. Pocket ha bisogno di alcune informazioni personali per poter operare. La loro privacy policy spiega in dettaglio come i dati vengono gestiti.",
      title: "Protezione dei dati"
    },
    kyc: {
      link: "Leggi le FAQ di Pocket",
      p1: "Pocket cerca di mantenere al minimo il KYC. Per acquisti al di sotto dei 950 EUR (1000 CHF) al giorno, non è necessario nessun documento aggiuntivo. Per acquisti di importi superiori, sarà necessario programmare una call con Pocket per completare le necessarie procedure KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puoi comprare Bitcoin istantaneamente con Pocket tramite un bonifico bancario SEPA. La commissione è del 1,5% e i Bitcoin vengono depositati sul tuo BitBox appena possibile una volta che Pocket ha ricevuto il bonifico (di solito in giornata).",
      p2: "Si prega di notare che i tassi di scambio utilizzati da Pocket potrebbero differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
      title: "Metodi di pagamento e commissioni"
    },
    previousTransactions: "Lo storico di transazioni di questo account non è vuoto. Condividere questo account renderà tutte le transazioni passate e future visibili per Pocket. Procedere comunque? ",
    security: {
      link: '"BitBox02 security threat model"',
      p1: `Quando acquisti Bitcoin tramite Pocket, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione. Comunque, lavoriamo insieme per migliorare la sicurezza utilizzando un meccanismo di autenticazione a due fattori per verificare il tuo indirizzo di ricezione.`,
      title: "Modello di sicurezza "
    },
    usedAddress: "L'indirizzo {{address}} è già stato utilizzato, per favore ricomincia da capo con un nuovo indirizzo.",
    verifyBitBox02: "Per favore, verifica che l'indirizzo che hai ricevuto via email corrisponda a quello visualizzato sul tuo BitBox. Se possibile, dovresti aprire la mail su un secondo dispositivo per maggiore sicurezza.",
    welcome: {
      p1: "Collaboriamo con Pocket per offrirti un modo fluido per acquistare Bitcoin direttamente nella BitBoxApp. Sono solo pochi click.",
      p2: "Pocket è una piattaforma Svizzera che rende semplice e veloce acquistare Bitcoin in gran parte dell'Europa (ovunque un bonifico bancario SEPA sia supportato).",
      p3: "Con Pocket, puoi anche acquistare regolarmente tramite singoli bonifici bancari, quindi puoi fare DCA (dollar-cost averaging) con semplicità.",
      title: "Benvenuto nel tuo sportello unico per l'acquisto di Bitcoin"
    }
  },
  title: "Acquista {{name}}"
}, changePin = {
  newTitle: "Nuova password del dispositivo",
  oldLabel: "Password attuale del dispositivo"
}, chart$1 = {
  dataMissing: "Raccolta di dati ... rimanete collegati.",
  dataOldTimestamp: "Aggiornamento dei tassi di cambio storici. Il grafico non visualizza dati posteriori al {{time}}",
  dataUpdating: "aggiornamento dei dati ...",
  filter: {
    all: "Tutto",
    month: "Mese",
    week: "Settimana",
    year: "Anno"
  }
}, checkSDcard = "verifica della scheda microSD", clickHere = "Clicca qui.", confirm$2 = {
  abortInfo: "Tocca per",
  abortInfoRedText: "interrompere",
  approveInfo: "Tocca per almeno 4 secondi per",
  approveInfoGreenText: "confermare",
  info: "Continua sul tuo BitBox",
  infoWhenPaired: "Prima sul cellulare accoppiato e poi sul tuo BitBox"
}, confirmOnDevice = "Conferma sul tuo dispositivo.", connectKeystore$1 = {
  promptNoName: "Connetti il tuo BitBox02 per continuare",
  promptWithName: 'Connetti il tuo BitBox02 con nome "{{name}}" per continuare'
}, darkmode$1 = {
  toggle: "Modalità scura"
}, device = {
  appUpradeRequired: "Il tuo BitBox non è compatibile con questa versione dell'applicazione desktop. Installa l'ultima versione."
}, deviceLock = {
  button: "Abilita autenticazione a due fattori (2FA)",
  condition1: "Hai un backup?",
  condition2: "La verifica via applicazione mobile funziona?",
  condition3: "2FA DISABILITA i backup e l'abbinamento dell'applicazione mobile. Il dispositivo deve essere resettato per uscire da 2FA!",
  confirm: "Abilita autenticazione a due fattori (2FA)",
  title: "Abilita autenticazione a due fattori (2FA)"
}, deviceSettings = {
  backups: {
    manageBackups: {
      description: "Crea o verifica il tuo backup su microSD."
    },
    showRecoveryWords: {
      description: "Mostra e verifica le parole di recupero."
    },
    title: "Backup"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp verifica che il tuo dispositivo sia autentico."
    },
    deviceName: {
      description: "Modifica il nome del tuo dispositivo."
    },
    rootFingerprint: {
      description: "La root fingerprint è un identificatore univoco del portafogli attualmente in uso. Ti può aiutare a distinguere portafogli diversi se usi la passphrase."
    },
    securechip: {
      description: "Modello del secur chip."
    },
    title: "Informazioni sul dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Ripristina il dispositivo alle impostazioni di fabbrica. Questo cancella il portafogli sul tuo BitBox02!",
      title: "Ripristino alle impostazioni di fabbrica"
    },
    goToStartupSettings: {
      description: "Entra nel bootloader del BitBox02. Da qui puoi abilitare il firmware hash"
    },
    passphrase: {
      description: "Abilita o disabilita la passphrase.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Versione Firmware",
    newVersion: {
      label: "Versione disponibile"
    },
    title: "Firmware",
    upToDate: "Il tuo dispositivo è aggiornato",
    upgradeAvailable: "Nuovo upgrade disponibile",
    version: {
      label: "Versione"
    }
  },
  hardware: {
    attestation: {
      false: "Verifica di autenticità fallita",
      label: "Verifica di autenticità",
      true: "Il tuo Bitbox02 è autentico"
    },
    sdcard: {
      false: "Non inserita",
      label: "carta microSD",
      true: "Inserita"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Recupero delle informazioni sul dispositivo...",
  pairing: {
    lock: {
      false: "Disabilitato",
      label: "Autenticazione a due fattori",
      true: "Abilitato"
    },
    mobile: {
      false: "Chiuso",
      label: "Applicazione mobile",
      true: "Aperto"
    },
    status: {
      false: "Non abbinato",
      label: "Status",
      true: "Abbinato"
    },
    title: "Abbinamento"
  },
  secrets: {
    manageBackups: "Gestione backup",
    title: "Segreti"
  }
}, deviceTampered = "Il tuo BitBox è stato fornito con una password di recupero? Se è così, interrompi il processo di configurazione e contatta il supporto immediatamente. Shift non ti fornirà mai un portafoglio pronto né ti consiglierà una password.", dialog$1 = {
  cancel: "Annulla",
  confirm: "Conferma",
  confirmTitle: "Conferma"
}, error$2 = {
  accountAlreadyExists: "L'account esiste già.",
  accountLimitReached: "Impossibile aggiungere un account. È stato raggiunto il numero massimo di account per questa moneta.",
  aoppCallback: `Si è verificato un errore nella consegna dell'indirizzo a {{host}}.
`,
  aoppInvalidRequest: "Richiesta non valida",
  aoppNoAccounts: "Non ci sono account disponibili.",
  aoppSigningAborted: `Richiesta di proprietà dell'indirizzo annullata.
`,
  aoppUnknown: `Si è verificato un errore sconosciuto.
`,
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "Non ci sono account disponibili che supportino il formato di indirizzo richiesto.",
  aoppUnsupportedKeystore: `Il dispositivo collegato non può firmare i messaggi per questo asset.
`,
  aoppVersion: "Versione sconosciuta.",
  wrongKeystore: "Portafogli connesso errato. Assicurati di inserire il dispositivo corretto per questo account.",
  wrongKeystore2: "Se stai utilizzando la passphrase opzionale, assicurati di avere inserito quella corretta per questo account."
}, fiat$2 = {
  default: "predefinito",
  setDefault: "Imposta {{code}} come valuta predefinita",
  title: "Valute"
}, footer$2 = {
  appVersion: "Versione dell'app:"
}, generic$1 = {
  enabled_false: "Disabilitato",
  enabled_true: "Abilitato"
}, genericError = "Si è verificato un errore. Se noti qualche problema, riavvia l'applicazione.", goal = {
  buttons: {
    create: "Creare un nuovo portafoglio",
    restore: "Ripristina un portafoglio dal backup"
  },
  paragraph: "Seleziona una delle seguenti opzioni:",
  step: {
    1: {
      title: "Informazioni sulla sicurezza"
    },
    2: {
      description: "Impostare la password del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crea un nuovo portafoglio",
      title: "Portafoglio"
    },
    "3-restore": {
      description: "da un backup",
      title: "Ripristina"
    },
    "4-create": {
      title: "Riassunto"
    },
    "4-restore": {
      title: "Riassunto"
    }
  }
}, guide$1 = {
  accountDescription: {
    text: "La panoramica dell'account mostra il tuo saldo disponibile e le transazioni in entrata e in uscita. La nostra guida in 'Impostazioni' contiene maggiori informazioni sui diversi tipi di account. ",
    title: "Cosa contiene questa pagina?"
  },
  accountFiat: {
    text: "Si. Clicca su qualsiasi ticker per scorrere tra le valute fiat. Puoi cambiare la lista delle valute nelle impostazioni.",
    title: "Posso visualizzare altri tassi di conversione?"
  },
  accountIncomingBalance: {
    text: "Le somme in entrata riassumono gli importi trasferiti a voi ma non ancora confermati dalla rete.",
    title: "Cosa significa somme in entrata?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Ogni xpub è legata al "Tipo" indicato: "Native Segwit (bech32)", "Wrapped Segwit" o "Taproot" (solo Bitcoin). Questi sono i tipi di script utilizzati da {{coinName}}. La BitBoxApp li combina, supportando più tipi di script nello stesso account. Poiché ogni tipo di script fornisce un xpub diverso, esistono più xpub per account.

Se si riceve sempre sull'indirizzo predefinito (Native Segwit), è necessario solo l'xpub "bech32". Tuttavia, se si ricevono fondi anche su "Wrapped Segwit" o "Taproot", è necessario utilizzare anche le chiavi pubbliche estese "Wrapped Segwit" e "Taproot" rispettivamente.`,
      title: `Perché ci sono diverse xpub?
`
    },
    privacy: {
      text: `Per questo specifico account, la chiave pubblica estesa rivela l'intera storia finanziaria, il saldo dell'account e tutte le transazioni future. L'xpub però non consente a nessuno di spendere i tuoi fondi.

Se si condivide un'xpub con qualcuno, si deve essere consapevoli che questa persona o azienda può vedere tutte le altre transazioni dello stesso account. Pertanto, è bene utilizzare quell'account solo per questo scopo e conservare gli altri fondi in account diversi.`,
      title: "Devo tenere la my xpub segreta?"
    },
    verify: {
      text: "Sì, è sempre una buona idea ricontrollare la propria xpub. E' particolarmente importante nel caso in cui qualcun altro generi indirizzi di ricezione da questa xpub per inviare denaro. È necessario verificarla sul dispositivo per assicurarsi che questa xpub appartenga a voi; in caso contrario, tutti i fondi potrebbero andare a indirizzi sbagliati.",
      title: `È necessario verificare l'xpub sul dispositivo?
`
    },
    xpub: {
      text: `Una chiave pubblica estesa è una chiave "root" da cui derivano tutti gli indirizzi di ricezione di un account. 

È fornita qui per un uso avanzato e per l'interoperabilità con portafogli watch-only, come Electrum o Sentinel. Se hai ricevuto su diversi tipi di indirizzo, importa tutti i diversi formati xpub nel portafoglio watch-only per vedere tutte le tue valute.

Nota bene: i portafogli di terze parti potrebbero non supportare ancora gli xpub di Taproot.`,
      title: "Cos'è una chiave pubblica estesa?"
    }
  },
  accountRates: {
    text: "Aggiorniamo i tassi di cambio ogni minuto da CoinGecko.",
    title: "Quali tassi di cambio si applicano?"
  },
  accountReload: {
    text: "Non ce n'è bisogno. Le informazioni sulla tua transazione vengono aggiornate automaticamente.",
    title: "Posso ricaricare la cronologia delle transazioni?"
  },
  accountSendDisabled: {
    text: "Il pulsante 'Invia' è attivo quando hai un saldo maggiore di zero.",
    title: "Perché non posso inviare {{unit}}?"
  },
  accountSummaryAmount: {
    text: `L'importo totale è la somma di tutti i tuoi account. I tassi di cambio sono ottenuti da coingecko.com.

Nota: se usi MyEtherWallet per i token non supportati nella BitBoxApp, questi non saranno inclusi nell'importo visualizzato.`,
    title: "Come viene calcolato l'importo totale?"
  },
  accountSummaryDescription: {
    text: "Qui pui vedere la performance del tuo portafogli nel tempo. Sotto il grafico viene visualizzato un riepilogo dei diversi account.",
    title: "Cosa contiene questa pagina?"
  },
  accountTransactionAttributesBTC: {
    text: `Dimensione virtuale: Determina la tassa di rete. Si risparmia sulle commissioni se è più piccola della dimensione della transazione.
Dimensione: Dimensione effettiva della transazione in byte quando serializzata secondo la blockchain sottostante.
Peso: Una nuova metrica introdotta con Segwit per valutare le dimensioni delle transazioni e dei blocchi. Ogni byte del "segregated witness" conta come uno, tutto il resto come quattro unità di peso. Invece di un megabyte di dimensione effettiva, il limite della dimensione del blocco è ora di quattro milioni di unità di peso.`,
    title: "E i dettagli delle transazioni in Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: `Conferme: La tua prima transazione trasmessa non è confermata fino a quando un minatore la include in un blocco, dopo di che ha una conferma. Ogni blocco trasmesso sulla rete aggiunge un'altra conferma alla tua transazione. Generalmente i commercianti e gli altri attori della rete saldano solo le transazioni con un numero di conferme compreso tra tre e sei.
ID della transazione: Un numero di identificazione unico che permette di cercare una transazione in un esploratore di blocchi.
Commissione: Ai minatori viene pagata una tassa di transazione come incentivo per includere le transazioni nei blocchi che estraggono. Per saperne di più, clicca sul pulsante invia.`,
    title: "Quali sono le informazioni nei dettagli della transazione?"
  },
  accountTransactionConfirmation: {
    text: "Una transazione trasmessa alla rete ma non ancora confermata.",
    title: "Cos'è una transazione in sospeso?"
  },
  accountTransactionLabel: {
    text: "L'indirizzo da cui hai ricevuto o a cui hai inviato delle monete.",
    title: "Quale indirizzo viene visualizzato per ogni transazione?"
  },
  accountTransactionTime: {
    text: "Il tempo di conferma della transazione su blockchain.",
    title: "Che ora viene visualizzata?"
  },
  accounts: {
    howManyAccounts: {
      text: `Non c'è un limite al numero di account Bitcoin e Litecoin supportati. Dopo il quinto account, potrai aggiungerne uno nuovo solo se il precedente è già stato utilizzato.
`,
      title: "Quanti account posso creare?"
    },
    howtoAddTokens: {
      text: 'I token che utilizzano lo standard ERC20 sono legati a uno specifico account Ethereum. Per attivare o disattivare un determinato token, aprire la schermata "Gestisci account", espandere il proprio account Ethereum e attivare o disattivare il token desiderato.',
      title: `Come posso aggiungere più token?
`
    },
    moveFunds: {
      text: `Sì, ma poiché gli account sono indipendenti, è necessario inviare i fondi con una transazione regolare.
`,
      title: "Posso spostare fondi tra account diversi?"
    },
    recoverAccounts: {
      text: "Sì. BitBoxApp crea account utilizzando standard consolidati e compatibili con la maggior parte degli altri portafogli di criptovalute.",
      title: `Posso recuperare i miei account con altri portafogli?
`
    },
    whatAreAccounts: {
      text: "Il portafoglio può gestire più account della stessa moneta. Diversi account sono utili quando si desidera mantenere i fondi separati.",
      title: "Cosa sono gli account?"
    },
    whyIsThisUseful: {
      text: 'Gli account sono ottimi per gestire fondi per persone o scopi diversi, perché sono separati. È inoltre possibile condividere la "chiave pubblica estesa" di un account senza rivelare nulla degli altri account. Ciò consente di ricevere ripetutamente fondi senza riutilizzare gli indirizzi, ad esempio per ricevere lo stipendio o per acquistare regolarmente criptovalute.',
      title: "Perchè è utile?"
    }
  },
  appendix: {
    link: "Contattaci",
    text: "Altre domande?"
  },
  backups: {
    check: {
      text: "'Controlla backup' ti permette di verificare di avere un backup funzionante corrispondente al tuo portafoglio attuale. Può anche essere usato per verificare che tu abbia ancora la password di recupero corretta. Puoi controllare la tua password di recupero principale o la tua password di recupero nascosta.",
      title: "Cos'è il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No, ma la tua password di recupero è necessaria per ricavare il portafoglio dal "seed" memorizzato.',
      title: "Posso criptare il backup?"
    },
    howOften: {
      text: `Il backup viene generato automaticamente quando viene creato un nuovo portafoglio. Devi fare un nuovo backup solo se la tua scheda microSD viene persa o danneggiata, o se vuoi usare più schede microSD come backup.
Non è necessario creare nuovi backup dopo l'attività di transazione. Tutti i dati delle tue transazioni possono essere ricreati dal tuo singolo backup che è stato generato automaticamente per te.`,
      title: "Quanto spesso devo fare un backup?"
    },
    whatIsABackup: {
      text: 'È una copia del "seed" su una scheda microSD. Il "seed" insieme alla tua password di recupero genera il tuo portafoglio.',
      title: "Cos'è un backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Controlla backup' ti permette di verificare che hai un backup funzionante corrispondente al tuo portafoglio attuale.",
      title: "Cos'è il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No. Tieni la scheda microSD al sicuro, perché contiene il "seed" non criptato per recuperare il tuo portafoglio. Se desideri proteggere con una password il tuo seed, puoi abilitare una passphrase opzionale nelle impostazioni avanzate sotto " Gestisci dispositivo ".',
      title: "Posso criptare il backup?"
    },
    whatIsABackup: {
      text: 'È una copia del "seed" su una scheda microSD.',
      title: "Cos'è un backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando la 2FA è abilitata, tutte le transazioni devono essere approvate sul cellulare abbinato per poter spendere fondi. Un numero monouso criptato viene inviato all'applicazione mobile, decriptato lì, e restituito al BitBox quando si preme il pulsante "Accetta". Questa comunicazione con il dispositivo avviene tramite un canale tra il telefono cellulare e l'applicazione desktop stabilita durante l'abbinamento.

Assicurati di fare il backup del tuo portafoglio e di abbinare l'applicazione mobile prima di abilitare il 2FA. Una volta abilitato, lo slot microSD e l'abbinamento dell'applicazione mobile sono disabilitati. Possono essere riabilitati resettando il BitBox, che cancella il dispositivo.`,
      title: "Come funziona l'autorizzazione a due fattori (2FA)?"
    },
    disable2FA: {
      text: "Per disabilitare il 2FA, è necessario resettare il BitBox e poi ripristinare il portafoglio dal suo backup. Assicurati di avere ancora la scheda microSD con il backup e di ricordare ancora la password di recupero. Poi premi 'Reset dispositivo'. Imposta una nuova password del dispositivo e scegli 'Ripristina un backup'. Seleziona il backup che hai fatto dal portafoglio, clicca su 'Ripristina' e inserisci la password di recupero che hai usato quando hai creato il portafoglio.",
      title: "Come posso disabilitare l'autorizzazione a due fattori (2FA)?"
    },
    ejectBitbox: {
      text: "È possibile scollegare il BitBox in qualsiasi momento senza doverlo prima espellere.",
      title: "Come posso espellere il BitBox?"
    },
    ejectSD: {
      text: "È possibile rimuovere la scheda microSD dal BitBox in qualsiasi momento, purché non si stia creando o ripristinando un backup.",
      title: "Come posso espellere la scheda microSD?"
    },
    hiddenWallet: {
      text: 'Si tratta di un secondo portafoglio sullo stesso dispositivo protetto da una password diversa da quella del dispositivo e quella di recupero, che puoi usare per una negazione plausibile. Lo stesso "seed" di backup viene utilizzato sia per il portafoglio normale che per quello nascosto, quindi non è necessario un backup aggiuntivo.',
      title: "Cos'è un portafoglio nascosto?"
    },
    legacyHiddenWallet: {
      text: "Prima clicca il pulsante qui sotto (disponibile se il BitBox è sbloccato con la password del dispositivo principale e 2FA è disabilitato), poi ricollega il tuo Bitbox e sbloccalo con la tua password del dispositivo nascosto.",
      title: "Come si accede al portafoglio nascosto legacy?"
    },
    pairing: {
      text: "Dopo aver scaricato la nostra applicazione mobile per iOS o Android, scansiona il codice QR visualizzato, che stabilisce un canale sicuro tra l'applicazione mobile e questa applicazione. Una volta scansionato, segui le istruzioni dell'applicazione mobile.",
      title: "Come abbinare in modo sicuro il tuo telefono"
    }
  },
  cointracking: {
    text: `Fai clic sul pulsante "Esporta" e apri la cartella dei download dove troverai l'esportazione CSV. Quindi fai clic sul link sottostante, carica il tuo file CSV BitBox e importa i dati per utilizzarli nel tuo gestore del portafoglio CoinTracking e per creare le tue dichiarazioni fiscali.
`,
    title: "Come importo le mie transazioni in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leggi di più sulla verifica di autenticità"
      },
      text: "La BitBoxApp effettua una verifica di autenticità sul BitBox02 per assicurarsi che il dispositivo sia autentico. La verifica viene eseguita localmente e non si connette a nessun server",
      title: "Come funziona la verifica di autenticità?"
    },
    name: {
      text: "Questo è il nome del tuo portafoglio e del backup. Il nome è utilizzato per i backup futuri e può essere utilizzato per distinguere tra differenti portafogli. Può essere cambiato in ogni momento, ma tieni presente che i backup fatti prima del cambio avranno il nome precedente.",
      title: "Per cosa è utilizzato il nome del BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leggi di più sul secure chip"
      },
      text: "Questa informazione mostra il modello del secure chip. Quello più aggiornato è ATECC608B, con funzionalità di sicurezza migliorate rispetto ai modelli precedenti.",
      title: "Perchè mostrare il modello del secure chip?"
    }
  },
  receive: {
    address: {
      text: "Puoi dare l'indirizzo ad altri per farti inviare dei fondi. Assicurati che stiano inviando all'indirizzo corretto.",
      title: "Cosa devo fare con un indirizzo?"
    },
    addressChange: {
      text: "Non appena si effettua una transazione, un nuovo indirizzo viene automaticamente aggiunto alla lista, quindi ci sono sempre 20 indirizzi disponibili che non hanno mai ricevuto fondi.",
      title: "Quando cambiano gli indirizzi?"
    },
    addressFormats: {
      text: "Da impostazione predefinita, il tipo di indirizzo è Native Segwit. Questo tipo di indirizzo è ampiamente adottato da altri portafogli/exchange e offre le migliori tariffe per le transazioni quotidiane. Tuttavia, si può anche scegliere di inviare a Taproot (solo Bitcoin), il tipo di indirizzo più recente, ma potenzialmente non ancora ampiamente supportato. In alternativa, se avete problemi a inviare a Native Segwit (predefinito), potete provare a passare al tipo di indirizzo più vecchio Wrapped Segwit, che potrebbe essere compatibile con più portafogli/scambi.",
      title: 'Quando uso "Cambia tipo di indirizzo"?'
    },
    howVerify: {
      text: `Per il BitBox01, clicca sull'icona BitBox nella barra laterale a sinistra e vedi la sezione Abbinamento. La guida si aggiornerà e potrai continuare a seguire le istruzioni da lì.
Per il BitBox02, è possibile verificare gli indirizzi direttamente sul dispositivo durante il processo di invio/ricezione.`,
      title: "Come posso verificare un indirizzo in modo sicuro?"
    },
    plugout: {
      text: "No, una volta inviate le valute al proprio indirizzo BitBox, non è necessario lasciare il BitBox collegato. Siete liberi di scollegare il vostro BitBox.",
      title: "È necessario lasciare il BitBox collegato durante la ricezione?"
    },
    why20: {
      text: `Durante l'avvio l'app genera indirizzi derivati dal vostro "seed" per vedere se hanno ricevuto fondi. Poiché l'app può generare un numero quasi infinito di indirizzi, potrebbero passare anni perché determini il saldo. Per limitare questa ricerca, la app si ferma quando vede 20 indirizzi che non hanno mai ricevuto fondi. Questo è il "gap limit" e 20 è uno standard applicato de-facto anche se il numero è arbitrario. Questi sono i 20 indirizzi tra cui puoi scegliere.`,
      title: "Perché solo 20 indirizzi?"
    },
    whyMany: {
      text: 'Per mantenere la privacy e la sicurezza, non dare mai lo stesso indirizzo due volte. Se hai usato un indirizzo, clicca sulla freccia a destra per un nuovo indirizzo. Puoi generare fino a 20 indirizzi alla volta. Pensa agli indirizzi come ai numeri di fattura. Tutti gli indirizzi sono derivati dal tuo singolo "seed" di backup.',
      title: "Perché così tanti indirizzi?"
    },
    whyVerify: {
      text: "Non dovresti fidarti del computer per generare e visualizzare indirizzi genuini. L'ampia superficie di attacco lo rende molto più vulnerabile di un hardware wallet. Nel caso del BitBox01, il pulsante per verificare l'indirizzo invia in modo sicuro l'indirizzo a un telefono cellulare associato, dal quale è anche possibile scansionare e verificare il codice QR. Per il BitBox02, l'indirizzo può essere verificato direttamente sul display del BitBox02.",
      title: "Perché dovrei verificare l'indirizzo in modo sicuro?"
    }
  },
  send: {
    change: {
      text: "Il resto verrà restituito a un indirizzo Taproot se è presente almeno un UTXO Taproot. Se si usa il coin control, il resto verrà restituito a un indirizzo Taproot se c'è almeno un UTXO Taproot tra gli UTXO selezionati. In tutti gli altri casi, il resto viene restituito a un indirizzo Native Segwit.",
      title: "Come viene determinato l'output del resto?"
    },
    fee: {
      text: `La commissione si basa sulla dimensione dei dati della transazione e non sulla sua quantità. 
le commissioni sono calcolate dall'algoritmo di stima di Bitcoin Core per ogni priorità di rete scelta. Sono mostrate se hanno un valore diverso rispetto a quelli qui sotto.
Economica: 24 blocchi (circa 4 ore per Bitcoin, 1 ora per Litecoin)
Basso: 12 blocchi (circa 2 ore per Bitcoin, 30 minuti per Litecoin)
Normale: 6 blocchi (circa 1 ora per il Bitcoin, 15 minuti per il Litecoin)
Alto: 2 blocchi (circa 20 minuti per il Bitcoin, 5 minuti per il Litecoin)
(Un blocco impiega in media dieci minuti per Bitcoin (2,5 minuti in Litecoin) per essere estratto e il carico della rete può variare considerevolmente nei periodi di cui sopra).`,
      title: "Come sono determinate le commissioni?"
    },
    plugout: {
      text: "No, una volta effettuata una transazione, non è necessario lasciare il BitBox collegato. Si è liberi di scollegare il BitBox.",
      title: "È necessario lasciare il BitBox collegato durante l'invio?"
    },
    priority: {
      text: "Più commissioni paghi, tipicamente più velocemente le transazioni sono confermate dalla rete",
      title: "Cos'è la priorità di rete?"
    },
    revert: {
      text: `Una volta che una transazione è firmata e inviata (cioè trasmessa alla rete), non può più essere annullata. Verificate bene le transazioni (compresa la commissione) prima di firmare!
Se conosci il destinatario e lui/lei è disposto/a a rimandarti lo stesso importo (meno le commissioni della transazione), puoi inviargli/le un nuovo indirizzo di ricezione.`,
      title: "Posso revocare una transazione?"
    },
    whyFee: {
      text: `Le transazioni sono in competizione per essere confermate da un minatore. I minatori scelgono le transazioni da includere nella blockchain in base al loro compenso.
I minatori votano sulla storia delle transazioni. Dal momento che non c'è una terza parte fidata che faccia rispettare un voto per persona (che è l'intero scopo delle blockchain), i minatori votano sulle transazioni sacrificando una risorsa costosa come la potenza di calcolo. Come ricompensa per il loro lavoro, possono reclamare fondi appena creati e le commissioni di tutte le transazioni che hanno incluso.`,
      title: "Perché ci sono delle commissioni di rete?"
    }
  },
  "settings-electrum": {
    connection: {
      text: `Se intendete connettervi al vostro nodo solo quando siete sulla stessa rete (ad esempio il wifi di casa vostra), allora è sufficiente utilizzare la normale comunicazione di rete.
In questo caso è consigliabile che il vostro server Electrum fornisca un certificato TLS per cifrare la comunicazione.
Se avete intenzione di connettervi al vostro nodo da qualsiasi luogo, usare Tor è l'opzione migliore. In questo caso non è necessario alcun certificato TLS.`,
      title: "Meglio usare clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guida per collegare il tuo nodo"
      },
      text: "Per un tutorial completo, visitate la nostra guida:",
      title: "Come faccio a collegare la mia BitBoxApp al mio full node?"
    },
    options: {
      text: `Ci sono diverse opzioni per utilizzare il proprio nodo come acquistare un dispositivo finito, costruire il proprio o utilizzare Bitcoin Core.
Se vuoi collegare la BitBoxApp al tuo nodo, assicurati che esegua un server Electrum. Questo è un programma dedicato che permette ad un'app portafoglio di comunicare con il tuo nodo.
Le opzioni supportate includono Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).`,
      title: "Quali opzioni ci sono per gestire un nodo?"
    },
    tor: {
      text: `Tor è l'acronimo di 'The Onion Router', che è un software gratuito e open source che offre un sacco di vantaggi per la privacy ed è particolarmente utile quando si usa Bitcoin.
Se hai intenzione di connetterti al tuo nodo tramite Tor, assicurati che Tor sia installato sul tuo computer e poi abilita il Proxy Tor nelle impostazioni di BitBoxApp.
Sulla maggior parte dei sistemi operativi ci sono due modi per eseguire Tor:
1. 1. Tor Browser: scaricare e aprire il Tor Browser. Questo permetterà alla BitBoxApp di connettersi alla rete Tor impostando la porta 9150 nelle impostazioni del proxy Tor.
2. Servizio Tor in background: installare il daemon Tor, che viene sempre eseguito in background. La BitBoxApp può quindi connettersi impostando la porta 9050 nelle impostazioni del proxy Tor.`,
      title: "Cos'è Tor, Tor proxy e quale porta usare?"
    },
    what: {
      text: "È possibile utilizzare il tuo portafoglio con il mio full node invece di usare i server di Shift?",
      title: "Cosa significa?"
    },
    why: {
      text: `Utilizzare il proprio nodo non è necessario, ma migliora la privacy e riduce la necessità di fidarsi degli altri.
In primo luogo, significa che stai usando Bitcoin più privatamente, poiché la BitBoxApp non si connetterà ai nostri server per recuperare la tua storia delle transazioni; invece recupererà quelle informazioni dal tuo nodo.
In secondo luogo, utilizzare il tuo nodo significa che il tuo nodo verifica tutte le transazioni, assicurandosi che le regole di consenso siano applicate.`,
      title: "Perché dovrei utilizzare il mio nodo?"
    }
  },
  settings: {
    sats: {
      text: "Un Satoshi ('sat' in breve) è la più piccola unità di Bitcoin. Un Satoshi è un centomilionesimo di Bitcoin (0.00000001 BTC). E' stato chiamato così in omaggio al creatore di Bitcoin, Satoshi Nakamoto.",
      title: "Cos'è un Satoshi? "
    },
    servers: {
      text: `Questa app comunica con i server Shift Crypto per controllare gli aggiornamenti, caricare le transazioni e inviare informazioni alle app mobili abbinate.
L'app recupera anche gli ultimi tassi di cambio da CoinGecko. Tutte le conversioni sono calcolate localmente, il che significa che nessun dato sull'importo della tua transazione viene mai trasmesso.
Nota: Per Ethereum e i Token ERC20, usiamo le API di Etherscan.io.`,
      title: "A quali server si connette questa app?"
    }
  },
  title: "Guida",
  toggle: {
    close: "Chiudi guida",
    open: "Guida"
  },
  trackingModePortfolioChart: {
    text: "Su Desktop, sposta il cursore sopra al grafico. Da mobile, tieni il dito premuto sul grafico e spostalo orizzontalmente.",
    title: "Come visualizzare lo storico dei prezzi sul grafico? "
  },
  unlock: {
    forgotDevicePassword: {
      text: "Devi resettare il dispositivo e ripristinare il portafoglio da un backup, utilizzando la password di recupero.",
      title: "Cosa devo fare se ho dimenticato la password del dispositivo?"
    },
    reset: {
      text: "Inserisci una password errata del dispositivo per 15 volte. Gli ultimi tentativi richiedono un lungo tocco sul dispositivo.",
      title: "Come faccio a resettare il dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: `Il dispositivo dovrebbe lampeggiare una volta quando viene inserito. Assicurati che sia inserito nel modo giusto. Se hai problemi, contattaci attraverso il link qui sotto.

Il BitBox01 non è supportato su dispositivi mobili. Utilizzare la BitBoxApp su desktop per collegare il BitBox01.`,
      title: "Il mio BitBox01 non viene riconosciuto"
    },
    getDevice: {
      link: {
        text: "Ordina un BitBox"
      },
      text: "Puoi comprare una BitBox nel nostro negozio online:",
      title: "Come posso ottenere un dispositivo?"
    },
    internet: {
      text: "Sì, è necessaria una connessione internet per sincronizzare il portafoglio, inviare transazioni e recuperare gli ultimi tassi di cambio.",
      title: "Questa app richiede una connessione a internet?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Puoi recuperare i tuoi account su un nuovo BitBox o con il nostro Backup center.",
      title: "Ho perso il mio dispositivo. E adesso?"
    },
    useWithoutDevice: {
      text: "Purtroppo, questo non è ancora possibile al momento.",
      title: "Posso usare l'applicazione senza un dispositivo?"
    },
    welcome: {
      text: "Grazie per aver usato questa app costruita da Shift Crypto in Svizzera. Apprezziamo qualsiasi input che hai da condividere. Inviaci il tuo feedback utilizzando il link in basso.",
      title: "Benvenuti nella BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se utilizzi la BitBoxApp su un nuovo telefono/computer, dovrai riconnetterti alle DApp per vedere le valute collegate come al solito.",
      title: "Non vedo le mie connessioni precedenti."
    },
    supportedNetworks: {
      text: "Al momento, solo la mainnet Ethereum è supportata da WalletConnect nella BiBoxApp. Se hai bisogno di un portafogli per altre chain EVM puoi utilizzare l'estensione per il browser Rabby.",
      title: "Quali reti sono supportate?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect è un protocollo di comunicazione per applicazioni web3. Ti permette di connetterti comodamente a DApp e portafogli web senza dover usare un'altra app. Particolarmente utile per gli utenti Android della BitBoxApp.",
      title: "Cos'è WalletConnect?"
    }
  }
}, headerssync = {
  blocksSynced: "{{blocks}} blocchi sincronizzati"
}, hiddenWallet = {
  info1HTML: "Per scopi di negazione plausibile, un portafoglio nascosto può essere creato sulla base di una combinazione <strong>diversa</strong> di password del dispositivo + password di recupero.",
  info2HTML: "Definisci la password del dispositivo e la password di recupero che vuoi associare al tuo portafoglio nascosto qui sotto. La password del dispositivo e la password di recupero devono essere <strong>diverse</strong> da quelle che hai definito per il tuo portafoglio principale.",
  passwordLabel: "Password di recupero nascosta",
  passwordPlaceholder: "Si prega di confermare la password di recupero nascosta",
  pinLabel: "Password nascosta del dispositivo",
  pinRepeatLabel: "Ripetere la password del dispositivo nascosto",
  pinRepeatPlaceholder: "Si prega di confermare la password del dispositivo nascosto",
  success: "Portafoglio nascosto creato con successo. Ricollega il tuo BitBox per sbloccarlo."
}, initialize = {
  create: "Imposta la password del dispositivo",
  creating: "Impostazione della password del dispositivo...",
  error: {
    e102: "La password del dispositivo deve essere composta da almeno 4 caratteri."
  },
  info: {
    description1: "Scegli la password del tuo dispositivo. Questa sarà usata per sbloccare il tuo BitBox.",
    description2: "Puoi usare numeri, lettere e simboli. Password più lunghe offrono maggiore sicurezza.",
    description3: "Se perdi la password del dispositivo, dovrai resettare il tuo dispositivo e ripristinare il backup del portafoglio.",
    subtitle: "Ora imposterai la password del tuo dispositivo",
    title: "Inizializzazione del dispositivo"
  },
  input: {
    label: "Password del dispositivo",
    labelRepeat: "Ripetere la password del dispositivo",
    placeholderRepeat: "Si prega di confermare la password del dispositivo"
  }
}, invalidFormat = "Formato non valido", language$1 = {
  title: "Seleziona lingua"
}, legacyhiddenwallet = {
  disable: "Disattiva il portafoglio nascosto legacy",
  enable: "Abilita il portafoglio nascosto legacy",
  successDisable: "Portafoglio nascosto legacy disattivato con successo",
  successEnable: "Il portafoglio nascosto legacy è stato attivato con successo. Ricollega il tuo BitBox e inserisci la password del dispositivo nascosto per accedere al portafoglio nascosto legacy."
}, loading = "caricamento...", manageAccounts = {
  accountHidden: "Questo account è stato nascosto dalla lista degli account watch-only. Per vederlo di nuovo, connetti il tuo BitBox02",
  editAccount: "Modifica",
  editAccountNameTitle: "Modifica il nome dell'account",
  noAccounts: "Nessun account trovato",
  settings: {
    hideTokens: "Nascondi token",
    showTokens: "Mostra token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aggiungi e mostra/nascondi gli account",
  title: "Gestisci gli account",
  watchAccount: "Watch-only account",
  watchAccountDescription: "Questo account è stato aggiunto alla lista degli account watch-only. Disattiva per nasconderlo."
}, mobile = {
  usingMobileDataWarning: "Utilizzo di dati mobili: dopo aver sbloccato un account questa app può scaricare fino a qualche centinaio di megabyte di dati dell'intestazione della blockchain. Si prega di connettersi al Wi-Fi per evitare di utilizzare i dati mobili. Dopo averlo chiuso, questo messaggio non verrà più visualizzato."
}, newSettings = {
  about: {
    appVersion: {
      title: "Versione dell'app"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Blocca l'accesso all'app con blocco schermo/impronta digitale.",
      title: "Blocco schermo"
    },
    coinControl: {
      description: "Seleziona quali UTXOs fanno parte di una transazione per aiutarti ad aumentare la tua privacy."
    },
    customFees: {
      description: "Ti permette di inserire una fee a tua discrezione all'invio."
    },
    torProxy: {
      description: "Connettiti tramite Tor per una migliore privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Puoi ruotare tra queste valute aggiuntive dalla pagina del tuo account.",
      title: "Valute attive"
    },
    darkmode: {
      description: "Visualizza la BitBoxApp in modalità scura."
    },
    defaultCurrency: {
      description: "Selezione la valuta di default",
      title: "Valuta di default"
    },
    hideAmounts: {
      description: "Visualizza un'opzione per nascondere il tuo bilancio e gli importi per aumentare la tua privacy quando usi l'app in pubblico.",
      hideAmounts: "Nascondi importi",
      showAmounts: "Mostra importi",
      title: "Abilita importi nascosti"
    },
    language: {
      description: "In che lingua preferisci visualizzare la BitBoxApp.",
      title: "Lingua"
    },
    toggleSats: {
      description: "Abilita o disabilita i Satoshi"
    }
  }
}, note$1 = {
  input: {
    description: "(facoltativo)",
    placeholder: "Aggiungi nota..."
  },
  title: "Nota"
}, notification = {
  newTxs_one: "Nuova transazione in: {{accountName}}",
  newTxs_other: "{{count}} nuove transazioni in: {{accountName}}"
}, pairing = {
  aborted: {
    text: "L'abbinamento è stato interrotto dall'applicazione mobile.",
    title: "Interrotto"
  },
  button: "Abbina l'applicazione mobile",
  confirm: "Sei sicuro/a di voler abbinare il tuo BitBox? Si noti che in seguito, il telefono cellulare sarà necessario per eseguire transazioni.",
  connectOnly: {
    button: "Collegare l'applicazione mobile",
    title: "Esegui la scansione con la nostra applicazione mobile selezionando la voce di menu 'Connetti a nuova applicazione desktop'."
  },
  error: {
    text: "Qualcosa è andato storto. Per favore, ricomincia.",
    title: "Errore"
  },
  pullFailed: {
    text: "Impossibile estrarre un messaggio dal tuo cellulare attraverso il server relay. Il server potrebbe essere offline, contatta il supporto.",
    title: "Fallito"
  },
  reconnectOnly: {
    button: "Riconnetti applicazione mobile"
  },
  scanningFailed: {
    text: "Il cellulare non è stato in grado di scansionare il messaggio con successo. Si prega di riprovare.",
    title: "Scansione fallita"
  },
  start: {
    hideAppQRCode: "Nascondi il codice QR",
    revealAppQRCode: "Mostra il codice QR",
    step1: "Se non hai l'applicazione mobile, puoi scansionare il codice QR per l'App Store di Apple o il Play Store di Google, a seconda del telefono che usi.",
    step2: "Scansiona con la nostra applicazione mobile, che puoi trovare sotto il nome 'Digital Bitbox 2FA' negli app store per iOS e Android:"
  },
  started: {
    text: "Ora segui le istruzioni dell'applicazione mobile.",
    title: "Ottimo"
  },
  success: {
    text: "Congratulazioni, hai abbinato con successo il tuo BitBox con l'applicazione mobile",
    title: "Successo"
  },
  timeout: {
    text: "L'abbinamento è scaduto dopo due minuti. Ricomincia se vuoi ancora abbinare l'applicaione mobile.",
    title: "Timeout"
  },
  title: "Abbinamento telefono cellulare"
}, passphrase = {
  considerations: {
    button: `Considerazioni sul backup
`,
    message: `La passphrase aggiunge un livello di protezione al backup del portafoglio (scheda microSD o parole di recupero). Se qualcuno ha accesso al vostro backup, avrà bisogno anche della passphrase per accedere al vostro portafoglio.

Tuttavia, questo significa che saranno necessari <strong>sia la passphrase che il backup del portafoglio</strong> per ripristinare il portafoglio abilitato alla passphrase, nel caso in cui il BitBox02 venga perso o rotto. Se si dimentica o si perde la passphrase, si perde l'accesso a tutte le valute del portafoglio.

Quando si memorizza la passphrase, si consiglia di conservarla in un luogo separato rispetto al backup. In questo modo, se qualcuno trova il backup, non troverà anche la passphrase.`,
    title: "Considerazioni sul backup"
  },
  disable: "Disabilita la passphrase",
  disableInfo: {
    button: "Disabilita",
    message: `Una volta disabilitata la passphrase, non verrà più richiesto di inserire una passphrase dopo aver sbloccato il BitBox02. Pertanto, si accederà al proprio portafoglio predefinito.

Tutte le valute presenti nel portafoglio con la passphrase saranno ancora presenti in quel portafoglio, ma non sarà possibile accedervi perché, dopo aver sbloccato il BitBox02, si aprirà il portafoglio predefinito.

Per accedere nuovamente ai portafogli di passphrase, è sufficiente riattivare la funzione passphrase e inserire la relativa passphrase dopo aver sbloccato il BitBox02.

<strong>Suggerimento:</strong> È ancora possibile accedere al portafoglio originale lasciando la passphrase vuota.`
  },
  enable: "Abilita la passphrase",
  error: {
    e104: "La modifica dell'impostazione della passphrase è stata interrotta."
  },
  how: {
    button: "Come si presenta",
    message: `Una passphrase non funziona come una password a cui si è abituati. Se si sbaglia a digitare la passphrase, non si riceve alcuna notifica. Questo perché <strong>ogni passphrase crea un portafoglio diverso, ma valido</strong>. Ciò significa che è possibile utilizzare diverse passphrase per tanti portafogli quanti se ne desiderano. Ma si può accedere a ciascun portafoglio solo digitando la passphrase corrispondente.

Quando si collega il BitBox02, viene richiesta la password del dispositivo come di consueto. Successivamente, verrà richiesto di inserire una passphrase sul dispositivo.

Dopo aver inserito la passphrase, vi verrà mostrata la passphrase inserita. In questo modo si può confermare di averla inserita correttamente.`,
    title: "Come funziona"
  },
  intro: {
    message: `Una passphrase fornisce un ulteriore livello di sicurezza oltre al portafoglio.
Scopriamo come funziona.`,
    title: "Impostare la passphrase"
  },
  progressDisable: {
    message: "Confermare sul BitBox che si desidera <strong>disabilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  progressEnable: {
    message: "Confermare su BitBox che si desidera <strong>abilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  successDisabled: {
    message: `Passphrase opzionale <strong>attivata con successo</strong>!
D'ora in poi verrà richiesto di fornire una passphrase.`,
    messageEnd: `Ricollegare ora il BitBox02.
`,
    title: "Passphrase abilitata"
  },
  successEnabled: {
    message: `Passphrase opzionale <strong>disabilitata con successo</strong>!

Non verrà più richiesto di fornire una passphrase.`,
    messageEnd: `Ricollegare ora il BitBox02.
`,
    tips: "Suggerimenti",
    tipsList: [
      "Si consiglia di inviare prima un piccolo importo al portafoglio con passphrase. Quindi scollegare e ricollegare il BitBox02 e inserire la password e la passphrase. Se la passphrase è stata inserita correttamente, si dovrebbero vedere i fondi nel portafoglio.",
      "Se si desidera accedere al portafoglio originale senza passphrase, è ancora possibile farlo non inserendo nulla quando viene richiesto di inserire la passphrase. Oppure puoi disattivare la funzione passphrase."
    ],
    title: "Passphrase disabilitata"
  },
  summary: {
    button: "Passphrase disabilitata",
    title: "Riepilogo",
    understand: `Ho capito come funziona la passphrase e i rischi ad essa associati.
`,
    understandList: [
      `La passphrase è un ulteriore livello di sicurezza oltre al backup.
`,
      `L'inserimento di una passphrase diversa genererà sempre un portafoglio diverso.
`,
      "Per ripristinare il portafoglio sono necessari <strong>sia la passphrase che il backup</strong>.",
      `Se si dimentica la passphrase, <strong>non è più possibile accedere ai propri fondi</strong>.
`
    ]
  },
  what: {
    button: "Scopri come funziona",
    message: `Un portafoglio viene creato (derivato) da un numero casuale molto grande, noto anche come seed. Questo seed viene creato quando si configura per la prima volta il BitBox02 e viene salvato nella scheda microSD o in una lista di parole di recupero. Chiunque abbia accesso al seed ha il pieno controllo sui fondi di quel portafoglio.

Una passphrase è un <strong>segreto opzionale</strong>, aggiunto al seed. Quando si usa una passphrase, ogni passphrase crea un nuovo portafoglio basato sul seed + passphrase (segreto opzionale). Una passphrase può essere qualsiasi cosa: lettere, parole, caratteri speciali o può anche essere vuota. Il portafoglio predefinito deriva infatti dal seed + passphrase vuota.

La passphrase fa parte dello standard BIP39, il che significa che è compatibile con tutti i portafogli che supportano lo stesso standard.`,
    title: "Cos'è una passphrase?"
  },
  why: {
    button: "Perchè usare una passphrase",
    message: `BitBox02 protegge il seed dall'estrazione dal dispositivo stesso, ma il backup (scheda microSD o parole di recupero) dà pieno accesso al portafoglio. Per questo motivo deve essere conservato in un luogo sicuro!

Poiché una passphrase crea un nuovo portafoglio utilizzando il seed esistente, il portafoglio con l apassphrase richiede sia il <strong>backup che la passphrase per il ripristino</strong>. Il vantaggio è che se qualcuno trova il vostro backup, ha comunque bisogno della passphrase per accedere al portafoglio con la passphrase.

Inoltre, la funzione passphrase consente di creare più portafogli sullo stesso dispositivo, o "portafogli nascosti", oltre a quello predefinito.`,
    title: "Perchè usare una passphrase?"
  }
}, password = {
  show: "Mostra {{label}}",
  warning: {
    caps: 'per incollare il testo, attivare "MOSTRA {{etichetta}}"',
    paste: 'per incollare il testo, attivare "MOSTRA {{label}}"'
  }
}, random$1 = {
  button: "Genera un numero casuale",
  description: "Il tuo BitBox ha generato il seguente numero casuale {{bits}}-bit:"
}, receive$2 = {
  changeScriptType: "Cambia il tipo di indirizzo",
  label: "Il tuo indirizzo",
  onlyThisCoin: {
    description: "Per ricevere altri token, abilitali nelle impostazioni. Se depositi altri token, potrebbero non essere accessibili.",
    warning: "Assicurati di ricevere solo {{coinName}} su questo indirizzo."
  },
  scriptType: {
    p2tr: "Taproot (formato più recente)",
    p2wpkh: "Native Segwit (predefinito)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatibile)"
  },
  selectAccount: "Scegli un account",
  showFull: "Mostra e verifica l'indirizzo completo sul dispositivo",
  taprootWarning: "Nota: Taproot è una nuova funzione di Bitcoin e non è ancora ampiamente adottata. I fondi ricevuti sugli indirizzi Taproot potrebbero non essere visibili nei portafogli di terze parti. Molti portafogli e exchange non sono ancora in grado di inviare ad indirizzi Taproot.",
  title: "Ricevi {{accountName}}",
  verify: "Verificare l'indirizzo in modo sicuro",
  verifyBitBox01: "Verificare l'indirizzo sull'applicazione mobile",
  verifyBitBox02: "Verificare l'indirizzo sul BitBox02",
  verifyInstruction: "Verifica che il seguente indirizzo corrisponda a quello visualizzato sul tuo dispositivo.",
  warning: {
    secureOutput: "Si prega di associare il tuo BitBox con il tuo dispositivo mobile per abilitare la verifica sicura dell'indirizzo. Vai su 'Gestisci dispositivo' nella barra laterale."
  }
}, reset = {
  description: "Tutti i dati saranno cancellati dal dispositivo. Inclusa la tua chiave privata!",
  notReset: "Dispositivo NON resettato.",
  title: "Ripristino di fabbrica del dispositivo",
  understand: "Ho un backup e conosco la mia password di recupero",
  understandBB02: "Ho un backup valido"
}, securityInformation = {
  create: {
    description1: "Ti consigliamo di impostare il tuo dispositivo in un ambiente sicuro, cioè lontano da altre persone che potrebbero vedere la password che hai scelto.",
    description2: "Ti verrà chiesto di creare due password.",
    description3: "La prima è la <strong>password del dispositivo</strong> che sblocca il tuo dispositivo BitBox e può essere cambiata in seguito.",
    description4: "La seconda è la <strong>password di recupero</strong> che sblocca il tuo portafoglio. Questa password non può essere cambiata in seguito.",
    description5: "Il portafoglio creato sarà salvato in un file sulla scheda microSD fornita. Questo può essere utilizzato in caso di emergenza per recuperare i tuoi fondi utilizzando la tua <strong>password di recupero</strong>.",
    title: "Informazioni di sicurezza"
  },
  restore: {
    description1: "Ti verrà chiesto di inserire la scheda microSD che hai usato per memorizzare il tuo backup.",
    description2: "Per ripristinare il tuo dispositivo avrai bisogno della tua password di recupero. ",
    description3: "Fai attenzione quando inserisci la password di recupero. Qualsiasi password inserita creerà un portafoglio valido. Se inserisci la password sbagliata, potrebbe esserti mostrato un saldo del portafoglio che non ti aspetti.",
    title: "Informazioni di sicurezza"
  }
}, seed = {
  agreements: {
    "funds-access": "NON potrò accedere ai miei fondi se dimentico la mia password di recupero",
    "password-change": "NON posso cambiare la password di recupero in futuro.",
    "password-required": "La password di recupero è necessaria per ripristinare un portafoglio da un backup"
  },
  create: "Crea un portafoglio",
  creating: "Creazione del portafoglio",
  description: "Capisco che:",
  error: {
    e102: "La password deve essere composta da almeno 4 caratteri.",
    e200: "È necessario inserire una scheda microSD nel tuo BitBox per creare un portafoglio, così un backup può essere creato automaticamente."
  },
  info: {
    button: `Imposta ora la password di recupero
`,
    description1: "Inserire la scheda microSD nel BitBox",
    description2: 'Scegli una password di recupero per il portafoglio e seleziona "Imposta password di recupero ora".',
    description3: "Il backup su scheda microSD e la password di recupero sono l'unico metodo per recuperare i tuoi fondi in caso di perdita o furto del dispositivo BitBox.",
    description4: "Non è possibile cambiare la password di recupero in futuro senza dover trasferire i tuoi fondi.",
    title: "Crea un nuovo portafoglio"
  },
  password: {
    label: "Password di recupero",
    repeatPlaceholder: "Ripeti la password di recupero"
  },
  walletName: {
    label: "Nome del portafoglio"
  }
}, seedRestore = {
  error: {
    e200: "Il ripristino di un portafoglio da un backup richiede la scheda microSD."
  },
  info: {
    description1: 'Inserire la scheda microSD nel BitBox e cliccare su "Continua".',
    description2: 'Scegliete un backup e cliccate su "Ripristina".',
    description3: "Inserisci la password di recupero",
    description4: "Confermo di aver capito che una password errata creerà un portafoglio diverso.",
    title: "Come ripristinare un portafoglio da un backup"
  }
}, send$2 = {
  abort: "La transazione è stata annullata",
  address: {
    label: "Indirizzo del destinatario",
    placeholder: "Inserisci indirizzo"
  },
  amount: {
    label: "Importo",
    placeholder: "Inserisci importo"
  },
  availableBalance: "Saldo disponibile",
  button: "Controlla",
  coincontrol: {
    address: "Indirizzo",
    outpoint: "Outpoint",
    title: "Invia da un output"
  },
  confirm: {
    "selected-coins": "Seleziona valute",
    title: "Conferma ed invia transazione",
    total: "Totale"
  },
  error: {
    erc20InsufficientGasFunds: "Sembra che tu non abbia abbastanza Ether per pagare questa transazione ERC20. Per favore, assicurati di avere abbastanza Ether nel tuo portafoglio.",
    feeTooLow: "commissione troppo bassa",
    feesNotAvailable: `Impossibile stimare le commissioni
`,
    insufficientFunds: "fondi insufficienti.",
    invalidAddress: "indirizzo non valido",
    invalidAmount: "importo non valido",
    invalidData: "dati non validi"
  },
  fee: {
    customPlaceholder: "Inserisci importo",
    label: "Commissioni di rete",
    placeholder: "Non disponibile"
  },
  feeTarget: {
    customLabel: "Tariffa",
    customLabel_eth: "Gas",
    description: {
      economy: "4 ore (24 blocchi)",
      economy_eth: "30 minuti al massimo",
      economy_ltc: "1 ora (24 blocchi)",
      high: "20 minuti (2 blocchi)",
      high_eth: "30 secondi al massimo",
      high_ltc: "5 minuti (2 blocchi)",
      low: "2 ore (12 blocchi)",
      low_eth: "5 minuti al massimo",
      low_ltc: "30 minuti (12 blocchi)",
      normal: "6 blocchi (circa 1 ora per Bitcoin, 15 minuti per Litecoin)",
      normal_eth: "2 minuti al massimo",
      normal_ltc: "15 minuti (6 blocchi)"
    },
    estimate: "Tempo di conferma stimato:",
    label: {
      custom: "Personalizzata",
      economy: "Economica",
      high: "Alta",
      low: "Bassa",
      normal: "Normale"
    },
    placeholder: "Calcolo delle commissioni..."
  },
  maximum: "Invia tutto",
  maximumSelectedCoins: `Invia le valute selezionate
`,
  noFeeTargets: "La stima delle fee al momento non è disponibile. Inserisci una fee a tua discrezione o riprova più tardi.",
  priority: "Priorità",
  scanQR: "Leggi il QR code",
  signprogress: {
    description: "Questa è una transazione che contiene molti dati. Per firmare la transazione, ti verrà chiesto di confermare {{steps}} volte.",
    label: "Progresso"
  },
  success: "La transazione è stata firmata ed inviata.",
  title: "Invia {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Dettagli della transazione"
}, settings$1 = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Impostazioni avanzate",
  appearance: "Aspetto",
  electrum: {
    add: "Aggiungi un server",
    "add-server": "Aggiungi",
    check: "Verifica",
    checkFailed: "Fallito",
    checkSuccess: "Connessione stabilita con {{host}}",
    checking: "Verifico",
    "download-cert": "Scarica certificato remoto",
    "remove-server": "Rimuovi",
    removeConfirm: "Rimuovere {{server}}?",
    reset: "Ripristina le impostazioni predefinite",
    resetConfirm: "Vuoi rimuovere tutti i server e installare quelli di default?",
    servers: "Server",
    step1: "1",
    "step1-text": "Inserisci l'endpoint.",
    step2: "2",
    "step2-text": "Inserisci un certificato della catena dei certificati del server. In alternativa, scarica il certificato remoto e confrontalo visivamente.",
    "step2-text-tcp": "Puoi saltare questo passo se non vuoi usare TLS.",
    step3: "3",
    "step3-text": "Controlla la connessione e aggiungi il server.",
    step4: "4",
    "step4-text": "Riavvia il portafoglio. Se non rimuovi i server di default, il tuo nodo sarà aggiunto come ridondanza.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: 'Abilita "coin control"',
    electrum: {
      description: "Puoi connetterti al tuo full node Electrum",
      title: "Connetti il tuo full node"
    },
    fee: "Abilitare commissioni personalizzate",
    setProxyAddress: "Imposta indirizzo proxy",
    title: "Impostazioni avanzate",
    useProxy: "Abilita il proxy per tor",
    useSats: "Mostra i valori BTC in Satoshi"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nuovo aggiornamento disponibile",
    title: "Informazioni",
    "up-to-date": "La tua app è aggiornata",
    version: "Versione App"
  },
  restart: "Si prega di riavviare la BitBoxApp affinché le modifiche abbiano effetto.",
  services: {
    title: "Servizi"
  },
  success: "Si prega di scollegare e ricollegare il BitBox affinché le modifiche abbiano effetto.",
  title: "Impostazioni"
}, setup = "Imposta il dispositivo", sidebar$1 = {
  buy: "Acquista criptovalute",
  device: "Gestisci il dispositivo",
  leave: "Esci",
  settings: "Impostazioni"
}, success$7 = {
  create: {
    info1: "Il tuo portafoglio è stato salvato in modo sicuro sulla scheda microSD. Rimuovila e tienila al sicuro.",
    info2: "Hai creato una password sicura del dispositivo che sblocca il BitBox.",
    info3: "Hai creato una password di recupero sicura per il tuo portafoglio che sblocca i tuoi fondi e ripristina i tuoi backup.",
    summary: "Ecco un riassunto di quello che hai fatto",
    title: "Successo"
  },
  getstarted: "Inizia",
  restore: {
    summary: "Hai ripristinato con successo un portafoglio dal tuo backup.",
    title: "Successo"
  }
}, transaction$1 = {
  confirmation: "Conferme",
  details: {
    activity: "Attività",
    address: "Indirizzo",
    amount: "Importo",
    date: "Data",
    fiat: "Fiat",
    fiatAmount: "Importo fiat",
    fiatAtTime: "Fiat al tempo della transazione",
    status: "Status",
    type: "Tipo"
  },
  explorer: "ID della transazione",
  explorerTitle: "Apri in un esploratore di blocchi esterno",
  fee: "Commissione",
  fiatHistorical: "Storico",
  gas: "Gas",
  note: {
    edit: "Modifica nota",
    save: "Salva nota"
  },
  pending: "Transazione in sospeso",
  size: "Dimensione",
  status: {
    complete: "Completata",
    failed: "Fallita",
    pending: "In sospeso"
  },
  tx: {
    received: "Ricevuta a",
    sent: "Inviata a"
  },
  vsize: "Dimensione virtuale",
  weight: "Peso"
}, transactions = {
  errorLoadTransactions: "Si è verificato un errore nel carimento delle transazioni",
  placeholder: "Nessuna transazione."
}, unknownError = "Si è verificato un errore sconosciuto: {{errorMessage}}", unlock = {
  description: "Inserisci la password del tuo dispositivo per sbloccarlo.",
  error: {
    e109_normal: "Password del dispositivo errata. Restano ancora {{remainingAttempts}} tentativi prima che il dispositivo venga resettato.",
    e109_touch: "$t(unlock.error.e109_normal) Il prossimo login richiede di tenere premuto il pulsante touch.",
    e113: "A causa di molti tentativi di login, il login successivo richiede di tenere premuto il pulsante a sfioramento per 4 secondi."
  },
  input: {
    label: "Password del dispositivo",
    placeholder: "Inserisci la password del tuo dispositivo per sbloccare il dispositivo"
  },
  unlocking: "Sblocco..."
}, upgradeFirmware$1 = {
  button: "Aggiorna il firmware",
  description: "Vuoi aggiornare il firmware dalla versione {{currentVersion}} alla {{newVersion}}?",
  label: "Il tuo BitBox richiede un aggiornamento del firmware.",
  locked: "Per aggiornare da {{currentVersion}} a {{newVersion}}, fai un tocco lungo.",
  title: "Aggiorna il firmware",
  unlocked: "Il bootloader è sbloccato. Per continuare, per favore:",
  unlocked1: "Scollegare e ricollegare il vostro Bitbox",
  unlocked2: "Il LED si accende quando il tuo BitBox è ricollegato",
  unlocked3: "Tocca il pulsante a sfioramento quando il LED si accende"
}, walletConnect$2 = {
  connect: {
    button: "Conneti",
    dappLabel: "Inserire indirizzo URI della DApp",
    invalidPairingUri: "URI di connessione non valido"
  },
  dashboard: {
    allSessions: "Tutte le sessioni",
    disclaimer: "WalletConnect è un protocollo per connettersi a Dapp basate su Ethereum. Queste DApp sono gestite da servizi di terze parti, per cui connettiti solo a DApp di cui ti fidi e accertati di sapere sempre cosa stai firmando quando crei una transazione.",
    newConnection: "Nuova Connessione",
    noConnectedSessions: "Nessun account è connesso a DApp al momento."
  },
  invalidPairingChain: "Errore nell'approvazione della connessione. Assicurati di utilizare una delle chain supportate: {{chains}}",
  pairingRequest: {
    approve: "Approva Connessione",
    reject: "Rifiuta",
    title: "Nuova richista di connessione da"
  },
  pairingSuccess: "DApp connessa. Puoi continuare sul sito della DApp.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Dati",
    dataParsingError: "Parse dei dati fallto.",
    decodeError: "Decodifica del messaggio fallita",
    method: {
      sendTransaction: "Firma ed invia transazione",
      signMessage: "Firma messaggio",
      signTransaction: "Firma transazione",
      signTypedData: "Firma typed data"
    },
    successfullySigned: "Richiesta firmata con successo",
    walletConnectRequest: "Richiesta WalletConnect"
  },
  useNewUri: "Questo URI è già stato utilizzato per provare a connettersi. Per favore, utilizzare un nuovo URI.",
  walletConnect: "WalletConnect"
}, warning$6 = {
  receivePairing: `Si prega di associare il BitBox per abilitare la verifica sicura dell'indirizzo. Vai su "Gestisci dispositivo" nella barra laterale.`,
  sdcard: "Tenere la scheda microSD separata dal BitBox, a meno che non si vogliano gestire i backup.",
  sendPairing: "Si prega di abbinare il BitBox per verificare in modo sicuro i dettagli della transazione. Vai su 'Gestisci dispositivo' nella barra laterale."
}, welcome = {
  connect: "Connetti BitBox02",
  getStarted: "Iniziamo con l'installazione del firmware sul BitBox02.",
  insertBitBox02: "Se hai collegato un BitBox02, tocca il dispositivo per continuare.",
  insertDevice: "Collega il tuo dispositivo per cominciare",
  title: "Benvenuto"
}, appTranslationsIT = {
  account,
  accountInfo,
  accountSummary,
  addAccount: addAccount$1,
  aopp,
  app,
  auth: auth$1,
  backup,
  bb02Bootloader,
  bitbox,
  bitbox02Interact,
  bitbox02Settings,
  bitbox02Wizard,
  blink,
  bootloader,
  button: button$4,
  buy: buy$1,
  changePin,
  chart: chart$1,
  checkSDcard,
  clickHere,
  confirm: confirm$2,
  confirmOnDevice,
  connectKeystore: connectKeystore$1,
  darkmode: darkmode$1,
  device,
  deviceLock,
  deviceSettings,
  deviceTampered,
  dialog: dialog$1,
  error: error$2,
  fiat: fiat$2,
  footer: footer$2,
  generic: generic$1,
  genericError,
  goal,
  guide: guide$1,
  headerssync,
  hiddenWallet,
  initialize,
  invalidFormat,
  language: language$1,
  legacyhiddenwallet,
  loading,
  manageAccounts,
  mobile,
  newSettings,
  note: note$1,
  notification,
  pairing,
  passphrase,
  password,
  random: random$1,
  receive: receive$2,
  reset,
  securityInformation,
  seed,
  seedRestore,
  send: send$2,
  settings: settings$1,
  setup,
  sidebar: sidebar$1,
  success: success$7,
  transaction: transaction$1,
  transactions,
  unknownError,
  unlock,
  upgradeFirmware: upgradeFirmware$1,
  walletConnect: walletConnect$2,
  warning: warning$6,
  welcome
};
function i18nextFormat(locale) {
  return locale.replace("_", "-");
}
__name(i18nextFormat, "i18nextFormat");
const localeMainLanguage = /* @__PURE__ */ __name((locale) => i18nextFormat(locale).split("-")[0], "localeMainLanguage"), getRegionNameFromLocale = /* @__PURE__ */ __name((nativeLocale) => {
  try {
    const formattedLocale = i18nextFormat(nativeLocale);
    return new Intl.Locale(formattedLocale).region || "";
  } catch {
    return "";
  }
}, "getRegionNameFromLocale"), defaultUserLanguage = "en", languageFromConfig = {
  type: "languageDetector",
  async: !0,
  detect: (cb2) => {
    apiGet("config").then(({ backend }) => {
      if (backend && backend.userLanguage) {
        cb2(backend.userLanguage);
        return;
      }
      apiGet("native-locale").then((locale) => {
        if (typeof locale == "string" && locale) {
          try {
            (/* @__PURE__ */ new Date()).toLocaleString(i18nextFormat(locale));
          } catch {
            cb2(defaultUserLanguage);
            return;
          }
          cb2(i18nextFormat(locale));
          return;
        }
        cb2(defaultUserLanguage);
      });
    });
  },
  init: () => {
  },
  cacheUserLanguage: () => {
  }
};
let pendingConfig = {};
const getConfig = /* @__PURE__ */ __name(() => apiGet("config"), "getConfig"), setConfig = /* @__PURE__ */ __name((object) => getConfig().then((currentConfig = {}) => {
  const nextConfig = Object.assign(currentConfig, {
    backend: Object.assign({}, currentConfig.backend, pendingConfig.backend, object.backend),
    frontend: Object.assign({}, currentConfig.frontend, pendingConfig.frontend, object.frontend)
  });
  return pendingConfig = nextConfig, apiPost("config", nextConfig).then(() => (pendingConfig = {}, nextConfig));
}), "setConfig"), locizeProjectID = "fe4e5a24-e4a2-4903-96fc-3d62c11fc502";
let i18Init = instance.use(languageFromConfig);
i18Init.init({
  fallbackLng: "en",
  // have a common namespace used around the full app
  ns: ["app", "wallet"],
  defaultNS: "app",
  debug: !1,
  returnObjects: !0,
  interpolation: {
    escapeValue: !1
    // not needed for react
  },
  react: {
    useSuspense: !0
    // Not using Suspense you will need to handle the not ready state yourself
  },
  backend: {
    projectId: locizeProjectID,
    referenceLng: "en"
  }
});
instance.addResourceBundle("ar", "app", appTranslationsAR);
instance.addResourceBundle("cs", "app", appTranslationsCS);
instance.addResourceBundle("de", "app", appTranslationsDE);
instance.addResourceBundle("en", "app", appTranslationsEN);
instance.addResourceBundle("fr", "app", appTranslationsFR);
instance.addResourceBundle("ja", "app", appTranslationsJA);
instance.addResourceBundle("ms", "app", appTranslationsMS);
instance.addResourceBundle("nl", "app", appTranslationsNL);
instance.addResourceBundle("ru", "app", appTranslationsRU);
instance.addResourceBundle("pt", "app", appTranslationsPT);
instance.addResourceBundle("hi", "app", appTranslationsHI);
instance.addResourceBundle("bg", "app", appTranslationsBG);
instance.addResourceBundle("tr", "app", appTranslationsTR);
instance.addResourceBundle("zh", "app", appTranslationsZH);
instance.addResourceBundle("fa", "app", appTranslationsFA);
instance.addResourceBundle("es", "app", appTranslationsES);
instance.addResourceBundle("sl", "app", appTranslationsSL);
instance.addResourceBundle("he", "app", appTranslationsHE);
instance.addResourceBundle("it", "app", appTranslationsIT);
instance.on("languageChanged", (lng) => getNativeLocale().then((nativeLocale) => {
  let match2 = lng === nativeLocale;
  if (!match2) {
    const lngLang = localeMainLanguage(lng), localeLang = localeMainLanguage(nativeLocale);
    match2 = lngLang === localeLang;
  }
  return setConfig({ backend: { userLanguage: match2 ? null : lng } });
}));
const captureStrongElement = /^(.*)<strong>(.*)<\/strong>(.*)$/;
function SimpleMarkup({ tagName, markup, ...props }) {
  if (typeof markup != "string")
    return null;
  const simpleMarkupChunks = captureStrongElement.exec(markup);
  return simpleMarkupChunks === null || simpleMarkupChunks.length !== 4 ? reactExports.createElement(tagName, props, markup) : reactExports.createElement(tagName, props, simpleMarkupChunks[1], reactExports.createElement("strong", null, simpleMarkupChunks[2]), simpleMarkupChunks[3]);
}
__name(SimpleMarkup, "SimpleMarkup");
const MultilineMarkup = /* @__PURE__ */ __name(({ tagName, markup, withBreaks, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: markup.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName, markup: line2, ...props }),
  withBreaks && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
] }, `${line2}-${i}`)) }), "MultilineMarkup"), DarkModeContext = reactExports.createContext({}), useDarkmode = /* @__PURE__ */ __name(() => {
  const { isDarkMode, toggleDarkmode } = reactExports.useContext(DarkModeContext);
  return { isDarkMode, toggleDarkmode };
}, "useDarkmode"), alert = "" + new URL("alert-triangle.svg", import.meta.url).href, BB02StylizedDark = "" + new URL("bitbox02-stylized-reflection-dark.png", import.meta.url).href, BB02StylizedLight = "" + new URL("bitbox02-stylized-reflection-light.png", import.meta.url).href, info$5 = "" + new URL("info2.svg", import.meta.url).href, arrowCircleLeftSVG = "" + new URL("arrow-circle-left.svg", import.meta.url).href, arrowCircleLeftActiveSVG = "" + new URL("arrow-circle-left-active.svg", import.meta.url).href, arrowCircleRightSVG = "" + new URL("arrow-circle-right.svg", import.meta.url).href, arrowCircleRightActiveSVG = "" + new URL("arrow-circle-right-active.svg", import.meta.url).href, bankDarkSVG = "" + new URL("bank.svg", import.meta.url).href, bankLightSVG = "" + new URL("bank-light.svg", import.meta.url).href, buyInfoSVG = "" + new URL("buy-info.svg", import.meta.url).href, checkedSmallSVG = "" + new URL("checked-small.svg", import.meta.url).href, checkSVG = "" + new URL("check.svg", import.meta.url).href, chevronRightDark = "" + new URL("chevron-right-dark.svg", import.meta.url).href, chevronLeftDark = "" + new URL("chevron-left-dark.svg", import.meta.url).href, cancelSVG = "" + new URL("cancel.svg", import.meta.url).href, creditCardDarkSVG = "" + new URL("credit-card.svg", import.meta.url).href, creditCardLightSVG = "" + new URL("credit-card-light.svg", import.meta.url).href, editSVG = "" + new URL("edit.svg", import.meta.url).href, editLightSVG = "" + new URL("edit-light.svg", import.meta.url).href, editActiveSVG = "" + new URL("edit-active.svg", import.meta.url).href, ETH = "" + new URL("eth-color.svg", import.meta.url).href, redDotSVG = "" + new URL("red-dot.svg", import.meta.url).href, copySVG = "" + new URL("copy.svg", import.meta.url).href, closeSVG = "" + new URL("close.svg", import.meta.url).href, closeXWhiteSVG = "" + new URL("close-x-white.svg", import.meta.url).href, closeXDarkSVG = "" + new URL("close-x-dark.svg", import.meta.url).href, externalLink = "" + new URL("external-link.svg", import.meta.url).href, eyeClosedSVG = "" + new URL("eye-closed.svg", import.meta.url).href, eyeOpenedSVG = "" + new URL("eye-opened.svg", import.meta.url).href, eyeOpenedDarkSVG = "" + new URL("eye-opened-dark.svg", import.meta.url).href, globeDarkSVG = "" + new URL("globe-dark.svg", import.meta.url).href, globeLightSVG = "" + new URL("globe-light.svg", import.meta.url).href, guideSVG = "" + new URL("guide.svg", import.meta.url).href, menuDarkSVG = "" + new URL("menu-dark.svg", import.meta.url).href, menuLightSVG = "" + new URL("menu-light.svg", import.meta.url).href, walletConnectDarkSVG = "" + new URL("wallet-connect-dark.svg", import.meta.url).href, walletConnectLightSVG = "" + new URL("wallet-connect-light.svg", import.meta.url).href, walletConnectDefaultSVG = "" + new URL("wallet-connect-default.svg", import.meta.url).href, warningPNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACowAAAqMBZNxfiQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOMSURBVGiB7ZjPS5RBGMe/877vrluJmLqR4KEfICJ46CB0CNwOGS5sLf0FYq63grqWseipJOzaD6N7lyBSUohAgkDpkgcREiI96Wp00d33dZ4Ou67uvvP6zjvvLFvg97bzzjzP892Z+bwzL3CsY4USq1Xg3FCqnwx+v5iEnra+mp6rRZ6aGNgaSV3hnH8GYJaaHIN4omVq5ovuXIbugJRNWJz4cxwUDwAWN4wXlE1YuvNpN5BbO5UBodv1gNC9ud44rDuf1iW0PZhu3rPsFQBxjy4bphPpPP3m3W9dObXOgGMWRuFdPADEuWU/1JlT2wxsZJKdjNgSgIhP1wIx6om/nF7RkVfbDDDOJuBfPABEGbEn2vLqCFJi/sdAiblxvfX1+9mwuUPPAGUTFpl8MvA4k0/qwGpoA57Y9JMmrIZaQhLY9FNorIaagRISVYsHgDiP2A/C1KA8AyVsfgcQrX4WSyQR679V0bYz8xb5eeE+D4VV5U3EOJsAcxcPAIhEYcbPVva3PAm7j9W0Sh1KSyg3lOoHww3PDoW8q4lsd9sh3cwNpfpVaglsQAabZBfcjQVB2+ExilgNbGBzvXHYD5skKNZnBopY/XXydtB6AhnYHkw3M6Ix346CYkWmqsUYG98eTDcHqSmQAVlsCosVLSu3AmNV2sBGJtlJwB2ZvqI9INwXorGEuxuZZKdsXdIGSqdNMTarJaKQxBIqKdBpVcqALzarJPy3/TZxpaSx6mtA5bQppJD8DBT7S2LV14AMNl0SUUhyDxwMkMPqkQaksVmd27bdjYJ94ScZrB5pQPW06XppEYEcgSl/+WLV00AQbLrkOADn5Z/k2ACRUig/rHpukiNPmxJyVpeBSHE45XdVwwA+p1XhfUDlkl5reX0EcC0h1Ut6reWFVZcBJWyKxBjMM+0w4+0A0/D1xgOrFZE1XNKLQWMn0HRvHNaFLgCA82MZf56NgnZ3woQFBB8BKmZAwyUdABDrGygXDwDWxS7E+gbChgUEWC0bCIXNKrHGJqk2FVVjtWyghCplbB5WYWG+4sVFjo3CwryO0AAQZcDj/R8MqA02zY5zaLh8FSAg//UT9tZ/6gxfxiqjbNbIrS0uAnRJa4ba61trR28v+xdfWtJiuGZwttdW7zpURUCb0WCaswC26l2MgnIN+egcA4CtkWQP5+wRgPN1LkpODKsGx1jL1IelepdyrP9efwF60oqTW0b3mgAAAABJRU5ErkJggg==", warningOutlinedSVG = "" + new URL("warning-outlined.svg", import.meta.url).href, qrCodeDarkSVG = "" + new URL("qr-dark.svg", import.meta.url).href, qrCodeLightSVG = "" + new URL("qr-light.svg", import.meta.url).href, saveSVG = "" + new URL("save.svg", import.meta.url).href, saveLightSVG = "" + new URL("save-light.svg", import.meta.url).href, selectedCheckLightSVG = "" + new URL("selected-check-light.svg", import.meta.url).href, usbSuccessSVG = "" + new URL("usb-success.svg", import.meta.url).href, expandIcon = "_expandIcon_j17uw_1", style$13 = {
  expandIcon
}, ExpandOpen = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$13.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "11", y1: "8", x2: "11", y2: "14" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
), "ExpandOpen"), ExpandClose = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$13.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
), "ExpandClose"), AnimatedChecked = /* @__PURE__ */ __name(({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: `checked ${className || ""}`, viewBox: "0 0 52 52", ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "checked-circle", cx: "26", cy: "26", r: "25", fill: "none" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "checked-check", fill: "none", d: "M14.1 27.2l7.1 7.2 16.7-16.8" })
] }), "AnimatedChecked"), CaretDown = /* @__PURE__ */ __name(({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `caretDown ${className || ""}`, viewBox: "0 0 1024 1024", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }) }), "CaretDown"), ExpandIcon = /* @__PURE__ */ __name(({
  expand = !0
}) => expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandOpen, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandClose, {}), "ExpandIcon"), Info$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: info$5, draggable: !1, ...props }), "Info$1"), BitBox02StylizedDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedDark, draggable: !1, ...props }), "BitBox02StylizedDark"), BitBox02StylizedLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedLight, draggable: !1, ...props }), "BitBox02StylizedLight"), ArrowCirlceLeft = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftSVG, draggable: !1, ...props }), "ArrowCirlceLeft"), ArrowCirlceLeftActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftActiveSVG, draggable: !1, ...props }), "ArrowCirlceLeftActive"), ArrowCirlceRight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightSVG, draggable: !1, ...props }), "ArrowCirlceRight"), ArrowCirlceRightActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightActiveSVG, draggable: !1, ...props }), "ArrowCirlceRightActive"), BankDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankDarkSVG, draggable: !1, ...props }), "BankDark"), Bank = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankLightSVG, draggable: !1, ...props }), "Bank"), BuyInfo$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: buyInfoSVG, draggable: !1, ...props }), "BuyInfo$1"), Checked = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkedSmallSVG, draggable: !1, ...props }), "Checked"), Check$3 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkSVG, draggable: !1, ...props }), "Check$3"), ChevronLeftDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronLeftDark, draggable: !1, ...props }), "ChevronLeftDark"), ChevronRightDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronRightDark, draggable: !1, ...props }), "ChevronRightDark"), Cancel = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cancelSVG, draggable: !1, ...props }), "Cancel"), CreditCardDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardDarkSVG, draggable: !1, ...props }), "CreditCardDark"), CreditCard = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardLightSVG, draggable: !1, ...props }), "CreditCard"), RedDot = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: redDotSVG, draggable: !1, ...props }), "RedDot"), Copy = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: copySVG, draggable: !1, ...props }), "Copy"), Close = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeSVG, draggable: !1, ...props }), "Close"), CloseXWhite = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXWhiteSVG, draggable: !1, ...props }), "CloseXWhite"), CloseXDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXDarkSVG, draggable: !1, ...props }), "CloseXDark"), Edit = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editSVG, draggable: !1, ...props }), "Edit"), EditLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editLightSVG, draggable: !1, ...props }), "EditLight"), EditActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editActiveSVG, draggable: !1, ...props }), "EditActive"), ETHLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ETH, draggable: !1, ...props }), "ETHLogo"), ExternalLink = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: externalLink, draggable: !1, ...props }), "ExternalLink"), EyeClosed = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeClosedSVG, draggable: !1, ...props }), "EyeClosed"), EyeOpened = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedSVG, draggable: !1, ...props }), "EyeOpened"), EyeOpenedDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedDarkSVG, draggable: !1, ...props }), "EyeOpenedDark"), GlobeDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeDarkSVG, draggable: !1, ...props }), "GlobeDark"), GlobeLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeLightSVG, draggable: !1, ...props }), "GlobeLight"), GuideActive = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: guideSVG, draggable: !1, ...props }), "GuideActive"), MenuDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuDarkSVG, draggable: !1, ...props }), "MenuDark"), MenuLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuLightSVG, draggable: !1, ...props }), "MenuLight"), WalletConnectDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDarkSVG, draggable: !1, ...props }), "WalletConnectDark"), WalletConnectLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectLightSVG, draggable: !1, ...props }), "WalletConnectLight"), WalletConnectDefaultLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDefaultSVG, draggable: !1, ...props }), "WalletConnectDefaultLogo"), Warning = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningPNG, draggable: !1, ...props }), "Warning"), WarningOutlined = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningOutlinedSVG, draggable: !1, ...props }), "WarningOutlined"), QRCodeDark = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeDarkSVG, draggable: !1, ...props }), "QRCodeDark"), QRCodeLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeLightSVG, draggable: !1, ...props }), "QRCodeLight"), Save = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveSVG, draggable: !1, ...props }), "Save"), SaveLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveLightSVG, draggable: !1, ...props }), "SaveLight"), SelectedCheckLight = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedCheckLightSVG, draggable: !1, ...props }), "SelectedCheckLight"), USBSuccess = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: usbSuccessSVG, draggable: !1, ...props }), "USBSuccess"), Alert$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: alert, draggable: !1, ...props }), "Alert$1"), AppLogoInvertedImg = "" + new URL("app-logo-inverted.svg", import.meta.url).href, AppLogoImg = "" + new URL("app-logo.svg", import.meta.url).href, BitBoxLogo = "" + new URL("bitbox-logo.svg", import.meta.url).href, BitBox02Logo = "" + new URL("bitbox02-logo.svg", import.meta.url).href, BitBox02InvertedLogo = "" + new URL("bitbox02inverted-logo.svg", import.meta.url).href, BTC = "" + new URL("btc-color.svg", import.meta.url).href, BTC_GREY = "" + new URL("btc-white.svg", import.meta.url).href, ETH_GREY = "" + new URL("eth-white.svg", import.meta.url).href, LTC = "" + new URL("ltc-color.svg", import.meta.url).href, LTC_GREY = "" + new URL("ltc-white.svg", import.meta.url).href, SwissOpenSourceLight = "" + new URL("swiss-made-open-source-light.svg", import.meta.url).href, SwissOpenSourceDark = "" + new URL("swiss-made-open-source-dark.svg", import.meta.url).href, BAT = "" + new URL("bat-color.svg", import.meta.url).href, BAT_GREY = "" + new URL("bat-white.svg", import.meta.url).href, DAI = "" + new URL("dai-color.svg", import.meta.url).href, DAI_GREY = "" + new URL("dai-white.svg", import.meta.url).href, LINK = "" + new URL("link-color.svg", import.meta.url).href, LINK_GREY = "" + new URL("link-white.svg", import.meta.url).href, MKR = "" + new URL("mkr-color.svg", import.meta.url).href, MKR_GREY = "" + new URL("mkr-white.svg", import.meta.url).href, USDC = "" + new URL("usdc-color.svg", import.meta.url).href, USDC_GREY = "" + new URL("usdc-white.svg", import.meta.url).href, USDT = "" + new URL("usdt-color.svg", import.meta.url).href, USDT_GREY = "" + new URL("usdt-white.svg", import.meta.url).href, ZRX = "" + new URL("zrx-color.svg", import.meta.url).href, ZRX_GREY = "" + new URL("zrx-white.svg", import.meta.url).href, WBTC = "" + new URL("wbtc-color.svg", import.meta.url).href, WBTC_GREY = "" + new URL("wbtc-white.svg", import.meta.url).href, PAXG = "" + new URL("paxg-color.svg", import.meta.url).href, PAXG_GREY = "" + new URL("paxg-white.svg", import.meta.url).href, logo$1 = "_logo_gbled_1", swissOpenSource = "_swissOpenSource_gbled_7", large$2 = "_large_gbled_12", style$12 = {
  logo: logo$1,
  swissOpenSource,
  large: large$2
}, BitBox = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBoxLogo, alt: "BitBox", className: style$12.logo }), "BitBox"), BitBox02$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBox02Logo, alt: "BitBox02", className: style$12.logo }), "BitBox02$1"), BitBox02Inverted = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: BitBox02InvertedLogo, alt: "BitBox02", className: style$12.logo }), "BitBox02Inverted"), AppLogo = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: AppLogoImg, alt: "BitBox", className: style$12.logo }), "AppLogo"), AppLogoInverted = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: AppLogoInvertedImg, alt: "BitBox", className: style$12.logo }), "AppLogoInverted"), SwissMadeOpenSource = /* @__PURE__ */ __name(({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: SwissOpenSourceLight, alt: "Swiss Made Open Source", className: `${style$12.swissOpenSource} ${props.large ? style$12.large : ""} ${className || ""}` }), "SwissMadeOpenSource"), SwissMadeOpenSourceDark = /* @__PURE__ */ __name(({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: !1, src: SwissOpenSourceDark, alt: "Swiss Made Open Source", className: `${style$12.swissOpenSource} ${props.large ? style$12.large : ""} ${className || ""}` }), "SwissMadeOpenSourceDark"), logoMap = {
  btc: [BTC, BTC_GREY],
  tbtc: [BTC, BTC_GREY],
  rbtc: [BTC, BTC_GREY],
  ltc: [LTC, LTC_GREY],
  tltc: [LTC, LTC_GREY],
  eth: [ETH, ETH_GREY],
  goeth: [ETH, ETH_GREY],
  sepeth: [ETH, ETH_GREY],
  erc20Test: [ETH, ETH_GREY],
  "eth-erc20-usdt": [USDT, USDT_GREY],
  "eth-erc20-usdc": [USDC, USDC_GREY],
  "eth-erc20-dai0x6b17": [DAI, DAI_GREY],
  "eth-erc20-link": [LINK, LINK_GREY],
  "eth-erc20-bat": [BAT, BAT_GREY],
  "eth-erc20-mkr": [MKR, MKR_GREY],
  "eth-erc20-zrx": [ZRX, ZRX_GREY],
  "eth-erc20-wbtc": [WBTC, WBTC_GREY],
  "eth-erc20-paxg": [PAXG, PAXG_GREY]
};
function Logo({ coinCode, active: active2, stacked, ...rest }) {
  return logoMap[coinCode] ? stacked ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: active2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][1], ...rest }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest })
  ] }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: logoMap[coinCode][0], ...rest }) : (console.error("logo undefined for ", coinCode), null);
}
__name(Logo, "Logo");
const point2bitbox02 = "_point2bitbox02_1vb0x_1", caret$1 = "_caret_1vb0x_5", bitbox02 = "_bitbox02_1vb0x_10", style$11 = {
  point2bitbox02,
  caret: caret$1,
  bitbox02
}, PointToBitBox02 = /* @__PURE__ */ __name(() => {
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$11.point2bitbox02, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { className: style$11.caret }),
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: style$11.bitbox02 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: style$11.bitbox02 })
  ] });
}, "PointToBitBox02"), overlay$3 = "_overlay_1u8gr_1", activeOverlay$1 = "_activeOverlay_1u8gr_15", modal$1 = "_modal_1u8gr_19", header$8 = "_header_1u8gr_31", title$9 = "_title_1u8gr_31", contentContainer$2 = "_contentContainer_1u8gr_37", small$2 = "_small_1u8gr_42", medium$1 = "_medium_1u8gr_47", large$1 = "_large_1u8gr_53", centered$1 = "_centered_1u8gr_68", closeButton$3 = "_closeButton_1u8gr_78", slim$1 = "_slim_1u8gr_105", padded$1 = "_padded_1u8gr_109", content$5 = "_content_1u8gr_37", actions$1 = "_actions_1u8gr_117", confirmationLabel$1 = "_confirmationLabel_1u8gr_135", confirmationLabelNumber$1 = "_confirmationLabelNumber_1u8gr_144", disabledLabel$1 = "_disabledLabel_1u8gr_150", noStep$1 = "_noStep_1u8gr_155", confirmationInstructions$1 = "_confirmationInstructions_1u8gr_159", confirm$1 = "_confirm_1u8gr_135", image$1 = "_image_1u8gr_179", modalContent$1 = "_modalContent_1u8gr_184", detail$2 = "_detail_1u8gr_193", description$1 = "_description_1u8gr_217", buttons$4 = "_buttons_1u8gr_221", dialogButtons$1 = "_dialogButtons_1u8gr_233", closingOverlay = "_closingOverlay_1u8gr_244", open$1 = "_open_1u8gr_268", style$10 = {
  overlay: overlay$3,
  activeOverlay: activeOverlay$1,
  modal: modal$1,
  header: header$8,
  title: title$9,
  contentContainer: contentContainer$2,
  small: small$2,
  medium: medium$1,
  large: large$1,
  centered: centered$1,
  closeButton: closeButton$3,
  slim: slim$1,
  padded: padded$1,
  content: content$5,
  actions: actions$1,
  confirmationLabel: confirmationLabel$1,
  confirmationLabelNumber: confirmationLabelNumber$1,
  disabledLabel: disabledLabel$1,
  noStep: noStep$1,
  confirmationInstructions: confirmationInstructions$1,
  confirm: confirm$1,
  image: image$1,
  modalContent: modalContent$1,
  detail: detail$2,
  description: description$1,
  buttons: buttons$4,
  dialogButtons: dialogButtons$1,
  closingOverlay,
  open: open$1
}, _Dialog = class _Dialog extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.modalContent = reactExports.createRef(), this.state = {
      currentTab: 0,
      renderDialog: !1
    }, this.handleFocus = (e2) => {
      const index = e2.target.getAttribute("index");
      this.setState({ currentTab: Number(index) });
    }, this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables)
          c2.classList.add("tabbable"), c2.setAttribute("index", focusables.indexOf(c2).toString()), c2.addEventListener("focus", this.handleFocus);
        document.addEventListener("keydown", this.handleKeyDown);
      }
    }, this.focusFirst = () => {
      const focusables = this.focusableChildren;
      focusables.length && focusables[0].getAttribute("autofocus") !== "false" && focusables[0].focus();
    }, this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    }, this.deactivateModal = (fireOnCloseProp) => {
      !this.modal.current || !this.overlay.current || (this.overlay.current.classList.remove(style$10.closingOverlay), this.setState({ currentTab: 0, renderDialog: !1 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown), this.props.onClose && fireOnCloseProp && this.props.onClose();
      }));
    }, this.handleKeyDown = (e2) => {
      const { disableEscape } = this.props, isEsc = e2.keyCode === 27, isTab = e2.keyCode === 9;
      !disableEscape && isEsc ? this.deactivate(!0) : isTab && e2.preventDefault(), isTab && e2.shiftKey ? this.updateIndex(!1) : isTab && this.updateIndex(!0);
    }, this.deactivate = (fireOnCloseProp) => {
      var _a46;
      if (!this.modal.current || !this.overlay.current)
        return;
      this.timerId && clearTimeout(this.timerId), this.overlay.current.classList.remove(style$10.activeOverlay), this.overlay.current.classList.add(style$10.closingOverlay), (_a46 = this.modal.current) == null || _a46.classList.remove(style$10.open);
      const onTransitionEnd = /* @__PURE__ */ __name((event2) => {
        var _a47;
        event2.target === this.modal.current && (this.deactivateModal(fireOnCloseProp), (_a47 = this.modal.current) == null || _a47.removeEventListener("transitionend", onTransitionEnd));
      }, "onTransitionEnd");
      parseFloat(window.getComputedStyle(this.modal.current).transitionDuration) > 0 ? (this.modal.current.addEventListener("transitionend", onTransitionEnd), this.timerId = setTimeout(() => this.deactivateModal(fireOnCloseProp), 400)) : this.deactivateModal(fireOnCloseProp);
    }, this.activate = () => {
      this.setState({ renderDialog: !0 }, () => {
        !this.modal.current || !this.overlay.current || (this.timerId && clearTimeout(this.timerId), this.overlay.current.classList.add(style$10.activeOverlay), this.timerId = setTimeout(() => {
          var _a46;
          (_a46 = this.modal.current) == null || _a46.classList.add(style$10.open);
        }, 10), this.focusWithin(), this.focusFirst());
      });
    };
  }
  componentDidMount() {
    this.props.open && this.activate();
  }
  componentDidUpdate(prevProps) {
    const { open: open2 } = this.props;
    if (open2 && !prevProps.open) {
      this.activate();
      return;
    }
    if (!open2 && prevProps.open) {
      this.deactivate(!1);
      return;
    }
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state, focusables = Array.from(this.focusableChildren), arr = isNext ? focusables : focusables.reverse(), current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    return next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled")), next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2, isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props, { renderDialog } = this.state, isSmall = small2 ? style$10.small : "", isMedium = medium2 ? style$10.medium : "", isLarge = large2 ? style$10.large : "", isSlim = slim2 ? style$10.slim : "", isCentered = centered2 && !onClose ? style$10.centered : "";
    return renderDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$10.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$10.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$10.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$10.closeButton, onClick: () => {
              this.deactivate(!0);
            }, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$10.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.content, children: children2 })
            }
          )
        ]
      }
    ) }) : null;
  }
};
__name(_Dialog, "Dialog");
let Dialog = _Dialog;
function DialogButtons$1({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.dialogButtons, children: children2 });
}
__name(DialogButtons$1, "DialogButtons$1");
const defaultLanguages = [
  { code: "ar", display: "العربية" },
  { code: "bg", display: "България" },
  { code: "cs", display: "Čeština" },
  { code: "de", display: "Deutsch" },
  { code: "en", display: "English" },
  { code: "es", display: "Español" },
  { code: "fa", display: "فارسی" },
  { code: "fr", display: "Français" },
  { code: "he", display: "עברית" },
  { code: "hi", display: "हिन्दी " },
  { code: "it", display: "Italiano" },
  { code: "ja", display: "日本語" },
  { code: "ms", display: "Bahasa Melayu" },
  { code: "nl", display: "Nederlands" },
  { code: "pt", display: "Português" },
  { code: "ru", display: "Русский" },
  { code: "sl", display: "Slovenščina" },
  { code: "tr", display: "Türkçe" },
  { code: "zh", display: "中文" }
], link$4 = "_link_28asd_1", language = "_language_28asd_20", selected = "_selected_28asd_38", checked = "_checked_28asd_46", style$$ = {
  link: link$4,
  language,
  selected,
  checked
}, getSelectedIndex = /* @__PURE__ */ __name((languages, i18n) => {
  const lang = i18n.language;
  let index = languages.findIndex(({ code }) => code === lang);
  if (index === -1 && lang.indexOf("-") > 0) {
    const tag = lang.slice(0, lang.indexOf("-"));
    index = languages.findIndex(({ code }) => code === tag);
  }
  if (index === -1 && lang.indexOf("_") > 0) {
    const tag = lang.slice(0, lang.indexOf("_"));
    index = languages.findIndex(({ code }) => code === tag);
  }
  return index === -1 ? 0 : index;
}, "getSelectedIndex"), LanguageSwitch = /* @__PURE__ */ __name(({ languages }) => {
  const { t: t2, i18n } = useTranslation(), allLanguages = languages || defaultLanguages, [selectedIndex, setSelectedIndex] = reactExports.useState(getSelectedIndex(allLanguages, i18n)), [activeDialog, setActiveDialog] = reactExports.useState(!1), changeLanguage = /* @__PURE__ */ __name((langCode, index) => {
    setSelectedIndex(index), setActiveDialog(!1), i18n.changeLanguage(langCode);
  }, "changeLanguage");
  return allLanguages.length === 1 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type: "button",
        title: "Select Language",
        className: style$$.link,
        onClick: () => setActiveDialog(!0),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
              ]
            }
          ),
          allLanguages[selectedIndex].code === "en" ? "Other languages" : "English"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { small: !0, slim: !0, title: t2("language.title"), onClose: () => setActiveDialog(!1), open: activeDialog, children: allLanguages.map((language2, i) => {
      const selected2 = selectedIndex === i;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: [style$$.language, selected2 ? style$$.selected : ""].join(" "),
          onClick: () => changeLanguage(language2.code, i),
          "data-testid": `language-selection-${language2.code}`,
          children: [
            language2.display,
            selected2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: style$$.checked,
                xmlns: "http://www.w3.org/2000/svg",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" })
              }
            )
          ]
        },
        language2.code
      );
    }) })
  ] });
}, "LanguageSwitch"), useMountedRef = /* @__PURE__ */ __name(() => {
  const isMountedRef = reactExports.useRef(!1);
  return reactExports.useEffect(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), isMountedRef;
}, "useMountedRef"), useSubscribeReset = /* @__PURE__ */ __name((subscription) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), subscribe2 = /* @__PURE__ */ __name(() => subscription((data) => {
    mounted.current && setResponse(data);
  }), "subscribe");
  return reactExports.useEffect(
    () => subscribe2(),
    // empty dependencies because it's only subscribed once
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), [response, () => setResponse(void 0)];
}, "useSubscribeReset"), useSubscribe = /* @__PURE__ */ __name((subscription) => {
  const [response] = useSubscribeReset(subscription);
  return response;
}, "useSubscribe"), useLoad = /* @__PURE__ */ __name((apiCall, dependencies) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), load2 = /* @__PURE__ */ __name(() => {
    apiCall !== null && apiCall().then((data) => {
      mounted.current && setResponse(data);
    });
  }, "load");
  return reactExports.useEffect(
    () => load2(),
    // By default no dependencies are passed to only query once
    dependencies || []
    // eslint-disable-line react-hooks/exhaustive-deps
  ), response;
}, "useLoad"), useSync = /* @__PURE__ */ __name((apiCall, subscription) => {
  const [response, setResponse] = reactExports.useState(), mounted = useMountedRef(), onData = /* @__PURE__ */ __name((data) => {
    mounted.current && setResponse(data);
  }, "onData");
  return reactExports.useEffect(
    () => (apiCall().then(onData), subscription(onData)),
    // we pass no dependencies because it's only queried once
    []
  ), response;
}, "useSync"), getVersion$1 = /* @__PURE__ */ __name(() => apiGet("version"), "getVersion$1"), getUpdate = /* @__PURE__ */ __name(() => apiGet("update"), "getUpdate"), Version = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), version = useLoad(getVersion$1);
  return version ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
    t2("footer.appVersion"),
    " ",
    version
  ] }) : null;
}, "Version"), fullscreen = "_fullscreen_q1y08_1", dialog = "_dialog_q1y08_22", fill = "_fill_q1y08_28", inner = "_inner_q1y08_38", verticallyCentered = "_verticallyCentered_q1y08_46", fit = "_fit_q1y08_50", content$4 = "_content_q1y08_56", textCenter = "_textCenter_q1y08_61", header$7 = "_header_q1y08_109", smallHeader = "_smallHeader_q1y08_130", title$8 = "_title_q1y08_155", closeButton$2 = "_closeButton_q1y08_169", fullWidth = "_fullWidth_q1y08_197", largeIcon = "_largeIcon_q1y08_215", buttons$3 = "_buttons_q1y08_240", footer$1 = "_footer_q1y08_294", style$_ = {
  fullscreen,
  dialog,
  fill,
  inner,
  verticallyCentered,
  fit,
  content: content$4,
  textCenter,
  "text-center": "_text-center_q1y08_62",
  "text-left": "_text-left_q1y08_65",
  header: header$7,
  smallHeader,
  title: title$8,
  closeButton: closeButton$2,
  fullWidth,
  largeIcon,
  buttons: buttons$3,
  footer: footer$1
}, View = /* @__PURE__ */ __name(({
  dialog: dialog2 = !1,
  fitContent = !1,
  fullscreen: fullscreen2,
  children: children2,
  minHeight,
  onClose,
  textCenter: textCenter2,
  verticallyCentered: verticallyCentered2 = !1,
  width,
  withBottomBar
}) => {
  const { isDarkMode } = useDarkmode(), containerClasses = `${style$_[fullscreen2 ? "fullscreen" : "fill"]} ${verticallyCentered2 ? style$_.verticallyCentered : ""} ${dialog2 ? style$_.dialog : ""}`;
  let classNames2 = style$_.inner;
  fitContent && (classNames2 += ` ${style$_.fit}`), textCenter2 && (classNames2 += ` ${style$_.textCenter}`);
  const inlineStyles = {
    ...minHeight && { minHeight },
    ...width && { width }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames2,
        style: inlineStyles,
        children: children2
      }
    ),
    onClose && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$_.closeButton, onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {}) }),
    withBottomBar && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: style$_.footer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
    ] }) })
  ] });
}, "View"), ViewContent = /* @__PURE__ */ __name(({
  children: children2,
  fullWidth: fullWidth2,
  minHeight,
  textAlign,
  withIcon,
  ...props
}) => {
  const align = textAlign ? style$_[`text-${textAlign}`] : "", containerWidth = fullWidth2 ? style$_.fullWidth : "", classes = `${style$_.content} ${containerWidth} ${align}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classes,
      style: minHeight ? { minHeight } : {},
      ...props,
      children: [
        withIcon === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: style$_.largeIcon }),
        children2
      ]
    }
  );
}, "ViewContent"), ViewHeader = /* @__PURE__ */ __name(({
  children: children2,
  small: small2,
  title: title2,
  withAppLogo
}) => {
  const { isDarkMode } = useDarkmode(), headerStyles = small2 ? `${style$_.header} ${style$_.smallHeader}` : style$_.header;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: headerStyles, children: [
    withAppLogo && (isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {})),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$_.title, children: title2 }),
    children2
  ] });
}, "ViewHeader"), ViewButtons = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$_.buttons, children: children2 }), "ViewButtons"), button$3 = "_button_b8ew4_1", primary$1 = "_primary_b8ew4_38 _button_b8ew4_1", secondary = "_secondary_b8ew4_49 _button_b8ew4_1", danger$1 = "_danger_b8ew4_67 _button_b8ew4_1", transparent = "_transparent_b8ew4_84 _button_b8ew4_1", style$Z = {
  button: button$3,
  primary: primary$1,
  secondary,
  danger: danger$1,
  transparent
}, ButtonLink = /* @__PURE__ */ __name(({
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  disabled: disabled2,
  ...props
}) => {
  const classNames2 = [
    style$Z[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return disabled2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: classNames2,
      disabled: !0,
      children: children2
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Link,
    {
      className: classNames2,
      ...props,
      children: children2
    }
  );
}, "ButtonLink"), Button = /* @__PURE__ */ __name(({
  type: type2 = "button",
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  ...props
}) => {
  const classNames2 = [
    style$Z[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: type2,
      className: classNames2,
      ...props,
      children: children2
    }
  );
}, "Button"), checkbox = "_checkbox_1m6k1_1", success$6 = "_success_1m6k1_33", warning$5 = "_warning_1m6k1_37", info$4 = "_info_1m6k1_41", styles$s = {
  checkbox,
  success: success$6,
  warning: warning$5,
  info: info$4
}, Checkbox = /* @__PURE__ */ __name(({
  disabled: disabled2 = !1,
  label: label2,
  id: id2,
  className = "",
  children: children2,
  checkboxStyle = "default",
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$s.checkbox} ${className} ${styles$s[checkboxStyle] || ""}`, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      id: id2,
      disabled: disabled2,
      ...props
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
    label2,
    " ",
    children2
  ] })
] }), "Checkbox"), radio$1 = "_radio_198i3_1", style$Y = {
  radio: radio$1
};
function Radio({
  disabled: disabled2 = !1,
  label: label2,
  id: id2,
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$Y.radio, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "radio",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      children2
    ] })
  ] });
}
__name(Radio, "Radio");
const field = "_field_d2mb0_1", style$X = {
  field
};
function Field({
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$X.field, ...props, children: children2 });
}
__name(Field, "Field");
const input = "_input_1dgl0_1", isTransparent = "_isTransparent_1dgl0_58", errorText = "_errorText_1dgl0_64", styles$r = {
  input,
  "align-left": "_align-left_1dgl0_12",
  "align-right": "_align-right_1dgl0_16",
  isTransparent,
  errorText
}, Input$2 = reactExports.forwardRef(/* @__PURE__ */ __name(function({
  id: id2,
  label: label2 = "",
  error: error3,
  align = "left",
  className = "",
  children: children2,
  transparent: transparent2 = !1,
  type: type2 = "text",
  labelSection,
  ...props
}, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    styles$r.input,
    styles$r[`align-${align}`],
    className,
    transparent2 ? styles$r.isTransparent : ""
  ].join(" "), children: [
    label2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: error3 ? styles$r.errorText : "", children: [
        label2,
        error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          ":",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: error3.toString() })
        ] }) : null
      ] }),
      labelSection && labelSection
    ] }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: !1,
        type: type2,
        id: id2,
        ref,
        ...props
      }
    ),
    children2
  ] });
}, "Input")), label$6 = "_label_53nw1_1", style$W = {
  label: label$6
};
function Label({
  className,
  children: children2,
  id: id2,
  // TODO: change to htmlFor when mirgated away from preact@8.x
  ...props
}) {
  const classes = [style$W.label, className].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: classes, ...props, children: children2 });
}
__name(Label, "Label");
const select$5 = "_select_yd5xu_1", styles$q = {
  select: select$5
}, Select$1 = /* @__PURE__ */ __name(({
  id: id2,
  label: label2,
  options: options2 = [],
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$q.select, children: [
  label2 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, children: label2 }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("select", { id: id2, ...props, children: options2.map(({ value, text: text2, disabled: disabled2 = !1 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "option",
    {
      value,
      disabled: disabled2,
      children: text2
    },
    `${value}`
  )) })
] }), "Select$1");
let alertUser, callback;
const Alert = /* @__PURE__ */ __name(() => {
  const [active2, setActive] = reactExports.useState(!1), [asDialog, setAsDialog] = reactExports.useState(!0), [message2, setMessage] = reactExports.useState(), { t: t2 } = useTranslation();
  alertUser = /* @__PURE__ */ __name((message22, options2 = {}) => {
    const {
      asDialog: asDialog2 = !0
    } = options2;
    callback = options2.callback, setActive(!0), setAsDialog(asDialog2), setMessage(message22);
  }, "alertUser");
  const handleClose = /* @__PURE__ */ __name(() => {
    callback && callback(), setActive(!1);
  }, "handleClose");
  return active2 && message2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: () => setActive(!1), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      dialog: asDialog,
      fullscreen: !0,
      textCenter: !asDialog,
      verticallyCentered: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "span", markup: message2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: !0,
            primary: !0,
            onClick: handleClose,
            children: t2("button.ok")
          }
        ) })
      ]
    },
    "alert-overlay"
  ) }) : null;
}, "Alert");
var QWebChannelMessageTypes = {
  signal: 1,
  propertyUpdate: 2,
  init: 3,
  idle: 4,
  debug: 5,
  invokeMethod: 6,
  connectToSignal: 7,
  disconnectFromSignal: 8,
  setProperty: 9,
  response: 10
};
const QWebChannel = /* @__PURE__ */ __name(function(transport, initCallback) {
  if (typeof transport != "object" || typeof transport.send != "function") {
    console.error("The QWebChannel expects a transport object with a send function and onmessage callback property. Given is: transport: " + typeof transport + ", transport.send: " + typeof transport.send);
    return;
  }
  var channel = this;
  this.transport = transport, this.send = function(data) {
    typeof data != "string" && (data = JSON.stringify(data)), channel.transport.send(data);
  }, this.transport.onmessage = function(message2) {
    var data = message2.data;
    switch (typeof data == "string" && (data = JSON.parse(data)), data.type) {
      case QWebChannelMessageTypes.signal:
        channel.handleSignal(data);
        break;
      case QWebChannelMessageTypes.response:
        channel.handleResponse(data);
        break;
      case QWebChannelMessageTypes.propertyUpdate:
        channel.handlePropertyUpdate(data);
        break;
      default:
        console.error("invalid message received:", message2.data);
        break;
    }
  }, this.execCallbacks = {}, this.execId = 0, this.exec = function(data, callback2) {
    if (!callback2) {
      channel.send(data);
      return;
    }
    if (channel.execId === Number.MAX_VALUE && (channel.execId = Number.MIN_VALUE), data.hasOwnProperty("id")) {
      console.error("Cannot exec message with property id: " + JSON.stringify(data));
      return;
    }
    data.id = channel.execId++, channel.execCallbacks[data.id] = callback2, channel.send(data);
  }, this.objects = {}, this.handleSignal = function(message2) {
    var object = channel.objects[message2.object];
    object ? object.signalEmitted(message2.signal, message2.args) : console.warn("Unhandled signal: " + message2.object + "::" + message2.signal);
  }, this.handleResponse = function(message2) {
    if (!message2.hasOwnProperty("id")) {
      console.error("Invalid response message received: ", JSON.stringify(message2));
      return;
    }
    channel.execCallbacks[message2.id](message2.data), delete channel.execCallbacks[message2.id];
  }, this.handlePropertyUpdate = function(message2) {
    for (var i in message2.data) {
      var data = message2.data[i], object = channel.objects[data.object];
      object ? object.propertyUpdate(data.signals, data.properties) : console.warn("Unhandled property update: " + data.object + "::" + data.signal);
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  }, this.debug = function(message2) {
    channel.send({ type: QWebChannelMessageTypes.debug, data: message2 });
  }, channel.exec({ type: QWebChannelMessageTypes.init }, function(data) {
    for (var objectName in data)
      new QObject(objectName, data[objectName], channel);
    for (var objectName in channel.objects)
      channel.objects[objectName].unwrapProperties();
    initCallback && initCallback(channel), channel.exec({ type: QWebChannelMessageTypes.idle });
  });
}, "QWebChannel");
function QObject(name, data, webChannel2) {
  this.__id__ = name, webChannel2.objects[name] = this, this.__objectSignals__ = {}, this.__propertyCache__ = {};
  var object = this;
  this.unwrapQObject = function(response) {
    if (response instanceof Array) {
      for (var ret = new Array(response.length), i = 0; i < response.length; ++i)
        ret[i] = object.unwrapQObject(response[i]);
      return ret;
    }
    if (!response || !response["__QObject*__"] || response.id === void 0)
      return response;
    var objectId = response.id;
    if (webChannel2.objects[objectId])
      return webChannel2.objects[objectId];
    if (!response.data) {
      console.error("Cannot unwrap unknown QObject " + objectId + " without data.");
      return;
    }
    var qObject = new QObject(objectId, response.data, webChannel2);
    return qObject.destroyed.connect(function() {
      if (webChannel2.objects[objectId] === qObject) {
        delete webChannel2.objects[objectId];
        var propertyNames = [];
        for (var propertyName in qObject)
          propertyNames.push(propertyName);
        for (var idx in propertyNames)
          delete qObject[propertyNames[idx]];
      }
    }), qObject.unwrapProperties(), qObject;
  }, this.unwrapProperties = function() {
    for (var propertyIdx in object.__propertyCache__)
      object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);
  };
  function addSignal(signalData, isPropertyNotifySignal) {
    var signalName = signalData[0], signalIndex = signalData[1];
    object[signalName] = {
      connect: function(callback2) {
        if (typeof callback2 != "function") {
          console.error("Bad callback given to connect to signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [], object.__objectSignals__[signalIndex].push(callback2), !isPropertyNotifySignal && signalName !== "destroyed" && webChannel2.exec({
          type: QWebChannelMessageTypes.connectToSignal,
          object: object.__id__,
          signal: signalIndex
        });
      },
      disconnect: function(callback2) {
        if (typeof callback2 != "function") {
          console.error("Bad callback given to disconnect from signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        var idx = object.__objectSignals__[signalIndex].indexOf(callback2);
        if (idx === -1) {
          console.error("Cannot find connection of signal " + signalName + " to " + callback2.name);
          return;
        }
        object.__objectSignals__[signalIndex].splice(idx, 1), !isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0 && webChannel2.exec({
          type: QWebChannelMessageTypes.disconnectFromSignal,
          object: object.__id__,
          signal: signalIndex
        });
      }
    };
  }
  __name(addSignal, "addSignal");
  function invokeSignalCallbacks(signalName, signalArgs) {
    var connections = object.__objectSignals__[signalName];
    connections && connections.forEach(function(callback2) {
      callback2.apply(callback2, signalArgs);
    });
  }
  __name(invokeSignalCallbacks, "invokeSignalCallbacks"), this.propertyUpdate = function(signals, propertyMap) {
    for (var propertyIndex in propertyMap) {
      var propertyValue = propertyMap[propertyIndex];
      object.__propertyCache__[propertyIndex] = propertyValue;
    }
    for (var signalName in signals)
      invokeSignalCallbacks(signalName, signals[signalName]);
  }, this.signalEmitted = function(signalName, signalArgs) {
    invokeSignalCallbacks(signalName, this.unwrapQObject(signalArgs));
  };
  function addMethod(methodData) {
    var methodName = methodData[0], methodIdx = methodData[1];
    object[methodName] = function() {
      for (var args = [], callback2, i = 0; i < arguments.length; ++i) {
        var argument = arguments[i];
        typeof argument == "function" ? callback2 = argument : argument instanceof QObject && webChannel2.objects[argument.__id__] !== void 0 ? args.push({
          id: argument.__id__
        }) : args.push(argument);
      }
      webChannel2.exec({
        type: QWebChannelMessageTypes.invokeMethod,
        object: object.__id__,
        method: methodIdx,
        args
      }, function(response) {
        if (response !== void 0) {
          var result = object.unwrapQObject(response);
          callback2 && callback2(result);
        }
      });
    };
  }
  __name(addMethod, "addMethod");
  function bindGetterSetter(propertyInfo) {
    var propertyIndex = propertyInfo[0], propertyName = propertyInfo[1], notifySignalData = propertyInfo[2];
    object.__propertyCache__[propertyIndex] = propertyInfo[3], notifySignalData && (notifySignalData[0] === 1 && (notifySignalData[0] = propertyName + "Changed"), addSignal(notifySignalData, !0)), Object.defineProperty(object, propertyName, {
      configurable: !0,
      get: function() {
        var propertyValue = object.__propertyCache__[propertyIndex];
        return propertyValue === void 0 && console.warn('Undefined value in property cache for property "' + propertyName + '" in object ' + object.__id__), propertyValue;
      },
      set: function(value) {
        if (value === void 0) {
          console.warn("Property setter for " + propertyName + " called with undefined value!");
          return;
        }
        object.__propertyCache__[propertyIndex] = value;
        var valueToSend = value;
        valueToSend instanceof QObject && webChannel2.objects[valueToSend.__id__] !== void 0 && (valueToSend = { id: valueToSend.__id__ }), webChannel2.exec({
          type: QWebChannelMessageTypes.setProperty,
          object: object.__id__,
          property: propertyIndex,
          value: valueToSend
        });
      }
    });
  }
  __name(bindGetterSetter, "bindGetterSetter"), data.methods.forEach(addMethod), data.properties.forEach(bindGetterSetter), data.signals.forEach(function(signal) {
    addSignal(signal, !1);
  });
  for (var name in data.enums)
    object[name] = data.enums[name];
}
__name(QObject, "QObject");
const debug = !1;
function runningInQtWebEngine() {
  return typeof window.qt < "u";
}
__name(runningInQtWebEngine, "runningInQtWebEngine");
function runningInAndroid() {
  return typeof window.android < "u";
}
__name(runningInAndroid, "runningInAndroid");
let webChannel = null, queryID$1 = 0;
const queryPromises$1 = {}, currentListeners$2 = [];
async function initTransport() {
  if (!runningInQtWebEngine())
    throw new Error("Must be running in Qt");
  if (webChannel)
    return webChannel;
  const initWebChannel = /* @__PURE__ */ __name(function(channel) {
    channel.objects.backend.gotResponse.connect((queryID2, response) => {
      queryPromises$1[queryID2].resolve(JSON.parse(response)), delete queryPromises$1[queryID2];
    }), channel.objects.backend.pushNotify.connect((msg) => {
      currentListeners$2.forEach((listener) => listener(JSON.parse(msg)));
    }), webChannel = channel;
  }, "initWebChannel");
  for (new QWebChannel(window.qt.webChannelTransport, initWebChannel); !webChannel; )
    await new Promise((r2) => setTimeout(r2, 1));
  return webChannel;
}
__name(initTransport, "initTransport");
function call(query) {
  return new Promise((resolve, reject2) => {
    initTransport().then((channel) => {
      queryID$1++, queryPromises$1[queryID$1] = { resolve, reject: reject2 }, channel.objects.backend.call(queryID$1, query);
    });
  });
}
__name(call, "call");
function qtSubscribePushNotifications(msgCallback) {
  return currentListeners$2.push(msgCallback), () => {
    currentListeners$2.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners$2.indexOf(msgCallback);
    currentListeners$2.splice(index, 1), currentListeners$2.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(qtSubscribePushNotifications, "qtSubscribePushNotifications");
let queryID = 0;
const queryPromises = {}, currentListeners$1 = [];
function androidCall(query) {
  return new Promise((resolve, reject2) => {
    runningInAndroid() ? (typeof window.onAndroidCallResponse > "u" && (window.onAndroidCallResponse = (queryID2, response) => {
      queryPromises[queryID2].resolve(response), delete queryPromises[queryID2];
    }), queryID++, queryPromises[queryID] = { resolve, reject: reject2 }, window.android.call(queryID, query)) : reject2();
  });
}
__name(androidCall, "androidCall");
function androidSubscribePushNotifications(msgCallback) {
  return typeof window.onAndroidPushNotification > "u" && (window.onAndroidPushNotification = (msg) => {
    currentListeners$1.forEach((listener) => listener(msg));
  }), currentListeners$1.push(msgCallback), () => {
    currentListeners$1.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners$1.indexOf(msgCallback);
    currentListeners$1.splice(index, 1), currentListeners$1.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(androidSubscribePushNotifications, "androidSubscribePushNotifications");
function extConfig(key, defaultValue) {
  return key.startsWith("{{ ") && key.endsWith(" }}") ? defaultValue : key;
}
__name(extConfig, "extConfig");
const apiPort = extConfig("{{ API_PORT }}", "8082"), apiToken = extConfig("{{ API_TOKEN }}", "");
function isTLS() {
  return document.URL.startsWith("https://");
}
__name(isTLS, "isTLS");
function apiURL(endpoint) {
  return (isTLS() ? "https://" : "http://") + "localhost:" + apiPort + "/api/" + endpoint;
}
__name(apiURL, "apiURL");
function handleError(endpoint) {
  return function(json) {
    return new Promise((resolve, reject2) => {
      if (json && json.error) {
        if (json.error.indexOf("hidapi: unknown failure") !== -1)
          return;
        console.error("error from endpoint", endpoint, json), alertUser(instance.t("genericError")), reject2(json.error);
        return;
      }
      resolve(json);
    });
  };
}
__name(handleError, "handleError");
function apiGet(endpoint) {
  return runningInQtWebEngine() ? call(JSON.stringify({
    method: "GET",
    endpoint
  })) : runningInAndroid() ? androidCall(JSON.stringify({
    method: "GET",
    endpoint
  })) : fetch(apiURL(endpoint), {
    method: "GET"
  }).then((response) => response.json()).then(handleError(endpoint));
}
__name(apiGet, "apiGet");
function apiPost(endpoint, body) {
  return runningInQtWebEngine() ? call(JSON.stringify({
    method: "POST",
    endpoint,
    body: JSON.stringify(body)
  })) : runningInAndroid() ? androidCall(JSON.stringify({
    method: "POST",
    endpoint,
    body: JSON.stringify(body)
  })) : fetch(apiURL(endpoint), {
    method: "POST",
    body: JSON.stringify(body)
  }).then((response) => response.json()).then(handleError(endpoint));
}
__name(apiPost, "apiPost");
let socket;
const currentListeners = [];
function webSubscribePushNotifications(msgCallback) {
  return currentListeners.push(msgCallback), socket || (socket = new WebSocket((isTLS() ? "wss://" : "ws://") + "localhost:" + apiPort + "/api/events"), socket.onopen = function() {
    socket && socket.send("Authorization: Basic " + apiToken);
  }, socket.onerror = function(event2) {
    console.error("websocket error", event2);
  }, socket.onmessage = function(event2) {
    const payload = JSON.parse(event2.data);
    currentListeners.forEach((listener) => listener(payload));
  }, socket.onclose = function() {
    currentListeners.forEach((listener) => listener({ subject: "backend/connected", action: "replace", object: !1 }));
  }), () => {
    currentListeners.includes(msgCallback) || console.warn("!currentListeners.includes(msgCallback)");
    const index = currentListeners.indexOf(msgCallback);
    currentListeners.splice(index, 1), currentListeners.includes(msgCallback) && console.warn("currentListeners.includes(msgCallback)");
  };
}
__name(webSubscribePushNotifications, "webSubscribePushNotifications");
function apiWebsocket(msgCallback) {
  return runningInQtWebEngine() ? qtSubscribePushNotifications(msgCallback) : runningInAndroid() ? androidSubscribePushNotifications(msgCallback) : webSubscribePushNotifications(msgCallback);
}
__name(apiWebsocket, "apiWebsocket");
const subscriptions$1 = {};
function handleEvent(payload) {
  if ("subject" in payload && typeof payload.subject == "string" && subscriptions$1[payload.subject])
    for (const observer of subscriptions$1[payload.subject])
      observer(payload);
}
__name(handleEvent, "handleEvent");
let subscribed = null;
function apiSubscribe(subject, observer) {
  subscribed || (subscribed = apiWebsocket(handleEvent));
  let observers = subscriptions$1[subject];
  return observers === void 0 && (observers = [], subscriptions$1[subject] = observers), observers.push(observer), () => {
    observers.includes(observer) || console.warn("!observers.includes(observer)");
    const index = observers.indexOf(observer);
    observers.splice(index, 1), observers.includes(observer) && console.warn("observers.includes(observer)");
  };
}
__name(apiSubscribe, "apiSubscribe");
function subscribeEndpoint(endpoint, cb2) {
  return apiSubscribe(endpoint, (event2) => {
    switch (event2.action) {
      case "replace":
        cb2(event2.object);
        break;
      case "reload":
        apiGet(event2.subject).then((object) => cb2(object)).catch(console.error);
        break;
      default:
        throw new Error(`Event: ${event2} not supported`);
    }
  });
}
__name(subscribeEndpoint, "subscribeEndpoint");
const backendConnected = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("backend/connected", cb2), "backendConnected"), getSupportedCoins = /* @__PURE__ */ __name(() => apiGet("supported-coins"), "getSupportedCoins"), setAccountActive = /* @__PURE__ */ __name((accountCode, active2) => apiPost("set-account-active", { accountCode, active: active2 }), "setAccountActive"), setTokenActive = /* @__PURE__ */ __name((accountCode, tokenCode, active2) => apiPost("set-token-active", { accountCode, tokenCode, active: active2 }), "setTokenActive"), renameAccount = /* @__PURE__ */ __name((accountCode, name) => apiPost("rename-account", { accountCode, name }), "renameAccount"), reinitializeAccounts = /* @__PURE__ */ __name(() => apiPost("accounts/reinitialize"), "reinitializeAccounts"), getTesting = /* @__PURE__ */ __name(() => apiGet("testing"), "getTesting"), getQRCode = /* @__PURE__ */ __name((data) => () => apiGet(`qr?data=${encodeURIComponent(data)}`), "getQRCode"), getDefaultConfig = /* @__PURE__ */ __name(() => apiGet("config/default"), "getDefaultConfig"), socksProxyCheck = /* @__PURE__ */ __name((proxyAddress) => apiPost("socksproxy/check", proxyAddress), "socksProxyCheck"), syncConnectKeystore = /* @__PURE__ */ __name(() => (cb2) => subscribeEndpoint("connect-keystore", (obj) => {
  cb2(obj);
}), "syncConnectKeystore"), cancelConnectKeystore = /* @__PURE__ */ __name(() => apiPost("cancel-connect-keystore"), "cancelConnectKeystore"), setWatchonly = /* @__PURE__ */ __name((rootFingerprint, watchonly) => apiPost("set-watchonly", { rootFingerprint, watchonly }), "setWatchonly"), authenticate = /* @__PURE__ */ __name((force = !1) => apiPost("authenticate", force), "authenticate"), forceAuth = /* @__PURE__ */ __name(() => apiPost("force-auth"), "forceAuth"), subscribeAuth = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("auth", cb2), "subscribeAuth"), onAuthSettingChanged = /* @__PURE__ */ __name(() => apiPost("on-auth-setting-changed"), "onAuthSettingChanged"), subscribeKeystores = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("keystores", cb2), "subscribeKeystores"), getKeystores = /* @__PURE__ */ __name(() => apiGet("keystores"), "getKeystores"), message$1 = "_message_ncb43_1", small$1 = "_small_ncb43_15", success$5 = "_success_ncb43_28 _message_ncb43_1", info$3 = "_info_ncb43_34 _message_ncb43_1", warning$4 = "_warning_ncb43_40 _message_ncb43_1", error$1 = "_error_ncb43_46 _message_ncb43_1", styles$p = {
  message: message$1,
  small: small$1,
  success: success$5,
  info: info$3,
  warning: warning$4,
  error: error$1
};
function Message({
  hidden,
  small: small2,
  type: type2 = "message",
  children: children2
}) {
  return hidden ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$p[type2]} ${small2 ? styles$p.small : ""}`, children: children2 });
}
__name(Message, "Message");
function getDisplayName(component) {
  return component.displayName || component.name || "Component";
}
__name(getDisplayName, "getDisplayName");
function share(store) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      componentDidMount() {
        store.subscribe(this);
      }
      componentWillUnmount() {
        store.unsubscribe(this);
      }
      render() {
        const props = this.props;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...store.state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Share(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(share, "share");
const coins = "" + new URL("coins.svg", import.meta.url).href, info$2 = "" + new URL("info.svg", import.meta.url).href, settings = "" + new URL("settings-alt.svg", import.meta.url).href, settingsGrey = "" + new URL("settings-alt_disabled.svg", import.meta.url).href;
function findAccount(accounts, accountCode) {
  return accounts.find(({ code }) => accountCode === code);
}
__name(findAccount, "findAccount");
function getCryptoName(cryptoLabel, account2) {
  return account2 && isBitcoinOnly(account2.coinCode) ? "Bitcoin" : cryptoLabel;
}
__name(getCryptoName, "getCryptoName");
function isBitcoinOnly(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return !0;
    default:
      return !1;
  }
}
__name(isBitcoinOnly, "isBitcoinOnly");
const isBitcoinCoin = /* @__PURE__ */ __name((coin) => coin === "BTC" || coin === "TBTC" || coin === "sat" || coin === "tsat", "isBitcoinCoin");
function isBitcoinBased(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
    case "ltc":
    case "tltc":
      return !0;
    default:
      return !1;
  }
}
__name(isBitcoinBased, "isBitcoinBased");
function isEthereumBased(coinCode) {
  return coinCode === "eth" || coinCode === "goeth" || coinCode === "sepeth" || coinCode.startsWith("eth-erc20-");
}
__name(isEthereumBased, "isEthereumBased");
function getCoinCode(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return "btc";
    case "ltc":
    case "tltc":
      return "ltc";
    case "eth":
    case "goeth":
    case "sepeth":
      return "eth";
  }
}
__name(getCoinCode, "getCoinCode");
function getScriptName(scriptType) {
  switch (scriptType) {
    case "p2pkh":
      return "Legacy (P2PKH)";
    case "p2wpkh-p2sh":
      return "Wrapped Segwit (P2WPKH-P2SH)";
    case "p2wpkh":
      return "Native segwit (bech32, P2WPKH)";
    case "p2tr":
      return "Taproot (bech32m, P2TR)";
  }
}
__name(getScriptName, "getScriptName");
function customFeeUnit$1(coinCode) {
  return isBitcoinBased(coinCode) ? "sat/vB" : isEthereumBased(coinCode) ? "Gwei" : "";
}
__name(customFeeUnit$1, "customFeeUnit$1");
function getAccountsByKeystore(accounts) {
  return Object.values(accounts.reduce((acc, account2) => {
    const key = account2.keystore.rootFingerprint;
    return acc[key] || (acc[key] = {
      keystore: account2.keystore,
      accounts: []
    }), acc[key].accounts.push(account2), acc;
  }, {})).sort((ac1, ac2) => ac1.keystore.name.localeCompare(ac2.keystore.name));
}
__name(getAccountsByKeystore, "getAccountsByKeystore");
function isAmbiguiousName(name, accounts) {
  return accounts.filter((keystore) => keystore.keystore.name === name).length > 1;
}
__name(isAmbiguiousName, "isAmbiguiousName");
const getAccounts = /* @__PURE__ */ __name(() => apiGet("accounts"), "getAccounts"), getAccountsTotalBalance = /* @__PURE__ */ __name(() => apiGet("accounts/total-balance"), "getAccountsTotalBalance"), getEthAccountCodeAndNameByAddress = /* @__PURE__ */ __name((address2) => apiPost("accounts/eth-account-code", { address: address2 }), "getEthAccountCodeAndNameByAddress"), getStatus$2 = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/status`), "getStatus$2"), allScriptTypes = ["p2pkh", "p2wpkh-p2sh", "p2wpkh", "p2tr"], getInfo = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/info`), "getInfo"), init = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/init`), "init"), getSummary = /* @__PURE__ */ __name(() => apiGet("account-summary"), "getSummary"), getBalance = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/balance`), "getBalance"), postNotesTx = /* @__PURE__ */ __name((code, {
  internalTxID,
  note: note2
}) => apiPost(`account/${code}/notes/tx`, { internalTxID, note: note2 }), "postNotesTx"), proposeTxNote = /* @__PURE__ */ __name((code, note2) => apiPost(`account/${code}/propose-tx-note`, note2), "proposeTxNote"), getTransactionList = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/transactions`), "getTransactionList"), getTransaction = /* @__PURE__ */ __name((code, id2) => apiGet(`account/${code}/transaction?id=${id2}`), "getTransaction"), exportAccount = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/export`), "exportAccount"), verifyXPub = /* @__PURE__ */ __name((code, signingConfigIndex) => apiPost(`account/${code}/verify-extended-public-key`, { signingConfigIndex }), "verifyXPub"), getReceiveAddressList = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/receive-addresses`), "getReceiveAddressList"), sendTx = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/sendtx`), "sendTx"), getFeeTargetList = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/fee-targets`), "getFeeTargetList"), verifyAddress$1 = /* @__PURE__ */ __name((code, addressID) => apiPost(`account/${code}/verify-address`, addressID), "verifyAddress$1"), getUTXOs = /* @__PURE__ */ __name((code) => apiGet(`account/${code}/utxos`), "getUTXOs"), hasSecureOutput = /* @__PURE__ */ __name((code) => () => apiGet(`account/${code}/has-secure-output`), "hasSecureOutput"), addAccount = /* @__PURE__ */ __name((coinCode, name) => apiPost("account-add", {
  coinCode,
  name
}), "addAccount"), testRegister = /* @__PURE__ */ __name((pin) => apiPost("test/register", { pin }), "testRegister"), connectKeystore = /* @__PURE__ */ __name((code) => apiPost(`account/${code}/connect-keystore`), "connectKeystore"), ethSignMessage = /* @__PURE__ */ __name((code, message2) => apiPost(`account/${code}/eth-sign-msg`, message2), "ethSignMessage"), ethSignTypedMessage = /* @__PURE__ */ __name((code, chainId, data) => apiPost(`account/${code}/eth-sign-typed-msg`, { chainId, data }), "ethSignTypedMessage"), ethSignWalletConnectTx = /* @__PURE__ */ __name((code, send2, chainId, tx) => apiPost(`account/${code}/eth-sign-wallet-connect-tx`, { send: send2, chainId, tx }), "ethSignWalletConnectTx"), capsWarning = "_capsWarning_1xqma_1", style$V = {
  capsWarning
};
function PasswordInput(props) {
  const { seePlaintext, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: seePlaintext ? "text" : "password",
      ...rest
    }
  );
}
__name(PasswordInput, "PasswordInput");
const _PasswordSingleInputClass = class _PasswordSingleInputClass extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: "",
      seePlaintext: !1,
      capsLock: !1
    });
    __publicField(this, "password", reactExports.createRef());
    __publicField(this, "idPrefix", /* @__PURE__ */ __name(() => this.props.idPrefix || "", "idPrefix"));
    __publicField(this, "tryPaste", /* @__PURE__ */ __name((event2) => {
      event2.target.type === "password" && (event2.preventDefault(), alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      })));
    }, "tryPaste"));
    __publicField(this, "clear", /* @__PURE__ */ __name(() => {
      this.setState({
        password: "",
        seePlaintext: !1,
        capsLock: !1
      });
    }, "clear"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => {
      if (this.regex && this.password.current && !this.password.current.validity.valid)
        return this.props.onValidPassword(null);
      this.state.password ? this.props.onValidPassword(this.state.password) : this.props.onValidPassword(null);
    }, "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      let value = event2.target.value;
      event2.target.type === "checkbox" && (value = event2.target.checked);
      const stateKey = event2.target.id.slice(this.idPrefix().length);
      this.setState({ [stateKey]: value }, this.validate);
    }, "handleFormChange"));
    __publicField(this, "handleCheckCaps", /* @__PURE__ */ __name((event2) => {
      const capsLock = hasCaps(event2);
      capsLock !== null && this.setState({ capsLock });
    }, "handleCheckCaps"));
  }
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a46;
    this.props.pattern && (this.regex = new RegExp(this.props.pattern)), this.props.autoFocus && ((_a46 = this.password) != null && _a46.current) && this.password.current.focus();
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      showLabel
    } = this.props, {
      password: password2,
      seePlaintext,
      capsLock
    } = this.state, warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$V.capsWarning,
        title: t2("password.warning.caps"),
        children: "⇪"
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        autoFocus: !0,
        disabled: disabled2,
        type: seePlaintext ? "text" : "password",
        pattern,
        title: title2,
        id: this.idPrefix() + "password",
        label: label2,
        placeholder,
        onInput: this.handleFormChange,
        onPaste: this.tryPaste,
        ref: this.password,
        value: password2,
        labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: this.idPrefix() + "seePlaintext",
            onChange: this.handleFormChange,
            checked: seePlaintext,
            label: t2("password.show", {
              label: showLabel || label2
            })
          }
        ),
        children: warning2
      }
    );
  }
};
__name(_PasswordSingleInputClass, "PasswordSingleInputClass");
let PasswordSingleInputClass = _PasswordSingleInputClass;
const PasswordSingleInput = withTranslation(null, { withRef: !0 })(PasswordSingleInputClass), _PasswordRepeatInputClass = class _PasswordRepeatInputClass extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: "",
      passwordRepeat: "",
      seePlaintext: !1,
      capsLock: !1
    });
    __publicField(this, "password", reactExports.createRef());
    __publicField(this, "passwordRepeat", reactExports.createRef());
    __publicField(this, "idPrefix", /* @__PURE__ */ __name(() => this.props.idPrefix || "", "idPrefix"));
    __publicField(this, "tryPaste", /* @__PURE__ */ __name((event2) => {
      event2.target.type === "password" && (event2.preventDefault(), alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      })));
    }, "tryPaste"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => {
      if (this.regex && this.password.current && this.passwordRepeat.current && (!this.password.current.validity.valid || !this.passwordRepeat.current.validity.valid))
        return this.props.onValidPassword(null);
      this.state.password && this.state.password === this.state.passwordRepeat ? this.props.onValidPassword(this.state.password) : this.props.onValidPassword(null);
    }, "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      let value = event2.target.value;
      event2.target.type === "checkbox" && (value = event2.target.checked);
      const stateKey = event2.target.id.slice(this.idPrefix().length);
      this.setState({ [stateKey]: value }, this.validate);
    }, "handleFormChange"));
    __publicField(this, "handleCheckCaps", /* @__PURE__ */ __name((event2) => {
      const capsLock = hasCaps(event2);
      capsLock != null && this.setState({ capsLock });
    }, "handleCheckCaps"));
  }
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a46;
    this.props.pattern && (this.regex = new RegExp(this.props.pattern)), this.props.autoFocus && ((_a46 = this.password) != null && _a46.current) && this.password.current.focus();
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      repeatLabel,
      repeatPlaceholder,
      showLabel
    } = this.props, {
      password: password2,
      passwordRepeat,
      seePlaintext,
      capsLock
    } = this.state, warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$V.capsWarning,
        title: t2("password.warning.caps"),
        children: "⇪"
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          autoFocus: !0,
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "password",
          label: label2,
          placeholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: password2,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: password2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "passwordRepeat",
          label: repeatLabel,
          placeholder: repeatPlaceholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: passwordRepeat,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: passwordRepeat
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          id: this.idPrefix() + "seePlaintext",
          onChange: this.handleFormChange,
          checked: seePlaintext,
          label: t2("password.show", {
            label: showLabel || label2
          })
        }
      ) })
    ] });
  }
};
__name(_PasswordRepeatInputClass, "PasswordRepeatInputClass");
let PasswordRepeatInputClass = _PasswordRepeatInputClass;
const PasswordRepeatInput = withTranslation(null, { withRef: !0 })(PasswordRepeatInputClass);
function MatchesPattern({ regex, value = "", text: text2 }) {
  return !regex || !value.length || regex.test(value) ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--color-error)" }, children: text2 });
}
__name(MatchesPattern, "MatchesPattern");
const excludeKeys = /^(Shift|Alt|Backspace|CapsLock|Tab)$/i;
function hasCaps({ key }) {
  return key.length > 1 || key.toUpperCase() === key.toLowerCase() || excludeKeys.test(key) ? null : key.toUpperCase() === key && key.toLowerCase() !== key && !event.shiftKey;
}
__name(hasCaps, "hasCaps");
const SkipForTesting = /* @__PURE__ */ __name(() => {
  const [dialog2, setDialog] = reactExports.useState(!1), show2 = useLoad(() => Promise.resolve(!1)), [testPIN, setTestPIN] = reactExports.useState(""), registerTestingDevice = /* @__PURE__ */ __name(async (e2) => {
    e2.preventDefault(), await testRegister(testPIN), setDialog(!1);
  }, "registerTestingDevice");
  if (!show2)
    return null;
  const title2 = "Unlock software keystore";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setDialog(!0), children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: dialog2, title: title2, onClose: () => setDialog(!1), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: registerTestingDevice, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordSingleInput,
        {
          type: "password",
          autoFocus: !0,
          label: "Test Password",
          onValidPassword: setTestPIN,
          value: testPIN
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: "Unlock" }) })
    ] }) })
  ] });
}, "SkipForTesting"), _Store = class _Store {
  /**
     * Creates a new store with the given initial state.
     */
  /* eslint no-useless-constructor: "off" */
  constructor(state) {
    this.state = state, this.components = [];
  }
  /**
     * This method should only be called by the Share HOC.
     */
  subscribe(component) {
    this.components.push(component);
  }
  /**
     * This method should only be called by the Share HOC.
     */
  unsubscribe(component) {
    const index = this.components.indexOf(component);
    this.components.splice(index, 1);
  }
  updateComponents() {
    for (const component of this.components)
      component.forceUpdate();
  }
  /**
     * Sets the state of this store and updates the subscribed components.
     * Please note that you are allowed to pass a partial state just as in React.
     */
  setState(partialState) {
    Object.assign(this.state, partialState), this.updateComponents();
  }
};
__name(_Store, "Store");
let Store = _Store;
const badge$3 = "_badge_f2nw5_1", iconOnly = "_iconOnly_f2nw5_11", badgeIcon = "_badgeIcon_f2nw5_20", withChildren = "_withChildren_f2nw5_24", success$4 = "_success_f2nw5_34", warning$3 = "_warning_f2nw5_40", style$U = {
  badge: badge$3,
  iconOnly,
  badgeIcon,
  withChildren,
  success: success$4,
  warning: warning$3
}, Badge = /* @__PURE__ */ __name(({
  children: children2,
  className,
  icon: icon2,
  type: type2 = "success",
  ...props
}) => {
  const withChildrenStyle = children2 !== void 0 ? style$U.withChildren : "", iconOnlyStyle = children2 === void 0 && icon2 ? style$U.iconOnly : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$U.badge} ${style$U[type2]} ${withChildrenStyle} ${iconOnlyStyle} ${className || ""}`,
      ...props,
      children: [
        icon2 && icon2({ className: style$U.badgeIcon }),
        children2
      ]
    }
  );
}, "Badge"), closeButton$1 = "_closeButton_1xwfn_1", sidebarOverlay = "_sidebarOverlay_1xwfn_13", active$3 = "_active_1xwfn_26", sidebar = "_sidebar_1xwfn_13", end = "_end_1xwfn_47", forceShow = "_forceShow_1xwfn_52", sidebarLogoContainer = "_sidebarLogoContainer_1xwfn_56", sidebarHeaderContainer = "_sidebarHeaderContainer_1xwfn_75", sidebarPortfolio = "_sidebarPortfolio_1xwfn_85", sidebarHeader = "_sidebarHeader_1xwfn_75", sidebarIconVisible = "_sidebarIconVisible_1xwfn_95", sidebarIconHidden = "_sidebarIconHidden_1xwfn_99", sidebarItem = "_sidebarItem_1xwfn_103", sidebarArrow = "_sidebarArrow_1xwfn_121", sidebarActive = "_sidebarActive_1xwfn_125", activeGroup = "_activeGroup_1xwfn_130", single = "_single_1xwfn_136", sidebarLabel = "_sidebarLabel_1xwfn_141", sidebarSubmenu = "_sidebarSubmenu_1xwfn_197", sidebarContainer = "_sidebarContainer_1xwfn_216", forceHide = "_forceHide_1xwfn_216", style$T = {
  closeButton: closeButton$1,
  sidebarOverlay,
  active: active$3,
  sidebar,
  end,
  forceShow,
  sidebarLogoContainer,
  sidebarHeaderContainer,
  sidebarPortfolio,
  sidebarHeader,
  sidebarIconVisible,
  sidebarIconHidden,
  sidebarItem,
  sidebarArrow,
  sidebarActive,
  activeGroup,
  single,
  sidebarLabel,
  sidebarSubmenu,
  sidebarContainer,
  forceHide
}, panelStore = new Store({
  activeSidebar: !1,
  sidebarStatus: ""
}), toggleSidebar = /* @__PURE__ */ __name(() => {
  const toggled = !panelStore.state.activeSidebar;
  panelStore.setState({ activeSidebar: toggled });
}, "toggleSidebar"), setSidebarStatus = /* @__PURE__ */ __name((status2) => {
  panelStore.setState({ sidebarStatus: status2 });
}, "setSidebarStatus"), GetAccountLink = /* @__PURE__ */ __name(({
  coinCode,
  code,
  name,
  handleSidebarItemClick
}) => {
  const { pathname } = useLocation(), active2 = pathname === `/account/${code}` || pathname.startsWith(`/account/${code}/`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Link,
    {
      className: active2 ? style$T.sidebarActive : "",
      to: `/account/${code}`,
      onClick: handleSidebarItemClick,
      title: name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: !0, coinCode, alt: name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: name })
      ]
    }
  ) }, code);
}, "GetAccountLink"), Sidebar = /* @__PURE__ */ __name(({
  deviceIDs,
  accounts,
  activeSidebar,
  sidebarStatus
  // from share HOC
}) => {
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    const swipe = {
      active: !1,
      x: 0,
      y: 0
    }, handleTouchStart = /* @__PURE__ */ __name((event2) => {
      const touch = event2.touches[0];
      swipe.x = touch.clientX, swipe.y = touch.clientY;
    }, "handleTouchStart"), handleTouchMove = /* @__PURE__ */ __name((event2) => {
      sidebarStatus !== "forceHidden" && event2.changedTouches && event2.changedTouches.length && (swipe.active = !0);
    }, "handleTouchMove"), handleTouchEnd = /* @__PURE__ */ __name((event2) => {
      if (sidebarStatus !== "forceHidden") {
        const touch = event2.changedTouches[0], travelX = Math.abs(touch.clientX - swipe.x), travelY = Math.abs(touch.clientY - swipe.y), validSwipe = window.innerWidth <= 901 && swipe.active && travelY < 100 && travelX > 70;
        (!panelStore.state.activeSidebar && validSwipe && swipe.x < 60 || panelStore.state.activeSidebar && validSwipe && swipe.x > 230) && toggleSidebar(), swipe.x = 0, swipe.y = 0, swipe.active = !1;
      }
    }, "handleTouchEnd");
    return document.addEventListener("touchstart", handleTouchStart), document.addEventListener("touchmove", handleTouchMove), document.addEventListener("touchend", handleTouchEnd), () => {
      document.removeEventListener("touchstart", handleTouchStart), document.removeEventListener("touchmove", handleTouchMove), document.removeEventListener("touchend", handleTouchEnd);
    };
  }, [sidebarStatus]);
  const [keystores, setKeystores] = reactExports.useState();
  reactExports.useEffect(() => (getKeystores().then((keystores2) => {
    setKeystores(keystores2);
  }), subscribeKeystores(setKeystores)), []);
  const handleSidebarItemClick = /* @__PURE__ */ __name((event2) => {
    event2.target.closest("a").classList.contains("sidebarActive") && window.innerWidth <= 901 && toggleSidebar();
  }, "handleSidebarItemClick"), hidden = sidebarStatus === "forceHidden", hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode)), accountsByKeystore = getAccountsByKeystore(accounts);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$T.sidebarContainer, hidden ? style$T.forceHide : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$T.sidebarOverlay, activeSidebar ? style$T.active : ""].join(" "), onClick: toggleSidebar }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: [style$T.sidebar, activeSidebar ? style$T.forceShow : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$T.sidebarLogoContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: accounts.length ? "/account-summary" : "/",
            onClick: handleSidebarItemClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, { className: style$T.sidebarLogo })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$T.closeButton, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {}) })
      ] }),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$T.sidebarItem} ${style$T.sidebarPortfolio}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/account-summary",
          title: t2("accountSummary.title"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: info$2 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: t2("accountSummary.title") })
          ]
        }
      ) }) : null,
      accountsByKeystore.map((keystore) => /* @__PURE__ */ jsxRuntimeExports.jsxs(React.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarHeaderContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: style$T.sidebarHeader,
            hidden: !keystore.accounts.length,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                `${keystore.keystore.name} `,
                isAmbiguiousName(keystore.keystore.name, accountsByKeystore) ? (
                  // Disambiguate accounts group by adding the fingerprint.
                  // The most common case where this would happen is when adding accounts from the
                  // same seed using different passphrases.
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    " (",
                    keystore.keystore.rootFingerprint,
                    ")"
                  ] })
                ) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Badge,
                {
                  className: keystore.keystore.connected ? style$T.sidebarIconVisible : style$T.sidebarIconHidden,
                  icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                  type: "success",
                  title: t2("device.keystoreConnected")
                }
              )
            ]
          }
        ) }),
        keystore.accounts.map((acc) => /* @__PURE__ */ jsxRuntimeExports.jsx(GetAccountLink, { ...acc, handleSidebarItemClick }, acc.code))
      ] }, keystore.keystore.rootFingerprint)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$T.sidebarHeaderContainer, style$T.end].join(" ") }),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/buy/info",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: coins }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: hasOnlyBTCAccounts ? t2("accountInfo.buyCTA.buy", { unit: "Bitcoin" }) : t2("sidebar.buy") })
          ]
        }
      ) }, "buy") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$T.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$T.sidebarActive : "",
          to: "/settings",
          title: t2("sidebar.settings"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: settingsGrey, alt: t2("sidebar.settings") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: !1, src: settings, alt: t2("sidebar.settings") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$T.sidebarLabel, children: t2("sidebar.settings") })
          ]
        }
      ) }, "settings-new"),
      !keystores || keystores.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {}) : null,
      debug
    ] })
  ] });
}, "Sidebar"), guideShareHOC = share(panelStore)(Sidebar), AppContext = reactExports.createContext({}), children$1 = "_children_1y42x_1", container$n = "_container_1y42x_22", fixed = "_fixed_1y42x_26", disabled$2 = "_disabled_1y42x_34", forceHidden = "_forceHidden_1y42x_38", sidebarToggler = "_sidebarToggler_1y42x_38", guideIcon = "_guideIcon_1y42x_42", guideIconContainer = "_guideIconContainer_1y42x_57", header$6 = "_header_1y42x_62", narrow = "_narrow_1y42x_76", title$7 = "_title_1y42x_99", hideSidebarToggler = "_hideSidebarToggler_1y42x_120", style$S = {
  children: children$1,
  container: container$n,
  fixed,
  disabled: disabled$2,
  forceHidden,
  sidebarToggler,
  guideIcon,
  guideIconContainer,
  header: header$6,
  narrow,
  title: title$7,
  hideSidebarToggler
}, Header = /* @__PURE__ */ __name(({
  sidebarStatus,
  narrow: narrow2,
  title: title2,
  hideSidebarToggler: hideSidebarToggler2,
  children: children2
}) => {
  const { t: t2 } = useTranslation(), { guideShown, guideExists, toggleGuide } = reactExports.useContext(AppContext), toggle2 = /* @__PURE__ */ __name((e2) => (e2.preventDefault(), guideShown || toggleGuide(), !1), "toggle");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.container, sidebarStatus ? style$S[sidebarStatus] : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.header, narrow2 ? style$S.narrow : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$S.sidebarToggler} ${hideSidebarToggler2 ? style$S.hideSidebarToggler : ""}`, onClick: toggleSidebar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, { className: "show-in-lightmode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuLight, { className: "show-in-darkmode" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.title, children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.children, children: [
      children2,
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$S.guideIconContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", onClick: toggle2, className: [style$S.guideIcon, guideShown ? style$S.disabled : ""].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GuideActive, {}),
        t2("guide.toggle.open")
      ] }) })
    ] })
  ] }) });
}, "Header"), SharedHeader = share(panelStore)(Header), main$1 = "_main_1ntet_1", style$R = {
  main: main$1
}, Main = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: style$R.main, children: children2 }), "Main"), columnAsCard = "_columnAsCard_1rob5_1", column$2 = "_column_1rob5_1", columnButtons = "_columnButtons_1rob5_10", columnButtonsInline = "_columnButtonsInline_1rob5_10", left$1 = "_left_1rob5_29", center = "_center_1rob5_33", grid = "_grid_1rob5_47", style$Q = {
  columnAsCard,
  column: column$2,
  columnButtons,
  columnButtonsInline,
  left: left$1,
  center,
  grid,
  "grid-columns-1": "_grid-columns-1_1rob5_53",
  "grid-columns-2": "_grid-columns-2_1rob5_56"
}, Grid = /* @__PURE__ */ __name(({
  children: children2,
  col = "2",
  textAlign
}) => {
  const styles2 = `
    ${style$Q.grid}
    ${style$Q[`grid-columns-${col}`]}
    ${textAlign !== void 0 ? style$Q[textAlign] : ""}
  `;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: styles2, children: children2 });
}, "Grid"), Column = /* @__PURE__ */ __name(({
  asCard,
  children: children2,
  className
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$Q.column} ${asCard ? style$Q.columnAsCard : ""} ${className || ""}`, children: children2 }), "Column"), ColumnButtons = /* @__PURE__ */ __name(({
  children: children2,
  className = "",
  inline
}) => {
  const classNames2 = `${style$Q.columnButtons} ${inline ? style$Q.columnButtonsInline : ""} ${className}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
}, "ColumnButtons"), footer = "_footer_19w3c_1", style$P = {
  footer
};
function Footer({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: [style$P.footer, "flex flex-row flex-items-center flex-end"].join(" "), children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
  ] });
}
__name(Footer, "Footer");
const contentWithGuide = "_contentWithGuide_1gscs_1", container$m = "_container_1gscs_8", styles$o = {
  contentWithGuide,
  container: container$m
}, GuideWrapper = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.contentWithGuide, children: children2 }), "GuideWrapper"), GuidedContent = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$o.container, children: children2 }), "GuidedContent"), steps = "_steps_1l429_6", step = "_step_1l429_6", dot = "_dot_1l429_38", line$1 = "_line_1l429_72", finish = "_finish_1l429_76", wait = "_wait_1l429_81", process$1 = "_process_1l429_97", content$3 = "_content_1l429_110", style$O = {
  steps,
  step,
  dot,
  line: line$1,
  finish,
  wait,
  process: process$1,
  content: content$3
}, Steps = /* @__PURE__ */ __name(({
  current,
  children: children2
}) => {
  let childrens = React.Children.toArray(children2).filter(React.isValidElement);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.steps, children: childrens.filter((child) => !child.props.hidden).map((child, step2) => {
    if (!child)
      return null;
    const status2 = step2 === current ? "process" : step2 < current ? "finish" : "wait", line2 = step2 > 0;
    return reactExports.cloneElement(child, {
      step: step2 + 1,
      line: line2,
      status: status2
    });
  }) });
}, "Steps");
function Step({
  children: children2,
  hidden = !1,
  line: line2,
  status: status2 = "wait"
}) {
  return hidden ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$O.step} ${style$O[status2]} ${line2 ? style$O.line : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.dot }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$O.content, children: children2 })
  ] });
}
__name(Step, "Step");
const CoinDropDown = /* @__PURE__ */ __name(({
  onChange: onChange2,
  supportedCoins,
  value
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select$1,
    {
      autoFocus: !0,
      options: [
        {
          text: t2("buy.info.selectPlaceholder"),
          disabled: !0,
          value: "choose"
        },
        ...supportedCoins.map(({ coinCode, name, canAddAccount }) => ({
          value: coinCode,
          text: name,
          disabled: !canAddAccount
        }))
      ],
      onInput: (e2) => onChange2(supportedCoins.find((c2) => c2.coinCode === e2.target.value)),
      value,
      id: "coinCodeDropDown"
    }
  );
}, "CoinDropDown"), notifyUser = /* @__PURE__ */ __name((text2) => apiPost("notify-user", { text: text2 }), "notifyUser"), open = /* @__PURE__ */ __name((href) => apiPost("open", href), "open"), link$3 = "_link_1o1mh_1", style$N = {
  link: link$3
}, A$3 = /* @__PURE__ */ __name(({
  href,
  icon: icon2,
  className,
  children: children2,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "span",
  {
    className: `${style$N.link} ${className || ""}`,
    title: props.title || href,
    onClick: (e2) => {
      e2.preventDefault(), open(href).catch(console.error);
    },
    tabIndex: 0,
    ...props,
    children: [
      icon2 || null,
      children2
    ]
  }
), "A$3"), overlay$2 = "_overlay_14an4_1", close$2 = "_close_14an4_13", wrapper = "_wrapper_14an4_29", guide = "_guide_14an4_33", header$5 = "_header_14an4_44", content$2 = "_content_14an4_62", show = "_show_14an4_83", entry$1 = "_entry_14an4_87", entryTitle = "_entryTitle_14an4_91", entryToggle = "_entryToggle_14an4_99", entryTitleText = "_entryTitleText_14an4_109", entryContent = "_entryContent_14an4_113", expanded = "_expanded_14an4_121", link$2 = "_link_14an4_125", guideWrapper = "_guideWrapper_14an4_135", style$M = {
  overlay: overlay$2,
  close: close$2,
  wrapper,
  guide,
  header: header$5,
  content: content$2,
  show,
  entry: entry$1,
  entryTitle,
  entryToggle,
  entryTitleText,
  entryContent,
  expanded,
  link: link$2,
  guideWrapper
}, Entry = /* @__PURE__ */ __name((props) => {
  const [shown, setShown] = reactExports.useState(props.shown || !1), toggle2 = /* @__PURE__ */ __name(() => {
    setShown((shown2) => !shown2);
  }, "toggle"), entry2 = props.entry;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entry, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entryTitle, onClick: toggle2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$M.entryToggle, children: shown ? "–" : "+" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$M.entryTitleText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: entry2.title }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$M.entryContent, shown ? style$M.expanded : ""].join(" "), children: shown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      entry2.text.trim().split(`
`).map((p2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: p2 }, idx)),
      entry2.link && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        A$3,
        {
          className: style$M.link,
          "data-testid": "link",
          href: entry2.link.url,
          children: entry2.link.text
        }
      ) }),
      props.children
    ] }) : null })
  ] });
}, "Entry"), Guide = /* @__PURE__ */ __name(({ children: children2 }) => {
  const { guideShown, toggleGuide, setGuideExists } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => (setGuideExists(!0), () => {
    setGuideExists(!1);
  }), [setGuideExists]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$M.overlay, guideShown && style$M.show].join(" "), onClick: toggleGuide }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$M.guide, guideShown && style$M.show].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$M.header, "flex flex-row flex-between flex-items-center"].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("guide.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: style$M.close, onClick: toggleGuide, children: [
          t2("guide.toggle.close"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.content, children: [
        children2,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$M.entry, children: [
          t2("guide.appendix.text"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { className: style$M.link, href: "https://bitbox.swiss/support/", children: t2("guide.appendix.link") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
        ] })
      ] })
    ] })
  ] });
}, "Guide"), AddAccountGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
}, "AddAccountGuide");
let navigate;
const route = /* @__PURE__ */ __name((route2, replace2) => {
  navigate == null || navigate(route2, { replace: replace2 });
}, "route"), RouterWatcher = /* @__PURE__ */ __name(({ onChange: onChange2 }) => {
  navigate = useNavigate();
  const { pathname } = useLocation();
  return reactExports.useEffect(() => {
    onChange2();
  }, [onChange2, pathname]), null;
}, "RouterWatcher"), manageContainer = "_manageContainer_1n5md_1", title$6 = "_title_1n5md_9", successCheck = "_successCheck_1n5md_14", successMessage = "_successMessage_1n5md_20", styles$n = {
  manageContainer,
  title: title$6,
  successCheck,
  successMessage
}, AddAccount = /* @__PURE__ */ __name(() => {
  const [accountCode, setAccountCode] = reactExports.useState(), [accountName2, setAccountName] = reactExports.useState(""), [coinCode, setCoinCode] = reactExports.useState("choose"), [errorMessage, setErrorMessage] = reactExports.useState(), [step2, setStep] = reactExports.useState("select-coin"), [supportedCoins, setSupportedCoins] = reactExports.useState([]), [adding, setAdding] = reactExports.useState(!1), inputRef = reactExports.useRef(null), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    var _a46;
    step2 === "choose-name" && ((_a46 = inputRef.current) == null || _a46.focus());
  }, [step2]);
  const onlyOneSupportedCoin = /* @__PURE__ */ __name(() => supportedCoins.length === 1, "onlyOneSupportedCoin"), startProcess = reactExports.useCallback(async () => {
    var _a46;
    try {
      const coins2 = await getSupportedCoins(), onlyOneCoinIsSupported = coins2.length === 1;
      setCoinCode(onlyOneCoinIsSupported ? coins2[0].coinCode : "choose"), setStep(onlyOneCoinIsSupported ? "choose-name" : "select-coin"), setSupportedCoins(coins2), onlyOneCoinIsSupported && setAccountCode(coins2[0].suggestedAccountName), (_a46 = inputRef.current) == null || _a46.focus();
    } catch (err) {
      console.error(err);
    }
  }, []);
  reactExports.useEffect(() => (startProcess(), subscribeKeystores(() => {
    startProcess();
  })), [startProcess]);
  const back = /* @__PURE__ */ __name(() => {
    switch (step2) {
      case "select-coin":
        route("/settings/manage-accounts");
        break;
      case "choose-name":
        setStep("select-coin"), setErrorMessage(void 0);
        break;
      case "success":
        setStep("choose-name");
        break;
    }
  }, "back"), next2 = /* @__PURE__ */ __name(async (e2) => {
    switch (e2.preventDefault(), step2) {
      case "select-coin":
        setStep("choose-name");
        break;
      case "choose-name":
        setAdding(!0);
        const responseData = await addAccount(coinCode, accountName2);
        setAdding(!1), responseData.success ? (setAccountCode(responseData.accountCode), setErrorMessage(void 0), setStep("success")) : responseData.errorCode ? setErrorMessage(t2(`error.${responseData.errorCode}`)) : responseData.errorMessage && setErrorMessage(t2("unknownError", { errorMessage: responseData.errorMessage }));
        break;
      case "success":
        accountCode && route(`/account/${accountCode}`);
        break;
    }
  }, "next"), renderContent = /* @__PURE__ */ __name(() => {
    switch (step2) {
      case "select-coin":
        return supportedCoins.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("connectKeystore.promptNoName") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          CoinDropDown,
          {
            onChange: (coin) => {
              setCoinCode(coin.coinCode), setAccountName(coin.suggestedAccountName);
            },
            supportedCoins,
            value: coinCode
          }
        );
      case "choose-name":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            autoFocus: !0,
            ref: inputRef,
            id: "accountName",
            onInput: (e2) => setAccountName(e2.target.value),
            value: accountName2
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { className: styles$n.successCheck }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleMarkup,
            {
              className: styles$n.successMessage,
              markup: t2("addAccount.success.message", { accountName: accountName2 }),
              tagName: "p"
            }
          )
        ] });
    }
  }, "renderContent"), getTextFor = /* @__PURE__ */ __name((step22) => {
    switch (step22) {
      case "select-coin":
        return {
          titleText: t2("addAccount.selectCoin.title"),
          nextButtonText: t2("addAccount.selectCoin.nextButton")
        };
      case "choose-name":
        return {
          titleText: t2("addAccount.chooseName.title"),
          nextButtonText: t2("addAccount.chooseName.nextButton")
        };
      case "success":
        return {
          titleText: t2("addAccount.success.title"),
          nextButtonText: t2("addAccount.success.nextButton")
        };
    }
  }, "getTextFor"), handleAddAnotherAccount = /* @__PURE__ */ __name(async () => {
    setAccountCode(void 0), setAccountName(""), setCoinCode("choose"), setErrorMessage(void 0), setStep("select-coin"), await startProcess();
  }, "handleAddAnotherAccount"), currentStep = [
    ...onlyOneSupportedCoin() ? [] : ["select-coin"],
    "choose-name",
    "success"
  ].indexOf(step2), { titleText, nextButtonText } = getTextFor(step2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("manageAccounts.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content larger isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: `${styles$n.manageContainer} box larger flex flex-column flex-between`,
          onSubmit: next2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              t2("addAccount.title"),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$n.title, children: titleText })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", hidden: !errorMessage, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: errorMessage }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: renderContent() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Steps, { current: currentStep, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { hidden: onlyOneSupportedCoin(), children: t2("addAccount.selectCoin.step") }, "select-coin"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.chooseName.step") }, "choose-name"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.success.step") }, "success")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row flex flex-row flex-between m-bottom", style: { flexDirection: "row-reverse" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: step2 === "select-coin" && coinCode === "choose" || step2 === "choose-name" && (accountName2 === "" || adding),
                  primary: !0,
                  type: "submit",
                  children: nextButtonText
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: back,
                  hidden: step2 === "success",
                  secondary: !0,
                  children: t2("button.back")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleAddAnotherAccount,
                  hidden: step2 !== "success",
                  secondary: !0,
                  children: t2("addAccount.success.addAnotherAccount")
                }
              )
            ] })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccountGuide, {})
  ] });
}, "AddAccount"), getExchangesByRegion = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/by-region/${code}`), "getExchangesByRegion"), getExchangeDeals = /* @__PURE__ */ __name(() => apiGet("exchange/deals"), "getExchangeDeals"), getMoonpayBuyInfo = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/moonpay/buy-info/${code}`), "getMoonpayBuyInfo"), signAddress = /* @__PURE__ */ __name((format, msg, accountCode) => apiPost("exchange/pocket/sign-address", { format, msg, accountCode }), "signAddress"), verifyAddress = /* @__PURE__ */ __name((address2, accountCode) => apiPost("exchange/pocket/verify-address", { address: address2, accountCode }), "verifyAddress"), getPocketURL = /* @__PURE__ */ __name(() => apiGet("exchange/pocket/api-url"), "getPocketURL"), getExchangeBuySupported = /* @__PURE__ */ __name((code) => () => apiGet(`exchange/buy-supported/${code}`), "getExchangeBuySupported");
function BuyGuide({ name, exchange }) {
  const { t: t2 } = useTranslation(), pocketLink = {
    text: t2("buy.pocket.data.link"),
    url: "https://pocketbitcoin.com/policy/privacy"
  }, moonpayLink = {
    text: t2("buy.info.disclaimer.privacyPolicy"),
    url: "https://www.moonpay.com/privacy_policy"
  }, privacyLink = exchange === "pocket" ? pocketLink : moonpayLink;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("buy.info.disclaimer.security.link"),
        url: "https://bitbox.swiss/bitbox02/threat-model/"
      },
      text: t2("buy.info.disclaimer.security.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.security.title")
    }, shown: !0 }, "guide.buy.security"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: exchange ? privacyLink : void 0,
      text: t2("buy.info.disclaimer.protection.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.protection.title")
    } }, "guide.buy.protection")
  ] });
}
__name(BuyGuide, "BuyGuide");
const spinnerContainer$2 = "_spinnerContainer_rthjr_1", spinner$2 = "_spinner_rthjr_1", spinnerText = "_spinnerText_rthjr_24", spinner1 = "_spinner1_rthjr_1", spinner2 = "_spinner2_rthjr_1", spinner3 = "_spinner3_rthjr_1", horizontallyCentered = "_horizontallyCentered_rthjr_59", overlay$1 = "_overlay_rthjr_81", fadein = "_fadein_rthjr_1", togglersContainer = "_togglersContainer_rthjr_98", guideToggler = "_guideToggler_rthjr_111", toggler = "_toggler_rthjr_98", togglerContainer = "_togglerContainer_rthjr_145", style$L = {
  spinnerContainer: spinnerContainer$2,
  spinner: spinner$2,
  spinnerText,
  spinner1,
  spinner2,
  spinner3,
  horizontallyCentered,
  overlay: overlay$1,
  fadein,
  togglersContainer,
  guideToggler,
  toggler,
  togglerContainer
}, SpinnerAnimation = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.spinner, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
] }), "SpinnerAnimation"), HorizontallyCenteredSpinner = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.horizontallyCentered, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }), "HorizontallyCenteredSpinner"), Spinner = /* @__PURE__ */ __name(({ text: text2, guideExists }) => {
  const { t: t2 } = useTranslation(), { toggleGuide } = reactExports.useContext(AppContext), handleKeyDown = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), document.activeElement.blur();
  }, "handleKeyDown");
  return reactExports.useEffect(() => (document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown)), []), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.spinnerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.togglersContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.togglerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.toggler, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, {}) }) }),
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.guideToggler, onClick: toggleGuide, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "4.93", x2: "9.17", y2: "9.17" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "14.83", x2: "19.07", y2: "19.07" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "19.07", y2: "4.93" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "18.36", y2: "5.64" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "19.07", x2: "9.17", y2: "14.83" })
            ]
          }
        ),
        t2("guide.toggle.open")
      ] })
    ] }),
    text2 && text2.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$L.spinnerText, children: line2 }, `${line2}-${i}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.overlay })
  ] });
}, "Spinner"), disclaimerContainer = "_disclaimerContainer_5gxwf_1", title$5 = "_title_5gxwf_15", disclaimer = "_disclaimer_5gxwf_1", table$1 = "_table_5gxwf_52", nowrap = "_nowrap_5gxwf_77", style$K = {
  disclaimerContainer,
  title: title$5,
  disclaimer,
  table: table$1,
  nowrap
}, MoonpayTerms = /* @__PURE__ */ __name(({ account: account2, onAgreedTerms }) => {
  const { t: t2 } = useTranslation(), name = getCryptoName(t2("buy.info.crypto"), account2), handleSkipDisclaimer = /* @__PURE__ */ __name((e2) => {
    setConfig({ frontend: { skipMoonpayDisclaimer: e2.target.checked } });
  }, "handleSkipDisclaimer");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.title", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.0", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.1", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.details", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$K.table, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "50px" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.method") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.fee") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$K.nowrap, children: "1.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_description") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$K.nowrap, children: "4.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_description") })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.footnote") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.security.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.info.disclaimer.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.info.disclaimer.protection.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.protection.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/privacy_policy", children: t2("buy.info.disclaimer.privacyPolicy") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
}, "MoonpayTerms"), container$l = "_container_yg57j_1", iframe = "_iframe_yg57j_12", header$4 = "_header_yg57j_18", style$J = {
  container: container$l,
  iframe,
  header: header$4
}, Moonpay = /* @__PURE__ */ __name(({ accounts, code }) => {
  const { t: t2 } = useTranslation(), [agreedTerms, setAgreedTerms] = reactExports.useState(!1), [iframeLoaded, setIframeLoaded] = reactExports.useState(!1), [height, setHeight] = reactExports.useState(0), { isDarkMode } = useDarkmode(), config = useLoad(getConfig), moonpay = useLoad(getMoonpayBuyInfo(code)), account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2), ref = reactExports.createRef();
  let resizeTimerID;
  reactExports.useEffect(() => {
    config && setAgreedTerms(config.frontend.skipMoonpayDisclaimer);
  }, [config]), reactExports.useEffect(() => (onResize(), window.addEventListener("resize", onResize), () => window.removeEventListener("resize", onResize)));
  const onResize = /* @__PURE__ */ __name(() => {
    resizeTimerID && clearTimeout(resizeTimerID), resizeTimerID = setTimeout(() => {
      ref.current && setHeight(ref.current.offsetHeight);
    }, 200);
  }, "onResize");
  return !account2 || !config ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$J.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$J.container, children: agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") }),
        moonpay && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(!0), onResize();
            },
            title: "Moonpay",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$J.iframe,
            allow: "camera; payment",
            src: `${moonpay.url}&colorCode=%235E94BF&theme=${isDarkMode ? "dark" : "light"}`
          }
        )
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        MoonpayTerms,
        {
          account: account2,
          onAgreedTerms: () => setAgreedTerms(!0)
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "moonpay" })
  ] });
}, "Moonpay");
function findLowestFee(providers) {
  let allFees = [];
  return providers.exchanges.forEach((provider) => {
    provider.deals.forEach((deal) => {
      provider.supported && (allFees = [...allFees, deal.fee]);
    });
  }), Math.min(...allFees);
}
__name(findLowestFee, "findLowestFee");
function findBestDeal(providers, lowestFee) {
  const hasMultipleSupportedExchanges = providers.exchanges.filter((p2) => p2.supported).length > 1;
  return { exchanges: providers.exchanges.map((exchange) => ({
    ...exchange,
    deals: exchange.deals.map((deal) => ({
      ...deal,
      isBestDeal: deal.fee === lowestFee && hasMultipleSupportedExchanges
    }))
  })) };
}
__name(findBestDeal, "findBestDeal");
function getFormattedName(name) {
  switch (name) {
    case "moonpay":
      return "MoonPay";
    case "pocket":
      return "Pocket";
  }
}
__name(getFormattedName, "getFormattedName");
async function getExchangeSupportedAccounts(accounts) {
  return (await Promise.all(
    accounts.map(async (account2) => (await getExchangeBuySupported(account2.code)()).exchanges.length ? account2 : !1)
  )).filter((result) => result);
}
__name(getExchangeSupportedAccounts, "getExchangeSupportedAccounts");
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
__name(ownKeys, "ownKeys");
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = arguments[r2] != null ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), !0).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
__name(_objectSpread2, "_objectSpread2");
var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? !1 : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$6), _useState = reactExports.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1], _useState3 = reactExports.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1], _useState5 = reactExports.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1], onChange2 = reactExports.useCallback(function(value2, actionMeta) {
    typeof propsOnChange == "function" && propsOnChange(value2, actionMeta), setStateValue(value2);
  }, [propsOnChange]), onInputChange = reactExports.useCallback(function(value2, actionMeta) {
    var newValue;
    typeof propsOnInputChange == "function" && (newValue = propsOnInputChange(value2, actionMeta)), setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]), onMenuOpen = reactExports.useCallback(function() {
    typeof propsOnMenuOpen == "function" && propsOnMenuOpen(), setStateMenuIsOpen(!0);
  }, [propsOnMenuOpen]), onMenuClose = reactExports.useCallback(function() {
    typeof propsOnMenuClose == "function" && propsOnMenuClose(), setStateMenuIsOpen(!1);
  }, [propsOnMenuClose]), inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue, menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen, value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
__name(useStateManager, "useStateManager");
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source)
        Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
    }
    return target;
  }, _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
    return !1;
  if (typeof Proxy == "function")
    return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
__name(_isNativeReflectConstruct, "_isNativeReflectConstruct");
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return /* @__PURE__ */ __name(function() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else
      result = Super.apply(this, arguments);
    return _possibleConstructorReturn(this, result);
  }, "_createSuperInternal");
}
__name(_createSuper, "_createSuper");
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
__name(_arrayWithoutHoles, "_arrayWithoutHoles");
function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
__name(_nonIterableSpread, "_nonIterableSpread");
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
__name(_toConsumableArray, "_toConsumableArray");
function sheetForTag(tag) {
  if (tag.sheet)
    return tag.sheet;
  for (var i = 0; i < document.styleSheets.length; i++)
    if (document.styleSheets[i].ownerNode === tag)
      return document.styleSheets[i];
}
__name(sheetForTag, "sheetForTag");
function createStyleElement(options2) {
  var tag = document.createElement("style");
  return tag.setAttribute("data-emotion", options2.key), options2.nonce !== void 0 && tag.setAttribute("nonce", options2.nonce), tag.appendChild(document.createTextNode("")), tag.setAttribute("data-s", ""), tag;
}
__name(createStyleElement, "createStyleElement");
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      _this.tags.length === 0 ? _this.insertionPoint ? before = _this.insertionPoint.nextSibling : _this.prepend ? before = _this.container.firstChild : before = _this.before : before = _this.tags[_this.tags.length - 1].nextSibling, _this.container.insertBefore(tag, before), _this.tags.push(tag);
    }, this.isSpeedy = options2.speedy === void 0 ? !0 : options2.speedy, this.tags = [], this.ctr = 0, this.nonce = options2.nonce, this.key = options2.key, this.container = options2.container, this.prepend = options2.prepend, this.insertionPoint = options2.insertionPoint, this.before = null;
  }
  __name(StyleSheet2, "StyleSheet");
  var _proto = StyleSheet2.prototype;
  return _proto.hydrate = /* @__PURE__ */ __name(function(nodes) {
    nodes.forEach(this._insertTag);
  }, "hydrate"), _proto.insert = /* @__PURE__ */ __name(function(rule) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch {
      }
    } else
      tag.appendChild(document.createTextNode(rule));
    this.ctr++;
  }, "insert"), _proto.flush = /* @__PURE__ */ __name(function() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    }), this.tags = [], this.ctr = 0;
  }, "flush"), StyleSheet2;
}(), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from$1 = String.fromCharCode, assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
__name(hash$1, "hash$1");
function trim(value) {
  return value.trim();
}
__name(trim, "trim");
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
__name(match, "match");
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
__name(replace, "replace");
function indexof(value, search) {
  return value.indexOf(search);
}
__name(indexof, "indexof");
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
__name(charat, "charat");
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
__name(substr, "substr");
function strlen(value) {
  return value.length;
}
__name(strlen, "strlen");
function sizeof(value) {
  return value.length;
}
__name(sizeof, "sizeof");
function append(value, array) {
  return array.push(value), value;
}
__name(append, "append");
function combine(array, callback2) {
  return array.map(callback2).join("");
}
__name(combine, "combine");
var line = 1, column$1 = 1, length = 0, position = 0, character = 0, characters = "";
function node$1(value, root2, parent, type2, props, children2, length2) {
  return { value, root: root2, parent, type: type2, props, children: children2, line, column: column$1, length: length2, return: "" };
}
__name(node$1, "node$1");
function copy(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
__name(copy, "copy");
function char() {
  return character;
}
__name(char, "char");
function prev() {
  return character = position > 0 ? charat(characters, --position) : 0, column$1--, character === 10 && (column$1 = 1, line--), character;
}
__name(prev, "prev");
function next$1() {
  return character = position < length ? charat(characters, position++) : 0, column$1++, character === 10 && (column$1 = 1, line++), character;
}
__name(next$1, "next$1");
function peek() {
  return charat(characters, position);
}
__name(peek, "peek");
function caret() {
  return position;
}
__name(caret, "caret");
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
__name(slice, "slice");
function token$2(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
__name(token$2, "token$2");
function alloc(value) {
  return line = column$1 = 1, length = strlen(characters = value), position = 0, [];
}
__name(alloc, "alloc");
function dealloc(value) {
  return characters = "", value;
}
__name(dealloc, "dealloc");
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
__name(delimit, "delimit");
function whitespace(type2) {
  for (; (character = peek()) && character < 33; )
    next$1();
  return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
}
__name(whitespace, "whitespace");
function escaping(index, count) {
  for (; --count && next$1() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice(index, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
__name(escaping, "escaping");
function delimiter(type2) {
  for (; next$1(); )
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        type2 !== 34 && type2 !== 39 && delimiter(character);
        break;
      case 40:
        type2 === 41 && delimiter(type2);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
__name(delimiter, "delimiter");
function commenter(type2, index) {
  for (; next$1() && type2 + character !== 47 + 10; )
    if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from$1(type2 === 47 ? type2 : next$1());
}
__name(commenter, "commenter");
function identifier(index) {
  for (; !token$2(peek()); )
    next$1();
  return slice(index, position);
}
__name(identifier, "identifier");
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
__name(compile, "compile");
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  for (var index = 0, offset = 0, length2 = pseudo, atrule = 0, property = 0, previous2 = 0, variable = 1, scanning = 1, ampersand = 1, character2 = 0, type2 = "", props = rules, children2 = rulesets, reference = rule, characters2 = type2; scanning; )
    switch (previous2 = character2, character2 = next$1()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1 && (ampersand = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            ampersand == -1 && (characters2 = replace(characters2, /\f/g, "")), property > 0 && strlen(characters2) - length2 && append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            if (append(reference = ruleset(characters2, root2, parent, index, offset, rules, points, type2, props = [], children2 = [], length2), rulesets), character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            peek() === 45 && (characters2 += delimit(next$1())), atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            previous2 === 45 && strlen(characters2) == 2 && (variable = 0);
        }
    }
  return rulesets;
}
__name(parse, "parse");
function ruleset(value, root2, parent, index, offset, rules, points, type2, props, children2, length2) {
  for (var post = offset - 1, rule = offset === 0 ? rules : [""], size2 = sizeof(rule), i = 0, j2 = 0, k2 = 0; i < index; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size2; ++x2)
      (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2]))) && (props[k2++] = z2);
  return node$1(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
}
__name(ruleset, "ruleset");
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
__name(comment, "comment");
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
__name(declaration, "declaration");
function serialize(children2, callback2) {
  for (var output2 = "", length2 = sizeof(children2), i = 0; i < length2; i++)
    output2 += callback2(children2[i], i, children2, callback2) || "";
  return output2;
}
__name(serialize, "serialize");
function stringify(element, index, children2, callback2) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback2)) ? element.return = element.value + "{" + children2 + "}" : "";
}
__name(stringify, "stringify");
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children2, callback2) {
    for (var output2 = "", i = 0; i < length2; i++)
      output2 += collection[i](element, index, children2, callback2) || "";
    return output2;
  };
}
__name(middleware, "middleware");
function rulesheet(callback2) {
  return function(element) {
    element.root || (element = element.return) && callback2(element);
  };
}
__name(rulesheet, "rulesheet");
function memoize(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    return cache[arg] === void 0 && (cache[arg] = fn2(arg)), cache[arg];
  };
}
__name(memoize, "memoize");
var identifierWithPointTracking = /* @__PURE__ */ __name(function(begin, points, index) {
  for (var previous2 = 0, character2 = 0; previous2 = character2, character2 = peek(), previous2 === 38 && character2 === 12 && (points[index] = 1), !token$2(character2); )
    next$1();
  return slice(begin, position);
}, "identifierWithPointTracking"), toRules = /* @__PURE__ */ __name(function(parsed, points) {
  var index = -1, character2 = 44;
  do
    switch (token$2(character2)) {
      case 0:
        character2 === 38 && peek() === 12 && (points[index] = 1), parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "", points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from$1(character2);
    }
  while (character2 = next$1());
  return parsed;
}, "toRules"), getRules = /* @__PURE__ */ __name(function(value, points) {
  return dealloc(toRules(alloc(value), points));
}, "getRules"), fixedElements = /* @__PURE__ */ new WeakMap(), compat = /* @__PURE__ */ __name(function(element) {
  if (!(element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1)) {
    for (var value = element.value, parent = element.parent, isImplicitRule = element.column === parent.column && element.line === parent.line; parent.type !== "rule"; )
      if (parent = parent.parent, !parent)
        return;
    if (!(element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) && !isImplicitRule) {
      fixedElements.set(element, !0);
      for (var points = [], rules = getRules(value, points), parentRules = parent.props, i = 0, k2 = 0; i < rules.length; i++)
        for (var j2 = 0; j2 < parentRules.length; j2++, k2++)
          element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
}, "compat"), removeLabel = /* @__PURE__ */ __name(function(element) {
  if (element.type === "decl") {
    var value = element.value;
    // charcode for l
    value.charCodeAt(0) === 108 && // charcode for b
    value.charCodeAt(2) === 98 && (element.return = "", element.value = "");
  }
}, "removeLabel");
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
__name(prefix, "prefix");
var prefixer = /* @__PURE__ */ __name(function(element, index, children2, callback2) {
  if (element.length > -1 && !element.return)
    switch (element.type) {
      case DECLARATION:
        element.return = prefix(element.value, element.length);
        break;
      case KEYFRAMES:
        return serialize([copy(element, {
          value: replace(element.value, "@", "@" + WEBKIT)
        })], callback2);
      case RULESET:
        if (element.length)
          return combine(element.props, function(value) {
            switch (match(value, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return serialize([copy(element, {
                  props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                })], callback2);
              case "::placeholder":
                return serialize([copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                }), copy(element, {
                  props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                })], callback2);
            }
            return "";
          });
    }
}, "prefixer"), defaultStylisPlugins = [prefixer], createCache = /* @__PURE__ */ __name(function(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      dataEmotionAttribute.indexOf(" ") !== -1 && (document.head.appendChild(node2), node2.setAttribute("data-s", ""));
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins, inserted = {}, container2, nodesToHydrate = [];
  container2 = options2.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
    function(node2) {
      for (var attrib = node2.getAttribute("data-emotion").split(" "), i = 1; i < attrib.length; i++)
        inserted[attrib[i]] = !0;
      nodesToHydrate.push(node2);
    }
  );
  var _insert, omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet, finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })], serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins)), stylis = /* @__PURE__ */ __name(function(styles2) {
      return serialize(compile(styles2), serializer);
    }, "stylis");
    _insert = /* @__PURE__ */ __name(function(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet, stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles), shouldCache && (cache.inserted[serialized.name] = !0);
    }, "insert");
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  return cache.sheet.hydrate(nodesToHydrate), cache;
}, "createCache"), reactIs$1 = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = typeof Symbol == "function" && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$2 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$3 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if (typeof a2 == "object" && a2 !== null) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$2:
          case e$2:
          case g$1:
          case f$1:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n:
              case t:
              case r$1:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
__name(z$1, "z$1");
function A$2(a2) {
  return z$1(a2) === m$2;
}
__name(A$2, "A$2");
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$2;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$2;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$2;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$2(a2) || z$1(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$2;
};
reactIs_production_min.isElement = function(a2) {
  return typeof a2 == "object" && a2 !== null && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$2;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return typeof a2 == "string" || typeof a2 == "function" || a2 === e$2 || a2 === m$2 || a2 === g$1 || a2 === f$1 || a2 === p$2 || a2 === q$1 || typeof a2 == "object" && a2 !== null && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n || a2.$$typeof === w$3 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
reactIs$1.exports = reactIs_production_min;
var reactIsExports = reactIs$1.exports, reactIs = reactIsExports, FORWARD_REF_STATICS = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, MEMO_STATICS = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = !0;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  return classNames2.split(" ").forEach(function(className) {
    registered[className] !== void 0 ? registeredStyles.push(registered[className] + ";") : rawClassName += className + " ";
  }), rawClassName;
}
__name(getRegisteredStyles, "getRegisteredStyles");
var registerStyles = /* @__PURE__ */ __name(function(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (isStringTag === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  isBrowser === !1) && cache.registered[className] === void 0 && (cache.registered[className] = serialized.styles);
}, "registerStyles"), insertStyles = /* @__PURE__ */ __name(function(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, !0), current = current.next;
    while (current !== void 0);
  }
}, "insertStyles");
function murmur2(str) {
  for (var h2 = 0, k2, i = 0, len = str.length; len >= 4; ++i, len -= 4)
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24, k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16), k2 ^= /* k >>> r: */
    k2 >>> 24, h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255, h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  return h2 ^= h2 >>> 13, h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16), ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
__name(murmur2, "murmur2");
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, hyphenateRegex = /[A-Z]|^ms/g, animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g, isCustomProperty = /* @__PURE__ */ __name(function(property) {
  return property.charCodeAt(1) === 45;
}, "isCustomProperty"), isProcessableValue = /* @__PURE__ */ __name(function(value) {
  return value != null && typeof value != "boolean";
}, "isProcessableValue"), processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
}), processStyleValue = /* @__PURE__ */ __name(function(key, value) {
  switch (key) {
    case "animation":
    case "animationName":
      if (typeof value == "string")
        return value.replace(animationRegex, function(match2, p1, p2) {
          return cursor = {
            name: p1,
            styles: p2,
            next: cursor
          }, p1;
        });
  }
  return unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value == "number" && value !== 0 ? value + "px" : value;
}, "processStyleValue");
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null)
    return "";
  if (interpolation.__emotion_styles !== void 0)
    return interpolation;
  switch (typeof interpolation) {
    case "boolean":
      return "";
    case "object": {
      if (interpolation.anim === 1)
        return cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        }, interpolation.name;
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0)
          for (; next2 !== void 0; )
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            }, next2 = next2.next;
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor, result = interpolation(mergedProps);
        return cursor = previousCursor, handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null)
    return interpolation;
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
__name(handleInterpolation, "handleInterpolation");
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj))
    for (var i = 0; i < obj.length; i++)
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
  else
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value != "object")
        registered != null && registered[value] !== void 0 ? string2 += _key + "{" + registered[value] + "}" : isProcessableValue(value) && (string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";");
      else if (Array.isArray(value) && typeof value[0] == "string" && (registered == null || registered[value[0]] === void 0))
        for (var _i2 = 0; _i2 < value.length; _i2++)
          isProcessableValue(value[_i2]) && (string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i2]) + ";");
      else {
        var interpolated = handleInterpolation(mergedProps, registered, value);
        switch (_key) {
          case "animation":
          case "animationName": {
            string2 += processStyleName(_key) + ":" + interpolated + ";";
            break;
          }
          default:
            string2 += _key + "{" + interpolated + "}";
        }
      }
    }
  return string2;
}
__name(createStringFromObject, "createStringFromObject");
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor, serializeStyles = /* @__PURE__ */ __name(function(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] == "object" && args[0] !== null && args[0].styles !== void 0)
    return args[0];
  var stringMode = !0, styles2 = "";
  cursor = void 0;
  var strings = args[0];
  strings == null || strings.raw === void 0 ? (stringMode = !1, styles2 += handleInterpolation(mergedProps, registered, strings)) : styles2 += strings[0];
  for (var i = 1; i < args.length; i++)
    styles2 += handleInterpolation(mergedProps, registered, args[i]), stringMode && (styles2 += strings[i]);
  labelPattern.lastIndex = 0;
  for (var identifierName = "", match2; (match2 = labelPattern.exec(styles2)) !== null; )
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
}, "serializeStyles"), syncFallback = /* @__PURE__ */ __name(function(create) {
  return create();
}, "syncFallback"), useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : !1, useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback, hasOwnProperty = {}.hasOwnProperty, EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = /* @__PURE__ */ __name(function(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
}, "withEmotionCache"), ThemeContext = /* @__PURE__ */ reactExports.createContext({}), typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", createEmotionProps = /* @__PURE__ */ __name(function(type2, props) {
  var newProps = {};
  for (var key in props)
    hasOwnProperty.call(props, key) && (newProps[key] = props[key]);
  return newProps[typePropName] = type2, newProps;
}, "createEmotionProps"), Insertion = /* @__PURE__ */ __name(function(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  return registerStyles(cache, serialized, isStringTag), useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  }), null;
}, "Insertion"), Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  typeof cssProp == "string" && cache.registered[cssProp] !== void 0 && (cssProp = cache.registered[cssProp]);
  var WrappedComponent = props[typePropName], registeredStyles = [cssProp], className = "";
  typeof props.className == "string" ? className = getRegisteredStyles(cache.registered, registeredStyles, props.className) : props.className != null && (className = props.className + " ");
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props)
    hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && (newProps[key] = props[key]);
  return newProps.ref = ref, newProps.className = className, /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent == "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
}), Emotion$1 = Emotion, jsx = /* @__PURE__ */ __name(function(type2, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css"))
    return reactExports.createElement.apply(void 0, args);
  var argsLength = args.length, createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1, createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++)
    createElementArgArray[i] = args[i];
  return reactExports.createElement.apply(null, createElementArgArray);
}, "jsx");
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
    args[_key] = arguments[_key];
  return serializeStyles(args);
}
__name(css$2, "css$2");
var keyframes = /* @__PURE__ */ __name(function() {
  var insertable = css$2.apply(void 0, arguments), name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: /* @__PURE__ */ __name(function() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }, "toString")
  };
}, "keyframes");
function _taggedTemplateLiteral(strings, raw) {
  return raw || (raw = strings.slice(0)), Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
__name(_taggedTemplateLiteral, "_taggedTemplateLiteral");
const min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = /* @__PURE__ */ __name((v2) => ({
  x: v2,
  y: v2
}), "createCoords");
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
__name(rectToClientRect, "rectToClientRect");
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
__name(getNodeName, "getNodeName");
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
__name(getWindow, "getWindow");
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
__name(getDocumentElement, "getDocumentElement");
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
__name(isNode, "isNode");
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
__name(isElement, "isElement");
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
__name(isHTMLElement, "isHTMLElement");
function isShadowRoot(value) {
  return typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
__name(isShadowRoot, "isShadowRoot");
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
__name(isOverflowElement, "isOverflowElement");
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
__name(isWebKit, "isWebKit");
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
__name(isLastTraversableNode, "isLastTraversableNode");
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
__name(getComputedStyle$1, "getComputedStyle$1");
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
__name(getParentNode, "getParentNode");
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
__name(getNearestOverflowAncestor, "getNearestOverflowAncestor");
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  list2 === void 0 && (list2 = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  return isBody ? list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []) : list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
__name(getOverflowAncestors, "getOverflowAncestors");
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0, height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
__name(getCssDimensions, "getCssDimensions");
function unwrapElement(element) {
  return isElement(element) ? element : element.contextElement;
}
__name(unwrapElement, "unwrapElement");
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement))
    return createCoords(1);
  const rect = domElement.getBoundingClientRect(), {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width, y2 = ($2 ? round(rect.height) : rect.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
__name(getScale, "getScale");
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  return !isWebKit() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
__name(getVisualOffsets, "getVisualOffsets");
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
__name(shouldAddVisualOffsets, "shouldAddVisualOffsets");
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale = createCoords(1);
  includeScale && (offsetParent ? isElement(offsetParent) && (scale = getScale(offsetParent)) : scale = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x, y2 = (clientRect.top + visualOffsets.y) / scale.y, width = clientRect.width / scale.x, height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    for (; currentIFrame && offsetParent && offsetWin !== win; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css4 = getComputedStyle$1(currentIFrame), left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x, top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left2, y2 += top, currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
__name(getBoundingClientRect, "getBoundingClientRect");
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId), io && io.disconnect(), io = null;
  }
  __name(cleanup, "cleanup");
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top), insetRight = floor(root2.clientWidth - (left2 + width)), insetBottom = floor(root2.clientHeight - (top + height)), insetLeft = floor(left2), options2 = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio ? refresh(!1, ratio) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 100);
      }
      isFirstUpdate = !1;
    }
    __name(handleObserve, "handleObserve");
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  return __name(refresh, "refresh"), refresh(!0), cleanup;
}
__name(observeMove, "observeMove");
function autoUpdate(reference, floating, update, options2) {
  options2 === void 0 && (options2 = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options2, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref3) => {
    let [firstEntry] = _ref3;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      resizeObserver && resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return __name(frameLoop, "frameLoop"), update(), () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo && cleanupIo(), resizeObserver && resizeObserver.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
__name(autoUpdate, "autoUpdate");
var index$1 = reactExports.useLayoutEffect, _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"], noop = /* @__PURE__ */ __name(function() {
}, "noop");
function applyPrefixToName(prefix2, name) {
  return name ? name[0] === "-" ? prefix2 + name : prefix2 + "__" + name : prefix2;
}
__name(applyPrefixToName, "applyPrefixToName");
function classNames(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++)
    classNameList[_key - 2] = arguments[_key];
  var arr = [].concat(classNameList);
  if (state && prefix2)
    for (var key in state)
      state.hasOwnProperty(key) && state[key] && arr.push("".concat(applyPrefixToName(prefix2, key)));
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
__name(classNames, "classNames");
var cleanValue = /* @__PURE__ */ __name(function(value) {
  return isArray$1(value) ? value.filter(Boolean) : _typeof(value) === "object" && value !== null ? [value] : [];
}, "cleanValue"), cleanCommonProps = /* @__PURE__ */ __name(function(props) {
  props.className, props.clearValue, props.cx, props.getStyles, props.getClassNames, props.getValue, props.hasValue, props.isMulti, props.isRtl, props.options, props.selectOption, props.selectProps, props.setValue, props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
}, "cleanCommonProps"), getStyleProps = /* @__PURE__ */ __name(function(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState ?? {}, getClassNames(name, props), className)
  };
}, "getStyleProps");
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
__name(isDocumentElement, "isDocumentElement");
function normalizedHeight(el2) {
  return isDocumentElement(el2) ? window.innerHeight : el2.clientHeight;
}
__name(normalizedHeight, "normalizedHeight");
function getScrollTop(el2) {
  return isDocumentElement(el2) ? window.pageYOffset : el2.scrollTop;
}
__name(getScrollTop, "getScrollTop");
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
__name(scrollTo, "scrollTo");
function getScrollParent(element) {
  var style2 = getComputedStyle(element), excludeStaticParent = style2.position === "absolute", overflowRx = /(auto|scroll)/;
  if (style2.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; )
    if (style2 = getComputedStyle(parent), !(excludeStaticParent && style2.position === "static") && overflowRx.test(style2.overflow + style2.overflowY + style2.overflowX))
      return parent;
  return document.documentElement;
}
__name(getScrollParent, "getScrollParent");
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
__name(easeOutCubic, "easeOutCubic");
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200, callback2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop, start = getScrollTop(element), change = to - start, increment = 10, currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val), currentTime < duration ? window.requestAnimationFrame(animateScroll) : callback2(element);
  }
  __name(animateScroll, "animateScroll"), animateScroll();
}
__name(animatedScrollTo, "animatedScrollTo");
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect(), focusedRect = focusedEl.getBoundingClientRect(), overScroll = focusedEl.offsetHeight / 3;
  focusedRect.bottom + overScroll > menuRect.bottom ? scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight)) : focusedRect.top - overScroll < menuRect.top && scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
}
__name(scrollIntoView, "scrollIntoView");
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
__name(getBoundingClientObj, "getBoundingClientObj");
function isTouchCapable() {
  try {
    return document.createEvent("TouchEvent"), !0;
  } catch {
    return !1;
  }
}
__name(isTouchCapable, "isTouchCapable");
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch {
    return !1;
  }
}
__name(isMobileDevice, "isMobileDevice");
var passiveOptionAccessed = !1, options = {
  get passive() {
    return passiveOptionAccessed = !0;
  }
}, w$2 = typeof window < "u" ? window : {};
w$2.addEventListener && w$2.removeEventListener && (w$2.addEventListener("p", noop, options), w$2.removeEventListener("p", noop, !1));
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item2) {
  return item2 != null;
}
__name(notNullish, "notNullish");
function isArray$1(arg) {
  return Array.isArray(arg);
}
__name(isArray$1, "isArray$1");
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
__name(valueTernary, "valueTernary");
var removeProps = /* @__PURE__ */ __name(function(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
    properties[_key2 - 1] = arguments[_key2];
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key = _ref22[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    return newProps[key] = val, newProps;
  }, {});
}, "removeProps"), _excluded$3 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight, scrollParent = getScrollParent(menuEl), defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height, _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top, _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top, viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent), scrollTop = getScrollTop(scrollParent), marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10), marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10), viewSpaceAbove = containerTop - marginTop, viewSpaceBelow = viewHeight - menuTop, scrollSpaceAbove = viewSpaceAbove + scrollTop, scrollSpaceBelow = scrollHeight - scrollTop - menuTop, scrollDown = menuBottom - viewHeight + scrollTop + marginBottom, scrollUp = scrollTop + menuTop - marginTop, scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight)
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition)
        return shouldScroll && animatedScrollTo(scrollParent, scrollDown, scrollDuration), {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        shouldScroll && animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight, spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        return spaceAbove >= minHeight && (_constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight)), {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom")
        return shouldScroll && scrollTo(scrollParent, scrollDown), {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight)
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition)
        return shouldScroll && animatedScrollTo(scrollParent, scrollUp, scrollDuration), {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        return (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) && (_constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop), shouldScroll && animatedScrollTo(scrollParent, scrollUp, scrollDuration), {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
__name(getMenuPlacement, "getMenuPlacement");
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
__name(alignToControl, "alignToControl");
var coercePlacement = /* @__PURE__ */ __name(function(p2) {
  return p2 === "auto" ? "bottom" : p2;
}, "coercePlacement"), menuCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _objectSpread2$1, placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "width", "100%"), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
}, "menuCSS"), PortalPlacementContext = /* @__PURE__ */ reactExports.createContext(null), MenuPlacer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme, _ref3 = reactExports.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement, ref = reactExports.useRef(null), _useState = reactExports.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1], _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1], controlHeight2 = theme.spacing.controlHeight;
  return index$1(function() {
    var menuEl = ref.current;
    if (menuEl) {
      var isFixedPosition = menuPosition === "fixed", shouldScroll = menuShouldScrollIntoView && !isFixedPosition, state = getMenuPlacement({
        maxHeight: maxMenuHeight,
        menuEl,
        minHeight: minMenuHeight,
        placement: menuPlacement,
        shouldScroll,
        isFixedPosition,
        controlHeight: controlHeight2
      });
      setMaxHeight(state.maxHeight), setPlacement(state.placement), setPortalPlacement == null || setPortalPlacement(state.placement);
    }
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]), children2({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
}, "MenuPlacer"), Menu = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: !0
  }), {
    ref: innerRef
  }, innerProps), children2);
}, "Menu"), Menu$1 = Menu, menuListCSS = /* @__PURE__ */ __name(function(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
}, "menuListCSS"), MenuList = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": !0,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children2);
}, "MenuList"), noticeCSS = /* @__PURE__ */ __name(function(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
}, "noticeCSS"), noOptionsMessageCSS = noticeCSS, loadingMessageCSS = noticeCSS, NoOptionsMessage = /* @__PURE__ */ __name(function(_ref6) {
  var _ref6$children = _ref6.children, children2 = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": !0,
    "menu-notice--no-options": !0
  }), innerProps), children2);
}, "NoOptionsMessage"), LoadingMessage = /* @__PURE__ */ __name(function(_ref7) {
  var _ref7$children = _ref7.children, children2 = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "loadingMessage", {
    "menu-notice": !0,
    "menu-notice--loading": !0
  }), innerProps), children2);
}, "LoadingMessage"), menuPortalCSS = /* @__PURE__ */ __name(function(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
}, "menuPortalCSS"), MenuPortal = /* @__PURE__ */ __name(function(props) {
  var appendTo = props.appendTo, children2 = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuPortalRef = reactExports.useRef(null), cleanupRef = reactExports.useRef(null), _useState5 = reactExports.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1], portalPlacementContext = reactExports.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []), _useState7 = reactExports.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1], updateComputedPosition = reactExports.useCallback(function() {
    if (controlElement) {
      var rect = getBoundingClientObj(controlElement), scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset, offset = rect[placement] + scrollDistance;
      (offset !== (computedPosition == null ? void 0 : computedPosition.offset) || rect.left !== (computedPosition == null ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition == null ? void 0 : computedPosition.rect.width)) && setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition == null ? void 0 : computedPosition.offset, computedPosition == null ? void 0 : computedPosition.rect.left, computedPosition == null ? void 0 : computedPosition.rect.width]);
  index$1(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = reactExports.useCallback(function() {
    typeof cleanupRef.current == "function" && (cleanupRef.current(), cleanupRef.current = null), controlElement && menuPortalRef.current && (cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
      elementResize: "ResizeObserver" in window
    }));
  }, [controlElement, updateComputedPosition]);
  index$1(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = reactExports.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement, runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": !0
  }), innerProps), children2);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
}, "MenuPortal"), containerCSS = /* @__PURE__ */ __name(function(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
}, "containerCSS"), SelectContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children2);
}, "SelectContainer"), valueContainerCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
}, "valueContainerCSS"), ValueContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": !0,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children2);
}, "ValueContainer"), indicatorsContainerCSS = /* @__PURE__ */ __name(function() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
}, "indicatorsContainerCSS"), IndicatorsContainer = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: !0
  }), innerProps), children2);
}, "IndicatorsContainer"), _templateObject, _excluded$2 = ["size"], _excluded2 = ["innerProps", "isRtl", "size"], _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
}, Svg = /* @__PURE__ */ __name(function(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
}, "Svg"), CrossIcon = /* @__PURE__ */ __name(function(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
}, "CrossIcon"), DownChevron = /* @__PURE__ */ __name(function(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
}, "DownChevron"), baseCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
}, "baseCSS"), dropdownIndicatorCSS = baseCSS, DropdownIndicator$3 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: !0,
    "dropdown-indicator": !0
  }), innerProps), children2 || jsx(DownChevron, null));
}, "DropdownIndicator"), clearIndicatorCSS = baseCSS, ClearIndicator = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: !0,
    "clear-indicator": !0
  }), innerProps), children2 || jsx(CrossIcon, null));
}, "ClearIndicator"), indicatorSeparatorCSS = /* @__PURE__ */ __name(function(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
}, "indicatorSeparatorCSS"), IndicatorSeparator = /* @__PURE__ */ __name(function(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": !0
  })));
}, "IndicatorSeparator"), loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral([`
  0%, 80%, 100% { opacity: 0; }
  40% { opacity: 1; }
`]))), loadingIndicatorCSS = /* @__PURE__ */ __name(function(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
}, "loadingIndicatorCSS"), LoadingDot = /* @__PURE__ */ __name(function(_ref6) {
  var delay2 = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
}, "LoadingDot"), LoadingIndicator = /* @__PURE__ */ __name(function(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: !0,
    "loading-indicator": !0
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: !0
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
}, "LoadingIndicator"), css$1 = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
}, "css"), Control = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: !0,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children2);
}, "Control"), Control$1 = Control, _excluded$1 = ["data"], groupCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
}, "groupCSS"), Group = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label2 = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: !0
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label2), jsx("div", null, children2));
}, "Group"), groupHeadingCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
}, "groupHeadingCSS"), GroupHeading = /* @__PURE__ */ __name(function(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": !0
  }), innerProps));
}, "GroupHeading"), Group$1 = Group, _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"], inputCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
}, "inputCSS"), spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
}, containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
}, inputStyle = /* @__PURE__ */ __name(function(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
}, "inputStyle"), Input2 = /* @__PURE__ */ __name(function(props) {
  var cx = props.cx, value = props.value, _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": !0
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: !0
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
}, "Input"), Input$1 = Input2, multiValueCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
}, "multiValueCSS"), multiValueLabelCSS = /* @__PURE__ */ __name(function(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
}, "multiValueLabelCSS"), multiValueRemoveCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
}, "multiValueRemoveCSS"), MultiValueGeneric = /* @__PURE__ */ __name(function(_ref4) {
  var children2 = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children2);
}, "MultiValueGeneric"), MultiValueContainer = MultiValueGeneric, MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children2 = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children2 || jsx(CrossIcon, {
    size: 14
  }));
}
__name(MultiValueRemove, "MultiValueRemove");
var MultiValue = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps, Container = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": !0,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": !0
    })),
    selectProps
  }, children2), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": !0
    })), {}, {
      "aria-label": "Remove ".concat(children2 || "option")
    }, removeProps3),
    selectProps
  }));
}, "MultiValue"), MultiValue$1 = MultiValue, optionCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: isDisabled ? void 0 : isSelected ? colors2.primary : colors2.primary50
    }
  });
}, "optionCSS"), Option$1 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: !0,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children2);
}, "Option"), Option$1$1 = Option$1, placeholderCSS = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
}, "placeholderCSS"), Placeholder = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: !0
  }), innerProps), children2);
}, "Placeholder"), Placeholder$1 = Placeholder, css2 = /* @__PURE__ */ __name(function(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
}, "css"), SingleValue$1 = /* @__PURE__ */ __name(function(props) {
  var children2 = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": !0,
    "single-value--is-disabled": isDisabled
  }), innerProps), children2);
}, "SingleValue"), SingleValue$1$1 = SingleValue$1, components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator: DropdownIndicator$3,
  DownChevron,
  CrossIcon,
  Group: Group$1,
  GroupHeading,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1$1,
  ValueContainer
}, defaultComponents = /* @__PURE__ */ __name(function(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
}, "defaultComponents"), safeIsNaN = Number.isNaN || /* @__PURE__ */ __name(function(value) {
  return typeof value == "number" && value !== value;
}, "ponyfill");
function isEqual(first2, second) {
  return !!(first2 === second || safeIsNaN(first2) && safeIsNaN(second));
}
__name(isEqual, "isEqual");
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length)
    return !1;
  for (var i = 0; i < newInputs.length; i++)
    if (!isEqual(newInputs[i], lastInputs[i]))
      return !1;
  return !0;
}
__name(areInputsEqual, "areInputsEqual");
function memoizeOne(resultFn, isEqual2) {
  isEqual2 === void 0 && (isEqual2 = areInputsEqual);
  var cache = null;
  function memoized() {
    for (var newArgs = [], _i2 = 0; _i2 < arguments.length; _i2++)
      newArgs[_i2] = arguments[_i2];
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs))
      return cache.lastResult;
    var lastResult = resultFn.apply(this, newArgs);
    return cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    }, lastResult;
  }
  return __name(memoized, "memoized"), memoized.clear = /* @__PURE__ */ __name(function() {
    cache = null;
  }, "clear"), memoized;
}
__name(memoizeOne, "memoizeOne");
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
}, A11yText = /* @__PURE__ */ __name(function(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
}, "A11yText"), A11yText$1 = A11yText, defaultAriaLiveMessages = {
  guidance: /* @__PURE__ */ __name(function(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  }, "guidance"),
  onChange: /* @__PURE__ */ __name(function(props) {
    var action2 = props.action, _props$label = props.label, label2 = _props$label === void 0 ? "" : _props$label, labels2 = props.labels, isDisabled = props.isDisabled;
    switch (action2) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label2, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels2.length > 1 ? "s" : "", " ").concat(labels2.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label2, " is disabled. Select another option.") : "option ".concat(label2, ", selected.");
      default:
        return "";
    }
  }, "onChange"),
  onFocus: /* @__PURE__ */ __name(function(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label2 = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected, getArrayIndex = /* @__PURE__ */ __name(function(arr, item2) {
      return arr && arr.length ? "".concat(arr.indexOf(item2) + 1, " of ").concat(arr.length) : "";
    }, "getArrayIndex");
    if (context === "value" && selectValue)
      return "value ".concat(label2, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    if (context === "menu") {
      var disabled2 = isDisabled ? " disabled" : "", status2 = "".concat(isSelected ? "selected" : "focused").concat(disabled2);
      return "option ".concat(label2, " ").concat(status2, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  }, "onFocus"),
  onFilter: /* @__PURE__ */ __name(function(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }, "onFilter")
}, LiveRegion = /* @__PURE__ */ __name(function(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id, ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue, ariaLabel = selectProps["aria-label"], ariaLive = selectProps["aria-live"], messages = reactExports.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]), ariaSelected = reactExports.useMemo(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value, asOption = /* @__PURE__ */ __name(function(val) {
        return Array.isArray(val) ? null : val;
      }, "asOption"), selected2 = removedValue || option || asOption(value), label2 = selected2 ? getOptionLabel4(selected2) : "", multiSelected = selectedOptions || removedValues || void 0, labels2 = multiSelected ? multiSelected.map(getOptionLabel4) : [], onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected2 && isOptionDisabled3(selected2, selectValue),
        label: label2,
        labels: labels2
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]), ariaFocused = reactExports.useMemo(function() {
    var focusMsg = "", focused = focusedOption || focusedValue, isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]), ariaResults = reactExports.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]), ariaGuidance = reactExports.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]), ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance), ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext)), isInitialFocus = (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
}, "LiveRegion"), LiveRegion$1 = LiveRegion, diacritics = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}], anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g"), diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++)
  for (var diacritic = diacritics[i], j$1 = 0; j$1 < diacritic.letters.length; j$1++)
    diacriticToBase[diacritic.letters[j$1]] = diacritic.base;
var stripDiacritics = /* @__PURE__ */ __name(function(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
}, "stripDiacritics"), memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics), trimString = /* @__PURE__ */ __name(function(str) {
  return str.replace(/^\s+|\s+$/g, "");
}, "trimString"), defaultStringify = /* @__PURE__ */ __name(function(option) {
  return "".concat(option.label, " ").concat(option.value);
}, "defaultStringify"), createFilter = /* @__PURE__ */ __name(function(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return !0;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: !0,
      ignoreAccents: !0,
      stringify: defaultStringify,
      trim: !0,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom, input2 = trim2 ? trimString(rawInput) : rawInput, candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    return ignoreCase && (input2 = input2.toLowerCase(), candidate = candidate.toLowerCase()), ignoreAccents && (input2 = memoizedStripDiacriticsForInput(input2), candidate = stripDiacritics(candidate)), matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
}, "createFilter"), _excluded = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded), filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$2({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
__name(DummyInput, "DummyInput");
var cancelScroll = /* @__PURE__ */ __name(function(event2) {
  event2.preventDefault(), event2.stopPropagation();
}, "cancelScroll");
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave, isBottom = reactExports.useRef(!1), isTop = reactExports.useRef(!1), touchStart = reactExports.useRef(0), scrollTarget = reactExports.useRef(null), handleEventDelta = reactExports.useCallback(function(event2, delta) {
    if (scrollTarget.current !== null) {
      var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight, target = scrollTarget.current, isDeltaPositive = delta > 0, availableScroll = scrollHeight - clientHeight - scrollTop, shouldCancelScroll = !1;
      availableScroll > delta && isBottom.current && (onBottomLeave && onBottomLeave(event2), isBottom.current = !1), isDeltaPositive && isTop.current && (onTopLeave && onTopLeave(event2), isTop.current = !1), isDeltaPositive && delta > availableScroll ? (onBottomArrive && !isBottom.current && onBottomArrive(event2), target.scrollTop = scrollHeight, shouldCancelScroll = !0, isBottom.current = !0) : !isDeltaPositive && -delta > scrollTop && (onTopArrive && !isTop.current && onTopArrive(event2), target.scrollTop = 0, shouldCancelScroll = !0, isTop.current = !0), shouldCancelScroll && cancelScroll(event2);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]), onWheel = reactExports.useCallback(function(event2) {
    handleEventDelta(event2, event2.deltaY);
  }, [handleEventDelta]), onTouchStart = reactExports.useCallback(function(event2) {
    touchStart.current = event2.changedTouches[0].clientY;
  }, []), onTouchMove = reactExports.useCallback(function(event2) {
    var deltaY = touchStart.current - event2.changedTouches[0].clientY;
    handleEventDelta(event2, deltaY);
  }, [handleEventDelta]), startListening = reactExports.useCallback(function(el2) {
    if (el2) {
      var notPassive = supportsPassiveEvents ? {
        passive: !1
      } : !1;
      el2.addEventListener("wheel", onWheel, notPassive), el2.addEventListener("touchstart", onTouchStart, notPassive), el2.addEventListener("touchmove", onTouchMove, notPassive);
    }
  }, [onTouchMove, onTouchStart, onWheel]), stopListening = reactExports.useCallback(function(el2) {
    el2 && (el2.removeEventListener("wheel", onWheel, !1), el2.removeEventListener("touchstart", onTouchStart, !1), el2.removeEventListener("touchmove", onTouchMove, !1));
  }, [onTouchMove, onTouchStart, onWheel]);
  return reactExports.useEffect(function() {
    if (isEnabled) {
      var element = scrollTarget.current;
      return startListening(element), function() {
        stopListening(element);
      };
    }
  }, [isEnabled, startListening, stopListening]), function(element) {
    scrollTarget.current = element;
  };
}
__name(useScrollCapture, "useScrollCapture");
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"], LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e2) {
  e2.preventDefault();
}
__name(preventTouchMove, "preventTouchMove");
function allowTouchMove(e2) {
  e2.stopPropagation();
}
__name(allowTouchMove, "allowTouchMove");
function preventInertiaScroll() {
  var top = this.scrollTop, totalScroll = this.scrollHeight, currentScroll = top + this.offsetHeight;
  top === 0 ? this.scrollTop = 1 : currentScroll === totalScroll && (this.scrollTop = top - 1);
}
__name(preventInertiaScroll, "preventInertiaScroll");
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
__name(isTouchDevice, "isTouchDevice");
var canUseDOM = !!(typeof window < "u" && window.document && window.document.createElement), activeScrollLocks = 0, listenerOptions = {
  capture: !1,
  passive: !1
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? !0 : _ref$accountForScroll, originalStyles = reactExports.useRef({}), scrollTarget = reactExports.useRef(null), addScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (canUseDOM) {
      var target = document.body, targetStyle = target && target.style;
      if (accountForScrollbars && STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      }), accountForScrollbars && activeScrollLocks < 1) {
        var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0, clientWidth = document.body ? document.body.clientWidth : 0, adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
        Object.keys(LOCK_STYLES).forEach(function(key) {
          var val = LOCK_STYLES[key];
          targetStyle && (targetStyle[key] = val);
        }), targetStyle && (targetStyle.paddingRight = "".concat(adjustedPadding, "px"));
      }
      target && isTouchDevice() && (target.addEventListener("touchmove", preventTouchMove, listenerOptions), touchScrollTarget && (touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions), touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions))), activeScrollLocks += 1;
    }
  }, [accountForScrollbars]), removeScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (canUseDOM) {
      var target = document.body, targetStyle = target && target.style;
      activeScrollLocks = Math.max(activeScrollLocks - 1, 0), accountForScrollbars && activeScrollLocks < 1 && STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        targetStyle && (targetStyle[key] = val);
      }), target && isTouchDevice() && (target.removeEventListener("touchmove", preventTouchMove, listenerOptions), touchScrollTarget && (touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions), touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions)));
    }
  }, [accountForScrollbars]);
  return reactExports.useEffect(function() {
    if (isEnabled) {
      var element = scrollTarget.current;
      return addScrollLock(element), function() {
        removeScrollLock(element);
      };
    }
  }, [isEnabled, addScrollLock, removeScrollLock]), function(element) {
    scrollTarget.current = element;
  };
}
__name(useScrollLock, "useScrollLock");
var blurSelectInput = /* @__PURE__ */ __name(function() {
  return document.activeElement && document.activeElement.blur();
}, "blurSelectInput"), _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function ScrollManager(_ref3) {
  var children2 = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? !0 : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave, setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  }), setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  }), targetRef = /* @__PURE__ */ __name(function(element) {
    setScrollCaptureTarget(element), setScrollLockTarget(element);
  }, "targetRef");
  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children2(targetRef));
}
__name(ScrollManager, "ScrollManager");
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
}, RequiredInput = /* @__PURE__ */ __name(function(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: !0,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref2,
    value: "",
    onChange: /* @__PURE__ */ __name(function() {
    }, "onChange")
  });
}, "RequiredInput"), RequiredInput$1 = RequiredInput, formatGroupLabel = /* @__PURE__ */ __name(function(group) {
  return group.label;
}, "formatGroupLabel"), getOptionLabel$1 = /* @__PURE__ */ __name(function(option) {
  return option.label;
}, "getOptionLabel"), getOptionValue$1 = /* @__PURE__ */ __name(function(option) {
  return option.value;
}, "getOptionValue"), isOptionDisabled = /* @__PURE__ */ __name(function(option) {
  return !!option.isDisabled;
}, "isOptionDisabled"), defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
}, colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
}, borderRadius = 4, baseUnit = 4, controlHeight = 38, menuGutter = baseUnit * 2, spacing = {
  baseUnit,
  controlHeight,
  menuGutter
}, defaultTheme = {
  borderRadius,
  colors,
  spacing
}, defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: !0,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: !0,
  closeMenuOnScroll: !1,
  components: {},
  controlShouldRenderValue: !0,
  escapeClearsValue: !1,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: !1,
  isLoading: !1,
  isMulti: !1,
  isRtl: !1,
  isSearchable: !0,
  isOptionDisabled,
  loadingMessage: /* @__PURE__ */ __name(function() {
    return "Loading...";
  }, "loadingMessage"),
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: !1,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: !1,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: /* @__PURE__ */ __name(function() {
    return "No options";
  }, "noOptionsMessage"),
  openMenuOnFocus: !1,
  openMenuOnClick: !0,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: /* @__PURE__ */ __name(function(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  }, "screenReaderStatus"),
  styles: {},
  tabIndex: 0,
  tabSelectsValue: !0,
  unstyled: !1
};
function toCategorizedOption(props, option, selectValue, index) {
  var isDisabled = _isOptionDisabled(props, option, selectValue), isSelected = _isOptionSelected(props, option, selectValue), label2 = getOptionLabel2(props, option), value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label: label2,
    value,
    index
  };
}
__name(toCategorizedOption, "toCategorizedOption");
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
__name(buildCategorizedOptions, "buildCategorizedOptions");
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    return categorizedOption.type === "group" ? optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
      return option.data;
    }))) : optionsAccumulator.push(categorizedOption.data), optionsAccumulator;
  }, []);
}
__name(buildFocusableOptionsFromCategorizedOptions, "buildFocusableOptionsFromCategorizedOptions");
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
__name(buildFocusableOptions, "buildFocusableOptions");
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue, data = categorizedOption.data, isSelected = categorizedOption.isSelected, label2 = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label2,
    value,
    data
  }, inputValue);
}
__name(isFocusable, "isFocusable");
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue, lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1)
      return focusedValue;
    if (lastFocusedIndex < nextSelectValue.length)
      return nextSelectValue[lastFocusedIndex];
  }
  return null;
}
__name(getNextFocusedValue, "getNextFocusedValue");
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
__name(getNextFocusedOption, "getNextFocusedOption");
var getOptionLabel2 = /* @__PURE__ */ __name(function(props, data) {
  return props.getOptionLabel(data);
}, "getOptionLabel"), getOptionValue2 = /* @__PURE__ */ __name(function(props, data) {
  return props.getOptionValue(data);
}, "getOptionValue");
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled == "function" ? props.isOptionDisabled(option, selectValue) : !1;
}
__name(_isOptionDisabled, "_isOptionDisabled");
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return !0;
  if (typeof props.isOptionSelected == "function")
    return props.isOptionSelected(option, selectValue);
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
__name(_isOptionSelected, "_isOptionSelected");
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : !0;
}
__name(_filterOption, "_filterOption");
var shouldHideSelectedOptions = /* @__PURE__ */ __name(function(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  return hideSelectedOptions === void 0 ? isMulti : hideSelectedOptions;
}, "shouldHideSelectedOptions"), instanceId = 1, Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    if (_classCallCheck(this, Select2), _this = _super.call(this, _props), _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: !1,
      isFocused: !1,
      selectValue: [],
      clearFocusValueOnUpdate: !1,
      prevWasFocused: !1,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    }, _this.blockOptionHover = !1, _this.isComposing = !1, _this.commonProps = void 0, _this.initialTouchX = 0, _this.initialTouchY = 0, _this.instancePrefix = "", _this.openAfterFocus = !1, _this.scrollToFocusedOptionOnUpdate = !1, _this.userIsDragging = void 0, _this.controlRef = null, _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    }, _this.focusedOptionRef = null, _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    }, _this.menuListRef = null, _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    }, _this.inputRef = null, _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    }, _this.focus = _this.focusInput, _this.blur = _this.blurInput, _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name, _this.ariaOnChange(newValue, actionMeta), onChange2(newValue, actionMeta);
    }, _this.setValue = function(newValue, action2, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      }), closeMenuOnSelect && (_this.setState({
        inputIsHiddenAfterUpdate: !isMulti
      }), _this.onMenuClose()), _this.setState({
        clearFocusValueOnUpdate: !0
      }), _this.onChange(newValue, {
        action: action2,
        option
      });
    }, _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name, selectValue = _this.state.selectValue, deselected = isMulti && _this.isOptionSelected(newValue, selectValue), isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        }), "deselect-option", newValue);
      } else if (!isDisabled)
        isMulti ? _this.setValue([].concat(_toConsumableArray(selectValue), [newValue]), "select-option", newValue) : _this.setValue(newValue, "select-option");
      else {
        _this.ariaOnChange(newValue, {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      blurInputOnSelect && _this.blurInput();
    }, _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti, selectValue = _this.state.selectValue, candidate = _this.getOptionValue(removedValue), newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      }), newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      }), _this.focusInput();
    }, _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    }, _this.popValue = function() {
      var isMulti = _this.props.isMulti, selectValue = _this.state.selectValue, lastSelectedValue = selectValue[selectValue.length - 1], newValueArray = selectValue.slice(0, selectValue.length - 1), newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    }, _this.getValue = function() {
      return _this.state.selectValue;
    }, _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)
        args[_key] = arguments[_key];
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    }, _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    }, _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    }, _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled, base3 = defaultStyles[key](props, unstyled);
      base3.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base3, props) : base3;
    }, _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    }, _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    }, _this.getComponents = function() {
      return defaultComponents(_this.props);
    }, _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    }, _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    }, _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    }, _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    }, _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    }, _this.onMenuMouseDown = function(event2) {
      event2.button === 0 && (event2.stopPropagation(), event2.preventDefault(), _this.focusInput());
    }, _this.onMenuMouseMove = function(event2) {
      _this.blockOptionHover = !1;
    }, _this.onControlMouseDown = function(event2) {
      if (!event2.defaultPrevented) {
        var openMenuOnClick = _this.props.openMenuOnClick;
        _this.state.isFocused ? _this.props.menuIsOpen ? event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA" && _this.onMenuClose() : openMenuOnClick && _this.openMenu("first") : (openMenuOnClick && (_this.openAfterFocus = !0), _this.focusInput()), event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA" && event2.preventDefault();
      }
    }, _this.onDropdownIndicatorMouseDown = function(event2) {
      if (!(event2 && event2.type === "mousedown" && event2.button !== 0) && !_this.props.isDisabled) {
        var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
        _this.focusInput(), menuIsOpen ? (_this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        }), _this.onMenuClose()) : _this.openMenu("first"), event2.preventDefault();
      }
    }, _this.onClearIndicatorMouseDown = function(event2) {
      event2 && event2.type === "mousedown" && event2.button !== 0 || (_this.clearValue(), event2.preventDefault(), _this.openAfterFocus = !1, event2.type === "touchend" ? _this.focusInput() : setTimeout(function() {
        return _this.focusInput();
      }));
    }, _this.onScroll = function(event2) {
      typeof _this.props.closeMenuOnScroll == "boolean" ? event2.target instanceof HTMLElement && isDocumentElement(event2.target) && _this.props.onMenuClose() : typeof _this.props.closeMenuOnScroll == "function" && _this.props.closeMenuOnScroll(event2) && _this.props.onMenuClose();
    }, _this.onCompositionStart = function() {
      _this.isComposing = !0;
    }, _this.onCompositionEnd = function() {
      _this.isComposing = !1;
    }, _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches, touch = touches && touches.item(0);
      touch && (_this.initialTouchX = touch.clientX, _this.initialTouchY = touch.clientY, _this.userIsDragging = !1);
    }, _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches, touch = touches && touches.item(0);
      if (touch) {
        var deltaX = Math.abs(touch.clientX - _this.initialTouchX), deltaY = Math.abs(touch.clientY - _this.initialTouchY), moveThreshold = 5;
        _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
      }
    }, _this.onTouchEnd = function(event2) {
      _this.userIsDragging || (_this.controlRef && !_this.controlRef.contains(event2.target) && _this.menuListRef && !_this.menuListRef.contains(event2.target) && _this.blurInput(), _this.initialTouchX = 0, _this.initialTouchY = 0);
    }, _this.onControlTouchEnd = function(event2) {
      _this.userIsDragging || _this.onControlMouseDown(event2);
    }, _this.onClearIndicatorTouchEnd = function(event2) {
      _this.userIsDragging || _this.onClearIndicatorMouseDown(event2);
    }, _this.onDropdownIndicatorTouchEnd = function(event2) {
      _this.userIsDragging || _this.onDropdownIndicatorMouseDown(event2);
    }, _this.handleInputChange = function(event2) {
      var prevInputValue = _this.props.inputValue, inputValue = event2.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: !1
      }), _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      }), _this.props.menuIsOpen || _this.onMenuOpen();
    }, _this.onInputFocus = function(event2) {
      _this.props.onFocus && _this.props.onFocus(event2), _this.setState({
        inputIsHiddenAfterUpdate: !1,
        isFocused: !0
      }), (_this.openAfterFocus || _this.props.openMenuOnFocus) && _this.openMenu("first"), _this.openAfterFocus = !1;
    }, _this.onInputBlur = function(event2) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      _this.props.onBlur && _this.props.onBlur(event2), _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      }), _this.onMenuClose(), _this.setState({
        focusedValue: null,
        isFocused: !1
      });
    }, _this.onOptionHover = function(focusedOption) {
      _this.blockOptionHover || _this.state.focusedOption === focusedOption || _this.setState({
        focusedOption
      });
    }, _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    }, _this.onValueInputFocus = function(e2) {
      e2.preventDefault(), e2.stopPropagation(), _this.focus();
    }, _this.onKeyDown = function(event2) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus, _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (!isDisabled && !(typeof onKeyDown == "function" && (onKeyDown(event2), event2.defaultPrevented))) {
        switch (_this.blockOptionHover = !0, event2.key) {
          case "ArrowLeft":
            if (!isMulti || inputValue)
              return;
            _this.focusValue("previous");
            break;
          case "ArrowRight":
            if (!isMulti || inputValue)
              return;
            _this.focusValue("next");
            break;
          case "Delete":
          case "Backspace":
            if (inputValue)
              return;
            if (focusedValue)
              _this.removeValue(focusedValue);
            else {
              if (!backspaceRemovesValue)
                return;
              isMulti ? _this.popValue() : isClearable && _this.clearValue();
            }
            break;
          case "Tab":
            if (_this.isComposing || event2.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
            // option is already selected; it breaks the flow of navigation
            openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue))
              return;
            _this.selectOption(focusedOption);
            break;
          case "Enter":
            if (event2.keyCode === 229)
              break;
            if (menuIsOpen) {
              if (!focusedOption || _this.isComposing)
                return;
              _this.selectOption(focusedOption);
              break;
            }
            return;
          case "Escape":
            menuIsOpen ? (_this.setState({
              inputIsHiddenAfterUpdate: !1
            }), _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            }), _this.onMenuClose()) : isClearable && escapeClearsValue && _this.clearValue();
            break;
          case " ":
            if (inputValue)
              return;
            if (!menuIsOpen) {
              _this.openMenu("first");
              break;
            }
            if (!focusedOption)
              return;
            _this.selectOption(focusedOption);
            break;
          case "ArrowUp":
            menuIsOpen ? _this.focusOption("up") : _this.openMenu("last");
            break;
          case "ArrowDown":
            menuIsOpen ? _this.focusOption("down") : _this.openMenu("first");
            break;
          case "PageUp":
            if (!menuIsOpen)
              return;
            _this.focusOption("pageup");
            break;
          case "PageDown":
            if (!menuIsOpen)
              return;
            _this.focusOption("pagedown");
            break;
          case "Home":
            if (!menuIsOpen)
              return;
            _this.focusOption("first");
            break;
          case "End":
            if (!menuIsOpen)
              return;
            _this.focusOption("last");
            break;
          default:
            return;
        }
        event2.preventDefault();
      }
    }, _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId), _this.state.selectValue = cleanValue(_props.value), _props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions(), optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  return __name(Select2, "Select"), _createClass(Select2, [{
    key: "componentDidMount",
    value: /* @__PURE__ */ __name(function() {
      this.startListeningComposition(), this.startListeningToTouch(), this.props.closeMenuOnScroll && document && document.addEventListener && document.addEventListener("scroll", this.onScroll, !0), this.props.autoFocus && this.focusInput(), this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef && scrollIntoView(this.menuListRef, this.focusedOptionRef);
    }, "componentDidMount")
  }, {
    key: "componentDidUpdate",
    value: /* @__PURE__ */ __name(function(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen, isFocused = this.state.isFocused;
      // ensure focus is restored correctly when the control becomes enabled
      (isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
      isFocused && menuIsOpen && !prevProps.menuIsOpen) && this.focusInput(), isFocused && isDisabled && !prevProps.isDisabled ? this.setState({
        isFocused: !1
      }, this.onMenuClose) : !isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement && this.setState({
        isFocused: !0
      }), this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate && (scrollIntoView(this.menuListRef, this.focusedOptionRef), this.scrollToFocusedOptionOnUpdate = !1);
    }, "componentDidUpdate")
  }, {
    key: "componentWillUnmount",
    value: /* @__PURE__ */ __name(function() {
      this.stopListeningComposition(), this.stopListeningToTouch(), document.removeEventListener("scroll", this.onScroll, !0);
    }, "componentWillUnmount")
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: /* @__PURE__ */ __name(function() {
      this.props.onMenuOpen();
    }, "onMenuOpen")
  }, {
    key: "onMenuClose",
    value: /* @__PURE__ */ __name(function() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      }), this.props.onMenuClose();
    }, "onMenuClose")
  }, {
    key: "onInputChange",
    value: /* @__PURE__ */ __name(function(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }, "onInputChange")
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: /* @__PURE__ */ __name(function() {
      this.inputRef && this.inputRef.focus();
    }, "focusInput")
  }, {
    key: "blurInput",
    value: /* @__PURE__ */ __name(function() {
      this.inputRef && this.inputRef.blur();
    }, "blurInput")
    // aliased for consumers
  }, {
    key: "openMenu",
    value: /* @__PURE__ */ __name(function(focusOption) {
      var _this2 = this, _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused, focusableOptions = this.buildFocusableOptions(), openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        selectedIndex > -1 && (openAtIndex = selectedIndex);
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef), this.setState({
        inputIsHiddenAfterUpdate: !1,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }, "openMenu")
  }, {
    key: "focusValue",
    value: /* @__PURE__ */ __name(function(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (this.props.isMulti) {
        this.setState({
          focusedOption: null
        });
        var focusedIndex = selectValue.indexOf(focusedValue);
        focusedValue || (focusedIndex = -1);
        var lastIndex = selectValue.length - 1, nextFocus = -1;
        if (selectValue.length) {
          switch (direction) {
            case "previous":
              focusedIndex === 0 ? nextFocus = 0 : focusedIndex === -1 ? nextFocus = lastIndex : nextFocus = focusedIndex - 1;
              break;
            case "next":
              focusedIndex > -1 && focusedIndex < lastIndex && (nextFocus = focusedIndex + 1);
              break;
          }
          this.setState({
            inputIsHidden: nextFocus !== -1,
            focusedValue: selectValue[nextFocus]
          });
        }
      }
    }, "focusValue")
  }, {
    key: "focusOption",
    value: /* @__PURE__ */ __name(function() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first", pageSize = this.props.pageSize, focusedOption = this.state.focusedOption, options2 = this.getFocusableOptions();
      if (options2.length) {
        var nextFocus = 0, focusedIndex = options2.indexOf(focusedOption);
        focusedOption || (focusedIndex = -1), direction === "up" ? nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1 : direction === "down" ? nextFocus = (focusedIndex + 1) % options2.length : direction === "pageup" ? (nextFocus = focusedIndex - pageSize, nextFocus < 0 && (nextFocus = 0)) : direction === "pagedown" ? (nextFocus = focusedIndex + pageSize, nextFocus > options2.length - 1 && (nextFocus = options2.length - 1)) : direction === "last" && (nextFocus = options2.length - 1), this.scrollToFocusedOptionOnUpdate = !0, this.setState({
          focusedOption: options2[nextFocus],
          focusedValue: null
        });
      }
    }, "focusOption")
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      /* @__PURE__ */ __name(function() {
        return this.props.theme ? typeof this.props.theme == "function" ? this.props.theme(defaultTheme) : _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme) : defaultTheme;
      }, "getTheme")
    )
  }, {
    key: "getCommonProps",
    value: /* @__PURE__ */ __name(function() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props, isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options, hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }, "getCommonProps")
  }, {
    key: "hasValue",
    value: /* @__PURE__ */ __name(function() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }, "hasValue")
  }, {
    key: "hasOptions",
    value: /* @__PURE__ */ __name(function() {
      return !!this.getFocusableOptions().length;
    }, "hasOptions")
  }, {
    key: "isClearable",
    value: /* @__PURE__ */ __name(function() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      return isClearable2 === void 0 ? isMulti : isClearable2;
    }, "isClearable")
  }, {
    key: "isOptionDisabled",
    value: /* @__PURE__ */ __name(function(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }, "isOptionDisabled")
  }, {
    key: "isOptionSelected",
    value: /* @__PURE__ */ __name(function(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }, "isOptionSelected")
  }, {
    key: "filterOption",
    value: /* @__PURE__ */ __name(function(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }, "filterOption")
  }, {
    key: "formatOptionLabel",
    value: /* @__PURE__ */ __name(function(data, context) {
      if (typeof this.props.formatOptionLabel == "function") {
        var _inputValue = this.props.inputValue, _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else
        return this.getOptionLabel(data);
    }, "formatOptionLabel")
  }, {
    key: "formatGroupLabel",
    value: /* @__PURE__ */ __name(function(data) {
      return this.props.formatGroupLabel(data);
    }, "formatGroupLabel")
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      /* @__PURE__ */ __name(function() {
        document && document.addEventListener && (document.addEventListener("compositionstart", this.onCompositionStart, !1), document.addEventListener("compositionend", this.onCompositionEnd, !1));
      }, "startListeningComposition")
    )
  }, {
    key: "stopListeningComposition",
    value: /* @__PURE__ */ __name(function() {
      document && document.removeEventListener && (document.removeEventListener("compositionstart", this.onCompositionStart), document.removeEventListener("compositionend", this.onCompositionEnd));
    }, "stopListeningComposition")
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      /* @__PURE__ */ __name(function() {
        document && document.addEventListener && (document.addEventListener("touchstart", this.onTouchStart, !1), document.addEventListener("touchmove", this.onTouchMove, !1), document.addEventListener("touchend", this.onTouchEnd, !1));
      }, "startListeningToTouch")
    )
  }, {
    key: "stopListeningToTouch",
    value: /* @__PURE__ */ __name(function() {
      document && document.removeEventListener && (document.removeEventListener("touchstart", this.onTouchStart), document.removeEventListener("touchmove", this.onTouchMove), document.removeEventListener("touchend", this.onTouchEnd));
    }, "stopListeningToTouch")
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      /* @__PURE__ */ __name(function() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required, _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input, _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection, commonProps = this.commonProps, id2 = inputId || this.getElementId("input"), ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": !0,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": !0
        }), this.hasValue() ? (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        return isSearchable ? /* @__PURE__ */ reactExports.createElement(Input4, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes)) : /* @__PURE__ */ reactExports.createElement(DummyInput, _extends({
          id: id2,
          innerRef: this.getInputRef,
          onBlur: this.onInputBlur,
          onChange: noop,
          onFocus: this.onInputFocus,
          disabled: isDisabled,
          tabIndex,
          inputMode: "none",
          form,
          value: ""
        }, ariaAttributes));
      }, "renderInput")
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: /* @__PURE__ */ __name(function() {
      var _this3 = this, _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder, commonProps = this.commonProps, _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder, _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue)
        return inputValue ? null : /* @__PURE__ */ reactExports.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      if (isMulti)
        return selectValue.map(function(opt, index) {
          var isOptionFocused = opt === focusedValue, key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ reactExports.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index,
            removeProps: {
              onClick: /* @__PURE__ */ __name(function() {
                return _this3.removeValue(opt);
              }, "onClick"),
              onTouchEnd: /* @__PURE__ */ __name(function() {
                return _this3.removeValue(opt);
              }, "onTouchEnd"),
              onMouseDown: /* @__PURE__ */ __name(function(e2) {
                e2.preventDefault();
              }, "onMouseDown")
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      if (inputValue)
        return null;
      var singleValue = selectValue[0];
      return /* @__PURE__ */ reactExports.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }, "renderPlaceholderOrValue")
  }, {
    key: "renderClearIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator, commonProps = this.commonProps, _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading, isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading)
        return null;
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }, "renderClearIndicator")
  }, {
    key: "renderLoadingIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator, commonProps = this.commonProps, _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading, isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }, "renderLoadingIndicator")
  }, {
    key: "renderIndicatorSeparator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps, isDisabled = this.props.isDisabled, isFocused = this.state.isFocused;
      return /* @__PURE__ */ reactExports.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }, "renderIndicatorSeparator")
  }, {
    key: "renderDropdownIndicator",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps, isDisabled = this.props.isDisabled, isFocused = this.state.isFocused, innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }, "renderDropdownIndicator")
  }, {
    key: "renderMenu",
    value: /* @__PURE__ */ __name(function() {
      var _this4 = this, _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option, commonProps = this.commonProps, focusedOption = this.state.focusedOption, _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = /* @__PURE__ */ __name(function(props, id2) {
        var type2 = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label2 = props.label, value = props.value, isFocused = focusedOption === data, onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        }, onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        }, optionId = "".concat(_this4.getElementId("option"), "-").concat(id2), innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ reactExports.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label: label2,
          type: type2,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      }, "render"), menuUI;
      if (this.hasOptions())
        menuUI = this.getCategorizedOptions().map(function(item2) {
          if (item2.type === "group") {
            var _data = item2.data, options2 = item2.options, groupIndex = item2.index, groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex), headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ reactExports.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item2.data
              },
              label: _this4.formatGroupLabel(item2.data)
            }), item2.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item2.type === "option")
            return render(item2, "".concat(item2.index));
        });
      else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      }, menuElement = /* @__PURE__ */ reactExports.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ reactExports.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ reactExports.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ reactExports.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: /* @__PURE__ */ __name(function(instance2) {
              _this4.getMenuListRef(instance2), scrollTargetRef(instance2);
            }, "innerRef"),
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ reactExports.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }, "renderMenu")
  }, {
    key: "renderFormField",
    value: /* @__PURE__ */ __name(function() {
      var _this5 = this, _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required, selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled)
        return /* @__PURE__ */ reactExports.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      if (!(!name || isDisabled))
        if (isMulti)
          if (delimiter2) {
            var value = selectValue.map(function(opt) {
              return _this5.getOptionValue(opt);
            }).join(delimiter2);
            return /* @__PURE__ */ reactExports.createElement("input", {
              name,
              type: "hidden",
              value
            });
          } else {
            var input2 = selectValue.length > 0 ? selectValue.map(function(opt, i) {
              return /* @__PURE__ */ reactExports.createElement("input", {
                key: "i-".concat(i),
                name,
                type: "hidden",
                value: _this5.getOptionValue(opt)
              });
            }) : /* @__PURE__ */ reactExports.createElement("input", {
              name,
              type: "hidden",
              value: ""
            });
            return /* @__PURE__ */ reactExports.createElement("div", null, input2);
          }
        else {
          var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
          return /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value: _value
          });
        }
    }, "renderFormField")
  }, {
    key: "renderLiveRegion",
    value: /* @__PURE__ */ __name(function() {
      var commonProps = this.commonProps, _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue, focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ reactExports.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }, "renderLiveRegion")
  }, {
    key: "render",
    value: /* @__PURE__ */ __name(function() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer, _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen, isFocused = this.state.isFocused, commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ reactExports.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ reactExports.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ reactExports.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ reactExports.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }, "render")
  }], [{
    key: "getDerivedStateFromProps",
    value: /* @__PURE__ */ __name(function(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused, options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti, selectValue = cleanValue(value), newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [], focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null, focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: !1
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {}, newAriaSelection = ariaSelection, hasKeptFocus = isFocused && prevWasFocused;
      return isFocused && !hasKeptFocus && (newAriaSelection = {
        value: valueTernary(isMulti, selectValue, selectValue[0] || null),
        options: selectValue,
        action: "initial-input-focus"
      }, hasKeptFocus = !prevWasFocused), (ariaSelection == null ? void 0 : ariaSelection.action) === "initial-input-focus" && (newAriaSelection = null), _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }, "getDerivedStateFromProps")
  }]), Select2;
}(reactExports.Component);
Select.defaultProps = defaultProps;
var StateManagedSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends({
    ref
  }, baseSelectProps));
}), StateManagedSelect$1 = StateManagedSelect;
const balance = "_balance_17xkv_1", balanceSingleValue = "_balanceSingleValue_17xkv_1", dropdown$2 = "_dropdown_17xkv_11", select$4 = "_select_17xkv_20", selectLabelText$1 = "_selectLabelText_17xkv_66", singleValueContainer$1 = "_singleValueContainer_17xkv_70", valueContainer = "_valueContainer_17xkv_78", styles$m = {
  balance,
  balanceSingleValue,
  dropdown: dropdown$2,
  select: select$4,
  selectLabelText: selectLabelText$1,
  singleValueContainer: singleValueContainer$1,
  valueContainer
}, SelectSingleValue$1 = /* @__PURE__ */ __name((props) => {
  const { hideAmounts } = reactExports.useContext(AppContext), { label: label2, coinCode, balance: balance2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$m.singleValueContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.selectLabelText, children: label2 }),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.balanceSingleValue, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) }) });
}, "SelectSingleValue$1"), SelectOption$1 = /* @__PURE__ */ __name((props) => {
  const { hideAmounts } = reactExports.useContext(AppContext), { label: label2, coinCode, balance: balance2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$m.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.selectLabelText, children: label2 }),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$m.balance, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) });
}, "SelectOption$1"), DropdownIndicator$2 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$m.dropdown }) }), "DropdownIndicator$2"), AccountSelector = /* @__PURE__ */ __name(({ title: title2, disabled: disabled2, options: options2, selected: selected2, onChange: onChange2, onProceed }) => {
  const { t: t2 } = useTranslation(), [selectedAccount, setSelectedAccount] = reactExports.useState();
  return reactExports.useEffect(() => {
    setSelectedAccount(options2.find((opt) => opt.value === selected2));
  }, [options2, selected2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title text-center", children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        className: styles$m.select,
        classNamePrefix: "react-select",
        components: { DropdownIndicator: DropdownIndicator$2, SingleValue: SelectSingleValue$1, Option: SelectOption$1, IndicatorSeparator: () => null },
        value: selected2 === "" ? {
          label: t2("buy.info.selectLabel"),
          value: "choose",
          disabled: !0
        } : selectedAccount,
        isSearchable: !1,
        onChange: (e2) => {
          const value = (e2 == null ? void 0 : e2.value) || "";
          onChange2(value);
        },
        isOptionDisabled: (option) => option.disabled,
        options: [
          {
            label: t2("buy.info.selectLabel") || "",
            value: "choose",
            disabled: !0
          },
          ...options2
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onProceed,
        disabled: !selected2 || disabled2,
        children: t2("buy.info.next")
      }
    ) })
  ] });
}, "AccountSelector"), button$2 = "_button_1riw8_1", styles$l = {
  button: button$2
}, HideAmountsButton = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { hideAmounts, toggleHideAmounts } = reactExports.useContext(AppContext), config = useLoad(getConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: config && config.frontend.allowHideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$l.button, onClick: toggleHideAmounts, transparent: !0, children: hideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeClosed, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.showAmounts") })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpened, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.hideAmounts") })
  ] }) }) : null });
}, "HideAmountsButton"), BuyInfo = /* @__PURE__ */ __name(({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code), [options2, setOptions] = reactExports.useState(), [disabled2, setDisabled] = reactExports.useState(!1), { t: t2 } = useTranslation(), checkSupportedCoins = reactExports.useCallback(async () => {
    try {
      const options22 = (await getExchangeSupportedAccounts(accounts)).map(({ name: name2, code: code2, coinCode }) => ({ label: `${name2}`, value: code2, coinCode, disabled: !1 }));
      setOptions(options22), getBalances(options22);
    } catch (e2) {
      console.error(e2);
    }
  }, [accounts]), maybeProceed = reactExports.useCallback(async () => {
    if (options2 !== void 0 && options2.length === 1) {
      const accountCode = options2[0].value;
      if (!(await connectKeystore(accountCode)).success)
        return;
      route(`/buy/exchange/${accountCode}`);
    }
  }, [options2]), handleChangeAccount = /* @__PURE__ */ __name((selected22) => {
    setSelected(selected22);
  }, "handleChangeAccount");
  reactExports.useEffect(() => {
    checkSupportedCoins();
  }, [checkSupportedCoins]), reactExports.useEffect(() => {
    maybeProceed();
  }, [maybeProceed, options2]);
  const getBalances = /* @__PURE__ */ __name((options22) => {
    Promise.all(options22.map((option) => getBalance(option.value).then((balance2) => ({ ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` })))).then((options3) => {
      setOptions(options3);
    });
  }, "getBalances"), handleProceed = /* @__PURE__ */ __name(async () => {
    setDisabled(!0);
    try {
      if (!(await connectKeystore(selected2)).success)
        return;
    } finally {
      setDisabled(!1);
    }
    route(`/buy/exchange/${selected2}`);
  }, "handleProceed");
  if (options2 === void 0)
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") });
  const account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: options2.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: t2("accountSummary.noAccount") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        AccountSelector,
        {
          title: t2("buy.title", { name }),
          disabled: disabled2,
          options: options2,
          selected: selected2,
          onChange: handleChangeAccount,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] }) });
}, "BuyInfo");
const button$1 = "_button_diw5d_1", style$I = {
  button: button$1
}, InfoButton = /* @__PURE__ */ __name(({ onClick, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick, ...props, className: style$I.button, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BuyInfo$1, {}) }), "InfoButton"), container$k = "_container_1ksto_17", paymentMethodContainer = "_paymentMethodContainer_1ksto_17", exchangeName = "_exchangeName_1ksto_21", infoButton = "_infoButton_1ksto_25", outerContainer$1 = "_outerContainer_1ksto_37", paymentMethodsContainer = "_paymentMethodsContainer_1ksto_41", paymentMethodName = "_paymentMethodName_1ksto_47", radio = "_radio_1ksto_67", radioLabel = "_radioLabel_1ksto_123", text$1 = "_text_1ksto_127", style$H = {
  container: container$k,
  paymentMethodContainer,
  exchangeName,
  infoButton,
  outerContainer: outerContainer$1,
  paymentMethodsContainer,
  paymentMethodName,
  radio,
  radioLabel,
  text: text$1
}, PaymentMethod = /* @__PURE__ */ __name(({ methodName }) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode();
  switch (methodName) {
    case "bank-transfer":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$H.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Bank, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BankDark, {}),
        t2("buy.exchange.bankTransfer")
      ] });
    case "card":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$H.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCardDark, {}),
        t2("buy.exchange.creditCard")
      ] });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: methodName });
  }
}, "PaymentMethod"), Deal = /* @__PURE__ */ __name(({ deal }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.paymentMethodContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, { methodName: deal.payment }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      deal.isBestDeal && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "success", children: t2("buy.exchange.bestDeal") }),
      deal.isFast && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "warning", children: t2("buy.exchange.fast") })
    ] })
  ] });
}, "Deal");
function ExchangeSelectionRadio({
  disabled: disabled2 = !1,
  id: id2,
  children: children2,
  checked: checked2,
  deals,
  onChange: onChange2,
  exchangeName: exchangeName2,
  onClickInfoButton,
  ...props
}) {
  const handleClick = /* @__PURE__ */ __name(() => {
    disabled2 || onChange2();
  }, "handleClick"), handleKeyDown = /* @__PURE__ */ __name((e2) => {
    !disabled2 && e2.key === "Enter" && onChange2();
  }, "handleKeyDown");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.outerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "aria-checked": checked2, onKeyDown: handleKeyDown, "aria-disabled": disabled2, role: "radio", tabIndex: 0, onClick: handleClick, className: style$H.radio, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          checked: checked2,
          type: "radio",
          id: id2,
          disabled: disabled2,
          onChange: onChange2,
          ...props
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: style$H.radioLabel, htmlFor: id2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$H.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$H.text, style$H.exchangeName].join(" "), children: getFormattedName(exchangeName2) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$H.paymentMethodsContainer, children: deals.map((deal) => /* @__PURE__ */ jsxRuntimeExports.jsx(Deal, { deal }, deal.payment)) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => onClickInfoButton(exchangeName2) })
  ] });
}
__name(ExchangeSelectionRadio, "ExchangeSelectionRadio");
const container$j = "_container_h94uh_1", style$G = {
  container: container$j
}, MoonPayInfo = /* @__PURE__ */ __name(({ cardFee, bankTransferFee }) => {
  const { t: t2 } = useTranslation(), formattedCardFee = cardFee && cardFee * 100, formattedBankTransferFee = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$G.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-", children: t2("buy.exchange.infoContent.moonpay.fullCurrenciesList") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCard") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCardDetails.cards") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.pix") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: t2("buy.exchange.infoContent.moonpay.payment.asteriskText") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/4406210084113-What-payment-methods-do-you-support-", children: t2("buy.exchange.infoContent.moonpay.payment.learnMore") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.creditDebitCard", { fee: formattedCardFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.bankTransfer", { fee: formattedBankTransferFee }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/", children: t2("buy.exchange.infoContent.moonpay.fees.learnMore") }) })
  ] });
}, "MoonPayInfo"), PocketInfo = /* @__PURE__ */ __name(({ bankTransferFee }) => {
  const { t: t2 } = useTranslation(), fee2 = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$G.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sic") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/how-do-I-set-up-my-standing-order", children: t2("buy.exchange.infoContent.pocket.payment.bankTransferReccuring") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.verification.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.verification.info") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/are-there-any-limits-with-pocket", children: t2("buy.exchange.infoContent.pocket.verification.link") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.fees.info", { fee: fee2 }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/", children: t2("buy.exchange.infoContent.pocket.learnMore") }) })
  ] });
}, "PocketInfo"), RegionInfo = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.region.title") }) });
}, "RegionInfo"), InfoContent = /* @__PURE__ */ __name(({ info: info2, cardFee, bankTransferFee }) => {
  switch (info2) {
    case "moonpay":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MoonPayInfo, { cardFee, bankTransferFee });
    case "pocket":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PocketInfo, { bankTransferFee });
    case "region":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RegionInfo, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
}, "InfoContent"), buttonBack = "_buttonBack_62uya_17", buttonsContainer$1 = "_buttonsContainer_62uya_21", container$i = "_container_62uya_27", exchangeContainer = "_exchangeContainer_62uya_31", header$3 = "_header_62uya_44", selectContainer = "_selectContainer_62uya_49", label$5 = "_label_62uya_62", noExchangeText = "_noExchangeText_62uya_69", radioButtonsContainer = "_radioButtonsContainer_62uya_77", title$4 = "_title_62uya_81", style$F = {
  buttonBack,
  buttonsContainer: buttonsContainer$1,
  container: container$i,
  exchangeContainer,
  header: header$3,
  selectContainer,
  label: label$5,
  noExchangeText,
  radioButtonsContainer,
  title: title$4
}, dropdown$1 = "_dropdown_9chnx_1", flag = "_flag_9chnx_10", globe = "_globe_9chnx_14", optionsContainer = "_optionsContainer_9chnx_20", select$3 = "_select_9chnx_25", selectLabelText = "_selectLabelText_9chnx_59", singleValueContainer = "_singleValueContainer_9chnx_64", styles$k = {
  dropdown: dropdown$1,
  flag,
  globe,
  optionsContainer,
  select: select$3,
  selectLabelText,
  singleValueContainer
}, SelectedRegionIcon = /* @__PURE__ */ __name(({ regionCode }) => {
  const { isDarkMode } = useDarkmode(), globe2 = isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeLight, { className: styles$k.globe }) : /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeDark, { className: styles$k.globe });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: regionCode === "" ? globe2 : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `fi fi-${regionCode} ${styles$k.flag}` }) });
}, "SelectedRegionIcon"), SelectSingleValue = /* @__PURE__ */ __name((props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.singleValueContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }) })
  ] });
}, "SelectSingleValue"), SelectOption = /* @__PURE__ */ __name((props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.optionsContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 })
  ] }) });
}, "SelectOption"), DropdownIndicator$1 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.dropdown }) }), "DropdownIndicator$1"), CountrySelect = /* @__PURE__ */ __name(({ onChangeRegion, regions, selectedRegion }) => {
  const { t: t2 } = useTranslation(), formattedRegionName = new Intl.DisplayNames([instance.language], { type: "region" }).of(selectedRegion) || "", selectedRegionName = selectedRegion === "" ? t2("buy.exchange.selectRegion") : formattedRegionName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: styles$k.select,
      classNamePrefix: "react-select",
      components: { DropdownIndicator: DropdownIndicator$1, SingleValue: SelectSingleValue, Option: SelectOption, IndicatorSeparator: () => null },
      defaultValue: { label: selectedRegionName, value: selectedRegion },
      isSearchable: !0,
      onChange: (e2) => onChangeRegion(e2),
      options: [
        {
          label: t2("buy.exchange.selectRegion") || "",
          value: ""
        },
        ...regions
      ]
    }
  );
}, "CountrySelect"), Exchange = /* @__PURE__ */ __name(({ code, accounts }) => {
  var _a46, _b, _c;
  const { t: t2 } = useTranslation(), [showPocket, setShowPocket] = reactExports.useState(!1), [showMoonpay, setShowMoonpay] = reactExports.useState(!1), [selectedRegion, setSelectedRegion] = reactExports.useState(""), [selectedExchange, setSelectedExchange] = reactExports.useState(""), [regions, setRegions] = reactExports.useState([]), [allExchangeDeals, setAllExchanges] = reactExports.useState(), [info2, setInfo] = reactExports.useState(), [supportedAccounts, setSupportedAccounts] = reactExports.useState([]), regionList = useLoad(getExchangesByRegion(code)), exchangeDeals = useLoad(getExchangeDeals), nativeLocale = useLoad(getNativeLocale), supportedExchanges = useLoad(getExchangeBuySupported(code)), config = useLoad(getConfig), account2 = findAccount(accounts, code), name = getCryptoName(t2("buy.info.crypto"), account2), hasOnlyOneSupportedExchange = allExchangeDeals ? allExchangeDeals.exchanges.filter((exchange) => exchange.supported).length === 1 : !1;
  reactExports.useEffect(() => {
    getExchangeSupportedAccounts(accounts).then(setSupportedAccounts);
  }, [accounts]), reactExports.useEffect(() => {
    if (!regionList || !config)
      return;
    const regionNames = new Intl.DisplayNames([instance.language], { type: "region" }) || "", regions2 = regionList.regions.map((region) => ({ value: region.code, label: regionNames.of(region.code) }));
    if (regions2.sort((a2, b2) => a2.label.localeCompare(b2.label, instance.language)), setRegions(regions2), config.frontend.selectedExchangeRegion === "")
      return;
    if (config.frontend.selectedExchangeRegion) {
      setSelectedRegion(config.frontend.selectedExchangeRegion);
      return;
    }
    const userRegion = getRegionNameFromLocale(nativeLocale || ""), regionAvailable = !!regionList.regions.find((region) => region.code === userRegion);
    setSelectedRegion(regionAvailable ? userRegion : "");
  }, [regionList, config, nativeLocale]), reactExports.useEffect(() => {
    if (!exchangeDeals)
      return;
    const deals = { exchanges: exchangeDeals.exchanges.map((ex) => ({ ...ex, supported: ex.exchangeName === "pocket" ? showPocket : showMoonpay })) }, lowestFee = findLowestFee(deals), exchangesWithBestDeal = findBestDeal(deals, lowestFee);
    setAllExchanges(exchangesWithBestDeal);
  }, [selectedRegion, showMoonpay, showPocket, exchangeDeals]), reactExports.useEffect(() => {
    if (hasOnlyOneSupportedExchange && allExchangeDeals && selectedRegion !== "") {
      const exchange = allExchangeDeals.exchanges.filter((exchange2) => exchange2.supported);
      setSelectedExchange(exchange[0].exchangeName);
    }
  }, [hasOnlyOneSupportedExchange, allExchangeDeals, selectedRegion]), reactExports.useEffect(() => {
    if (setSelectedExchange(""), !supportedExchanges) {
      setShowPocket(!1), setShowMoonpay(!1);
      return;
    }
    if (selectedRegion === "") {
      setShowPocket(supportedExchanges.exchanges.includes("pocket")), setShowMoonpay(supportedExchanges.exchanges.includes("moonpay"));
      return;
    }
    regionList && (setShowPocket(!1), setShowMoonpay(!1), regionList.regions.forEach((region) => {
      if (region.code === selectedRegion) {
        setShowPocket(region.isPocketEnabled), setShowMoonpay(region.isMoonpayEnabled);
        return;
      }
    }));
  }, [selectedRegion, regionList, supportedExchanges]);
  const goToExchange = /* @__PURE__ */ __name(() => {
    selectedExchange && route(`/buy/${selectedExchange}/${code}`);
  }, "goToExchange"), handleChangeRegion = /* @__PURE__ */ __name((newValue) => {
    if (newValue) {
      const selectedRegion2 = newValue.value;
      setSelectedRegion(selectedRegion2), setConfig({ frontend: { selectedExchangeRegion: selectedRegion2 } });
    }
  }, "handleChangeRegion"), noExchangeAvailable = !showMoonpay && !showPocket, infoFeesDetail = (_a46 = exchangeDeals == null ? void 0 : exchangeDeals.exchanges.find((exchange) => exchange.exchangeName === info2)) == null ? void 0 : _a46.deals, cardFee = infoFeesDetail && ((_b = infoFeesDetail.find((feeDetail) => feeDetail.payment === "card")) == null ? void 0 : _b.fee), bankTransferFee = infoFeesDetail && ((_c = infoFeesDetail.find((feeDetail) => feeDetail.payment === "bank-transfer")) == null ? void 0 : _c.fee);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { medium: !0, title: info2 && info2 !== "region" ? getFormattedName(info2) : t2("buy.exchange.region"), onClose: () => setInfo(void 0), open: !!info2, children: info2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoContent, { info: info2, cardFee, bankTransferFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.exchange.title", { name }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$F.exchangeContainer, "content", "narrow", "isVerticallyCentered"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$F.title, children: t2("buy.title", { name }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$F.label, children: t2("buy.exchange.region") }),
          regions.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.selectContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CountrySelect,
                {
                  onChangeRegion: handleChangeRegion,
                  regions,
                  selectedRegion
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => setInfo("region") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.radioButtonsContainer, children: [
              noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$F.noExchangeText, children: t2("buy.exchange.noExchanges") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !noExchangeAvailable && allExchangeDeals && allExchangeDeals.exchanges.map((exchange) => exchange.supported && /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExchangeSelectionRadio,
                {
                  id: exchange.exchangeName,
                  exchangeName: exchange.exchangeName,
                  deals: exchange.deals,
                  checked: selectedExchange === exchange.exchangeName,
                  onChange: () => setSelectedExchange(exchange.exchangeName),
                  onClickInfoButton: setInfo
                },
                exchange.exchangeName
              )) }),
              !noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.buttonsContainer, children: [
                supportedAccounts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: style$F.buttonBack,
                    secondary: !0,
                    onClick: () => route("/buy/info"),
                    children: t2("button.back")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    primary: !0,
                    disabled: !selectedExchange,
                    onClick: goToExchange,
                    children: t2("button.next")
                  }
                )
              ] })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0 })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] });
}, "Exchange");
var dist = {}, utils$1 = {};
Object.defineProperty(utils$1, "__esModule", { value: !0 });
utils$1.isOneOf = utils$1.isLiteral = utils$1.isNullish = utils$1.isBoolean = utils$1.isString = utils$1.isObject = void 0;
function isObject(value) {
  return Object(value) === value;
}
__name(isObject, "isObject");
utils$1.isObject = isObject;
function isString(value) {
  return typeof value == "string";
}
__name(isString, "isString");
utils$1.isString = isString;
function isBoolean(value) {
  return typeof value == "boolean";
}
__name(isBoolean, "isBoolean");
utils$1.isBoolean = isBoolean;
function isNullish(value) {
  return value == null;
}
__name(isNullish, "isNullish");
utils$1.isNullish = isNullish;
function isLiteral(value, literal) {
  return value === literal;
}
__name(isLiteral, "isLiteral");
utils$1.isLiteral = isLiteral;
function isOneOf(value, ...literal) {
  return literal.some((l2) => l2 === value);
}
__name(isOneOf, "isOneOf");
utils$1.isOneOf = isOneOf;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.parseMessage = exports.serializeMessage = exports.V0MessageScriptType = exports.V0MessageType = exports.MessageVersion = void 0;
  const utils_1 = utils$1;
  var MessageVersion;
  (function(MessageVersion2) {
    MessageVersion2.V0 = "0";
  })(MessageVersion = exports.MessageVersion || (exports.MessageVersion = {}));
  var V0MessageType;
  (function(V0MessageType2) {
    V0MessageType2.RequestAddress = "requestAddress", V0MessageType2.RequestExtendedPublicKey = "requestExtendedPublicKey", V0MessageType2.VerifyAddress = "verifyAddress", V0MessageType2.Address = "address", V0MessageType2.ExtendedPublicKey = "extendedPublicKey";
  })(V0MessageType = exports.V0MessageType || (exports.V0MessageType = {}));
  var V0MessageScriptType;
  (function(V0MessageScriptType2) {
    V0MessageScriptType2.P2PKH = "p2pkh", V0MessageScriptType2.P2WPKH = "p2wpkh", V0MessageScriptType2.P2SH = "p2sh", V0MessageScriptType2.P2TR = "p2tr";
  })(V0MessageScriptType = exports.V0MessageScriptType || (exports.V0MessageScriptType = {}));
  function serializeMessage(message2) {
    return JSON.stringify(message2);
  }
  __name(serializeMessage, "serializeMessage"), exports.serializeMessage = serializeMessage;
  function parseMessage(value) {
    let object = value;
    if (typeof object == "string")
      try {
        object = JSON.parse(object);
      } catch {
        throw new Error("could not parse as json");
      }
    if (!(0, utils_1.isObject)(object))
      throw new Error("not an object");
    const { version } = object;
    if ((0, utils_1.isLiteral)(version, MessageVersion.V0)) {
      const { type: type2 } = object;
      if (!(0, utils_1.isOneOf)(type2, ...Object.values(V0MessageType)))
        throw new Error("invalid type");
      if (type2 === V0MessageType.RequestAddress) {
        const { withMessageSignature } = object;
        if (!(0, utils_1.isString)(withMessageSignature) && !(0, utils_1.isNullish)(withMessageSignature))
          throw new Error("message signature indicator invalid");
        const { withExtendedPublicKey } = object;
        if (!(0, utils_1.isBoolean)(withExtendedPublicKey) && !(0, utils_1.isNullish)(withExtendedPublicKey))
          throw new Error("extended public key indicator invalid");
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType))
          throw new Error("script type indicator invalid");
        return {
          version,
          type: type2,
          withMessageSignature,
          withExtendedPublicKey,
          withScriptType
        };
      } else if (type2 === V0MessageType.RequestExtendedPublicKey) {
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType))
          throw new Error("script type indicator invalid");
        return {
          version,
          type: type2,
          withScriptType
        };
      } else if (type2 === V0MessageType.VerifyAddress) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress))
          throw new Error("bitcoin address missing");
        return {
          version,
          type: type2,
          bitcoinAddress
        };
      } else if (type2 === V0MessageType.Address) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress))
          throw new Error("bitcoin address missing");
        const { signature } = object;
        if (!(0, utils_1.isString)(signature) && !(0, utils_1.isNullish)(signature))
          throw new Error("signature invalid");
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey) && !(0, utils_1.isNullish)(extendedPublicKey))
          throw new Error("extended public key invalid");
        return {
          version,
          type: type2,
          bitcoinAddress,
          signature,
          extendedPublicKey
        };
      } else if (type2 === V0MessageType.ExtendedPublicKey) {
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey))
          throw new Error("extended public key missing");
        return {
          version,
          type: type2,
          extendedPublicKey
        };
      } else
        throw new Error("unsupported type");
    }
    throw new Error("unsupported version");
  }
  __name(parseMessage, "parseMessage"), exports.parseMessage = parseMessage;
})(dist);
const overlay = "_overlay_12k4v_1", activeOverlay = "_activeOverlay_12k4v_16", modal = "_modal_12k4v_20", activeModal = "_activeModal_12k4v_32", active$2 = "_active_12k4v_16", small = "_small_12k4v_38", medium = "_medium_12k4v_43", large = "_large_12k4v_49", header$2 = "_header_12k4v_54", centered = "_centered_12k4v_64", title$3 = "_title_12k4v_68", closeButton = "_closeButton_12k4v_74", contentContainer$1 = "_contentContainer_12k4v_95", slim = "_slim_12k4v_101", padded = "_padded_12k4v_105", content$1 = "_content_12k4v_95", actions = "_actions_12k4v_113", confirmationLabel = "_confirmationLabel_12k4v_131", confirmationLabelNumber = "_confirmationLabelNumber_12k4v_140", disabledLabel = "_disabledLabel_12k4v_146", noStep = "_noStep_12k4v_151", confirmationInstructions = "_confirmationInstructions_12k4v_155", confirm = "_confirm_12k4v_131", image = "_image_12k4v_175", modalContent = "_modalContent_12k4v_180", detail$1 = "_detail_12k4v_189", description = "_description_12k4v_213", buttons$2 = "_buttons_12k4v_217", dialogButtons = "_dialogButtons_12k4v_229", style$E = {
  overlay,
  activeOverlay,
  modal,
  activeModal,
  active: active$2,
  small,
  medium,
  large,
  header: header$2,
  centered,
  title: title$3,
  closeButton,
  contentContainer: contentContainer$1,
  slim,
  padded,
  content: content$1,
  actions,
  confirmationLabel,
  confirmationLabelNumber,
  disabledLabel,
  noStep,
  confirmationInstructions,
  confirm,
  image,
  modalContent,
  detail: detail$1,
  description,
  buttons: buttons$2,
  dialogButtons
}, _DialogLegacy = class _DialogLegacy extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.modalContent = reactExports.createRef(), this.state = {
      active: !1,
      currentTab: 0
    }, this.handleFocus = (e2) => {
      const index = e2.target.getAttribute("index");
      this.setState({ currentTab: Number(index) });
    }, this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables)
          c2.classList.add("tabbable"), c2.setAttribute("index", focusables.indexOf(c2).toString()), c2.addEventListener("focus", this.handleFocus);
        document.addEventListener("keydown", this.handleKeyDown);
      }
    }, this.focusFirst = () => {
      const focusables = this.focusableChildren;
      focusables.length && focusables[0].getAttribute("autofocus") !== "false" && focusables[0].focus();
    }, this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    }, this.handleKeyDown = (e2) => {
      const { disableEscape } = this.props, isEsc = e2.keyCode === 27, isTab = e2.keyCode === 9;
      !disableEscape && isEsc ? this.deactivate() : isTab && e2.preventDefault(), isTab && e2.shiftKey ? this.updateIndex(!1) : isTab && this.updateIndex(!0);
    }, this.deactivate = () => {
      !this.modal.current || !this.overlay.current || (this.modal.current.classList.remove(style$E.activeModal), this.overlay.current.classList.remove(style$E.activeOverlay), this.setState({ active: !1, currentTab: 0 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown), this.props.onClose && this.props.onClose();
      }));
    }, this.activate = () => {
      this.setState({ active: !0 }, () => {
        !this.modal.current || !this.overlay.current || (this.overlay.current.classList.add(style$E.activeOverlay), this.modal.current.classList.add(style$E.activeModal), this.focusWithin(), this.focusFirst());
      });
    };
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state, focusables = Array.from(this.focusableChildren), arr = isNext ? focusables : focusables.reverse(), current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    return next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled")), next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2, isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props, isSmall = small2 ? style$E.small : "", isMedium = medium2 ? style$E.medium : "", isLarge = large2 ? style$E.large : "", isSlim = slim2 ? style$E.slim : "", isCentered = centered2 && !onClose ? style$E.centered : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$E.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$E.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$E.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$E.closeButton, onClick: this.deactivate, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$E.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
};
__name(_DialogLegacy, "DialogLegacy");
let DialogLegacy = _DialogLegacy;
function DialogButtons({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.dialogButtons, children: children2 });
}
__name(DialogButtons, "DialogButtons");
let confirmation;
const Confirm = /* @__PURE__ */ __name(() => {
  const [state, setState] = reactExports.useState({ active: !1 }), { t: t2 } = useTranslation(), callback2 = reactExports.useRef(() => {
  });
  confirmation = /* @__PURE__ */ __name((message22, cb2, customButtonText2) => {
    callback2.current = cb2, setState({
      active: !0,
      message: message22,
      customButtonText: customButtonText2
    });
  }, "confirmation");
  const respond = /* @__PURE__ */ __name((response) => {
    callback2.current(response), setState({
      active: !1
    });
  }, "respond"), { message: message2, active: active2, customButtonText } = state;
  return active2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("dialog.confirmTitle"), onClose: () => respond(!1), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: message2 ? message2.split(`
`).map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: i === 0 ? "first" : "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: line2 })
      },
      i
    )) : null }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: () => respond(!0), children: customButtonText || t2("dialog.confirm") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => respond(!1), children: t2("dialog.cancel") })
    ] })
  ] }) : null;
}, "Confirm"), PocketTerms = /* @__PURE__ */ __name(({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation(), handleSkipDisclaimer = /* @__PURE__ */ __name((e2) => {
    setConfig({ frontend: { skipPocketDisclaimer: e2.target.checked } });
  }, "handleSkipDisclaimer");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.welcome.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.security.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.pocket.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.kyc.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.kyc.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq", children: t2("buy.pocket.kyc.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$K.title, children: t2("buy.pocket.data.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.data.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/policy/privacy", children: t2("buy.pocket.data.link") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
}, "PocketTerms"), Pocket = /* @__PURE__ */ __name(({ code }) => {
  const { t: t2 } = useTranslation(), [height, setHeight] = reactExports.useState(0), [iframeLoaded, setIframeLoaded] = reactExports.useState(!1), [agreedTerms, setAgreedTerms] = reactExports.useState(!1), [verifying, setVerifying] = reactExports.useState(!1), iframeURL = useLoad(getPocketURL), config = useLoad(getConfig), accountInfo2 = useLoad(getInfo(code)), ref = reactExports.createRef(), iframeRef = reactExports.createRef();
  let signing = !1, resizeTimerID;
  const name = "Bitcoin";
  reactExports.useEffect(() => {
    config && setAgreedTerms(config.frontend.skipPocketDisclaimer);
  }, [config]), reactExports.useEffect(() => (onResize(), window.addEventListener("resize", onResize), window.addEventListener("message", onMessage), () => {
    window.removeEventListener("resize", onResize), window.removeEventListener("message", onMessage);
  }));
  const onResize = /* @__PURE__ */ __name(() => {
    resizeTimerID && clearTimeout(resizeTimerID), resizeTimerID = setTimeout(() => {
      ref.current && setHeight(ref.current.offsetHeight);
    }, 200);
  }, "onResize"), sendAddress = /* @__PURE__ */ __name((address2, sig) => {
    var _a46;
    const { current } = iframeRef;
    if (!current)
      return;
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      signature: sig
    });
    (_a46 = current.contentWindow) == null || _a46.postMessage(message2, "*");
  }, "sendAddress"), handleRequestAddress = /* @__PURE__ */ __name((message2) => {
    signing = !0;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "", withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = !1, response.success ? sendAddress(response.address, response.signature) : response.errorCode !== "userAbort" && (alertUser(t2("unknownError", { errorMessage: response.errorMessage })), console.log("error: " + response.errorMessage));
    });
  }, "handleRequestAddress"), handleVerifyAddress = /* @__PURE__ */ __name((address2) => {
    setVerifying(!0), verifyAddress(address2, code).then((response) => {
      setVerifying(!1), response.success || (response.errorCode === "addressNotFound" ? alertUser(t2("buy.pocket.usedAddress", { address: address2 })) : (alertUser(t2("unknownError", { errorMessage: response.errorMessage })), console.log("error: " + response.errorMessage)));
    });
  }, "handleVerifyAddress"), sendXpub = /* @__PURE__ */ __name(() => {
    var _a46;
    if (accountInfo2) {
      const bitcoinSimple = accountInfo2.signingConfigurations[0].bitcoinSimple;
      if (bitcoinSimple) {
        const xpub = bitcoinSimple.keyInfo.xpub, { current } = iframeRef;
        if (!current)
          return;
        const message2 = dist.serializeMessage({
          version: dist.MessageVersion.V0,
          type: dist.V0MessageType.ExtendedPublicKey,
          extendedPublicKey: xpub
        });
        (_a46 = current.contentWindow) == null || _a46.postMessage(message2, "*");
      }
    }
  }, "sendXpub"), handleRequestXpub = /* @__PURE__ */ __name(() => {
    getTransactionList(code).then((txs) => {
      if (!txs.success) {
        alertUser(t2("transactions.errorLoadTransactions"));
        return;
      }
      txs.list.length > 0 ? confirmation(t2("buy.pocket.previousTransactions"), (result) => {
        result && sendXpub();
      }) : sendXpub();
    });
  }, "handleRequestXpub"), onMessage = /* @__PURE__ */ __name((m2) => {
    if (!(!iframeURL || !code) && m2.origin === new URL(iframeURL).origin)
      try {
        const message2 = dist.parseMessage(m2.data);
        switch (message2.type) {
          case dist.V0MessageType.RequestAddress:
            signing || handleRequestAddress(message2);
            break;
          case dist.V0MessageType.VerifyAddress:
            verifying || handleVerifyAddress(message2.bitcoinAddress);
            break;
          case dist.V0MessageType.RequestExtendedPublicKey:
            handleRequestXpub();
        }
      } catch (e2) {
        console.log(e2);
      }
  }, "onMessage");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$J.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: style$J.container, children: [
        agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
          !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "iframe",
            {
              onLoad: () => {
                setIframeLoaded(!0);
              },
              ref: iframeRef,
              title: "Pocket",
              width: "100%",
              height,
              frameBorder: "0",
              className: style$J.iframe,
              allow: "camera; payment",
              src: iframeURL
            }
          )
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          PocketTerms,
          {
            onAgreedTerms: () => setAgreedTerms(!0)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: verifying,
            title: t2("receive.verifyBitBox02"),
            disableEscape: !0,
            medium: !0,
            centered: !0,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: t2("buy.pocket.verifyBitBox02") })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "pocket" })
  ] });
}, "Pocket"), useEsc = /* @__PURE__ */ __name((callback2) => {
  reactExports.useEffect(() => {
    const handleKeyDown = /* @__PURE__ */ __name((e2) => {
      e2.key === "Escape" && callback2();
    }, "handleKeyDown");
    return document.addEventListener("keydown", handleKeyDown), () => document.removeEventListener("keydown", handleKeyDown);
  }, [callback2]);
}, "useEsc"), button = "_button_1djzh_1", success$3 = "_success_1djzh_34", container$h = "_container_1djzh_38", inputField = "_inputField_1djzh_42", flexibleHeight = "_flexibleHeight_1djzh_72", alignLeft = "_alignLeft_1djzh_76", alignRight = "_alignRight_1djzh_80", borderLess = "_borderLess_1djzh_84", style$D = {
  button,
  success: success$3,
  container: container$h,
  inputField,
  flexibleHeight,
  alignLeft,
  alignRight,
  borderLess
}, CopyableInput = /* @__PURE__ */ __name(({ alignLeft: alignLeft2, alignRight: alignRight2, borderLess: borderLess2, value, className, disabled: disabled2, flexibleHeight: flexibleHeight2 }) => {
  const [success2, setSuccess] = reactExports.useState(!1), { t: t2 } = useTranslation(), textAreaRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setHeight();
  }, []), reactExports.useEffect(() => {
    success2 && setTimeout(() => setSuccess(!1), 1500);
  }, [success2]);
  const setHeight = /* @__PURE__ */ __name(() => {
    const textarea2 = textAreaRef.current;
    if (!textarea2)
      return;
    const fontSize = window.getComputedStyle(textarea2, null).getPropertyValue("font-size"), units = Number(fontSize.replace("px", "")) + 2;
    textarea2.setAttribute("rows", "1"), textarea2.setAttribute("rows", String(Math.round(textarea2.scrollHeight / units - 2)));
  }, "setHeight"), onFocus2 = /* @__PURE__ */ __name((e2) => {
    e2.currentTarget.focus();
  }, "onFocus"), copy2 = /* @__PURE__ */ __name(() => {
    var _a46;
    (_a46 = textAreaRef.current) == null || _a46.select(), document.execCommand("copy") && setSuccess(!0);
  }, "copy");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    "flex flex-row flex-start flex-items-start",
    style$D.container,
    className || ""
  ].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        disabled: disabled2,
        readOnly: !0,
        onFocus: onFocus2,
        value,
        ref: textAreaRef,
        rows: 1,
        className: [
          style$D.inputField,
          flexibleHeight2 && style$D.flexibleHeight,
          alignLeft2 && style$D.alignLeft,
          alignRight2 && style$D.alignRight,
          borderLess2 && style$D.borderLess
        ].join(" ")
      }
    ),
    disabled2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: copy2,
        className: [style$D.button, success2 && style$D.success, "ignore"].join(" "),
        title: t2("button.copy"),
        children: success2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, {})
      }
    )
  ] });
}, "CopyableInput"), empty$1 = "_empty_gzy3c_1", style$C = {
  empty: empty$1
}, QRCode = /* @__PURE__ */ __name(({
  data,
  size: size2 = 256
}) => {
  const qrCode2 = useLoad(data !== void 0 ? getQRCode(data) : null, [data]);
  return qrCode2 ? qrCode2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { width: size2, height: size2, src: qrCode2.data }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: qrCode2.message }) : data !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$C.empty }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: style$C.empty, style: { verticalAlign: "middle", fill: "currentColor", overflow: "hidden" }, viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M433.282171 47.939849 94.944396 47.939849c-23.327288 0-42.304502 18.975167-42.304502 42.300408l0 338.341868c0 23.324218 18.977213 42.300408 42.304502 42.300408L433.282171 470.882534c23.324218 0 42.300408-18.97619 42.300408-42.300408L475.582579 90.240257C475.581556 66.915016 456.606389 47.939849 433.282171 47.939849zM438.742533 428.582125c0 3.01159-2.449795 5.461385-5.461385 5.461385L94.944396 434.04351c-3.013637 0-5.465478-2.450818-5.465478-5.461385L89.478917 90.240257c0-3.01159 2.451842-5.461385 5.465478-5.461385L433.282171 84.778872c3.01159 0 5.461385 2.449795 5.461385 5.461385L438.743556 428.582125zM322.914504 173.887352l-117.608581 0c-14.733563 0-26.719548 11.985986-26.719548 26.719548l0 117.608581c0 14.735609 11.985986 26.724665 26.719548 26.724665l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581C349.640192 185.873338 337.651137 173.887352 322.914504 173.887352zM312.801169 308.101123l-97.374748 0 0-97.374748 97.374748 0L312.801169 308.101123zM322.914504 675.606195l-117.608581 0c-14.733563 0-26.719548 11.989055-26.719548 26.724665l0 117.608581c0 14.732539 11.985986 26.719548 26.719548 26.719548l117.608581 0c14.735609 0 26.724665-11.987009 26.724665-26.719548l0-117.608581C349.640192 687.59525 337.651137 675.606195 322.914504 675.606195zM312.801169 809.819966l-97.374748 0 0-97.374748 97.374748 0L312.801169 809.819966zM699.123818 344.940147l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581c0-14.733563-11.989055-26.719548-26.724665-26.719548l-117.608581 0c-14.732539 0-26.719548 11.985986-26.719548 26.719548l0 117.608581C672.40427 332.951091 684.391279 344.940147 699.123818 344.940147zM709.243293 210.726376l97.374748 0 0 97.374748-97.374748 0L709.243293 210.726376zM433.282171 546.435277 94.944396 546.435277c-23.327288 0-42.304502 18.97619-42.304502 42.300408L52.639894 927.077553c0 23.325241 18.977213 42.301432 42.304502 42.301432L433.282171 969.378985c23.324218 0 42.300408-18.97619 42.300408-42.301432L475.582579 588.735685C475.581556 565.411467 456.606389 546.435277 433.282171 546.435277zM438.742533 927.077553c0 3.01159-2.449795 5.462408-5.461385 5.462408L94.944396 932.539962c-3.013637 0-5.465478-2.450818-5.465478-5.462408L89.478917 588.735685c0-3.010567 2.451842-5.461385 5.465478-5.461385L433.282171 583.2743c3.01159 0 5.461385 2.450818 5.461385 5.461385L438.743556 927.077553zM590.849836 547.776831c-23.325241 0-42.301432 18.978237-42.301432 42.305525l0 194.649212c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L585.387427 590.082356c0-3.013637 2.450818-5.466502 5.462408-5.466502l204.825992 0c10.172687 0 18.419512-8.246825 18.419512-18.419512s-8.246825-18.419512-18.419512-18.419512L590.849836 547.776831zM588.757175 470.882534l338.341868 0c23.325241 0 42.301432-18.97619 42.301432-42.300408L969.400474 90.240257c0-23.324218-18.97619-42.300408-42.301432-42.300408L588.757175 47.939849c-23.324218 0-42.300408 18.975167-42.300408 42.300408l0 338.341868C546.456766 451.906343 565.432956 470.882534 588.757175 470.882534zM583.295789 90.240257c0-3.01159 2.450818-5.461385 5.461385-5.461385l338.341868 0c3.01159 0 5.462408 2.449795 5.462408 5.461385l0 338.341868c0 3.01159-2.450818 5.461385-5.462408 5.461385L588.757175 434.04351c-3.010567 0-5.461385-2.450818-5.461385-5.461385L583.295789 90.240257zM969.676767 566.196343c0-10.172687-8.246825-18.419512-18.419512-18.419512l-67.50444 0c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l49.084928 0 0 71.009264L779.708158 655.625118c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l171.549098 0c10.172687 0 18.419512-8.246825 18.419512-18.419512 0-0.076748-0.010233-0.151449-0.011256-0.228197 0.001023-0.076748 0.011256-0.150426 0.011256-0.228197L969.676767 566.196343zM630.202099 933.142689l-44.813648 0 0-51.2922c0-10.172687-8.246825-18.419512-18.419512-18.419512s-18.419512 8.246825-18.419512 18.419512l0 69.711711c0 10.172687 8.246825 18.419512 18.419512 18.419512l63.23316 0c10.172687 0 18.419512-8.246825 18.419512-18.419512S640.374786 933.142689 630.202099 933.142689zM834.04981 790.359752c0-10.172687-8.246825-18.419512-18.419512-18.419512L699.257871 771.940241c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 163.013701c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L717.677383 808.779264 815.630299 808.779264C825.802986 808.779264 834.04981 800.532439 834.04981 790.359752zM951.060781 723.425294c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 194.301288L765.943666 936.146093c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l185.117115 0c10.172687 0 18.419512-8.246825 18.419512-18.419512L969.480292 741.844805C969.480292 731.672118 961.234491 723.425294 951.060781 723.425294zM655.979182 623.620194c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 59.869552c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512l0-59.869552C674.398694 631.867018 666.151869 623.620194 655.979182 623.620194z" }) });
}, "QRCode"), title$2 = "_title_nnme6_1", nextButton = "_nextButton_nnme6_6", details = "_details_nnme6_17", qrCode = "_qrCode_nnme6_22", address$3 = "_address_nnme6_32", buttons$1 = "_buttons_nnme6_35", verifyButton = "_verifyButton_nnme6_42", entry = "_entry_nnme6_46", xPubInfo = "_xPubInfo_nnme6_55", infoContent = "_infoContent_nnme6_82", largeEntry = "_largeEntry_nnme6_86", addressField = "_addressField_nnme6_96", style$B = {
  title: title$2,
  nextButton,
  details,
  qrCode,
  address: address$3,
  buttons: buttons$1,
  verifyButton,
  entry,
  xPubInfo,
  infoContent,
  largeEntry,
  addressField
}, SigningConfiguration = /* @__PURE__ */ __name(({ account: account2, info: info2, code, signingConfigIndex, children: children2 }) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), config = (/* @__PURE__ */ __name(() => info2.bitcoinSimple !== void 0 ? info2.bitcoinSimple : info2.ethereumSimple, "getSimpleInfo"))(), bitcoinBased = isBitcoinBased(account2.coinCode);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.address, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$B.qrCode, children: bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      QRCode,
      {
        data: config.keyInfo.xpub
      }
    ) : null }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.details, children: [
      account2.isToken ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountSummary.name"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name })
      ] }, "accountname"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Keypath:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.keypath })
      ] }, "keypath"),
      "scriptType" in config ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountInfo.scriptType"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getScriptName(config.scriptType) })
      ] }, "scriptName") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Root fingerprint:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.rootFingerprint })
      ] }, "rootFingerprint"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          account2.isToken ? "Token" : "Coin",
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          account2.coinName,
          " (",
          account2.coinUnit,
          ")"
        ] })
      ] }, "coinName"),
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$B.entry} ${style$B.largeEntry}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { className: "m-right-half", children: [
          t2("accountInfo.extendedPublicKey"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyableInput,
          {
            className: "flex-grow",
            alignLeft: !0,
            flexibleHeight: !0,
            value: config.keyInfo.xpub
          }
        )
      ] }, "xpub") : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$B.buttons, children: [
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$B.verifyButton, primary: !0, disabled: verifying, onClick: async () => {
        setVerifying(!0);
        try {
          const result = await verifyXPub(code, signingConfigIndex);
          result.success || alertUser(result.errorMessage);
        } finally {
          setVerifying(!1);
        }
      }, children: t2("accountInfo.verify") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$B.verifyButton, primary: !0, onClick: () => route(`/account/${code}/receive`), children: t2("receive.verify") }),
      children2
    ] })
  ] });
}, "SigningConfiguration");
function BitcoinBasedAccountInfoGuide({
  coinName: coinName2
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.xpub"), shown: !0 }, "guide.accountInfo.xpub"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      text: t2("guide.accountInfo.multipleXPubs.text", { coinName: coinName2 }),
      title: t2("guide.accountInfo.multipleXPubs.title")
    } }, "guide.accountInfo.multipleXPubs"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.privacy") }, "guide.accountInfo.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.verify") }, "guide.accountInfo.verify")
  ] });
}
__name(BitcoinBasedAccountInfoGuide, "BitcoinBasedAccountInfoGuide");
const Info = /* @__PURE__ */ __name(({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation(), info2 = useLoad(getInfo(code)), [viewXPub, setViewXPub] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  if (useEsc(() => route(`/account/${code}`)), !account2 || !info2)
    return null;
  const config = info2.signingConfigurations[viewXPub], numberOfXPubs = info2.signingConfigurations.length, xpubTypes = info2.signingConfigurations.map((cfg) => {
    var _a46;
    return (_a46 = cfg.bitcoinSimple) == null ? void 0 : _a46.scriptType;
  }), showNextXPub = /* @__PURE__ */ __name(() => {
    if (!info2)
      return;
    const numberOfXPubs2 = info2.signingConfigurations.length;
    setViewXPub((viewXPub + 1) % numberOfXPubs2);
  }, "showNextXPub");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountInfo.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box larger", children: [
        isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$B.title, children: t2("accountInfo.extendedPublicKey") }) : null,
        config.bitcoinSimple !== void 0 && numberOfXPubs > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$B.xPubInfo, children: [
          t2("accountInfo.xpubTypeInfo", {
            current: `${viewXPub + 1}`,
            numberOfXPubs: numberOfXPubs.toString(),
            scriptType: config.bitcoinSimple.scriptType.toUpperCase()
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$B.nextButton, onClick: showNextXPub, children: t2(`accountInfo.xpubTypeChangeBtn.${xpubTypes[(viewXPub + 1) % numberOfXPubs]}`) })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SigningConfiguration,
          {
            account: account2,
            code,
            info: config,
            signingConfigIndex: viewXPub,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: !0,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          },
          viewXPub
        )
      ] }) })
    ] }) }),
    isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitcoinBasedAccountInfoGuide, { coinName: account2.coinName }) : null
  ] });
}, "Info");
function ReceiveGuide({
  hasMultipleAddresses,
  hasDifferentFormats
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.address") }, "guide.receive.address"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyVerify") }, "guide.receive.whyVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.howVerify") }, "guide.receive.howVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.plugout") }, "guide.receive.plugout"),
    hasMultipleAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyMany") }, "guide.receive.whyMany"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.why20") }, "guide.receive.why20"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressChange") }, "guide.receive.addressChange"),
      hasDifferentFormats && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressFormats") }, "guide.receive.addressFormats")
    ] })
  ] });
}
__name(ReceiveGuide, "ReceiveGuide");
const labels = "_labels_1m4jx_1", label$4 = "_label_1m4jx_1", qrCodeContainer = "_qrCodeContainer_1m4jx_17", arrowLeft = "_arrowLeft_1m4jx_22", arrowRight = "_arrowRight_1m4jx_23", previous = "_previous_1m4jx_37", next = "_next_1m4jx_38", hide = "_hide_1m4jx_49", changeType = "_changeType_1m4jx_58", style$A = {
  labels,
  label: label$4,
  qrCodeContainer,
  arrowLeft,
  arrowRight,
  previous,
  next,
  hide,
  changeType
}, scriptTypes$1 = ["p2wpkh", "p2tr", "p2wpkh-p2sh"], getIndexOfMatchingScriptType$1 = /* @__PURE__ */ __name((receiveAddresses, scriptType) => receiveAddresses ? receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType) : -1, "getIndexOfMatchingScriptType$1"), Receive$2 = /* @__PURE__ */ __name(({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), [activeIndex, setActiveIndex] = reactExports.useState(0), [addressType, setAddressType] = reactExports.useState(0), [addressDialog, setAddressDialog] = reactExports.useState(), [currentAddresses, setCurrentAddresses] = reactExports.useState(), [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code), receiveAddresses = useLoad(getReceiveAddressList(code)), availableScriptTypes = reactExports.useRef(), hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1, scriptTypeDialogOpened = !!(addressDialog && hasManyScriptTypes);
  useEsc(() => !scriptTypeDialogOpened && !verifying && route(`/account/${code}`)), reactExports.useEffect(() => {
    receiveAddresses && (availableScriptTypes.current = scriptTypes$1.filter((sc2) => getIndexOfMatchingScriptType$1(receiveAddresses, sc2) >= 0));
  }, [receiveAddresses]), reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType$1(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      addressIndex === -1 && (addressIndex = 0), setCurrentAddressIndex(addressIndex), setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const handleSubmit = /* @__PURE__ */ __name((e2) => {
    addressDialog && (e2.preventDefault(), setActiveIndex(0), setAddressType(addressDialog.addressType), setAddressDialog(void 0));
  }, "handleSubmit"), verifyAddress2 = /* @__PURE__ */ __name(async (addressesIndex) => {
    if (!receiveAddresses || code === void 0 || !(await connectKeystore(code)).success)
      return;
    if (!(await hasSecureOutput(code)()).hasSecureOutput) {
      setVerifying("insecure");
      return;
    }
    setVerifying("secure");
    try {
      await verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID);
    } finally {
      setVerifying(!1);
    }
  }, "verifyAddress"), previous2 = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), !verifying && activeIndex > 0 && setActiveIndex(activeIndex - 1);
  }, "previous"), next2 = /* @__PURE__ */ __name((e2, numAddresses) => {
    e2.preventDefault(), !verifying && activeIndex < numAddresses - 1 && setActiveIndex(activeIndex + 1);
  }, "next");
  let uriPrefix = "";
  account2 && (account2.coinCode === "btc" || account2.coinCode === "tbtc" ? uriPrefix = "bitcoin:" : (account2.coinCode === "ltc" || account2.coinCode === "tltc") && (uriPrefix = "litecoin:"));
  let address2 = "";
  return currentAddresses && (address2 = currentAddresses[activeIndex].address, verifying || (address2 = address2.substring(0, 8) + "...")), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: void 0 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$A.labels, children: [
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.previous,
              onClick: previous2,
              children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.label, children: [
            t2("receive.label"),
            " ",
            currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
          ] }),
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.next,
              onClick: (e2) => next2(e2, currentAddresses.length),
              children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !0, value: address2, flexibleHeight: !0 }),
        hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: style$A.changeType,
            onClick: () => setAddressDialog(addressDialog ? void 0 : { addressType }),
            children: t2("receive.changeScriptType")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: scriptTypeDialogOpened, onClose: () => setAddressDialog(void 0), medium: !0, title: t2("receive.changeScriptType"), children: [
          availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio,
              {
                checked: addressDialog.addressType === i,
                id: scriptType,
                name: "scriptType",
                onChange: () => setAddressDialog({ addressType: i }),
                title: getScriptName(scriptType),
                children: t2(`receive.scriptType.${scriptType}`)
              }
            ),
            scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
          ] }) }, scriptType)),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.done") }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              disabled: verifying !== !1,
              onClick: () => verifyAddress2(currentAddressIndex),
              primary: !0,
              children: t2("receive.verifyBitBox02")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonLink,
            {
              secondary: !0,
              to: `/account/${code}`,
              children: t2("button.back")
            }
          )
        ] }),
        verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.hide }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: !!(account2 && verifying),
            title: t2("receive.verifyBitBox02"),
            disableEscape: verifying === "secure",
            onClose: verifying === "insecure" ? () => {
              setVerifying(!1);
            } : void 0,
            medium: !0,
            centered: !0,
            children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                    coinName: account2.coinName
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  t2("receive.onlyThisCoin.description")
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: !0 }) })
            ] })
          }
        )
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : !1,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : !1
      }
    )
  ] });
}, "Receive$2"), getDeviceList = /* @__PURE__ */ __name(() => apiGet("devices/registered"), "getDeviceList"), hasMobileChannel = /* @__PURE__ */ __name((deviceID) => () => apiGet(`devices/${deviceID}/has-mobile-channel`), "hasMobileChannel"), container$g = "_container_1ooxc_1", withCloseBtn = "_withCloseBtn_1ooxc_7", status$2 = "_status_1ooxc_15", success$2 = "_success_1ooxc_21", warning$2 = "_warning_1ooxc_25", info$1 = "_info_1ooxc_29", close$1 = "_close_1ooxc_42", style$z = {
  container: container$g,
  withCloseBtn,
  status: status$2,
  success: success$2,
  warning: warning$2,
  info: info$1,
  "close-success": "_close-success_1ooxc_42",
  "close-warning": "_close-warning_1ooxc_46",
  "close-info": "_close-info_1ooxc_50",
  close: close$1
}, Status = /* @__PURE__ */ __name(({
  hidden,
  type: type2 = "warning",
  dismissible,
  className,
  children: children2
}) => {
  const [show2, setShow] = reactExports.useState(!dismissible), checkConfig = reactExports.useCallback(async () => {
    if (dismissible) {
      const config = await getConfig();
      setShow(config ? !config.frontend[dismissible] : !0);
    }
  }, [dismissible]);
  reactExports.useEffect(() => {
    checkConfig();
  }, [checkConfig]);
  const dismiss = /* @__PURE__ */ __name(async () => {
    dismissible && (setConfig({
      frontend: {
        [dismissible]: !0
      }
    }), setShow(!1));
  }, "dismiss");
  return hidden || !show2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$z.container, style$z[type2], className || "", dismissible ? style$z.withCloseBtn : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$z.status, children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        hidden: !dismissible,
        className: `${style$z.close} ${style$z[`close-${type2}`]}`,
        onClick: dismiss,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
      }
    )
  ] }) });
}, "Status"), PairedWarning = /* @__PURE__ */ __name(({
  deviceID
}) => {
  const { t: t2 } = useTranslation(), paired = useLoad(hasMobileChannel(deviceID));
  return paired ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== !1, children: t2("warning.receivePairing") });
}, "PairedWarning"), useVerifyLabel = /* @__PURE__ */ __name((device2) => {
  const { t: t2 } = useTranslation();
  return t2(device2 === "bitbox" ? "receive.verifyBitBox01" : device2 === "bitbox02" ? "receive.verifyBitBox02" : "receive.verify");
}, "useVerifyLabel"), VerifyButton = /* @__PURE__ */ __name(({
  device: device2,
  forceVerification,
  ...props
}) => {
  const { t: t2 } = useTranslation(), verifyLabel = useVerifyLabel(device2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, ...props, children: forceVerification ? t2("receive.showFull") : verifyLabel });
}, "VerifyButton"), scriptTypes = ["p2wpkh", "p2tr", "p2wpkh-p2sh"], getIndexOfMatchingScriptType = /* @__PURE__ */ __name((receiveAddresses, scriptType) => receiveAddresses ? receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType) : -1, "getIndexOfMatchingScriptType"), Receive$1 = /* @__PURE__ */ __name(({
  accounts,
  code,
  deviceID
}) => {
  const { t: t2 } = useTranslation(), [verifying, setVerifying] = reactExports.useState(!1), [activeIndex, setActiveIndex] = reactExports.useState(0), [addressType, setAddressType] = reactExports.useState(0), [addressDialog, setAddressDialog] = reactExports.useState(), [currentAddresses, setCurrentAddresses] = reactExports.useState(), [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0), account2 = accounts.find(({ code: accountCode }) => accountCode === code), verifyLabel = useVerifyLabel("bitbox"), receiveAddresses = useLoad(getReceiveAddressList(code)), secureOutput = useLoad(hasSecureOutput(code));
  useEsc(() => !verifying && route(`/account/${code}`));
  const availableScriptTypes = reactExports.useRef();
  reactExports.useEffect(() => {
    receiveAddresses && (availableScriptTypes.current = scriptTypes.filter((sc2) => getIndexOfMatchingScriptType(receiveAddresses, sc2) >= 0));
  }, [receiveAddresses]), reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      addressIndex === -1 && (addressIndex = 0), setCurrentAddressIndex(addressIndex), setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const verifyAddress2 = /* @__PURE__ */ __name((addressesIndex) => {
    if (receiveAddresses && secureOutput) {
      if (code === void 0)
        return;
      if (!secureOutput.hasSecureOutput) {
        alertUser(t2("receive.warning.secureOutput"));
        return;
      }
      setVerifying(!0), verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID).then(() => setVerifying(!1));
    }
  }, "verifyAddress"), previous2 = /* @__PURE__ */ __name((e2) => {
    e2.preventDefault(), !verifying && activeIndex > 0 && setActiveIndex(activeIndex - 1);
  }, "previous"), next2 = /* @__PURE__ */ __name((e2, numAddresses) => {
    e2.preventDefault(), !verifying && activeIndex < numAddresses - 1 && setActiveIndex(activeIndex + 1);
  }, "next"), forceVerification = secureOutput === void 0 ? !0 : secureOutput.hasSecureOutput && !secureOutput.optional, enableCopy = !forceVerification;
  let uriPrefix = "";
  account2 && (account2.coinCode === "btc" || account2.coinCode === "tbtc" ? uriPrefix = "bitcoin:" : (account2.coinCode === "ltc" || account2.coinCode === "tltc") && (uriPrefix = "litecoin:"));
  let address2 = "";
  currentAddresses && (address2 = currentAddresses[activeIndex].address, !enableCopy && !verifying && (address2 = address2.substring(0, 8) + "..."));
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PairedWarning, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: enableCopy ? uriPrefix + address2 : void 0 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$A.labels, children: [
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$A.previous,
                onClick: previous2,
                children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.label, children: [
              t2("receive.label"),
              " ",
              currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
            ] }),
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$A.next,
                onClick: (e2) => next2(e2, currentAddresses.length),
                children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !enableCopy, value: address2, flexibleHeight: !0 }),
          hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$A.changeType,
              onClick: () => setAddressDialog(addressDialog ? void 0 : { addressType }),
              children: t2("receive.changeScriptType")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: (e2) => {
            e2.preventDefault(), setActiveIndex(0), setAddressType(addressDialog ? addressDialog == null ? void 0 : addressDialog.addressType : addressType), setAddressDialog(void 0);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !!addressDialog, medium: !0, title: t2("receive.changeScriptType"), children: [
            availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Radio,
                {
                  checked: addressDialog.addressType === i,
                  id: scriptType,
                  name: "scriptType",
                  onChange: () => setAddressDialog({ addressType: i }),
                  title: getScriptName(scriptType),
                  children: t2(`receive.scriptType.${scriptType}`)
                }
              ),
              scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
            ] }) }, scriptType)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.done") }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              VerifyButton,
              {
                device: "bitbox",
                disabled: verifying || secureOutput === void 0,
                forceVerification,
                onClick: () => verifyAddress2(currentAddressIndex)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: !0,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          ] }),
          forceVerification && verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$A.hide }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dialog,
            {
              open: !!account2 && forceVerification && verifying,
              title: verifyLabel,
              disableEscape: !0,
              medium: !0,
              centered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                      coinName: account2.coinName
                    }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                    t2("receive.onlyThisCoin.description")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: !0 }) })
              ]
            }
          )
        ] }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : !1,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : !1
      }
    )
  ] });
}, "Receive$1"), Receive = /* @__PURE__ */ __name((props) => {
  const {
    devices,
    deviceIDs
  } = props, deviceID = deviceIDs[0];
  switch (deviceIDs.length ? devices[deviceID] : void 0) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$1,
        {
          deviceID,
          ...props
        }
      );
    case "bitbox02":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$2,
        {
          ...props
        }
      );
  }
}, "Receive"), RatesContext = reactExports.createContext({}), subscriptions = {};
function handleMessages(payload) {
  if ("type" in payload && payload.data && typeof payload.data == "string" && payload.data in subscriptions && subscriptions[payload.data].length)
    for (const observer of subscriptions[payload.data])
      observer(payload);
}
__name(handleMessages, "handleMessages");
function subscribe$1(subject, observer) {
  subscriptions[subject] || (subscriptions[subject] = []);
  const observers = subscriptions[subject];
  return observers.includes(observer) && console.error(`observer already registered for ${subject}`), observers.push(observer), () => {
    observers.includes(observer) || console.error("!observers.includes(observer)");
    const index = observers.indexOf(observer);
    observers.splice(index, 1);
  };
}
__name(subscribe$1, "subscribe$1");
apiWebsocket(handleMessages);
const syncAccountsList = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("accounts", cb2), "syncAccountsList"), syncAddressesCount = /* @__PURE__ */ __name((code) => (cb2) => subscribeEndpoint(`account/${code}/synced-addresses-count`, (count) => {
  cb2(count);
}), "syncAddressesCount"), statusChanged$1 = /* @__PURE__ */ __name((cb2) => subscribe$1("statusChanged", (event2) => {
  event2.type === "account" && event2.code && cb2(event2.code);
}), "statusChanged$1"), syncdone = /* @__PURE__ */ __name((cb2) => subscribe$1("syncdone", (event2) => {
  event2.type === "account" && event2.code && cb2(event2.code);
}), "syncdone"), subscribeCoinHeaders = /* @__PURE__ */ __name((coinCode) => (cb2) => subscribeEndpoint(`coins/${coinCode}/headers/status`, cb2), "subscribeCoinHeaders"), setBtcUnit = /* @__PURE__ */ __name((unit2) => apiPost("coins/btc/set-unit", { unit: unit2 }), "setBtcUnit"), parseExternalBtcAmount = /* @__PURE__ */ __name((amount2) => apiGet(`coins/btc/parse-external-amount?amount=${amount2}`), "parseExternalBtcAmount"), getDeviceInfo$1 = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/${deviceID}/info`), "getDeviceInfo$1"), space = "_space_tpxrt_1", style$y = {
  space
}, Amount = /* @__PURE__ */ __name(({ amount: amount2, unit: unit2, removeBtcTrailingZeroes, alwaysShowAmounts = !1 }) => {
  const { hideAmounts } = reactExports.useContext(AppContext), formatSats = /* @__PURE__ */ __name((amount22) => {
    const blocks = [];
    for (let i = amount22.length; i > 0; i -= 3) {
      const start = Math.max(0, i - 3);
      blocks.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: start === 0 ? "" : style$y.space, children: amount22.slice(start, i) }, "block_" + blocks.length)
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "amountBlocks", children: blocks.reverse() });
  }, "formatSats"), formatBtc = /* @__PURE__ */ __name((amount22) => {
    const dot2 = amount22.indexOf(".");
    return dot2 === -1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount22 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "amountBlocks", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: amount22.slice(0, dot2 + 3) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$y.space, children: amount22.slice(dot2 + 3, dot2 + 6) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$y.space, children: amount22.slice(dot2 + 6, dot2 + 9) })
    ] });
  }, "formatBtc");
  if (hideAmounts && !alwaysShowAmounts)
    return "***";
  switch (unit2) {
    case "BTC":
    case "TBTC":
    case "LTC":
    case "TLTC":
      return removeBtcTrailingZeroes && amount2.includes(".") ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2.replace(/\.?0+$/, "") }) : formatBtc(amount2);
    case "sat":
    case "tsat":
      return formatSats(amount2);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2 });
}, "Amount"), rates = "_rates_19qqe_1", unit$1 = "_unit_19qqe_8", unitAction = "_unitAction_19qqe_13", fiatRow = "_fiatRow_19qqe_20", availableFiatAmount = "_availableFiatAmount_19qqe_24", availableFiatUnitNoAction = "_availableFiatUnitNoAction_19qqe_29", availableFiatUnit = "_availableFiatUnit_19qqe_29", notAvailable = "_notAvailable_19qqe_46", style$x = {
  rates,
  unit: unit$1,
  unitAction,
  fiatRow,
  availableFiatAmount,
  availableFiatUnitNoAction,
  availableFiatUnit,
  notAvailable
}, currenciesWithDisplayName = [
  { currency: "AUD", displayName: "Australian Dollar" },
  { currency: "BRL", displayName: "Brazilian Real" },
  { currency: "CAD", displayName: "Canadian Dollar" },
  { currency: "CHF", displayName: "Swiss franc" },
  { currency: "CNY", displayName: "Chinese Yuan" },
  { currency: "CZK", displayName: "Czech Koruna" },
  { currency: "EUR", displayName: "Euro" },
  { currency: "GBP", displayName: "British Pound" },
  { currency: "HKD", displayName: "Hong Kong Dollar" },
  { currency: "ILS", displayName: "Israeli New Shekel" },
  { currency: "JPY", displayName: "Japanese Yen" },
  { currency: "KRW", displayName: "South Korean Won" },
  { currency: "NOK", displayName: "Norwegian Krone" },
  { currency: "PLN", displayName: "Polish Zloty" },
  { currency: "RUB", displayName: "Russian ruble" },
  { currency: "SEK", displayName: "Swedish Krona" },
  { currency: "SGD", displayName: "Singapore Dollar" },
  { currency: "USD", displayName: "United States Dollar" },
  { currency: "BTC", displayName: "Bitcoin" }
];
function formatNumber(amount2, maxDigits) {
  let formatted = amount2.toFixed(maxDigits), position2 = formatted.indexOf(".") - 3;
  for (; position2 > 0; )
    formatted = formatted.slice(0, position2) + "'" + formatted.slice(position2), position2 = position2 - 3;
  return formatted;
}
__name(formatNumber, "formatNumber");
function Conversion({
  amount: amount2,
  tableRow,
  unstyled,
  skipUnit,
  noAction,
  sign,
  noBtcZeroes,
  alwaysShowAmounts = !1
}) {
  const { rotateFiat, defaultCurrency: defaultCurrency2, btcUnit } = reactExports.useContext(RatesContext);
  let formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "---" }), isAvailable = !1, activeUnit = defaultCurrency2;
  return defaultCurrency2 === "BTC" && btcUnit === "sat" && (activeUnit = "sat"), amount2 && amount2.conversions && amount2.conversions[defaultCurrency2] && amount2.conversions[defaultCurrency2] !== "" && (isAvailable = !0, formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts, amount: amount2.conversions[defaultCurrency2], unit: activeUnit, removeBtcTrailingZeroes: !!noBtcZeroes })), tableRow ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: unstyled ? "" : style$x.fiatRow, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatAmount, children: formattedAmount }),
    !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatUnit, onClick: rotateFiat, children: activeUnit }),
    noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$x.availableFiatUnitNoAction, children: activeUnit })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${style$x.rates} ${isAvailable ? "" : style$x.notAvailable}`, children: [
    isAvailable ? sign : "",
    formattedAmount,
    " ",
    !skipUnit && !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$x.unitAction, onClick: rotateFiat, children: activeUnit }),
    !skipUnit && noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$x.unit, children: activeUnit })
  ] });
}
__name(Conversion, "Conversion");
const formattedCurrencies = currenciesWithDisplayName.map((fiat2) => ({ label: `${fiat2.displayName} (${fiat2.currency})`, value: fiat2.currency })), FiatConversion = Conversion, balanceTable$1 = "_balanceTable_m2hui_1", availableAmount = "_availableAmount_m2hui_27", availableUnit = "_availableUnit_m2hui_32", pendingBalance = "_pendingBalance_m2hui_37", style$w = {
  balanceTable: balanceTable$1,
  availableAmount,
  availableUnit,
  pendingBalance
}, Balance = /* @__PURE__ */ __name(({
  balance: balance2,
  noRotateFiat
}) => {
  const { t: t2 } = useTranslation();
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: style$w.balance, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: style$w.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { "data-testid": "availableBalance", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$w.availableAmount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.available.amount,
            unit: balance2.available.unit,
            removeBtcTrailingZeroes: !0
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$w.availableUnit, children: balance2.available.unit })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FiatConversion,
        {
          amount: balance2.available,
          tableRow: !0,
          noAction: noRotateFiat,
          noBtcZeroes: !0
        }
      )
    ] }) }),
    balance2.hasIncoming && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$w.pendingBalance, children: [
      t2("account.incoming"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "incomingBalance", children: [
        "+",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.incoming.amount,
            unit: balance2.incoming.unit,
            removeBtcTrailingZeroes: !0
          }
        ),
        " ",
        balance2.incoming.unit,
        " /",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$w.incomingConversion, children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.incoming, noBtcZeroes: !0 })
        ] })
      ] })
    ] })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: style$w.balance });
}, "Balance"), translate = withTranslation;
function load(endpointsObjectOrFunction, renderOnlyOnceLoaded = !0) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      constructor() {
        super(...arguments), this.state = {};
      }
      determineEndpoints() {
        return typeof endpointsObjectOrFunction == "function" ? endpointsObjectOrFunction(this.props) : endpointsObjectOrFunction;
      }
      loadEndpoint(key, endpoint) {
        apiGet(endpoint).then((object) => {
          this.setState({ [key]: object });
        });
      }
      loadEndpoints() {
        const oldEndpoints = this.endpoints, newEndpoints = this.determineEndpoints();
        for (const key of Object.keys(newEndpoints))
          (oldEndpoints === void 0 || newEndpoints[key] !== oldEndpoints[key]) && this.loadEndpoint(key, newEndpoints[key]);
        if (oldEndpoints === void 0)
          renderOnlyOnceLoaded && Object.keys(newEndpoints).length === 0 && this.setState({});
        else
          for (const key of Object.keys(oldEndpoints))
            newEndpoints[key] === void 0 && this.setState({ [key]: void 0 });
        this.endpoints = newEndpoints;
      }
      componentDidMount() {
        this.loadEndpoints();
      }
      componentDidUpdate() {
        this.loadEndpoints();
      }
      allEndpointsLoaded() {
        if (this.endpoints === void 0)
          return !1;
        for (const key of Object.keys(this.endpoints))
          if (this.state[key] === void 0)
            return !1;
        return !0;
      }
      render() {
        const props = this.props, state = this.state;
        return renderOnlyOnceLoaded && !this.allEndpointsLoaded() ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(WrappedComponent, { ...state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Load(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(load, "load");
const row$1 = "_row_1qpuo_1", rowCustomFee = "_rowCustomFee_1qpuo_6", column = "_column_1qpuo_12", priority = "_priority_1qpuo_38", fee$1 = "_fee_1qpuo_42", feeCustom = "_feeCustom_1qpuo_91", feeDescription = "_feeDescription_1qpuo_95", feeProposed = "_feeProposed_1qpuo_96", customFeeUnit = "_customFeeUnit_1qpuo_112", style$v = {
  row: row$1,
  rowCustomFee,
  column,
  priority,
  fee: fee$1,
  feeCustom,
  feeDescription,
  feeProposed,
  customFeeUnit
}, _FeeTargets = class _FeeTargets extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      feeTarget: "",
      options: null,
      noFeeTargets: !1
    }, this.input = reactExports.createRef(), this.updateFeeTargets = (accountCode) => {
      getFeeTargetList(accountCode).then(({ feeTargets, defaultFeeTarget }) => {
        const expert = this.props.config.frontend.expertFee || feeTargets.length === 0, options2 = feeTargets.map(({ code, feeRateInfo }) => ({
          value: code,
          text: this.props.t(`send.feeTarget.label.${code}`) + (expert && feeRateInfo ? ` (${feeRateInfo})` : "")
        }));
        expert && options2.push({
          value: "custom",
          text: this.props.t("send.feeTarget.label.custom")
        }), this.setState({ options: options2 }), this.setFeeTarget(defaultFeeTarget), feeTargets.length === 0 && this.setState({ noFeeTargets: !0 });
      }).catch(console.error);
    }, this.handleFeeTargetChange = (event2) => {
      const target = event2.target;
      this.setFeeTarget(target.options[target.selectedIndex].value);
    }, this.handleCustomFee = (event2) => {
      const target = event2.target;
      this.props.onCustomFee(target.value);
    }, this.setFeeTarget = (feeTarget) => {
      this.setState({ feeTarget }), this.props.onFeeTargetChange(feeTarget);
    }, this.getProposeFeeText = () => {
      if (!this.props.proposedFee)
        return "";
      const { amount: amount2, unit: unit2, conversions } = this.props.proposedFee, fiatUnit = this.props.fiatUnit;
      return `${amount2} ${unit2} ${conversions ? ` = ${conversions[fiatUnit === "sat" ? "BTC" : fiatUnit]} ${fiatUnit}` : ""}`;
    }, this.focusInput = () => {
      !this.props.disabled && this.input.current && this.input.current.autofocus && this.input.current.focus();
    };
  }
  componentDidMount() {
    this.updateFeeTargets(this.props.accountCode), this.focusInput();
  }
  UNSAFE_componentWillReceiveProps({ accountCode }) {
    this.props.accountCode !== accountCode && this.updateFeeTargets(accountCode);
  }
  render() {
    const {
      t: t2,
      coinCode,
      disabled: disabled2,
      error: error3,
      showCalculatingFeeLabel = !1,
      customFee
    } = this.props, {
      feeTarget,
      options: options2,
      noFeeTargets
    } = this.state;
    if (options2 === null)
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          label: t2("send.priority"),
          id: "feetarget",
          placeholder: t2("send.feeTarget.placeholder"),
          disabled: !0,
          value: "",
          transparent: !0
        }
      );
    const isCustom = feeTarget === "custom", hasOptions = options2.length > 0, proposeFeeText = this.getProposeFeeText(), preventFocus = document.activeElement && document.activeElement.nodeName === "INPUT";
    return hasOptions ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      isCustom ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$v.rowCustomFee, children: [
        noFeeTargets ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { small: !0, type: "warning", children: t2("send.noFeeTargets") }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$v.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Select$1,
          {
            className: style$v.priority,
            label: t2("send.priority"),
            id: "feeTarget",
            disabled: disabled2,
            onChange: this.handleFeeTargetChange,
            value: feeTarget,
            options: options2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$v.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            type: disabled2 ? "text" : "number",
            min: "0",
            step: "any",
            autoFocus: !preventFocus,
            align: "right",
            className: `${style$v.fee} ${style$v.feeCustom}`,
            disabled: disabled2,
            label: t2("send.feeTarget.customLabel", {
              context: isEthereumBased(coinCode) ? "eth" : ""
            }),
            id: "proposedFee",
            placeholder: t2("send.fee.customPlaceholder"),
            error: error3,
            transparent: !0,
            onInput: this.handleCustomFee,
            ref: this.input,
            value: customFee,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$v.customFeeUnit, children: customFeeUnit$1(this.props.coinCode) })
          }
        ) })
      ] }) : showCalculatingFeeLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: !0,
          label: t2("send.priority"),
          placeholder: t2("send.feeTarget.placeholder"),
          value: "",
          transparent: !0
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select$1,
        {
          className: style$v.priority,
          label: t2("send.priority"),
          id: "feeTarget",
          disabled: disabled2,
          onChange: this.handleFeeTargetChange,
          value: feeTarget,
          options: options2
        }
      ),
      feeTarget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        showCalculatingFeeLabel || proposeFeeText ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$v.feeProposed, children: [
          t2("send.fee.label"),
          ":",
          " ",
          showCalculatingFeeLabel ? t2("send.feeTarget.placeholder") : proposeFeeText
        ] }) : null,
        isCustom ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$v.feeDescription, children: [
          t2("send.feeTarget.estimate"),
          " ",
          t2(`send.feeTarget.description.${feeTarget}`, {
            context: getCoinCode(coinCode) || ""
          })
        ] })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        disabled: !0,
        label: t2("send.fee.label"),
        id: "proposedFee",
        placeholder: t2("send.fee.placeholder"),
        error: error3,
        transparent: !0,
        value: proposeFeeText
      }
    );
  }
};
__name(_FeeTargets, "FeeTargets");
let FeeTargets = _FeeTargets;
const loadedHOC = load(
  { config: "config" }
)(FeeTargets), TranslatedFeeTargets = translate()(loadedHOC), utxosList = "_utxosList_8ra1q_1", utxo = "_utxo_8ra1q_1", utxoContent = "_utxoContent_8ra1q_17", note = "_note_8ra1q_25", utxoData = "_utxoData_8ra1q_33", utxoExplorer = "_utxoExplorer_8ra1q_41", amounts = "_amounts_8ra1q_51", amount$1 = "_amount_8ra1q_51", label$3 = "_label_8ra1q_59", unit = "_unit_8ra1q_60", address$2 = "_address_8ra1q_73", transaction = "_transaction_8ra1q_74", shrink = "_shrink_8ra1q_81", style$u = {
  utxosList,
  utxo,
  utxoContent,
  note,
  utxoData,
  utxoExplorer,
  amounts,
  amount: amount$1,
  label: label$3,
  unit,
  address: address$2,
  transaction,
  shrink
}, UTXOs = /* @__PURE__ */ __name(({
  accountCode,
  active: active2,
  explorerURL,
  onChange: onChange2,
  onClose
}) => {
  const { t: t2 } = useTranslation(), [utxos, setUtxos] = reactExports.useState([]), [selectedUTXOs, setSelectedUTXOs] = reactExports.useState({});
  reactExports.useEffect(() => (getUTXOs(accountCode).then(setUtxos), () => setUtxos([])), [accountCode]), reactExports.useEffect(() => {
    const unsubscribe2 = syncdone((code) => {
      accountCode === code && getUTXOs(accountCode).then(setUtxos);
    });
    return () => unsubscribe2();
  }, [accountCode]);
  const handleUTXOChange = /* @__PURE__ */ __name((event2) => {
    const target = event2.target, outPoint = target.dataset.outpoint, proposedUTXOs = Object.assign({}, selectedUTXOs);
    target.checked ? proposedUTXOs[outPoint] = !0 : delete proposedUTXOs[outPoint], setSelectedUTXOs(proposedUTXOs), onChange2(proposedUTXOs);
  }, "handleUTXOChange"), renderUTXOs = /* @__PURE__ */ __name((scriptType) => {
    const filteredUTXOs = utxos.filter((utxo2) => utxo2.scriptType === scriptType);
    return filteredUTXOs.length === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "subTitle", children: getScriptName(scriptType) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$u.utxosList, children: filteredUTXOs.map((utxo2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: style$u.utxo, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Checkbox,
        {
          checked: !!selectedUTXOs[utxo2.outPoint],
          id: "utxo-" + utxo2.outPoint,
          "data-outpoint": utxo2.outPoint,
          onChange: handleUTXOChange,
          children: [
            utxo2.note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$u.note, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              utxo2.note,
              " "
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.utxoContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.utxoData, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.amounts, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.amount, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: utxo2.amount.amount, unit: utxo2.amount.unit }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.unit, children: utxo2.amount.unit })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { alwaysShowAmounts: !0, amount: utxo2.amount, unstyled: !0, noAction: !0 })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.address, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.label, children: [
                    t2("send.coincontrol.address"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.shrink, children: utxo2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$u.transaction, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$u.label, children: [
                    t2("send.coincontrol.outpoint"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.shrink, children: utxo2.txId }),
                  ":",
                  utxo2.txOutput
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: style$u.utxoExplorer,
                  href: explorerURL + utxo2.txId,
                  title: t2("transaction.explorerTitle"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, {})
                }
              )
            ] })
          ]
        }
      ) }, "utxo-" + utxo2.outPoint)) })
    ] }, "utxos-" + scriptType);
  }, "renderUTXOs");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      open: active2,
      title: t2("send.coincontrol.title"),
      large: !0,
      onClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        allScriptTypes.map(renderUTXOs),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-top-none m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onClose, children: t2("button.continue") }) })
      ] })
    }
  );
}, "UTXOs");
function unsubscribe(unsubscribeList) {
  for (const unsubscribeCallback of unsubscribeList)
    unsubscribeCallback();
  unsubscribeList.splice(0, unsubscribeList.length);
}
__name(unsubscribe, "unsubscribe");
const approve$1 = "" + new URL("hold.png", import.meta.url).href, reject = "" + new URL("tap.png", import.meta.url).href, _WaitDialog = class _WaitDialog extends reactExports.Component {
  constructor() {
    super(...arguments), this.overlay = reactExports.createRef(), this.modal = reactExports.createRef(), this.state = {
      active: !1
    }, this.handleKeyDown = (e2) => {
      const activeElement = document.activeElement;
      activeElement && activeElement instanceof HTMLElement && activeElement.blur(), e2.preventDefault(), e2.stopPropagation();
    }, this.activate = () => {
      this.setState({ active: !0 }, () => {
        !this.overlay.current || !this.modal.current || (this.overlay.current.classList.add(style$10.activeOverlay), this.modal.current.classList.add(style$10.activeModal));
      });
    };
  }
  UNSAFE_componentWillMount() {
    document.body.addEventListener("keydown", this.handleKeyDown);
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.body.removeEventListener("keydown", this.handleKeyDown);
  }
  render() {
    const {
      t: t2,
      includeDefault,
      prequel,
      title: title2,
      paired = !1,
      touchConfirm = !0,
      children: children2
    } = this.props, defaultContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      prequel && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: prequel }),
      paired ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$10.confirmationLabel, touchConfirm && paired ? style$10.disabledLabel : "", "m-top-none"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$10.confirmationLabelNumber, children: "1." }),
          t2("confirm.infoWhenPaired")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$10.confirmationLabel, !touchConfirm && paired ? style$10.disabledLabel : ""].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$10.confirmationLabelNumber, children: "2." }),
          t2("confirm.info")
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$10.confirmationLabel, style$10.noStep, "m-top-none"].join(" "), children: t2("confirm.info") }),
      touchConfirm && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-between flex-items-stretch", style$10.confirmationInstructions].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$10.image, src: reject, alt: "Reject" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.abortInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red", children: t2("confirm.abortInfoRedText") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$10.image, src: approve$1, alt: "Approve" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.approveInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green", children: t2("confirm.approveInfoGreenText") })
          ] })
        ] })
      ] })
    ] }), hasChildren = React.Children.toArray(children2).length > 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: style$10.overlay,
        ref: this.overlay,
        style: { zIndex: 10001 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$10.modal, style$10.open].join(" "), ref: this.modal, children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$10.title, children: title2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.contentContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.content, children: [
            hasChildren && includeDefault ? defaultContent : null,
            hasChildren ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-start", children: children2 }) : defaultContent
          ] }) })
        ] })
      }
    );
  }
};
__name(_WaitDialog, "WaitDialog");
let WaitDialog = _WaitDialog;
const TranslatedWaitDialog = translate()(WaitDialog), confirmItem = "_confirmItem_1e5e5_1", confirmationValue = "_confirmationValue_1e5e5_6", total = "_total_1e5e5_15", style$t = {
  confirmItem,
  confirmationValue,
  total
}, ConfirmingWaitDialog = /* @__PURE__ */ __name(({
  paired,
  baseCurrencyUnit,
  note: note2,
  hasSelectedUTXOs,
  selectedUTXOs,
  coinCode,
  transactionStatus,
  transactionDetails
}) => {
  const { t: t2 } = useTranslation(), { isConfirming, signConfirm, signProgress } = transactionStatus, {
    proposedFee,
    proposedAmount,
    proposedTotal,
    customFee,
    feeTarget,
    recipientAddress,
    fiatUnit
  } = transactionDetails;
  if (!isConfirming)
    return null;
  const confirmPrequel = signProgress && signProgress.steps > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    t2("send.signprogress.description", {
      steps: signProgress.steps.toString()
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    t2("send.signprogress.label"),
    ": ",
    signProgress.step,
    "/",
    signProgress.steps
  ] }) : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TranslatedWaitDialog,
    {
      title: t2("send.confirm.title"),
      prequel: confirmPrequel,
      paired,
      touchConfirm: signConfirm,
      includeDefault: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.address.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: recipientAddress || "N/A" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.amount.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedAmount && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedAmount.amount, unit: proposedAmount.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedAmount && proposedAmount.unit || "N/A" })
            ] }, "proposedAmount"),
            proposedAmount && proposedAmount.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedAmount.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: note2 })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            t2("send.fee.label"),
            feeTarget ? " (" + t2(`send.feeTarget.label.${feeTarget}`) + ")" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedFee && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedFee.amount, unit: proposedFee.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedFee && proposedFee.unit || "N/A" })
            ] }, "amount"),
            proposedFee && proposedFee.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedFee.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] }, "conversation"),
            customFee ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "(",
                customFee,
                " ",
                customFeeUnit$1(coinCode),
                ")"
              ] })
            ] }, "customFee") : null
          ] })
        ] }),
        hasSelectedUTXOs && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$t.confirmItem].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.selected-coins") }),
          selectedUTXOs.map((uxto, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$t.confirmationValue, children: uxto }, `selectedCoin-${i}`))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$t.confirmItem, style$t.total].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.total") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: proposedTotal && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedTotal.amount, unit: proposedTotal.unit }) || "N/A" }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedTotal && proposedTotal.unit || "N/A" })
            ] }),
            proposedTotal && proposedTotal.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: !0, amount: proposedTotal.conversions[fiatUnit], unit: baseCurrencyUnit }) }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] })
      ]
    }
  );
}, "ConfirmingWaitDialog"), SendGuide = /* @__PURE__ */ __name(({ coinCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.whyFee") }, "guide.send.whyFee"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.priority") }, "guide.send.priority"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.fee") }, "guide.send.fee"),
    isBitcoinOnly(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.change") }, "guide.send.change"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.revert") }, "guide.send.revert"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.plugout") }, "guide.send.plugout")
  ] });
}, "SendGuide"), txProposalErrorHandling = /* @__PURE__ */ __name((registerEvents, unregisterEvents, errorCode) => {
  const { t: t2 } = instance;
  switch (errorCode) {
    case "invalidAddress":
      return { addressError: t2("send.error.invalidAddress") };
    case "invalidAmount":
    case "insufficientFunds":
      return { amountError: t2(`send.error.${errorCode}`), proposedFee: void 0 };
    case "feeTooLow":
    case "feesNotAvailable":
      return { feeError: t2(`send.error.${errorCode}`) };
    default:
      return errorCode && (unregisterEvents(), alertUser(errorCode, { callback: registerEvents })), { proposedFee: void 0 };
  }
}, "txProposalErrorHandling"), MessageWaitDialog = /* @__PURE__ */ __name(({ isShown, messageType }) => isShown ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-center flex-items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconAndMessage, { messageType }) }) }) : null, "MessageWaitDialog"), IconAndMessage = /* @__PURE__ */ __name(({ messageType }) => {
  const { t: t2 } = useTranslation();
  switch (messageType) {
    case "sent":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, { style: { height: 18, marginRight: "1rem" } }),
        t2("send.success")
      ] });
    case "abort":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { alt: "Abort", style: { height: 18, marginRight: "1rem" } }),
        t2("send.abort")
      ] });
    default:
      return null;
  }
}, "IconAndMessage"), scriptRel = (/* @__PURE__ */ __name(function() {
  const relList = typeof document < "u" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}, "detectScriptRel"))(), assetsURL = /* @__PURE__ */ __name(function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
}, "assetsURL"), seen = {}, __vitePreload = /* @__PURE__ */ __name(function(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0)
    return baseModule();
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    if (dep = assetsURL(dep, importerUrl), dep in seen)
      return;
    seen[dep] = !0;
    const isCss = dep.endsWith(".css"), cssSelector = isCss ? '[rel="stylesheet"]' : "";
    if (!!importerUrl)
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet"))
          return;
      }
    else if (document.querySelector(`link[href="${dep}"]${cssSelector}`))
      return;
    const link2 = document.createElement("link");
    if (link2.rel = isCss ? "stylesheet" : scriptRel, isCss || (link2.as = "script", link2.crossOrigin = ""), link2.href = dep, document.head.appendChild(link2), isCss)
      return new Promise((res, rej) => {
        link2.addEventListener("load", res), link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
  })).then(() => baseModule()).catch((err) => {
    const e2 = new Event("vite:preloadError", { cancelable: !0 });
    if (e2.payload = err, window.dispatchEvent(e2), !e2.defaultPrevented)
      throw err;
  });
}, "preload");
var _a;
let e$1 = (_a = class {
  constructor(a2, b2, c2, d2, f2) {
    this._legacyCanvasSize = _a.DEFAULT_CANVAS_SIZE, this._preferredCamera = "environment", this._maxScansPerSecond = 25, this._lastScanTimestamp = -1, this._destroyed = this._flashOn = this._paused = this._active = !1, this.$video = a2, this.$canvas = document.createElement("canvas"), c2 && typeof c2 == "object" ? this._onDecode = b2 : (console.warn(c2 || d2 || f2 ? "You're using a deprecated version of the QrScanner constructor which will be removed in the future" : "Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), this._legacyOnDecode = b2), b2 = typeof c2 == "object" ? c2 : {}, this._onDecodeError = b2.onDecodeError || (typeof c2 == "function" ? c2 : this._onDecodeError), this._calculateScanRegion = b2.calculateScanRegion || (typeof d2 == "function" ? d2 : this._calculateScanRegion), this._preferredCamera = b2.preferredCamera || f2 || this._preferredCamera, this._legacyCanvasSize = typeof c2 == "number" ? c2 : typeof d2 == "number" ? d2 : this._legacyCanvasSize, this._maxScansPerSecond = b2.maxScansPerSecond || this._maxScansPerSecond, this._onPlay = this._onPlay.bind(this), this._onLoadedMetaData = this._onLoadedMetaData.bind(this), this._onVisibilityChange = this._onVisibilityChange.bind(this), this._updateOverlay = this._updateOverlay.bind(this), a2.disablePictureInPicture = !0, a2.playsInline = !0, a2.muted = !0;
    let h2 = !1;
    if (a2.hidden && (a2.hidden = !1, h2 = !0), document.body.contains(a2) || (document.body.appendChild(a2), h2 = !0), c2 = a2.parentElement, b2.highlightScanRegion || b2.highlightCodeOutline) {
      if (d2 = !!b2.overlay, this.$overlay = b2.overlay || document.createElement("div"), f2 = this.$overlay.style, f2.position = "absolute", f2.display = "none", f2.pointerEvents = "none", this.$overlay.classList.add("scan-region-highlight"), !d2 && b2.highlightScanRegion) {
        this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
        try {
          this.$overlay.firstElementChild.animate({ transform: [
            "scale(.98)",
            "scale(1.01)"
          ] }, { duration: 400, iterations: 1 / 0, direction: "alternate", easing: "ease-in-out" });
        } catch {
        }
        c2.insertBefore(this.$overlay, this.$video.nextSibling);
      }
      b2.highlightCodeOutline && (this.$overlay.insertAdjacentHTML("beforeend", '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);
    }
    this._scanRegion = this._calculateScanRegion(a2), requestAnimationFrame(() => {
      let m2 = window.getComputedStyle(a2);
      m2.display === "none" && (a2.style.setProperty("display", "block", "important"), h2 = !0), m2.visibility !== "visible" && (a2.style.setProperty("visibility", "visible", "important"), h2 = !0), h2 && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), a2.style.opacity = "0", a2.style.width = "0", a2.style.height = "0", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight), this.$overlay && this._updateOverlay();
    }), a2.addEventListener("play", this._onPlay), a2.addEventListener("loadedmetadata", this._onLoadedMetaData), document.addEventListener("visibilitychange", this._onVisibilityChange), window.addEventListener("resize", this._updateOverlay), this._qrEnginePromise = _a.createQrEngine();
  }
  static set WORKER_PATH(a2) {
    console.warn("Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.");
  }
  static async hasCamera() {
    try {
      return !!(await _a.listCameras(!1)).length;
    } catch {
      return !1;
    }
  }
  static async listCameras(a2 = !1) {
    if (!navigator.mediaDevices)
      return [];
    let b2 = /* @__PURE__ */ __name(async () => (await navigator.mediaDevices.enumerateDevices()).filter((d2) => d2.kind === "videoinput"), "b"), c2;
    try {
      a2 && (await b2()).every((d2) => !d2.label) && (c2 = await navigator.mediaDevices.getUserMedia({ audio: !1, video: !0 }));
    } catch {
    }
    try {
      return (await b2()).map((d2, f2) => ({ id: d2.deviceId, label: d2.label || (f2 === 0 ? "Default Camera" : `Camera ${f2 + 1}`) }));
    } finally {
      c2 && (console.warn("Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"), _a._stopVideoStream(c2));
    }
  }
  async hasFlash() {
    let a2;
    try {
      if (this.$video.srcObject) {
        if (!(this.$video.srcObject instanceof MediaStream))
          return !1;
        a2 = this.$video.srcObject;
      } else
        a2 = (await this._getCameraStream()).stream;
      return "torch" in a2.getVideoTracks()[0].getSettings();
    } catch {
      return !1;
    } finally {
      a2 && a2 !== this.$video.srcObject && (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), _a._stopVideoStream(a2));
    }
  }
  isFlashOn() {
    return this._flashOn;
  }
  async toggleFlash() {
    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();
  }
  async turnFlashOn() {
    if (!this._flashOn && !this._destroyed && (this._flashOn = !0, this._active && !this._paused))
      try {
        if (!await this.hasFlash())
          throw "No flash available";
        await this.$video.srcObject.getVideoTracks()[0].applyConstraints({ advanced: [{ torch: !0 }] });
      } catch (a2) {
        throw this._flashOn = !1, a2;
      }
  }
  async turnFlashOff() {
    this._flashOn && (this._flashOn = !1, await this._restartVideoStream());
  }
  destroy() {
    this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData), this.$video.removeEventListener("play", this._onPlay), document.removeEventListener(
      "visibilitychange",
      this._onVisibilityChange
    ), window.removeEventListener("resize", this._updateOverlay), this._destroyed = !0, this._flashOn = !1, this.stop(), _a._postWorkerMessage(this._qrEnginePromise, "close");
  }
  async start() {
    if (this._destroyed)
      throw Error("The QR scanner can not be started as it had been destroyed.");
    if ((!this._active || this._paused) && (window.location.protocol !== "https:" && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = !0, !document.hidden))
      if (this._paused = !1, this.$video.srcObject)
        await this.$video.play();
      else
        try {
          let { stream: a2, facingMode: b2 } = await this._getCameraStream();
          !this._active || this._paused ? _a._stopVideoStream(a2) : (this._setVideoMirror(b2), this.$video.srcObject = a2, await this.$video.play(), this._flashOn && (this._flashOn = !1, this.turnFlashOn().catch(() => {
          })));
        } catch (a2) {
          if (!this._paused)
            throw this._active = !1, a2;
        }
  }
  stop() {
    this.pause(), this._active = !1;
  }
  async pause(a2 = !1) {
    if (this._paused = !0, !this._active)
      return !0;
    this.$video.pause(), this.$overlay && (this.$overlay.style.display = "none");
    let b2 = /* @__PURE__ */ __name(() => {
      this.$video.srcObject instanceof MediaStream && (_a._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);
    }, "b");
    return a2 ? (b2(), !0) : (await new Promise((c2) => setTimeout(c2, 300)), this._paused ? (b2(), !0) : !1);
  }
  async setCamera(a2) {
    a2 !== this._preferredCamera && (this._preferredCamera = a2, await this._restartVideoStream());
  }
  static async scanImage(a2, b2, c2, d2, f2 = !1, h2 = !1) {
    let m2, n2 = !1;
    b2 && ("scanRegion" in b2 || "qrEngine" in b2 || "canvas" in b2 || "disallowCanvasResizing" in b2 || "alsoTryWithoutScanRegion" in b2 || "returnDetailedScanResult" in b2) ? (m2 = b2.scanRegion, c2 = b2.qrEngine, d2 = b2.canvas, f2 = b2.disallowCanvasResizing || !1, h2 = b2.alsoTryWithoutScanRegion || !1, n2 = !0) : console.warn(b2 || c2 || d2 || f2 || h2 ? "You're using a deprecated api for scanImage which will be removed in the future." : "Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), b2 = !!c2;
    try {
      let p2, k2;
      [c2, p2] = await Promise.all([c2 || _a.createQrEngine(), _a._loadImage(a2)]), [d2, k2] = _a._drawToCanvas(p2, m2, d2, f2);
      let q2;
      if (c2 instanceof Worker) {
        let g2 = c2;
        b2 || _a._postWorkerMessageSync(g2, "inversionMode", "both"), q2 = await new Promise((l2, v2) => {
          let w2, u2, r2, y2 = -1;
          u2 = /* @__PURE__ */ __name((t2) => {
            t2.data.id === y2 && (g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), t2.data.data !== null ? l2({ data: t2.data.data, cornerPoints: _a._convertPoints(t2.data.cornerPoints, m2) }) : v2(_a.NO_QR_CODE_FOUND));
          }, "u"), r2 = /* @__PURE__ */ __name((t2) => {
            g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), v2("Scanner error: " + (t2 ? t2.message || t2 : "Unknown Error"));
          }, "r"), g2.addEventListener("message", u2), g2.addEventListener("error", r2), w2 = setTimeout(() => r2("timeout"), 1e4);
          let x2 = k2.getImageData(0, 0, d2.width, d2.height);
          y2 = _a._postWorkerMessageSync(g2, "decode", x2, [x2.data.buffer]);
        });
      } else
        q2 = await Promise.race([new Promise((g2, l2) => window.setTimeout(() => l2("Scanner error: timeout"), 1e4)), (async () => {
          try {
            var [g2] = await c2.detect(d2);
            if (!g2)
              throw _a.NO_QR_CODE_FOUND;
            return { data: g2.rawValue, cornerPoints: _a._convertPoints(g2.cornerPoints, m2) };
          } catch (l2) {
            if (g2 = l2.message || l2, /not implemented|service unavailable/.test(g2))
              return _a._disableBarcodeDetector = !0, _a.scanImage(a2, { scanRegion: m2, canvas: d2, disallowCanvasResizing: f2, alsoTryWithoutScanRegion: h2 });
            throw `Scanner error: ${g2}`;
          }
        })()]);
      return n2 ? q2 : q2.data;
    } catch (p2) {
      if (!m2 || !h2)
        throw p2;
      let k2 = await _a.scanImage(a2, { qrEngine: c2, canvas: d2, disallowCanvasResizing: f2 });
      return n2 ? k2 : k2.data;
    } finally {
      b2 || _a._postWorkerMessage(c2, "close");
    }
  }
  setGrayscaleWeights(a2, b2, c2, d2 = !0) {
    _a._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
      red: a2,
      green: b2,
      blue: c2,
      useIntegerApproximation: d2
    });
  }
  setInversionMode(a2) {
    _a._postWorkerMessage(this._qrEnginePromise, "inversionMode", a2);
  }
  static async createQrEngine(a2) {
    if (a2 && console.warn("Specifying a worker path is not required and not supported anymore."), a2 = /* @__PURE__ */ __name(() => __vitePreload(() => import("./qr-scanner-worker.min.js"), [], import.meta.url).then((c2) => c2.createWorker()), "a"), !(!_a._disableBarcodeDetector && "BarcodeDetector" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes("qr_code")))
      return a2();
    let b2 = navigator.userAgentData;
    return b2 && b2.brands.some(({ brand: c2 }) => /Chromium/i.test(c2)) && /mac ?OS/i.test(b2.platform) && await b2.getHighEntropyValues(["architecture", "platformVersion"]).then(({ architecture: c2, platformVersion: d2 }) => /arm/i.test(c2 || "arm") && 13 <= parseInt(d2 || "13")).catch(() => !0) ? a2() : new BarcodeDetector({ formats: ["qr_code"] });
  }
  _onPlay() {
    this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay(), this.$overlay && (this.$overlay.style.display = ""), this._scanFrame();
  }
  _onLoadedMetaData() {
    this._scanRegion = this._calculateScanRegion(this.$video), this._updateOverlay();
  }
  _onVisibilityChange() {
    document.hidden ? this.pause() : this._active && this.start();
  }
  _calculateScanRegion(a2) {
    let b2 = Math.round(0.6666666666666666 * Math.min(a2.videoWidth, a2.videoHeight));
    return { x: Math.round((a2.videoWidth - b2) / 2), y: Math.round((a2.videoHeight - b2) / 2), width: b2, height: b2, downScaledWidth: this._legacyCanvasSize, downScaledHeight: this._legacyCanvasSize };
  }
  _updateOverlay() {
    requestAnimationFrame(() => {
      if (this.$overlay) {
        var a2 = this.$video, b2 = a2.videoWidth, c2 = a2.videoHeight, d2 = a2.offsetWidth, f2 = a2.offsetHeight, h2 = a2.offsetLeft, m2 = a2.offsetTop, n2 = window.getComputedStyle(a2), p2 = n2.objectFit, k2 = b2 / c2, q2 = d2 / f2;
        switch (p2) {
          case "none":
            var g2 = b2, l2 = c2;
            break;
          case "fill":
            g2 = d2, l2 = f2;
            break;
          default:
            (p2 === "cover" ? k2 > q2 : k2 < q2) ? (l2 = f2, g2 = l2 * k2) : (g2 = d2, l2 = g2 / k2), p2 === "scale-down" && (g2 = Math.min(g2, b2), l2 = Math.min(l2, c2));
        }
        var [v2, w2] = n2.objectPosition.split(" ").map((r2, y2) => {
          const x2 = parseFloat(r2);
          return r2.endsWith("%") ? (y2 ? f2 - l2 : d2 - g2) * x2 / 100 : x2;
        });
        n2 = this._scanRegion.width || b2, q2 = this._scanRegion.height || c2, p2 = this._scanRegion.x || 0;
        var u2 = this._scanRegion.y || 0;
        k2 = this.$overlay.style, k2.width = `${n2 / b2 * g2}px`, k2.height = `${q2 / c2 * l2}px`, k2.top = `${m2 + w2 + u2 / c2 * l2}px`, c2 = /scaleX\(-1\)/.test(a2.style.transform), k2.left = `${h2 + (c2 ? d2 - v2 - g2 : v2) + (c2 ? b2 - p2 - n2 : p2) / b2 * g2}px`, k2.transform = a2.style.transform;
      }
    });
  }
  static _convertPoints(a2, b2) {
    if (!b2)
      return a2;
    let c2 = b2.x || 0, d2 = b2.y || 0, f2 = b2.width && b2.downScaledWidth ? b2.width / b2.downScaledWidth : 1;
    b2 = b2.height && b2.downScaledHeight ? b2.height / b2.downScaledHeight : 1;
    for (let h2 of a2)
      h2.x = h2.x * f2 + c2, h2.y = h2.y * b2 + d2;
    return a2;
  }
  _scanFrame() {
    !this._active || this.$video.paused || this.$video.ended || ("requestVideoFrameCallback" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {
      if (!(1 >= this.$video.readyState)) {
        var a2 = Date.now() - this._lastScanTimestamp, b2 = 1e3 / this._maxScansPerSecond;
        a2 < b2 && await new Promise((d2) => setTimeout(d2, b2 - a2)), this._lastScanTimestamp = Date.now();
        try {
          var c2 = await _a.scanImage(this.$video, { scanRegion: this._scanRegion, qrEngine: this._qrEnginePromise, canvas: this.$canvas });
        } catch (d2) {
          if (!this._active)
            return;
          this._onDecodeError(d2);
        }
        !_a._disableBarcodeDetector || await this._qrEnginePromise instanceof Worker || (this._qrEnginePromise = _a.createQrEngine()), c2 ? (this._onDecode ? this._onDecode(c2) : this._legacyOnDecode && this._legacyOnDecode(c2.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute("viewBox", `${this._scanRegion.x || 0} ${this._scanRegion.y || 0} ${this._scanRegion.width || this.$video.videoWidth} ${this._scanRegion.height || this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute(
          "points",
          c2.cornerPoints.map(({ x: d2, y: f2 }) => `${d2},${f2}`).join(" ")
        ), this.$codeOutlineHighlight.style.display = "")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = "none", 100));
      }
      this._scanFrame();
    });
  }
  _onDecodeError(a2) {
    a2 !== _a.NO_QR_CODE_FOUND && console.log(a2);
  }
  async _getCameraStream() {
    if (!navigator.mediaDevices)
      throw "Camera not found.";
    let a2 = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId", b2 = [{ width: { min: 1024 } }, { width: { min: 768 } }, {}], c2 = b2.map((d2) => Object.assign({}, d2, { [a2]: { exact: this._preferredCamera } }));
    for (let d2 of [...c2, ...b2])
      try {
        let f2 = await navigator.mediaDevices.getUserMedia({ video: d2, audio: !1 }), h2 = this._getFacingMode(f2) || (d2.facingMode ? this._preferredCamera : this._preferredCamera === "environment" ? "user" : "environment");
        return { stream: f2, facingMode: h2 };
      } catch {
      }
    throw "Camera not found.";
  }
  async _restartVideoStream() {
    let a2 = this._paused;
    await this.pause(!0) && !a2 && this._active && await this.start();
  }
  static _stopVideoStream(a2) {
    for (let b2 of a2.getTracks())
      b2.stop(), a2.removeTrack(b2);
  }
  _setVideoMirror(a2) {
    this.$video.style.transform = "scaleX(" + (a2 === "user" ? -1 : 1) + ")";
  }
  _getFacingMode(a2) {
    return (a2 = a2.getVideoTracks()[0]) ? /rear|back|environment/i.test(a2.label) ? "environment" : /front|user|face/i.test(a2.label) ? "user" : null : null;
  }
  static _drawToCanvas(a2, b2, c2, d2 = !1) {
    c2 = c2 || document.createElement("canvas");
    let f2 = b2 && b2.x ? b2.x : 0, h2 = b2 && b2.y ? b2.y : 0, m2 = b2 && b2.width ? b2.width : a2.videoWidth || a2.width, n2 = b2 && b2.height ? b2.height : a2.videoHeight || a2.height;
    return d2 || (d2 = b2 && b2.downScaledWidth ? b2.downScaledWidth : m2, b2 = b2 && b2.downScaledHeight ? b2.downScaledHeight : n2, c2.width !== d2 && (c2.width = d2), c2.height !== b2 && (c2.height = b2)), b2 = c2.getContext("2d", { alpha: !1 }), b2.imageSmoothingEnabled = !1, b2.drawImage(a2, f2, h2, m2, n2, 0, 0, c2.width, c2.height), [c2, b2];
  }
  static async _loadImage(a2) {
    if (a2 instanceof Image)
      return await _a._awaitImageLoad(a2), a2;
    if (a2 instanceof HTMLVideoElement || a2 instanceof HTMLCanvasElement || a2 instanceof SVGImageElement || "OffscreenCanvas" in window && a2 instanceof OffscreenCanvas || "ImageBitmap" in window && a2 instanceof ImageBitmap)
      return a2;
    if (a2 instanceof File || a2 instanceof Blob || a2 instanceof URL || typeof a2 == "string") {
      let b2 = new Image();
      b2.src = a2 instanceof File || a2 instanceof Blob ? URL.createObjectURL(a2) : a2.toString();
      try {
        return await _a._awaitImageLoad(b2), b2;
      } finally {
        (a2 instanceof File || a2 instanceof Blob) && URL.revokeObjectURL(b2.src);
      }
    } else
      throw "Unsupported image type.";
  }
  static async _awaitImageLoad(a2) {
    a2.complete && a2.naturalWidth !== 0 || await new Promise((b2, c2) => {
      let d2 = /* @__PURE__ */ __name((f2) => {
        a2.removeEventListener("load", d2), a2.removeEventListener("error", d2), f2 instanceof ErrorEvent ? c2("Image load error") : b2();
      }, "d");
      a2.addEventListener("load", d2), a2.addEventListener("error", d2);
    });
  }
  static async _postWorkerMessage(a2, b2, c2, d2) {
    return _a._postWorkerMessageSync(await a2, b2, c2, d2);
  }
  static _postWorkerMessageSync(a2, b2, c2, d2) {
    if (!(a2 instanceof Worker))
      return -1;
    let f2 = _a._workerMessageId++;
    return a2.postMessage({ id: f2, type: b2, data: c2 }, d2), f2;
  }
}, __name(_a, "e"), _a);
e$1.DEFAULT_CANVAS_SIZE = 400;
e$1.NO_QR_CODE_FOUND = "No QR code found";
e$1._disableBarcodeDetector = !1;
e$1._workerMessageId = 0;
const useQRScanner = /* @__PURE__ */ __name((videoRef, {
  onStart,
  onResult,
  onError
}) => {
  reactExports.useEffect(() => {
    const scannerPromise = (/* @__PURE__ */ __name(async () => {
      const scanner = videoRef.current && new e$1(
        videoRef.current,
        (result) => {
          scanner == null || scanner.stop(), onResult(result);
        },
        {
          onDecodeError: onError,
          highlightScanRegion: !0,
          highlightCodeOutline: !0
        }
      );
      try {
        await (scanner == null ? void 0 : scanner.start()), onStart && onStart();
      } catch (error3) {
        console.error(error3);
      }
      return () => {
        scanner == null || scanner.stop(), scanner == null || scanner.destroy();
      };
    }, "startScanner"))();
    return () => {
      scannerPromise.then((cleanupFunc) => cleanupFunc());
    };
  }, [videoRef, onStart, onResult, onError]);
}, "useQRScanner"), spinnerAnimationContainer = "_spinnerAnimationContainer_18sha_1", qrVideo = "_qrVideo_18sha_10", style$s = {
  spinnerAnimationContainer,
  qrVideo
}, ScanQRVideo = /* @__PURE__ */ __name(({
  onResult
}) => {
  const videoRef = reactExports.useRef(null);
  return useQRScanner(videoRef, {
    onResult: (result) => onResult(result.data),
    onError: console.error
  }), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$s.spinnerAnimationContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        className: style$s.qrVideo,
        ref: videoRef,
        poster: "%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%20width=%2264%22%20height=%2248%22%3E%3C/svg%3E"
      }
    )
  ] });
}, "ScanQRVideo"), ScanQRDialog = /* @__PURE__ */ __name(({ parseQRResult, activeScanQR, toggleScanQR, onChangeActiveScanQR }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      large: !0,
      open: activeScanQR,
      title: t2("send.scanQR"),
      onClose: toggleScanQR,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ScanQRVideo,
          {
            onResult: (result) => {
              parseQRResult(result), onChangeActiveScanQR(!1);
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: toggleScanQR,
            children: t2("button.back")
          }
        ) })
      ]
    }
  );
}, "ScanQRDialog"), inputWithIcon$1 = "_inputWithIcon_drrz7_1", action$2 = "_action_drrz7_9", qrButton = "_qrButton_drrz7_18", style$r = {
  inputWithIcon: inputWithIcon$1,
  action: action$2,
  qrButton
}, ScanQRButton = /* @__PURE__ */ __name(({ onClick }) => {
  const { isDarkMode } = reactExports.useContext(DarkModeContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick, className: style$r.qrButton, children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeDark, {}) });
}, "ScanQRButton"), ReceiverAddressInput = /* @__PURE__ */ __name(({
  accountCode,
  addressError,
  onInputChange,
  recipientAddress,
  activeScanQR,
  parseQRResult,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation(), toggleScanQR = /* @__PURE__ */ __name(() => {
    if (activeScanQR) {
      onChangeActiveScanQR(!1);
      return;
    }
    onChangeActiveScanQR(!0);
  }, "toggleScanQR");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScanQRDialog,
      {
        activeScanQR,
        toggleScanQR,
        onChangeActiveScanQR,
        parseQRResult
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.address.label"),
        placeholder: t2("send.address.placeholder"),
        id: "recipientAddress",
        error: addressError,
        onInput: (e2) => onInputChange(e2.target.value),
        value: recipientAddress,
        className: style$r.inputWithIcon,
        labelSection: void 0,
        autoFocus: !0,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
      }
    )
  ] });
}, "ReceiverAddressInput"), maxAmount = "_maxAmount_1t5n0_1", style$q = {
  maxAmount
}, CoinInput = /* @__PURE__ */ __name(({
  balance: balance2,
  onAmountChange,
  onSendAllChange,
  sendAll,
  amountError,
  proposedAmount,
  amount: amount2,
  hasSelectedUTXOs
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: balance2 ? balance2.available.unit : t2("send.amount.label"),
      id: "amount",
      onInput: (e2) => onAmountChange(e2.target.value),
      disabled: sendAll,
      error: amountError,
      value: sendAll ? proposedAmount ? proposedAmount.amount : "" : amount2,
      placeholder: t2("send.amount.placeholder"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          label: t2(hasSelectedUTXOs ? "send.maximumSelectedCoins" : "send.maximum"),
          id: "sendAll",
          onChange: (e2) => onSendAllChange(e2.target.checked),
          checked: sendAll,
          className: style$q.maxAmount
        }
      )
    }
  );
}, "CoinInput"), FiatInput = /* @__PURE__ */ __name(({ label: label2, onFiatChange, disabled: disabled2, error: error3, fiatAmount }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: label2,
      id: "fiatAmount",
      onInput: onFiatChange,
      disabled: disabled2,
      error: error3,
      value: fiatAmount,
      placeholder: t2("send.amount.placeholder")
    }
  );
}, "FiatInput"), labelDescription = "_labelDescription_5etm5_1", style$p = {
  labelDescription
}, NoteInput = /* @__PURE__ */ __name(({ onNoteChange, note: note2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      label: t2("note.title"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.labelDescription, children: t2("note.input.description") }),
      id: "note",
      onInput: onNoteChange,
      value: note2,
      placeholder: t2("note.input.placeholder")
    }
  );
}, "NoteInput"), container$f = "_container_8f83b_1", style$o = {
  container: container$f
}, _Send = class _Send extends reactExports.Component {
  constructor() {
    super(...arguments), this.selectedUTXOs = {}, this.unsubscribeList = [], this.pendingProposals = [], this.proposeTimeout = null, this.state = {
      recipientAddress: "",
      amount: "",
      fiatAmount: "",
      valid: !1,
      sendAll: !1,
      isConfirming: !1,
      signConfirm: !1,
      isSent: !1,
      isAborted: !1,
      isUpdatingProposal: !1,
      noMobileChannelError: !1,
      fiatUnit: this.props.activeCurrency,
      coinControl: !1,
      btcUnit: "default",
      activeCoinControl: !1,
      activeScanQR: !1,
      note: "",
      customFee: ""
    }, this.isBitcoinBased = () => {
      const account2 = this.getAccount();
      return account2 ? isBitcoinBased(account2.coinCode) : !1;
    }, this.registerEvents = () => {
      document.addEventListener("keydown", this.handleKeyDown);
    }, this.unregisterEvents = () => {
      document.removeEventListener("keydown", this.handleKeyDown);
    }, this.handleKeyDown = (e2) => {
      e2.keyCode === 27 && !this.state.activeCoinControl && !this.state.activeScanQR && route(`/account/${this.props.code}`);
    }, this.send = async () => {
      if (this.state.noMobileChannelError) {
        alertUser(this.props.t("warning.sendPairing"));
        return;
      }
      const code = this.getAccount().code;
      if ((await connectKeystore(code)).success) {
        this.setState({ signProgress: void 0, isConfirming: !0 });
        try {
          const result = await sendTx(code);
          if (result.success)
            this.setState({
              sendAll: !1,
              isConfirming: !1,
              isSent: !0,
              recipientAddress: "",
              proposedAmount: void 0,
              proposedFee: void 0,
              proposedTotal: void 0,
              fiatAmount: "",
              amount: "",
              note: "",
              customFee: ""
            }), this.selectedUTXOs = {}, setTimeout(() => this.setState({
              isSent: !1,
              isConfirming: !1
            }), 5e3);
          else if (result.aborted)
            this.setState({ isAborted: !0 }), setTimeout(() => this.setState({ isAborted: !1 }), 5e3);
          else
            switch (result.errorCode) {
              case "erc20InsufficientGasFunds":
                alertUser(this.props.t(`send.error.${result.errorCode}`));
                break;
              default:
                const { errorMessage } = result;
                alertUser(this.props.t("unknownError", errorMessage && { errorMessage }));
            }
        } catch (err) {
          console.error(err);
        } finally {
          this.setState({ isConfirming: !1, signProgress: void 0, signConfirm: !1 });
        }
      }
    }, this.txInput = () => ({
      address: this.state.recipientAddress,
      amount: this.state.amount,
      feeTarget: this.state.feeTarget || "",
      customFee: this.state.customFee,
      sendAll: this.state.sendAll ? "yes" : "no",
      selectedUTXOs: Object.keys(this.selectedUTXOs)
    }), this.sendDisabled = () => {
      const txInput = this.txInput();
      return !txInput.address || this.state.feeTarget === void 0 || txInput.sendAll === "no" && !txInput.amount || this.state.feeTarget === "custom" && !this.state.customFee;
    }, this.validateAndDisplayFee = (updateFiat = !0) => {
      if (this.setState({
        proposedTotal: void 0,
        addressError: void 0,
        amountError: void 0,
        feeError: void 0
      }), this.sendDisabled())
        return;
      const txInput = this.txInput();
      this.proposeTimeout && (clearTimeout(this.proposeTimeout), this.proposeTimeout = null), this.setState({ isUpdatingProposal: !0 }), this.proposeTimeout = setTimeout(() => {
        const propose = apiPost("account/" + this.getAccount().code + "/tx-proposal", txInput).then((result) => {
          const pos = this.pendingProposals.indexOf(propose);
          this.pendingProposals.length - 1 === pos && this.txProposal(updateFiat, result), this.pendingProposals.splice(pos, 1);
        }).catch(() => {
          this.setState({ valid: !1 }), this.pendingProposals.splice(this.pendingProposals.indexOf(propose), 1);
        });
        this.pendingProposals.push(propose);
      }, 400);
    }, this.handleNoteInput = (event2) => {
      const target = event2.target;
      this.setState({
        note: target.value
      }, () => {
        proposeTxNote(this.getAccount().code, this.state.note);
      });
    }, this.txProposal = (updateFiat, result) => {
      if (this.setState({ valid: result.success }), result.success)
        this.setState({
          addressError: void 0,
          amountError: void 0,
          feeError: void 0,
          proposedFee: result.fee,
          proposedAmount: result.amount,
          proposedTotal: result.total,
          isUpdatingProposal: !1
        }), updateFiat && this.convertToFiat(result.amount.amount);
      else {
        const errorHandling = txProposalErrorHandling(this.registerEvents, this.unregisterEvents, result.errorCode);
        this.setState({ ...errorHandling, isUpdatingProposal: !1 });
      }
    }, this.handleFiatInput = (event2) => {
      const value = event2.target.value;
      this.setState({ fiatAmount: value }), this.convertFromFiat(value);
    }, this.convertToFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-to-plain-fiat?from=${coinCode}&to=${this.state.fiatUnit}&amount=${value}`).then((data) => {
          data.success ? this.setState({ fiatAmount: data.fiatAmount }) : this.setState({ amountError: this.props.t("send.error.invalidAmount") });
        });
      } else
        this.setState({ fiatAmount: "" });
    }, this.convertFromFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-from-fiat?from=${this.state.fiatUnit}&to=${coinCode}&amount=${value}`).then((data) => {
          data.success ? this.setState({ amount: data.amount }, () => this.validateAndDisplayFee(!1)) : this.setState({ amountError: this.props.t("send.error.invalidAmount") });
        });
      } else
        this.setState({ amount: "" });
    }, this.feeTargetChange = (feeTarget) => {
      this.setState(
        { feeTarget, customFee: "" },
        () => this.validateAndDisplayFee(this.state.sendAll)
      );
    }, this.onSelectedUTXOsChange = (selectedUTXOs) => {
      this.selectedUTXOs = selectedUTXOs, this.validateAndDisplayFee(!0);
    }, this.hasSelectedUTXOs = () => Object.keys(this.selectedUTXOs).length !== 0, this.getAccount = () => {
      if (this.props.code)
        return findAccount(this.props.accounts, this.props.code);
    }, this.toggleCoinControl = () => {
      this.setState(({ activeCoinControl }) => (activeCoinControl && (this.selectedUTXOs = {}), { activeCoinControl: !activeCoinControl }));
    }, this.setActiveScanQR = (activeScanQR) => {
      this.setState({ activeScanQR });
    }, this.parseQRResult = async (uri) => {
      let address2, amount2 = "";
      try {
        const url = new URL(uri);
        if (url.protocol !== "bitcoin:" && url.protocol !== "litecoin:" && url.protocol !== "ethereum:") {
          alertUser(this.props.t("invalidFormat"));
          return;
        }
        address2 = url.pathname, this.isBitcoinBased() && (amount2 = url.searchParams.get("amount") || "");
      } catch {
        address2 = uri;
      }
      let updateState = {
        recipientAddress: address2,
        sendAll: !1,
        fiatAmount: ""
      };
      const coinCode = this.getAccount().coinCode;
      if (amount2)
        if (coinCode === "btc" || coinCode === "tbtc") {
          const result = await parseExternalBtcAmount(amount2);
          if (result.success)
            updateState.amount = result.amount;
          else {
            updateState.amountError = this.props.t("send.error.invalidAmount"), this.setState(updateState);
            return;
          }
        } else
          updateState.amount = amount2;
      this.setState(updateState, () => {
        this.convertToFiat(this.state.amount), this.validateAndDisplayFee(!0);
      });
    }, this.deactivateCoinControl = () => {
      this.setState({ activeCoinControl: !1 });
    }, this.onReceiverAddressInputChange = (recipientAddress) => {
      this.setState({ recipientAddress }, () => {
        this.validateAndDisplayFee(!0);
      });
    }, this.onCoinAmountChange = (amount2) => {
      this.convertToFiat(amount2), this.setState({ amount: amount2 }, () => {
        this.validateAndDisplayFee(!0);
      });
    }, this.onSendAllChange = (sendAll) => {
      sendAll || this.convertToFiat(this.state.amount), this.setState({ sendAll }, () => {
        this.validateAndDisplayFee(!0);
      });
    };
  }
  componentDidMount() {
    this.props.code && getBalance(this.props.code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error), this.props.deviceIDs.length > 0 && this.props.devices[this.props.deviceIDs[0]] === "bitbox" && apiGet("devices/" + this.props.deviceIDs[0] + "/has-mobile-channel").then((mobileChannel) => {
      getDeviceInfo$1(this.props.deviceIDs[0]).then(({ pairing: pairing2 }) => {
        const account2 = this.getAccount(), paired = mobileChannel && pairing2, noMobileChannelError = pairing2 && !mobileChannel && account2 && isBitcoinBased(account2.coinCode);
        this.setState((prevState) => ({ ...prevState, paired, noMobileChannelError }));
      });
    }), apiGet("config").then((config) => {
      this.setState({ btcUnit: config.backend.btcUnit }), this.isBitcoinBased() && this.setState({ coinControl: !!(config.frontend || {}).coinControl });
    }), this.unsubscribeList = [
      apiWebsocket((payload) => {
        if ("type" in payload) {
          const { data, meta, type: type2 } = payload;
          switch (type2) {
            case "device":
              switch (data) {
                case "signProgress":
                  this.setState({ signProgress: meta, signConfirm: !1 });
                  break;
                case "signConfirm":
                  this.setState({ signConfirm: !0 });
                  break;
              }
              break;
          }
        }
      }),
      syncdone((code) => {
        this.props.code === code && getBalance(code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error);
      })
    ];
  }
  UNSAFE_componentWillMount() {
    this.registerEvents();
  }
  componentWillUnmount() {
    this.unregisterEvents(), unsubscribe(this.unsubscribeList);
  }
  render() {
    var _a46;
    const { t: t2, code } = this.props, {
      balance: balance2,
      proposedFee,
      proposedTotal,
      recipientAddress,
      proposedAmount,
      valid,
      amount: amount2,
      /* data, */
      fiatAmount,
      fiatUnit,
      sendAll,
      feeTarget,
      customFee,
      isConfirming,
      isSent,
      isAborted,
      isUpdatingProposal,
      addressError,
      amountError,
      feeError,
      paired,
      signProgress,
      signConfirm,
      coinControl,
      btcUnit,
      activeCoinControl,
      activeScanQR,
      note: note2
    } = this.state, waitDialogTransactionDetails = {
      proposedFee,
      proposedAmount,
      proposedTotal,
      customFee,
      feeTarget,
      recipientAddress,
      fiatUnit
    }, waitDialogTransactionStatus = {
      isConfirming,
      signProgress,
      signConfirm
    }, account2 = this.getAccount();
    if (!account2)
      return null;
    const baseCurrencyUnit = fiatUnit === "BTC" && btcUnit === "sat" ? "sat" : fiatUnit;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== !1, children: t2("warning.sendPairing") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SharedHeader,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("send.title", { accountName: account2.coinName }) }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.availableBalance") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2, noRotateFiat: !0 }),
            coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              UTXOs,
              {
                accountCode: account2.code,
                active: activeCoinControl,
                explorerURL: account2.blockExplorerTxPrefix,
                onClose: this.deactivateCoinControl,
                onChange: this.onSelectedUTXOsChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-row flex-between ${style$o.container}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.transactionDetails") }),
              coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: "m-bottom-quarter p-right-none",
                  transparent: !0,
                  onClick: this.toggleCoinControl,
                  children: t2("send.toggleCoinControl")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ReceiverAddressInput,
              {
                accountCode: (_a46 = this.getAccount()) == null ? void 0 : _a46.code,
                addressError,
                onInputChange: this.onReceiverAddressInputChange,
                recipientAddress,
                parseQRResult: this.parseQRResult,
                activeScanQR,
                onChangeActiveScanQR: this.setActiveScanQR
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CoinInput,
                {
                  balance: balance2,
                  onAmountChange: this.onCoinAmountChange,
                  onSendAllChange: this.onSendAllChange,
                  sendAll,
                  amountError,
                  proposedAmount,
                  amount: amount2,
                  hasSelectedUTXOs: this.hasSelectedUTXOs()
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FiatInput,
                {
                  onFiatChange: this.handleFiatInput,
                  disabled: sendAll,
                  error: amountError,
                  fiatAmount,
                  label: baseCurrencyUnit
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                TranslatedFeeTargets,
                {
                  accountCode: account2.code,
                  coinCode: account2.coinCode,
                  disabled: !amount2 && !sendAll,
                  fiatUnit: baseCurrencyUnit,
                  proposedFee,
                  customFee,
                  showCalculatingFeeLabel: isUpdatingProposal,
                  onFeeTargetChange: this.feeTargetChange,
                  onCustomFee: (customFee2) => this.setState({ customFee: customFee2 }, this.validateAndDisplayFee),
                  error: feeError
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NoteInput,
                  {
                    note: note2,
                    onNoteChange: this.handleNoteInput
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  ColumnButtons,
                  {
                    className: "m-top-default m-bottom-xlarge",
                    inline: !0,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          primary: !0,
                          onClick: this.send,
                          disabled: this.sendDisabled() || !valid || isUpdatingProposal,
                          children: t2("send.button")
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ButtonLink,
                        {
                          secondary: !0,
                          to: `/account/${code}`,
                          children: t2("button.back")
                        }
                      )
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConfirmingWaitDialog,
            {
              paired,
              baseCurrencyUnit,
              note: note2,
              hasSelectedUTXOs: this.hasSelectedUTXOs(),
              selectedUTXOs: Object.keys(this.selectedUTXOs),
              coinCode: account2.coinCode,
              transactionDetails: waitDialogTransactionDetails,
              transactionStatus: waitDialogTransactionStatus
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isSent, messageType: "sent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isAborted, messageType: "abort" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SendGuide, { coinCode: account2.coinCode })
    ] });
  }
};
__name(_Send, "Send");
let Send = _Send;
const TranslatedSend = translate()(Send), SendWrapper = /* @__PURE__ */ __name(({ accounts, code, deviceIDs, devices }) => {
  const { defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedSend,
    {
      accounts,
      code,
      devices,
      deviceIDs,
      activeCurrency: defaultCurrency2
    }
  );
}, "SendWrapper"), errUserAbort = 104, resetDevice = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/reset`), "resetDevice"), getDeviceInfo = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/info`), "getDeviceInfo"), checkSDCard = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/check-sdcard`), "checkSDCard"), insertSDCard = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/insert-sdcard`), "insertSDCard"), setDeviceName = /* @__PURE__ */ __name((deviceID, newDeviceName) => apiPost(`devices/bitbox02/${deviceID}/set-device-name`, {
  name: newDeviceName
}), "setDeviceName"), getVersion = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/version`), "getVersion"), setMnemonicPassphraseEnabled = /* @__PURE__ */ __name((deviceID, enabled) => apiPost(`devices/bitbox02/${deviceID}/set-mnemonic-passphrase-enabled`, enabled), "setMnemonicPassphraseEnabled"), verifyAttestation = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/attestation`), "verifyAttestation"), checkBackup = /* @__PURE__ */ __name((deviceID, silent) => apiPost(`devices/bitbox02/${deviceID}/backups/check`, { silent }), "checkBackup"), createBackup = /* @__PURE__ */ __name((deviceID, method) => apiPost(`devices/bitbox02/${deviceID}/backups/create`, method), "createBackup"), restoreBackup = /* @__PURE__ */ __name((deviceID, selectedBackup) => apiPost(`devices/bitbox02/${deviceID}/backups/restore`, selectedBackup), "restoreBackup"), upgradeDeviceFirmware = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/upgrade-firmware`), "upgradeDeviceFirmware"), showMnemonic = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/show-mnemonic`), "showMnemonic"), restoreFromMnemonic = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02/${deviceID}/restore-from-mnemonic`), "restoreFromMnemonic"), getStatus$1 = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/status`), "getStatus$1"), getChannelHash = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/channel-hash`), "getChannelHash"), verifyChannelHash = /* @__PURE__ */ __name((deviceID, ok2) => apiPost(`devices/bitbox02/${deviceID}/channel-hash-verify`, ok2), "verifyChannelHash"), setPassword = /* @__PURE__ */ __name((deviceID, seedLen) => apiPost(`devices/bitbox02/${deviceID}/set-password`, seedLen), "setPassword"), getRootFingerprint = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/root-fingerprint`), "getRootFingerprint"), useSDCard = /* @__PURE__ */ __name((devices, dependencies) => {
  const [sdcard, setSDCard] = reactExports.useState(!1), mounted = useMountedRef();
  return reactExports.useEffect(() => {
    const deviceIDs = Object.keys(devices);
    Promise.all(deviceIDs.map((deviceID) => {
      switch (devices[deviceID]) {
        case "bitbox":
          return getDeviceInfo$1(deviceID).then(({ sdcard: sdcard2 }) => sdcard2);
        case "bitbox02":
          return checkSDCard(deviceID);
        default:
          return !1;
      }
    })).then((sdcards) => sdcards.some((sdcard2) => sdcard2)).then((result) => {
      mounted.current && setSDCard(result);
    }).catch(console.error);
  }, [devices, ...dependencies || []]), sdcard;
}, "useSDCard");
function size(_a46) {
  var width = _a46.width, height = _a46.height;
  if (width < 0)
    throw new Error("Negative width is not allowed for Size");
  if (height < 0)
    throw new Error("Negative height is not allowed for Size");
  return {
    width,
    height
  };
}
__name(size, "size");
function equalSizes(first2, second) {
  return first2.width === second.width && first2.height === second.height;
}
__name(equalSizes, "equalSizes");
var Observable = (
  /** @class */
  function() {
    function Observable2(win) {
      var _this = this;
      this._resolutionListener = function() {
        return _this._onResolutionChanged();
      }, this._resolutionMediaQueryList = null, this._observers = [], this._window = win, this._installResolutionListener();
    }
    return __name(Observable2, "Observable"), Observable2.prototype.dispose = function() {
      this._uninstallResolutionListener(), this._window = null;
    }, Object.defineProperty(Observable2.prototype, "value", {
      get: function() {
        return this._window.devicePixelRatio;
      },
      enumerable: !1,
      configurable: !0
    }), Observable2.prototype.subscribe = function(next2) {
      var _this = this, observer = { next: next2 };
      return this._observers.push(observer), {
        unsubscribe: function() {
          _this._observers = _this._observers.filter(function(o2) {
            return o2 !== observer;
          });
        }
      };
    }, Observable2.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null)
        throw new Error("Resolution listener is already installed");
      var dppx = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(dppx, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener);
    }, Observable2.prototype._uninstallResolutionListener = function() {
      this._resolutionMediaQueryList !== null && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null);
    }, Observable2.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener(), this._installResolutionListener();
    }, Observable2.prototype._onResolutionChanged = function() {
      var _this = this;
      this._observers.forEach(function(observer) {
        return observer.next(_this._window.devicePixelRatio);
      }), this._reinstallResolutionListener();
    }, Observable2;
  }()
);
function createObservable(win) {
  return new Observable(win);
}
__name(createObservable, "createObservable");
var DevicePixelContentBoxBinding = (
  /** @class */
  function() {
    function DevicePixelContentBoxBinding2(canvasElement, transformBitmapSize, options2) {
      var _a46;
      this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = canvasElement, this._canvasElementClientSize = size({
        width: this._canvasElement.clientWidth,
        height: this._canvasElement.clientHeight
      }), this._transformBitmapSize = transformBitmapSize ?? function(size2) {
        return size2;
      }, this._allowResizeObserver = (_a46 = options2 == null ? void 0 : options2.allowResizeObserver) !== null && _a46 !== void 0 ? _a46 : !0, this._chooseAndInitObserver();
    }
    return __name(DevicePixelContentBoxBinding2, "DevicePixelContentBoxBinding"), DevicePixelContentBoxBinding2.prototype.dispose = function() {
      var _a46, _b;
      if (this._canvasElement === null)
        throw new Error("Object is disposed");
      (_a46 = this._canvasElementResizeObserver) === null || _a46 === void 0 || _a46.disconnect(), this._canvasElementResizeObserver = null, (_b = this._devicePixelRatioObservable) === null || _b === void 0 || _b.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null;
    }, Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElement", {
      get: function() {
        if (this._canvasElement === null)
          throw new Error("Object is disposed");
        return this._canvasElement;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElementClientSize", {
      get: function() {
        return this._canvasElementClientSize;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "bitmapSize", {
      get: function() {
        return size({
          width: this.canvasElement.width,
          height: this.canvasElement.height
        });
      },
      enumerable: !1,
      configurable: !0
    }), DevicePixelContentBoxBinding2.prototype.resizeCanvasElement = function(clientSize) {
      this._canvasElementClientSize = size(clientSize), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize();
    }, DevicePixelContentBoxBinding2.prototype.subscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners.push(listener);
    }, DevicePixelContentBoxBinding2.prototype.unsubscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    }, Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "suggestedBitmapSize", {
      get: function() {
        return this._suggestedBitmapSize;
      },
      enumerable: !1,
      configurable: !0
    }), DevicePixelContentBoxBinding2.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners.push(listener);
    }, DevicePixelContentBoxBinding2.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    }, DevicePixelContentBoxBinding2.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize !== null) {
        var oldSuggestedSize = this._suggestedBitmapSize;
        this._suggestedBitmapSize = null, this._resizeBitmap(oldSuggestedSize), this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);
      }
    }, DevicePixelContentBoxBinding2.prototype._resizeBitmap = function(newSize) {
      var oldSize = this.bitmapSize;
      equalSizes(oldSize, newSize) || (this.canvasElement.width = newSize.width, this.canvasElement.height = newSize.height, this._emitBitmapSizeChanged(oldSize, newSize));
    }, DevicePixelContentBoxBinding2.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._bitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    }, DevicePixelContentBoxBinding2.prototype._suggestNewBitmapSize = function(newSize) {
      var oldSuggestedSize = this._suggestedBitmapSize, finalNewSize = size(this._transformBitmapSize(newSize, this._canvasElementClientSize)), newSuggestedSize = equalSizes(this.bitmapSize, finalNewSize) ? null : finalNewSize;
      oldSuggestedSize === null && newSuggestedSize === null || oldSuggestedSize !== null && newSuggestedSize !== null && equalSizes(oldSuggestedSize, newSuggestedSize) || (this._suggestedBitmapSize = newSuggestedSize, this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize));
    }, DevicePixelContentBoxBinding2.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    }, DevicePixelContentBoxBinding2.prototype._chooseAndInitObserver = function() {
      var _this = this;
      if (!this._allowResizeObserver) {
        this._initDevicePixelRatioObservable();
        return;
      }
      isDevicePixelContentBoxSupported().then(function(isSupported) {
        return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();
      });
    }, DevicePixelContentBoxBinding2.prototype._initDevicePixelRatioObservable = function() {
      var _this = this;
      if (this._canvasElement !== null) {
        var win = canvasElementWindow(this._canvasElement);
        if (win === null)
          throw new Error("No window is associated with the canvas");
        this._devicePixelRatioObservable = createObservable(win), this._devicePixelRatioObservable.subscribe(function() {
          return _this._invalidateBitmapSize();
        }), this._invalidateBitmapSize();
      }
    }, DevicePixelContentBoxBinding2.prototype._invalidateBitmapSize = function() {
      var _a46, _b;
      if (this._canvasElement !== null) {
        var win = canvasElementWindow(this._canvasElement);
        if (win !== null) {
          var ratio = (_b = (_a46 = this._devicePixelRatioObservable) === null || _a46 === void 0 ? void 0 : _a46.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio, canvasRects = this._canvasElement.getClientRects(), newSize = (
            // eslint-disable-next-line no-negated-condition
            canvasRects[0] !== void 0 ? predictedBitmapSize(canvasRects[0], ratio) : size({
              width: this._canvasElementClientSize.width * ratio,
              height: this._canvasElementClientSize.height * ratio
            })
          );
          this._suggestNewBitmapSize(newSize);
        }
      }
    }, DevicePixelContentBoxBinding2.prototype._initResizeObserver = function() {
      var _this = this;
      this._canvasElement !== null && (this._canvasElementResizeObserver = new ResizeObserver(function(entries) {
        var entry2 = entries.find(function(entry3) {
          return entry3.target === _this._canvasElement;
        });
        if (!(!entry2 || !entry2.devicePixelContentBoxSize || !entry2.devicePixelContentBoxSize[0])) {
          var entrySize = entry2.devicePixelContentBoxSize[0], newSize = size({
            width: entrySize.inlineSize,
            height: entrySize.blockSize
          });
          _this._suggestNewBitmapSize(newSize);
        }
      }), this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" }));
    }, DevicePixelContentBoxBinding2;
  }()
);
function bindTo(canvasElement, target) {
  if (target.type === "device-pixel-content-box")
    return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);
  throw new Error("Unsupported binding target");
}
__name(bindTo, "bindTo");
function canvasElementWindow(canvasElement) {
  return canvasElement.ownerDocument.defaultView;
}
__name(canvasElementWindow, "canvasElementWindow");
function isDevicePixelContentBoxSupported() {
  return new Promise(function(resolve) {
    var ro = new ResizeObserver(function(entries) {
      resolve(entries.every(function(entry2) {
        return "devicePixelContentBoxSize" in entry2;
      })), ro.disconnect();
    });
    ro.observe(document.body, { box: "device-pixel-content-box" });
  }).catch(function() {
    return !1;
  });
}
__name(isDevicePixelContentBoxSupported, "isDevicePixelContentBoxSupported");
function predictedBitmapSize(canvasRect, ratio) {
  return size({
    width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),
    height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)
  });
}
__name(predictedBitmapSize, "predictedBitmapSize");
var CanvasRenderingTarget2D = (
  /** @class */
  function() {
    function CanvasRenderingTarget2D2(context, mediaSize, bitmapSize) {
      if (mediaSize.width === 0 || mediaSize.height === 0)
        throw new TypeError("Rendering target could only be created on a media with positive width and height");
      if (this._mediaSize = mediaSize, bitmapSize.width === 0 || bitmapSize.height === 0)
        throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      this._bitmapSize = bitmapSize, this._context = context;
    }
    return __name(CanvasRenderingTarget2D2, "CanvasRenderingTarget2D"), CanvasRenderingTarget2D2.prototype.useMediaCoordinateSpace = function(f2) {
      try {
        return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), f2({
          context: this._context,
          mediaSize: this._mediaSize
        });
      } finally {
        this._context.restore();
      }
    }, CanvasRenderingTarget2D2.prototype.useBitmapCoordinateSpace = function(f2) {
      try {
        return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), f2({
          context: this._context,
          mediaSize: this._mediaSize,
          bitmapSize: this._bitmapSize,
          horizontalPixelRatio: this._horizontalPixelRatio,
          verticalPixelRatio: this._verticalPixelRatio
        });
      } finally {
        this._context.restore();
      }
    }, Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_horizontalPixelRatio", {
      get: function() {
        return this._bitmapSize.width / this._mediaSize.width;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_verticalPixelRatio", {
      get: function() {
        return this._bitmapSize.height / this._mediaSize.height;
      },
      enumerable: !1,
      configurable: !0
    }), CanvasRenderingTarget2D2;
  }()
);
function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {
  var mediaSize = binding.canvasElementClientSize;
  if (mediaSize.width === 0 || mediaSize.height === 0)
    return null;
  var bitmapSize = binding.bitmapSize;
  if (bitmapSize.width === 0 || bitmapSize.height === 0)
    return null;
  var context = binding.canvasElement.getContext("2d", contextOptions);
  return context === null ? null : new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);
}
__name(tryCreateCanvasRenderingTarget2D, "tryCreateCanvasRenderingTarget2D");
/*!
 * @license
 * TradingView Lightweight Charts™ v4.1.1
 * Copyright (c) 2023 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
const e = { upColor: "#26a69a", downColor: "#ef5350", wickVisible: !0, borderVisible: !0, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, r = { upColor: "#26a69a", downColor: "#ef5350", openVisible: !0, thinBars: !0 }, h$1 = { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, l = { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: !1, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, a = { baseValue: { type: "price", price: 0 }, topFillColor1: "rgba(38, 166, 154, 0.28)", topFillColor2: "rgba(38, 166, 154, 0.05)", topLineColor: "rgba(38, 166, 154, 1)", bottomFillColor1: "rgba(239, 83, 80, 0.05)", bottomFillColor2: "rgba(239, 83, 80, 0.28)", bottomLineColor: "rgba(239, 83, 80, 1)", lineWidth: 3, lineStyle: 0, lineType: 0, lineVisible: !0, crosshairMarkerVisible: !0, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: !1 }, o = { color: "#26a69a", base: 0 }, _$1 = { color: "#2196f3" }, u = { title: "", visible: !0, lastValueVisible: !0, priceLineVisible: !0, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: !0, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: 0.01 } };
var c, d;
function f(t2, i) {
  const n2 = { 0: [], 1: [t2.lineWidth, t2.lineWidth], 2: [2 * t2.lineWidth, 2 * t2.lineWidth], 3: [6 * t2.lineWidth, 6 * t2.lineWidth], 4: [t2.lineWidth, 4 * t2.lineWidth] }[i];
  t2.setLineDash(n2);
}
__name(f, "f");
function v(t2, i, n2, s) {
  t2.beginPath();
  const e2 = t2.lineWidth % 2 ? 0.5 : 0;
  t2.moveTo(n2, i + e2), t2.lineTo(s, i + e2), t2.stroke();
}
__name(v, "v");
function p$1(t2, i) {
  if (!t2)
    throw new Error("Assertion failed" + (i ? ": " + i : ""));
}
__name(p$1, "p$1");
function m$1(t2) {
  if (t2 === void 0)
    throw new Error("Value is undefined");
  return t2;
}
__name(m$1, "m$1");
function b(t2) {
  if (t2 === null)
    throw new Error("Value is null");
  return t2;
}
__name(b, "b");
function w$1(t2) {
  return b(m$1(t2));
}
__name(w$1, "w$1");
(function(t2) {
  t2[t2.Simple = 0] = "Simple", t2[t2.WithSteps = 1] = "WithSteps", t2[t2.Curved = 2] = "Curved";
})(c || (c = {})), function(t2) {
  t2[t2.Solid = 0] = "Solid", t2[t2.Dotted = 1] = "Dotted", t2[t2.Dashed = 2] = "Dashed", t2[t2.LargeDashed = 3] = "LargeDashed", t2[t2.SparseDotted = 4] = "SparseDotted";
}(d || (d = {}));
const g = { khaki: "#f0e68c", azure: "#f0ffff", aliceblue: "#f0f8ff", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", gray: "#808080", green: "#008000", honeydew: "#f0fff0", floralwhite: "#fffaf0", lightblue: "#add8e6", lightcoral: "#f08080", lemonchiffon: "#fffacd", hotpink: "#ff69b4", lightyellow: "#ffffe0", greenyellow: "#adff2f", lightgoldenrodyellow: "#fafad2", limegreen: "#32cd32", linen: "#faf0e6", lightcyan: "#e0ffff", magenta: "#f0f", maroon: "#800000", olive: "#808000", orange: "#ffa500", oldlace: "#fdf5e6", mediumblue: "#0000cd", transparent: "#0000", lime: "#0f0", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", midnightblue: "#191970", orchid: "#da70d6", mediumorchid: "#ba55d3", mediumturquoise: "#48d1cc", orangered: "#ff4500", royalblue: "#4169e1", powderblue: "#b0e0e6", red: "#f00", coral: "#ff7f50", turquoise: "#40e0d0", white: "#fff", whitesmoke: "#f5f5f5", wheat: "#f5deb3", teal: "#008080", steelblue: "#4682b4", bisque: "#ffe4c4", aquamarine: "#7fffd4", aqua: "#0ff", sienna: "#a0522d", silver: "#c0c0c0", springgreen: "#00ff7f", antiquewhite: "#faebd7", burlywood: "#deb887", brown: "#a52a2a", beige: "#f5f5dc", chocolate: "#d2691e", chartreuse: "#7fff00", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cadetblue: "#5f9ea0", tomato: "#ff6347", fuchsia: "#f0f", blue: "#00f", salmon: "#fa8072", blanchedalmond: "#ffebcd", slateblue: "#6a5acd", slategray: "#708090", thistle: "#d8bfd8", tan: "#d2b48c", cyan: "#0ff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", blueviolet: "#8a2be2", black: "#000", darkmagenta: "#8b008b", darkslateblue: "#483d8b", darkkhaki: "#bdb76b", darkorchid: "#9932cc", darkorange: "#ff8c00", darkgreen: "#006400", darkred: "#8b0000", dodgerblue: "#1e90ff", darkslategray: "#2f4f4f", dimgray: "#696969", deepskyblue: "#00bfff", firebrick: "#b22222", forestgreen: "#228b22", indigo: "#4b0082", ivory: "#fffff0", lavenderblush: "#fff0f5", feldspar: "#d19275", indianred: "#cd5c5c", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightskyblue: "#87cefa", lightslategray: "#789", lightslateblue: "#8470ff", snow: "#fffafa", lightseagreen: "#20b2aa", lightsalmon: "#ffa07a", darksalmon: "#e9967a", darkviolet: "#9400d3", mediumpurple: "#9370d8", mediumaquamarine: "#66cdaa", skyblue: "#87ceeb", lavender: "#e6e6fa", lightsteelblue: "#b0c4de", mediumvioletred: "#c71585", mintcream: "#f5fffa", navajowhite: "#ffdead", navy: "#000080", olivedrab: "#6b8e23", palevioletred: "#d87093", violetred: "#d02090", yellow: "#ff0", yellowgreen: "#9acd32", lawngreen: "#7cfc00", pink: "#ffc0cb", paleturquoise: "#afeeee", palegoldenrod: "#eee8aa", darkolivegreen: "#556b2f", darkseagreen: "#8fbc8f", darkturquoise: "#00ced1", peachpuff: "#ffdab9", deeppink: "#ff1493", violet: "#ee82ee", palegreen: "#98fb98", mediumseagreen: "#3cb371", peru: "#cd853f", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", purple: "#800080", seagreen: "#2e8b57", seashell: "#fff5ee", papayawhip: "#ffefd5", mediumslateblue: "#7b68ee", plum: "#dda0dd", mediumspringgreen: "#00fa9a" };
function M(t2) {
  return t2 < 0 ? 0 : t2 > 255 ? 255 : Math.round(t2) || 0;
}
__name(M, "M");
function x(t2) {
  return t2 <= 0 || t2 > 0 ? t2 < 0 ? 0 : t2 > 1 ? 1 : Math.round(1e4 * t2) / 1e4 : 0;
}
__name(x, "x");
const S$1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i, k$1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i, y = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/, C$1 = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
function T$1(t2) {
  (t2 = t2.toLowerCase()) in g && (t2 = g[t2]);
  {
    const i = C$1.exec(t2) || y.exec(t2);
    if (i)
      return [M(parseInt(i[1], 10)), M(parseInt(i[2], 10)), M(parseInt(i[3], 10)), x(i.length < 5 ? 1 : parseFloat(i[4]))];
  }
  {
    const i = k$1.exec(t2);
    if (i)
      return [M(parseInt(i[1], 16)), M(parseInt(i[2], 16)), M(parseInt(i[3], 16)), 1];
  }
  {
    const i = S$1.exec(t2);
    if (i)
      return [M(17 * parseInt(i[1], 16)), M(17 * parseInt(i[2], 16)), M(17 * parseInt(i[3], 16)), 1];
  }
  throw new Error(`Cannot parse color: ${t2}`);
}
__name(T$1, "T$1");
function P(t2) {
  const i = T$1(t2);
  return { t: `rgb(${i[0]}, ${i[1]}, ${i[2]})`, i: (n2 = i, 0.199 * n2[0] + 0.687 * n2[1] + 0.114 * n2[2] > 160 ? "black" : "white") };
  var n2;
}
__name(P, "P");
const _R = class _R {
  constructor() {
    this.h = [];
  }
  l(t2, i, n2) {
    const s = { o: t2, _: i, u: n2 === !0 };
    this.h.push(s);
  }
  v(t2) {
    const i = this.h.findIndex((i2) => t2 === i2.o);
    i > -1 && this.h.splice(i, 1);
  }
  p(t2) {
    this.h = this.h.filter((i) => i._ !== t2);
  }
  m(t2, i, n2) {
    const s = [...this.h];
    this.h = this.h.filter((t3) => !t3.u), s.forEach((s2) => s2.o(t2, i, n2));
  }
  M() {
    return this.h.length > 0;
  }
  S() {
    this.h = [];
  }
};
__name(_R, "R");
let R = _R;
function D$1(t2, ...i) {
  for (const n2 of i)
    for (const i2 in n2)
      n2[i2] !== void 0 && (typeof n2[i2] != "object" || t2[i2] === void 0 || Array.isArray(n2[i2]) ? t2[i2] = n2[i2] : D$1(t2[i2], n2[i2]));
  return t2;
}
__name(D$1, "D$1");
function O$1(t2) {
  return typeof t2 == "number" && isFinite(t2);
}
__name(O$1, "O$1");
function A$1(t2) {
  return typeof t2 == "number" && t2 % 1 == 0;
}
__name(A$1, "A$1");
function V$1(t2) {
  return typeof t2 == "string";
}
__name(V$1, "V$1");
function B$1(t2) {
  return typeof t2 == "boolean";
}
__name(B$1, "B$1");
function I(t2) {
  const i = t2;
  if (!i || typeof i != "object")
    return i;
  let n2, s, e2;
  for (s in n2 = Array.isArray(i) ? [] : {}, i)
    i.hasOwnProperty(s) && (e2 = i[s], n2[s] = e2 && typeof e2 == "object" ? I(e2) : e2);
  return n2;
}
__name(I, "I");
function z(t2) {
  return t2 !== null;
}
__name(z, "z");
function E(t2) {
  return t2 === null ? void 0 : t2;
}
__name(E, "E");
const L$1 = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
function N$1(t2, i, n2) {
  return i === void 0 && (i = L$1), `${n2 = n2 !== void 0 ? `${n2} ` : ""}${t2}px ${i}`;
}
__name(N$1, "N$1");
var _a2;
let F$1 = (_a2 = class {
  constructor(t2) {
    this.k = { C: 1, T: 5, P: NaN, R: "", D: "", O: "", A: "", V: 0, B: 0, I: 0, L: 0, N: 0 }, this.F = t2;
  }
  W() {
    const t2 = this.k, i = this.j(), n2 = this.H();
    return t2.P === i && t2.D === n2 || (t2.P = i, t2.D = n2, t2.R = N$1(i, n2), t2.L = 2.5 / 12 * i, t2.V = t2.L, t2.B = i / 12 * t2.T, t2.I = i / 12 * t2.T, t2.N = 0), t2.O = this.$(), t2.A = this.U(), this.k;
  }
  $() {
    return this.F.W().layout.textColor;
  }
  U() {
    return this.F.q();
  }
  j() {
    return this.F.W().layout.fontSize;
  }
  H() {
    return this.F.W().layout.fontFamily;
  }
}, __name(_a2, "F"), _a2);
const _W = class _W {
  constructor() {
    this.Y = [];
  }
  X(t2) {
    this.Y = t2;
  }
  K(t2, i, n2) {
    this.Y.forEach((s) => {
      s.K(t2, i, n2);
    });
  }
};
__name(_W, "W");
let W = _W;
const _j = class _j {
  K(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
  G(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.J(t3, i, n2));
  }
  J(t2, i, n2) {
  }
};
__name(_j, "j");
let j = _j;
var _a3;
let H$1 = (_a3 = class extends j {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z({ context: t2 }) {
    if (this.tt === null || this.tt.nt === null)
      return;
    const i = this.tt.nt, n2 = this.tt, s = /* @__PURE__ */ __name((s2) => {
      t2.beginPath();
      for (let e2 = i.to - 1; e2 >= i.from; --e2) {
        const i2 = n2.st[e2];
        t2.moveTo(i2.et, i2.rt), t2.arc(i2.et, i2.rt, s2, 0, 2 * Math.PI);
      }
      t2.fill();
    }, "s");
    n2.ht > 0 && (t2.fillStyle = n2.lt, s(n2.ot + n2.ht)), t2.fillStyle = n2._t, s(n2.ot);
  }
}, __name(_a3, "H"), _a3);
function $$1() {
  return { st: [{ et: 0, rt: 0, ut: 0, ct: 0 }], _t: "", lt: "", ot: 0, ht: 0, nt: null };
}
__name($$1, "$$1");
const U$1 = { from: 0, to: 1 }, _q = class _q {
  constructor(t2, i) {
    this.dt = new W(), this.ft = [], this.vt = [], this.bt = !0, this.F = t2, this.wt = i, this.dt.X(this.ft);
  }
  gt(t2) {
    const i = this.F.Mt();
    i.length !== this.ft.length && (this.vt = i.map($$1), this.ft = this.vt.map((t3) => {
      const i2 = new H$1();
      return i2.it(t3), i2;
    }), this.dt.X(this.ft)), this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.dt;
  }
  St() {
    const t2 = this.wt.W().mode === 2, i = this.F.Mt(), n2 = this.wt.kt(), s = this.F.yt();
    i.forEach((i2, e2) => {
      var r2;
      const h2 = this.vt[e2], l2 = i2.Ct(n2);
      if (t2 || l2 === null || !i2.Tt())
        return void (h2.nt = null);
      const a2 = b(i2.Pt());
      h2._t = l2.Rt, h2.ot = l2.ot, h2.ht = l2.Dt, h2.st[0].ct = l2.ct, h2.st[0].rt = i2.At().Ot(l2.ct, a2.Vt), h2.lt = (r2 = l2.Bt) !== null && r2 !== void 0 ? r2 : this.F.It(h2.st[0].rt / i2.At().zt()), h2.st[0].ut = n2, h2.st[0].et = s.Et(n2), h2.nt = U$1;
    });
  }
};
__name(_q, "q");
let q = _q;
const _Y = class _Y {
  K(t2, i, n2) {
    t2.useBitmapCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
};
__name(_Y, "Y");
let Y = _Y;
var _a4;
let X$1 = (_a4 = class extends Y {
  constructor(t2) {
    super(), this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null)
      return;
    const e2 = this.Lt.Nt.Tt, r2 = this.Lt.Ft.Tt;
    if (!e2 && !r2)
      return;
    const h2 = Math.round(this.Lt.et * n2), l2 = Math.round(this.Lt.rt * s);
    t2.lineCap = "butt", e2 && h2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Nt.ht * n2), t2.strokeStyle = this.Lt.Nt.O, t2.fillStyle = this.Lt.Nt.O, f(t2, this.Lt.Nt.Wt), function(t3, i2, n3, s2) {
      t3.beginPath();
      const e3 = t3.lineWidth % 2 ? 0.5 : 0;
      t3.moveTo(i2 + e3, n3), t3.lineTo(i2 + e3, s2), t3.stroke();
    }(t2, h2, 0, i.height)), r2 && l2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Ft.ht * s), t2.strokeStyle = this.Lt.Ft.O, t2.fillStyle = this.Lt.Ft.O, f(t2, this.Lt.Ft.Wt), v(t2, l2, 0, i.width));
  }
}, __name(_a4, "X"), _a4);
const _K = class _K {
  constructor(t2) {
    this.bt = !0, this.jt = { Nt: { ht: 1, Wt: 0, O: "", Tt: !1 }, Ft: { ht: 1, Wt: 0, O: "", Tt: !1 }, et: 0, rt: 0 }, this.Ht = new X$1(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht;
  }
  St() {
    const t2 = this.$t.Tt(), i = b(this.$t.Ut()), n2 = i.qt().W().crosshair, s = this.jt;
    if (n2.mode === 2)
      return s.Ft.Tt = !1, void (s.Nt.Tt = !1);
    s.Ft.Tt = t2 && this.$t.Yt(i), s.Nt.Tt = t2 && this.$t.Xt(), s.Ft.ht = n2.horzLine.width, s.Ft.Wt = n2.horzLine.style, s.Ft.O = n2.horzLine.color, s.Nt.ht = n2.vertLine.width, s.Nt.Wt = n2.vertLine.style, s.Nt.O = n2.vertLine.color, s.et = this.$t.Kt(), s.rt = this.$t.Zt();
  }
};
__name(_K, "K");
let K = _K;
function Z$1(t2, i, n2, s, e2, r2) {
  t2.fillRect(i + r2, n2, s - 2 * r2, r2), t2.fillRect(i + r2, n2 + e2 - r2, s - 2 * r2, r2), t2.fillRect(i, n2, r2, e2), t2.fillRect(i + s - r2, n2, r2, e2);
}
__name(Z$1, "Z$1");
function G$1(t2, i, n2, s, e2, r2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.fillStyle = r2, t2.fillRect(i, n2, s, e2), t2.restore();
}
__name(G$1, "G$1");
function J$1(t2, i) {
  return t2.map((t3) => t3 === 0 ? t3 : t3 + i);
}
__name(J$1, "J$1");
function Q$1(t2, i, n2, s, e2, r2) {
  t2.beginPath(), t2.lineTo(i + s - r2[1], n2), r2[1] !== 0 && t2.arcTo(i + s, n2, i + s, n2 + r2[1], r2[1]), t2.lineTo(i + s, n2 + e2 - r2[2]), r2[2] !== 0 && t2.arcTo(i + s, n2 + e2, i + s - r2[2], n2 + e2, r2[2]), t2.lineTo(i + r2[3], n2 + e2), r2[3] !== 0 && t2.arcTo(i, n2 + e2, i, n2 + e2 - r2[3], r2[3]), t2.lineTo(i, n2 + r2[0]), r2[0] !== 0 && t2.arcTo(i, n2, i + r2[0], n2, r2[0]);
}
__name(Q$1, "Q$1");
function tt(t2, i, n2, s, e2, r2, h2 = 0, l2 = [0, 0, 0, 0], a2 = "") {
  if (t2.save(), !h2 || !a2 || a2 === r2)
    return Q$1(t2, i, n2, s, e2, l2), t2.fillStyle = r2, t2.fill(), void t2.restore();
  const o2 = h2 / 2;
  r2 !== "transparent" && (Q$1(t2, i + h2, n2 + h2, s - 2 * h2, e2 - 2 * h2, J$1(l2, -h2)), t2.fillStyle = r2, t2.fill()), a2 !== "transparent" && (Q$1(t2, i + o2, n2 + o2, s - h2, e2 - h2, J$1(l2, -o2)), t2.lineWidth = h2, t2.strokeStyle = a2, t2.closePath(), t2.stroke()), t2.restore();
}
__name(tt, "tt");
function it(t2, i, n2, s, e2, r2, h2) {
  t2.save(), t2.globalCompositeOperation = "copy";
  const l2 = t2.createLinearGradient(0, 0, 0, e2);
  l2.addColorStop(0, r2), l2.addColorStop(1, h2), t2.fillStyle = l2, t2.fillRect(i, n2, s, e2), t2.restore();
}
__name(it, "it");
const _nt = class _nt {
  constructor(t2, i) {
    this.it(t2, i);
  }
  it(t2, i) {
    this.Lt = t2, this.Gt = i;
  }
  zt(t2, i) {
    return this.Lt.Tt ? t2.P + t2.L + t2.V : 0;
  }
  K(t2, i, n2, s) {
    if (!this.Lt.Tt || this.Lt.Jt.length === 0)
      return;
    const e2 = this.Lt.O, r2 = this.Gt.t, h2 = t2.useBitmapCoordinateSpace((t3) => {
      const h3 = t3.context;
      h3.font = i.R;
      const l2 = this.Qt(t3, i, n2, s), a2 = l2.ti, o2 = /* @__PURE__ */ __name((t4, i2) => {
        l2.ii ? tt(h3, a2.ni, a2.si, a2.ei, a2.ri, t4, a2.hi, [a2.ot, 0, 0, a2.ot], i2) : tt(h3, a2.li, a2.si, a2.ei, a2.ri, t4, a2.hi, [0, a2.ot, a2.ot, 0], i2);
      }, "o");
      return o2(r2, "transparent"), this.Lt.ai && (h3.fillStyle = e2, h3.fillRect(a2.li, a2.oi, a2._i - a2.li, a2.ui)), o2("transparent", r2), this.Lt.ci && (h3.fillStyle = i.A, h3.fillRect(l2.ii ? a2.di - a2.hi : 0, a2.si, a2.hi, a2.fi - a2.si)), l2;
    });
    t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = h2.vi;
      t3.font = i.R, t3.textAlign = h2.ii ? "right" : "left", t3.textBaseline = "middle", t3.fillStyle = e2, t3.fillText(this.Lt.Jt, n3.pi, (n3.si + n3.fi) / 2 + n3.mi);
    });
  }
  Qt(t2, i, n2, s) {
    var e2;
    const { context: r2, bitmapSize: h2, mediaSize: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = this.Lt.ai || !this.Lt.bi ? i.T : 0, u2 = this.Lt.wi ? i.C : 0, c2 = i.L + this.Gt.gi, d2 = i.V + this.Gt.Mi, f2 = i.B, v2 = i.I, p2 = this.Lt.Jt, m2 = i.P, b2 = n2.xi(r2, p2), w2 = Math.ceil(n2.Si(r2, p2)), g2 = m2 + c2 + d2, M2 = i.C + f2 + v2 + w2 + _24, x2 = Math.max(1, Math.floor(o2));
    let S2 = Math.round(g2 * o2);
    S2 % 2 != x2 % 2 && (S2 += 1);
    const k2 = u2 > 0 ? Math.max(1, Math.floor(u2 * a2)) : 0, y2 = Math.round(M2 * a2), C2 = Math.round(_24 * a2), T2 = (e2 = this.Gt.ki) !== null && e2 !== void 0 ? e2 : this.Gt.yi, P2 = Math.round(T2 * o2) - Math.floor(0.5 * o2), R2 = Math.floor(P2 + x2 / 2 - S2 / 2), D2 = R2 + S2, O2 = s === "right", A2 = O2 ? l2.width - u2 : u2, V2 = O2 ? h2.width - k2 : k2;
    let B2, I2, z2;
    return O2 ? (B2 = V2 - y2, I2 = V2 - C2, z2 = A2 - _24 - f2 - u2) : (B2 = V2 + y2, I2 = V2 + C2, z2 = A2 + _24 + f2), { ii: O2, ti: { si: R2, oi: P2, fi: D2, ei: y2, ri: S2, ot: 2 * a2, hi: k2, ni: B2, li: V2, _i: I2, ui: x2, di: h2.width }, vi: { si: R2 / o2, fi: D2 / o2, pi: z2, mi: b2 } };
  }
};
__name(_nt, "nt");
let nt = _nt;
const _st = class _st {
  constructor(t2) {
    this.Ci = { yi: 0, t: "#000", Mi: 0, gi: 0 }, this.Ti = { Jt: "", Tt: !1, ai: !0, bi: !1, Bt: "", O: "#FFF", ci: !1, wi: !1 }, this.Pi = { Jt: "", Tt: !1, ai: !1, bi: !0, Bt: "", O: "#FFF", ci: !0, wi: !0 }, this.bt = !0, this.Ri = new (t2 || nt)(this.Ti, this.Ci), this.Di = new (t2 || nt)(this.Pi, this.Ci);
  }
  Jt() {
    return this.Oi(), this.Ti.Jt;
  }
  yi() {
    return this.Oi(), this.Ci.yi;
  }
  gt() {
    this.bt = !0;
  }
  zt(t2, i = !1) {
    return Math.max(this.Ri.zt(t2, i), this.Di.zt(t2, i));
  }
  Ai() {
    return this.Ci.ki || 0;
  }
  Vi(t2) {
    this.Ci.ki = t2;
  }
  Bi() {
    return this.Oi(), this.Ti.Tt || this.Pi.Tt;
  }
  Ii() {
    return this.Oi(), this.Ti.Tt;
  }
  xt(t2) {
    return this.Oi(), this.Ti.ai = this.Ti.ai && t2.W().ticksVisible, this.Pi.ai = this.Pi.ai && t2.W().ticksVisible, this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Ri;
  }
  zi() {
    return this.Oi(), this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Di;
  }
  Oi() {
    this.bt && (this.Ti.ai = !0, this.Pi.ai = !1, this.Ei(this.Ti, this.Pi, this.Ci));
  }
};
__name(_st, "st");
let st = _st;
const _et = class _et extends st {
  constructor(t2, i, n2) {
    super(), this.$t = t2, this.Li = i, this.Ni = n2;
  }
  Ei(t2, i, n2) {
    if (t2.Tt = !1, this.$t.W().mode === 2)
      return;
    const s = this.$t.W().horzLine;
    if (!s.labelVisible)
      return;
    const e2 = this.Li.Pt();
    if (!this.$t.Tt() || this.Li.Fi() || e2 === null)
      return;
    const r2 = P(s.labelBackgroundColor);
    n2.t = r2.t, t2.O = r2.i;
    const h2 = 2 / 12 * this.Li.P();
    n2.gi = h2, n2.Mi = h2;
    const l2 = this.Ni(this.Li);
    n2.yi = l2.yi, t2.Jt = this.Li.Wi(l2.ct, e2), t2.Tt = !0;
  }
};
__name(_et, "et");
let et = _et;
const rt$1 = /[1-9]/g;
var _a5;
let ht$1 = (_a5 = class {
  constructor() {
    this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  K(t2, i) {
    if (this.Lt === null || this.Lt.Tt === !1 || this.Lt.Jt.length === 0)
      return;
    const n2 = t2.useMediaCoordinateSpace(({ context: t3 }) => (t3.font = i.R, Math.round(i.ji.Si(t3, b(this.Lt).Jt, rt$1))));
    if (n2 <= 0)
      return;
    const s = i.Hi, e2 = n2 + 2 * s, r2 = e2 / 2, h2 = this.Lt.$i;
    let l2 = this.Lt.yi, a2 = Math.floor(l2 - r2) + 0.5;
    a2 < 0 ? (l2 += Math.abs(0 - a2), a2 = Math.floor(l2 - r2) + 0.5) : a2 + e2 > h2 && (l2 -= Math.abs(h2 - (a2 + e2)), a2 = Math.floor(l2 - r2) + 0.5);
    const o2 = a2 + e2, _24 = Math.ceil(0 + i.C + i.T + i.L + i.P + i.V);
    t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: n3, verticalPixelRatio: s2 }) => {
      const e3 = b(this.Lt);
      t3.fillStyle = e3.t;
      const r3 = Math.round(a2 * n3), h3 = Math.round(0 * s2), l3 = Math.round(o2 * n3), u2 = Math.round(_24 * s2), c2 = Math.round(2 * n3);
      if (t3.beginPath(), t3.moveTo(r3, h3), t3.lineTo(r3, u2 - c2), t3.arcTo(r3, u2, r3 + c2, u2, c2), t3.lineTo(l3 - c2, u2), t3.arcTo(l3, u2, l3, u2 - c2, c2), t3.lineTo(l3, h3), t3.fill(), e3.ai) {
        const r4 = Math.round(e3.yi * n3), l4 = h3, a3 = Math.round((l4 + i.T) * s2);
        t3.fillStyle = e3.O;
        const o3 = Math.max(1, Math.floor(n3)), _25 = Math.floor(0.5 * n3);
        t3.fillRect(r4 - _25, l4, o3, a3 - l4);
      }
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = b(this.Lt), e3 = 0 + i.C + i.T + i.L + i.P / 2;
      t3.font = i.R, t3.textAlign = "left", t3.textBaseline = "middle", t3.fillStyle = n3.O;
      const r3 = i.ji.xi(t3, "Apr0");
      t3.translate(a2 + s, e3 + r3), t3.fillText(n3.Jt, 0, 0);
    });
  }
}, __name(_a5, "ht"), _a5);
var _a6;
let lt$1 = (_a6 = class {
  constructor(t2, i, n2) {
    this.bt = !0, this.Ht = new ht$1(), this.jt = { Tt: !1, t: "#4c525e", O: "white", Jt: "", $i: 0, yi: NaN, ai: !0 }, this.wt = t2, this.Ui = i, this.Ni = n2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht.it(this.jt), this.Ht;
  }
  St() {
    const t2 = this.jt;
    if (t2.Tt = !1, this.wt.W().mode === 2)
      return;
    const i = this.wt.W().vertLine;
    if (!i.labelVisible)
      return;
    const n2 = this.Ui.yt();
    if (n2.Fi())
      return;
    t2.$i = n2.$i();
    const s = this.Ni();
    if (s === null)
      return;
    t2.yi = s.yi;
    const e2 = n2.qi(this.wt.kt());
    t2.Jt = n2.Yi(b(e2)), t2.Tt = !0;
    const r2 = P(i.labelBackgroundColor);
    t2.t = r2.t, t2.O = r2.i, t2.ai = n2.W().ticksVisible;
  }
}, __name(_a6, "lt"), _a6);
var _a7;
let at$1 = (_a7 = class {
  constructor() {
    this.Xi = null, this.Ki = 0;
  }
  Zi() {
    return this.Ki;
  }
  Gi(t2) {
    this.Ki = t2;
  }
  At() {
    return this.Xi;
  }
  Ji(t2) {
    this.Xi = t2;
  }
  Qi(t2) {
    return [];
  }
  tn() {
    return [];
  }
  Tt() {
    return !0;
  }
}, __name(_a7, "at"), _a7);
var ot$1;
(function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Magnet = 1] = "Magnet", t2[t2.Hidden = 2] = "Hidden";
})(ot$1 || (ot$1 = {}));
var _a8;
let _t$1 = (_a8 = class extends at$1 {
  constructor(t2, i) {
    super(), this.nn = null, this.sn = NaN, this.en = 0, this.rn = !0, this.hn = /* @__PURE__ */ new Map(), this.ln = !1, this.an = NaN, this.on = NaN, this._n = NaN, this.un = NaN, this.Ui = t2, this.cn = i, this.dn = new q(t2, this), this.fn = ((t3, i2) => (n3) => {
      const s = i2(), e2 = t3();
      if (n3 === b(this.nn).vn())
        return { ct: e2, yi: s };
      {
        const t4 = b(n3.Pt());
        return { ct: n3.pn(s, t4), yi: s };
      }
    })(() => this.sn, () => this.on);
    const n2 = ((t3, i2) => () => {
      const n3 = this.Ui.yt().mn(t3()), s = i2();
      return n3 && Number.isFinite(s) ? { ut: n3, yi: s } : null;
    })(() => this.en, () => this.Kt());
    this.bn = new lt$1(this, t2, n2), this.wn = new K(this);
  }
  W() {
    return this.cn;
  }
  gn(t2, i) {
    this._n = t2, this.un = i;
  }
  Mn() {
    this._n = NaN, this.un = NaN;
  }
  xn() {
    return this._n;
  }
  Sn() {
    return this.un;
  }
  kn(t2, i, n2) {
    this.ln || (this.ln = !0), this.rn = !0, this.yn(t2, i, n2);
  }
  kt() {
    return this.en;
  }
  Kt() {
    return this.an;
  }
  Zt() {
    return this.on;
  }
  Tt() {
    return this.rn;
  }
  Cn() {
    this.rn = !1, this.Tn(), this.sn = NaN, this.an = NaN, this.on = NaN, this.nn = null, this.Mn();
  }
  Pn(t2) {
    return this.nn !== null ? [this.wn, this.dn] : [];
  }
  Yt(t2) {
    return t2 === this.nn && this.cn.horzLine.visible;
  }
  Xt() {
    return this.cn.vertLine.visible;
  }
  Rn(t2, i) {
    this.rn && this.nn === t2 || this.hn.clear();
    const n2 = [];
    return this.nn === t2 && n2.push(this.Dn(this.hn, i, this.fn)), n2;
  }
  tn() {
    return this.rn ? [this.bn] : [];
  }
  Ut() {
    return this.nn;
  }
  On() {
    this.wn.gt(), this.hn.forEach((t2) => t2.gt()), this.bn.gt(), this.dn.gt();
  }
  An(t2) {
    return t2 && !t2.vn().Fi() ? t2.vn() : null;
  }
  yn(t2, i, n2) {
    this.Vn(t2, i, n2) && this.On();
  }
  Vn(t2, i, n2) {
    const s = this.an, e2 = this.on, r2 = this.sn, h2 = this.en, l2 = this.nn, a2 = this.An(n2);
    this.en = t2, this.an = isNaN(t2) ? NaN : this.Ui.yt().Et(t2), this.nn = n2;
    const o2 = a2 !== null ? a2.Pt() : null;
    return a2 !== null && o2 !== null ? (this.sn = i, this.on = a2.Ot(i, o2)) : (this.sn = NaN, this.on = NaN), s !== this.an || e2 !== this.on || h2 !== this.en || r2 !== this.sn || l2 !== this.nn;
  }
  Tn() {
    const t2 = this.Ui.Mt().map((t3) => t3.In().Bn()).filter(z), i = t2.length === 0 ? null : Math.max(...t2);
    this.en = i !== null ? i : NaN;
  }
  Dn(t2, i, n2) {
    let s = t2.get(i);
    return s === void 0 && (s = new et(this, i, n2), t2.set(i, s)), s;
  }
}, __name(_a8, "_t"), _a8);
function ut$1(t2) {
  return t2 === "left" || t2 === "right";
}
__name(ut$1, "ut$1");
const _ct = class _ct {
  constructor(t2) {
    this.zn = /* @__PURE__ */ new Map(), this.En = [], this.Ln = t2;
  }
  Nn(t2, i) {
    const n2 = function(t3, i2) {
      return t3 === void 0 ? i2 : { Fn: Math.max(t3.Fn, i2.Fn), Wn: t3.Wn || i2.Wn };
    }(this.zn.get(t2), i);
    this.zn.set(t2, n2);
  }
  jn() {
    return this.Ln;
  }
  Hn(t2) {
    const i = this.zn.get(t2);
    return i === void 0 ? { Fn: this.Ln } : { Fn: Math.max(this.Ln, i.Fn), Wn: i.Wn };
  }
  $n() {
    this.Un(), this.En = [{ qn: 0 }];
  }
  Yn(t2) {
    this.Un(), this.En = [{ qn: 1, Vt: t2 }];
  }
  Xn(t2) {
    this.Kn(), this.En.push({ qn: 5, Vt: t2 });
  }
  Un() {
    this.Kn(), this.En.push({ qn: 6 });
  }
  Zn() {
    this.Un(), this.En = [{ qn: 4 }];
  }
  Gn(t2) {
    this.Un(), this.En.push({ qn: 2, Vt: t2 });
  }
  Jn(t2) {
    this.Un(), this.En.push({ qn: 3, Vt: t2 });
  }
  Qn() {
    return this.En;
  }
  ts(t2) {
    for (const i of t2.En)
      this.ns(i);
    this.Ln = Math.max(this.Ln, t2.Ln), t2.zn.forEach((t3, i) => {
      this.Nn(i, t3);
    });
  }
  static ss() {
    return new _ct(2);
  }
  static es() {
    return new _ct(3);
  }
  ns(t2) {
    switch (t2.qn) {
      case 0:
        this.$n();
        break;
      case 1:
        this.Yn(t2.Vt);
        break;
      case 2:
        this.Gn(t2.Vt);
        break;
      case 3:
        this.Jn(t2.Vt);
        break;
      case 4:
        this.Zn();
        break;
      case 5:
        this.Xn(t2.Vt);
        break;
      case 6:
        this.Kn();
    }
  }
  Kn() {
    const t2 = this.En.findIndex((t3) => t3.qn === 5);
    t2 !== -1 && this.En.splice(t2, 1);
  }
};
__name(_ct, "ct");
let ct = _ct;
const dt$1 = ".";
function ft$1(t2, i) {
  if (!O$1(t2))
    return "n/a";
  if (!A$1(i))
    throw new TypeError("invalid length");
  if (i < 0 || i > 16)
    throw new TypeError("invalid length");
  return i === 0 ? t2.toString() : ("0000000000000000" + t2.toString()).slice(-i);
}
__name(ft$1, "ft$1");
var _a9;
let vt$1 = (_a9 = class {
  constructor(t2, i) {
    if (i || (i = 1), O$1(t2) && A$1(t2) || (t2 = 100), t2 < 0)
      throw new TypeError("invalid base");
    this.Li = t2, this.rs = i, this.hs();
  }
  format(t2) {
    const i = t2 < 0 ? "−" : "";
    return t2 = Math.abs(t2), i + this.ls(t2);
  }
  hs() {
    if (this.os = 0, this.Li > 0 && this.rs > 0) {
      let t2 = this.Li;
      for (; t2 > 1; )
        t2 /= 10, this.os++;
    }
  }
  ls(t2) {
    const i = this.Li / this.rs;
    let n2 = Math.floor(t2), s = "";
    const e2 = this.os !== void 0 ? this.os : NaN;
    if (i > 1) {
      let r2 = +(Math.round(t2 * i) - n2 * i).toFixed(this.os);
      r2 >= i && (r2 -= i, n2 += 1), s = dt$1 + ft$1(+r2.toFixed(this.os) * this.rs, e2);
    } else
      n2 = Math.round(n2 * i) / i, e2 > 0 && (s = dt$1 + ft$1(0, e2));
    return n2.toFixed(0) + s;
  }
}, __name(_a9, "vt"), _a9);
var _a10;
let pt$1 = (_a10 = class extends vt$1 {
  constructor(t2 = 100) {
    super(t2);
  }
  format(t2) {
    return `${super.format(t2)}%`;
  }
}, __name(_a10, "pt"), _a10);
var _a11;
let mt$1 = (_a11 = class {
  constructor(t2) {
    this._s = t2;
  }
  format(t2) {
    let i = "";
    return t2 < 0 && (i = "-", t2 = -t2), t2 < 995 ? i + this.us(t2) : t2 < 999995 ? i + this.us(t2 / 1e3) + "K" : t2 < 999999995 ? (t2 = 1e3 * Math.round(t2 / 1e3), i + this.us(t2 / 1e6) + "M") : (t2 = 1e6 * Math.round(t2 / 1e6), i + this.us(t2 / 1e9) + "B");
  }
  us(t2) {
    let i;
    const n2 = Math.pow(10, this._s);
    return i = (t2 = Math.round(t2 * n2) / n2) >= 1e-15 && t2 < 1 ? t2.toFixed(this._s).replace(/\.?0+$/, "") : String(t2), i.replace(/(\.[1-9]*)0+$/, (t3, i2) => i2);
  }
}, __name(_a11, "mt"), _a11);
function bt$1(t2, i, n2, s, e2, r2, h2) {
  if (i.length === 0 || s.from >= i.length || s.to <= 0)
    return;
  const { context: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = i[s.from];
  let u2 = r2(t2, _24), c2 = _24;
  if (s.to - s.from < 2) {
    const i2 = e2 / 2;
    l2.beginPath();
    const n3 = { et: _24.et - i2, rt: _24.rt }, s2 = { et: _24.et + i2, rt: _24.rt };
    l2.moveTo(n3.et * a2, n3.rt * o2), l2.lineTo(s2.et * a2, s2.rt * o2), h2(t2, u2, n3, s2);
  } else {
    const e3 = /* @__PURE__ */ __name((i2, n3) => {
      h2(t2, u2, c2, n3), l2.beginPath(), u2 = i2, c2 = n3;
    }, "e");
    let d2 = c2;
    l2.beginPath(), l2.moveTo(_24.et * a2, _24.rt * o2);
    for (let h3 = s.from + 1; h3 < s.to; ++h3) {
      d2 = i[h3];
      const s2 = r2(t2, d2);
      switch (n2) {
        case 0:
          l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 1:
          l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2), s2 !== u2 && (e3(s2, d2), l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2)), l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 2: {
          const [t3, n3] = xt$1(i, h3 - 1, h3);
          l2.bezierCurveTo(t3.et * a2, t3.rt * o2, n3.et * a2, n3.rt * o2, d2.et * a2, d2.rt * o2);
          break;
        }
      }
      n2 !== 1 && s2 !== u2 && (e3(s2, d2), l2.moveTo(d2.et * a2, d2.rt * o2));
    }
    (c2 !== d2 || c2 === d2 && n2 === 1) && h2(t2, u2, c2, d2);
  }
}
__name(bt$1, "bt$1");
const wt$1 = 6;
function gt$1(t2, i) {
  return { et: t2.et - i.et, rt: t2.rt - i.rt };
}
__name(gt$1, "gt$1");
function Mt(t2, i) {
  return { et: t2.et / i, rt: t2.rt / i };
}
__name(Mt, "Mt");
function xt$1(t2, i, n2) {
  const s = Math.max(0, i - 1), e2 = Math.min(t2.length - 1, n2 + 1);
  var r2, h2;
  return [(r2 = t2[i], h2 = Mt(gt$1(t2[n2], t2[s]), wt$1), { et: r2.et + h2.et, rt: r2.rt + h2.rt }), gt$1(t2[n2], Mt(gt$1(t2[e2], t2[i]), wt$1))];
}
__name(xt$1, "xt$1");
function St$1(t2, i, n2, s, e2) {
  const { context: r2, horizontalPixelRatio: h2, verticalPixelRatio: l2 } = i;
  r2.lineTo(e2.et * h2, t2 * l2), r2.lineTo(s.et * h2, t2 * l2), r2.closePath(), r2.fillStyle = n2, r2.fill();
}
__name(St$1, "St$1");
const _kt = class _kt extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    var i;
    if (this.tt === null)
      return;
    const { st: n2, nt: s, cs: e2, ht: r2, Wt: h2, ds: l2 } = this.tt, a2 = (i = this.tt.fs) !== null && i !== void 0 ? i : this.tt.vs ? 0 : t2.mediaSize.height;
    if (s === null)
      return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineJoin = "round", o2.lineWidth = r2, f(o2, h2), o2.lineWidth = 1, bt$1(t2, n2, l2, s, e2, this.ps.bind(this), St$1.bind(null, a2));
  }
};
__name(_kt, "kt");
let kt = _kt;
function yt$1(t2, i, n2) {
  return Math.min(Math.max(t2, i), n2);
}
__name(yt$1, "yt$1");
function Ct$1(t2, i, n2) {
  return i - t2 <= n2;
}
__name(Ct$1, "Ct$1");
function Tt$1(t2) {
  const i = Math.ceil(t2);
  return i % 2 == 0 ? i - 1 : i;
}
__name(Tt$1, "Tt$1");
var _a12;
let Pt$1 = (_a12 = class {
  bs(t2, i) {
    const n2 = this.ws, { gs: s, Ms: e2, xs: r2, Ss: h2, ks: l2, fs: a2 } = i;
    if (this.ys === void 0 || n2 === void 0 || n2.gs !== s || n2.Ms !== e2 || n2.xs !== r2 || n2.Ss !== h2 || n2.fs !== a2 || n2.ks !== l2) {
      const n3 = t2.context.createLinearGradient(0, 0, 0, l2);
      if (n3.addColorStop(0, s), a2 != null) {
        const i2 = yt$1(a2 * t2.verticalPixelRatio / l2, 0, 1);
        n3.addColorStop(i2, e2), n3.addColorStop(i2, r2);
      }
      n3.addColorStop(1, h2), this.ys = n3, this.ws = i;
    }
    return this.ys;
  }
}, __name(_a12, "Pt"), _a12);
var _a13;
let Rt$1 = (_a13 = class extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    return this.Cs.bs(t2, { gs: i.Ts, Ms: "", xs: "", Ss: i.Ps, ks: t2.bitmapSize.height });
  }
}, __name(_a13, "Rt"), _a13);
function Dt$1(t2, i) {
  const n2 = t2.context;
  n2.strokeStyle = i, n2.stroke();
}
__name(Dt$1, "Dt$1");
var _a14;
let Ot$1 = (_a14 = class extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    if (this.tt === null)
      return;
    const { st: i, nt: n2, cs: s, ds: e2, ht: r2, Wt: h2, Rs: l2 } = this.tt;
    if (n2 === null)
      return;
    const a2 = t2.context;
    a2.lineCap = "butt", a2.lineWidth = r2 * t2.verticalPixelRatio, f(a2, h2), a2.lineJoin = "round";
    const o2 = this.Ds.bind(this);
    e2 !== void 0 && bt$1(t2, i, e2, n2, s, o2, Dt$1), l2 && function(t3, i2, n3, s2, e3) {
      const { horizontalPixelRatio: r3, verticalPixelRatio: h3, context: l3 } = t3;
      let a3 = null;
      const o3 = Math.max(1, Math.floor(r3)) % 2 / 2, _24 = n3 * h3 + o3;
      for (let n4 = s2.to - 1; n4 >= s2.from; --n4) {
        const s3 = i2[n4];
        if (s3) {
          const i3 = e3(t3, s3);
          i3 !== a3 && (l3.beginPath(), a3 !== null && l3.fill(), l3.fillStyle = i3, a3 = i3);
          const n5 = Math.round(s3.et * r3) + o3, u2 = s3.rt * h3;
          l3.moveTo(n5, u2), l3.arc(n5, u2, _24, 0, 2 * Math.PI);
        }
      }
      l3.fill();
    }(t2, i, l2, n2, o2);
  }
}, __name(_a14, "Ot"), _a14);
var _a15;
let At$1 = (_a15 = class extends Ot$1 {
  Ds(t2, i) {
    return i._t;
  }
}, __name(_a15, "At"), _a15);
function Vt$1(t2, i, n2, s, e2 = 0, r2 = i.length) {
  let h2 = r2 - e2;
  for (; 0 < h2; ) {
    const r3 = h2 >> 1, l2 = e2 + r3;
    s(i[l2], n2) === t2 ? (e2 = l2 + 1, h2 -= r3 + 1) : h2 = r3;
  }
  return e2;
}
__name(Vt$1, "Vt$1");
const Bt$1 = Vt$1.bind(null, !0), It$1 = Vt$1.bind(null, !1);
function zt$1(t2, i) {
  return t2.ut < i;
}
__name(zt$1, "zt$1");
function Et$1(t2, i) {
  return i < t2.ut;
}
__name(Et$1, "Et$1");
function Lt$1(t2, i, n2) {
  const s = i.Os(), e2 = i.di(), r2 = Bt$1(t2, s, zt$1), h2 = It$1(t2, e2, Et$1);
  if (!n2)
    return { from: r2, to: h2 };
  let l2 = r2, a2 = h2;
  return r2 > 0 && r2 < t2.length && t2[r2].ut >= s && (l2 = r2 - 1), h2 > 0 && h2 < t2.length && t2[h2 - 1].ut <= e2 && (a2 = h2 + 1), { from: l2, to: a2 };
}
__name(Lt$1, "Lt$1");
var _a16;
let Nt$1 = (_a16 = class {
  constructor(t2, i, n2) {
    this.As = !0, this.Vs = !0, this.Bs = !0, this.Is = [], this.zs = null, this.Es = t2, this.Ls = i, this.Ns = n2;
  }
  gt(t2) {
    this.As = !0, t2 === "data" && (this.Vs = !0), t2 === "options" && (this.Bs = !0);
  }
  xt() {
    return this.Es.Tt() ? (this.Fs(), this.zs === null ? null : this.Ws) : null;
  }
  js() {
    this.Is = this.Is.map((t2) => Object.assign(Object.assign({}, t2), this.Es.$s().Hs(t2.ut)));
  }
  Us() {
    this.zs = null;
  }
  Fs() {
    this.Vs && (this.qs(), this.Vs = !1), this.Bs && (this.js(), this.Bs = !1), this.As && (this.Ys(), this.As = !1);
  }
  Ys() {
    const t2 = this.Es.At(), i = this.Ls.yt();
    if (this.Us(), i.Fi() || t2.Fi())
      return;
    const n2 = i.Xs();
    if (n2 === null || this.Es.In().Ks() === 0)
      return;
    const s = this.Es.Pt();
    s !== null && (this.zs = Lt$1(this.Is, n2, this.Ns), this.Zs(t2, i, s.Vt), this.Gs());
  }
}, __name(_a16, "Nt"), _a16);
var _a17;
let Ft$1 = (_a17 = class extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, !0);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.Qs(this.Is, n2, E(this.zs));
  }
  te(t2, i) {
    return { ut: t2, ct: i, et: NaN, rt: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => {
      const n2 = i.Vt[3];
      return this.ne(i.se, n2, t2);
    });
  }
}, __name(_a17, "Ft"), _a17);
var _a18;
let Wt$1 = (_a18 = class extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.ee = new Rt$1(), this.re = new At$1(), this.Ws.X([this.ee, this.re]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.ee.it({ ds: t2.lineType, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, fs: null, vs: t2.invertFilledArea, nt: this.zs, cs: this.Ls.yt().he() }), this.re.it({ ds: t2.lineVisible ? t2.lineType : void 0, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, nt: this.zs, cs: this.Ls.yt().he(), Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0 });
  }
}, __name(_a18, "Wt"), _a18);
var _a19;
let jt$1 = (_a19 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0, this.ae = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (this.Lt === null || this.Lt.In.length === 0 || this.Lt.nt === null)
      return;
    this.le = this.oe(i), this.le >= 2 && Math.max(1, Math.floor(i)) % 2 != this.le % 2 && this.le--, this.ae = this.Lt._e ? Math.min(this.le, Math.floor(i)) : this.le;
    let s = null;
    const e2 = this.ae <= this.le && this.Lt.he >= Math.floor(1.5 * i);
    for (let r2 = this.Lt.nt.from; r2 < this.Lt.nt.to; ++r2) {
      const h2 = this.Lt.In[r2];
      s !== h2.ue && (t2.fillStyle = h2.ue, s = h2.ue);
      const l2 = Math.floor(0.5 * this.ae), a2 = Math.round(h2.et * i), o2 = a2 - l2, _24 = this.ae, u2 = o2 + _24 - 1, c2 = Math.min(h2.ce, h2.de), d2 = Math.max(h2.ce, h2.de), f2 = Math.round(c2 * n2) - l2, v2 = Math.round(d2 * n2) + l2, p2 = Math.max(v2 - f2, this.ae);
      t2.fillRect(o2, f2, _24, p2);
      const m2 = Math.ceil(1.5 * this.le);
      if (e2) {
        if (this.Lt.fe) {
          const i3 = a2 - m2;
          let s3 = Math.max(f2, Math.round(h2.ve * n2) - l2), e4 = s3 + _24 - 1;
          e4 > f2 + p2 - 1 && (e4 = f2 + p2 - 1, s3 = e4 - _24 + 1), t2.fillRect(i3, s3, o2 - i3, e4 - s3 + 1);
        }
        const i2 = a2 + m2;
        let s2 = Math.max(f2, Math.round(h2.pe * n2) - l2), e3 = s2 + _24 - 1;
        e3 > f2 + p2 - 1 && (e3 = f2 + p2 - 1, s2 = e3 - _24 + 1), t2.fillRect(u2 + 1, s2, i2 - u2, e3 - s2 + 1);
      }
    }
  }
  oe(t2) {
    const i = Math.floor(t2);
    return Math.max(i, Math.floor(function(t3, i2) {
      return Math.floor(0.3 * t3 * i2);
    }(b(this.Lt).he, t2)));
  }
}, __name(_a19, "jt"), _a19);
var _a20;
let Ht$1 = (_a20 = class extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, !1);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.me(this.Is, n2, E(this.zs));
  }
  be(t2, i, n2) {
    return { ut: t2, we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3], et: NaN, ve: NaN, ce: NaN, de: NaN, pe: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => this.ne(i.se, i, t2));
  }
}, __name(_a20, "Ht"), _a20);
var _a21;
let $t$1 = (_a21 = class extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new jt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), fe: t2.openVisible, _e: t2.thinBars, nt: this.zs });
  }
}, __name(_a21, "$t"), _a21);
var _a22;
let Ut$1 = (_a22 = class extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    const n2 = this.tt;
    return this.Cs.bs(t2, { gs: i.Se, Ms: i.ke, xs: i.ye, Ss: i.Ce, ks: t2.bitmapSize.height, fs: n2.fs });
  }
}, __name(_a22, "Ut"), _a22);
var _a23;
let qt$1 = (_a23 = class extends Ot$1 {
  constructor() {
    super(...arguments), this.Te = new Pt$1();
  }
  Ds(t2, i) {
    const n2 = this.tt;
    return this.Te.bs(t2, { gs: i.Pe, Ms: i.Pe, xs: i.Re, Ss: i.Re, ks: t2.bitmapSize.height, fs: n2.fs });
  }
}, __name(_a23, "qt"), _a23);
var _a24;
let Yt$1 = (_a24 = class extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.De = new Ut$1(), this.Oe = new qt$1(), this.Ws.X([this.De, this.Oe]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.Pt();
    if (t2 === null)
      return;
    const i = this.Es.W(), n2 = this.Es.At().Ot(i.baseValue.price, t2.Vt), s = this.Ls.yt().he();
    this.De.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineType, fs: n2, vs: !1, nt: this.zs, cs: s }), this.Oe.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineVisible ? i.lineType : void 0, Rs: i.pointMarkersVisible ? i.pointMarkersRadius || i.lineWidth / 2 + 2 : void 0, fs: n2, nt: this.zs, cs: s });
  }
}, __name(_a24, "Yt"), _a24);
var _a25;
let Xt$1 = (_a25 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z(t2) {
    if (this.Lt === null || this.Lt.In.length === 0 || this.Lt.nt === null)
      return;
    const { horizontalPixelRatio: i } = t2;
    this.le = function(t3, i2) {
      if (t3 >= 2.5 && t3 <= 4)
        return Math.floor(3 * i2);
      const n3 = 1 - 0.2 * Math.atan(Math.max(4, t3) - 4) / (0.5 * Math.PI), s2 = Math.floor(t3 * n3 * i2), e2 = Math.floor(t3 * i2), r2 = Math.min(s2, e2);
      return Math.max(Math.floor(i2), r2);
    }(this.Lt.he, i), this.le >= 2 && Math.floor(i) % 2 != this.le % 2 && this.le--;
    const n2 = this.Lt.In;
    this.Lt.Ae && this.Ve(t2, n2, this.Lt.nt), this.Lt.ci && this.Be(t2, n2, this.Lt.nt);
    const s = this.Ie(i);
    (!this.Lt.ci || this.le > 2 * s) && this.ze(t2, n2, this.Lt.nt);
  }
  Ve(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "", l2 = Math.min(Math.floor(e2), Math.floor(this.Lt.he * e2));
    l2 = Math.max(Math.floor(e2), Math.min(l2, this.le));
    const a2 = Math.floor(0.5 * l2);
    let o2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Ee !== h2 && (s.fillStyle = n3.Ee, h2 = n3.Ee);
      const _24 = Math.round(Math.min(n3.ve, n3.pe) * r2), u2 = Math.round(Math.max(n3.ve, n3.pe) * r2), c2 = Math.round(n3.ce * r2), d2 = Math.round(n3.de * r2);
      let f2 = Math.round(e2 * n3.et) - a2;
      const v2 = f2 + l2 - 1;
      o2 !== null && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, v2));
      const p2 = v2 - f2 + 1;
      s.fillRect(f2, c2, p2, _24 - c2), s.fillRect(f2, u2 + 1, p2, d2 - u2), o2 = v2;
    }
  }
  Ie(t2) {
    let i = Math.floor(1 * t2);
    this.le <= 2 * i && (i = Math.floor(0.5 * (this.le - 1)));
    const n2 = Math.max(Math.floor(t2), i);
    return this.le <= 2 * n2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : n2;
  }
  Be(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e2);
    let a2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Le !== h2 && (s.fillStyle = n3.Le, h2 = n3.Le);
      let o2 = Math.round(n3.et * e2) - Math.floor(0.5 * this.le);
      const _24 = o2 + this.le - 1, u2 = Math.round(Math.min(n3.ve, n3.pe) * r2), c2 = Math.round(Math.max(n3.ve, n3.pe) * r2);
      if (a2 !== null && (o2 = Math.max(a2 + 1, o2), o2 = Math.min(o2, _24)), this.Lt.he * e2 > 2 * l2)
        Z$1(s, o2, u2, _24 - o2 + 1, c2 - u2 + 1, l2);
      else {
        const t4 = _24 - o2 + 1;
        s.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      a2 = _24;
    }
  }
  ze(t2, i, n2) {
    if (this.Lt === null)
      return;
    const { context: s, horizontalPixelRatio: e2, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e2);
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      let a2 = Math.round(Math.min(n3.ve, n3.pe) * r2), o2 = Math.round(Math.max(n3.ve, n3.pe) * r2), _24 = Math.round(n3.et * e2) - Math.floor(0.5 * this.le), u2 = _24 + this.le - 1;
      if (n3.ue !== h2) {
        const t4 = n3.ue;
        s.fillStyle = t4, h2 = t4;
      }
      this.Lt.ci && (_24 += l2, a2 += l2, u2 -= l2, o2 -= l2), a2 > o2 || s.fillRect(_24, a2, u2 - _24 + 1, o2 - a2 + 1);
    }
  }
}, __name(_a25, "Xt"), _a25);
var _a26;
let Kt$1 = (_a26 = class extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new Xt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), Ae: t2.wickVisible, ci: t2.borderVisible, nt: this.zs });
  }
}, __name(_a26, "Kt"), _a26);
var _a27;
let Zt$1 = (_a27 = class {
  constructor(t2, i) {
    this.Ne = t2, this.Li = i;
  }
  K(t2, i, n2) {
    this.Ne.draw(t2, this.Li, i, n2);
  }
}, __name(_a27, "Zt"), _a27);
var _a28;
let Gt$1 = (_a28 = class extends Nt$1 {
  constructor(t2, i, n2) {
    super(t2, i, !1), this.wn = n2, this.Ws = new Zt$1(this.wn.renderer(), (i2) => {
      const n3 = t2.Pt();
      return n3 === null ? null : t2.At().Ot(i2, n3.Vt);
    });
  }
  Fe(t2) {
    return this.wn.priceValueBuilder(t2);
  }
  We(t2) {
    return this.wn.isWhitespace(t2);
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => Object.assign(Object.assign({ ut: i.se, et: NaN }, t2.Hs(i.se)), { je: i.He }));
  }
  Zs(t2, i) {
    i.Js(this.Is, E(this.zs));
  }
  Gs() {
    this.wn.update({ bars: this.Is.map(Jt$1), barSpacing: this.Ls.yt().he(), visibleRange: this.zs }, this.Es.W());
  }
}, __name(_a28, "Gt"), _a28);
function Jt$1(t2) {
  return { x: t2.et, time: t2.ut, originalData: t2.je, barColor: t2.ue };
}
__name(Jt$1, "Jt$1");
var _a29;
let Qt$1 = (_a29 = class extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.$e = [];
  }
  it(t2) {
    this.Lt = t2, this.$e = [];
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (this.Lt === null || this.Lt.st.length === 0 || this.Lt.nt === null)
      return;
    this.$e.length || this.Ue(i);
    const s = Math.max(1, Math.floor(n2)), e2 = Math.round(this.Lt.qe * n2) - Math.floor(s / 2), r2 = e2 + s;
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const h2 = this.Lt.st[i2], l2 = this.$e[i2 - this.Lt.nt.from], a2 = Math.round(h2.rt * n2);
      let o2, _24;
      t2.fillStyle = h2.ue, a2 <= e2 ? (o2 = a2, _24 = r2) : (o2 = e2, _24 = a2 - Math.floor(s / 2) + s), t2.fillRect(l2.Os, o2, l2.di - l2.Os + 1, _24 - o2);
    }
  }
  Ue(t2) {
    if (this.Lt === null || this.Lt.st.length === 0 || this.Lt.nt === null)
      return void (this.$e = []);
    const i = Math.ceil(this.Lt.he * t2) <= 1 ? 0 : Math.max(1, Math.floor(t2)), n2 = Math.round(this.Lt.he * t2) - i;
    this.$e = new Array(this.Lt.nt.to - this.Lt.nt.from);
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const s2 = this.Lt.st[i2], e2 = Math.round(s2.et * t2);
      let r2, h2;
      if (n2 % 2) {
        const t3 = (n2 - 1) / 2;
        r2 = e2 - t3, h2 = e2 + t3;
      } else {
        const t3 = n2 / 2;
        r2 = e2 - t3, h2 = e2 + t3 - 1;
      }
      this.$e[i2 - this.Lt.nt.from] = { Os: r2, di: h2, Ye: e2, Xe: s2.et * t2, ut: s2.ut };
    }
    for (let t3 = this.Lt.nt.from + 1; t3 < this.Lt.nt.to; t3++) {
      const n3 = this.$e[t3 - this.Lt.nt.from], s2 = this.$e[t3 - this.Lt.nt.from - 1];
      n3.ut === s2.ut + 1 && n3.Os - s2.di !== i + 1 && (s2.Ye > s2.Xe ? s2.di = n3.Os - i - 1 : n3.Os = s2.di + i + 1);
    }
    let s = Math.ceil(this.Lt.he * t2);
    for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
      const i2 = this.$e[t3 - this.Lt.nt.from];
      i2.di < i2.Os && (i2.di = i2.Os);
      const n3 = i2.di - i2.Os + 1;
      s = Math.min(n3, s);
    }
    if (i > 0 && s < 4)
      for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
        const i2 = this.$e[t3 - this.Lt.nt.from];
        i2.di - i2.Os + 1 > s && (i2.Ye > i2.Xe ? i2.di -= 1 : i2.Os += 1);
      }
  }
}, __name(_a29, "Qt"), _a29);
const _ti = class _ti extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new Qt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = { st: this.Is, he: this.Ls.yt().he(), nt: this.zs, qe: this.Es.At().Ot(this.Es.W().base, b(this.Es.Pt()).Vt) };
    this.Ws.it(t2);
  }
};
__name(_ti, "ti");
let ti = _ti;
const _ii = class _ii extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new At$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W(), i = { st: this.Is, Wt: t2.lineStyle, ds: t2.lineVisible ? t2.lineType : void 0, ht: t2.lineWidth, Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0, nt: this.zs, cs: this.Ls.yt().he() };
    this.Ws.it(i);
  }
};
__name(_ii, "ii");
let ii = _ii;
const ni = /[2-9]/g, _si = class _si {
  constructor(t2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Je = {}, this.Qe = /* @__PURE__ */ new Map(), this.tr = t2;
  }
  ir() {
    this.Ke = 0, this.Qe.clear(), this.Ze = 1, this.Ge = 1, this.Je = {};
  }
  Si(t2, i, n2) {
    return this.nr(t2, i, n2).width;
  }
  xi(t2, i, n2) {
    const s = this.nr(t2, i, n2);
    return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2;
  }
  nr(t2, i, n2) {
    const s = n2 || ni, e2 = String(i).replace(s, "0");
    if (this.Qe.has(e2))
      return m$1(this.Qe.get(e2)).sr;
    if (this.Ke === this.tr) {
      const t3 = this.Je[this.Ge];
      delete this.Je[this.Ge], this.Qe.delete(t3), this.Ge++, this.Ke--;
    }
    t2.save(), t2.textBaseline = "middle";
    const r2 = t2.measureText(e2);
    return t2.restore(), r2.width === 0 && i.length || (this.Qe.set(e2, { sr: r2, er: this.Ze }), this.Je[this.Ze] = e2, this.Ke++, this.Ze++), r2;
  }
};
__name(_si, "si");
let si = _si;
const _ei = class _ei {
  constructor(t2) {
    this.rr = null, this.k = null, this.hr = "right", this.lr = t2;
  }
  ar(t2, i, n2) {
    this.rr = t2, this.k = i, this.hr = n2;
  }
  K(t2) {
    this.k !== null && this.rr !== null && this.rr.K(t2, this.k, this.lr, this.hr);
  }
};
__name(_ei, "ei");
let ei = _ei;
const _ri = class _ri {
  constructor(t2, i, n2) {
    this._r = t2, this.lr = new si(50), this.ur = i, this.F = n2, this.j = -1, this.Ht = new ei(this.lr);
  }
  xt() {
    const t2 = this.F.cr(this.ur);
    if (t2 === null)
      return null;
    const i = t2.dr(this.ur) ? t2.vr() : this.ur.At();
    if (i === null)
      return null;
    const n2 = t2.pr(i);
    if (n2 === "overlay")
      return null;
    const s = this.F.mr();
    return s.P !== this.j && (this.j = s.P, this.lr.ir()), this.Ht.ar(this._r.zi(), s, n2), this.Ht;
  }
};
__name(_ri, "ri");
let ri = _ri;
const _hi = class _hi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  br(t2, i) {
    var n2;
    if (!(!((n2 = this.Lt) === null || n2 === void 0) && n2.Tt))
      return null;
    const { rt: s, ht: e2, wr: r2 } = this.Lt;
    return i >= s - e2 - 7 && i <= s + e2 + 7 ? { gr: this.Lt, wr: r2 } : null;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null || this.Lt.Tt === !1)
      return;
    const e2 = Math.round(this.Lt.rt * s);
    e2 < 0 || e2 > i.height || (t2.lineCap = "butt", t2.strokeStyle = this.Lt.O, t2.lineWidth = Math.floor(this.Lt.ht * n2), f(t2, this.Lt.Wt), v(t2, e2, 0, i.width));
  }
};
__name(_hi, "hi");
let hi = _hi;
const _li = class _li {
  constructor(t2) {
    this.Mr = { rt: 0, O: "rgba(0, 0, 0, 0)", ht: 1, Wt: 0, Tt: !1 }, this.Sr = new hi(), this.bt = !0, this.Es = t2, this.Ls = t2.qt(), this.Sr.it(this.Mr);
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.Es.Tt() ? (this.bt && (this.kr(), this.bt = !1), this.Sr) : null;
  }
};
__name(_li, "li");
let li = _li;
const _ai = class _ai extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    this.Mr.Tt = !1;
    const t2 = this.Es.At(), i = t2.yr().yr;
    if (i !== 2 && i !== 3)
      return;
    const n2 = this.Es.W();
    if (!n2.baseLineVisible || !this.Es.Tt())
      return;
    const s = this.Es.Pt();
    s !== null && (this.Mr.Tt = !0, this.Mr.rt = t2.Ot(s.Vt, s.Vt), this.Mr.O = n2.baseLineColor, this.Mr.ht = n2.baseLineWidth, this.Mr.Wt = n2.baseLineStyle);
  }
};
__name(_ai, "ai");
let ai = _ai;
const _oi = class _oi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  He() {
    return this.Lt;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    const s = this.Lt;
    if (s === null)
      return;
    const e2 = Math.max(1, Math.floor(i)), r2 = e2 % 2 / 2, h2 = Math.round(s.Xe.x * i) + r2, l2 = s.Xe.y * n2;
    t2.fillStyle = s.Cr, t2.beginPath();
    const a2 = Math.max(2, 1.5 * s.Tr) * i;
    t2.arc(h2, l2, a2, 0, 2 * Math.PI, !1), t2.fill(), t2.fillStyle = s.Pr, t2.beginPath(), t2.arc(h2, l2, s.ot * i, 0, 2 * Math.PI, !1), t2.fill(), t2.lineWidth = e2, t2.strokeStyle = s.Rr, t2.beginPath(), t2.arc(h2, l2, s.ot * i + e2 / 2, 0, 2 * Math.PI, !1), t2.stroke();
  }
};
__name(_oi, "oi");
let oi = _oi;
const _i = [{ Dr: 0, Or: 0.25, Ar: 4, Vr: 10, Br: 0.25, Ir: 0, zr: 0.4, Er: 0.8 }, { Dr: 0.25, Or: 0.525, Ar: 10, Vr: 14, Br: 0, Ir: 0, zr: 0.8, Er: 0 }, { Dr: 0.525, Or: 1, Ar: 14, Vr: 14, Br: 0, Ir: 0, zr: 0, Er: 0 }];
function ui(t2, i, n2, s) {
  return function(t3, i2) {
    if (t3 === "transparent")
      return t3;
    const n3 = T$1(t3), s2 = n3[3];
    return `rgba(${n3[0]}, ${n3[1]}, ${n3[2]}, ${i2 * s2})`;
  }(t2, n2 + (s - n2) * i);
}
__name(ui, "ui");
function ci(t2, i) {
  const n2 = t2 % 2600 / 2600;
  let s;
  for (const t3 of _i)
    if (n2 >= t3.Dr && n2 <= t3.Or) {
      s = t3;
      break;
    }
  p$1(s !== void 0, "Last price animation internal logic error");
  const e2 = (n2 - s.Dr) / (s.Or - s.Dr);
  return { Pr: ui(i, e2, s.Br, s.Ir), Rr: ui(i, e2, s.zr, s.Er), ot: (r2 = e2, h2 = s.Ar, l2 = s.Vr, h2 + (l2 - h2) * r2) };
  var r2, h2, l2;
}
__name(ci, "ci");
const _di = class _di {
  constructor(t2) {
    this.Ht = new oi(), this.bt = !0, this.Lr = !0, this.Nr = performance.now(), this.Fr = this.Nr - 1, this.Wr = t2;
  }
  jr() {
    this.Fr = this.Nr - 1, this.gt();
  }
  Hr() {
    if (this.gt(), this.Wr.W().lastPriceAnimation === 2) {
      const t2 = performance.now(), i = this.Fr - t2;
      if (i > 0)
        return void (i < 650 && (this.Fr += 2600));
      this.Nr = t2, this.Fr = t2 + 2600;
    }
  }
  gt() {
    this.bt = !0;
  }
  $r() {
    this.Lr = !0;
  }
  Tt() {
    return this.Wr.W().lastPriceAnimation !== 0;
  }
  Ur() {
    switch (this.Wr.W().lastPriceAnimation) {
      case 0:
        return !1;
      case 1:
        return !0;
      case 2:
        return performance.now() <= this.Fr;
    }
  }
  xt() {
    return this.bt ? (this.St(), this.bt = !1, this.Lr = !1) : this.Lr && (this.qr(), this.Lr = !1), this.Ht;
  }
  St() {
    this.Ht.it(null);
    const t2 = this.Wr.qt().yt(), i = t2.Xs(), n2 = this.Wr.Pt();
    if (i === null || n2 === null)
      return;
    const s = this.Wr.Yr(!0);
    if (s.Xr || !i.Kr(s.se))
      return;
    const e2 = { x: t2.Et(s.se), y: this.Wr.At().Ot(s.ct, n2.Vt) }, r2 = s.O, h2 = this.Wr.W().lineWidth, l2 = ci(this.Zr(), r2);
    this.Ht.it({ Cr: r2, Tr: h2, Pr: l2.Pr, Rr: l2.Rr, ot: l2.ot, Xe: e2 });
  }
  qr() {
    const t2 = this.Ht.He();
    if (t2 !== null) {
      const i = ci(this.Zr(), t2.Cr);
      t2.Pr = i.Pr, t2.Rr = i.Rr, t2.ot = i.ot;
    }
  }
  Zr() {
    return this.Ur() ? performance.now() - this.Nr : 2599;
  }
};
__name(_di, "di");
let di = _di;
function fi(t2, i) {
  return Tt$1(Math.min(Math.max(t2, 12), 30) * i);
}
__name(fi, "fi");
function vi(t2, i) {
  switch (t2) {
    case "arrowDown":
    case "arrowUp":
      return fi(i, 1);
    case "circle":
      return fi(i, 0.8);
    case "square":
      return fi(i, 0.7);
  }
}
__name(vi, "vi");
function pi(t2) {
  return function(t3) {
    const i = Math.ceil(t3);
    return i % 2 != 0 ? i - 1 : i;
  }(fi(t2, 1));
}
__name(pi, "pi");
function mi(t2) {
  return Math.max(fi(t2, 0.1), 3);
}
__name(mi, "mi");
function bi(t2, i, n2, s, e2) {
  const r2 = vi("square", n2), h2 = (r2 - 1) / 2, l2 = t2 - h2, a2 = i - h2;
  return s >= l2 && s <= l2 + r2 && e2 >= a2 && e2 <= a2 + r2;
}
__name(bi, "bi");
function wi(t2, i, n2, s, e2) {
  const r2 = (vi("arrowUp", e2) - 1) / 2, h2 = (Tt$1(e2 / 2) - 1) / 2;
  i.beginPath(), t2 ? (i.moveTo(n2 - r2, s), i.lineTo(n2, s - r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s + r2), i.lineTo(n2 - h2, s + r2), i.lineTo(n2 - h2, s)) : (i.moveTo(n2 - r2, s), i.lineTo(n2, s + r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s - r2), i.lineTo(n2 - h2, s - r2), i.lineTo(n2 - h2, s)), i.fill();
}
__name(wi, "wi");
function gi(t2, i, n2, s, e2, r2) {
  return bi(i, n2, s, e2, r2);
}
__name(gi, "gi");
const _Mi = class _Mi extends j {
  constructor() {
    super(...arguments), this.Lt = null, this.lr = new si(), this.j = -1, this.H = "", this.Gr = "";
  }
  it(t2) {
    this.Lt = t2;
  }
  ar(t2, i) {
    this.j === t2 && this.H === i || (this.j = t2, this.H = i, this.Gr = N$1(t2, i), this.lr.ir());
  }
  br(t2, i) {
    if (this.Lt === null || this.Lt.nt === null)
      return null;
    for (let n2 = this.Lt.nt.from; n2 < this.Lt.nt.to; n2++) {
      const s = this.Lt.st[n2];
      if (Si(s, t2, i))
        return { gr: s.Jr, wr: s.wr };
    }
    return null;
  }
  Z({ context: t2 }, i, n2) {
    if (this.Lt !== null && this.Lt.nt !== null) {
      t2.textBaseline = "middle", t2.font = this.Gr;
      for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
        const n3 = this.Lt.st[i2];
        n3.Jt !== void 0 && (n3.Jt.$i = this.lr.Si(t2, n3.Jt.Qr), n3.Jt.zt = this.j, n3.Jt.et = n3.et - n3.Jt.$i / 2), xi(n3, t2);
      }
    }
  }
};
__name(_Mi, "Mi");
let Mi = _Mi;
function xi(t2, i) {
  i.fillStyle = t2.O, t2.Jt !== void 0 && function(t3, i2, n2, s) {
    t3.fillText(i2, n2, s);
  }(i, t2.Jt.Qr, t2.Jt.et, t2.Jt.rt), function(t3, i2) {
    if (t3.Ks !== 0) {
      switch (t3.th) {
        case "arrowDown":
          return void wi(!1, i2, t3.et, t3.rt, t3.Ks);
        case "arrowUp":
          return void wi(!0, i2, t3.et, t3.rt, t3.Ks);
        case "circle":
          return void function(t4, i3, n2, s) {
            const e2 = (vi("circle", s) - 1) / 2;
            t4.beginPath(), t4.arc(i3, n2, e2, 0, 2 * Math.PI, !1), t4.fill();
          }(i2, t3.et, t3.rt, t3.Ks);
        case "square":
          return void function(t4, i3, n2, s) {
            const e2 = vi("square", s), r2 = (e2 - 1) / 2, h2 = i3 - r2, l2 = n2 - r2;
            t4.fillRect(h2, l2, e2, e2);
          }(i2, t3.et, t3.rt, t3.Ks);
      }
      t3.th;
    }
  }(t2, i);
}
__name(xi, "xi");
function Si(t2, i, n2) {
  return !(t2.Jt === void 0 || !function(t3, i2, n3, s, e2, r2) {
    const h2 = s / 2;
    return e2 >= t3 && e2 <= t3 + n3 && r2 >= i2 - h2 && r2 <= i2 + h2;
  }(t2.Jt.et, t2.Jt.rt, t2.Jt.$i, t2.Jt.zt, i, n2)) || function(t3, i2, n3) {
    if (t3.Ks === 0)
      return !1;
    switch (t3.th) {
      case "arrowDown":
      case "arrowUp":
        return gi(0, t3.et, t3.rt, t3.Ks, i2, n3);
      case "circle":
        return function(t4, i3, n4, s, e2) {
          const r2 = 2 + vi("circle", n4) / 2, h2 = t4 - s, l2 = i3 - e2;
          return Math.sqrt(h2 * h2 + l2 * l2) <= r2;
        }(t3.et, t3.rt, t3.Ks, i2, n3);
      case "square":
        return bi(t3.et, t3.rt, t3.Ks, i2, n3);
    }
  }(t2, i, n2);
}
__name(Si, "Si");
function ki(t2, i, n2, s, e2, r2, h2, l2, a2) {
  const o2 = O$1(n2) ? n2 : n2.xe, _24 = O$1(n2) ? n2 : n2.ge, u2 = O$1(n2) ? n2 : n2.Me, c2 = O$1(i.size) ? Math.max(i.size, 0) : 1, d2 = pi(l2.he()) * c2, f2 = d2 / 2;
  switch (t2.Ks = d2, i.position) {
    case "inBar":
      return t2.rt = h2.Ot(o2, a2), void (t2.Jt !== void 0 && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e2));
    case "aboveBar":
      return t2.rt = h2.Ot(_24, a2) - f2 - s.ih, t2.Jt !== void 0 && (t2.Jt.rt = t2.rt - f2 - 0.6 * e2, s.ih += 1.2 * e2), void (s.ih += d2 + r2);
    case "belowBar":
      return t2.rt = h2.Ot(u2, a2) + f2 + s.nh, t2.Jt !== void 0 && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e2, s.nh += 1.2 * e2), void (s.nh += d2 + r2);
  }
  i.position;
}
__name(ki, "ki");
const _yi = class _yi {
  constructor(t2, i) {
    this.bt = !0, this.sh = !0, this.eh = !0, this.rh = null, this.Ht = new Mi(), this.Wr = t2, this.Ui = i, this.Lt = { st: [], nt: null };
  }
  gt(t2) {
    this.bt = !0, this.eh = !0, t2 === "data" && (this.sh = !0);
  }
  xt(t2) {
    if (!this.Wr.Tt())
      return null;
    this.bt && this.hh();
    const i = this.Ui.W().layout;
    return this.Ht.ar(i.fontSize, i.fontFamily), this.Ht.it(this.Lt), this.Ht;
  }
  lh() {
    if (this.eh) {
      if (this.Wr.ah().length > 0) {
        const t2 = this.Ui.yt().he(), i = mi(t2), n2 = 1.5 * pi(t2) + 2 * i;
        this.rh = { above: n2, below: n2 };
      } else
        this.rh = null;
      this.eh = !1;
    }
    return this.rh;
  }
  hh() {
    const t2 = this.Wr.At(), i = this.Ui.yt(), n2 = this.Wr.ah();
    this.sh && (this.Lt.st = n2.map((t3) => ({ ut: t3.time, et: 0, rt: 0, Ks: 0, th: t3.shape, O: t3.color, Jr: t3.Jr, wr: t3.id, Jt: void 0 })), this.sh = !1);
    const s = this.Ui.W().layout;
    this.Lt.nt = null;
    const e2 = i.Xs();
    if (e2 === null)
      return;
    const r2 = this.Wr.Pt();
    if (r2 === null || this.Lt.st.length === 0)
      return;
    let h2 = NaN;
    const l2 = mi(i.he()), a2 = { ih: l2, nh: l2 };
    this.Lt.nt = Lt$1(this.Lt.st, e2, !0);
    for (let e3 = this.Lt.nt.from; e3 < this.Lt.nt.to; e3++) {
      const o2 = n2[e3];
      o2.time !== h2 && (a2.ih = l2, a2.nh = l2, h2 = o2.time);
      const _24 = this.Lt.st[e3];
      _24.et = i.Et(o2.time), o2.text !== void 0 && o2.text.length > 0 && (_24.Jt = { Qr: o2.text, et: 0, rt: 0, $i: 0, zt: 0 });
      const u2 = this.Wr.oh(o2.time);
      u2 !== null && ki(_24, o2, u2, a2, s.fontSize, l2, t2, i, r2.Vt);
    }
    this.bt = !1;
  }
};
__name(_yi, "yi");
let yi = _yi;
const _Ci = class _Ci extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = !1;
    const i = this.Es.W();
    if (!i.priceLineVisible || !this.Es.Tt())
      return;
    const n2 = this.Es.Yr(i.priceLineSource === 0);
    n2.Xr || (t2.Tt = !0, t2.rt = n2.yi, t2.O = this.Es._h(n2.O), t2.ht = i.priceLineWidth, t2.Wt = i.priceLineStyle);
  }
};
__name(_Ci, "Ci");
let Ci = _Ci;
const _Ti = class _Ti extends st {
  constructor(t2) {
    super(), this.$t = t2;
  }
  Ei(t2, i, n2) {
    t2.Tt = !1, i.Tt = !1;
    const s = this.$t;
    if (!s.Tt())
      return;
    const e2 = s.W(), r2 = e2.lastValueVisible, h2 = s.uh() !== "", l2 = e2.seriesLastValueMode === 0, a2 = s.Yr(!1);
    if (a2.Xr)
      return;
    r2 && (t2.Jt = this.dh(a2, r2, l2), t2.Tt = t2.Jt.length !== 0), (h2 || l2) && (i.Jt = this.fh(a2, r2, h2, l2), i.Tt = i.Jt.length > 0);
    const o2 = s._h(a2.O), _24 = P(o2);
    n2.t = _24.t, n2.yi = a2.yi, i.Bt = s.qt().It(a2.yi / s.At().zt()), t2.Bt = o2, t2.O = _24.i, i.O = _24.i;
  }
  fh(t2, i, n2, s) {
    let e2 = "";
    const r2 = this.$t.uh();
    return n2 && r2.length !== 0 && (e2 += `${r2} `), i && s && (e2 += this.$t.At().ph() ? t2.mh : t2.bh), e2.trim();
  }
  dh(t2, i, n2) {
    return i ? n2 ? this.$t.At().ph() ? t2.bh : t2.mh : t2.Jt : "";
  }
};
__name(_Ti, "Ti");
let Ti = _Ti;
function Pi(t2, i, n2, s) {
  const e2 = Number.isFinite(i), r2 = Number.isFinite(n2);
  return e2 && r2 ? t2(i, n2) : e2 || r2 ? e2 ? i : n2 : s;
}
__name(Pi, "Pi");
const _Ri = class _Ri {
  constructor(t2, i) {
    this.wh = t2, this.gh = i;
  }
  Mh(t2) {
    return t2 !== null && this.wh === t2.wh && this.gh === t2.gh;
  }
  xh() {
    return new _Ri(this.wh, this.gh);
  }
  Sh() {
    return this.wh;
  }
  kh() {
    return this.gh;
  }
  yh() {
    return this.gh - this.wh;
  }
  Fi() {
    return this.gh === this.wh || Number.isNaN(this.gh) || Number.isNaN(this.wh);
  }
  ts(t2) {
    return t2 === null ? this : new _Ri(Pi(Math.min, this.Sh(), t2.Sh(), -1 / 0), Pi(Math.max, this.kh(), t2.kh(), 1 / 0));
  }
  Ch(t2) {
    if (!O$1(t2) || this.gh - this.wh === 0)
      return;
    const i = 0.5 * (this.gh + this.wh);
    let n2 = this.gh - i, s = this.wh - i;
    n2 *= t2, s *= t2, this.gh = i + n2, this.wh = i + s;
  }
  Th(t2) {
    O$1(t2) && (this.gh += t2, this.wh += t2);
  }
  Ph() {
    return { minValue: this.wh, maxValue: this.gh };
  }
  static Rh(t2) {
    return t2 === null ? null : new _Ri(t2.minValue, t2.maxValue);
  }
};
__name(_Ri, "Ri");
let Ri = _Ri;
const _Di = class _Di {
  constructor(t2, i) {
    this.Dh = t2, this.Oh = i || null;
  }
  Ah() {
    return this.Dh;
  }
  Vh() {
    return this.Oh;
  }
  Ph() {
    return this.Dh === null ? null : { priceRange: this.Dh.Ph(), margins: this.Oh || void 0 };
  }
  static Rh(t2) {
    return t2 === null ? null : new _Di(Ri.Rh(t2.priceRange), t2.margins);
  }
};
__name(_Di, "Di");
let Di = _Di;
const _Oi = class _Oi extends li {
  constructor(t2, i) {
    super(t2), this.Bh = i;
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = !1;
    const i = this.Bh.W();
    if (!this.Es.Tt() || !i.lineVisible)
      return;
    const n2 = this.Bh.Ih();
    n2 !== null && (t2.Tt = !0, t2.rt = n2, t2.O = i.color, t2.ht = i.lineWidth, t2.Wt = i.lineStyle, t2.wr = this.Bh.W().id);
  }
};
__name(_Oi, "Oi");
let Oi = _Oi;
const _Ai = class _Ai extends st {
  constructor(t2, i) {
    super(), this.Wr = t2, this.Bh = i;
  }
  Ei(t2, i, n2) {
    t2.Tt = !1, i.Tt = !1;
    const s = this.Bh.W(), e2 = s.axisLabelVisible, r2 = s.title !== "", h2 = this.Wr;
    if (!e2 || !h2.Tt())
      return;
    const l2 = this.Bh.Ih();
    if (l2 === null)
      return;
    r2 && (i.Jt = s.title, i.Tt = !0), i.Bt = h2.qt().It(l2 / h2.At().zt()), t2.Jt = this.zh(s.price), t2.Tt = !0;
    const a2 = P(s.axisLabelColor || s.color);
    n2.t = a2.t;
    const o2 = s.axisLabelTextColor || a2.i;
    t2.O = o2, i.O = o2, n2.yi = l2;
  }
  zh(t2) {
    const i = this.Wr.Pt();
    return i === null ? "" : this.Wr.At().Wi(t2, i.Vt);
  }
};
__name(_Ai, "Ai");
let Ai = _Ai;
const _Vi = class _Vi {
  constructor(t2, i) {
    this.Wr = t2, this.cn = i, this.Eh = new Oi(t2, this), this._r = new Ai(t2, this), this.Lh = new ri(this._r, t2, t2.qt());
  }
  Nh(t2) {
    D$1(this.cn, t2), this.gt(), this.Wr.qt().Fh();
  }
  W() {
    return this.cn;
  }
  Wh() {
    return this.Eh;
  }
  jh() {
    return this.Lh;
  }
  Hh() {
    return this._r;
  }
  gt() {
    this.Eh.gt(), this._r.gt();
  }
  Ih() {
    const t2 = this.Wr, i = t2.At();
    if (t2.qt().yt().Fi() || i.Fi())
      return null;
    const n2 = t2.Pt();
    return n2 === null ? null : i.Ot(this.cn.price, n2.Vt);
  }
};
__name(_Vi, "Vi");
let Vi = _Vi;
const _Bi = class _Bi extends at$1 {
  constructor(t2) {
    super(), this.Ui = t2;
  }
  qt() {
    return this.Ui;
  }
};
__name(_Bi, "Bi");
let Bi = _Bi;
const Ii = { Bar: (t2, i, n2, s) => {
  var e2;
  const r2 = i.upColor, h2 = i.downColor, l2 = b(t2(n2, s)), a2 = w$1(l2.Vt[0]) <= w$1(l2.Vt[3]);
  return { ue: (e2 = l2.O) !== null && e2 !== void 0 ? e2 : a2 ? r2 : h2 };
}, Candlestick: (t2, i, n2, s) => {
  var e2, r2, h2;
  const l2 = i.upColor, a2 = i.downColor, o2 = i.borderUpColor, _24 = i.borderDownColor, u2 = i.wickUpColor, c2 = i.wickDownColor, d2 = b(t2(n2, s)), f2 = w$1(d2.Vt[0]) <= w$1(d2.Vt[3]);
  return { ue: (e2 = d2.O) !== null && e2 !== void 0 ? e2 : f2 ? l2 : a2, Le: (r2 = d2.Bt) !== null && r2 !== void 0 ? r2 : f2 ? o2 : _24, Ee: (h2 = d2.$h) !== null && h2 !== void 0 ? h2 : f2 ? u2 : c2 };
}, Custom: (t2, i, n2, s) => {
  var e2;
  return { ue: (e2 = b(t2(n2, s)).O) !== null && e2 !== void 0 ? e2 : i.color };
}, Area: (t2, i, n2, s) => {
  var e2, r2, h2, l2;
  const a2 = b(t2(n2, s));
  return { ue: (e2 = a2._t) !== null && e2 !== void 0 ? e2 : i.lineColor, _t: (r2 = a2._t) !== null && r2 !== void 0 ? r2 : i.lineColor, Ts: (h2 = a2.Ts) !== null && h2 !== void 0 ? h2 : i.topColor, Ps: (l2 = a2.Ps) !== null && l2 !== void 0 ? l2 : i.bottomColor };
}, Baseline: (t2, i, n2, s) => {
  var e2, r2, h2, l2, a2, o2;
  const _24 = b(t2(n2, s));
  return { ue: _24.Vt[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor, Pe: (e2 = _24.Pe) !== null && e2 !== void 0 ? e2 : i.topLineColor, Re: (r2 = _24.Re) !== null && r2 !== void 0 ? r2 : i.bottomLineColor, Se: (h2 = _24.Se) !== null && h2 !== void 0 ? h2 : i.topFillColor1, ke: (l2 = _24.ke) !== null && l2 !== void 0 ? l2 : i.topFillColor2, ye: (a2 = _24.ye) !== null && a2 !== void 0 ? a2 : i.bottomFillColor1, Ce: (o2 = _24.Ce) !== null && o2 !== void 0 ? o2 : i.bottomFillColor2 };
}, Line: (t2, i, n2, s) => {
  var e2, r2;
  const h2 = b(t2(n2, s));
  return { ue: (e2 = h2.O) !== null && e2 !== void 0 ? e2 : i.color, _t: (r2 = h2.O) !== null && r2 !== void 0 ? r2 : i.color };
}, Histogram: (t2, i, n2, s) => {
  var e2;
  return { ue: (e2 = b(t2(n2, s)).O) !== null && e2 !== void 0 ? e2 : i.color };
} }, _zi = class _zi {
  constructor(t2) {
    this.Uh = (t3, i) => i !== void 0 ? i.Vt : this.Wr.In().qh(t3), this.Wr = t2, this.Yh = Ii[t2.Xh()];
  }
  Hs(t2, i) {
    return this.Yh(this.Uh, this.Wr.W(), t2, i);
  }
};
__name(_zi, "zi");
let zi = _zi;
var Ei;
(function(t2) {
  t2[t2.NearestLeft = -1] = "NearestLeft", t2[t2.None = 0] = "None", t2[t2.NearestRight = 1] = "NearestRight";
})(Ei || (Ei = {}));
const Li = 30, _Ni = class _Ni {
  constructor() {
    this.Kh = [], this.Zh = /* @__PURE__ */ new Map(), this.Gh = /* @__PURE__ */ new Map();
  }
  Jh() {
    return this.Ks() > 0 ? this.Kh[this.Kh.length - 1] : null;
  }
  Qh() {
    return this.Ks() > 0 ? this.tl(0) : null;
  }
  Bn() {
    return this.Ks() > 0 ? this.tl(this.Kh.length - 1) : null;
  }
  Ks() {
    return this.Kh.length;
  }
  Fi() {
    return this.Ks() === 0;
  }
  Kr(t2) {
    return this.il(t2, 0) !== null;
  }
  qh(t2) {
    return this.nl(t2);
  }
  nl(t2, i = 0) {
    const n2 = this.il(t2, i);
    return n2 === null ? null : Object.assign(Object.assign({}, this.sl(n2)), { se: this.tl(n2) });
  }
  ie() {
    return this.Kh;
  }
  el(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    for (const e2 of n2)
      s = Fi(s, this.rl(t2, i, e2));
    return s;
  }
  it(t2) {
    this.Gh.clear(), this.Zh.clear(), this.Kh = t2;
  }
  tl(t2) {
    return this.Kh[t2].se;
  }
  sl(t2) {
    return this.Kh[t2];
  }
  il(t2, i) {
    const n2 = this.hl(t2);
    if (n2 === null && i !== 0)
      switch (i) {
        case -1:
          return this.ll(t2);
        case 1:
          return this.al(t2);
        default:
          throw new TypeError("Unknown search mode");
      }
    return n2;
  }
  ll(t2) {
    let i = this.ol(t2);
    return i > 0 && (i -= 1), i !== this.Kh.length && this.tl(i) < t2 ? i : null;
  }
  al(t2) {
    const i = this._l(t2);
    return i !== this.Kh.length && t2 < this.tl(i) ? i : null;
  }
  hl(t2) {
    const i = this.ol(t2);
    return i === this.Kh.length || t2 < this.Kh[i].se ? null : i;
  }
  ol(t2) {
    return Bt$1(this.Kh, t2, (t3, i) => t3.se < i);
  }
  _l(t2) {
    return It$1(this.Kh, t2, (t3, i) => t3.se > i);
  }
  ul(t2, i, n2) {
    let s = null;
    for (let e2 = t2; e2 < i; e2++) {
      const t3 = this.Kh[e2].Vt[n2];
      Number.isNaN(t3) || (s === null ? s = { cl: t3, dl: t3 } : (t3 < s.cl && (s.cl = t3), t3 > s.dl && (s.dl = t3)));
    }
    return s;
  }
  rl(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    const e2 = b(this.Qh()), r2 = b(this.Bn()), h2 = Math.max(t2, e2), l2 = Math.min(i, r2), a2 = Math.ceil(h2 / Li) * Li, o2 = Math.max(a2, Math.floor(l2 / Li) * Li);
    {
      const t3 = this.ol(h2), e3 = this._l(Math.min(l2, a2, i));
      s = Fi(s, this.ul(t3, e3, n2));
    }
    let _24 = this.Zh.get(n2);
    _24 === void 0 && (_24 = /* @__PURE__ */ new Map(), this.Zh.set(n2, _24));
    for (let t3 = Math.max(a2 + 1, h2); t3 < o2; t3 += Li) {
      const i2 = Math.floor(t3 / Li);
      let e3 = _24.get(i2);
      if (e3 === void 0) {
        const t4 = this.ol(i2 * Li), s2 = this._l((i2 + 1) * Li - 1);
        e3 = this.ul(t4, s2, n2), _24.set(i2, e3);
      }
      s = Fi(s, e3);
    }
    {
      const t3 = this.ol(o2), i2 = this._l(l2);
      s = Fi(s, this.ul(t3, i2, n2));
    }
    return s;
  }
};
__name(_Ni, "Ni");
let Ni = _Ni;
function Fi(t2, i) {
  return t2 === null ? i : i === null ? t2 : { cl: Math.min(t2.cl, i.cl), dl: Math.max(t2.dl, i.dl) };
}
__name(Fi, "Fi");
const _Wi = class _Wi {
  constructor(t2) {
    this.fl = t2;
  }
  K(t2, i, n2) {
    this.fl.draw(t2);
  }
  G(t2, i, n2) {
    var s, e2;
    (e2 = (s = this.fl).drawBackground) === null || e2 === void 0 || e2.call(s, t2);
  }
};
__name(_Wi, "Wi");
let Wi = _Wi;
const _ji = class _ji {
  constructor(t2) {
    this.Qe = null, this.wn = t2;
  }
  xt() {
    var t2;
    const i = this.wn.renderer();
    if (i === null)
      return null;
    if (((t2 = this.Qe) === null || t2 === void 0 ? void 0 : t2.vl) === i)
      return this.Qe.pl;
    const n2 = new Wi(i);
    return this.Qe = { vl: i, pl: n2 }, n2;
  }
  ml() {
    var t2, i, n2;
    return (n2 = (i = (t2 = this.wn).zOrder) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : "normal";
  }
};
__name(_ji, "ji");
let ji = _ji;
function Hi(t2) {
  var i, n2, s, e2, r2;
  return { Jt: t2.text(), yi: t2.coordinate(), ki: (i = t2.fixedCoordinate) === null || i === void 0 ? void 0 : i.call(t2), O: t2.textColor(), t: t2.backColor(), Tt: (s = (n2 = t2.visible) === null || n2 === void 0 ? void 0 : n2.call(t2)) === null || s === void 0 || s, ai: (r2 = (e2 = t2.tickVisible) === null || e2 === void 0 ? void 0 : e2.call(t2)) === null || r2 === void 0 || r2 };
}
__name(Hi, "Hi");
const _$i = class _$i {
  constructor(t2, i) {
    this.Ht = new ht$1(), this.bl = t2, this.wl = i;
  }
  xt() {
    return this.Ht.it(Object.assign({ $i: this.wl.$i() }, Hi(this.bl))), this.Ht;
  }
};
__name(_$i, "$i");
let $i = _$i;
const _Ui = class _Ui extends st {
  constructor(t2, i) {
    super(), this.bl = t2, this.Li = i;
  }
  Ei(t2, i, n2) {
    const s = Hi(this.bl);
    n2.t = s.t, t2.O = s.O;
    const e2 = 2 / 12 * this.Li.P();
    n2.gi = e2, n2.Mi = e2, n2.yi = s.yi, n2.ki = s.ki, t2.Jt = s.Jt, t2.Tt = s.Tt, t2.ai = s.ai;
  }
};
__name(_Ui, "Ui");
let Ui = _Ui;
const _qi = class _qi {
  constructor(t2, i) {
    this.gl = null, this.Ml = null, this.xl = null, this.Sl = null, this.kl = null, this.yl = t2, this.Wr = i;
  }
  Cl() {
    return this.yl;
  }
  On() {
    var t2, i;
    (i = (t2 = this.yl).updateAllViews) === null || i === void 0 || i.call(t2);
  }
  Pn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).paneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.gl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.gl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.gl = { vl: e2, pl: r2 }, r2;
  }
  tn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).timeAxisViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.Ml) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.Ml.pl;
    const r2 = this.Wr.qt().yt(), h2 = e2.map((t3) => new $i(t3, r2));
    return this.Ml = { vl: e2, pl: h2 }, h2;
  }
  Rn() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).priceAxisViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.xl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.xl.pl;
    const r2 = this.Wr.At(), h2 = e2.map((t3) => new Ui(t3, r2));
    return this.xl = { vl: e2, pl: h2 }, h2;
  }
  Tl() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).priceAxisPaneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.Sl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.Sl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.Sl = { vl: e2, pl: r2 }, r2;
  }
  Pl() {
    var t2, i, n2, s;
    const e2 = (n2 = (i = (t2 = this.yl).timeAxisPaneViews) === null || i === void 0 ? void 0 : i.call(t2)) !== null && n2 !== void 0 ? n2 : [];
    if (((s = this.kl) === null || s === void 0 ? void 0 : s.vl) === e2)
      return this.kl.pl;
    const r2 = e2.map((t3) => new ji(t3));
    return this.kl = { vl: e2, pl: r2 }, r2;
  }
  Rl(t2, i) {
    var n2, s, e2;
    return (e2 = (s = (n2 = this.yl).autoscaleInfo) === null || s === void 0 ? void 0 : s.call(n2, t2, i)) !== null && e2 !== void 0 ? e2 : null;
  }
  br(t2, i) {
    var n2, s, e2;
    return (e2 = (s = (n2 = this.yl).hitTest) === null || s === void 0 ? void 0 : s.call(n2, t2, i)) !== null && e2 !== void 0 ? e2 : null;
  }
};
__name(_qi, "qi");
let qi = _qi;
function Yi(t2, i, n2, s) {
  t2.forEach((t3) => {
    i(t3).forEach((t4) => {
      t4.ml() === n2 && s.push(t4);
    });
  });
}
__name(Yi, "Yi");
function Xi(t2) {
  return t2.Pn();
}
__name(Xi, "Xi");
function Ki(t2) {
  return t2.Tl();
}
__name(Ki, "Ki");
function Zi(t2) {
  return t2.Pl();
}
__name(Zi, "Zi");
const _Gi = class _Gi extends Bi {
  constructor(t2, i, n2, s, e2) {
    super(t2), this.Lt = new Ni(), this.Eh = new Ci(this), this.Dl = [], this.Ol = new ai(this), this.Al = null, this.Vl = null, this.Bl = [], this.Il = [], this.zl = null, this.El = [], this.cn = i, this.Ll = n2;
    const r2 = new Ti(this);
    this.hn = [r2], this.Lh = new ri(r2, this, t2), n2 !== "Area" && n2 !== "Line" && n2 !== "Baseline" || (this.Al = new di(this)), this.Nl(), this.Fl(e2);
  }
  S() {
    this.zl !== null && clearTimeout(this.zl);
  }
  _h(t2) {
    return this.cn.priceLineColor || t2;
  }
  Yr(t2) {
    const i = { Xr: !0 }, n2 = this.At();
    if (this.qt().yt().Fi() || n2.Fi() || this.Lt.Fi())
      return i;
    const s = this.qt().yt().Xs(), e2 = this.Pt();
    if (s === null || e2 === null)
      return i;
    let r2, h2;
    if (t2) {
      const t3 = this.Lt.Jh();
      if (t3 === null)
        return i;
      r2 = t3, h2 = t3.se;
    } else {
      const t3 = this.Lt.nl(s.di(), -1);
      if (t3 === null || (r2 = this.Lt.qh(t3.se), r2 === null))
        return i;
      h2 = t3.se;
    }
    const l2 = r2.Vt[3], a2 = this.$s().Hs(h2, { Vt: r2 }), o2 = n2.Ot(l2, e2.Vt);
    return { Xr: !1, ct: l2, Jt: n2.Wi(l2, e2.Vt), mh: n2.Wl(l2), bh: n2.jl(l2, e2.Vt), O: a2.ue, yi: o2, se: h2 };
  }
  $s() {
    return this.Vl !== null || (this.Vl = new zi(this)), this.Vl;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    const i = t2.priceScaleId;
    i !== void 0 && i !== this.cn.priceScaleId && this.qt().Hl(this, i), D$1(this.cn, t2), t2.priceFormat !== void 0 && (this.Nl(), this.qt().$l()), this.qt().Ul(this), this.qt().ql(), this.wn.gt("options");
  }
  it(t2, i) {
    this.Lt.it(t2), this.Yl(), this.wn.gt("data"), this.dn.gt("data"), this.Al !== null && (i && i.Xl ? this.Al.Hr() : t2.length === 0 && this.Al.jr());
    const n2 = this.qt().cr(this);
    this.qt().Kl(n2), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Zl(t2) {
    this.Bl = t2, this.Yl();
    const i = this.qt().cr(this);
    this.dn.gt("data"), this.qt().Kl(i), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Gl() {
    return this.Bl;
  }
  ah() {
    return this.Il;
  }
  Jl(t2) {
    const i = new Vi(this, t2);
    return this.Dl.push(i), this.qt().Ul(this), i;
  }
  Ql(t2) {
    const i = this.Dl.indexOf(t2);
    i !== -1 && this.Dl.splice(i, 1), this.qt().Ul(this);
  }
  Xh() {
    return this.Ll;
  }
  Pt() {
    const t2 = this.ta();
    return t2 === null ? null : { Vt: t2.Vt[3], ia: t2.ut };
  }
  ta() {
    const t2 = this.qt().yt().Xs();
    if (t2 === null)
      return null;
    const i = t2.Os();
    return this.Lt.nl(i, 1);
  }
  In() {
    return this.Lt;
  }
  oh(t2) {
    const i = this.Lt.qh(t2);
    return i === null ? null : this.Ll === "Bar" || this.Ll === "Candlestick" || this.Ll === "Custom" ? { we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3] } : i.Vt[3];
  }
  na(t2) {
    const i = [];
    Yi(this.El, Xi, "top", i);
    const n2 = this.Al;
    return n2 !== null && n2.Tt() && (this.zl === null && n2.Ur() && (this.zl = setTimeout(() => {
      this.zl = null, this.qt().sa();
    }, 0)), n2.$r(), i.push(n2)), i;
  }
  Pn() {
    const t2 = [];
    this.ea() || t2.push(this.Ol), t2.push(this.wn, this.Eh, this.dn);
    const i = this.Dl.map((t3) => t3.Wh());
    return t2.push(...i), Yi(this.El, Xi, "normal", t2), t2;
  }
  ra() {
    return this.ha(Xi, "bottom");
  }
  la(t2) {
    return this.ha(Ki, t2);
  }
  aa(t2) {
    return this.ha(Zi, t2);
  }
  oa(t2, i) {
    return this.El.map((n2) => n2.br(t2, i)).filter((t3) => t3 !== null);
  }
  Qi(t2) {
    return [this.Lh, ...this.Dl.map((t3) => t3.jh())];
  }
  Rn(t2, i) {
    if (i !== this.Xi && !this.ea())
      return [];
    const n2 = [...this.hn];
    for (const t3 of this.Dl)
      n2.push(t3.Hh());
    return this.El.forEach((t3) => {
      n2.push(...t3.Rn());
    }), n2;
  }
  tn() {
    const t2 = [];
    return this.El.forEach((i) => {
      t2.push(...i.tn());
    }), t2;
  }
  Rl(t2, i) {
    if (this.cn.autoscaleInfoProvider !== void 0) {
      const n2 = this.cn.autoscaleInfoProvider(() => {
        const n3 = this._a(t2, i);
        return n3 === null ? null : n3.Ph();
      });
      return Di.Rh(n2);
    }
    return this._a(t2, i);
  }
  ua() {
    return this.cn.priceFormat.minMove;
  }
  ca() {
    return this.da;
  }
  On() {
    var t2;
    this.wn.gt(), this.dn.gt();
    for (const t3 of this.hn)
      t3.gt();
    for (const t3 of this.Dl)
      t3.gt();
    this.Eh.gt(), this.Ol.gt(), (t2 = this.Al) === null || t2 === void 0 || t2.gt(), this.El.forEach((t3) => t3.On());
  }
  At() {
    return b(super.At());
  }
  Ct(t2) {
    if (!((this.Ll === "Line" || this.Ll === "Area" || this.Ll === "Baseline") && this.cn.crosshairMarkerVisible))
      return null;
    const i = this.Lt.qh(t2);
    return i === null ? null : { ct: i.Vt[3], ot: this.fa(), Bt: this.va(), Dt: this.pa(), Rt: this.ma(t2) };
  }
  uh() {
    return this.cn.title;
  }
  Tt() {
    return this.cn.visible;
  }
  ba(t2) {
    this.El.push(new qi(t2, this));
  }
  wa(t2) {
    this.El = this.El.filter((i) => i.Cl() !== t2);
  }
  ga() {
    if (this.wn instanceof Gt$1)
      return (t2) => this.wn.Fe(t2);
  }
  Ma() {
    if (this.wn instanceof Gt$1)
      return (t2) => this.wn.We(t2);
  }
  ea() {
    return !ut$1(this.At().xa());
  }
  _a(t2, i) {
    if (!A$1(t2) || !A$1(i) || this.Lt.Fi())
      return null;
    const n2 = this.Ll === "Line" || this.Ll === "Area" || this.Ll === "Baseline" || this.Ll === "Histogram" ? [3] : [2, 1], s = this.Lt.el(t2, i, n2);
    let e2 = s !== null ? new Ri(s.cl, s.dl) : null;
    if (this.Xh() === "Histogram") {
      const t3 = this.cn.base, i2 = new Ri(t3, t3);
      e2 = e2 !== null ? e2.ts(i2) : i2;
    }
    let r2 = this.dn.lh();
    return this.El.forEach((n3) => {
      const s2 = n3.Rl(t2, i);
      if (s2 != null && s2.priceRange) {
        const t3 = new Ri(s2.priceRange.minValue, s2.priceRange.maxValue);
        e2 = e2 !== null ? e2.ts(t3) : t3;
      }
      var h2, l2, a2, o2;
      s2 != null && s2.margins && (h2 = r2, l2 = s2.margins, r2 = { above: Math.max((a2 = h2 == null ? void 0 : h2.above) !== null && a2 !== void 0 ? a2 : 0, l2.above), below: Math.max((o2 = h2 == null ? void 0 : h2.below) !== null && o2 !== void 0 ? o2 : 0, l2.below) });
    }), new Di(e2, r2);
  }
  fa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerRadius;
    }
    return 0;
  }
  va() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t2 = this.cn.crosshairMarkerBorderColor;
        if (t2.length !== 0)
          return t2;
      }
    }
    return null;
  }
  pa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerBorderWidth;
    }
    return 0;
  }
  ma(t2) {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t3 = this.cn.crosshairMarkerBackgroundColor;
        if (t3.length !== 0)
          return t3;
      }
    }
    return this.$s().Hs(t2).ue;
  }
  Nl() {
    switch (this.cn.priceFormat.type) {
      case "custom":
        this.da = { format: this.cn.priceFormat.formatter };
        break;
      case "volume":
        this.da = new mt$1(this.cn.priceFormat.precision);
        break;
      case "percent":
        this.da = new pt$1(this.cn.priceFormat.precision);
        break;
      default: {
        const t2 = Math.pow(10, this.cn.priceFormat.precision);
        this.da = new vt$1(t2, this.cn.priceFormat.minMove * t2);
      }
    }
    this.Xi !== null && this.Xi.Sa();
  }
  Yl() {
    const t2 = this.qt().yt();
    if (!t2.ka() || this.Lt.Fi())
      return void (this.Il = []);
    const i = b(this.Lt.Qh());
    this.Il = this.Bl.map((n2, s) => {
      const e2 = b(t2.ya(n2.time, !0)), r2 = e2 < i ? 1 : -1;
      return { time: b(this.Lt.nl(e2, r2)).se, position: n2.position, shape: n2.shape, color: n2.color, id: n2.id, Jr: s, text: n2.text, size: n2.size, originalTime: n2.originalTime };
    });
  }
  Fl(t2) {
    switch (this.dn = new yi(this, this.qt()), this.Ll) {
      case "Bar":
        this.wn = new $t$1(this, this.qt());
        break;
      case "Candlestick":
        this.wn = new Kt$1(this, this.qt());
        break;
      case "Line":
        this.wn = new ii(this, this.qt());
        break;
      case "Custom":
        this.wn = new Gt$1(this, this.qt(), m$1(t2));
        break;
      case "Area":
        this.wn = new Wt$1(this, this.qt());
        break;
      case "Baseline":
        this.wn = new Yt$1(this, this.qt());
        break;
      case "Histogram":
        this.wn = new ti(this, this.qt());
        break;
      default:
        throw Error("Unknown chart style assigned: " + this.Ll);
    }
  }
  ha(t2, i) {
    const n2 = [];
    return Yi(this.El, t2, i, n2), n2;
  }
};
__name(_Gi, "Gi");
let Gi = _Gi;
const _Ji = class _Ji {
  constructor(t2) {
    this.cn = t2;
  }
  Ca(t2, i, n2) {
    let s = t2;
    if (this.cn.mode === 0)
      return s;
    const e2 = n2.vn(), r2 = e2.Pt();
    if (r2 === null)
      return s;
    const h2 = e2.Ot(t2, r2), l2 = n2.Ta().filter((t3) => t3 instanceof Gi).reduce((t3, s2) => {
      if (n2.dr(s2) || !s2.Tt())
        return t3;
      const e3 = s2.At(), r3 = s2.In();
      if (e3.Fi() || !r3.Kr(i))
        return t3;
      const h3 = r3.qh(i);
      if (h3 === null)
        return t3;
      const l3 = w$1(s2.Pt());
      return t3.concat([e3.Ot(h3.Vt[3], l3.Vt)]);
    }, []);
    if (l2.length === 0)
      return s;
    l2.sort((t3, i2) => Math.abs(t3 - h2) - Math.abs(i2 - h2));
    const a2 = l2[0];
    return s = e2.pn(a2, r2), s;
  }
};
__name(_Ji, "Ji");
let Ji = _Ji;
const _Qi = class _Qi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (this.Lt === null)
      return;
    const e2 = Math.max(1, Math.floor(n2));
    t2.lineWidth = e2, function(t3, i2) {
      t3.save(), t3.lineWidth % 2 && t3.translate(0.5, 0.5), i2(), t3.restore();
    }(t2, () => {
      const r2 = b(this.Lt);
      if (r2.Pa) {
        t2.strokeStyle = r2.Ra, f(t2, r2.Da), t2.beginPath();
        for (const s2 of r2.Oa) {
          const r3 = Math.round(s2.Aa * n2);
          t2.moveTo(r3, -e2), t2.lineTo(r3, i.height + e2);
        }
        t2.stroke();
      }
      if (r2.Va) {
        t2.strokeStyle = r2.Ba, f(t2, r2.Ia), t2.beginPath();
        for (const n3 of r2.za) {
          const r3 = Math.round(n3.Aa * s);
          t2.moveTo(-e2, r3), t2.lineTo(i.width + e2, r3);
        }
        t2.stroke();
      }
    });
  }
};
__name(_Qi, "Qi");
let Qi = _Qi;
var _a30;
let tn$1 = (_a30 = class {
  constructor(t2) {
    this.Ht = new Qi(), this.bt = !0, this.nn = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    if (this.bt) {
      const t2 = this.nn.qt().W().grid, i = { Va: t2.horzLines.visible, Pa: t2.vertLines.visible, Ba: t2.horzLines.color, Ra: t2.vertLines.color, Ia: t2.horzLines.style, Da: t2.vertLines.style, za: this.nn.vn().Ea(), Oa: (this.nn.qt().yt().Ea() || []).map((t3) => ({ Aa: t3.coord })) };
      this.Ht.it(i), this.bt = !1;
    }
    return this.Ht;
  }
}, __name(_a30, "tn"), _a30);
var _a31;
let nn$1 = (_a31 = class {
  constructor(t2) {
    this.wn = new tn$1(t2);
  }
  Wh() {
    return this.wn;
  }
}, __name(_a31, "nn"), _a31);
const sn$1 = { La: 4, Na: 1e-4 };
function en$1(t2, i) {
  const n2 = 100 * (t2 - i) / i;
  return i < 0 ? -n2 : n2;
}
__name(en$1, "en$1");
function rn$1(t2, i) {
  const n2 = en$1(t2.Sh(), i), s = en$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(rn$1, "rn$1");
function hn$1(t2, i) {
  const n2 = 100 * (t2 - i) / i + 100;
  return i < 0 ? -n2 : n2;
}
__name(hn$1, "hn$1");
function ln$1(t2, i) {
  const n2 = hn$1(t2.Sh(), i), s = hn$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(ln$1, "ln$1");
function an$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.log10(n2 + i.Na) + i.La;
  return t2 < 0 ? -s : s;
}
__name(an$1, "an$1");
function on$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.pow(10, n2 - i.La) - i.Na;
  return t2 < 0 ? -s : s;
}
__name(on$1, "on$1");
function _n(t2, i) {
  if (t2 === null)
    return null;
  const n2 = an$1(t2.Sh(), i), s = an$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(_n, "_n");
function un$1(t2, i) {
  if (t2 === null)
    return null;
  const n2 = on$1(t2.Sh(), i), s = on$1(t2.kh(), i);
  return new Ri(n2, s);
}
__name(un$1, "un$1");
function cn$1(t2) {
  if (t2 === null)
    return sn$1;
  const i = Math.abs(t2.kh() - t2.Sh());
  if (i >= 1 || i < 1e-15)
    return sn$1;
  const n2 = Math.ceil(Math.abs(Math.log10(i))), s = sn$1.La + n2;
  return { La: s, Na: 1 / Math.pow(10, s) };
}
__name(cn$1, "cn$1");
var _a32;
let dn$1 = (_a32 = class {
  constructor(t2, i) {
    if (this.Fa = t2, this.Wa = i, function(t3) {
      if (t3 < 0)
        return !1;
      for (let i2 = t3; i2 > 1; i2 /= 10)
        if (i2 % 10 != 0)
          return !1;
      return !0;
    }(this.Fa))
      this.ja = [2, 2.5, 2];
    else {
      this.ja = [];
      for (let t3 = this.Fa; t3 !== 1; ) {
        if (t3 % 2 == 0)
          this.ja.push(2), t3 /= 2;
        else {
          if (t3 % 5 != 0)
            throw new Error("unexpected base");
          this.ja.push(2, 2.5), t3 /= 5;
        }
        if (this.ja.length > 100)
          throw new Error("something wrong with base");
      }
    }
  }
  Ha(t2, i, n2) {
    const s = this.Fa === 0 ? 0 : 1 / this.Fa;
    let e2 = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t2 - i)))), r2 = 0, h2 = this.Wa[0];
    for (; ; ) {
      const t3 = Ct$1(e2, s, 1e-14) && e2 > s + 1e-14, i2 = Ct$1(e2, n2 * h2, 1e-14), l3 = Ct$1(e2, 1, 1e-14);
      if (!(t3 && i2 && l3))
        break;
      e2 /= h2, h2 = this.Wa[++r2 % this.Wa.length];
    }
    if (e2 <= s + 1e-14 && (e2 = s), e2 = Math.max(1, e2), this.ja.length > 0 && (l2 = e2, a2 = 1, o2 = 1e-14, Math.abs(l2 - a2) < o2))
      for (r2 = 0, h2 = this.ja[0]; Ct$1(e2, n2 * h2, 1e-14) && e2 > s + 1e-14; )
        e2 /= h2, h2 = this.ja[++r2 % this.ja.length];
    var l2, a2, o2;
    return e2;
  }
}, __name(_a32, "dn"), _a32);
var _a33;
let fn$1 = (_a33 = class {
  constructor(t2, i, n2, s) {
    this.$a = [], this.Li = t2, this.Fa = i, this.Ua = n2, this.qa = s;
  }
  Ha(t2, i) {
    if (t2 < i)
      throw new Error("high < low");
    const n2 = this.Li.zt(), s = (t2 - i) * this.Ya() / n2, e2 = new dn$1(this.Fa, [2, 2.5, 2]), r2 = new dn$1(this.Fa, [2, 2, 2.5]), h2 = new dn$1(this.Fa, [2.5, 2, 2]), l2 = [];
    return l2.push(e2.Ha(t2, i, s), r2.Ha(t2, i, s), h2.Ha(t2, i, s)), function(t3) {
      if (t3.length < 1)
        throw Error("array is empty");
      let i2 = t3[0];
      for (let n3 = 1; n3 < t3.length; ++n3)
        t3[n3] < i2 && (i2 = t3[n3]);
      return i2;
    }(l2);
  }
  Xa() {
    const t2 = this.Li, i = t2.Pt();
    if (i === null)
      return void (this.$a = []);
    const n2 = t2.zt(), s = this.Ua(n2 - 1, i), e2 = this.Ua(0, i), r2 = this.Li.W().entireTextOnly ? this.Ka() / 2 : 0, h2 = r2, l2 = n2 - 1 - r2, a2 = Math.max(s, e2), o2 = Math.min(s, e2);
    if (a2 === o2)
      return void (this.$a = []);
    let _24 = this.Ha(a2, o2), u2 = a2 % _24;
    u2 += u2 < 0 ? _24 : 0;
    const c2 = a2 >= o2 ? 1 : -1;
    let d2 = null, f2 = 0;
    for (let n3 = a2 - u2; n3 > o2; n3 -= _24) {
      const s2 = this.qa(n3, i, !0);
      d2 !== null && Math.abs(s2 - d2) < this.Ya() || s2 < h2 || s2 > l2 || (f2 < this.$a.length ? (this.$a[f2].Aa = s2, this.$a[f2].Za = t2.Ga(n3)) : this.$a.push({ Aa: s2, Za: t2.Ga(n3) }), f2++, d2 = s2, t2.Ja() && (_24 = this.Ha(n3 * c2, o2)));
    }
    this.$a.length = f2;
  }
  Ea() {
    return this.$a;
  }
  Ka() {
    return this.Li.P();
  }
  Ya() {
    return Math.ceil(2.5 * this.Ka());
  }
}, __name(_a33, "fn"), _a33);
function vn(t2) {
  return t2.slice().sort((t3, i) => b(t3.Zi()) - b(i.Zi()));
}
__name(vn, "vn");
var pn$1;
(function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Logarithmic = 1] = "Logarithmic", t2[t2.Percentage = 2] = "Percentage", t2[t2.IndexedTo100 = 3] = "IndexedTo100";
})(pn$1 || (pn$1 = {}));
const mn$1 = new pt$1(), bn = new vt$1(100, 1), _wn = class _wn {
  constructor(t2, i, n2, s) {
    this.Qa = 0, this.io = null, this.Dh = null, this.no = null, this.so = { eo: !1, ro: null }, this.ho = 0, this.lo = 0, this.ao = new R(), this.oo = new R(), this._o = [], this.uo = null, this.co = null, this.do = null, this.fo = null, this.da = bn, this.vo = cn$1(null), this.po = t2, this.cn = i, this.mo = n2, this.bo = s, this.wo = new fn$1(this, 100, this.Mo.bind(this), this.xo.bind(this));
  }
  xa() {
    return this.po;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    if (D$1(this.cn, t2), this.Sa(), t2.mode !== void 0 && this.So({ yr: t2.mode }), t2.scaleMargins !== void 0) {
      const i = m$1(t2.scaleMargins.top), n2 = m$1(t2.scaleMargins.bottom);
      if (i < 0 || i > 1)
        throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i}`);
      if (n2 < 0 || n2 > 1 || i + n2 > 1)
        throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n2}`);
      if (i + n2 > 1)
        throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i + n2}`);
      this.ko(), this.co = null;
    }
  }
  yo() {
    return this.cn.autoScale;
  }
  Ja() {
    return this.cn.mode === 1;
  }
  ph() {
    return this.cn.mode === 2;
  }
  Co() {
    return this.cn.mode === 3;
  }
  yr() {
    return { Wn: this.cn.autoScale, To: this.cn.invertScale, yr: this.cn.mode };
  }
  So(t2) {
    const i = this.yr();
    let n2 = null;
    t2.Wn !== void 0 && (this.cn.autoScale = t2.Wn), t2.yr !== void 0 && (this.cn.mode = t2.yr, t2.yr !== 2 && t2.yr !== 3 || (this.cn.autoScale = !0), this.so.eo = !1), i.yr === 1 && t2.yr !== i.yr && (function(t3, i2) {
      if (t3 === null)
        return !1;
      const n3 = on$1(t3.Sh(), i2), s2 = on$1(t3.kh(), i2);
      return isFinite(n3) && isFinite(s2);
    }(this.Dh, this.vo) ? (n2 = un$1(this.Dh, this.vo), n2 !== null && this.Po(n2)) : this.cn.autoScale = !0), t2.yr === 1 && t2.yr !== i.yr && (n2 = _n(this.Dh, this.vo), n2 !== null && this.Po(n2));
    const s = i.yr !== this.cn.mode;
    s && (i.yr === 2 || this.ph()) && this.Sa(), s && (i.yr === 3 || this.Co()) && this.Sa(), t2.To !== void 0 && i.To !== t2.To && (this.cn.invertScale = t2.To, this.Ro()), this.oo.m(i, this.yr());
  }
  Do() {
    return this.oo;
  }
  P() {
    return this.mo.fontSize;
  }
  zt() {
    return this.Qa;
  }
  Oo(t2) {
    this.Qa !== t2 && (this.Qa = t2, this.ko(), this.co = null);
  }
  Ao() {
    if (this.io)
      return this.io;
    const t2 = this.zt() - this.Vo() - this.Bo();
    return this.io = t2, t2;
  }
  Ah() {
    return this.Io(), this.Dh;
  }
  Po(t2, i) {
    const n2 = this.Dh;
    (i || n2 === null && t2 !== null || n2 !== null && !n2.Mh(t2)) && (this.co = null, this.Dh = t2);
  }
  Fi() {
    return this.Io(), this.Qa === 0 || !this.Dh || this.Dh.Fi();
  }
  zo(t2) {
    return this.To() ? t2 : this.zt() - 1 - t2;
  }
  Ot(t2, i) {
    return this.ph() ? t2 = en$1(t2, i) : this.Co() && (t2 = hn$1(t2, i)), this.xo(t2, i);
  }
  Qs(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e2 = b(this.Ah()), r2 = e2.Sh(), h2 = e2.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = n2 === void 0 ? 0 : n2.from, u2 = n2 === void 0 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e3 = t2[n3], h3 = e3.ct;
      if (isNaN(h3))
        continue;
      let l3 = h3;
      c2 !== null && (l3 = c2(e3.ct, i));
      const _25 = s + o2 * (l3 - r2), u3 = a2 ? _25 : this.Qa - 1 - _25;
      e3.rt = u3;
    }
  }
  me(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e2 = b(this.Ah()), r2 = e2.Sh(), h2 = e2.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = n2 === void 0 ? 0 : n2.from, u2 = n2 === void 0 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e3 = t2[n3];
      let h3 = e3.we, l3 = e3.ge, _25 = e3.Me, u3 = e3.xe;
      c2 !== null && (h3 = c2(e3.we, i), l3 = c2(e3.ge, i), _25 = c2(e3.Me, i), u3 = c2(e3.xe, i));
      let d2 = s + o2 * (h3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2;
      e3.ve = f2, d2 = s + o2 * (l3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.ce = f2, d2 = s + o2 * (_25 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.de = f2, d2 = s + o2 * (u3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e3.pe = f2;
    }
  }
  pn(t2, i) {
    const n2 = this.Mo(t2, i);
    return this.Lo(n2, i);
  }
  Lo(t2, i) {
    let n2 = t2;
    return this.ph() ? n2 = function(t3, i2) {
      return i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i) : this.Co() && (n2 = function(t3, i2) {
      return t3 -= 100, i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i)), n2;
  }
  Ta() {
    return this._o;
  }
  No() {
    if (this.uo)
      return this.uo;
    let t2 = [];
    for (let i = 0; i < this._o.length; i++) {
      const n2 = this._o[i];
      n2.Zi() === null && n2.Gi(i + 1), t2.push(n2);
    }
    return t2 = vn(t2), this.uo = t2, this.uo;
  }
  Fo(t2) {
    this._o.indexOf(t2) === -1 && (this._o.push(t2), this.Sa(), this.Wo());
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    if (i === -1)
      throw new Error("source is not attached to scale");
    this._o.splice(i, 1), this._o.length === 0 && (this.So({ Wn: !0 }), this.Po(null)), this.Sa(), this.Wo();
  }
  Pt() {
    let t2 = null;
    for (const i of this._o) {
      const n2 = i.Pt();
      n2 !== null && (t2 === null || n2.ia < t2.ia) && (t2 = n2);
    }
    return t2 === null ? null : t2.Vt;
  }
  To() {
    return this.cn.invertScale;
  }
  Ea() {
    const t2 = this.Pt() === null;
    if (this.co !== null && (t2 || this.co.Ho === t2))
      return this.co.Ea;
    this.wo.Xa();
    const i = this.wo.Ea();
    return this.co = { Ea: i, Ho: t2 }, this.ao.m(), i;
  }
  $o() {
    return this.ao;
  }
  Uo(t2) {
    this.ph() || this.Co() || this.do === null && this.no === null && (this.Fi() || (this.do = this.Qa - t2, this.no = b(this.Ah()).xh()));
  }
  qo(t2) {
    if (this.ph() || this.Co() || this.do === null)
      return;
    this.So({ Wn: !1 }), (t2 = this.Qa - t2) < 0 && (t2 = 0);
    let i = (this.do + 0.2 * (this.Qa - 1)) / (t2 + 0.2 * (this.Qa - 1));
    const n2 = b(this.no).xh();
    i = Math.max(i, 0.1), n2.Ch(i), this.Po(n2);
  }
  Yo() {
    this.ph() || this.Co() || (this.do = null, this.no = null);
  }
  Xo(t2) {
    this.yo() || this.fo === null && this.no === null && (this.Fi() || (this.fo = t2, this.no = b(this.Ah()).xh()));
  }
  Ko(t2) {
    if (this.yo() || this.fo === null)
      return;
    const i = b(this.Ah()).yh() / (this.Ao() - 1);
    let n2 = t2 - this.fo;
    this.To() && (n2 *= -1);
    const s = n2 * i, e2 = b(this.no).xh();
    e2.Th(s), this.Po(e2, !0), this.co = null;
  }
  Zo() {
    this.yo() || this.fo !== null && (this.fo = null, this.no = null);
  }
  ca() {
    return this.da || this.Sa(), this.da;
  }
  Wi(t2, i) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(en$1(t2, i));
      case 3:
        return this.ca().format(hn$1(t2, i));
      default:
        return this.zh(t2);
    }
  }
  Ga(t2) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(t2);
      case 3:
        return this.ca().format(t2);
      default:
        return this.zh(t2);
    }
  }
  Wl(t2) {
    return this.zh(t2, b(this.Jo()).ca());
  }
  jl(t2, i) {
    return t2 = en$1(t2, i), this.Go(t2, mn$1);
  }
  Qo() {
    return this._o;
  }
  t_(t2) {
    this.so = { ro: t2, eo: !1 };
  }
  On() {
    this._o.forEach((t2) => t2.On());
  }
  Sa() {
    this.co = null;
    const t2 = this.Jo();
    let i = 100;
    t2 !== null && (i = Math.round(1 / t2.ua())), this.da = bn, this.ph() ? (this.da = mn$1, i = 100) : this.Co() ? (this.da = new vt$1(100, 1), i = 100) : t2 !== null && (this.da = t2.ca()), this.wo = new fn$1(this, i, this.Mo.bind(this), this.xo.bind(this)), this.wo.Xa();
  }
  Wo() {
    this.uo = null;
  }
  Jo() {
    return this._o[0] || null;
  }
  Vo() {
    return this.To() ? this.cn.scaleMargins.bottom * this.zt() + this.lo : this.cn.scaleMargins.top * this.zt() + this.ho;
  }
  Bo() {
    return this.To() ? this.cn.scaleMargins.top * this.zt() + this.ho : this.cn.scaleMargins.bottom * this.zt() + this.lo;
  }
  Io() {
    this.so.eo || (this.so.eo = !0, this.i_());
  }
  ko() {
    this.io = null;
  }
  xo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    t2 = this.Ja() && t2 ? an$1(t2, this.vo) : t2;
    const n2 = b(this.Ah()), s = this.Bo() + (this.Ao() - 1) * (t2 - n2.Sh()) / n2.yh();
    return this.zo(s);
  }
  Mo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    const n2 = this.zo(t2), s = b(this.Ah()), e2 = s.Sh() + s.yh() * ((n2 - this.Bo()) / (this.Ao() - 1));
    return this.Ja() ? on$1(e2, this.vo) : e2;
  }
  Ro() {
    this.co = null, this.wo.Xa();
  }
  i_() {
    const t2 = this.so.ro;
    if (t2 === null)
      return;
    let i = null;
    const n2 = this.Qo();
    let s = 0, e2 = 0;
    for (const r3 of n2) {
      if (!r3.Tt())
        continue;
      const n3 = r3.Pt();
      if (n3 === null)
        continue;
      const h3 = r3.Rl(t2.Os(), t2.di());
      let l2 = h3 && h3.Ah();
      if (l2 !== null) {
        switch (this.cn.mode) {
          case 1:
            l2 = _n(l2, this.vo);
            break;
          case 2:
            l2 = rn$1(l2, n3.Vt);
            break;
          case 3:
            l2 = ln$1(l2, n3.Vt);
        }
        if (i = i === null ? l2 : i.ts(b(l2)), h3 !== null) {
          const t3 = h3.Vh();
          t3 !== null && (s = Math.max(s, t3.above), e2 = Math.max(s, t3.below));
        }
      }
    }
    if (s === this.ho && e2 === this.lo || (this.ho = s, this.lo = e2, this.co = null, this.ko()), i !== null) {
      if (i.Sh() === i.kh()) {
        const t3 = this.Jo(), n3 = 5 * (t3 === null || this.ph() || this.Co() ? 1 : t3.ua());
        this.Ja() && (i = un$1(i, this.vo)), i = new Ri(i.Sh() - n3, i.kh() + n3), this.Ja() && (i = _n(i, this.vo));
      }
      if (this.Ja()) {
        const t3 = un$1(i, this.vo), n3 = cn$1(t3);
        if (r2 = n3, h2 = this.vo, r2.La !== h2.La || r2.Na !== h2.Na) {
          const s2 = this.no !== null ? un$1(this.no, this.vo) : null;
          this.vo = n3, i = _n(t3, n3), s2 !== null && (this.no = _n(s2, n3));
        }
      }
      this.Po(i);
    } else
      this.Dh === null && (this.Po(new Ri(-0.5, 0.5)), this.vo = cn$1(null));
    var r2, h2;
    this.so.eo = !0;
  }
  Eo() {
    return this.ph() ? en$1 : this.Co() ? hn$1 : this.Ja() ? (t2) => an$1(t2, this.vo) : null;
  }
  n_(t2, i, n2) {
    return i === void 0 ? (n2 === void 0 && (n2 = this.ca()), n2.format(t2)) : i(t2);
  }
  zh(t2, i) {
    return this.n_(t2, this.bo.priceFormatter, i);
  }
  Go(t2, i) {
    return this.n_(t2, this.bo.percentageFormatter, i);
  }
};
__name(_wn, "wn");
let wn = _wn;
var _a34;
let gn$1 = (_a34 = class {
  constructor(t2, i) {
    this._o = [], this.s_ = /* @__PURE__ */ new Map(), this.Qa = 0, this.e_ = 0, this.r_ = 1e3, this.uo = null, this.h_ = new R(), this.wl = t2, this.Ui = i, this.l_ = new nn$1(this);
    const n2 = i.W();
    this.a_ = this.o_("left", n2.leftPriceScale), this.__ = this.o_("right", n2.rightPriceScale), this.a_.Do().l(this.u_.bind(this, this.a_), this), this.__.Do().l(this.u_.bind(this, this.__), this), this.c_(n2);
  }
  c_(t2) {
    if (t2.leftPriceScale && this.a_.Nh(t2.leftPriceScale), t2.rightPriceScale && this.__.Nh(t2.rightPriceScale), t2.localization && (this.a_.Sa(), this.__.Sa()), t2.overlayPriceScales) {
      const i = Array.from(this.s_.values());
      for (const n2 of i) {
        const i2 = b(n2[0].At());
        i2.Nh(t2.overlayPriceScales), t2.localization && i2.Sa();
      }
    }
  }
  d_(t2) {
    switch (t2) {
      case "left":
        return this.a_;
      case "right":
        return this.__;
    }
    return this.s_.has(t2) ? m$1(this.s_.get(t2))[0].At() : null;
  }
  S() {
    this.qt().f_().p(this), this.a_.Do().p(this), this.__.Do().p(this), this._o.forEach((t2) => {
      t2.S && t2.S();
    }), this.h_.m();
  }
  v_() {
    return this.r_;
  }
  p_(t2) {
    this.r_ = t2;
  }
  qt() {
    return this.Ui;
  }
  $i() {
    return this.e_;
  }
  zt() {
    return this.Qa;
  }
  m_(t2) {
    this.e_ = t2, this.b_();
  }
  Oo(t2) {
    this.Qa = t2, this.a_.Oo(t2), this.__.Oo(t2), this._o.forEach((i) => {
      if (this.dr(i)) {
        const n2 = i.At();
        n2 !== null && n2.Oo(t2);
      }
    }), this.b_();
  }
  Ta() {
    return this._o;
  }
  dr(t2) {
    const i = t2.At();
    return i === null || this.a_ !== i && this.__ !== i;
  }
  Fo(t2, i, n2) {
    const s = n2 !== void 0 ? n2 : this.g_().w_ + 1;
    this.M_(t2, i, s);
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    p$1(i !== -1, "removeDataSource: invalid data source"), this._o.splice(i, 1);
    const n2 = b(t2.At()).xa();
    if (this.s_.has(n2)) {
      const i2 = m$1(this.s_.get(n2)), s2 = i2.indexOf(t2);
      s2 !== -1 && (i2.splice(s2, 1), i2.length === 0 && this.s_.delete(n2));
    }
    const s = t2.At();
    s && s.Ta().indexOf(t2) >= 0 && s.jo(t2), s !== null && (s.Wo(), this.x_(s)), this.uo = null;
  }
  pr(t2) {
    return t2 === this.a_ ? "left" : t2 === this.__ ? "right" : "overlay";
  }
  S_() {
    return this.a_;
  }
  k_() {
    return this.__;
  }
  y_(t2, i) {
    t2.Uo(i);
  }
  C_(t2, i) {
    t2.qo(i), this.b_();
  }
  T_(t2) {
    t2.Yo();
  }
  P_(t2, i) {
    t2.Xo(i);
  }
  R_(t2, i) {
    t2.Ko(i), this.b_();
  }
  D_(t2) {
    t2.Zo();
  }
  b_() {
    this._o.forEach((t2) => {
      t2.On();
    });
  }
  vn() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible && this.__.Ta().length !== 0 ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && this.a_.Ta().length !== 0 ? t2 = this.a_ : this._o.length !== 0 && (t2 = this._o[0].At()), t2 === null && (t2 = this.__), t2;
  }
  vr() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && (t2 = this.a_), t2;
  }
  x_(t2) {
    t2 !== null && t2.yo() && this.O_(t2);
  }
  A_(t2) {
    const i = this.wl.Xs();
    t2.So({ Wn: !0 }), i !== null && t2.t_(i), this.b_();
  }
  V_() {
    this.O_(this.a_), this.O_(this.__);
  }
  B_() {
    this.x_(this.a_), this.x_(this.__), this._o.forEach((t2) => {
      this.dr(t2) && this.x_(t2.At());
    }), this.b_(), this.Ui.Fh();
  }
  No() {
    return this.uo === null && (this.uo = vn(this._o)), this.uo;
  }
  I_() {
    return this.h_;
  }
  z_() {
    return this.l_;
  }
  O_(t2) {
    const i = t2.Qo();
    if (i && i.length > 0 && !this.wl.Fi()) {
      const i2 = this.wl.Xs();
      i2 !== null && t2.t_(i2);
    }
    t2.On();
  }
  g_() {
    const t2 = this.No();
    if (t2.length === 0)
      return { E_: 0, w_: 0 };
    let i = 0, n2 = 0;
    for (let s = 0; s < t2.length; s++) {
      const e2 = t2[s].Zi();
      e2 !== null && (e2 < i && (i = e2), e2 > n2 && (n2 = e2));
    }
    return { E_: i, w_: n2 };
  }
  M_(t2, i, n2) {
    let s = this.d_(i);
    if (s === null && (s = this.o_(i, this.Ui.W().overlayPriceScales)), this._o.push(t2), !ut$1(i)) {
      const n3 = this.s_.get(i) || [];
      n3.push(t2), this.s_.set(i, n3);
    }
    s.Fo(t2), t2.Ji(s), t2.Gi(n2), this.x_(s), this.uo = null;
  }
  u_(t2, i, n2) {
    i.yr !== n2.yr && this.O_(t2);
  }
  o_(t2, i) {
    const n2 = Object.assign({ visible: !0, autoScale: !0 }, I(i)), s = new wn(t2, n2, this.Ui.W().layout, this.Ui.W().localization);
    return s.Oo(this.zt()), s;
  }
}, __name(_a34, "gn"), _a34);
var _a35;
let Mn$1 = (_a35 = class {
  constructor(t2, i, n2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Qe = /* @__PURE__ */ new Map(), this.Je = /* @__PURE__ */ new Map(), this.L_ = t2, this.N_ = i, this.tr = n2;
  }
  F_(t2) {
    const i = t2.time, n2 = this.N_.cacheKey(i), s = this.Qe.get(n2);
    if (s !== void 0)
      return s.W_;
    if (this.Ke === this.tr) {
      const t3 = this.Je.get(this.Ge);
      this.Je.delete(this.Ge), this.Qe.delete(m$1(t3)), this.Ge++, this.Ke--;
    }
    const e2 = this.L_(t2);
    return this.Qe.set(n2, { W_: e2, er: this.Ze }), this.Je.set(this.Ze, n2), this.Ke++, this.Ze++, e2;
  }
}, __name(_a35, "Mn"), _a35);
var _a36;
let xn$1 = (_a36 = class {
  constructor(t2, i) {
    p$1(t2 <= i, "right should be >= left"), this.j_ = t2, this.H_ = i;
  }
  Os() {
    return this.j_;
  }
  di() {
    return this.H_;
  }
  U_() {
    return this.H_ - this.j_ + 1;
  }
  Kr(t2) {
    return this.j_ <= t2 && t2 <= this.H_;
  }
  Mh(t2) {
    return this.j_ === t2.Os() && this.H_ === t2.di();
  }
}, __name(_a36, "xn"), _a36);
function Sn(t2, i) {
  return t2 === null || i === null ? t2 === i : t2.Mh(i);
}
__name(Sn, "Sn");
var _a37;
let kn$1 = (_a37 = class {
  constructor() {
    this.q_ = /* @__PURE__ */ new Map(), this.Qe = null, this.Y_ = !1;
  }
  X_(t2) {
    this.Y_ = t2, this.Qe = null;
  }
  K_(t2, i) {
    this.Z_(i), this.Qe = null;
    for (let n2 = i; n2 < t2.length; ++n2) {
      const i2 = t2[n2];
      let s = this.q_.get(i2.timeWeight);
      s === void 0 && (s = [], this.q_.set(i2.timeWeight, s)), s.push({ index: n2, time: i2.time, weight: i2.timeWeight, originalTime: i2.originalTime });
    }
  }
  G_(t2, i) {
    const n2 = Math.ceil(i / t2);
    return this.Qe !== null && this.Qe.J_ === n2 || (this.Qe = { Ea: this.Q_(n2), J_: n2 }), this.Qe.Ea;
  }
  Z_(t2) {
    if (t2 === 0)
      return void this.q_.clear();
    const i = [];
    this.q_.forEach((n2, s) => {
      t2 <= n2[0].index ? i.push(s) : n2.splice(Bt$1(n2, t2, (i2) => i2.index < t2), 1 / 0);
    });
    for (const t3 of i)
      this.q_.delete(t3);
  }
  Q_(t2) {
    let i = [];
    for (const n2 of Array.from(this.q_.keys()).sort((t3, i2) => i2 - t3)) {
      if (!this.q_.get(n2))
        continue;
      const s = i;
      i = [];
      const e2 = s.length;
      let r2 = 0;
      const h2 = m$1(this.q_.get(n2)), l2 = h2.length;
      let a2 = 1 / 0, o2 = -1 / 0;
      for (let n3 = 0; n3 < l2; n3++) {
        const l3 = h2[n3], _24 = l3.index;
        for (; r2 < e2; ) {
          const t3 = s[r2], n4 = t3.index;
          if (!(n4 < _24)) {
            a2 = n4;
            break;
          }
          r2++, i.push(t3), o2 = n4, a2 = 1 / 0;
        }
        if (a2 - _24 >= t2 && _24 - o2 >= t2)
          i.push(l3), o2 = _24;
        else if (this.Y_)
          return s;
      }
      for (; r2 < e2; r2++)
        i.push(s[r2]);
    }
    return i;
  }
}, __name(_a37, "kn"), _a37);
var _a38;
let yn$1 = (_a38 = class {
  constructor(t2) {
    this.tu = t2;
  }
  iu() {
    return this.tu === null ? null : new xn$1(Math.floor(this.tu.Os()), Math.ceil(this.tu.di()));
  }
  nu() {
    return this.tu;
  }
  static su() {
    return new _a38(null);
  }
}, __name(_a38, "yn"), _a38);
function Cn(t2, i) {
  return t2.weight > i.weight ? t2 : i;
}
__name(Cn, "Cn");
const _Tn = class _Tn {
  constructor(t2, i, n2, s) {
    this.e_ = 0, this.eu = null, this.ru = [], this.fo = null, this.do = null, this.hu = new kn$1(), this.lu = /* @__PURE__ */ new Map(), this.au = yn$1.su(), this.ou = !0, this._u = new R(), this.uu = new R(), this.cu = new R(), this.du = null, this.fu = null, this.vu = [], this.cn = i, this.bo = n2, this.pu = i.rightOffset, this.mu = i.barSpacing, this.Ui = t2, this.N_ = s, this.bu(), this.hu.X_(i.uniformDistribution);
  }
  W() {
    return this.cn;
  }
  wu(t2) {
    D$1(this.bo, t2), this.gu(), this.bu();
  }
  Nh(t2, i) {
    var n2;
    D$1(this.cn, t2), this.cn.fixLeftEdge && this.Mu(), this.cn.fixRightEdge && this.xu(), t2.barSpacing !== void 0 && this.Ui.Gn(t2.barSpacing), t2.rightOffset !== void 0 && this.Ui.Jn(t2.rightOffset), t2.minBarSpacing !== void 0 && this.Ui.Gn((n2 = t2.barSpacing) !== null && n2 !== void 0 ? n2 : this.mu), this.gu(), this.bu(), this.cu.m();
  }
  mn(t2) {
    var i, n2;
    return (n2 = (i = this.ru[t2]) === null || i === void 0 ? void 0 : i.time) !== null && n2 !== void 0 ? n2 : null;
  }
  qi(t2) {
    var i;
    return (i = this.ru[t2]) !== null && i !== void 0 ? i : null;
  }
  ya(t2, i) {
    if (this.ru.length < 1)
      return null;
    if (this.N_.key(t2) > this.N_.key(this.ru[this.ru.length - 1].time))
      return i ? this.ru.length - 1 : null;
    const n2 = Bt$1(this.ru, this.N_.key(t2), (t3, i2) => this.N_.key(t3.time) < i2);
    return this.N_.key(t2) < this.N_.key(this.ru[n2].time) ? i ? n2 : null : n2;
  }
  Fi() {
    return this.e_ === 0 || this.ru.length === 0 || this.eu === null;
  }
  ka() {
    return this.ru.length > 0;
  }
  Xs() {
    return this.Su(), this.au.iu();
  }
  ku() {
    return this.Su(), this.au.nu();
  }
  yu() {
    const t2 = this.Xs();
    if (t2 === null)
      return null;
    const i = { from: t2.Os(), to: t2.di() };
    return this.Cu(i);
  }
  Cu(t2) {
    const i = Math.round(t2.from), n2 = Math.round(t2.to), s = b(this.Tu()), e2 = b(this.Pu());
    return { from: b(this.qi(Math.max(s, i))), to: b(this.qi(Math.min(e2, n2))) };
  }
  Ru(t2) {
    return { from: b(this.ya(t2.from, !0)), to: b(this.ya(t2.to, !0)) };
  }
  $i() {
    return this.e_;
  }
  m_(t2) {
    if (!isFinite(t2) || t2 <= 0 || this.e_ === t2)
      return;
    const i = this.ku(), n2 = this.e_;
    if (this.e_ = t2, this.ou = !0, this.cn.lockVisibleTimeRangeOnResize && n2 !== 0) {
      const i2 = this.mu * t2 / n2;
      this.mu = i2;
    }
    if (this.cn.fixLeftEdge && i !== null && i.Os() <= 0) {
      const i2 = n2 - t2;
      this.pu -= Math.round(i2 / this.mu) + 1, this.ou = !0;
    }
    this.Du(), this.Ou();
  }
  Et(t2) {
    if (this.Fi() || !A$1(t2))
      return 0;
    const i = this.Au() + this.pu - t2;
    return this.e_ - (i + 0.5) * this.mu - 1;
  }
  Js(t2, i) {
    const n2 = this.Au(), s = i === void 0 ? 0 : i.from, e2 = i === void 0 ? t2.length : i.to;
    for (let i2 = s; i2 < e2; i2++) {
      const s2 = t2[i2].ut, e3 = n2 + this.pu - s2, r2 = this.e_ - (e3 + 0.5) * this.mu - 1;
      t2[i2].et = r2;
    }
  }
  Vu(t2) {
    return Math.ceil(this.Bu(t2));
  }
  Jn(t2) {
    this.ou = !0, this.pu = t2, this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  he() {
    return this.mu;
  }
  Gn(t2) {
    this.zu(t2), this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  Eu() {
    return this.pu;
  }
  Ea() {
    if (this.Fi())
      return null;
    if (this.fu !== null)
      return this.fu;
    const t2 = this.mu, i = 5 * (this.Ui.W().layout.fontSize + 4) / 8 * (this.cn.tickMarkMaxCharacterLength || 8), n2 = Math.round(i / t2), s = b(this.Xs()), e2 = Math.max(s.Os(), s.Os() - n2), r2 = Math.max(s.di(), s.di() - n2), h2 = this.hu.G_(t2, i), l2 = this.Tu() + n2, a2 = this.Pu() - n2, o2 = this.Lu(), _24 = this.cn.fixLeftEdge || o2, u2 = this.cn.fixRightEdge || o2;
    let c2 = 0;
    for (const t3 of h2) {
      if (!(e2 <= t3.index && t3.index <= r2))
        continue;
      let n3;
      c2 < this.vu.length ? (n3 = this.vu[c2], n3.coord = this.Et(t3.index), n3.label = this.Nu(t3), n3.weight = t3.weight) : (n3 = { needAlignCoordinate: !1, coord: this.Et(t3.index), label: this.Nu(t3), weight: t3.weight }, this.vu.push(n3)), this.mu > i / 2 && !o2 ? n3.needAlignCoordinate = !1 : n3.needAlignCoordinate = _24 && t3.index <= l2 || u2 && t3.index >= a2, c2++;
    }
    return this.vu.length = c2, this.fu = this.vu, this.vu;
  }
  Fu() {
    this.ou = !0, this.Gn(this.cn.barSpacing), this.Jn(this.cn.rightOffset);
  }
  Wu(t2) {
    this.ou = !0, this.eu = t2, this.Ou(), this.Mu();
  }
  ju(t2, i) {
    const n2 = this.Bu(t2), s = this.he(), e2 = s + i * (s / 10);
    this.Gn(e2), this.cn.rightBarStaysOnScroll || this.Jn(this.Eu() + (n2 - this.Bu(t2)));
  }
  Uo(t2) {
    this.fo && this.Zo(), this.do === null && this.du === null && (this.Fi() || (this.do = t2, this.Hu()));
  }
  qo(t2) {
    if (this.du === null)
      return;
    const i = yt$1(this.e_ - t2, 0, this.e_), n2 = yt$1(this.e_ - b(this.do), 0, this.e_);
    i !== 0 && n2 !== 0 && this.Gn(this.du.he * i / n2);
  }
  Yo() {
    this.do !== null && (this.do = null, this.$u());
  }
  Xo(t2) {
    this.fo === null && this.du === null && (this.Fi() || (this.fo = t2, this.Hu()));
  }
  Ko(t2) {
    if (this.fo === null)
      return;
    const i = (this.fo - t2) / this.he();
    this.pu = b(this.du).Eu + i, this.ou = !0, this.Ou();
  }
  Zo() {
    this.fo !== null && (this.fo = null, this.$u());
  }
  Uu() {
    this.qu(this.cn.rightOffset);
  }
  qu(t2, i = 400) {
    if (!isFinite(t2))
      throw new RangeError("offset is required and must be finite number");
    if (!isFinite(i) || i <= 0)
      throw new RangeError("animationDuration (optional) must be finite positive number");
    const n2 = this.pu, s = performance.now();
    this.Ui.Xn({ Yu: (t3) => (t3 - s) / i >= 1, Xu: (e2) => {
      const r2 = (e2 - s) / i;
      return r2 >= 1 ? t2 : n2 + (t2 - n2) * r2;
    } });
  }
  gt(t2, i) {
    this.ou = !0, this.ru = t2, this.hu.K_(t2, i), this.Ou();
  }
  Ku() {
    return this._u;
  }
  Zu() {
    return this.uu;
  }
  Gu() {
    return this.cu;
  }
  Au() {
    return this.eu || 0;
  }
  Ju(t2) {
    const i = t2.U_();
    this.zu(this.e_ / i), this.pu = t2.di() - this.Au(), this.Ou(), this.ou = !0, this.Ui.Iu(), this.Ui.Fh();
  }
  Qu() {
    const t2 = this.Tu(), i = this.Pu();
    t2 !== null && i !== null && this.Ju(new xn$1(t2, i + this.cn.rightOffset));
  }
  tc(t2) {
    const i = new xn$1(t2.from, t2.to);
    this.Ju(i);
  }
  Yi(t2) {
    return this.bo.timeFormatter !== void 0 ? this.bo.timeFormatter(t2.originalTime) : this.N_.formatHorzItem(t2.time);
  }
  Lu() {
    const { handleScroll: t2, handleScale: i } = this.Ui.W();
    return !(t2.horzTouchDrag || t2.mouseWheel || t2.pressedMouseMove || t2.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch);
  }
  Tu() {
    return this.ru.length === 0 ? null : 0;
  }
  Pu() {
    return this.ru.length === 0 ? null : this.ru.length - 1;
  }
  ic(t2) {
    return (this.e_ - 1 - t2) / this.mu;
  }
  Bu(t2) {
    const i = this.ic(t2), n2 = this.Au() + this.pu - i;
    return Math.round(1e6 * n2) / 1e6;
  }
  zu(t2) {
    const i = this.mu;
    this.mu = t2, this.Du(), i !== this.mu && (this.ou = !0, this.nc());
  }
  Su() {
    if (!this.ou)
      return;
    if (this.ou = !1, this.Fi())
      return void this.sc(yn$1.su());
    const t2 = this.Au(), i = this.e_ / this.mu, n2 = this.pu + t2, s = new xn$1(n2 - i + 1, n2);
    this.sc(new yn$1(s));
  }
  Du() {
    const t2 = this.ec();
    if (this.mu < t2 && (this.mu = t2, this.ou = !0), this.e_ !== 0) {
      const t3 = 0.5 * this.e_;
      this.mu > t3 && (this.mu = t3, this.ou = !0);
    }
  }
  ec() {
    return this.cn.fixLeftEdge && this.cn.fixRightEdge && this.ru.length !== 0 ? this.e_ / this.ru.length : this.cn.minBarSpacing;
  }
  Ou() {
    const t2 = this.rc();
    this.pu > t2 && (this.pu = t2, this.ou = !0);
    const i = this.hc();
    i !== null && this.pu < i && (this.pu = i, this.ou = !0);
  }
  hc() {
    const t2 = this.Tu(), i = this.eu;
    return t2 === null || i === null ? null : t2 - i - 1 + (this.cn.fixLeftEdge ? this.e_ / this.mu : Math.min(2, this.ru.length));
  }
  rc() {
    return this.cn.fixRightEdge ? 0 : this.e_ / this.mu - Math.min(2, this.ru.length);
  }
  Hu() {
    this.du = { he: this.he(), Eu: this.Eu() };
  }
  $u() {
    this.du = null;
  }
  Nu(t2) {
    let i = this.lu.get(t2.weight);
    return i === void 0 && (i = new Mn$1((t3) => this.lc(t3), this.N_), this.lu.set(t2.weight, i)), i.F_(t2);
  }
  lc(t2) {
    return this.N_.formatTickmark(t2, this.bo);
  }
  sc(t2) {
    const i = this.au;
    this.au = t2, Sn(i.iu(), this.au.iu()) || this._u.m(), Sn(i.nu(), this.au.nu()) || this.uu.m(), this.nc();
  }
  nc() {
    this.fu = null;
  }
  gu() {
    this.nc(), this.lu.clear();
  }
  bu() {
    this.N_.updateFormatter(this.bo);
  }
  Mu() {
    if (!this.cn.fixLeftEdge)
      return;
    const t2 = this.Tu();
    if (t2 === null)
      return;
    const i = this.Xs();
    if (i === null)
      return;
    const n2 = i.Os() - t2;
    if (n2 < 0) {
      const t3 = this.pu - n2 - 1;
      this.Jn(t3);
    }
    this.Du();
  }
  xu() {
    this.Ou(), this.Du();
  }
};
__name(_Tn, "Tn");
let Tn = _Tn;
const _Pn = class _Pn extends j {
  constructor(t2) {
    super(), this.ac = /* @__PURE__ */ new Map(), this.Lt = t2;
  }
  Z(t2) {
  }
  J(t2) {
    if (!this.Lt.Tt)
      return;
    const { context: i, mediaSize: n2 } = t2;
    let s = 0;
    for (const t3 of this.Lt.oc) {
      if (t3.Jt.length === 0)
        continue;
      i.font = t3.R;
      const e3 = this._c(i, t3.Jt);
      e3 > n2.width ? t3.ju = n2.width / e3 : t3.ju = 1, s += t3.uc * t3.ju;
    }
    let e2 = 0;
    switch (this.Lt.cc) {
      case "top":
        e2 = 0;
        break;
      case "center":
        e2 = Math.max((n2.height - s) / 2, 0);
        break;
      case "bottom":
        e2 = Math.max(n2.height - s, 0);
    }
    i.fillStyle = this.Lt.O;
    for (const t3 of this.Lt.oc) {
      i.save();
      let s2 = 0;
      switch (this.Lt.dc) {
        case "left":
          i.textAlign = "left", s2 = t3.uc / 2;
          break;
        case "center":
          i.textAlign = "center", s2 = n2.width / 2;
          break;
        case "right":
          i.textAlign = "right", s2 = n2.width - 1 - t3.uc / 2;
      }
      i.translate(s2, e2), i.textBaseline = "top", i.font = t3.R, i.scale(t3.ju, t3.ju), i.fillText(t3.Jt, 0, t3.fc), i.restore(), e2 += t3.uc * t3.ju;
    }
  }
  _c(t2, i) {
    const n2 = this.vc(t2.font);
    let s = n2.get(i);
    return s === void 0 && (s = t2.measureText(i).width, n2.set(i, s)), s;
  }
  vc(t2) {
    let i = this.ac.get(t2);
    return i === void 0 && (i = /* @__PURE__ */ new Map(), this.ac.set(t2, i)), i;
  }
};
__name(_Pn, "Pn");
let Pn = _Pn;
const _Rn = class _Rn {
  constructor(t2) {
    this.bt = !0, this.jt = { Tt: !1, O: "", oc: [], cc: "center", dc: "center" }, this.Ht = new Pn(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = !0;
  }
  xt() {
    return this.bt && (this.St(), this.bt = !1), this.Ht;
  }
  St() {
    const t2 = this.$t.W(), i = this.jt;
    i.Tt = t2.visible, i.Tt && (i.O = t2.color, i.dc = t2.horzAlign, i.cc = t2.vertAlign, i.oc = [{ Jt: t2.text, R: N$1(t2.fontSize, t2.fontFamily, t2.fontStyle), uc: 1.2 * t2.fontSize, fc: 0, ju: 0 }]);
  }
};
__name(_Rn, "Rn");
let Rn = _Rn;
var _a39;
let Dn$1 = (_a39 = class extends at$1 {
  constructor(t2, i) {
    super(), this.cn = i, this.wn = new Rn(this);
  }
  Rn() {
    return [];
  }
  Pn() {
    return [this.wn];
  }
  W() {
    return this.cn;
  }
  On() {
    this.wn.gt();
  }
}, __name(_a39, "Dn"), _a39);
var On, An, Vn$1, Bn$1, In;
(function(t2) {
  t2[t2.OnTouchEnd = 0] = "OnTouchEnd", t2[t2.OnNextTap = 1] = "OnNextTap";
})(On || (On = {}));
const _zn = class _zn {
  constructor(t2, i, n2) {
    this.mc = [], this.bc = [], this.e_ = 0, this.wc = null, this.gc = new R(), this.Mc = new R(), this.xc = null, this.Sc = t2, this.cn = i, this.N_ = n2, this.kc = new F$1(this), this.wl = new Tn(this, i.timeScale, this.cn.localization, n2), this.wt = new _t$1(this, i.crosshair), this.yc = new Ji(i.crosshair), this.Cc = new Dn$1(this, i.watermark), this.Tc(), this.mc[0].p_(2e3), this.Pc = this.Rc(0), this.Dc = this.Rc(1);
  }
  $l() {
    this.Oc(ct.es());
  }
  Fh() {
    this.Oc(ct.ss());
  }
  sa() {
    this.Oc(new ct(1));
  }
  Ul(t2) {
    const i = this.Ac(t2);
    this.Oc(i);
  }
  Vc() {
    return this.wc;
  }
  Bc(t2) {
    const i = this.wc;
    this.wc = t2, i !== null && this.Ul(i.Ic), t2 !== null && this.Ul(t2.Ic);
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    D$1(this.cn, t2), this.mc.forEach((i) => i.c_(t2)), t2.timeScale !== void 0 && this.wl.Nh(t2.timeScale), t2.localization !== void 0 && this.wl.wu(t2.localization), (t2.leftPriceScale || t2.rightPriceScale) && this.gc.m(), this.Pc = this.Rc(0), this.Dc = this.Rc(1), this.$l();
  }
  zc(t2, i) {
    if (t2 === "left")
      return void this.Nh({ leftPriceScale: i });
    if (t2 === "right")
      return void this.Nh({ rightPriceScale: i });
    const n2 = this.Ec(t2);
    n2 !== null && (n2.At.Nh(i), this.gc.m());
  }
  Ec(t2) {
    for (const i of this.mc) {
      const n2 = i.d_(t2);
      if (n2 !== null)
        return { Ut: i, At: n2 };
    }
    return null;
  }
  yt() {
    return this.wl;
  }
  Lc() {
    return this.mc;
  }
  Nc() {
    return this.Cc;
  }
  Fc() {
    return this.wt;
  }
  Wc() {
    return this.Mc;
  }
  jc(t2, i) {
    t2.Oo(i), this.Iu();
  }
  m_(t2) {
    this.e_ = t2, this.wl.m_(this.e_), this.mc.forEach((i) => i.m_(t2)), this.Iu();
  }
  Tc(t2) {
    const i = new gn$1(this.wl, this);
    t2 !== void 0 ? this.mc.splice(t2, 0, i) : this.mc.push(i);
    const n2 = t2 === void 0 ? this.mc.length - 1 : t2, s = ct.es();
    return s.Nn(n2, { Fn: 0, Wn: !0 }), this.Oc(s), i;
  }
  y_(t2, i, n2) {
    t2.y_(i, n2);
  }
  C_(t2, i, n2) {
    t2.C_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2));
  }
  T_(t2, i) {
    t2.T_(i), this.Oc(this.Hc(t2, 2));
  }
  P_(t2, i, n2) {
    i.yo() || t2.P_(i, n2);
  }
  R_(t2, i, n2) {
    i.yo() || (t2.R_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2)));
  }
  D_(t2, i) {
    i.yo() || (t2.D_(i), this.Oc(this.Hc(t2, 2)));
  }
  A_(t2, i) {
    t2.A_(i), this.Oc(this.Hc(t2, 2));
  }
  $c(t2) {
    this.wl.Uo(t2);
  }
  Uc(t2, i) {
    const n2 = this.yt();
    if (n2.Fi() || i === 0)
      return;
    const s = n2.$i();
    t2 = Math.max(1, Math.min(t2, s)), n2.ju(t2, i), this.Iu();
  }
  qc(t2) {
    this.Yc(0), this.Xc(t2), this.Kc();
  }
  Zc(t2) {
    this.wl.qo(t2), this.Iu();
  }
  Gc() {
    this.wl.Yo(), this.Fh();
  }
  Yc(t2) {
    this.wl.Xo(t2);
  }
  Xc(t2) {
    this.wl.Ko(t2), this.Iu();
  }
  Kc() {
    this.wl.Zo(), this.Fh();
  }
  Mt() {
    return this.bc;
  }
  Jc(t2, i, n2, s, e2) {
    this.wt.gn(t2, i);
    let r2 = NaN, h2 = this.wl.Vu(t2);
    const l2 = this.wl.Xs();
    l2 !== null && (h2 = Math.min(Math.max(l2.Os(), h2), l2.di()));
    const a2 = s.vn(), o2 = a2.Pt();
    o2 !== null && (r2 = a2.pn(i, o2)), r2 = this.yc.Ca(r2, h2, s), this.wt.kn(h2, r2, s), this.sa(), e2 || this.Mc.m(this.wt.kt(), { x: t2, y: i }, n2);
  }
  Qc(t2, i, n2) {
    const s = n2.vn(), e2 = s.Pt(), r2 = s.Ot(t2, b(e2)), h2 = this.wl.ya(i, !0), l2 = this.wl.Et(b(h2));
    this.Jc(l2, r2, null, n2, !0);
  }
  td(t2) {
    this.Fc().Cn(), this.sa(), t2 || this.Mc.m(null, null, null);
  }
  ql() {
    const t2 = this.wt.Ut();
    if (t2 !== null) {
      const i = this.wt.xn(), n2 = this.wt.Sn();
      this.Jc(i, n2, null, t2);
    }
    this.wt.On();
  }
  nd(t2, i, n2) {
    const s = this.wl.mn(0);
    i !== void 0 && n2 !== void 0 && this.wl.gt(i, n2);
    const e2 = this.wl.mn(0), r2 = this.wl.Au(), h2 = this.wl.Xs();
    if (h2 !== null && s !== null && e2 !== null) {
      const i2 = h2.Kr(r2), l2 = this.N_.key(s) > this.N_.key(e2), a2 = t2 !== null && t2 > r2 && !l2, o2 = this.wl.W().allowShiftVisibleRangeOnWhitespaceReplacement, _24 = i2 && (n2 !== void 0 || o2) && this.wl.W().shiftVisibleRangeOnNewBar;
      if (a2 && !_24) {
        const i3 = t2 - r2;
        this.wl.Jn(this.wl.Eu() - i3);
      }
    }
    this.wl.Wu(t2);
  }
  Kl(t2) {
    t2 !== null && t2.B_();
  }
  cr(t2) {
    const i = this.mc.find((i2) => i2.No().includes(t2));
    return i === void 0 ? null : i;
  }
  Iu() {
    this.Cc.On(), this.mc.forEach((t2) => t2.B_()), this.ql();
  }
  S() {
    this.mc.forEach((t2) => t2.S()), this.mc.length = 0, this.cn.localization.priceFormatter = void 0, this.cn.localization.percentageFormatter = void 0, this.cn.localization.timeFormatter = void 0;
  }
  sd() {
    return this.kc;
  }
  mr() {
    return this.kc.W();
  }
  f_() {
    return this.gc;
  }
  ed(t2, i, n2) {
    const s = this.mc[0], e2 = this.rd(i, t2, s, n2);
    return this.bc.push(e2), this.bc.length === 1 ? this.$l() : this.Fh(), e2;
  }
  hd(t2) {
    const i = this.cr(t2), n2 = this.bc.indexOf(t2);
    p$1(n2 !== -1, "Series not found"), this.bc.splice(n2, 1), b(i).jo(t2), t2.S && t2.S();
  }
  Hl(t2, i) {
    const n2 = b(this.cr(t2));
    n2.jo(t2);
    const s = this.Ec(i);
    if (s === null) {
      const s2 = t2.Zi();
      n2.Fo(t2, i, s2);
    } else {
      const e2 = s.Ut === n2 ? t2.Zi() : void 0;
      s.Ut.Fo(t2, i, e2);
    }
  }
  Qu() {
    const t2 = ct.ss();
    t2.$n(), this.Oc(t2);
  }
  ld(t2) {
    const i = ct.ss();
    i.Yn(t2), this.Oc(i);
  }
  Zn() {
    const t2 = ct.ss();
    t2.Zn(), this.Oc(t2);
  }
  Gn(t2) {
    const i = ct.ss();
    i.Gn(t2), this.Oc(i);
  }
  Jn(t2) {
    const i = ct.ss();
    i.Jn(t2), this.Oc(i);
  }
  Xn(t2) {
    const i = ct.ss();
    i.Xn(t2), this.Oc(i);
  }
  Un() {
    const t2 = ct.ss();
    t2.Un(), this.Oc(t2);
  }
  ad() {
    return this.cn.rightPriceScale.visible ? "right" : "left";
  }
  od() {
    return this.Dc;
  }
  q() {
    return this.Pc;
  }
  It(t2) {
    const i = this.Dc, n2 = this.Pc;
    if (i === n2)
      return i;
    if (t2 = Math.max(0, Math.min(100, Math.round(100 * t2))), this.xc === null || this.xc.Ts !== n2 || this.xc.Ps !== i)
      this.xc = { Ts: n2, Ps: i, _d: /* @__PURE__ */ new Map() };
    else {
      const i2 = this.xc._d.get(t2);
      if (i2 !== void 0)
        return i2;
    }
    const s = function(t3, i2, n3) {
      const [s2, e2, r2, h2] = T$1(t3), [l2, a2, o2, _24] = T$1(i2), u2 = [M(s2 + n3 * (l2 - s2)), M(e2 + n3 * (a2 - e2)), M(r2 + n3 * (o2 - r2)), x(h2 + n3 * (_24 - h2))];
      return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
    }(n2, i, t2 / 100);
    return this.xc._d.set(t2, s), s;
  }
  Hc(t2, i) {
    const n2 = new ct(i);
    if (t2 !== null) {
      const s = this.mc.indexOf(t2);
      n2.Nn(s, { Fn: i });
    }
    return n2;
  }
  Ac(t2, i) {
    return i === void 0 && (i = 2), this.Hc(this.cr(t2), i);
  }
  Oc(t2) {
    this.Sc && this.Sc(t2), this.mc.forEach((t3) => t3.z_().Wh().gt());
  }
  rd(t2, i, n2, s) {
    const e2 = new Gi(this, t2, i, n2, s), r2 = t2.priceScaleId !== void 0 ? t2.priceScaleId : this.ad();
    return n2.Fo(e2, r2), ut$1(r2) || e2.Nh(t2), e2;
  }
  Rc(t2) {
    const i = this.cn.layout;
    return i.background.type === "gradient" ? t2 === 0 ? i.background.topColor : i.background.bottomColor : i.background.color;
  }
};
__name(_zn, "zn");
let zn = _zn;
function En(t2) {
  return !O$1(t2) && !V$1(t2);
}
__name(En, "En");
function Ln$1(t2) {
  return O$1(t2);
}
__name(Ln$1, "Ln$1");
(function(t2) {
  t2[t2.Disabled = 0] = "Disabled", t2[t2.Continuous = 1] = "Continuous", t2[t2.OnDataUpdate = 2] = "OnDataUpdate";
})(An || (An = {})), function(t2) {
  t2[t2.LastBar = 0] = "LastBar", t2[t2.LastVisible = 1] = "LastVisible";
}(Vn$1 || (Vn$1 = {})), function(t2) {
  t2.Solid = "solid", t2.VerticalGradient = "gradient";
}(Bn$1 || (Bn$1 = {})), function(t2) {
  t2[t2.Year = 0] = "Year", t2[t2.Month = 1] = "Month", t2[t2.DayOfMonth = 2] = "DayOfMonth", t2[t2.Time = 3] = "Time", t2[t2.TimeWithSeconds = 4] = "TimeWithSeconds";
}(In || (In = {}));
const Nn = /* @__PURE__ */ __name((t2) => t2.getUTCFullYear(), "Nn");
function Fn$1(t2, i, n2) {
  return i.replace(/yyyy/g, ((t3) => ft$1(Nn(t3), 4))(t2)).replace(/yy/g, ((t3) => ft$1(Nn(t3) % 100, 2))(t2)).replace(/MMMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "long" }))(t2, n2)).replace(/MMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "short" }))(t2, n2)).replace(/MM/g, ((t3) => ft$1(((t4) => t4.getUTCMonth() + 1)(t3), 2))(t2)).replace(/dd/g, ((t3) => ft$1(((t4) => t4.getUTCDate())(t3), 2))(t2));
}
__name(Fn$1, "Fn$1");
var _a40;
let Wn$1 = (_a40 = class {
  constructor(t2 = "yyyy-MM-dd", i = "default") {
    this.ud = t2, this.dd = i;
  }
  F_(t2) {
    return Fn$1(t2, this.ud, this.dd);
  }
}, __name(_a40, "Wn"), _a40);
const _jn = class _jn {
  constructor(t2) {
    this.fd = t2 || "%h:%m:%s";
  }
  F_(t2) {
    return this.fd.replace("%h", ft$1(t2.getUTCHours(), 2)).replace("%m", ft$1(t2.getUTCMinutes(), 2)).replace("%s", ft$1(t2.getUTCSeconds(), 2));
  }
};
__name(_jn, "jn");
let jn = _jn;
const Hn$1 = { vd: "yyyy-MM-dd", pd: "%h:%m:%s", md: " ", bd: "default" }, _$n = class _$n {
  constructor(t2 = {}) {
    const i = Object.assign(Object.assign({}, Hn$1), t2);
    this.wd = new Wn$1(i.vd, i.bd), this.gd = new jn(i.pd), this.Md = i.md;
  }
  F_(t2) {
    return `${this.wd.F_(t2)}${this.Md}${this.gd.F_(t2)}`;
  }
};
__name(_$n, "$n");
let $n = _$n;
function Un(t2) {
  return 60 * t2 * 60 * 1e3;
}
__name(Un, "Un");
function qn$1(t2) {
  return 60 * t2 * 1e3;
}
__name(qn$1, "qn$1");
const Yn = [{ xd: (Xn$1 = 1, 1e3 * Xn$1), Sd: 10 }, { xd: qn$1(1), Sd: 20 }, { xd: qn$1(5), Sd: 21 }, { xd: qn$1(30), Sd: 22 }, { xd: Un(1), Sd: 30 }, { xd: Un(3), Sd: 31 }, { xd: Un(6), Sd: 32 }, { xd: Un(12), Sd: 33 }];
var Xn$1;
function Kn$1(t2, i) {
  if (t2.getUTCFullYear() !== i.getUTCFullYear())
    return 70;
  if (t2.getUTCMonth() !== i.getUTCMonth())
    return 60;
  if (t2.getUTCDate() !== i.getUTCDate())
    return 50;
  for (let n2 = Yn.length - 1; n2 >= 0; --n2)
    if (Math.floor(i.getTime() / Yn[n2].xd) !== Math.floor(t2.getTime() / Yn[n2].xd))
      return Yn[n2].Sd;
  return 0;
}
__name(Kn$1, "Kn$1");
function Zn(t2) {
  let i = t2;
  if (V$1(t2) && (i = Jn$1(t2)), !En(i))
    throw new Error("time must be of type BusinessDay");
  const n2 = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0));
  return { kd: Math.round(n2.getTime() / 1e3), yd: i };
}
__name(Zn, "Zn");
function Gn$1(t2) {
  if (!Ln$1(t2))
    throw new Error("time must be of type isUTCTimestamp");
  return { kd: t2 };
}
__name(Gn$1, "Gn$1");
function Jn$1(t2) {
  const i = new Date(t2);
  if (isNaN(i.getTime()))
    throw new Error(`Invalid date string=${t2}, expected format=yyyy-mm-dd`);
  return { day: i.getUTCDate(), month: i.getUTCMonth() + 1, year: i.getUTCFullYear() };
}
__name(Jn$1, "Jn$1");
function Qn$1(t2) {
  V$1(t2.time) && (t2.time = Jn$1(t2.time));
}
__name(Qn$1, "Qn$1");
const _ts = class _ts {
  options() {
    return this.cn;
  }
  setOptions(t2) {
    this.cn = t2, this.updateFormatter(t2.localization);
  }
  preprocessData(t2) {
    Array.isArray(t2) ? function(t3) {
      t3.forEach(Qn$1);
    }(t2) : Qn$1(t2);
  }
  createConverterToInternalObj(t2) {
    return b(function(t3) {
      return t3.length === 0 ? null : En(t3[0].time) || V$1(t3[0].time) ? Zn : Gn$1;
    }(t2));
  }
  key(t2) {
    return typeof t2 == "object" && "kd" in t2 ? t2.kd : this.key(this.convertHorzItemToInternal(t2));
  }
  cacheKey(t2) {
    const i = t2;
    return i.yd === void 0 ? new Date(1e3 * i.kd).getTime() : new Date(Date.UTC(i.yd.year, i.yd.month - 1, i.yd.day)).getTime();
  }
  convertHorzItemToInternal(t2) {
    return Ln$1(i = t2) ? Gn$1(i) : En(i) ? Zn(i) : Zn(Jn$1(i));
    var i;
  }
  updateFormatter(t2) {
    if (!this.cn)
      return;
    const i = t2.dateFormat;
    this.cn.timeScale.timeVisible ? this.Cd = new $n({ vd: i, pd: this.cn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", md: "   ", bd: t2.locale }) : this.Cd = new Wn$1(i, t2.locale);
  }
  formatHorzItem(t2) {
    const i = t2;
    return this.Cd.F_(new Date(1e3 * i.kd));
  }
  formatTickmark(t2, i) {
    const n2 = function(t3, i2, n3) {
      switch (t3) {
        case 0:
        case 10:
          return i2 ? n3 ? 4 : 3 : 2;
        case 20:
        case 21:
        case 22:
        case 30:
        case 31:
        case 32:
        case 33:
          return i2 ? 3 : 2;
        case 50:
          return 2;
        case 60:
          return 1;
        case 70:
          return 0;
      }
    }(t2.weight, this.cn.timeScale.timeVisible, this.cn.timeScale.secondsVisible), s = this.cn.timeScale;
    if (s.tickMarkFormatter !== void 0) {
      const e2 = s.tickMarkFormatter(t2.originalTime, n2, i.locale);
      if (e2 !== null)
        return e2;
    }
    return function(t3, i2, n3) {
      const s2 = {};
      switch (i2) {
        case 0:
          s2.year = "numeric";
          break;
        case 1:
          s2.month = "short";
          break;
        case 2:
          s2.day = "numeric";
          break;
        case 3:
          s2.hour12 = !1, s2.hour = "2-digit", s2.minute = "2-digit";
          break;
        case 4:
          s2.hour12 = !1, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
      }
      const e2 = t3.yd === void 0 ? new Date(1e3 * t3.kd) : new Date(Date.UTC(t3.yd.year, t3.yd.month - 1, t3.yd.day));
      return new Date(e2.getUTCFullYear(), e2.getUTCMonth(), e2.getUTCDate(), e2.getUTCHours(), e2.getUTCMinutes(), e2.getUTCSeconds(), e2.getUTCMilliseconds()).toLocaleString(n3, s2);
    }(t2.time, n2, i.locale);
  }
  maxTickMarkWeight(t2) {
    let i = t2.reduce(Cn, t2[0]).weight;
    return i > 30 && i < 50 && (i = 30), i;
  }
  fillWeightsForPoints(t2, i) {
    (function(t3, i2 = 0) {
      if (t3.length === 0)
        return;
      let n2 = i2 === 0 ? null : t3[i2 - 1].time.kd, s = n2 !== null ? new Date(1e3 * n2) : null, e2 = 0;
      for (let r2 = i2; r2 < t3.length; ++r2) {
        const i3 = t3[r2], h2 = new Date(1e3 * i3.time.kd);
        s !== null && (i3.timeWeight = Kn$1(h2, s)), e2 += i3.time.kd - (n2 || i3.time.kd), n2 = i3.time.kd, s = h2;
      }
      if (i2 === 0 && t3.length > 1) {
        const i3 = Math.ceil(e2 / (t3.length - 1)), n3 = new Date(1e3 * (t3[0].time.kd - i3));
        t3[0].timeWeight = Kn$1(new Date(1e3 * t3[0].time.kd), n3);
      }
    })(t2, i);
  }
  static Td(t2) {
    return D$1({ localization: { dateFormat: "dd MMM 'yy" } }, t2 ?? {});
  }
};
__name(_ts, "ts");
let ts = _ts;
const is = typeof window < "u";
function ns() {
  return !!is && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
}
__name(ns, "ns");
function ss() {
  return !!is && /iPhone|iPad|iPod/.test(window.navigator.platform);
}
__name(ss, "ss");
function es(t2) {
  return t2 + t2 % 2;
}
__name(es, "es");
function rs(t2, i) {
  return t2.Pd - i.Pd;
}
__name(rs, "rs");
function hs(t2, i, n2) {
  const s = (t2.Pd - i.Pd) / (t2.ut - i.ut);
  return Math.sign(s) * Math.min(Math.abs(s), n2);
}
__name(hs, "hs");
const _ls = class _ls {
  constructor(t2, i, n2, s) {
    this.Rd = null, this.Dd = null, this.Od = null, this.Ad = null, this.Vd = null, this.Bd = 0, this.Id = 0, this.zd = t2, this.Ed = i, this.Ld = n2, this.rs = s;
  }
  Nd(t2, i) {
    if (this.Rd !== null) {
      if (this.Rd.ut === i)
        return void (this.Rd.Pd = t2);
      if (Math.abs(this.Rd.Pd - t2) < this.rs)
        return;
    }
    this.Ad = this.Od, this.Od = this.Dd, this.Dd = this.Rd, this.Rd = { ut: i, Pd: t2 };
  }
  Dr(t2, i) {
    if (this.Rd === null || this.Dd === null || i - this.Rd.ut > 50)
      return;
    let n2 = 0;
    const s = hs(this.Rd, this.Dd, this.Ed), e2 = rs(this.Rd, this.Dd), r2 = [s], h2 = [e2];
    if (n2 += e2, this.Od !== null) {
      const t3 = hs(this.Dd, this.Od, this.Ed);
      if (Math.sign(t3) === Math.sign(s)) {
        const i2 = rs(this.Dd, this.Od);
        if (r2.push(t3), h2.push(i2), n2 += i2, this.Ad !== null) {
          const t4 = hs(this.Od, this.Ad, this.Ed);
          if (Math.sign(t4) === Math.sign(s)) {
            const i3 = rs(this.Od, this.Ad);
            r2.push(t4), h2.push(i3), n2 += i3;
          }
        }
      }
    }
    let l2 = 0;
    for (let t3 = 0; t3 < r2.length; ++t3)
      l2 += h2[t3] / n2 * r2[t3];
    Math.abs(l2) < this.zd || (this.Vd = { Pd: t2, ut: i }, this.Id = l2, this.Bd = function(t3, i2) {
      const n3 = Math.log(i2);
      return Math.log(1 * n3 / -t3) / n3;
    }(Math.abs(l2), this.Ld));
  }
  Xu(t2) {
    const i = b(this.Vd), n2 = t2 - i.ut;
    return i.Pd + this.Id * (Math.pow(this.Ld, n2) - 1) / Math.log(this.Ld);
  }
  Yu(t2) {
    return this.Vd === null || this.Fd(t2) === this.Bd;
  }
  Fd(t2) {
    const i = t2 - b(this.Vd).ut;
    return Math.min(i, this.Bd);
  }
};
__name(_ls, "ls");
let ls = _ls;
function as(t2, n2) {
  const s = b(t2.ownerDocument).createElement("canvas");
  t2.appendChild(s);
  const e2 = bindTo(s, { type: "device-pixel-content-box", options: { allowResizeObserver: !1 }, transform: (t3, i) => ({ width: Math.max(t3.width, i.width), height: Math.max(t3.height, i.height) }) });
  return e2.resizeCanvasElement(n2), e2;
}
__name(as, "as");
function os(t2, i, n2, s) {
  t2.G && t2.G(i, n2, s);
}
__name(os, "os");
function _s(t2, i, n2, s) {
  t2.K(i, n2, s);
}
__name(_s, "_s");
function us(t2, i, n2, s) {
  const e2 = t2(n2, s);
  for (const t3 of e2) {
    const n3 = t3.xt();
    n3 !== null && i(n3);
  }
}
__name(us, "us");
function cs(t2) {
  is && window.chrome !== void 0 && t2.addEventListener("mousedown", (t3) => {
    if (t3.button === 1)
      return t3.preventDefault(), !1;
  });
}
__name(cs, "cs");
const _ds = class _ds {
  constructor(t2, i, n2) {
    this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.Yd = null, this.Xd = !1, this.Kd = null, this.Zd = null, this.Gd = !1, this.Jd = !1, this.Qd = !1, this.tf = null, this.if = null, this.nf = null, this.sf = null, this.ef = null, this.rf = null, this.hf = null, this.lf = 0, this.af = !1, this._f = !1, this.uf = !1, this.cf = 0, this.df = null, this.ff = !ss(), this.vf = (t3) => {
      this.pf(t3);
    }, this.mf = (t3) => {
      if (this.bf(t3)) {
        const i2 = this.wf(t3);
        if (++this.$d, this.Ud && this.$d > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.qd);
          n3 < 30 && !this.Qd && this.xf(i2, this.kf.Sf), this.yf();
        }
      } else {
        const i2 = this.wf(t3);
        if (++this.Wd, this.jd && this.Wd > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.Hd);
          n3 < 5 && !this.Jd && this.Cf(i2, this.kf.Tf), this.Pf();
        }
      }
    }, this.Rf = t2, this.kf = i, this.cn = n2, this.Df();
  }
  S() {
    this.tf !== null && (this.tf(), this.tf = null), this.if !== null && (this.if(), this.if = null), this.sf !== null && (this.sf(), this.sf = null), this.ef !== null && (this.ef(), this.ef = null), this.rf !== null && (this.rf(), this.rf = null), this.nf !== null && (this.nf(), this.nf = null), this.Of(), this.Pf();
  }
  Af(t2) {
    this.sf && this.sf();
    const i = this.Vf.bind(this);
    if (this.sf = () => {
      this.Rf.removeEventListener("mousemove", i);
    }, this.Rf.addEventListener("mousemove", i), this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Bf), this.ff = !0;
  }
  Pf() {
    this.jd !== null && clearTimeout(this.jd), this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  yf() {
    this.Ud !== null && clearTimeout(this.Ud), this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  Vf(t2) {
    if (this.uf || this.Zd !== null || this.bf(t2))
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.If), this.ff = !0;
  }
  zf(t2) {
    const i = bs(t2.changedTouches, b(this.df));
    if (i === null || (this.cf = ms(t2), this.hf !== null) || this._f)
      return;
    this.af = !0;
    const n2 = this.Mf(ps(i), b(this.Zd)), { Ef: s, Lf: e2, gf: r2 } = n2;
    if (this.Gd || !(r2 < 5)) {
      if (!this.Gd) {
        const t3 = 0.5 * s, i2 = e2 >= t3 && !this.cn.Nf(), n3 = t3 > e2 && !this.cn.Ff();
        i2 || n3 || (this._f = !0), this.Gd = !0, this.Qd = !0, this.Of(), this.yf();
      }
      if (!this._f) {
        const n3 = this.wf(t2, i);
        this.xf(n3, this.kf.Wf), vs(t2);
      }
    }
  }
  jf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.Mf(ps(t2), b(this.Kd)), { gf: n2 } = i;
    if (n2 >= 5 && (this.Jd = !0, this.Pf()), this.Jd) {
      const i2 = this.wf(t2);
      this.Cf(i2, this.kf.Hf);
    }
  }
  Mf(t2, i) {
    const n2 = Math.abs(i.et - t2.et), s = Math.abs(i.rt - t2.rt);
    return { Ef: n2, Lf: s, gf: n2 + s };
  }
  $f(t2) {
    let i = bs(t2.changedTouches, b(this.df));
    if (i === null && t2.touches.length === 0 && (i = t2.changedTouches[0]), i === null)
      return;
    this.df = null, this.cf = ms(t2), this.Of(), this.Zd = null, this.rf && (this.rf(), this.rf = null);
    const n2 = this.wf(t2, i);
    if (this.xf(n2, this.kf.Uf), ++this.$d, this.Ud && this.$d > 1) {
      const { gf: t3 } = this.Mf(ps(i), this.qd);
      t3 < 30 && !this.Qd && this.xf(n2, this.kf.Sf), this.yf();
    } else
      this.Qd || (this.xf(n2, this.kf.qf), this.kf.qf && vs(t2));
    this.$d === 0 && vs(t2), t2.touches.length === 0 && this.Xd && (this.Xd = !1, vs(t2));
  }
  pf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.wf(t2);
    if (this.Kd = null, this.uf = !1, this.ef && (this.ef(), this.ef = null), ns() && this.Rf.ownerDocument.documentElement.removeEventListener("mouseleave", this.vf), !this.bf(t2))
      if (this.Cf(i, this.kf.Yf), ++this.Wd, this.jd && this.Wd > 1) {
        const { gf: n2 } = this.Mf(ps(t2), this.Hd);
        n2 < 5 && !this.Jd && this.Cf(i, this.kf.Tf), this.Pf();
      } else
        this.Jd || this.Cf(i, this.kf.Xf);
  }
  Of() {
    this.Yd !== null && (clearTimeout(this.Yd), this.Yd = null);
  }
  Kf(t2) {
    if (this.df !== null)
      return;
    const i = t2.changedTouches[0];
    this.df = i.identifier, this.cf = ms(t2);
    const n2 = this.Rf.ownerDocument.documentElement;
    this.Qd = !1, this.Gd = !1, this._f = !1, this.Zd = ps(i), this.rf && (this.rf(), this.rf = null);
    {
      const i2 = this.zf.bind(this), s2 = this.$f.bind(this);
      this.rf = () => {
        n2.removeEventListener("touchmove", i2), n2.removeEventListener("touchend", s2);
      }, n2.addEventListener("touchmove", i2, { passive: !1 }), n2.addEventListener("touchend", s2, { passive: !1 }), this.Of(), this.Yd = setTimeout(this.Zf.bind(this, t2), 240);
    }
    const s = this.wf(t2, i);
    this.xf(s, this.kf.Gf), this.Ud || (this.$d = 0, this.Ud = setTimeout(this.yf.bind(this), 500), this.qd = ps(i));
  }
  Jf(t2) {
    if (t2.button !== 0)
      return;
    const i = this.Rf.ownerDocument.documentElement;
    ns() && i.addEventListener("mouseleave", this.vf), this.Jd = !1, this.Kd = ps(t2), this.ef && (this.ef(), this.ef = null);
    {
      const t3 = this.jf.bind(this), n3 = this.pf.bind(this);
      this.ef = () => {
        i.removeEventListener("mousemove", t3), i.removeEventListener("mouseup", n3);
      }, i.addEventListener("mousemove", t3), i.addEventListener("mouseup", n3);
    }
    if (this.uf = !0, this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Qf), this.jd || (this.Wd = 0, this.jd = setTimeout(this.Pf.bind(this), 500), this.Hd = ps(t2));
  }
  Df() {
    this.Rf.addEventListener("mouseenter", this.Af.bind(this)), this.Rf.addEventListener("touchcancel", this.Of.bind(this));
    {
      const t2 = this.Rf.ownerDocument, i = /* @__PURE__ */ __name((t3) => {
        this.kf.tv && (t3.composed && this.Rf.contains(t3.composedPath()[0]) || t3.target && this.Rf.contains(t3.target) || this.kf.tv());
      }, "i");
      this.if = () => {
        t2.removeEventListener("touchstart", i);
      }, this.tf = () => {
        t2.removeEventListener("mousedown", i);
      }, t2.addEventListener("mousedown", i), t2.addEventListener("touchstart", i, { passive: !0 });
    }
    ss() && (this.nf = () => {
      this.Rf.removeEventListener("dblclick", this.mf);
    }, this.Rf.addEventListener("dblclick", this.mf)), this.Rf.addEventListener("mouseleave", this.iv.bind(this)), this.Rf.addEventListener("touchstart", this.Kf.bind(this), { passive: !0 }), cs(this.Rf), this.Rf.addEventListener("mousedown", this.Jf.bind(this)), this.nv(), this.Rf.addEventListener("touchmove", () => {
    }, { passive: !1 });
  }
  nv() {
    this.kf.sv === void 0 && this.kf.ev === void 0 && this.kf.rv === void 0 || (this.Rf.addEventListener("touchstart", (t2) => this.hv(t2.touches), { passive: !0 }), this.Rf.addEventListener("touchmove", (t2) => {
      if (t2.touches.length === 2 && this.hf !== null && this.kf.ev !== void 0) {
        const i = fs(t2.touches[0], t2.touches[1]) / this.lf;
        this.kf.ev(this.hf, i), vs(t2);
      }
    }, { passive: !1 }), this.Rf.addEventListener("touchend", (t2) => {
      this.hv(t2.touches);
    }));
  }
  hv(t2) {
    t2.length === 1 && (this.af = !1), t2.length !== 2 || this.af || this.Xd ? this.lv() : this.av(t2);
  }
  av(t2) {
    const i = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    this.hf = { et: (t2[0].clientX - i.left + (t2[1].clientX - i.left)) / 2, rt: (t2[0].clientY - i.top + (t2[1].clientY - i.top)) / 2 }, this.lf = fs(t2[0], t2[1]), this.kf.sv !== void 0 && this.kf.sv(), this.Of();
  }
  lv() {
    this.hf !== null && (this.hf = null, this.kf.rv !== void 0 && this.kf.rv());
  }
  iv(t2) {
    if (this.sf && this.sf(), this.bf(t2) || !this.ff)
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.ov), this.ff = !ss();
  }
  Zf(t2) {
    const i = bs(t2.touches, b(this.df));
    if (i === null)
      return;
    const n2 = this.wf(t2, i);
    this.xf(n2, this.kf._v), this.Qd = !0, this.Xd = !0;
  }
  bf(t2) {
    return t2.sourceCapabilities && t2.sourceCapabilities.firesTouchEvents !== void 0 ? t2.sourceCapabilities.firesTouchEvents : ms(t2) < this.cf + 500;
  }
  xf(t2, i) {
    i && i.call(this.kf, t2);
  }
  Cf(t2, i) {
    i && i.call(this.kf, t2);
  }
  wf(t2, i) {
    const n2 = i || t2, s = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    return { clientX: n2.clientX, clientY: n2.clientY, pageX: n2.pageX, pageY: n2.pageY, screenX: n2.screenX, screenY: n2.screenY, localX: n2.clientX - s.left, localY: n2.clientY - s.top, ctrlKey: t2.ctrlKey, altKey: t2.altKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, uv: !t2.type.startsWith("mouse") && t2.type !== "contextmenu" && t2.type !== "click", cv: t2.type, dv: n2.target, fv: t2.view, vv: () => {
      t2.type !== "touchstart" && vs(t2);
    } };
  }
};
__name(_ds, "ds");
let ds = _ds;
function fs(t2, i) {
  const n2 = t2.clientX - i.clientX, s = t2.clientY - i.clientY;
  return Math.sqrt(n2 * n2 + s * s);
}
__name(fs, "fs");
function vs(t2) {
  t2.cancelable && t2.preventDefault();
}
__name(vs, "vs");
function ps(t2) {
  return { et: t2.pageX, rt: t2.pageY };
}
__name(ps, "ps");
function ms(t2) {
  return t2.timeStamp || performance.now();
}
__name(ms, "ms");
function bs(t2, i) {
  for (let n2 = 0; n2 < t2.length; ++n2)
    if (t2[n2].identifier === i)
      return t2[n2];
  return null;
}
__name(bs, "bs");
function ws(t2) {
  return { Ic: t2.Ic, pv: { wr: t2.mv.externalId }, bv: t2.mv.cursorStyle };
}
__name(ws, "ws");
function gs(t2, i, n2) {
  for (const s of t2) {
    const t3 = s.xt();
    if (t3 !== null && t3.br) {
      const e2 = t3.br(i, n2);
      if (e2 !== null)
        return { fv: s, pv: e2 };
    }
  }
  return null;
}
__name(gs, "gs");
function Ms(t2, i) {
  return (n2) => {
    var s, e2, r2, h2;
    return ((e2 = (s = n2.At()) === null || s === void 0 ? void 0 : s.xa()) !== null && e2 !== void 0 ? e2 : "") !== i ? [] : (h2 = (r2 = n2.la) === null || r2 === void 0 ? void 0 : r2.call(n2, t2)) !== null && h2 !== void 0 ? h2 : [];
  };
}
__name(Ms, "Ms");
const _xs = class _xs {
  constructor(i, n2, s, e2) {
    this.Li = null, this.wv = null, this.gv = !1, this.Mv = new si(200), this.Gr = null, this.xv = 0, this.Sv = !1, this.kv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.nn = i, this.cn = n2, this.mo = n2.layout, this.kc = s, this.Tv = e2 === "left", this.Pv = Ms("normal", e2), this.Rv = Ms("top", e2), this.Dv = Ms("bottom", e2), this.Ov = document.createElement("div"), this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Ov.style.width = "25px", this.Ov.style.left = "0", this.Ov.style.position = "relative", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const r2 = this.Av.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "1", r2.style.left = "0", r2.style.top = "0", this.Vv = as(this.Ov, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const h2 = this.Vv.canvasElement;
    h2.style.position = "absolute", h2.style.zIndex = "2", h2.style.left = "0", h2.style.top = "0";
    const l2 = { Qf: this.Bv.bind(this), Gf: this.Bv.bind(this), Hf: this.Iv.bind(this), Wf: this.Iv.bind(this), tv: this.zv.bind(this), Yf: this.Ev.bind(this), Uf: this.Ev.bind(this), Tf: this.Lv.bind(this), Sf: this.Lv.bind(this), Bf: this.Nv.bind(this), ov: this.Fv.bind(this) };
    this.Wv = new ds(this.Vv.canvasElement, l2, { Nf: () => !this.cn.handleScroll.vertTouchDrag, Ff: () => !0 });
  }
  S() {
    this.Wv.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), this.Li !== null && this.Li.$o().p(this), this.Li = null;
  }
  jv() {
    return this.Ov;
  }
  P() {
    return this.mo.fontSize;
  }
  Hv() {
    const t2 = this.kc.W();
    return this.Gr !== t2.R && (this.Mv.ir(), this.Gr = t2.R), t2;
  }
  $v() {
    if (this.Li === null)
      return 0;
    let t2 = 0;
    const i = this.Hv(), n2 = b(this.Av.canvasElement.getContext("2d"));
    n2.save();
    const s = this.Li.Ea();
    n2.font = this.Uv(), s.length > 0 && (t2 = Math.max(this.Mv.Si(n2, s[0].Za), this.Mv.Si(n2, s[s.length - 1].Za)));
    const e2 = this.qv();
    for (let i2 = e2.length; i2--; ) {
      const s2 = this.Mv.Si(n2, e2[i2].Jt());
      s2 > t2 && (t2 = s2);
    }
    const r2 = this.Li.Pt();
    if (r2 !== null && this.wv !== null) {
      const i2 = this.Li.pn(1, r2), s2 = this.Li.pn(this.wv.height - 2, r2);
      t2 = Math.max(t2, this.Mv.Si(n2, this.Li.Wi(Math.floor(Math.min(i2, s2)) + 0.11111111111111, r2)), this.Mv.Si(n2, this.Li.Wi(Math.ceil(Math.max(i2, s2)) - 0.11111111111111, r2)));
    }
    n2.restore();
    const h2 = t2 || 34;
    return es(Math.ceil(i.C + i.T + i.B + i.I + 5 + h2));
  }
  Yv(t2) {
    this.wv !== null && equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = !0, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = !1, this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`);
  }
  Xv() {
    return b(this.wv).width;
  }
  Ji(t2) {
    this.Li !== t2 && (this.Li !== null && this.Li.$o().p(this), this.Li = t2, t2.$o().l(this.ao.bind(this), this));
  }
  At() {
    return this.Li;
  }
  ir() {
    const t2 = this.nn.Kv();
    this.nn.yv().qt().A_(t2, b(this.At()));
  }
  Zv(t2) {
    if (this.wv === null)
      return;
    if (t2 !== 1) {
      this.Gv(), this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      t3 !== null && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4), this.Be(t4);
      }), this.nn.Qv(t3, this.Dv), this.tp(t3), this.nn.Qv(t3, this.Pv), this.ip(t3));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.np(i), this.nn.Qv(i, this.Rv));
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  gt() {
    var t2;
    (t2 = this.Li) === null || t2 === void 0 || t2.Ea();
  }
  Bv(t2) {
    if (this.Li === null || this.Li.Fi() || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = !0, i.y_(n2, this.Li, t2.localY);
  }
  Iv(t2) {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv(), s = this.Li;
    i.C_(n2, s, t2.localY);
  }
  zv() {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const t2 = this.nn.yv().qt(), i = this.nn.Kv(), n2 = this.Li;
    this.gv && (this.gv = !1, t2.T_(i, n2));
  }
  Ev(t2) {
    if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = !1, i.T_(n2, this.Li);
  }
  Lv(t2) {
    this.cn.handleScale.axisDoubleClickReset.price && this.ir();
  }
  Nv(t2) {
    this.Li !== null && (!this.nn.yv().qt().W().handleScale.axisPressedMouseMove.price || this.Li.ph() || this.Li.Co() || this.rp(1));
  }
  Fv(t2) {
    this.rp(0);
  }
  qv() {
    const t2 = [], i = this.Li === null ? void 0 : this.Li;
    return ((n2) => {
      for (let s = 0; s < n2.length; ++s) {
        const e2 = n2[s].Rn(this.nn.Kv(), i);
        for (let i2 = 0; i2 < e2.length; i2++)
          t2.push(e2[i2]);
      }
    })(this.nn.Kv().No()), t2;
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e2 = this.nn.Kv().qt(), r2 = e2.q(), h2 = e2.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, r2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2 }) {
    if (this.wv === null || this.Li === null || !this.Li.W().borderVisible)
      return;
    t2.fillStyle = this.Li.W().borderColor;
    const s = Math.max(1, Math.floor(this.Hv().C * n2));
    let e2;
    e2 = this.Tv ? i.width - s : 0, t2.fillRect(e2, 0, s, i.height);
  }
  tp(t2) {
    if (this.wv === null || this.Li === null)
      return;
    const i = this.Li.Ea(), n2 = this.Li.W(), s = this.Hv(), e2 = this.Tv ? this.wv.width - s.T : 0;
    n2.borderVisible && n2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: r2, verticalPixelRatio: h2 }) => {
      t3.fillStyle = n2.borderColor;
      const l2 = Math.max(1, Math.floor(h2)), a2 = Math.floor(0.5 * h2), o2 = Math.round(s.T * r2);
      t3.beginPath();
      for (const n3 of i)
        t3.rect(Math.floor(e2 * r2), Math.round(n3.Aa * h2) - a2, o2, l2);
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      var r2;
      t3.font = this.Uv(), t3.fillStyle = (r2 = n2.textColor) !== null && r2 !== void 0 ? r2 : this.mo.textColor, t3.textAlign = this.Tv ? "right" : "left", t3.textBaseline = "middle";
      const h2 = this.Tv ? Math.round(e2 - s.B) : Math.round(e2 + s.T + s.B), l2 = i.map((i2) => this.Mv.xi(t3, i2.Za));
      for (let n3 = i.length; n3--; ) {
        const s2 = i[n3];
        t3.fillText(s2.Za, h2, s2.Aa + l2[n3]);
      }
    });
  }
  Gv() {
    if (this.wv === null || this.Li === null)
      return;
    let t2 = this.wv.height / 2;
    const i = [], n2 = this.Li.No().slice(), s = this.nn.Kv(), e2 = this.Hv();
    this.Li === s.vr() && this.nn.Kv().No().forEach((t3) => {
      s.dr(t3) && n2.push(t3);
    });
    const r2 = this.Li.Ta()[0], h2 = this.Li;
    n2.forEach((n3) => {
      const e3 = n3.Rn(s, h2);
      e3.forEach((t3) => {
        t3.Vi(null), t3.Bi() && i.push(t3);
      }), r2 === n3 && e3.length > 0 && (t2 = e3[0].yi());
    }), i.forEach((t3) => t3.Vi(t3.yi())), this.Li.W().alignLabels && this.hp(i, e2, t2);
  }
  hp(t2, i, n2) {
    if (this.wv === null)
      return;
    const s = t2.filter((t3) => t3.yi() <= n2), e2 = t2.filter((t3) => t3.yi() > n2);
    s.sort((t3, i2) => i2.yi() - t3.yi()), s.length && e2.length && e2.push(s[0]), e2.sort((t3, i2) => t3.yi() - i2.yi());
    for (const n3 of t2) {
      const t3 = Math.floor(n3.zt(i) / 2), s2 = n3.yi();
      s2 > -t3 && s2 < t3 && n3.Vi(t3), s2 > this.wv.height - t3 && s2 < this.wv.height + t3 && n3.Vi(this.wv.height - t3);
    }
    for (let t3 = 1; t3 < s.length; t3++) {
      const n3 = s[t3], e3 = s[t3 - 1], r2 = e3.zt(i, !1), h2 = n3.yi(), l2 = e3.Ai();
      h2 > l2 - r2 && n3.Vi(l2 - r2);
    }
    for (let t3 = 1; t3 < e2.length; t3++) {
      const n3 = e2[t3], s2 = e2[t3 - 1], r2 = s2.zt(i, !0), h2 = n3.yi(), l2 = s2.Ai();
      h2 < l2 + r2 && n3.Vi(l2 + r2);
    }
  }
  ip(t2) {
    if (this.wv === null)
      return;
    const i = this.qv(), n2 = this.Hv(), s = this.Tv ? "right" : "left";
    i.forEach((i2) => {
      i2.Ii() && i2.xt(b(this.Li)).K(t2, n2, this.Mv, s);
    });
  }
  np(t2) {
    if (this.wv === null || this.Li === null)
      return;
    const i = this.nn.yv().qt(), n2 = [], s = this.nn.Kv(), e2 = i.Fc().Rn(s, this.Li);
    e2.length && n2.push(e2);
    const r2 = this.Hv(), h2 = this.Tv ? "right" : "left";
    n2.forEach((i2) => {
      i2.forEach((i3) => {
        i3.xt(b(this.Li)).K(t2, r2, this.Mv, h2);
      });
    });
  }
  rp(t2) {
    this.Ov.style.cursor = t2 === 1 ? "ns-resize" : "default";
  }
  ao() {
    const t2 = this.$v();
    this.xv < t2 && this.nn.yv().qt().$l(), this.xv = t2;
  }
  Uv() {
    return N$1(this.mo.fontSize, this.mo.fontFamily);
  }
};
__name(_xs, "xs");
let xs = _xs;
function Ss(t2, i) {
  var n2, s;
  return (s = (n2 = t2.ra) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(Ss, "Ss");
function ks(t2, i) {
  var n2, s;
  return (s = (n2 = t2.Pn) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(ks, "ks");
function ys(t2, i) {
  var n2, s;
  return (s = (n2 = t2.Qi) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(ys, "ys");
function Cs(t2, i) {
  var n2, s;
  return (s = (n2 = t2.na) === null || n2 === void 0 ? void 0 : n2.call(t2, i)) !== null && s !== void 0 ? s : [];
}
__name(Cs, "Cs");
const _Ts = class _Ts {
  constructor(i, n2) {
    this.wv = size({ width: 0, height: 0 }), this.lp = null, this.ap = null, this.op = null, this._p = !1, this.up = new R(), this.cp = new R(), this.dp = 0, this.fp = !1, this.vp = null, this.pp = !1, this.mp = null, this.bp = null, this.Sv = !1, this.kv = () => {
      this.Sv || this.wp === null || this.Ui().Fh();
    }, this.Cv = () => {
      this.Sv || this.wp === null || this.Ui().Fh();
    }, this.gp = i, this.wp = n2, this.wp.I_().l(this.Mp.bind(this), this, !0), this.xp = document.createElement("td"), this.xp.style.padding = "0", this.xp.style.position = "relative";
    const s = document.createElement("div");
    s.style.width = "100%", s.style.height = "100%", s.style.position = "relative", s.style.overflow = "hidden", this.Sp = document.createElement("td"), this.Sp.style.padding = "0", this.kp = document.createElement("td"), this.kp.style.padding = "0", this.xp.appendChild(s), this.Av = as(s, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const e2 = this.Av.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "1", e2.style.left = "0", e2.style.top = "0", this.Vv = as(s, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const r2 = this.Vv.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0", this.yp = document.createElement("tr"), this.yp.appendChild(this.Sp), this.yp.appendChild(this.xp), this.yp.appendChild(this.kp), this.Cp(), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => this.vp === null && !this.gp.W().handleScroll.vertTouchDrag, Ff: () => this.vp === null && !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.lp !== null && this.lp.S(), this.ap !== null && this.ap.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), this.wp !== null && this.wp.I_().p(this), this.Wv.S();
  }
  Kv() {
    return b(this.wp);
  }
  Tp(t2) {
    this.wp !== null && this.wp.I_().p(this), this.wp = t2, this.wp !== null && this.wp.I_().l(_Ts.prototype.Mp.bind(this), this, !0), this.Cp();
  }
  yv() {
    return this.gp;
  }
  jv() {
    return this.yp;
  }
  Cp() {
    if (this.wp !== null && (this.Pp(), this.Ui().Mt().length !== 0)) {
      if (this.lp !== null) {
        const t2 = this.wp.S_();
        this.lp.Ji(b(t2));
      }
      if (this.ap !== null) {
        const t2 = this.wp.k_();
        this.ap.Ji(b(t2));
      }
    }
  }
  Rp() {
    this.lp !== null && this.lp.gt(), this.ap !== null && this.ap.gt();
  }
  v_() {
    return this.wp !== null ? this.wp.v_() : 0;
  }
  p_(t2) {
    this.wp && this.wp.p_(t2);
  }
  Bf(t2) {
    if (!this.wp)
      return;
    this.Dp();
    const i = t2.localX, n2 = t2.localY;
    this.Op(i, n2, t2);
  }
  Qf(t2) {
    this.Dp(), this.Ap(), this.Op(t2.localX, t2.localY, t2);
  }
  If(t2) {
    var i;
    if (!this.wp)
      return;
    this.Dp();
    const n2 = t2.localX, s = t2.localY;
    this.Op(n2, s, t2);
    const e2 = this.br(n2, s);
    this.gp.Vp((i = e2 == null ? void 0 : e2.bv) !== null && i !== void 0 ? i : null), this.Ui().Bc(e2 && { Ic: e2.Ic, pv: e2.pv });
  }
  Xf(t2) {
    this.wp !== null && (this.Dp(), this.Bp(t2));
  }
  Tf(t2) {
    this.wp !== null && this.Ip(this.cp, t2);
  }
  Sf(t2) {
    this.Tf(t2);
  }
  Hf(t2) {
    this.Dp(), this.zp(t2), this.Op(t2.localX, t2.localY, t2);
  }
  Yf(t2) {
    this.wp !== null && (this.Dp(), this.fp = !1, this.Ep(t2));
  }
  qf(t2) {
    this.wp !== null && this.Bp(t2);
  }
  _v(t2) {
    if (this.fp = !0, this.vp === null) {
      const i = { x: t2.localX, y: t2.localY };
      this.Lp(i, i, t2);
    }
  }
  ov(t2) {
    this.wp !== null && (this.Dp(), this.wp.qt().Bc(null), this.Np());
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  sv() {
    this.dp = 1, this.Ui().Un();
  }
  ev(t2, i) {
    if (!this.gp.W().handleScale.pinch)
      return;
    const n2 = 5 * (i - this.dp);
    this.dp = i, this.Ui().Uc(t2.et, n2);
  }
  Gf(t2) {
    this.fp = !1, this.pp = this.vp !== null, this.Ap();
    const i = this.Ui().Fc();
    this.vp !== null && i.Tt() && (this.mp = { x: i.Kt(), y: i.Zt() }, this.vp = { x: t2.localX, y: t2.localY });
  }
  Wf(t2) {
    if (this.wp === null)
      return;
    const i = t2.localX, n2 = t2.localY;
    if (this.vp === null)
      this.zp(t2);
    else {
      this.pp = !1;
      const s = b(this.mp), e2 = s.x + (i - this.vp.x), r2 = s.y + (n2 - this.vp.y);
      this.Op(e2, r2, t2);
    }
  }
  Uf(t2) {
    this.yv().W().trackingMode.exitMode === 0 && (this.pp = !0), this.jp(), this.Ep(t2);
  }
  br(t2, i) {
    const n2 = this.wp;
    return n2 === null ? null : function(t3, i2, n3) {
      const s = t3.No(), e2 = function(t4, i3, n4) {
        var s2, e3;
        let r2, h2;
        for (const o2 of t4) {
          const t5 = (e3 = (s2 = o2.oa) === null || s2 === void 0 ? void 0 : s2.call(o2, i3, n4)) !== null && e3 !== void 0 ? e3 : [];
          for (const i4 of t5)
            l2 = i4.zOrder, (!(a2 = r2 == null ? void 0 : r2.zOrder) || l2 === "top" && a2 !== "top" || l2 === "normal" && a2 === "bottom") && (r2 = i4, h2 = o2);
        }
        var l2, a2;
        return r2 && h2 ? { mv: r2, Ic: h2 } : null;
      }(s, i2, n3);
      if ((e2 == null ? void 0 : e2.mv.zOrder) === "top")
        return ws(e2);
      for (const r2 of s) {
        if (e2 && e2.Ic === r2 && e2.mv.zOrder !== "bottom" && !e2.mv.isBackground)
          return ws(e2);
        const s2 = gs(r2.Pn(t3), i2, n3);
        if (s2 !== null)
          return { Ic: r2, fv: s2.fv, pv: s2.pv };
        if (e2 && e2.Ic === r2 && e2.mv.zOrder !== "bottom" && e2.mv.isBackground)
          return ws(e2);
      }
      return e2 != null && e2.mv ? ws(e2) : null;
    }(n2, t2, i);
  }
  Hp(i, n2) {
    b(n2 === "left" ? this.lp : this.ap).Yv(size({ width: i, height: this.wv.height }));
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = !0, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = !1, this.xp.style.width = t2.width + "px", this.xp.style.height = t2.height + "px");
  }
  Up() {
    const t2 = b(this.wp);
    t2.x_(t2.S_()), t2.x_(t2.k_());
    for (const i of t2.Ta())
      if (t2.dr(i)) {
        const n2 = i.At();
        n2 !== null && t2.x_(n2), i.On();
      }
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (t2 === 0 || this.wp === null)
      return;
    if (t2 > 1 && this.Up(), this.lp !== null && this.lp.Zv(t2), this.ap !== null && this.ap.Zv(t2), t2 !== 1) {
      this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      t3 !== null && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4);
      }), this.wp && (this.qp(t3, Ss), this.Yp(t3), this.Xp(t3), this.qp(t3, ks), this.qp(t3, ys)));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Kp(i), this.qp(i, Cs));
  }
  Zp() {
    return this.lp;
  }
  Gp() {
    return this.ap;
  }
  Qv(t2, i) {
    this.qp(t2, i);
  }
  Mp() {
    this.wp !== null && this.wp.I_().p(this), this.wp = null;
  }
  Bp(t2) {
    this.Ip(this.up, t2);
  }
  Ip(t2, i) {
    const n2 = i.localX, s = i.localY;
    t2.M() && t2.m(this.Ui().yt().Vu(n2), { x: n2, y: s }, i);
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e2 = this.Ui(), r2 = e2.q(), h2 = e2.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, h2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Yp(t2) {
    const i = b(this.wp).z_().Wh().xt();
    i !== null && i.K(t2, !1);
  }
  Xp(t2) {
    const i = this.Ui().Nc();
    this.Jp(t2, ks, os, i), this.Jp(t2, ks, _s, i);
  }
  Kp(t2) {
    this.Jp(t2, ks, _s, this.Ui().Fc());
  }
  qp(t2, i) {
    const n2 = b(this.wp).No();
    for (const s of n2)
      this.Jp(t2, i, os, s);
    for (const s of n2)
      this.Jp(t2, i, _s, s);
  }
  Jp(t2, i, n2, s) {
    const e2 = b(this.wp), r2 = e2.qt().Vc(), h2 = r2 !== null && r2.Ic === s, l2 = r2 !== null && h2 && r2.pv !== void 0 ? r2.pv.gr : void 0;
    us(i, (i2) => n2(i2, t2, h2, l2), s, e2);
  }
  Pp() {
    if (this.wp === null)
      return;
    const t2 = this.gp, i = this.wp.S_().W().visible, n2 = this.wp.k_().W().visible;
    i || this.lp === null || (this.Sp.removeChild(this.lp.jv()), this.lp.S(), this.lp = null), n2 || this.ap === null || (this.kp.removeChild(this.ap.jv()), this.ap.S(), this.ap = null);
    const s = t2.qt().sd();
    i && this.lp === null && (this.lp = new xs(this, t2.W(), s, "left"), this.Sp.appendChild(this.lp.jv())), n2 && this.ap === null && (this.ap = new xs(this, t2.W(), s, "right"), this.kp.appendChild(this.ap.jv()));
  }
  Qp(t2) {
    return t2.uv && this.fp || this.vp !== null;
  }
  tm(t2) {
    return Math.max(0, Math.min(t2, this.wv.width - 1));
  }
  im(t2) {
    return Math.max(0, Math.min(t2, this.wv.height - 1));
  }
  Op(t2, i, n2) {
    this.Ui().Jc(this.tm(t2), this.im(i), n2, b(this.wp));
  }
  Np() {
    this.Ui().td();
  }
  jp() {
    this.pp && (this.vp = null, this.Np());
  }
  Lp(t2, i, n2) {
    this.vp = t2, this.pp = !1, this.Op(i.x, i.y, n2);
    const s = this.Ui().Fc();
    this.mp = { x: s.Kt(), y: s.Zt() };
  }
  Ui() {
    return this.gp.qt();
  }
  Ep(t2) {
    if (!this._p)
      return;
    const i = this.Ui(), n2 = this.Kv();
    if (i.D_(n2, n2.vn()), this.op = null, this._p = !1, i.Kc(), this.bp !== null) {
      const t3 = performance.now(), n3 = i.yt();
      this.bp.Dr(n3.Eu(), t3), this.bp.Yu(t3) || i.Xn(this.bp);
    }
  }
  Dp() {
    this.vp = null;
  }
  Ap() {
    if (this.wp) {
      if (this.Ui().Un(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
        b(document.activeElement).blur();
      else {
        const t2 = document.getSelection();
        t2 !== null && t2.removeAllRanges();
      }
      !this.wp.vn().Fi() && this.Ui().yt().Fi();
    }
  }
  zp(t2) {
    if (this.wp === null)
      return;
    const i = this.Ui(), n2 = i.yt();
    if (n2.Fi())
      return;
    const s = this.gp.W(), e2 = s.handleScroll, r2 = s.kineticScroll;
    if ((!e2.pressedMouseMove || t2.uv) && (!e2.horzTouchDrag && !e2.vertTouchDrag || !t2.uv))
      return;
    const h2 = this.wp.vn(), l2 = performance.now();
    if (this.op !== null || this.Qp(t2) || (this.op = { x: t2.clientX, y: t2.clientY, kd: l2, nm: t2.localX, sm: t2.localY }), this.op !== null && !this._p && (this.op.x !== t2.clientX || this.op.y !== t2.clientY)) {
      if (t2.uv && r2.touch || !t2.uv && r2.mouse) {
        const t3 = n2.he();
        this.bp = new ls(0.2 / t3, 7 / t3, 0.997, 15 / t3), this.bp.Nd(n2.Eu(), this.op.kd);
      } else
        this.bp = null;
      h2.Fi() || i.P_(this.wp, h2, t2.localY), i.Yc(t2.localX), this._p = !0;
    }
    this._p && (h2.Fi() || i.R_(this.wp, h2, t2.localY), i.Xc(t2.localX), this.bp !== null && this.bp.Nd(n2.Eu(), l2));
  }
};
__name(_Ts, "Ts");
let Ts = _Ts;
const _Ps = class _Ps {
  constructor(i, n2, s, e2, r2) {
    this.bt = !0, this.wv = size({ width: 0, height: 0 }), this.kv = () => this.Zv(3), this.Tv = i === "left", this.kc = s.sd, this.cn = n2, this.rm = e2, this.hm = r2, this.Ov = document.createElement("div"), this.Ov.style.width = "25px", this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
  }
  S() {
    this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.Ov;
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Av.resizeCanvasElement(t2), this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`, this.bt = !0);
  }
  Zv(t2) {
    if (t2 < 3 && !this.bt || this.wv.width === 0 || this.wv.height === 0)
      return;
    this.bt = !1, this.Av.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Av);
    i !== null && i.useBitmapCoordinateSpace((t3) => {
      this.Jv(t3), this.Be(t3);
    });
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (!this.rm())
      return;
    t2.fillStyle = this.cn.timeScale.borderColor;
    const e2 = Math.floor(this.kc.W().C * n2), r2 = Math.floor(this.kc.W().C * s), h2 = this.Tv ? i.width - e2 : 0;
    t2.fillRect(h2, 0, e2, r2);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.hm());
  }
};
__name(_Ps, "Ps");
let Ps = _Ps;
function Rs(t2) {
  return (i) => {
    var n2, s;
    return (s = (n2 = i.aa) === null || n2 === void 0 ? void 0 : n2.call(i, t2)) !== null && s !== void 0 ? s : [];
  };
}
__name(Rs, "Rs");
const Ds = Rs("normal"), Os = Rs("top"), As = Rs("bottom"), _Vs = class _Vs {
  constructor(i, n2) {
    this.lm = null, this.am = null, this.k = null, this.om = !1, this.wv = size({ width: 0, height: 0 }), this._m = new R(), this.Mv = new si(5), this.Sv = !1, this.kv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.gp = i, this.N_ = n2, this.cn = i.W().layout, this.um = document.createElement("tr"), this.dm = document.createElement("td"), this.dm.style.padding = "0", this.fm = document.createElement("td"), this.fm.style.padding = "0", this.Ov = document.createElement("td"), this.Ov.style.height = "25px", this.Ov.style.padding = "0", this.vm = document.createElement("div"), this.vm.style.width = "100%", this.vm.style.height = "100%", this.vm.style.position = "relative", this.vm.style.overflow = "hidden", this.Ov.appendChild(this.vm), this.Av = as(this.vm, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const s = this.Av.canvasElement;
    s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Vv = as(this.vm, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const e2 = this.Vv.canvasElement;
    e2.style.position = "absolute", e2.style.zIndex = "2", e2.style.left = "0", e2.style.top = "0", this.um.appendChild(this.dm), this.um.appendChild(this.Ov), this.um.appendChild(this.fm), this.pm(), this.gp.qt().f_().l(this.pm.bind(this), this), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => !0, Ff: () => !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.Wv.S(), this.lm !== null && this.lm.S(), this.am !== null && this.am.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.um;
  }
  bm() {
    return this.lm;
  }
  wm() {
    return this.am;
  }
  Qf(t2) {
    if (this.om)
      return;
    this.om = !0;
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.$c(t2.localX);
  }
  Gf(t2) {
    this.Qf(t2);
  }
  tv() {
    const t2 = this.gp.qt();
    !t2.yt().Fi() && this.om && (this.om = !1, this.gp.W().handleScale.axisPressedMouseMove.time && t2.Gc());
  }
  Hf(t2) {
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.Zc(t2.localX);
  }
  Wf(t2) {
    this.Hf(t2);
  }
  Yf() {
    this.om = !1;
    const t2 = this.gp.qt();
    t2.yt().Fi() && !this.gp.W().handleScale.axisPressedMouseMove.time || t2.Gc();
  }
  Uf() {
    this.Yf();
  }
  Tf() {
    this.gp.W().handleScale.axisDoubleClickReset.time && this.gp.qt().Zn();
  }
  Sf() {
    this.Tf();
  }
  Bf() {
    this.gp.qt().W().handleScale.axisPressedMouseMove.time && this.rp(1);
  }
  ov() {
    this.rp(0);
  }
  $p() {
    return this.wv;
  }
  gm() {
    return this._m;
  }
  Mm(i, s, e2) {
    equalSizes(this.wv, i) || (this.wv = i, this.Sv = !0, this.Av.resizeCanvasElement(i), this.Vv.resizeCanvasElement(i), this.Sv = !1, this.Ov.style.width = `${i.width}px`, this.Ov.style.height = `${i.height}px`, this._m.m(i)), this.lm !== null && this.lm.Yv(size({ width: s, height: i.height })), this.am !== null && this.am.Yv(size({ width: e2, height: i.height }));
  }
  xm() {
    const t2 = this.Sm();
    return Math.ceil(t2.C + t2.T + t2.P + t2.L + t2.V + t2.km);
  }
  gt() {
    this.gp.qt().yt().Ea();
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (t2 === 0)
      return;
    if (t2 !== 1) {
      this.Av.applySuggestedBitmapSize();
      const i2 = tryCreateCanvasRenderingTarget2D(this.Av);
      i2 !== null && (i2.useBitmapCoordinateSpace((t3) => {
        this.Jv(t3), this.Be(t3), this.ym(i2, As);
      }), this.tp(i2), this.ym(i2, Ds)), this.lm !== null && this.lm.Zv(t2), this.am !== null && this.am.Zv(t2);
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    i !== null && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Cm([...this.gp.qt().Mt(), this.gp.qt().Fc()], i), this.ym(i, Os));
  }
  ym(t2, i) {
    const n2 = this.gp.qt().Mt();
    for (const s of n2)
      us(i, (i2) => os(i2, t2, !1, void 0), s, void 0);
    for (const s of n2)
      us(i, (i2) => _s(i2, t2, !1, void 0), s, void 0);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.gp.qt().od());
  }
  Be({ context: t2, bitmapSize: i, verticalPixelRatio: n2 }) {
    if (this.gp.W().timeScale.borderVisible) {
      t2.fillStyle = this.Tm();
      const s = Math.max(1, Math.floor(this.Sm().C * n2));
      t2.fillRect(0, 0, i.width, s);
    }
  }
  tp(t2) {
    const i = this.gp.qt().yt(), n2 = i.Ea();
    if (!n2 || n2.length === 0)
      return;
    const s = this.N_.maxTickMarkWeight(n2), e2 = this.Sm(), r2 = i.W();
    r2.borderVisible && r2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) => {
      t3.strokeStyle = this.Tm(), t3.fillStyle = this.Tm();
      const r3 = Math.max(1, Math.floor(i2)), h2 = Math.floor(0.5 * i2);
      t3.beginPath();
      const l2 = Math.round(e2.T * s2);
      for (let s3 = n2.length; s3--; ) {
        const e3 = Math.round(n2[s3].coord * i2);
        t3.rect(e3 - h2, 0, r3, l2);
      }
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const i2 = e2.C + e2.T + e2.L + e2.P / 2;
      t3.textAlign = "center", t3.textBaseline = "middle", t3.fillStyle = this.$(), t3.font = this.Uv();
      for (const e3 of n2)
        if (e3.weight < s) {
          const n3 = e3.needAlignCoordinate ? this.Pm(t3, e3.coord, e3.label) : e3.coord;
          t3.fillText(e3.label, n3, i2);
        }
      t3.font = this.Rm();
      for (const e3 of n2)
        if (e3.weight >= s) {
          const n3 = e3.needAlignCoordinate ? this.Pm(t3, e3.coord, e3.label) : e3.coord;
          t3.fillText(e3.label, n3, i2);
        }
    });
  }
  Pm(t2, i, n2) {
    const s = this.Mv.Si(t2, n2), e2 = s / 2, r2 = Math.floor(i - e2) + 0.5;
    return r2 < 0 ? i += Math.abs(0 - r2) : r2 + s > this.wv.width && (i -= Math.abs(this.wv.width - (r2 + s))), i;
  }
  Cm(t2, i) {
    const n2 = this.Sm();
    for (const s of t2)
      for (const t3 of s.tn())
        t3.xt().K(i, n2);
  }
  Tm() {
    return this.gp.W().timeScale.borderColor;
  }
  $() {
    return this.cn.textColor;
  }
  j() {
    return this.cn.fontSize;
  }
  Uv() {
    return N$1(this.j(), this.cn.fontFamily);
  }
  Rm() {
    return N$1(this.j(), this.cn.fontFamily, "bold");
  }
  Sm() {
    this.k === null && (this.k = { C: 1, N: NaN, L: NaN, V: NaN, Hi: NaN, T: 5, P: NaN, R: "", ji: new si(), km: 0 });
    const t2 = this.k, i = this.Uv();
    if (t2.R !== i) {
      const n2 = this.j();
      t2.P = n2, t2.R = i, t2.L = 3 * n2 / 12, t2.V = 3 * n2 / 12, t2.Hi = 9 * n2 / 12, t2.N = 0, t2.km = 4 * n2 / 12, t2.ji.ir();
    }
    return this.k;
  }
  rp(t2) {
    this.Ov.style.cursor = t2 === 1 ? "ew-resize" : "default";
  }
  pm() {
    const t2 = this.gp.qt(), i = t2.W();
    i.leftPriceScale.visible || this.lm === null || (this.dm.removeChild(this.lm.jv()), this.lm.S(), this.lm = null), i.rightPriceScale.visible || this.am === null || (this.fm.removeChild(this.am.jv()), this.am.S(), this.am = null);
    const n2 = { sd: this.gp.qt().sd() }, s = /* @__PURE__ */ __name(() => i.leftPriceScale.borderVisible && t2.yt().W().borderVisible, "s"), e2 = /* @__PURE__ */ __name(() => t2.od(), "e");
    i.leftPriceScale.visible && this.lm === null && (this.lm = new Ps("left", i, n2, s, e2), this.dm.appendChild(this.lm.jv())), i.rightPriceScale.visible && this.am === null && (this.am = new Ps("right", i, n2, s, e2), this.fm.appendChild(this.am.jv()));
  }
};
__name(_Vs, "Vs");
let Vs = _Vs;
const Bs = !!is && !!navigator.userAgentData && navigator.userAgentData.brands.some((t2) => t2.brand.includes("Chromium")) && !!is && (!((Is = navigator == null ? void 0 : navigator.userAgentData) === null || Is === void 0) && Is.platform ? navigator.userAgentData.platform === "Windows" : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
var Is;
const _zs = class _zs {
  constructor(t2, i, n2) {
    var s;
    this.Dm = [], this.Om = 0, this.Qa = 0, this.e_ = 0, this.Am = 0, this.Vm = 0, this.Bm = null, this.Im = !1, this.up = new R(), this.cp = new R(), this.Mc = new R(), this.zm = null, this.Em = null, this.Lm = t2, this.cn = i, this.N_ = n2, this.um = document.createElement("div"), this.um.classList.add("tv-lightweight-charts"), this.um.style.overflow = "hidden", this.um.style.direction = "ltr", this.um.style.width = "100%", this.um.style.height = "100%", (s = this.um).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.Nm = document.createElement("table"), this.Nm.setAttribute("cellspacing", "0"), this.um.appendChild(this.Nm), this.Fm = this.Wm.bind(this), Es(this.cn) && this.jm(!0), this.Ui = new zn(this.Sc.bind(this), this.cn, n2), this.qt().Wc().l(this.Hm.bind(this), this), this.$m = new Vs(this, this.N_), this.Nm.appendChild(this.$m.jv());
    const e2 = i.autoSize && this.Um();
    let r2 = this.cn.width, h2 = this.cn.height;
    if (e2 || r2 === 0 || h2 === 0) {
      const i2 = t2.getBoundingClientRect();
      r2 = r2 || i2.width, h2 = h2 || i2.height;
    }
    this.qm(r2, h2), this.Ym(), t2.appendChild(this.um), this.Xm(), this.Ui.yt().Gu().l(this.Ui.$l.bind(this.Ui), this), this.Ui.f_().l(this.Ui.$l.bind(this.Ui), this);
  }
  qt() {
    return this.Ui;
  }
  W() {
    return this.cn;
  }
  Km() {
    return this.Dm;
  }
  Zm() {
    return this.$m;
  }
  S() {
    this.jm(!1), this.Om !== 0 && window.cancelAnimationFrame(this.Om), this.Ui.Wc().p(this), this.Ui.yt().Gu().p(this), this.Ui.f_().p(this), this.Ui.S();
    for (const t2 of this.Dm)
      this.Nm.removeChild(t2.jv()), t2.Fp().p(this), t2.Wp().p(this), t2.S();
    this.Dm = [], b(this.$m).S(), this.um.parentElement !== null && this.um.parentElement.removeChild(this.um), this.Mc.S(), this.up.S(), this.cp.S(), this.Gm();
  }
  qm(i, n2, s = !1) {
    if (this.Qa === n2 && this.e_ === i)
      return;
    const e2 = function(i2) {
      const n3 = Math.floor(i2.width), s2 = Math.floor(i2.height);
      return size({ width: n3 - n3 % 2, height: s2 - s2 % 2 });
    }(size({ width: i, height: n2 }));
    this.Qa = e2.height, this.e_ = e2.width;
    const r2 = this.Qa + "px", h2 = this.e_ + "px";
    b(this.um).style.height = r2, b(this.um).style.width = h2, this.Nm.style.height = r2, this.Nm.style.width = h2, s ? this.Jm(ct.es(), performance.now()) : this.Ui.$l();
  }
  Zv(t2) {
    t2 === void 0 && (t2 = ct.es());
    for (let i = 0; i < this.Dm.length; i++)
      this.Dm[i].Zv(t2.Hn(i).Fn);
    this.cn.timeScale.visible && this.$m.Zv(t2.jn());
  }
  Nh(t2) {
    const i = Es(this.cn);
    this.Ui.Nh(t2);
    const n2 = Es(this.cn);
    n2 !== i && this.jm(n2), this.Xm(), this.Qm(t2);
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  Wc() {
    return this.Mc;
  }
  tb() {
    this.Bm !== null && (this.Jm(this.Bm, performance.now()), this.Bm = null);
    const t2 = this.ib(null), i = document.createElement("canvas");
    i.width = t2.width, i.height = t2.height;
    const n2 = b(i.getContext("2d"));
    return this.ib(n2), i;
  }
  nb(t2) {
    return t2 === "left" && !this.sb() || t2 === "right" && !this.eb() || this.Dm.length === 0 ? 0 : b(t2 === "left" ? this.Dm[0].Zp() : this.Dm[0].Gp()).Xv();
  }
  rb() {
    return this.cn.autoSize && this.zm !== null;
  }
  hb() {
    return this.um;
  }
  Vp(t2) {
    this.Em = t2, this.Em ? this.hb().style.setProperty("cursor", t2) : this.hb().style.removeProperty("cursor");
  }
  lb() {
    return this.Em;
  }
  ab() {
    return m$1(this.Dm[0]).$p();
  }
  Qm(t2) {
    (t2.autoSize !== void 0 || !this.zm || t2.width === void 0 && t2.height === void 0) && (t2.autoSize && !this.zm && this.Um(), t2.autoSize === !1 && this.zm !== null && this.Gm(), t2.autoSize || t2.width === void 0 && t2.height === void 0 || this.qm(t2.width || this.e_, t2.height || this.Qa));
  }
  ib(i) {
    let n2 = 0, s = 0;
    const e2 = this.Dm[0], r2 = /* @__PURE__ */ __name((t2, n3) => {
      let s2 = 0;
      for (let e3 = 0; e3 < this.Dm.length; e3++) {
        const r3 = this.Dm[e3], h3 = b(t2 === "left" ? r3.Zp() : r3.Gp()), l2 = h3.sp();
        i !== null && h3.ep(i, n3, s2), s2 += l2.height;
      }
    }, "r");
    this.sb() && (r2("left", 0), n2 += b(e2.Zp()).sp().width);
    for (let t2 = 0; t2 < this.Dm.length; t2++) {
      const e3 = this.Dm[t2], r3 = e3.sp();
      i !== null && e3.ep(i, n2, s), s += r3.height;
    }
    n2 += e2.sp().width, this.eb() && (r2("right", n2), n2 += b(e2.Gp()).sp().width);
    const h2 = /* @__PURE__ */ __name((t2, n3, s2) => {
      b(t2 === "left" ? this.$m.bm() : this.$m.wm()).ep(b(i), n3, s2);
    }, "h");
    if (this.cn.timeScale.visible) {
      const t2 = this.$m.sp();
      if (i !== null) {
        let n3 = 0;
        this.sb() && (h2("left", n3, s), n3 = b(e2.Zp()).sp().width), this.$m.ep(i, n3, s), n3 += t2.width, this.eb() && h2("right", n3, s);
      }
      s += t2.height;
    }
    return size({ width: n2, height: s });
  }
  ob() {
    let i = 0, n2 = 0, s = 0;
    for (const t2 of this.Dm)
      this.sb() && (n2 = Math.max(n2, b(t2.Zp()).$v(), this.cn.leftPriceScale.minimumWidth)), this.eb() && (s = Math.max(s, b(t2.Gp()).$v(), this.cn.rightPriceScale.minimumWidth)), i += t2.v_();
    n2 = es(n2), s = es(s);
    const e2 = this.e_, r2 = this.Qa, h2 = Math.max(e2 - n2 - s, 0), l2 = this.cn.timeScale.visible;
    let a2 = l2 ? Math.max(this.$m.xm(), this.cn.timeScale.minimumHeight) : 0;
    var o2;
    a2 = (o2 = a2) + o2 % 2;
    const _24 = 0 + a2, u2 = r2 < _24 ? 0 : r2 - _24, c2 = u2 / i;
    let d2 = 0;
    for (let i2 = 0; i2 < this.Dm.length; ++i2) {
      const e3 = this.Dm[i2];
      e3.Tp(this.Ui.Lc()[i2]);
      let r3 = 0, l3 = 0;
      l3 = i2 === this.Dm.length - 1 ? u2 - d2 : Math.round(e3.v_() * c2), r3 = Math.max(l3, 2), d2 += r3, e3.Yv(size({ width: h2, height: r3 })), this.sb() && e3.Hp(n2, "left"), this.eb() && e3.Hp(s, "right"), e3.Kv() && this.Ui.jc(e3.Kv(), r3);
    }
    this.$m.Mm(size({ width: l2 ? h2 : 0, height: a2 }), l2 ? n2 : 0, l2 ? s : 0), this.Ui.m_(h2), this.Am !== n2 && (this.Am = n2), this.Vm !== s && (this.Vm = s);
  }
  jm(t2) {
    t2 ? this.um.addEventListener("wheel", this.Fm, { passive: !1 }) : this.um.removeEventListener("wheel", this.Fm);
  }
  _b(t2) {
    switch (t2.deltaMode) {
      case t2.DOM_DELTA_PAGE:
        return 120;
      case t2.DOM_DELTA_LINE:
        return 32;
    }
    return Bs ? 1 / window.devicePixelRatio : 1;
  }
  Wm(t2) {
    if (!(t2.deltaX !== 0 && this.cn.handleScroll.mouseWheel || t2.deltaY !== 0 && this.cn.handleScale.mouseWheel))
      return;
    const i = this._b(t2), n2 = i * t2.deltaX / 100, s = -i * t2.deltaY / 100;
    if (t2.cancelable && t2.preventDefault(), s !== 0 && this.cn.handleScale.mouseWheel) {
      const i2 = Math.sign(s) * Math.min(1, Math.abs(s)), n3 = t2.clientX - this.um.getBoundingClientRect().left;
      this.qt().Uc(n3, i2);
    }
    n2 !== 0 && this.cn.handleScroll.mouseWheel && this.qt().qc(-80 * n2);
  }
  Jm(t2, i) {
    var n2;
    const s = t2.jn();
    s === 3 && this.ub(), s !== 3 && s !== 2 || (this.cb(t2), this.fb(t2, i), this.$m.gt(), this.Dm.forEach((t3) => {
      t3.Rp();
    }), ((n2 = this.Bm) === null || n2 === void 0 ? void 0 : n2.jn()) === 3 && (this.Bm.ts(t2), this.ub(), this.cb(this.Bm), this.fb(this.Bm, i), t2 = this.Bm, this.Bm = null)), this.Zv(t2);
  }
  fb(t2, i) {
    for (const n2 of t2.Qn())
      this.ns(n2, i);
  }
  cb(t2) {
    const i = this.Ui.Lc();
    for (let n2 = 0; n2 < i.length; n2++)
      t2.Hn(n2).Wn && i[n2].V_();
  }
  ns(t2, i) {
    const n2 = this.Ui.yt();
    switch (t2.qn) {
      case 0:
        n2.Qu();
        break;
      case 1:
        n2.tc(t2.Vt);
        break;
      case 2:
        n2.Gn(t2.Vt);
        break;
      case 3:
        n2.Jn(t2.Vt);
        break;
      case 4:
        n2.Fu();
        break;
      case 5:
        t2.Vt.Yu(i) || n2.Jn(t2.Vt.Xu(i));
    }
  }
  Sc(t2) {
    this.Bm !== null ? this.Bm.ts(t2) : this.Bm = t2, this.Im || (this.Im = !0, this.Om = window.requestAnimationFrame((t3) => {
      if (this.Im = !1, this.Om = 0, this.Bm !== null) {
        const i = this.Bm;
        this.Bm = null, this.Jm(i, t3);
        for (const n2 of i.Qn())
          if (n2.qn === 5 && !n2.Vt.Yu(t3)) {
            this.qt().Xn(n2.Vt);
            break;
          }
      }
    }));
  }
  ub() {
    this.Ym();
  }
  Ym() {
    const t2 = this.Ui.Lc(), i = t2.length, n2 = this.Dm.length;
    for (let t3 = i; t3 < n2; t3++) {
      const t4 = m$1(this.Dm.pop());
      this.Nm.removeChild(t4.jv()), t4.Fp().p(this), t4.Wp().p(this), t4.S();
    }
    for (let s = n2; s < i; s++) {
      const i2 = new Ts(this, t2[s]);
      i2.Fp().l(this.vb.bind(this), this), i2.Wp().l(this.pb.bind(this), this), this.Dm.push(i2), this.Nm.insertBefore(i2.jv(), this.$m.jv());
    }
    for (let n3 = 0; n3 < i; n3++) {
      const i2 = t2[n3], s = this.Dm[n3];
      s.Kv() !== i2 ? s.Tp(i2) : s.Cp();
    }
    this.Xm(), this.ob();
  }
  mb(t2, i, n2) {
    var s;
    const e2 = /* @__PURE__ */ new Map();
    t2 !== null && this.Ui.Mt().forEach((i2) => {
      const n3 = i2.In().nl(t2);
      n3 !== null && e2.set(i2, n3);
    });
    let r2;
    if (t2 !== null) {
      const i2 = (s = this.Ui.yt().qi(t2)) === null || s === void 0 ? void 0 : s.originalTime;
      i2 !== void 0 && (r2 = i2);
    }
    const h2 = this.qt().Vc(), l2 = h2 !== null && h2.Ic instanceof Gi ? h2.Ic : void 0, a2 = h2 !== null && h2.pv !== void 0 ? h2.pv.wr : void 0;
    return { bb: r2, se: t2 ?? void 0, wb: i ?? void 0, gb: l2, Mb: e2, xb: a2, Sb: n2 ?? void 0 };
  }
  vb(t2, i, n2) {
    this.up.m(() => this.mb(t2, i, n2));
  }
  pb(t2, i, n2) {
    this.cp.m(() => this.mb(t2, i, n2));
  }
  Hm(t2, i, n2) {
    this.Mc.m(() => this.mb(t2, i, n2));
  }
  Xm() {
    const t2 = this.cn.timeScale.visible ? "" : "none";
    this.$m.jv().style.display = t2;
  }
  sb() {
    return this.Dm[0].Kv().S_().W().visible;
  }
  eb() {
    return this.Dm[0].Kv().k_().W().visible;
  }
  Um() {
    return "ResizeObserver" in window && (this.zm = new ResizeObserver((t2) => {
      const i = t2.find((t3) => t3.target === this.Lm);
      i && this.qm(i.contentRect.width, i.contentRect.height);
    }), this.zm.observe(this.Lm, { box: "border-box" }), !0);
  }
  Gm() {
    this.zm !== null && this.zm.disconnect(), this.zm = null;
  }
};
__name(_zs, "zs");
let zs = _zs;
function Es(t2) {
  return !!(t2.handleScroll.mouseWheel || t2.handleScale.mouseWheel);
}
__name(Es, "Es");
function Ls(t2, i) {
  var n2 = {};
  for (var s in t2)
    Object.prototype.hasOwnProperty.call(t2, s) && i.indexOf(s) < 0 && (n2[s] = t2[s]);
  if (t2 != null && typeof Object.getOwnPropertySymbols == "function") {
    var e2 = 0;
    for (s = Object.getOwnPropertySymbols(t2); e2 < s.length; e2++)
      i.indexOf(s[e2]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, s[e2]) && (n2[s[e2]] = t2[s[e2]]);
  }
  return n2;
}
__name(Ls, "Ls");
function Ns(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.color !== void 0 && (r2.O = n2.color), r2;
}
__name(Ns, "Ns");
function Fs(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.lineColor !== void 0 && (r2._t = n2.lineColor), n2.topColor !== void 0 && (r2.Ts = n2.topColor), n2.bottomColor !== void 0 && (r2.Ps = n2.bottomColor), r2;
}
__name(Fs, "Fs");
function Ws(t2, i, n2, s) {
  const e2 = n2.value, r2 = { se: i, ut: t2, Vt: [e2, e2, e2, e2], bb: s };
  return n2.topLineColor !== void 0 && (r2.Pe = n2.topLineColor), n2.bottomLineColor !== void 0 && (r2.Re = n2.bottomLineColor), n2.topFillColor1 !== void 0 && (r2.Se = n2.topFillColor1), n2.topFillColor2 !== void 0 && (r2.ke = n2.topFillColor2), n2.bottomFillColor1 !== void 0 && (r2.ye = n2.bottomFillColor1), n2.bottomFillColor2 !== void 0 && (r2.Ce = n2.bottomFillColor2), r2;
}
__name(Ws, "Ws");
function js(t2, i, n2, s) {
  const e2 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return n2.color !== void 0 && (e2.O = n2.color), e2;
}
__name(js, "js");
function Hs(t2, i, n2, s) {
  const e2 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return n2.color !== void 0 && (e2.O = n2.color), n2.borderColor !== void 0 && (e2.Bt = n2.borderColor), n2.wickColor !== void 0 && (e2.$h = n2.wickColor), e2;
}
__name(Hs, "Hs");
function $s(t2, i, n2, s, e2) {
  const r2 = m$1(e2)(n2), h2 = Math.max(...r2), l2 = Math.min(...r2), a2 = r2[r2.length - 1], o2 = [a2, h2, l2, a2], _24 = n2, { time: u2, color: c2 } = _24;
  return { se: i, ut: t2, Vt: o2, bb: s, He: Ls(_24, ["time", "color"]), O: c2 };
}
__name($s, "$s");
function Us(t2) {
  return t2.Vt !== void 0;
}
__name(Us, "Us");
function qs(t2, i) {
  return i.customValues !== void 0 && (t2.kb = i.customValues), t2;
}
__name(qs, "qs");
function Ys(t2) {
  return (i, n2, s, e2, r2, h2) => function(t3, i2) {
    return i2 ? i2(t3) : (n3 = t3).open === void 0 && n3.value === void 0;
    var n3;
  }(s, h2) ? qs({ ut: i, se: n2, bb: e2 }, s) : qs(t2(i, n2, s, e2, r2), s);
}
__name(Ys, "Ys");
function Xs(t2) {
  return { Candlestick: Ys(Hs), Bar: Ys(js), Area: Ys(Fs), Baseline: Ys(Ws), Histogram: Ys(Ns), Line: Ys(Ns), Custom: Ys($s) }[t2];
}
__name(Xs, "Xs");
function Ks(t2) {
  return { se: 0, yb: /* @__PURE__ */ new Map(), ia: t2 };
}
__name(Ks, "Ks");
function Zs(t2, i) {
  if (t2 !== void 0 && t2.length !== 0)
    return { Cb: i.key(t2[0].ut), Tb: i.key(t2[t2.length - 1].ut) };
}
__name(Zs, "Zs");
function Gs(t2) {
  let i;
  return t2.forEach((t3) => {
    i === void 0 && (i = t3.bb);
  }), m$1(i);
}
__name(Gs, "Gs");
const _Js = class _Js {
  constructor(t2) {
    this.Pb = /* @__PURE__ */ new Map(), this.Rb = /* @__PURE__ */ new Map(), this.Db = /* @__PURE__ */ new Map(), this.Ob = [], this.N_ = t2;
  }
  S() {
    this.Pb.clear(), this.Rb.clear(), this.Db.clear(), this.Ob = [];
  }
  Ab(t2, i) {
    let n2 = this.Pb.size !== 0, s = !1;
    const e2 = this.Rb.get(t2);
    if (e2 !== void 0)
      if (this.Rb.size === 1)
        n2 = !1, s = !0, this.Pb.clear();
      else
        for (const i2 of this.Ob)
          i2.pointData.yb.delete(t2) && (s = !0);
    let r2 = [];
    if (i.length !== 0) {
      const n3 = i.map((t3) => t3.time), e3 = this.N_.createConverterToInternalObj(i), h3 = Xs(t2.Xh()), l2 = t2.ga(), a2 = t2.Ma();
      r2 = i.map((i2, r3) => {
        const o2 = e3(i2.time), _24 = this.N_.key(o2);
        let u2 = this.Pb.get(_24);
        u2 === void 0 && (u2 = Ks(o2), this.Pb.set(_24, u2), s = !0);
        const c2 = h3(o2, u2.se, i2, n3[r3], l2, a2);
        return u2.yb.set(t2, c2), c2;
      });
    }
    n2 && this.Vb(), this.Bb(t2, r2);
    let h2 = -1;
    if (s) {
      const t3 = [];
      this.Pb.forEach((i2) => {
        t3.push({ timeWeight: 0, time: i2.ia, pointData: i2, originalTime: Gs(i2.yb) });
      }), t3.sort((t4, i2) => this.N_.key(t4.time) - this.N_.key(i2.time)), h2 = this.Ib(t3);
    }
    return this.zb(t2, h2, function(t3, i2, n3) {
      const s2 = Zs(t3, n3), e3 = Zs(i2, n3);
      if (s2 !== void 0 && e3 !== void 0)
        return { Xl: s2.Tb >= e3.Tb && s2.Cb >= e3.Cb };
    }(this.Rb.get(t2), e2, this.N_));
  }
  hd(t2) {
    return this.Ab(t2, []);
  }
  Eb(t2, i) {
    const n2 = i;
    (function(t3) {
      t3.bb === void 0 && (t3.bb = t3.time);
    })(n2), this.N_.preprocessData(i);
    const s = this.N_.createConverterToInternalObj([i])(i.time), e2 = this.Db.get(t2);
    if (e2 !== void 0 && this.N_.key(s) < this.N_.key(e2))
      throw new Error(`Cannot update oldest data, last time=${e2}, new time=${s}`);
    let r2 = this.Pb.get(this.N_.key(s));
    const h2 = r2 === void 0;
    r2 === void 0 && (r2 = Ks(s), this.Pb.set(this.N_.key(s), r2));
    const l2 = Xs(t2.Xh()), a2 = t2.ga(), o2 = t2.Ma(), _24 = l2(s, r2.se, i, n2.bb, a2, o2);
    r2.yb.set(t2, _24), this.Lb(t2, _24);
    const u2 = { Xl: Us(_24) };
    if (!h2)
      return this.zb(t2, -1, u2);
    const c2 = { timeWeight: 0, time: r2.ia, pointData: r2, originalTime: Gs(r2.yb) }, d2 = Bt$1(this.Ob, this.N_.key(c2.time), (t3, i2) => this.N_.key(t3.time) < i2);
    this.Ob.splice(d2, 0, c2);
    for (let t3 = d2; t3 < this.Ob.length; ++t3)
      Qs(this.Ob[t3].pointData, t3);
    return this.N_.fillWeightsForPoints(this.Ob, d2), this.zb(t2, d2, u2);
  }
  Lb(t2, i) {
    let n2 = this.Rb.get(t2);
    n2 === void 0 && (n2 = [], this.Rb.set(t2, n2));
    const s = n2.length !== 0 ? n2[n2.length - 1] : null;
    s === null || this.N_.key(i.ut) > this.N_.key(s.ut) ? Us(i) && n2.push(i) : Us(i) ? n2[n2.length - 1] = i : n2.splice(-1, 1), this.Db.set(t2, i.ut);
  }
  Bb(t2, i) {
    i.length !== 0 ? (this.Rb.set(t2, i.filter(Us)), this.Db.set(t2, i[i.length - 1].ut)) : (this.Rb.delete(t2), this.Db.delete(t2));
  }
  Vb() {
    for (const t2 of this.Ob)
      t2.pointData.yb.size === 0 && this.Pb.delete(this.N_.key(t2.time));
  }
  Ib(t2) {
    let i = -1;
    for (let n2 = 0; n2 < this.Ob.length && n2 < t2.length; ++n2) {
      const s = this.Ob[n2], e2 = t2[n2];
      if (this.N_.key(s.time) !== this.N_.key(e2.time)) {
        i = n2;
        break;
      }
      e2.timeWeight = s.timeWeight, Qs(e2.pointData, n2);
    }
    if (i === -1 && this.Ob.length !== t2.length && (i = Math.min(this.Ob.length, t2.length)), i === -1)
      return -1;
    for (let n2 = i; n2 < t2.length; ++n2)
      Qs(t2[n2].pointData, n2);
    return this.N_.fillWeightsForPoints(t2, i), this.Ob = t2, i;
  }
  Nb() {
    if (this.Rb.size === 0)
      return null;
    let t2 = 0;
    return this.Rb.forEach((i) => {
      i.length !== 0 && (t2 = Math.max(t2, i[i.length - 1].se));
    }), t2;
  }
  zb(t2, i, n2) {
    const s = { Fb: /* @__PURE__ */ new Map(), yt: { Au: this.Nb() } };
    if (i !== -1)
      this.Rb.forEach((i2, e2) => {
        s.Fb.set(e2, { He: i2, Wb: e2 === t2 ? n2 : void 0 });
      }), this.Rb.has(t2) || s.Fb.set(t2, { He: [], Wb: n2 }), s.yt.jb = this.Ob, s.yt.Hb = i;
    else {
      const i2 = this.Rb.get(t2);
      s.Fb.set(t2, { He: i2 || [], Wb: n2 });
    }
    return s;
  }
};
__name(_Js, "Js");
let Js = _Js;
function Qs(t2, i) {
  t2.se = i, t2.yb.forEach((t3) => {
    t3.se = i;
  });
}
__name(Qs, "Qs");
function te$1(t2) {
  const i = { value: t2.Vt[3], time: t2.bb };
  return t2.kb !== void 0 && (i.customValues = t2.kb), i;
}
__name(te$1, "te$1");
function ie$1(t2) {
  const i = te$1(t2);
  return t2.O !== void 0 && (i.color = t2.O), i;
}
__name(ie$1, "ie$1");
function ne(t2) {
  const i = te$1(t2);
  return t2._t !== void 0 && (i.lineColor = t2._t), t2.Ts !== void 0 && (i.topColor = t2.Ts), t2.Ps !== void 0 && (i.bottomColor = t2.Ps), i;
}
__name(ne, "ne");
function se$1(t2) {
  const i = te$1(t2);
  return t2.Pe !== void 0 && (i.topLineColor = t2.Pe), t2.Re !== void 0 && (i.bottomLineColor = t2.Re), t2.Se !== void 0 && (i.topFillColor1 = t2.Se), t2.ke !== void 0 && (i.topFillColor2 = t2.ke), t2.ye !== void 0 && (i.bottomFillColor1 = t2.ye), t2.Ce !== void 0 && (i.bottomFillColor2 = t2.Ce), i;
}
__name(se$1, "se$1");
function ee$1(t2) {
  const i = { open: t2.Vt[0], high: t2.Vt[1], low: t2.Vt[2], close: t2.Vt[3], time: t2.bb };
  return t2.kb !== void 0 && (i.customValues = t2.kb), i;
}
__name(ee$1, "ee$1");
function re$1(t2) {
  const i = ee$1(t2);
  return t2.O !== void 0 && (i.color = t2.O), i;
}
__name(re$1, "re$1");
function he(t2) {
  const i = ee$1(t2), { O: n2, Bt: s, $h: e2 } = t2;
  return n2 !== void 0 && (i.color = n2), s !== void 0 && (i.borderColor = s), e2 !== void 0 && (i.wickColor = e2), i;
}
__name(he, "he");
function le(t2) {
  return { Area: ne, Line: ie$1, Baseline: se$1, Histogram: ie$1, Bar: re$1, Candlestick: he, Custom: ae$1 }[t2];
}
__name(le, "le");
function ae$1(t2) {
  const i = t2.bb;
  return Object.assign(Object.assign({}, t2.He), { time: i });
}
__name(ae$1, "ae$1");
const oe$1 = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: !0, labelVisible: !0, labelBackgroundColor: "#131722" }, mode: 1 }, _e$1 = { vertLines: { color: "#D6DCDE", style: 0, visible: !0 }, horzLines: { color: "#D6DCDE", style: 0, visible: !0 } }, ue = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: L$1 }, ce$1 = { autoScale: !0, mode: 0, invertScale: !1, alignLabels: !0, borderVisible: !0, borderColor: "#2B2B43", entireTextOnly: !1, visible: !1, ticksVisible: !1, scaleMargins: { bottom: 0.1, top: 0.2 }, minimumWidth: 0 }, de = { rightOffset: 0, barSpacing: 6, minBarSpacing: 0.5, fixLeftEdge: !1, fixRightEdge: !1, lockVisibleTimeRangeOnResize: !1, rightBarStaysOnScroll: !1, borderVisible: !0, borderColor: "#2B2B43", visible: !0, timeVisible: !1, secondsVisible: !0, shiftVisibleRangeOnNewBar: !0, allowShiftVisibleRangeOnWhitespaceReplacement: !1, ticksVisible: !1, uniformDistribution: !1, minimumHeight: 0 }, fe = { color: "rgba(0, 0, 0, 0)", visible: !1, fontSize: 48, fontFamily: L$1, fontStyle: "", text: "", horzAlign: "center", vertAlign: "center" };
function ve() {
  return { width: 0, height: 0, autoSize: !1, layout: ue, crosshair: oe$1, grid: _e$1, overlayPriceScales: Object.assign({}, ce$1), leftPriceScale: Object.assign(Object.assign({}, ce$1), { visible: !1 }), rightPriceScale: Object.assign(Object.assign({}, ce$1), { visible: !0 }), timeScale: de, watermark: fe, localization: { locale: is ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: !0, pressedMouseMove: !0, horzTouchDrag: !0, vertTouchDrag: !0 }, handleScale: { axisPressedMouseMove: { time: !0, price: !0 }, axisDoubleClickReset: { time: !0, price: !0 }, mouseWheel: !0, pinch: !0 }, kineticScroll: { mouse: !1, touch: !0 }, trackingMode: { exitMode: 1 } };
}
__name(ve, "ve");
const _pe = class _pe {
  constructor(t2, i) {
    this.$b = t2, this.Ub = i;
  }
  applyOptions(t2) {
    this.$b.qt().zc(this.Ub, t2);
  }
  options() {
    return this.Li().W();
  }
  width() {
    return ut$1(this.Ub) ? this.$b.nb(this.Ub) : 0;
  }
  Li() {
    return b(this.$b.qt().Ec(this.Ub)).At;
  }
};
__name(_pe, "pe");
let pe = _pe;
function me(t2, i, n2) {
  const s = Ls(t2, ["time", "originalTime"]), e2 = Object.assign({ time: i }, s);
  return n2 !== void 0 && (e2.originalTime = n2), e2;
}
__name(me, "me");
const be = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: !0, axisLabelVisible: !0, title: "", axisLabelColor: "", axisLabelTextColor: "" }, _we = class _we {
  constructor(t2) {
    this.Bh = t2;
  }
  applyOptions(t2) {
    this.Bh.Nh(t2);
  }
  options() {
    return this.Bh.W();
  }
  qb() {
    return this.Bh;
  }
};
__name(_we, "we");
let we = _we;
const _ge = class _ge {
  constructor(t2, i, n2, s, e2) {
    this.Yb = new R(), this.Es = t2, this.Xb = i, this.Kb = n2, this.N_ = e2, this.Zb = s;
  }
  S() {
    this.Yb.S();
  }
  priceFormatter() {
    return this.Es.ca();
  }
  priceToCoordinate(t2) {
    const i = this.Es.Pt();
    return i === null ? null : this.Es.At().Ot(t2, i.Vt);
  }
  coordinateToPrice(t2) {
    const i = this.Es.Pt();
    return i === null ? null : this.Es.At().pn(t2, i.Vt);
  }
  barsInLogicalRange(t2) {
    if (t2 === null)
      return null;
    const i = new yn$1(new xn$1(t2.from, t2.to)).iu(), n2 = this.Es.In();
    if (n2.Fi())
      return null;
    const s = n2.nl(i.Os(), 1), e2 = n2.nl(i.di(), -1), r2 = b(n2.Qh()), h2 = b(n2.Bn());
    if (s !== null && e2 !== null && s.se > e2.se)
      return { barsBefore: t2.from - r2, barsAfter: h2 - t2.to };
    const l2 = { barsBefore: s === null || s.se === r2 ? t2.from - r2 : s.se - r2, barsAfter: e2 === null || e2.se === h2 ? h2 - t2.to : h2 - e2.se };
    return s !== null && e2 !== null && (l2.from = s.bb, l2.to = e2.bb), l2;
  }
  setData(t2) {
    this.N_, this.Es.Xh(), this.Xb.Gb(this.Es, t2), this.Jb("full");
  }
  update(t2) {
    this.Es.Xh(), this.Xb.Qb(this.Es, t2), this.Jb("update");
  }
  dataByIndex(t2, i) {
    const n2 = this.Es.In().nl(t2, i);
    return n2 === null ? null : le(this.seriesType())(n2);
  }
  data() {
    const t2 = le(this.seriesType());
    return this.Es.In().ie().map((i) => t2(i));
  }
  subscribeDataChanged(t2) {
    this.Yb.l(t2);
  }
  unsubscribeDataChanged(t2) {
    this.Yb.v(t2);
  }
  setMarkers(t2) {
    this.N_;
    const i = t2.map((t3) => me(t3, this.N_.convertHorzItemToInternal(t3.time), t3.time));
    this.Es.Zl(i);
  }
  markers() {
    return this.Es.Gl().map((t2) => me(t2, t2.originalTime, void 0));
  }
  applyOptions(t2) {
    this.Es.Nh(t2);
  }
  options() {
    return I(this.Es.W());
  }
  priceScale() {
    return this.Kb.priceScale(this.Es.At().xa());
  }
  createPriceLine(t2) {
    const i = D$1(I(be), t2), n2 = this.Es.Jl(i);
    return new we(n2);
  }
  removePriceLine(t2) {
    this.Es.Ql(t2.qb());
  }
  seriesType() {
    return this.Es.Xh();
  }
  attachPrimitive(t2) {
    this.Es.ba(t2), t2.attached && t2.attached({ chart: this.Zb, series: this, requestUpdate: () => this.Es.qt().$l() });
  }
  detachPrimitive(t2) {
    this.Es.wa(t2), t2.detached && t2.detached();
  }
  Jb(t2) {
    this.Yb.M() && this.Yb.m(t2);
  }
};
__name(_ge, "ge");
let ge = _ge;
var _a41;
let Me$1 = (_a41 = class {
  constructor(t2, i, n2) {
    this.tw = new R(), this.uu = new R(), this._m = new R(), this.Ui = t2, this.wl = t2.yt(), this.$m = i, this.wl.Ku().l(this.iw.bind(this)), this.wl.Zu().l(this.nw.bind(this)), this.$m.gm().l(this.sw.bind(this)), this.N_ = n2;
  }
  S() {
    this.wl.Ku().p(this), this.wl.Zu().p(this), this.$m.gm().p(this), this.tw.S(), this.uu.S(), this._m.S();
  }
  scrollPosition() {
    return this.wl.Eu();
  }
  scrollToPosition(t2, i) {
    i ? this.wl.qu(t2, 1e3) : this.Ui.Jn(t2);
  }
  scrollToRealTime() {
    this.wl.Uu();
  }
  getVisibleRange() {
    const t2 = this.wl.yu();
    return t2 === null ? null : { from: t2.from.originalTime, to: t2.to.originalTime };
  }
  setVisibleRange(t2) {
    const i = { from: this.N_.convertHorzItemToInternal(t2.from), to: this.N_.convertHorzItemToInternal(t2.to) }, n2 = this.wl.Ru(i);
    this.Ui.ld(n2);
  }
  getVisibleLogicalRange() {
    const t2 = this.wl.ku();
    return t2 === null ? null : { from: t2.Os(), to: t2.di() };
  }
  setVisibleLogicalRange(t2) {
    p$1(t2.from <= t2.to, "The from index cannot be after the to index."), this.Ui.ld(t2);
  }
  resetTimeScale() {
    this.Ui.Zn();
  }
  fitContent() {
    this.Ui.Qu();
  }
  logicalToCoordinate(t2) {
    const i = this.Ui.yt();
    return i.Fi() ? null : i.Et(t2);
  }
  coordinateToLogical(t2) {
    return this.wl.Fi() ? null : this.wl.Vu(t2);
  }
  timeToCoordinate(t2) {
    const i = this.N_.convertHorzItemToInternal(t2), n2 = this.wl.ya(i, !1);
    return n2 === null ? null : this.wl.Et(n2);
  }
  coordinateToTime(t2) {
    const i = this.Ui.yt(), n2 = i.Vu(t2), s = i.qi(n2);
    return s === null ? null : s.originalTime;
  }
  width() {
    return this.$m.$p().width;
  }
  height() {
    return this.$m.$p().height;
  }
  subscribeVisibleTimeRangeChange(t2) {
    this.tw.l(t2);
  }
  unsubscribeVisibleTimeRangeChange(t2) {
    this.tw.v(t2);
  }
  subscribeVisibleLogicalRangeChange(t2) {
    this.uu.l(t2);
  }
  unsubscribeVisibleLogicalRangeChange(t2) {
    this.uu.v(t2);
  }
  subscribeSizeChange(t2) {
    this._m.l(t2);
  }
  unsubscribeSizeChange(t2) {
    this._m.v(t2);
  }
  applyOptions(t2) {
    this.wl.Nh(t2);
  }
  options() {
    return Object.assign(Object.assign({}, I(this.wl.W())), { barSpacing: this.wl.he() });
  }
  iw() {
    this.tw.M() && this.tw.m(this.getVisibleRange());
  }
  nw() {
    this.uu.M() && this.uu.m(this.getVisibleLogicalRange());
  }
  sw(t2) {
    this._m.m(t2.width, t2.height);
  }
}, __name(_a41, "Me"), _a41);
function xe(t2) {
  if (t2 === void 0 || t2.type === "custom")
    return;
  const i = t2;
  i.minMove !== void 0 && i.precision === void 0 && (i.precision = function(t3) {
    if (t3 >= 1)
      return 0;
    let i2 = 0;
    for (; i2 < 8; i2++) {
      const n2 = Math.round(t3);
      if (Math.abs(n2 - t3) < 1e-8)
        return i2;
      t3 *= 10;
    }
    return i2;
  }(i.minMove));
}
__name(xe, "xe");
function Se(t2) {
  return function(t3) {
    if (B$1(t3.handleScale)) {
      const i2 = t3.handleScale;
      t3.handleScale = { axisDoubleClickReset: { time: i2, price: i2 }, axisPressedMouseMove: { time: i2, price: i2 }, mouseWheel: i2, pinch: i2 };
    } else if (t3.handleScale !== void 0) {
      const { axisPressedMouseMove: i2, axisDoubleClickReset: n2 } = t3.handleScale;
      B$1(i2) && (t3.handleScale.axisPressedMouseMove = { time: i2, price: i2 }), B$1(n2) && (t3.handleScale.axisDoubleClickReset = { time: n2, price: n2 });
    }
    const i = t3.handleScroll;
    B$1(i) && (t3.handleScroll = { horzTouchDrag: i, vertTouchDrag: i, mouseWheel: i, pressedMouseMove: i });
  }(t2), t2;
}
__name(Se, "Se");
var _a42;
let ke$1 = (_a42 = class {
  constructor(t2, i, n2) {
    this.ew = /* @__PURE__ */ new Map(), this.rw = /* @__PURE__ */ new Map(), this.hw = new R(), this.lw = new R(), this.aw = new R(), this.ow = new Js(i);
    const s = n2 === void 0 ? I(ve()) : D$1(I(ve()), Se(n2));
    this.N_ = i, this.$b = new zs(t2, s, i), this.$b.Fp().l((t3) => {
      this.hw.M() && this.hw.m(this._w(t3()));
    }, this), this.$b.Wp().l((t3) => {
      this.lw.M() && this.lw.m(this._w(t3()));
    }, this), this.$b.Wc().l((t3) => {
      this.aw.M() && this.aw.m(this._w(t3()));
    }, this);
    const e2 = this.$b.qt();
    this.uw = new Me$1(e2, this.$b.Zm(), this.N_);
  }
  remove() {
    this.$b.Fp().p(this), this.$b.Wp().p(this), this.$b.Wc().p(this), this.uw.S(), this.$b.S(), this.ew.clear(), this.rw.clear(), this.hw.S(), this.lw.S(), this.aw.S(), this.ow.S();
  }
  resize(t2, i, n2) {
    this.autoSizeActive() || this.$b.qm(t2, i, n2);
  }
  addCustomSeries(t2, i) {
    const n2 = w$1(t2), s = Object.assign(Object.assign({}, _$1), n2.defaultOptions());
    return this.cw("Custom", s, i, n2);
  }
  addAreaSeries(t2) {
    return this.cw("Area", l, t2);
  }
  addBaselineSeries(t2) {
    return this.cw("Baseline", a, t2);
  }
  addBarSeries(t2) {
    return this.cw("Bar", r, t2);
  }
  addCandlestickSeries(t2 = {}) {
    return function(t3) {
      t3.borderColor !== void 0 && (t3.borderUpColor = t3.borderColor, t3.borderDownColor = t3.borderColor), t3.wickColor !== void 0 && (t3.wickUpColor = t3.wickColor, t3.wickDownColor = t3.wickColor);
    }(t2), this.cw("Candlestick", e, t2);
  }
  addHistogramSeries(t2) {
    return this.cw("Histogram", o, t2);
  }
  addLineSeries(t2) {
    return this.cw("Line", h$1, t2);
  }
  removeSeries(t2) {
    const i = m$1(this.ew.get(t2)), n2 = this.ow.hd(i);
    this.$b.qt().hd(i), this.dw(n2), this.ew.delete(t2), this.rw.delete(i);
  }
  Gb(t2, i) {
    this.dw(this.ow.Ab(t2, i));
  }
  Qb(t2, i) {
    this.dw(this.ow.Eb(t2, i));
  }
  subscribeClick(t2) {
    this.hw.l(t2);
  }
  unsubscribeClick(t2) {
    this.hw.v(t2);
  }
  subscribeCrosshairMove(t2) {
    this.aw.l(t2);
  }
  unsubscribeCrosshairMove(t2) {
    this.aw.v(t2);
  }
  subscribeDblClick(t2) {
    this.lw.l(t2);
  }
  unsubscribeDblClick(t2) {
    this.lw.v(t2);
  }
  priceScale(t2) {
    return new pe(this.$b, t2);
  }
  timeScale() {
    return this.uw;
  }
  applyOptions(t2) {
    this.$b.Nh(Se(t2));
  }
  options() {
    return this.$b.W();
  }
  takeScreenshot() {
    return this.$b.tb();
  }
  autoSizeActive() {
    return this.$b.rb();
  }
  chartElement() {
    return this.$b.hb();
  }
  paneSize() {
    const t2 = this.$b.ab();
    return { height: t2.height, width: t2.width };
  }
  setCrosshairPosition(t2, i, n2) {
    const s = this.ew.get(n2);
    if (s === void 0)
      return;
    const e2 = this.$b.qt().cr(s);
    e2 !== null && this.$b.qt().Qc(t2, i, e2);
  }
  clearCrosshairPosition() {
    this.$b.qt().td(!0);
  }
  cw(t2, i, n2 = {}, s) {
    xe(n2.priceFormat);
    const e2 = D$1(I(u), I(i), n2), r2 = this.$b.qt().ed(t2, e2, s), h2 = new ge(r2, this, this, this, this.N_);
    return this.ew.set(h2, r2), this.rw.set(r2, h2), h2;
  }
  dw(t2) {
    const i = this.$b.qt();
    i.nd(t2.yt.Au, t2.yt.jb, t2.yt.Hb), t2.Fb.forEach((t3, i2) => i2.it(t3.He, t3.Wb)), i.Iu();
  }
  fw(t2) {
    return m$1(this.rw.get(t2));
  }
  _w(t2) {
    const i = /* @__PURE__ */ new Map();
    t2.Mb.forEach((t3, n3) => {
      const s = n3.Xh(), e2 = le(s)(t3);
      if (s !== "Custom")
        p$1(function(t4) {
          return t4.open !== void 0 || t4.value !== void 0;
        }(e2));
      else {
        const t4 = n3.Ma();
        p$1(!t4 || t4(e2) === !1);
      }
      i.set(this.fw(n3), e2);
    });
    const n2 = t2.gb === void 0 ? void 0 : this.fw(t2.gb);
    return { time: t2.bb, logical: t2.se, point: t2.wb, hoveredSeries: n2, hoveredObjectId: t2.xb, seriesData: i, sourceEvent: t2.Sb };
  }
}, __name(_a42, "ke"), _a42);
function ye(t2, i, n2) {
  let s;
  if (V$1(t2)) {
    const i2 = document.getElementById(t2);
    p$1(i2 !== null, `Cannot find element in DOM with id=${t2}`), s = i2;
  } else
    s = t2;
  const e2 = new ke$1(s, i, n2);
  return i.setOptions(e2.options()), e2;
}
__name(ye, "ye");
function Ce$1(t2, i) {
  return ye(t2, new ts(), ts.Td(i));
}
__name(Ce$1, "Ce$1");
Object.assign(Object.assign({}, u), _$1);
const skeleton = "_skeleton_13p4i_1", style$n = {
  skeleton,
  "skeleton-loading": "_skeleton-loading_13p4i_1"
}, Skeleton = /* @__PURE__ */ __name(({
  fontSize,
  minWidth = "100%"
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$n.skeleton, style: { fontSize, minWidth } }), "Skeleton"), chart = "_chart_1bo3n_1", invisible = "_invisible_1bo3n_7", chartUpdatingMessage = "_chartUpdatingMessage_1bo3n_11", summary$1 = "_summary_1bo3n_28", filters = "_filters_1bo3n_35", filterActive = "_filterActive_1bo3n_87", arrow = "_arrow_1bo3n_104", up = "_up_1bo3n_109", down = "_down_1bo3n_113", totalValue = "_totalValue_1bo3n_117", totalUnit = "_totalUnit_1bo3n_121", diffValue = "_diffValue_1bo3n_128", diffUnit = "_diffUnit_1bo3n_132", chartCanvas = "_chartCanvas_1bo3n_137", tooltip = "_tooltip_1bo3n_149", toolTipValue = "_toolTipValue_1bo3n_164", toolTipUnit = "_toolTipUnit_1bo3n_170", toolTipTime = "_toolTipTime_1bo3n_176", styles$j = {
  chart,
  invisible,
  chartUpdatingMessage,
  summary: summary$1,
  filters,
  filterActive,
  arrow,
  up,
  down,
  totalValue,
  totalUnit,
  diffValue,
  diffUnit,
  chartCanvas,
  tooltip,
  toolTipValue,
  toolTipUnit,
  toolTipTime
}, Filters = /* @__PURE__ */ __name(({
  display,
  disableFilters,
  onDisplayWeek,
  onDisplayMonth,
  onDisplayYear,
  onDisplayAll
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.filters, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "week" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayWeek,
        children: t2("chart.filter.week")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "month" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayMonth,
        children: t2("chart.filter.month")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "year" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayYear,
        children: t2("chart.filter.year")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "all" ? styles$j.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayAll,
        children: t2("chart.filter.all")
      }
    )
  ] });
}, "Filters");
let darkmode;
const Darkmode = /* @__PURE__ */ __name(() => {
  const { isDarkMode } = useDarkmode();
  return darkmode = isDarkMode, null;
}, "Darkmode"), getDarkmode = /* @__PURE__ */ __name(() => darkmode, "getDarkmode"), _Chart = class _Chart extends reactExports.Component {
  constructor() {
    super(...arguments), this.ref = reactExports.createRef(), this.refToolTip = reactExports.createRef(), this.height = 300, this.mobileHeight = 150, this.state = {
      display: "all",
      source: "daily",
      toolTipVisible: !1,
      toolTipValue: void 0,
      toolTipTop: 0,
      toolTipLeft: 0,
      toolTipTime: 0,
      isMobile: !1
    }, this.hasData = () => this.props.data.chartDataDaily && this.props.data.chartDataDaily.length > 0, this.checkIfMobile = () => {
      this.setState({ isMobile: window.innerWidth <= 640 });
    }, this.createChart = () => {
      const { data: { chartDataMissing } } = this.props, darkmode2 = getDarkmode();
      if (this.ref.current && this.hasData() && !chartDataMissing) {
        if (!this.chart) {
          const chartWidth = this.state.isMobile ? document.body.clientWidth : this.ref.current.offsetWidth, chartHeight = this.state.isMobile ? this.mobileHeight : this.height;
          this.chart = Ce$1(this.ref.current, {
            width: chartWidth,
            height: chartHeight,
            handleScroll: !1,
            handleScale: !1,
            crosshair: {
              vertLine: {
                visible: !1,
                labelVisible: !1
              },
              horzLine: {
                visible: !1,
                labelVisible: !1
              },
              mode: 1
            },
            grid: {
              vertLines: {
                visible: !1
              },
              horzLines: {
                color: darkmode2 ? "#333333" : "#dedede",
                style: d.Solid,
                visible: !this.state.isMobile
              }
            },
            layout: {
              background: {
                type: Bn$1.Solid,
                color: darkmode2 ? "#1D1D1B" : "#F5F5F5"
              },
              fontSize: 11,
              fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Ubuntu", "Roboto", "Oxygen", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
              textColor: darkmode2 ? "#F5F5F5" : "#1D1D1B"
            },
            leftPriceScale: {
              borderVisible: !1,
              ticksVisible: !1,
              visible: this.props.hideAmounts ? !1 : !this.state.isMobile,
              entireTextOnly: !0
            },
            localization: {
              locale: this.props.i18n.language
            },
            rightPriceScale: {
              visible: !1,
              ticksVisible: !1
            },
            timeScale: {
              borderVisible: !1,
              timeVisible: !1,
              visible: !this.state.isMobile
            },
            trackingMode: {
              exitMode: 0
            }
          });
        }
        this.lineSeries = this.chart.addAreaSeries({
          priceLineVisible: !1,
          lastValueVisible: !1,
          priceFormat: {
            type: "volume"
          },
          topColor: darkmode2 ? "#5E94BF" : "#DFF1FF",
          bottomColor: darkmode2 ? "#1D1D1B" : "#F5F5F5",
          lineColor: "rgba(94, 148, 192, 1)",
          crosshairMarkerRadius: 6
        }), this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.timeScale().subscribeVisibleLogicalRangeChange(this.calculateChange), this.chart.subscribeCrosshairMove(this.handleCrosshair), this.chart.timeScale().fitContent(), window.addEventListener("resize", this.onResize), setTimeout(() => {
          var _a46;
          return (_a46 = this.ref.current) == null ? void 0 : _a46.classList.remove(styles$j.invisible);
        }, 200);
      }
    }, this.onResize = () => {
      this.checkIfMobile(), this.resizeTimerID && clearTimeout(this.resizeTimerID), this.resizeTimerID = setTimeout(() => {
        if (!this.chart || !this.ref.current)
          return;
        const chartWidth = this.state.isMobile ? document.body.clientWidth : this.ref.current.offsetWidth, chartHeight = this.state.isMobile ? this.mobileHeight : this.height;
        this.chart.resize(chartWidth, chartHeight), this.chart.applyOptions({
          grid: {
            horzLines: {
              visible: !this.state.isMobile
            }
          },
          timeScale: {
            visible: !this.state.isMobile
          },
          leftPriceScale: {
            visible: this.props.hideAmounts ? !1 : !this.state.isMobile
          }
        });
      }, 200);
    }, this.getUTCRange = () => {
      const now = /* @__PURE__ */ new Date(), utcYear = now.getUTCFullYear(), utcMonth = now.getUTCMonth(), utcDate = now.getUTCDate(), utcHours = now.getUTCHours(), to = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0)), from2 = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      return {
        utcYear,
        utcMonth,
        utcDate,
        to,
        from: from2
      };
    }, this.displayWeek = () => {
      this.state.source !== "hourly" && this.lineSeries && this.props.data.chartDataHourly && this.chart && (this.lineSeries.setData(this.props.data.chartDataHourly || []), this.setFormattedData(this.props.data.chartDataHourly || []), this.chart.applyOptions({ timeScale: { timeVisible: !0 } })), this.setState(
        { display: "week", source: "hourly" },
        () => {
          if (!this.chart)
            return;
          const { utcDate, from: from2, to } = this.getUTCRange();
          from2.setUTCDate(utcDate - 7), this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayMonth = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily || []), this.setFormattedData(this.props.data.chartDataDaily || []), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "month", source: "daily" },
        () => {
          if (!this.chart)
            return;
          const { utcMonth, from: from2, to } = this.getUTCRange();
          from2.setUTCMonth(utcMonth - 1), this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayYear = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "year", source: "daily" },
        () => {
          if (!this.chart)
            return;
          const { utcYear, from: from2, to } = this.getUTCRange();
          from2.setUTCFullYear(utcYear - 1), this.chart && this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    }, this.displayAll = () => {
      this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart && (this.lineSeries.setData(this.props.data.chartDataDaily), this.setFormattedData(this.props.data.chartDataDaily), this.chart.applyOptions({ timeScale: { timeVisible: !1 } })), this.setState(
        { display: "all", source: "daily" },
        () => {
          this.chart && this.chart.timeScale().fitContent();
        }
      );
    }, this.calculateChange = () => {
      const data = this.props.data[this.state.source === "daily" ? "chartDataDaily" : "chartDataHourly"];
      if (!data || !this.chart || !this.lineSeries)
        return;
      const logicalrange = this.chart.timeScale().getVisibleLogicalRange(), visiblerange = this.lineSeries.barsInLogicalRange(logicalrange);
      if (!visiblerange)
        return;
      const rangeFrom = Math.max(Math.floor(visiblerange.barsBefore), 0);
      if (!data[rangeFrom]) {
        this.setState({ difference: 0, diffSince: "" });
        return;
      }
      const valueFrom = data[rangeFrom].value, valueTo = this.props.data.chartTotal, valueDiff = valueTo ? valueTo - valueFrom : 0;
      this.setState({
        difference: valueDiff / valueFrom * 100,
        diffSince: `${data[rangeFrom].formattedValue} (${this.renderDate(Number(data[rangeFrom].time) * 1e3)})`
      });
    }, this.handleCrosshair = ({ point, time: time2, seriesData }) => {
      if (!this.refToolTip.current)
        return;
      const tooltip2 = this.refToolTip.current, parent = tooltip2.parentNode;
      if (!this.lineSeries || !point || !time2 || point.x < 0 || point.x > parent.clientWidth || point.y < 0 || point.y > parent.clientHeight) {
        this.setState({
          toolTipVisible: !1
        });
        return;
      }
      const price = seriesData.get(this.lineSeries);
      if (!price)
        return;
      const coordinate = this.lineSeries.priceToCoordinate(price.value);
      if (!coordinate)
        return;
      const coordinateY = coordinate - tooltip2.clientHeight > 0 ? coordinate - tooltip2.clientHeight : Math.max(
        0,
        Math.min(
          parent.clientHeight - tooltip2.clientHeight,
          coordinate + 70
        )
      ), toolTipTop = Math.floor(Math.max(coordinateY, 0)), toolTipLeft = Math.floor(Math.max(40, Math.min(parent.clientWidth - 140, point.x + 40 - 70)));
      this.setState({
        toolTipVisible: !0,
        toolTipValue: this.formattedData ? this.formattedData[time2] : "",
        toolTipTop,
        toolTipLeft,
        toolTipTime: time2
      });
    }, this.renderDate = (date2) => new Date(date2).toLocaleString(
      this.props.i18n.language,
      {
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
        ...this.state.source === "hourly" ? {
          hour: "2-digit",
          minute: "2-digit"
        } : null
      }
    );
  }
  componentDidMount() {
    this.checkIfMobile(), this.createChart();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.onResize), this.chart && (this.chart.timeScale().unsubscribeVisibleLogicalRangeChange(this.calculateChange), this.chart.unsubscribeCrosshairMove(this.handleCrosshair));
  }
  componentDidUpdate(prev2) {
    var _a46;
    const { chartDataDaily, chartDataHourly } = this.props.data;
    if (this.chart || this.createChart(), this.lineSeries && prev2.data.chartDataDaily && prev2.data.chartDataHourly && chartDataDaily && chartDataHourly && (prev2.data.chartDataDaily.length !== chartDataDaily.length || prev2.data.chartDataHourly.length !== chartDataHourly.length)) {
      const data = this.state.source === "hourly" ? chartDataHourly : chartDataDaily;
      this.lineSeries.setData(data), this.setFormattedData(data);
    }
    prev2.hideAmounts !== this.props.hideAmounts && ((_a46 = this.chart) == null || _a46.applyOptions({
      leftPriceScale: {
        visible: this.props.hideAmounts ? !1 : !this.state.isMobile
      }
    }));
  }
  setFormattedData(data) {
    this.formattedData = {}, data.forEach((entry2) => {
      this.formattedData && (this.formattedData[entry2.time] = entry2.formattedValue);
    });
  }
  render() {
    const {
      t: t2,
      data: {
        lastTimestamp,
        chartDataMissing,
        chartFiat,
        chartIsUpToDate,
        chartTotal,
        formattedChartTotal
      },
      noDataPlaceholder,
      hideAmounts
    } = this.props, {
      difference,
      diffSince,
      display,
      toolTipVisible,
      toolTipValue: toolTipValue2,
      toolTipTop,
      toolTipLeft,
      toolTipTime: toolTipTime2,
      isMobile
    } = this.state, hasDifferenece = difference && Number.isFinite(difference), hasData = this.hasData(), disableFilters = !hasData || chartTotal === 0 || chartDataMissing, showMobileTotalValue = toolTipVisible && !!toolTipValue2 && isMobile, chartFiltersProps = {
      display,
      disableFilters,
      onDisplayWeek: this.displayWeek,
      onDisplayMonth: this.displayMonth,
      onDisplayYear: this.displayYear,
      onDisplayAll: this.displayAll
    }, chartHeight = `${isMobile ? this.mobileHeight : this.height}px`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: styles$j.chart, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.summary, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.totalValue, children: [
            formattedChartTotal !== null ? (
              // remove trailing zeroes for BTC fiat total
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: showMobileTotalValue ? toolTipValue2 : formattedChartTotal, unit: chartFiat, removeBtcTrailingZeroes: !0 })
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { minWidth: "220px" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.totalUnit, children: chartTotal !== null && chartFiat })
          ] }),
          showMobileTotalValue ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.diffValue, children: this.renderDate(toolTipTime2 * 1e3) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: hasDifferenece ? styles$j[difference < 0 ? "down" : "up"] : "", title: diffSince, children: hasDifferenece ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.arrow, children: difference < 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDown, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$j.diffValue, children: [
              hideAmounts ? "***" : formatNumber(difference, 2),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.diffUnit, children: "%" })
            ] })
          ] }) : chartTotal === 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "1.125rem", minWidth: "125px" }) })
        ] }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.chartCanvas, style: { minHeight: chartHeight }, children: [
        chartDataMissing ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.chartUpdatingMessage, style: { height: chartHeight }, children: t2("chart.dataMissing") }) : hasData ? !chartIsUpToDate && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.chartUpdatingMessage, children: t2("chart.dataOldTimestamp", { time: new Date(lastTimestamp).toLocaleString(this.props.i18n.language) }) }) : noDataPlaceholder,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: this.ref, className: styles$j.invisible }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ref: this.refToolTip,
            className: styles$j.tooltip,
            style: { left: toolTipLeft, top: toolTipTop },
            hidden: !toolTipVisible || isMobile,
            children: toolTipValue2 !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: styles$j.toolTipValue, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: toolTipValue2, unit: chartFiat }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.toolTipUnit, children: chartFiat })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.toolTipTime, children: this.renderDate(toolTipTime2 * 1e3) })
            ] }) : null
          }
        )
      ] }),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
    ] });
  }
};
__name(_Chart, "Chart");
let Chart = _Chart;
Chart.defaultProps = {
  data: {
    chartDataMissing: !0,
    chartDataDaily: [],
    chartDataHourly: [],
    chartFiat: "USD",
    chartTotal: null,
    formattedChartTotal: null,
    chartIsUpToDate: !1,
    lastTimestamp: 0
  },
  hideAmounts: !1
};
const HOC$4 = translate()(Chart), ArrowUp = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
), "ArrowUp"), ArrowDown = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
), "ArrowDown"), spinnerContainer$1 = "_spinnerContainer_1akm7_1", spinner$1 = "_spinner_1akm7_1", changeContent$2 = "_changeContent_1akm7_1", style$m = {
  spinnerContainer: spinnerContainer$1,
  spinner: spinner$1,
  changeContent: changeContent$2
};
function AsciiSpinner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$m.spinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$m.spinner }) });
}
__name(AsciiSpinner, "AsciiSpinner");
const balanceTable = "_balanceTable_1v4c8_1", coincode = "_coincode_1v4c8_4", coinheader = "_coinheader_1v4c8_9", dataMissing = "_dataMissing_1v4c8_20", openFileText = "_openFileText_1v4c8_24", table = "_table_1v4c8_30", noAccount = "_noAccount_1v4c8_45", clickable = "_clickable_1v4c8_80", summaryTableBalance = "_summaryTableBalance_1v4c8_84", coinName = "_coinName_1v4c8_94", coinUnit = "_coinUnit_1v4c8_104", syncText$1 = "_syncText_1v4c8_108", showOnTableView = "_showOnTableView_1v4c8_112", showInCollapsedView = "_showInCollapsedView_1v4c8_116", subTotal = "_subTotal_1v4c8_167", style$l = {
  balanceTable,
  coincode,
  coinheader,
  dataMissing,
  openFileText,
  table,
  noAccount,
  clickable,
  summaryTableBalance,
  coinName,
  coinUnit,
  syncText: syncText$1,
  showOnTableView,
  showInCollapsedView,
  subTotal
};
function BalanceRow({ code, name, coinCode, balance: balance2 }) {
  const { t: t2 } = useTranslation(), syncStatus2 = useSubscribe(syncAddressesCount(code)), nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      className: style$l.clickable,
      "data-label": t2("accountSummary.name"),
      onClick: () => route(`/account/${code}`),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$l.coinName, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$l.coincode, coinCode, active: !0, alt: coinCode }),
        name
      ] })
    }
  );
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$l.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.available.amount, unit: balance2.available.unit }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: balance2.available.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.available, noAction: !0 }) })
  ] }, `${code}_balance`) : /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 2, className: style$l.syncText, children: [
      t2("account.syncedAddressesCount", {
        count: syncStatus2 == null ? void 0 : syncStatus2.toString(),
        defaultValue: 0
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] })
  ] }, `${code}_syncing`);
}
__name(BalanceRow, "BalanceRow");
function SubTotalRow({ coinCode, coinName: coinName2, balance: balance2 }) {
  const { t: t2 } = useTranslation(), nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.total"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$l.coinName, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$l.coincode, coinCode, active: !0, alt: coinCode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$l.showOnTableView, children: t2("accountSummary.subtotalWithCoinName", { coinName: coinName2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$l.showInCollapsedView, children: coinName2 })
  ] }) });
  return balance2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: style$l.subTotal, children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$l.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.amount, unit: balance2.unit }) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: balance2.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2, noAction: !0 }) }) })
  ] }, `${coinCode}_subtotal`) : null;
}
__name(SubTotalRow, "SubTotalRow");
function SummaryBalance({
  accounts,
  summaryData,
  totalBalancePerCoin,
  balances
}) {
  const { t: t2 } = useTranslation(), accountsPerCoin = (/* @__PURE__ */ __name(() => accounts.reduce((accountPerCoin, account2) => (accountPerCoin[account2.coinCode] ? accountPerCoin[account2.coinCode].push(account2) : accountPerCoin[account2.coinCode] = [account2], accountPerCoin), {}), "getAccountsPerCoin"))(), coins2 = Object.keys(accountsPerCoin);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$l.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: style$l.table, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.balance") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.fiatBalance") })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: accounts.length > 0 ? coins2.map((coinCode) => {
      const balanceRows = accountsPerCoin[coinCode].map(
        (account2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          BalanceRow,
          {
            code: account2.code,
            name: account2.name,
            coinCode: account2.coinCode,
            balance: balances && balances[account2.code]
          },
          account2.code
        )
      );
      if ((balanceRows == null ? void 0 : balanceRows.length) > 1) {
        const account2 = accountsPerCoin[coinCode][0];
        balanceRows.push(
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SubTotalRow,
            {
              coinCode: account2.coinCode,
              coinName: account2.coinName,
              balance: totalBalancePerCoin && totalBalancePerCoin[coinCode]
            },
            account2.coinCode
          )
        );
      }
      return balanceRows;
    }) : /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 3, className: style$l.noAccount, children: t2("accountSummary.noAccount") }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("tfoot", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("accountSummary.total") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 2, children: summaryData && summaryData.formattedChartTotal !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: summaryData.formattedChartTotal, unit: summaryData.chartFiat }) }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$l.coinUnit, children: summaryData.chartFiat })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
    ] }) })
  ] }) });
}
__name(SummaryBalance, "SummaryBalance");
const useMediaQuery = /* @__PURE__ */ __name((query) => {
  const getMatches = /* @__PURE__ */ __name((query2) => window.matchMedia(query2).matches, "getMatches"), [matches, setMatches] = reactExports.useState(getMatches(query));
  return reactExports.useEffect(() => {
    const handleChange = /* @__PURE__ */ __name(() => {
      setMatches(getMatches(query));
    }, "handleChange"), matchMedia = window.matchMedia(query);
    return handleChange(), matchMedia.addEventListener("change", handleChange), () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]), matches;
}, "useMediaQuery"), container$e = "_container_1mptn_1", main = "_main_1mptn_8", walletConnect$1 = "_walletConnect_1mptn_17", styles$i = {
  container: container$e,
  main,
  walletConnect: walletConnect$1
}, BuyReceiveCTA = /* @__PURE__ */ __name(({ code, unit: unit2, balanceList, exchangeBuySupported = !0, account: account2 }) => {
  const formattedUnit = isBitcoinCoin(unit2) ? "BTC" : unit2, { t: t2 } = useTranslation(), isMobile = useMediaQuery("(max-width: 768px)"), onBuyCTA = /* @__PURE__ */ __name(() => route(code ? `/buy/info/${code}` : "/buy/info"), "onBuyCTA"), onWalletConnect = /* @__PURE__ */ __name(() => route(`/account/${code}/wallet-connect/dashboard`), "onWalletConnect"), onReceiveCTA = /* @__PURE__ */ __name(() => {
    if (balanceList) {
      if (balanceList.length > 1) {
        route("accounts/select-receive");
        return;
      }
      route(`/account/${code}/receive`);
    }
  }, "onReceiveCTA");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$i.main}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.looksEmpty") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.start") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.container, children: [
      balanceList && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onReceiveCTA, children: formattedUnit ? t2("receive.title", { accountName: formattedUnit }) : t2("receive.title", { accountName: t2("buy.info.crypto") }) }),
      exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onBuyCTA, children: formattedUnit ? t2("accountInfo.buyCTA.buy", { unit: formattedUnit }) : t2("accountInfo.buyCTA.buyCrypto") }),
      account2 && isEthereumBased(account2.coinCode) && !account2.isToken && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onWalletConnect, className: styles$i.walletConnect, children: isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
      ] }) })
    ] })
  ] });
}, "BuyReceiveCTA"), AddBuyReceiveOnEmptyBalances = /* @__PURE__ */ __name(({ balances, accounts }) => {
  const mounted = useMountedRef(), [supportedAccounts, setSupportedAccounts] = reactExports.useState(), onlyHasOneActiveAccount = accounts.length === 1;
  if (reactExports.useEffect(() => {
    mounted.current && getExchangeSupportedAccounts(accounts).then((supportedAccounts2) => {
      mounted.current && setSupportedAccounts(supportedAccounts2);
    }).catch(console.error);
  }, [accounts, mounted]), balances === void 0 || supportedAccounts === void 0)
    return null;
  const balanceList = accounts.map((account2) => balances[account2.code]).filter((balance2) => !!balance2);
  return balanceList.some((entry2) => entry2.hasAvailable) ? null : balanceList.map((entry2) => entry2.available.unit).every(isBitcoinCoin) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { code: onlyHasOneActiveAccount ? accounts[0].code : void 0, unit: "BTC", balanceList }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { exchangeBuySupported: supportedAccounts.length > 0, balanceList });
}, "AddBuyReceiveOnEmptyBalances");
function AccountsSummary({
  accounts,
  devices
}) {
  const { t: t2 } = useTranslation(), summaryReqTimerID = reactExports.useRef(), mounted = useMountedRef(), { hideAmounts } = reactExports.useContext(AppContext), [summaryData, setSummaryData] = reactExports.useState(), [totalBalancePerCoin, setTotalBalancePerCoin] = reactExports.useState(), [balances, setBalances] = reactExports.useState(), hasCard = useSDCard(devices), getAccountSummary = reactExports.useCallback(async () => {
    summaryReqTimerID.current && window.clearTimeout(summaryReqTimerID.current);
    try {
      const summaryData2 = await getSummary();
      if (!mounted.current)
        return;
      setSummaryData(summaryData2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]), getAccountsTotalBalance$1 = reactExports.useCallback(async () => {
    try {
      const totalBalance = await getAccountsTotalBalance();
      if (!mounted.current)
        return;
      setTotalBalancePerCoin(totalBalance);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]), onStatusChanged = reactExports.useCallback(async (code) => {
    if (!mounted.current)
      return;
    const status2 = await getStatus$2(code);
    if (status2.disabled || !mounted.current)
      return;
    if (!status2.synced)
      return init(code);
    const balance2 = await getBalance(code);
    mounted.current && setBalances((prevBalances) => ({
      ...prevBalances,
      [code]: balance2
    }));
  }, [mounted]), update = reactExports.useCallback((code) => {
    mounted.current && (onStatusChanged(code), getAccountSummary());
  }, [getAccountSummary, mounted, onStatusChanged]);
  return reactExports.useEffect(() => {
    const subscriptions2 = [
      statusChanged$1(update),
      syncdone(update)
    ];
    return getAccountSummary(), getAccountsTotalBalance$1(), () => unsubscribe(subscriptions2);
  }, [getAccountSummary, getAccountsTotalBalance$1, update]), reactExports.useEffect(() => {
    const delay2 = !summaryData || summaryData.chartDataMissing ? 1e3 : 1e4;
    return summaryReqTimerID.current = window.setTimeout(getAccountSummary, delay2), () => {
      summaryReqTimerID.current && window.clearTimeout(summaryReqTimerID.current);
    };
  }, [summaryData, getAccountSummary]), reactExports.useEffect(() => {
    accounts.forEach((account2) => {
      onStatusChanged(account2.code);
    }), getAccountsTotalBalance$1();
  }, [onStatusChanged, getAccountsTotalBalance$1, accounts]), /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountSummary.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HOC$4,
          {
            hideAmounts,
            data: summaryData,
            noDataPlaceholder: accounts.length && accounts.length <= Object.keys(balances || {}).length ? /* @__PURE__ */ jsxRuntimeExports.jsx(AddBuyReceiveOnEmptyBalances, { accounts, balances }) : void 0
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SummaryBalance,
          {
            accounts,
            summaryData,
            totalBalancePerCoin,
            balances
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSummaryDescription") }, "accountSummaryDescription"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: "www.coingecko.com",
          url: "https://www.coingecko.com/"
        },
        text: t2("guide.accountSummaryAmount.text"),
        title: t2("guide.accountSummaryAmount.title")
      } }, "accountSummaryAmount"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.trackingModePortfolioChart") }, "trackingModePortfolioChart")
    ] })
  ] });
}
__name(AccountsSummary, "AccountsSummary");
const URL_CONSTANTS = {
  DOWNLOAD_LINK_GLOBAL: "https://bitbox.swiss/download/?source=bitboxapp",
  DOWNLOAD_LINK_DE: "https://bitbox.swiss/de/download/?source=bitboxapp",
  DOWNLOAD_LINK_ES: "https://bitbox.swiss/es/descargar/?source=bitboxapp"
}, downloadLinkByLanguage = /* @__PURE__ */ __name(() => {
  switch (instance.resolvedLanguage) {
    case "de":
      return URL_CONSTANTS.DOWNLOAD_LINK_DE;
    case "es":
      return URL_CONSTANTS.DOWNLOAD_LINK_ES;
    default:
      return URL_CONSTANTS.DOWNLOAD_LINK_GLOBAL;
  }
}, "downloadLinkByLanguage"), AppDownloadLink = /* @__PURE__ */ __name(({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: t2("button.download") });
}, "AppDownloadLink"), AppDownloadButton = /* @__PURE__ */ __name(({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, children: t2("button.download") }) });
}, "AppDownloadButton"), AppUpgradeRequired = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        verticallyCentered: !0,
        width: "840px",
        withBottomBar: !0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("device.appUpradeRequired") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadButton, {}) })
        ]
      }
    )
  ] });
}, "AppUpgradeRequired"), stateEnum$1 = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
var _a43;
let Unlock$1 = (_a43 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      status: stateEnum$1.DEFAULT,
      errorMessage: "",
      errorCode: null,
      remainingAttempts: null,
      needsLongTouch: !1,
      password: ""
    });
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.password !== "", "validate"));
    __publicField(this, "handleSubmit", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        status: stateEnum$1.WAITING
      }), apiPost("devices/" + this.props.deviceID + "/login", { password: this.state.password }).then((data) => {
        data.success && apiGet("devices/" + this.props.deviceID + "/status").then((status2) => {
          status2 === "seeded" && (console.info("unlock.jsx route to /account-summary"), route("/account-summary", !0));
        }), data.success || (data.code && this.setState({ errorCode: data.code }), data.remainingAttempts && this.setState({ remainingAttempts: data.remainingAttempts }), data.needsLongTouch && this.setState({ needsLongTouch: data.needsLongTouch }), this.setState({ status: stateEnum$1.ERROR, errorMessage: data.errorMessage }));
      }), this.setState({ password: "" }));
    }, "handleSubmit"));
  }
  render() {
    const { t: t2 } = this.props, {
      status: status2,
      password: password2,
      errorCode,
      errorMessage,
      remainingAttempts,
      needsLongTouch
    } = this.state;
    let submissionState = null;
    switch (status2) {
      case stateEnum$1.DEFAULT:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("unlock.description") });
        break;
      case stateEnum$1.WAITING:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: t2("unlock.unlocking") });
        break;
      case stateEnum$1.ERROR:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`unlock.error.e${errorCode}`, {
          defaultValue: errorMessage,
          remainingAttempts,
          context: needsLongTouch ? "touch" : "normal"
        }) });
        break;
    }
    const darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content narrow padded isVerticallyCentered", children: [
          darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            submissionState,
            status2 !== stateEnum$1.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordSingleInput,
                {
                  autoFocus: !0,
                  id: "password",
                  type: "password",
                  label: t2("unlock.input.label"),
                  disabled: status2 === stateEnum$1.WAITING,
                  placeholder: t2("unlock.input.placeholder"),
                  onValidPassword: this.handleFormChange,
                  value: password2
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  type: "submit",
                  disabled: !this.validate() || status2 === stateEnum$1.WAITING,
                  children: t2("button.unlock")
                }
              ) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.forgotDevicePassword") }, "guide.unlock.forgotDevicePassword"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.reset") }, "guide.unlock.reset")
      ] })
    ] });
  }
}, __name(_a43, "Unlock"), _a43);
const Unlock$2 = withTranslation()(Unlock$1), container$d = "_container_17oq2_1", scrollable = "_scrollable_17oq2_17", agreements$1 = "_agreements_17oq2_22", agreementsLabel = "_agreementsLabel_17oq2_26", title$1 = "_title_17oq2_30", summary = "_summary_17oq2_36", heading = "_heading_17oq2_45", content = "_content_17oq2_49", verticalButtons = "_verticalButtons_17oq2_60", block$1 = "_block_17oq2_72", list = "_list_17oq2_85", buttons = "_buttons_17oq2_93", stepNumber = "_stepNumber_17oq2_98", badge$2 = "_badge_17oq2_108", waitingLogo = "_waitingLogo_17oq2_113", waitingContent = "_waitingContent_17oq2_117", waitingText = "_waitingText_17oq2_126", waitingDescription = "_waitingDescription_17oq2_134", qrcodeContainer = "_qrcodeContainer_17oq2_140", style$k = {
  container: container$d,
  scrollable,
  agreements: agreements$1,
  agreementsLabel,
  title: title$1,
  summary,
  heading,
  content,
  verticalButtons,
  block: block$1,
  list,
  buttons,
  stepNumber,
  badge: badge$2,
  waitingLogo,
  waitingContent,
  waitingText,
  waitingDescription,
  qrcodeContainer
}, _Bootloader = class _Bootloader extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "onEvent", /* @__PURE__ */ __name((data) => {
      if (data.type === "device")
        switch (data.data) {
          case "bootloaderStatusChanged":
            this.onStatusChanged();
            break;
        }
    }, "onEvent"));
    __publicField(this, "onStatusChanged", /* @__PURE__ */ __name(() => {
      apiGet("devices/" + this.props.deviceID + "/bootloader-status").then(({ upgrading, progress, upgradeSuccessful, errMsg }) => {
        this.setState({
          upgrading,
          progress,
          upgradeSuccessful,
          errMsg
        });
      });
    }, "onStatusChanged"));
    __publicField(this, "upgradeFirmware", /* @__PURE__ */ __name(() => {
      apiPost("devices/" + this.props.deviceID + "/bootloader/upgrade-firmware");
    }, "upgradeFirmware"));
    this.state = {
      upgrading: !1,
      errMsg: null,
      progress: 0,
      upgradeSuccessful: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onEvent), this.onStatusChanged();
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const { t: t2 } = this.props, {
      upgrading,
      progress,
      upgradeSuccessful,
      errMsg
    } = this.state;
    let UpgradeOrStatus;
    if (upgrading)
      if (upgradeSuccessful)
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bootloader.success") });
      else {
        const value = Math.round(progress * 100);
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
            value,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none text-center", children: t2("bootloader.progress", {
            progress: value
          }) })
        ] });
      }
    else
      UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: this.upgradeFirmware,
          children: t2("bootloader.button")
        }
      ) });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$k.container, style$k.scrollable].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        UpgradeOrStatus,
        errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none", children: errMsg })
      ] })
    ] }) }) }) }) });
  }
};
__name(_Bootloader, "Bootloader");
let Bootloader = _Bootloader;
const Bootloader$1 = withTranslation()(Bootloader), container$c = "_container_l7fdu_1", danger = "_danger_l7fdu_27", children = "_children_l7fdu_31", optionalText = "_optionalText_l7fdu_35", secondaryText$1 = "_secondaryText_l7fdu_46", primaryText$1 = "_primaryText_l7fdu_54", icon = "_icon_l7fdu_58", disabled$1 = "_disabled_l7fdu_63", item$2 = "_item_l7fdu_68", style$j = {
  container: container$c,
  danger,
  children,
  optionalText,
  secondaryText: secondaryText$1,
  primaryText: primaryText$1,
  icon,
  disabled: disabled$1,
  item: item$2
}, SettingsButton = /* @__PURE__ */ __name(({
  onClick,
  danger: danger2,
  optionalText: optionalText2,
  secondaryText: secondaryText2,
  disabled: disabled2,
  children: children2,
  optionalIcon
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "button",
  {
    className: [
      style$j.container,
      danger2 ? style$j.danger : "",
      disabled2 === !0 ? style$j.disabled : ""
    ].join(" "),
    onClick: disabled2 ? void 0 : onClick,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$j.children, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.primaryText, children: children2 }),
        secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.secondaryText, children: secondaryText2 }) : null
      ] }),
      optionalText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.optionalText, children: optionalText2 }) : null,
      optionalIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.icon, children: optionalIcon }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 18 15 12 9 6" }) })
    ]
  }
), "SettingsButton"), _UpgradeFirmware = class _UpgradeFirmware extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      unlocked: !1,
      newVersion: "",
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "upgradeFirmware", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/unlock-bootloader").then((success2) => {
        this.setState({
          unlocked: success2,
          isConfirming: success2
        });
      }).catch(() => {
        this.setState({
          isConfirming: !1
        });
      });
    }, "upgradeFirmware"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({ activeDialog: !1 });
    }, "abort"));
  }
  componentDidMount() {
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
  }
  render() {
    const {
      t: t2,
      currentVersion,
      disabled: disabled2,
      asButton
    } = this.props, {
      unlocked,
      newVersion,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("upgradeFirmware.button")
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: () => this.setState({ activeDialog: !0 }),
          disabled: disabled2,
          optionalText: newVersion,
          children: t2("upgradeFirmware.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("upgradeFirmware.title"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.description", {
          currentVersion,
          newVersion
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.upgradeFirmware, children: t2("button.upgrade") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
        ] })
      ] }),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("upgradeFirmware.title"), includeDefault: !unlocked, children: unlocked ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.unlocked") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { style: { lineHeight: "1.5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked3") })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.locked", {
        currentVersion,
        newVersion
      }) }) })
    ] });
  }
};
__name(_UpgradeFirmware, "UpgradeFirmware");
let UpgradeFirmware = _UpgradeFirmware;
const UpgradeFirmware$1 = withTranslation()(UpgradeFirmware), _RequireUpgrade = class _RequireUpgrade extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null
    });
  }
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({ version }) => {
      this.setState({
        firmwareVersion: version.replace("v", "")
      });
    });
  }
  render() {
    const { t: t2, deviceID } = this.props, { firmwareVersion } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$k.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion, asButton: !0 }) })
      ] })
    ] }) });
  }
};
__name(_RequireUpgrade, "RequireUpgrade");
let RequireUpgrade = _RequireUpgrade;
const RequireUpgrade$1 = withTranslation()(RequireUpgrade), _Goal = class _Goal extends reactExports.Component {
  render() {
    const {
      t: t2,
      onCreate,
      onRestore
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("goal.paragraph") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onCreate, children: t2("goal.buttons.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: onRestore, children: t2("goal.buttons.restore") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) })
    ] }) });
  }
};
__name(_Goal, "Goal");
let Goal = _Goal;
const Goal$1 = withTranslation()(Goal), _SecurityInformation = class _SecurityInformation extends reactExports.Component {
  constructor(props) {
    super(props), this.handleStart = () => {
      this.setState({ showInfo: !1 });
    }, this.state = {
      showInfo: !0
    };
  }
  render() {
    const { t: t2, goBack, goal: goal2, children: children2 } = this.props, { showInfo } = this.state;
    return showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(`securityInformation.${goal2}.title`) }),
        goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$k.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description4") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$k.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description2") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("securityInformation.restore.description3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "warning", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("deviceTampered") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) })
    ] }) }) : children2;
  }
};
__name(_SecurityInformation, "SecurityInformation");
let SecurityInformation = _SecurityInformation;
const translatedSecutiryInformation = translate()(SecurityInformation), STATUS$1 = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
}), _SeedCreateNew = class _SeedCreateNew extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      showInfo: !0,
      status: STATUS$1.CHECKING,
      walletName: "",
      backupPassword: "",
      error: "",
      agreements: {
        password_change: !1,
        password_required: !1,
        funds_access: !1
      }
    });
    __publicField(this, "walletNameInput", reactExports.createRef());
    __publicField(this, "validate", /* @__PURE__ */ __name(() => !this.walletNameInput.current || !this.walletNameInput.current.validity.valid || !this.validAgreements() ? !1 : this.state.backupPassword && this.state.walletName !== "", "validate"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name(({ target }) => {
      this.setState({ [target.id]: target.value });
    }, "handleFormChange"));
    __publicField(this, "handleSubmit", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ status: STATUS$1.CREATING, error: "" }), apiPost("devices/" + this.props.deviceID + "/create-wallet", {
        walletName: this.state.walletName,
        backupPassword: this.state.backupPassword
      }).then((data) => {
        data.success ? this.props.onSuccess() : this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t(`seed.error.e${data.code}`, {
            defaultValue: data.errorMessage
          })
        }), this.setState({ backupPassword: "" });
      }));
    }, "handleSubmit"));
    __publicField(this, "setValidBackupPassword", /* @__PURE__ */ __name((backupPassword) => {
      this.setState({ backupPassword });
    }, "setValidBackupPassword"));
    __publicField(this, "validAgreements", /* @__PURE__ */ __name(() => {
      const { agreements: agreements2 } = this.state;
      return !Object.keys(agreements2).map((agr) => agreements2[agr]).includes(!1);
    }, "validAgreements"));
    __publicField(this, "handleAgreementChange", /* @__PURE__ */ __name(({ target }) => {
      this.setState((state) => ({ agreements: {
        ...state.agreements,
        [target.id]: target.checked
      } }));
    }, "handleAgreementChange"));
    __publicField(this, "checkSDcard", /* @__PURE__ */ __name(() => {
      getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
        if (sdcard)
          return this.setState({ status: STATUS$1.DEFAULT, error: "" });
        this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t("seed.error.e200")
        }), setTimeout(this.checkSDcard, 2500);
      });
    }, "checkSDcard"));
    __publicField(this, "handleStart", /* @__PURE__ */ __name(() => {
      this.setState({ showInfo: !1 }), this.checkSDcard();
    }, "handleStart"));
  }
  componentDidMount() {
    this.checkSDcard();
  }
  renderSpinner() {
    switch (this.state.status) {
      case STATUS$1.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("checkSDcard") });
      case STATUS$1.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      goBack
    } = this.props, {
      showInfo,
      status: status2,
      walletName,
      error: error3,
      agreements: agreements2
    } = this.state, content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: this.handleStart,
            disabled: status2 !== STATUS$1.DEFAULT,
            children: t2("seed.info.button")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            pattern: "^[0-9a-zA-Z-_]{1,31}$",
            autoFocus: !0,
            id: "walletName",
            label: t2("seed.walletName.label"),
            disabled: status2 === STATUS$1.CREATING,
            onInput: this.handleFormChange,
            ref: this.walletNameInput,
            value: walletName
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PasswordRepeatInput,
          {
            label: t2("seed.password.label"),
            repeatPlaceholder: t2("seed.password.repeatPlaceholder"),
            disabled: status2 === STATUS$1.CREATING,
            onValidPassword: this.setValidBackupPassword
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$k.agreements, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { width: 18, marginRight: 10, position: "relative", bottom: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$k.agreementsLabel, children: t2("seed.description") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_change",
            label: t2("seed.agreements.password-change"),
            checked: agreements2.password_change,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_required",
            label: t2("seed.agreements.password-required"),
            checked: agreements2.password_required,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "funds_access",
            label: t2("seed.agreements.funds-access"),
            checked: agreements2.funds_access,
            onChange: this.handleAgreementChange
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: !0,
            disabled: !this.validate() || status2 === STATUS$1.CREATING,
            children: t2("seed.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2("seed.info.title") }),
          error3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS$1.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }),
          content2,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
};
__name(_SeedCreateNew, "SeedCreateNew");
let SeedCreateNew = _SeedCreateNew;
const SeedCreateNew$1 = withTranslation()(SeedCreateNew), convertDateToLocaleString = /* @__PURE__ */ __name((date2, language2) => new Date(date2).toLocaleString(language2, {
  weekday: "long",
  year: "numeric",
  month: "long",
  day: "numeric",
  hour: "2-digit",
  minute: "2-digit"
}), "convertDateToLocaleString"), stepContext = "_stepContext_g2o2c_1", backupsList = "_backupsList_g2o2c_5", listContainer$1 = "_listContainer_g2o2c_14", item$1 = "_item_g2o2c_24", agreements = "_agreements_g2o2c_37", emptyText = "_emptyText_g2o2c_41", backupItem = "_backupItem_g2o2c_47", backupID = "_backupID_g2o2c_52", backupButtons = "_backupButtons_g2o2c_59", backupStyle = {
  stepContext,
  backupsList,
  listContainer: listContainer$1,
  item: item$1,
  agreements,
  emptyText,
  backupItem,
  backupID,
  backupButtons
}, BackupsListItem = /* @__PURE__ */ __name(({
  backup: backup2,
  disabled: disabled2,
  handleChange,
  onFocus: onFocus2,
  radio: radio2,
  selectedBackup
}) => {
  let date2 = "";
  return backup2.date && backup2.date !== "" ? date2 = convertDateToLocaleString(backup2.date, instance.language) : date2 = "unknown", radio2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Radio,
    {
      disabled: !!disabled2,
      checked: selectedBackup === backup2.id,
      onChange: (event2) => {
        handleChange && handleChange(event2.target.value);
      },
      id: backup2.id,
      label: backup2.name && backup2.name !== "" ? backup2.name : backup2.id,
      value: backup2.id,
      onFocus: onFocus2,
      className: backupStyle.backupItem,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-small text-gray", children: date2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-small text-gray", children: [
          "ID: ",
          backup2.id
        ] })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-medium m-bottom-quarter", children: backup2.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupID, children: [
      "ID: ",
      backup2.id
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-small text-gray", children: date2 })
  ] });
}, "BackupsListItem");
var _a44;
let Check$1 = (_a44 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: null,
      activeDialog: !1,
      message: null
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        password: null,
        activeDialog: !1,
        message: null
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.props.selectedBackup && this.state.password, "validate"));
    __publicField(this, "check", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ message: this.props.t("backup.check.checking") }), apiPost("devices/" + this.props.deviceID + "/backups/check", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).catch(() => {
      }).then(({ success: success2, matches, errorMessage }) => {
        let message2;
        success2 ? matches ? message2 = this.props.t("backup.check.ok") : message2 = this.props.t("backup.check.notOK") : errorMessage && (message2 = errorMessage), this.setState({ message: message2 });
      }));
    }, "check"));
    __publicField(this, "setValidPassword", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "setValidPassword"));
  }
  render() {
    const {
      t: t2,
      selectedBackup
    } = this.props, {
      activeDialog,
      message: message2
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          secondary: !0,
          disabled: selectedBackup === null,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.check")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.check.title"),
          onClose: this.abort,
          children: message2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { minHeight: "3rem" }, children: message2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$10.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.check, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordSingleInput,
              {
                label: t2("backup.check.password.label"),
                placeholder: t2("backup.check.password.placeholder"),
                showLabel: t2("backup.check.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: !0, disabled: !this.validate(), children: t2("button.check") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
            ] })
          ] })
        }
      )
    ] });
  }
}, __name(_a44, "Check"), _a44);
const Check$2 = withTranslation()(Check$1);
var _a45;
let Create$1 = (_a45 = class extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      waiting: !1,
      backupName: "",
      recoveryPassword: "",
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        waiting: !1,
        backupName: "",
        recoveryPassword: "",
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => !this.state.waiting && this.state.backupName !== "", "validate"));
    __publicField(this, "create", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({ waiting: !0 }), apiPost("devices/" + this.props.deviceID + "/backups/create", {
        backupName: this.state.backupName,
        recoveryPassword: this.state.recoveryPassword
      }).then((data) => {
        this.abort(), data.success ? (this.props.onCreate(), data.verification || alertUser(this.props.t("backup.create.verificationFailed"))) : alertUser(data.errorMessage);
      }));
    }, "create"));
  }
  render() {
    const { t: t2 } = this.props, {
      waiting,
      recoveryPassword,
      backupName,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.create")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.create.title"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.create, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: !0,
                id: "backupName",
                label: t2("backup.create.name.label"),
                placeholder: t2("backup.create.name.placeholder"),
                onInput: this.handleFormChange,
                value: backupName
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.create.info") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                id: "recoveryPassword",
                label: t2("backup.create.password.label"),
                placeholder: t2("backup.create.password.placeholder"),
                onInput: this.handleFormChange,
                value: recoveryPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: !0, disabled: waiting || !this.validate(), children: t2("button.create") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.abort") })
            ] })
          ] })
        }
      )
    ] });
  }
}, __name(_a45, "Create"), _a45);
const Create$2 = withTranslation()(Create$1), _Restore = class _Restore extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      isConfirming: !1,
      activeDialog: !1,
      isLoading: !1,
      understand: !1,
      password: void 0
    }, this.abort = () => {
      this.setState({
        isConfirming: !1,
        activeDialog: !1,
        isLoading: !1,
        understand: !1,
        password: void 0
      });
    }, this.validate = () => this.props.selectedBackup && this.state.password, this.restore = (event2) => {
      event2.preventDefault(), this.validate() && (this.props.requireConfirmation ? this.setState({
        activeDialog: !1,
        isConfirming: !0
      }) : this.setState({
        activeDialog: !1,
        isLoading: !0
      }), apiPost("devices/" + this.props.deviceID + "/backups/restore", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).then((data) => {
        const { success: success2, didRestore, errorMessage, code } = data;
        if (this.abort(), success2) {
          if (didRestore) {
            if (this.props.onRestore)
              return this.props.onRestore();
            console.info("restore.jsx route to /"), route("/", !0);
          }
        } else
          alertUser(this.props.t(`backup.restore.error.e${code}`, {
            defaultValue: errorMessage
          }));
      }));
    }, this.handleUnderstandChange = (e2) => {
      this.setState({ understand: e2.target.checked });
    }, this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
  }
  render() {
    const {
      t: t2,
      selectedBackup,
      requireConfirmation
    } = this.props, {
      isConfirming,
      activeDialog,
      isLoading,
      understand
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          ...requireConfirmation ? { danger: !0 } : { primary: !0 },
          disabled: !selectedBackup,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.restore")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.restore.title"),
          disableEscape: isConfirming || isLoading,
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.restore, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                label: t2("backup.restore.password.label"),
                placeholder: t2("backup.restore.password.placeholder"),
                repeatPlaceholder: t2("backup.restore.password.repeatPlaceholder"),
                showLabel: t2("backup.restore.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("backup.restore.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "submit",
                  ...requireConfirmation ? { danger: !0 } : { primary: !0 },
                  disabled: !understand || !this.validate() || isConfirming,
                  children: t2("button.restore")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: this.abort,
                  disabled: isConfirming,
                  children: t2("button.back")
                }
              )
            ] })
          ] })
        }
      ),
      isConfirming && requireConfirmation && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.restore.confirmTitle") }),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("backup.restore.restoring") })
    ] });
  }
};
__name(_Restore, "Restore");
let Restore = _Restore;
const TranslatedRestore = translate()(Restore), _Backups = class _Backups extends reactExports.Component {
  constructor(props) {
    super(props), this.scrollableContainer = reactExports.createRef(), this.refresh = () => {
      getDeviceInfo$1(this.props.deviceID).then(({ lock }) => this.setState({ lock })), apiGet("devices/" + this.props.deviceID + "/backups/list").then(({ sdCardInserted, backupList, success: success2, errorMessage }) => {
        success2 ? this.setState({
          sdCardInserted,
          backupList
        }) : errorMessage && alertUser(errorMessage);
      });
    }, this.handleBackuplistChange = (backupID2) => {
      this.setState({ selectedBackup: backupID2 });
    }, this.scrollIntoView = (event2) => {
      if (!this.scrollableContainer.current)
        return;
      const target = event2.target, offsetTop = target.offsetTop, offsetHeight = target.parentNode.offsetHeight;
      if (offsetTop > this.scrollableContainer.current.scrollTop + offsetHeight)
        return;
      const top = Math.max(offsetTop + offsetHeight - this.scrollableContainer.current.offsetHeight, 0);
      this.scrollableContainer.current.scroll({ top, behavior: "smooth" });
    }, this.state = {
      backupList: [],
      sdCardInserted: null
    };
  }
  componentDidMount() {
    this.refresh();
  }
  render() {
    const {
      t: t2,
      children: children2,
      showCreate = !1,
      showRestore = !0,
      deviceID,
      requireConfirmation = !0,
      onRestore
    } = this.props, { backupList, selectedBackup, sdCardInserted, lock } = this.state;
    return lock === void 0 ? null : sdCardInserted === !1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("backup.insert") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.refresh, children: t2("backup.insertButton") }),
        children2
      ] })
    ] }) : sdCardInserted ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("backup.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, ref: this.scrollableContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backupList.length ? backupList.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: backup2,
          selectedBackup,
          handleChange: this.handleBackuplistChange,
          onFocus: this.scrollIntoView,
          radio: !0
        }
      ) }, backup2.id)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: backupStyle.emptyText, children: t2("backup.noBackups") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        showCreate && !lock && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Create$2,
          {
            onCreate: this.refresh,
            deviceID
          }
        ),
        showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Check$2,
          {
            selectedBackup,
            deviceID
          }
        ),
        showRestore && onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedRestore,
          {
            selectedBackup,
            deviceID,
            onRestore,
            requireConfirmation
          }
        ),
        children2
      ] })
    ] }) : null;
  }
};
__name(_Backups, "Backups");
let Backups = _Backups;
const TranslatedBackups = translate()(Backups), STATUS = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
}), _SeedRestore = class _SeedRestore extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      showInfo: !0,
      status: STATUS.CHECKING,
      error: ""
    });
    __publicField(this, "checkSDcard", /* @__PURE__ */ __name(() => {
      getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
        if (sdcard)
          return this.setState({ status: STATUS.DEFAULT, error: "" });
        this.setState({
          status: STATUS.ERROR,
          error: this.props.t("seedRestore.error.e200")
        }), setTimeout(this.checkSDcard, 2500);
      });
    }, "checkSDcard"));
    __publicField(this, "handleStart", /* @__PURE__ */ __name(() => {
      this.setState({ showInfo: !1 }), this.checkSDcard();
    }, "handleStart"));
  }
  componentDidMount() {
    this.checkSDcard();
  }
  renderSpinner() {
    switch (this.state.status) {
      case STATUS.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("checkSDcard") });
      case STATUS.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      deviceID,
      goBack,
      onSuccess
    } = this.props, {
      showInfo,
      status: status2,
      error: error3
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2("seedRestore.info.title") }),
          error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }) : null,
          showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description3") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seedRestore.info.description4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  onClick: this.handleStart,
                  disabled: status2 !== STATUS.DEFAULT,
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              showCreate: !1,
              deviceID,
              requireConfirmation: !1,
              onRestore: onSuccess,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: !0,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
};
__name(_SeedRestore, "SeedRestore");
let SeedRestore = _SeedRestore;
const SeedRestore$1 = withTranslation()(SeedRestore), stateEnum = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
}), _Initialize = class _Initialize extends reactExports.Component {
  constructor(props) {
    super(props), this.handleSubmit = (event2) => {
      event2.preventDefault(), this.state.password && (this.setState({
        status: stateEnum.WAITING,
        errorCode: null,
        errorMessage: ""
      }), apiPost("devices/" + this.props.deviceID + "/set-password", {
        password: this.state.password
      }).then((data) => {
        data.success || (data.code && this.setState({ errorCode: data.code }), this.setState({
          status: stateEnum.ERROR,
          errorMessage: data.errorMessage
        }));
      }));
    }, this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    }, this.handleStart = () => {
      this.setState({ showInfo: !1 });
    }, this.state = {
      showInfo: !0,
      password: null,
      status: stateEnum.DEFAULT,
      errorCode: null,
      errorMessage: ""
    };
  }
  render() {
    const { t: t2, goBack } = this.props, { showInfo, password: password2, status: status2, errorCode, errorMessage } = this.state;
    let formSubmissionState;
    switch (status2) {
      case stateEnum.DEFAULT:
        formSubmissionState = null;
        break;
      case stateEnum.WAITING:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("initialize.creating") });
        break;
      case stateEnum.ERROR:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`initialize.error.e${errorCode}`, {
          defaultValue: errorMessage
        }) });
    }
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("initialize.info.subtitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("initialize.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleStart, children: t2("button.continue") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordRepeatInput,
        {
          pattern: "^.{4,}$",
          label: t2("initialize.input.label"),
          repeatLabel: t2("initialize.input.labelRepeat"),
          repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
          disabled: status2 === stateEnum.WAITING,
          onValidPassword: this.setValidPassword
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: !0,
            disabled: !password2 || status2 === stateEnum.WAITING,
            children: t2("initialize.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(showInfo ? "initialize.info.title" : "setup") }),
        formSubmissionState,
        content2,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] }) }),
      status2 === stateEnum.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !1, text: t2("initialize.creating") })
    ] }) });
  }
};
__name(_Initialize, "Initialize");
let Initialize = _Initialize;
const TranslatedInitialize = translate()(Initialize), _Success = class _Success extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "handleGetStarted", /* @__PURE__ */ __name(() => {
      route("/account-summary", !0);
    }, "handleGetStarted"));
  }
  render() {
    const {
      t: t2,
      handleHideSuccess,
      goal: goal2
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$k.title, "text-center"].join(" "), children: t2(`success.${goal2}.title`) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { textAlign: "center" }, children: t2(`success.${goal2}.summary`) }),
          goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$k.summary, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info3") })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.handleGetStarted, children: t2("success.getstarted") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: handleHideSuccess, children: t2("sidebar.device") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: !0 }) })
      ] })
    ] }) }) });
  }
};
__name(_Success, "Success");
let Success = _Success;
const Success$1 = withTranslation()(Success), _Blink = class _Blink extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "blinkDevice", /* @__PURE__ */ __name(() => {
      apiPost("devices/" + this.props.deviceID + "/blink");
    }, "blinkDevice"));
  }
  render() {
    const { t: t2 } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.blinkDevice, children: t2("blink.button") });
  }
};
__name(_Blink, "Blink");
let Blink = _Blink;
const Blink$1 = withTranslation()(Blink), _LegacyHiddenWallet = class _LegacyHiddenWallet extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "toggle", /* @__PURE__ */ __name(() => {
      const newValue = !this.props.newHiddenWallet;
      apiPost("devices/" + this.props.deviceID + "/feature-set", {
        new_hidden_wallet: newValue
      }).then(() => {
        alertUser(newValue ? this.props.t("legacyhiddenwallet.successDisable") : this.props.t("legacyhiddenwallet.successEnable")), this.props.onChange && this.props.onChange(newValue);
      });
    }, "toggle"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      newHiddenWallet
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        danger: !0,
        disabled: disabled2,
        onclick: this.toggle,
        children: t2(newHiddenWallet ? "legacyhiddenwallet.enable" : "legacyhiddenwallet.disable")
      }
    );
  }
};
__name(_LegacyHiddenWallet, "LegacyHiddenWallet");
let LegacyHiddenWallet = _LegacyHiddenWallet;
const LegacyHiddenWallet$1 = withTranslation()(LegacyHiddenWallet), _RandomNumber = class _RandomNumber extends reactExports.Component {
  constructor(props) {
    super(props);
    __publicField(this, "getRandomNumber", /* @__PURE__ */ __name(() => {
      apiPost(this.props.apiPrefix + "/random-number").then((number) => {
        this.setState({
          active: !0,
          number
        });
      });
    }, "getRandomNumber"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        active: !1,
        number: void 0
      });
    }, "abort"));
    this.state = {
      active: !1,
      number: ""
    };
  }
  render() {
    const { t: t2 } = this.props, { number, active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.getRandomNumber, children: t2("random.button") }),
      // @ts-ignore Object is possibly 'undefined'.
      active2 && number ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: "Generate Random Number", onClose: this.abort, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("random.description", {
            // @ts-ignore
            bits: number.length * 4
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: number, flexibleHeight: !0 })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.abort, children: t2("button.ok") }) })
      ] }) : null
    ] });
  }
};
__name(_RandomNumber, "RandomNumber");
let RandomNumber = _RandomNumber;
const RandomNumber$1 = withTranslation()(RandomNumber), _HiddenWallet = class _HiddenWallet extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      password: null,
      pin: null,
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        password: null,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "handleFormChange", /* @__PURE__ */ __name((event2) => {
      this.setState({ [event2.target.id]: event2.target.value });
    }, "handleFormChange"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.password && this.state.pin, "validate"));
    __publicField(this, "createHiddenWallet", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/set-hidden-password", {
        pin: this.state.pin,
        backupPassword: this.state.password
      }).catch(() => {
      }).then(({ success: success2, didCreate, errorMessage, code }) => {
        this.abort(), success2 ? didCreate && alertUser(this.props.t("hiddenWallet.success")) : alertUser(this.props.t(`bitbox.error.e${code}`, {
          defaultValue: errorMessage
        }));
      }));
    }, "createHiddenWallet"));
    __publicField(this, "setValidPassword", /* @__PURE__ */ __name((password2) => {
      this.setState({ password: password2 });
    }, "setValidPassword"));
    __publicField(this, "setValidPIN", /* @__PURE__ */ __name((pin) => {
      this.setState({ pin });
    }, "setValidPIN"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props, {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.hiddenwallet")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("button.hiddenwallet"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info1HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info2HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.createHiddenWallet, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "pin",
                  pattern: "^.{4,}$",
                  label: t2("hiddenWallet.pinLabel"),
                  repeatLabel: t2("hiddenWallet.pinRepeatLabel"),
                  repeatPlaceholder: t2("hiddenWallet.pinRepeatPlaceholder"),
                  onValidPassword: this.setValidPIN
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "password",
                  label: t2("hiddenWallet.passwordLabel"),
                  repeatPlaceholder: t2("hiddenWallet.passwordPlaceholder"),
                  onValidPassword: this.setValidPassword
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: !0, disabled: !this.validate() || isConfirming, children: t2("button.hiddenwallet") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.abort") })
              ] })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.hiddenwallet") })
    ] });
  }
};
__name(_HiddenWallet, "HiddenWallet");
let HiddenWallet = _HiddenWallet;
const HiddenWallet$1 = withTranslation()(HiddenWallet), _ChangePIN = class _ChangePIN extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      oldPIN: null,
      newPIN: null,
      errorCode: null,
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        oldPIN: null,
        newPIN: null,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
    __publicField(this, "validate", /* @__PURE__ */ __name(() => this.state.newPIN && this.state.oldPIN, "validate"));
    __publicField(this, "changePin", /* @__PURE__ */ __name((event2) => {
      event2.preventDefault(), this.validate() && (this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/change-password", {
        oldPIN: this.state.oldPIN,
        newPIN: this.state.newPIN
      }).catch(() => {
      }).then((data) => {
        this.abort(), data.success || alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }));
    }, "changePin"));
    __publicField(this, "setValidOldPIN", /* @__PURE__ */ __name((e2) => {
      this.setState({ oldPIN: e2.target.value });
    }, "setValidOldPIN"));
    __publicField(this, "setValidNewPIN", /* @__PURE__ */ __name((newPIN) => {
      this.setState({ newPIN });
    }, "setValidNewPIN"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props, {
      oldPIN,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: !0 }),
          children: t2("button.changepin")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("button.changepin"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.changePin, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "oldPIN",
                label: t2("changePin.oldLabel"),
                value: oldPIN,
                onInput: this.setValidOldPIN
              }
            ),
            t2("changePin.newTitle") && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("changePin.newTitle") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                idPrefix: "newPIN",
                pattern: "^.{4,}$",
                label: t2("initialize.input.label"),
                repeatLabel: t2("initialize.input.labelRepeat"),
                repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
                onValidPassword: this.setValidNewPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: !0, disabled: !this.validate() || isConfirming, children: t2("button.changepin") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ] })
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.changepin") })
    ] });
  }
};
__name(_ChangePIN, "ChangePIN");
let ChangePIN = _ChangePIN;
const ChangePIN$1 = withTranslation()(ChangePIN), _Reset = class _Reset extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      pin: null,
      isConfirming: !1,
      activeDialog: !1,
      understand: !1
    });
    __publicField(this, "handleUnderstandChange", /* @__PURE__ */ __name((e2) => {
      this.setState({ understand: e2.target.checked });
    }, "handleUnderstandChange"));
    __publicField(this, "resetDevice", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/reset", { pin: this.state.pin }).then((data) => {
        this.abort(), data.success ? data.didReset && route("/", !0) : data.errorMessage && alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      });
    }, "resetDevice"));
    __publicField(this, "setValidPIN", /* @__PURE__ */ __name((e2) => {
      this.setState({ pin: e2.target.value });
    }, "setValidPIN"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({
        pin: null,
        understand: !1,
        isConfirming: !1,
        activeDialog: !1
      });
    }, "abort"));
  }
  render() {
    const { t: t2 } = this.props, {
      isConfirming,
      activeDialog,
      understand,
      pin
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { danger: !0, onClick: () => this.setState({ activeDialog: !0 }), children: t2("reset.title") }),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("reset.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "pin",
                label: t2("initialize.input.label"),
                value: pin,
                onInput: this.setValidPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$k.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("reset.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, disabled: !pin || !understand, onClick: this.resetDevice, children: t2("reset.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("reset.title") }) : null
    ] });
  }
};
__name(_Reset, "Reset");
let Reset = _Reset;
const Reset$1 = withTranslation()(Reset), appStoreBadge = "" + new URL("app-store-badge.svg", import.meta.url).href, playStoreBadge = "" + new URL("google-play-badge.png", import.meta.url).href, _MobilePairing = class _MobilePairing extends reactExports.Component {
  constructor(props) {
    super(props), this.onDeviceStatus = (payload) => {
      if ("type" in payload) {
        const { type: type2, data, deviceID } = payload;
        if (type2 === "device" && deviceID === this.props.deviceID)
          switch (data) {
            case "pairingStarted":
              this.setState({ status: "started" });
              break;
            case "pairingTimedout":
              this.state.status && this.setState({ status: "timeout" });
              break;
            case "pairingPullMessageFailed":
              this.setState({ status: "pullFailed" });
              break;
            case "pairingScanningFailed":
              this.setState({ status: "scanningFailed" });
              break;
            case "pairingAborted":
              this.setState({ status: "aborted" });
              break;
            case "pairingError":
              this.setState({ status: "error" });
              break;
            case "pairingSuccess":
              this.setState({ status: "success" });
              break;
          }
      }
    }, this.reconnectUnpaired = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        response && apiPost("devices/" + this.props.deviceID + "/feature-set", {
          pairing: !0
        }).then(() => {
          this.props.onPairingEnabled(), alertUser(this.props.t("pairing.success.text"));
        });
      });
    }, this.startPairing = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        response && (this.setState({
          channel: null,
          status: "loading"
        }), apiPost("devices/" + this.props.deviceID + "/pairing/start").then((channel) => {
          this.props.deviceLocked ? this.setState({
            channel,
            status: "connectOnly"
          }) : this.setState({
            channel,
            status: "start"
          });
        }));
      });
    }, this.abort = () => {
      this.setState({
        showQRCode: !1,
        status: !1
      });
    }, this.toggleQRCode = () => {
      this.setState({ showQRCode: !this.state.showQRCode });
    }, this.state = {
      channel: null,
      status: !1,
      showQRCode: !1
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onDeviceStatus);
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const { t: t2, deviceLocked, paired, hasMobileChannel: hasMobileChannel2 } = this.props, { channel, status: status2, showQRCode } = this.state;
    let content2;
    return status2 === "start" ? content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "1." }),
          " ",
          t2("pairing.start.step1")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.toggleQRCode, className: "width-1-1", children: t2(`pairing.start.${showQRCode ? "hideAppQRCode" : "revealAppQRCode"}`) }) }),
        showQRCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Apple App Store" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", size: 148 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: appStoreBadge, className: style$k.badge }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Google Play Store" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", size: 148 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playStoreBadge, className: style$k.badge }) })
            ] })
          ] })
        ] }) }) : null
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "2." }),
          t2("pairing.start.step2")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: JSON.stringify(channel), size: 196 }) })
      ] }) })
    ] }) : status2 === "connectOnly" ? content2 = /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: JSON.stringify({ channel, connectOnly: !0 }) }) : content2 = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2(`pairing.${status2}.text`) }), /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: hasMobileChannel2 && !paired ? this.reconnectUnpaired : this.startPairing,
          optionalText: t2(`deviceSettings.pairing.status.${paired}`),
          children: t2(deviceLocked ? hasMobileChannel2 ? "pairing.reconnectOnly.button" : "pairing.connectOnly.button" : hasMobileChannel2 && !paired ? "pairing.reconnectOnly.button" : "pairing.button")
        }
      ),
      status2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("pairing.title"),
          onClose: this.abort,
          medium: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-center flex-items-center", children: channel ? content2 : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("loading") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") }) })
          ]
        }
      )
    ] });
  }
};
__name(_MobilePairing, "MobilePairing");
let MobilePairing = _MobilePairing;
const translatedMobilePairing = translate()(MobilePairing), _DeviceLock = class _DeviceLock extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      isConfirming: !1,
      activeDialog: !1
    });
    __publicField(this, "resetDevice", /* @__PURE__ */ __name(() => {
      this.setState({
        activeDialog: !1,
        isConfirming: !0
      }), apiPost("devices/" + this.props.deviceID + "/lock").then((didLock) => {
        this.setState({
          isConfirming: !1
        }), didLock && this.props.onLock();
      });
    }, "resetDevice"));
    __publicField(this, "abort", /* @__PURE__ */ __name(() => {
      this.setState({ activeDialog: !1 });
    }, "abort"));
  }
  render() {
    const {
      t: t2,
      disabled: disabled2,
      lock
    } = this.props, {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          danger: !0,
          onClick: () => this.setState({ activeDialog: !0 }),
          disabled: disabled2,
          optionalText: t2(`deviceSettings.pairing.lock.${lock}`),
          children: t2("deviceLock.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("deviceLock.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$10.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, onClick: this.resetDevice, children: t2("deviceLock.confirm") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.abort, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("deviceLock.title") })
    ] });
  }
};
__name(_DeviceLock, "DeviceLock");
let DeviceLock = _DeviceLock;
const DeviceLock$1 = withTranslation()(DeviceLock), SettingsItem$1 = /* @__PURE__ */ __name(({ optionalText: optionalText2, optionalIcon, children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$j.container, style$j.item].join(" "), children: [
  children2,
  optionalText2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$j.optionalText, children: optionalText2 }),
  optionalIcon
] }), "SettingsItem$1"), _Settings = class _Settings extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null,
      newVersion: null,
      lock: !0,
      name: null,
      spinner: !0,
      sdcard: !1,
      serial: "",
      pairing: !1,
      mobileChannel: !1,
      connected: !1,
      newHiddenWallet: !0
    });
  }
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({
      lock,
      name,
      new_hidden_wallet,
      pairing: pairing2,
      sdcard,
      serial,
      version
    }) => {
      this.setState({
        firmwareVersion: version.replace("v", ""),
        lock,
        name,
        newHiddenWallet: new_hidden_wallet,
        pairing: pairing2,
        sdcard,
        serial,
        spinner: !1
      });
    }), apiGet("devices/" + this.props.deviceID + "/has-mobile-channel").then((mobileChannel) => {
      this.setState({ mobileChannel });
    }), apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    }), this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "device") {
        if (deviceID !== this.props.deviceID)
          return;
        switch (data) {
          case "mobileDisconnected":
            this.setState({ connected: !1 });
            break;
          case "mobileConnected":
            this.setState({ connected: !0 });
            break;
          case "pairingSuccess":
            this.setState({ pairing: !0, mobileChannel: !0 });
            break;
          case "pairingFalse":
            this.setState({ mobileChannel: !1 });
            break;
        }
      }
    });
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  render() {
    const {
      t: t2,
      deviceID
    } = this.props, {
      firmwareVersion,
      newVersion,
      lock,
      name,
      spinner: spinner4,
      sdcard,
      serial,
      pairing: pairing2,
      mobileChannel,
      connected,
      newHiddenWallet
    } = this.state, canUpgrade = firmwareVersion && newVersion !== firmwareVersion, paired = pairing2 && mobileChannel;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: name === null ? "" : name || "BitBox" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columnsContainer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.secrets.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: () => route(`/manage-backups/${deviceID}`), children: t2("deviceSettings.secrets.manageBackups") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChangePIN$1, { deviceID }),
                newHiddenWallet ? /* @__PURE__ */ jsxRuntimeExports.jsx(HiddenWallet$1, { deviceID, disabled: lock }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LegacyHiddenWallet$1,
                  {
                    deviceID,
                    newHiddenWallet,
                    disabled: lock,
                    onChange: (value) => this.setState({ newHiddenWallet: value })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Reset$1, { deviceID })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.pairing.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.pairing.mobile.${connected}`), children: t2("deviceSettings.pairing.mobile.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  translatedMobilePairing,
                  {
                    deviceID,
                    deviceLocked: lock,
                    hasMobileChannel: mobileChannel,
                    paired,
                    onPairingEnabled: () => this.setState({ pairing: !0 })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DeviceLock$1,
                  {
                    lock,
                    deviceID,
                    onLock: () => this.setState({ lock: !0 }),
                    disabled: lock || !paired
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.firmware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box slim divide", children: canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: `${t2("deviceSettings.firmware.version.label")} ${firmwareVersion || t2("loading")}`, children: t2("deviceSettings.firmware.upToDate") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.hardware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: serial, children: "Serial number" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.hardware.sdcard.${sdcard}`), children: t2("deviceSettings.hardware.sdcard.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(RandomNumber$1, { apiPrefix: "devices/" + deviceID }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Blink$1, { deviceID })
              ] })
            ] })
          ] })
        ] }) }),
        spinner4 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: t2("deviceSettings.loading") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectBitbox") }, "guide.bitbox.ejectBitbox"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectSD") }, "guide.bitbox.ejectSD"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.hiddenWallet") }, "guide.bitbox.hiddenWallet"),
        !lock && newHiddenWallet && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.legacyHiddenWallet"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LegacyHiddenWallet$1,
          {
            deviceID,
            newHiddenWallet,
            onChange: (value) => this.setState({ newHiddenWallet: value })
          }
        ) }) }, "guide.bitbox.legacyHiddenWallet"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.pairing") }, "guide.bitbox.pairing"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.2FA") }, "guide.bitbox.2FA"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.disable2FA") }, "guide.bitbox.disable2FA")
      ] })
    ] });
  }
};
__name(_Settings, "Settings");
let Settings = _Settings;
const Settings$1 = withTranslation()(Settings), DeviceStatus = Object.freeze({
  BOOTLOADER: "bootloader",
  INITIALIZED: "initialized",
  UNINITIALIZED: "uninitialized",
  LOGGED_IN: "logged_in",
  SEEDED: "seeded",
  REQUIRE_FIRMWARE_UPGRADE: "require_firmware_upgrade",
  REQUIRE_APP_UPGRADE: "require_app_upgrade"
}), GOAL = Object.freeze({
  CREATE: "create",
  RESTORE: "restore"
}), _Device = class _Device extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      firmwareVersion: null,
      deviceRegistered: !1,
      deviceStatus: "",
      goal: "",
      success: null
    });
    __publicField(this, "onDevicesRegisteredChanged", /* @__PURE__ */ __name(() => {
      apiGet("devices/registered").then((devices) => {
        const deviceRegistered = Object.keys(devices).includes(this.getDeviceID());
        this.setState({
          deviceRegistered,
          deviceStatus: null
        }, () => {
          this.state.deviceRegistered && this.onDeviceStatusChanged();
        });
      });
    }, "onDevicesRegisteredChanged"));
    __publicField(this, "onDeviceStatusChanged", /* @__PURE__ */ __name(() => {
      this.state.deviceRegistered && apiGet("devices/" + this.props.deviceID + "/status").then((deviceStatus) => {
        ["seeded", "initialized"].includes(deviceStatus) ? setSidebarStatus("") : setSidebarStatus("forceHidden"), this.setState({ deviceStatus });
      });
    }, "onDeviceStatusChanged"));
    __publicField(this, "handleCreate", /* @__PURE__ */ __name(() => {
      this.setState({ goal: GOAL.CREATE });
    }, "handleCreate"));
    __publicField(this, "handleRestore", /* @__PURE__ */ __name(() => {
      this.setState({ goal: GOAL.RESTORE });
    }, "handleRestore"));
    __publicField(this, "handleBack", /* @__PURE__ */ __name(() => {
      this.setState({ goal: null });
    }, "handleBack"));
    __publicField(this, "handleSuccess", /* @__PURE__ */ __name(() => {
      this.setState({ success: !0 });
    }, "handleSuccess"));
  }
  componentDidMount() {
    this.onDevicesRegisteredChanged(), this.onDeviceStatusChanged(), this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      type2 === "devices" && data === "registeredChanged" && this.onDevicesRegisteredChanged(), type2 === "device" && data === "statusChanged" && deviceID === this.getDeviceID() && this.onDeviceStatusChanged();
    });
  }
  componentWillUnmount() {
    this.unsubscribe && this.unsubscribe();
  }
  componentDidUpdate(prevProps) {
    this.props.deviceID !== prevProps.deviceID && this.onDevicesRegisteredChanged();
  }
  getDeviceID() {
    return this.props.deviceID || null;
  }
  render() {
    const {
      deviceID
    } = this.props, {
      deviceRegistered,
      deviceStatus,
      goal: goal2,
      success: success2
    } = this.state;
    if (!deviceRegistered || !deviceStatus)
      return null;
    if (success2)
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Success$1, { goal: goal2, handleHideSuccess: () => this.setState({ success: null }) });
    switch (deviceStatus) {
      case DeviceStatus.BOOTLOADER:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Bootloader$1, { deviceID });
      case DeviceStatus.REQUIRE_FIRMWARE_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RequireUpgrade$1, { deviceID });
      case DeviceStatus.REQUIRE_APP_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
      case DeviceStatus.INITIALIZED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Unlock$2, { deviceID });
      case DeviceStatus.UNINITIALIZED:
        return goal2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(translatedSecutiryInformation, { goal: goal2, goBack: this.handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedInitialize, { goBack: this.handleBack, deviceID }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
      case DeviceStatus.LOGGED_IN:
        switch (goal2) {
          case GOAL.CREATE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedCreateNew$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          case GOAL.RESTORE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedRestore$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
      case DeviceStatus.SEEDED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, { deviceID });
      default:
        return null;
    }
  }
};
__name(_Device, "Device");
let Device = _Device;
const BitBox01 = withTranslation()(Device), syncDeviceList = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("devices/registered", cb2), "syncDeviceList"), statusChanged = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("statusChanged", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2();
}), "statusChanged"), channelHashChanged = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("channelHashChanged", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2(deviceID);
}), "channelHashChanged"), attestationCheckDone = /* @__PURE__ */ __name((deviceID, cb2) => subscribe$1("attestationCheckDone", (event2) => {
  event2.type === "device" && event2.deviceID === deviceID && cb2(deviceID);
}), "attestationCheckDone"), container$b = "_container_6tizs_1", primaryText = "_primaryText_6tizs_21", isButton = "_isButton_6tizs_27", rightContentContainer = "_rightContentContainer_6tizs_32", displayedValue = "_displayedValue_6tizs_38", withMargin = "_withMargin_6tizs_47", secondaryText = "_secondaryText_6tizs_51", collapse = "_collapse_6tizs_74", hideDisplayedValueOnSmall = "_hideDisplayedValueOnSmall_6tizs_87", styles$h = {
  container: container$b,
  primaryText,
  isButton,
  rightContentContainer,
  displayedValue,
  withMargin,
  secondaryText,
  collapse,
  hideDisplayedValueOnSmall
}, SettingsItem = /* @__PURE__ */ __name(({
  className = "",
  collapseOnSmall = !1,
  displayedValue: displayedValue2 = "",
  extraComponent,
  hideDisplayedValueOnSmall: hideDisplayedValueOnSmall2 = !1,
  onClick,
  secondaryText: secondaryText2,
  settingName: settingName2
}) => {
  const notButton = onClick === void 0, rightContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.rightContentContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: `
        ${displayedValue2 ? styles$h.displayedValue : ""}
        ${extraComponent ? styles$h.withMargin : ""}
        ${hideDisplayedValueOnSmall2 ? styles$h.hideDisplayedValueOnSmall : ""}
       `,
        children: displayedValue2
      }
    ),
    extraComponent || null
  ] }), content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      typeof settingName2 == "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$h.primaryText, children: settingName2 }) : settingName2,
      secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$h.secondaryText, children: secondaryText2 }) : null
    ] }),
    rightContent
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: notButton ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$h.container} ${className} 
          ${collapseOnSmall ? styles$h.collapse : ""}`, children: content2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: `${styles$h.container} ${styles$h.isButton} ${className}`,
      onClick,
      children: content2
    }
  ) });
}, "SettingsItem"), container$a = "_container_1rta5_1", active$1 = "_active_1rta5_13", styles$g = {
  container: container$a,
  active: active$1
}, WithSettingsTabs = /* @__PURE__ */ __name(({
  children: children2,
  deviceIDs,
  hideMobileMenu,
  hasAccounts
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { hideMobileMenu, deviceIDs, hasAccounts }) }),
  children2
] }), "WithSettingsTabs"), Tab = /* @__PURE__ */ __name(({ name, url, hideMobileMenu }) => hideMobileMenu ? /* @__PURE__ */ jsxRuntimeExports.jsx(
  NavLink,
  {
    className: ({ isActive }) => isActive ? `${styles$g.active} hide-on-small` : "hide-on-small",
    to: url,
    children: name
  },
  url
) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "show-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  SettingsItem,
  {
    settingName: name,
    onClick: () => route(url),
    extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
  }
) }, url), "Tab"), Tabs = /* @__PURE__ */ __name(({ deviceIDs, hideMobileMenu, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.appearance"), url: "/settings/appearance" }, "appearance"),
    hasAccounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("manageAccounts.title"), url: "/settings/manage-accounts" }, "manage-accounts") : null,
    deviceIDs.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("sidebar.device"), url: `/settings/device-settings/${id2}` }, `device-${id2}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.advancedSettings"), url: "/settings/advanced-settings" }, "advanced-settings"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.about"), url: "/settings/about" }, "about")
  ] });
}, "Tabs"), ManageBackupSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/manage-backups/${deviceID}`),
      settingName: t2("backup.title"),
      secondaryText: t2("deviceSettings.backups.manageBackups.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
}, "ManageBackupSetting"), ShowRecoveryWordsSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [inProgress, setInProgress] = reactExports.useState(!1), [showDialog, setShowDialog] = reactExports.useState(!1), confirmShowWords = /* @__PURE__ */ __name(async () => {
    setShowDialog(!1), setInProgress(!0), await showMnemonic(deviceID), setInProgress(!1);
  }, "confirmShowWords");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("backup.showMnemonic.title"),
        secondaryText: t2("deviceSettings.backups.showRecoveryWords.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setShowDialog(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMnemonicWaitDialog, { inProgress }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("backup.showMnemonic.title"), open: showDialog, onClose: () => setShowDialog(!1), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MultilineMarkup,
        {
          markup: t2("backup.showMnemonic.description"),
          tagName: "span",
          withBreaks: !0
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: confirmShowWords, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => setShowDialog(!1), children: t2("dialog.cancel") })
      ] })
    ] })
  ] });
}, "ShowRecoveryWordsSetting"), ShowMnemonicWaitDialog = /* @__PURE__ */ __name(({ inProgress }) => {
  const { t: t2 } = useTranslation();
  return inProgress ? /* @__PURE__ */ jsxRuntimeExports.jsxs(TranslatedWaitDialog, { title: t2("backup.showMnemonic.title"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MultilineMarkup,
      {
        markup: t2("backup.showMnemonic.description"),
        tagName: "span",
        withBreaks: !0
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Interact.followInstructions") })
  ] }) : null;
}, "ShowMnemonicWaitDialog"), StartupSettingsWaitDialog = /* @__PURE__ */ __name(({ show: show2 }) => {
  const { t: t2 } = useTranslation();
  return show2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("bitbox02Settings.gotoStartupSettings.title"),
      children: t2("bitbox02Settings.gotoStartupSettings.description")
    }
  ) : null;
}, "StartupSettingsWaitDialog"), GoToStartupSettings = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [show2, setShow] = reactExports.useState(!1), handleGoToStartupSettings = /* @__PURE__ */ __name(async () => {
    setShow(!0), await apiPost(`devices/bitbox02/${deviceID}/goto-startup-settings`).catch(console.error), setShow(!1);
  }, "handleGoToStartupSettings");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.gotoStartupSettings.title"),
        secondaryText: t2("deviceSettings.expert.goToStartupSettings.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: handleGoToStartupSettings
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StartupSettingsWaitDialog, { show: show2 })
  ] });
}, "GoToStartupSettings"), PassphraseSetting = /* @__PURE__ */ __name(({ deviceID, passphraseEnabled }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/settings/device-settings/passphrase/${deviceID}`),
      settingName: t2("deviceSettings.expert.passphrase.title"),
      secondaryText: t2("deviceSettings.expert.passphrase.description"),
      displayedValue: t2(passphraseEnabled ? "generic.enabled_true" : "generic.enabled_false"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
}, "PassphraseSetting"), AttestationCheckSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const [attestation, setAttestation] = reactExports.useState(null), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    verifyAttestation(deviceID).then(setAttestation);
  }, [deviceID]);
  const icon2 = attestation ? /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { width: 20, height: 20 });
  return attestation === null ? /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.attestation.label"),
      secondaryText: t2("deviceSettings.deviceInformation.attestation.description"),
      extraComponent: icon2,
      displayedValue: t2(`deviceSettings.hardware.attestation.${attestation}`),
      hideDisplayedValueOnSmall: !0
    }
  );
}, "AttestationCheckSetting"), FirmwareSetting = /* @__PURE__ */ __name(({ deviceID, versionInfo, asButton = !1 }) => {
  const { t: t2 } = useTranslation(), [dialogOpen, setDialogOpen] = reactExports.useState(!1), [confirming, setConfirming] = reactExports.useState(!1), canUpgrade = versionInfo.canUpgrade, secondaryText2 = t2(canUpgrade ? "deviceSettings.firmware.upgradeAvailable" : "deviceSettings.firmware.upToDate"), extraComponent = canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}), handleOpenDialog = canUpgrade ? () => setDialogOpen(!0) : void 0, handleUpgradeFirmware = /* @__PURE__ */ __name(async () => {
    setConfirming(!0), await upgradeDeviceFirmware(deviceID), setConfirming(!1), setDialogOpen(!1);
  }, "handleUpgradeFirmware");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleOpenDialog,
        primary: !0,
        children: t2("button.upgrade")
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("deviceSettings.firmware.title"),
        secondaryText: secondaryText2,
        onClick: handleOpenDialog,
        displayedValue: versionInfo.currentVersion,
        extraComponent
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UpgradeDialog,
      {
        open: dialogOpen && canUpgrade,
        versionInfo,
        confirming,
        onUpgradeFirmware: handleUpgradeFirmware,
        onClose: () => setDialogOpen(!1)
      }
    )
  ] });
}, "FirmwareSetting"), UpgradeDialog = /* @__PURE__ */ __name(({
  open: open2,
  versionInfo,
  confirming,
  onUpgradeFirmware,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onClose, open: open2, title: t2("upgradeFirmware.title"), children: [
    confirming ? t2("confirmOnDevice") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("upgradeFirmware.description", {
      currentVersion: versionInfo.currentVersion,
      newVersion: versionInfo.newVersion
    }) }),
    !confirming && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: onUpgradeFirmware,
          children: t2("button.upgrade")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: onClose, children: t2("button.back") })
    ] })
  ] });
}, "UpgradeDialog"), SecureChipSetting = /* @__PURE__ */ __name(({ secureChipModel }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.securechip"),
      secondaryText: t2("deviceSettings.deviceInformation.securechip.description"),
      displayedValue: secureChipModel
    }
  );
}, "SecureChipSetting"), DeviceNameSetting = /* @__PURE__ */ __name(({ deviceName, deviceID }) => {
  const { t: t2 } = useTranslation(), [active2, setActive] = reactExports.useState(!1), [currentName, setCurrentName] = reactExports.useState(deviceName), [name, setName] = reactExports.useState(""), [inProgress, setInProgress] = reactExports.useState(!1), updateName = /* @__PURE__ */ __name(async () => {
    setInProgress(!0);
    try {
      const setNameResult = await setDeviceName(deviceID, name);
      if (!setNameResult.success)
        throw new Error(setNameResult.message);
      const deviceInfoResult = await getDeviceInfo(deviceID);
      if (!deviceInfoResult.success)
        throw new Error(deviceInfoResult.message);
      setCurrentName(deviceInfoResult.deviceInfo.name);
    } catch (error3) {
      alertUser(t2("bitbox02Settings.deviceName.error")), console.error(error3);
    } finally {
      setActive(!1), setInProgress(!1);
    }
  }, "updateName"), handleCloseDialog = /* @__PURE__ */ __name(() => {
    setActive(!1), setName("");
  }, "handleCloseDialog");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.deviceName.input"),
        secondaryText: t2("deviceSettings.deviceInformation.deviceName.description"),
        displayedValue: currentName,
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActive(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetDeviceNameDialog,
      {
        open: active2,
        onClose: handleCloseDialog,
        currentName,
        onInputChange: (e2) => setName(e2.target.value),
        name,
        handleUpdateName: updateName
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetDeviceNameWaitDialog, { inProgress })
  ] });
}, "DeviceNameSetting"), SetDeviceNameDialog = /* @__PURE__ */ __name(({ open: open2, onClose, currentName, onInputChange, name, handleUpdateName }) => {
  var _a46;
  const { t: t2 } = useTranslation(), inputRef = reactExports.useRef(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      onClose,
      title: t2("bitbox02Settings.deviceName.title"),
      small: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns half", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("bitbox02Settings.deviceName.current") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-half", children: currentName })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              pattern: "^.{0,63}$",
              label: t2("bitbox02Settings.deviceName.input"),
              onInput: onInputChange,
              ref: inputRef,
              placeholder: t2("bitbox02Settings.deviceName.placeholder"),
              value: name,
              id: "deviceName"
            }
          ) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            disabled: !(name && ((_a46 = inputRef == null ? void 0 : inputRef.current) != null && _a46.validity.valid)),
            onClick: handleUpdateName,
            children: t2("button.ok")
          }
        ) })
      ]
    }
  );
}, "SetDeviceNameDialog"), SetDeviceNameWaitDialog = /* @__PURE__ */ __name(({ inProgress }) => {
  const { t: t2 } = useTranslation();
  return inProgress ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: t2("bitbox02Interact.followInstructions") }) : null;
}, "SetDeviceNameWaitDialog"), settingNameContainer = "_settingNameContainer_usdew_1", settingName = "_settingName_usdew_1", styles$f = {
  settingNameContainer,
  settingName
}, FactoryResetSetting = /* @__PURE__ */ __name(({ deviceID }) => {
  const [understand, setUnderstand] = reactExports.useState(!1), [isConfirming, setIsConfirming] = reactExports.useState(!1), [activeDialog, setActiveDialog] = reactExports.useState(!1), { t: t2 } = useTranslation(), abort = /* @__PURE__ */ __name(() => {
    setUnderstand(!1), setIsConfirming(!1), setActiveDialog(!1);
  }, "abort"), handleUnderstandChange = /* @__PURE__ */ __name((e2) => {
    setUnderstand(e2.target.checked);
  }, "handleUnderstandChange"), reset2 = /* @__PURE__ */ __name(async () => {
    setActiveDialog(!1), setIsConfirming(!0);
    const responseData = await resetDevice(deviceID);
    abort(), responseData.success || alertUser(t2("reset.notReset"));
  }, "reset"), settingName2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.settingNameContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WarningOutlined, { width: 16, height: 16 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$f.settingName, children: t2("deviceSettings.expert.factoryReset.title") })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: settingName2,
        secondaryText: t2("deviceSettings.expert.factoryReset.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActiveDialog(!0)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FactoryResetDialog,
      {
        open: activeDialog,
        handleCloseDialog: abort,
        isConfirming,
        understand,
        handleUnderstandChange,
        handleReset: reset2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetWaitDialog, { isConfirming })
  ] });
}, "FactoryResetSetting"), FactoryResetDialog = /* @__PURE__ */ __name(({
  open: open2,
  handleCloseDialog,
  isConfirming,
  understand,
  handleUnderstandChange,
  handleReset
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      title: t2("reset.title"),
      onClose: handleCloseDialog,
      disabledClose: isConfirming,
      small: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: "reset_understand",
              label: t2("reset.understandBB02"),
              checked: understand,
              onChange: handleUnderstandChange
            }
          ) })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, disabled: !understand, onClick: handleReset, children: t2("reset.title") }) })
      ]
    }
  );
}, "FactoryResetDialog"), FactoryResetWaitDialog = /* @__PURE__ */ __name(({ isConfirming }) => {
  const { t: t2 } = useTranslation();
  return isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("reset.title"),
      children: t2("bitbox02Interact.followInstructions")
    }
  ) : null;
}, "FactoryResetWaitDialog"), RootFingerprintSetting = /* @__PURE__ */ __name(({ rootFingerprint }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: "Root fingerprint",
      secondaryText: t2("deviceSettings.deviceInformation.rootFingerprint.description"),
      displayedValue: rootFingerprint
    }
  );
}, "RootFingerprintSetting"), section = "_section_18i3w_1", skeletonWrapper = "_skeletonWrapper_18i3w_9", styles$e = {
  section,
  skeletonWrapper
}, getLink = /* @__PURE__ */ __name(() => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/bitbox02/sicherheit/#device-authenticity-check";
    case "es":
      return "https://bitbox.swiss/es/bitbox02/seguridad/#device-authenticity-check";
    default:
      return "https://bitbox.swiss/bitbox02/security-features/#device-authenticity-check";
  }
}, "getLink"), ManageDeviceGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.device.name") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.secure-chip.link.text"),
        url: "https://bitbox.swiss/blog/bitbox-05-2021-masnee-update/#check-your-secure-chip-variant"
      },
      text: t2("guide.device.secure-chip.text"),
      title: t2("guide.device.secure-chip.title")
    } }, "guide.device.secure-chip"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.attestation.link.text"),
        url: getLink()
      },
      text: t2("guide.device.attestation.text"),
      title: t2("guide.device.attestation.title")
    } }, "guide.device.attestation")
  ] });
}, "ManageDeviceGuide"), container$9 = "_container_flzib_1", backButton = "_backButton_flzib_7", headerText = "_headerText_flzib_31", withGuide = "_withGuide_flzib_40", styles$d = {
  container: container$9,
  backButton,
  headerText,
  withGuide
}, MobileHeader = /* @__PURE__ */ __name(({ title: title2, withGuide: withGuide2 = !1 }) => {
  const { t: t2 } = useTranslation(), handleClick = /* @__PURE__ */ __name(() => {
    route("/settings");
  }, "handleClick");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$d.container} ${withGuide2 ? `${styles$d.withGuide}` : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleClick, className: styles$d.backButton, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftDark, {}),
      " ",
      t2("button.back")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$d.headerText, children: title2 })
  ] });
}, "MobileHeader"), StyledSkeleton = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$e.skeletonWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "var(--item-height-xlarge)" }) }), "StyledSkeleton"), BB02Settings = /* @__PURE__ */ __name(({ deviceID, deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("sidebar.device") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: !0,
          hasAccounts,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { deviceID })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDeviceGuide, {})
  ] }) });
}, "BB02Settings"), Content = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [deviceInfo, setDeviceInfo] = reactExports.useState(), versionInfo = useLoad(() => getVersion(deviceID), [deviceID]), rootFingerprintResult = useLoad(() => getRootFingerprint(deviceID), [deviceID]);
  return reactExports.useEffect(() => {
    getDeviceInfo(deviceID).then((result) => {
      if (!result.success) {
        alertUser(t2("genericError"));
        return;
      }
      setDeviceInfo(result.deviceInfo);
    }).catch(console.error);
  }, [deviceID, t2]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.backups.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ManageBackupSetting, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ShowRecoveryWordsSetting, { deviceID })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.deviceInformation.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeviceNameSetting,
        {
          deviceName: deviceInfo.name,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AttestationCheckSetting, { deviceID }),
      versionInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        FirmwareSetting,
        {
          deviceID,
          versionInfo
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      deviceInfo && deviceInfo.securechipModel !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SecureChipSetting, { secureChipModel: deviceInfo.securechipModel }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      rootFingerprintResult && rootFingerprintResult.success ? /* @__PURE__ */ jsxRuntimeExports.jsx(RootFingerprintSetting, { rootFingerprint: rootFingerprintResult.rootFingerprint }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("settings.expert.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        PassphraseSetting,
        {
          passphraseEnabled: deviceInfo.mnemonicPassphraseEnabled,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(GoToStartupSettings, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetSetting, { deviceID })
    ] })
  ] });
}, "Content"), BitBox02 = /* @__PURE__ */ __name(({ deviceID, deviceIDs, hasAccounts }) => useSync(
  () => getStatus$1(deviceID),
  (cb2) => statusChanged(deviceID, () => {
    getStatus$1(deviceID).then(cb2);
  })
) !== "initialized" ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(BB02Settings, { deviceID, deviceIDs, hasAccounts }), "BitBox02"), getStatus = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02-bootloader/${deviceID}/status`), "getStatus"), syncStatus = /* @__PURE__ */ __name((deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02-bootloader/${deviceID}/status`, cb2), "syncStatus"), getVersionInfo = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02-bootloader/${deviceID}/version-info`), "getVersionInfo"), upgradeFirmware = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/upgrade-firmware`), "upgradeFirmware"), reboot = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/reboot`), "reboot"), screenRotate = /* @__PURE__ */ __name((deviceID) => apiPost(`devices/bitbox02-bootloader/${deviceID}/screen-rotate`), "screenRotate"), getShowFirmwareHash = /* @__PURE__ */ __name((deviceID) => () => apiGet(`devices/bitbox02-bootloader/${deviceID}/show-firmware-hash-enabled`), "getShowFirmwareHash"), setShowFirmwareHash = /* @__PURE__ */ __name((deviceID, enabled) => apiPost(
  `devices/bitbox02-bootloader/${deviceID}/set-firmware-hash-enabled`,
  enabled
), "setShowFirmwareHash"), container$8 = "_container_18axn_1", style$i = {
  container: container$8
}, CenteredContent = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$i.container, children: children2 }) }), "CenteredContent"), container$7 = "_container_14uup_1", slider = "_slider_14uup_16", style$h = {
  container: container$7,
  slider
}, Toggle = /* @__PURE__ */ __name(({
  className = "",
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `${style$h.container} ${className}`, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      ...props
    }
  ),
  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$h.slider })
] }), "Toggle"), ToggleShowFirmwareHash = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), [enabledState, setEnabledState] = reactExports.useState(!1), enabledConfig = useLoad(getShowFirmwareHash(deviceID));
  reactExports.useEffect(() => {
    enabledConfig !== void 0 && setEnabledState(enabledConfig);
  }, [enabledConfig]);
  const handleToggle = /* @__PURE__ */ __name((event2) => {
    const enabled = event2.target.checked;
    setShowFirmwareHash(deviceID, enabled), setEnabledState(enabled);
  }, "handleToggle");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bb02Bootloader.advanced.toggleShowFirmwareHash") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        checked: enabledState,
        id: "togggle-show-firmware-hash",
        onChange: handleToggle
      }
    )
  ] });
}, "ToggleShowFirmwareHash"), BitBox02Bootloader = /* @__PURE__ */ __name(({ deviceID }) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), status2 = useSync(
    () => getStatus(deviceID),
    syncStatus(deviceID)
  ), versionInfo = useLoad(() => getVersionInfo(deviceID));
  if (versionInfo === void 0)
    return null;
  let contents;
  if (status2 && status2.upgrading)
    if (status2.upgradeSuccessful)
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bb02Bootloader.success", {
        rebootSeconds: status2.rebootSeconds.toString(),
        context: versionInfo.erased ? "install" : ""
      }) }) });
    else {
      const value = Math.round(status2.progress * 100);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
          value,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bootloader.progress", {
          progress: value.toString(),
          context: versionInfo.erased ? "install" : ""
        }) })
      ] });
    }
  else
    contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", style: { minHeight: 390 }, children: [
      versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("welcome.getStarted") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        versionInfo.canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: () => upgradeFirmware(deviceID),
            children: t2("bootloader.button", { context: versionInfo.erased ? "install" : "" })
          }
        ) : null,
        !versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: !0,
            onClick: () => reboot(deviceID),
            children: t2("bb02Bootloader.abort", { context: versionInfo.canUpgrade ? "" : "noUpgrade" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-center", style: { marginTop: 32 }, children: [
        t2("bb02Bootloader.orientation"),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            onClick: () => screenRotate(deviceID),
            style: { textDecoration: "underline", cursor: "pointer" },
            children: t2("bb02Bootloader.flipscreen")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { children: t2("bb02Bootloader.advanced.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleShowFirmwareHash, { deviceID })
        ] })
      ] })
    ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredContent, { children: [
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Inverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02$1, {}),
    status2 && status2.errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: status2.errMsg }),
    contents
  ] });
}, "BitBox02Bootloader"), Waiting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$k.waitingText, children: t2("welcome.insertDevice") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$k.waitingDescription, children: t2("welcome.insertBitBox02") })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.welcome"), shown: !0 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.getDevice.link.text"),
          url: "https://bitbox.shop/"
        },
        text: t2("guide.waiting.getDevice.text"),
        title: t2("guide.waiting.getDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.lostDevice.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/5-backup/8-wie-kann-ich-ein-bitbox02-wallet-in-ein-drittanbieter-wallet-importieren" : "https://shiftcrypto.support/help/en-us/5-backup/8-how-do-i-restore-my-wallet-if-my-bitbox02-is-lost"
        },
        text: t2("guide.waiting.lostDevice.text"),
        title: t2("guide.waiting.lostDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.internet") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.deviceNotRecognized") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.useWithoutDevice") })
    ] })
  ] });
}, "Waiting"), DeviceSwitch = /* @__PURE__ */ __name(({ deviceID, devices, hasAccounts }) => {
  const deviceIDs = Object.keys(devices);
  if (deviceID === null || !deviceIDs.includes(deviceID))
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  switch (devices[deviceID]) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox01, { deviceID });
    case "bitbox02":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitBox02,
        {
          deviceID,
          deviceIDs,
          hasAccounts
        }
      );
    case "bitbox02-bootloader":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Bootloader, { deviceID });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
}, "DeviceSwitch"), getBackupList = /* @__PURE__ */ __name((deviceID) => apiGet(`devices/bitbox02/${deviceID}/backups/list`), "getBackupList"), subscribeBackupList = /* @__PURE__ */ __name((deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02/${deviceID}/backups/list`, cb2), "subscribeBackupList"), toast = "_toast_4ztjp_1", active = "_active_4ztjp_17", shifted = "_shifted_4ztjp_21", info = "_info_4ztjp_25", success$1 = "_success_4ztjp_29", warning$1 = "_warning_4ztjp_33", style$g = {
  toast,
  active,
  shifted,
  info,
  success: success$1,
  warning: warning$1
}, _Toast = class _Toast extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      active: !1
    });
    __publicField(this, "show", /* @__PURE__ */ __name(() => {
      this.setState({ active: !0 });
    }, "show"));
    __publicField(this, "hide", /* @__PURE__ */ __name(() => {
      this.setState({ active: !1 }), this.props.onHide && this.props.onHide();
    }, "hide"));
  }
  componentDidMount() {
    setTimeout(this.show, 5);
  }
  render() {
    const {
      theme,
      children: children2,
      withGuide: withGuide2
    } = this.props, { active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: [style$g.toast, style$g[theme], active2 ? style$g.active : "", withGuide2 ? style$g.shifted : ""].join(" "),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: children2 })
      }
    );
  }
};
__name(_Toast, "Toast");
let Toast = _Toast;
const Check = /* @__PURE__ */ __name(({ deviceID, backups, disabled: disabled2 }) => {
  const [activeDialog, setActiveDialog] = reactExports.useState(!1), [message2, setMessage] = reactExports.useState(""), [foundBackup, setFoundBackup] = reactExports.useState(), [userVerified, setUserVerified] = reactExports.useState(!1), { t: t2 } = useTranslation(), checkBackup$1 = /* @__PURE__ */ __name(async () => {
    setMessage(t2("backup.check.confirmTitle"));
    try {
      const result = await checkBackup(deviceID, !0);
      if (result.success) {
        const { backupID: backupID2 } = result, foundBackup2 = backups.find((backup2) => backup2.id === backupID2);
        if (!foundBackup2) {
          alertUser(t2("unknownError", { errorMessage: "Not found" }));
          return;
        }
        setActiveDialog(!0), setFoundBackup(foundBackup2);
      }
      if (!(await checkBackup(deviceID, !1)).success) {
        setActiveDialog(!0), setMessage(t2("backup.check.notOK")), setUserVerified(!0);
        return;
      }
      setMessage(t2("backup.check.success")), setUserVerified(!0);
    } catch (error3) {
      console.error(error3);
    }
  }, "checkBackup$1");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        disabled: disabled2,
        onClick: checkBackup$1,
        children: t2("button.check")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: activeDialog, title: message2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: (e2) => {
      e2.preventDefault(), setActiveDialog(!1), setUserVerified(!1);
    }, children: [
      foundBackup !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: foundBackup,
          radio: !1
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: userVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          autoFocus: !0,
          disabled: !userVerified,
          primary: !0,
          type: "submit",
          children: t2(userVerified ? "button.ok" : "accountInfo.verify")
        }
      ) })
    ] }) })
  ] });
}, "Check"), Create = /* @__PURE__ */ __name(({ deviceID }) => {
  const [creatingBackup, setCreatingBackup] = reactExports.useState(!1), [disabled2, setDisabled] = reactExports.useState(!1), { t: t2 } = useTranslation(), createBackup$1 = /* @__PURE__ */ __name(() => {
    setCreatingBackup(!0), createBackup(deviceID, "sdcard").then((result) => {
      setCreatingBackup(!1), setDisabled(!1), result.success || alertUser(t2("backup.create.fail"));
    }).catch(console.error);
  }, "createBackup$1"), maybeCreateBackup = /* @__PURE__ */ __name(async () => {
    setDisabled(!0);
    try {
      if ((await checkBackup(deviceID, !0)).success) {
        confirmation(t2("backup.create.alreadyExists"), (result) => {
          result ? createBackup$1() : setDisabled(!1);
        });
        return;
      }
      createBackup$1();
    } catch (error3) {
      console.error(error3);
    }
  }, "maybeCreateBackup");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: !0,
        disabled: disabled2,
        onClick: maybeCreateBackup,
        children: t2("backup.create.title")
      }
    ),
    creatingBackup && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.create.title"), children: t2("bitbox02Interact.followInstructions") })
  ] });
}, "Create"), BackupsV2 = /* @__PURE__ */ __name(({
  deviceID,
  showRestore,
  showCreate,
  showRadio,
  onSelectBackup,
  onRestoreBackup,
  children: children2
}) => {
  const { t: t2 } = useTranslation(), [selectedBackup, setSelectedBackup] = reactExports.useState(), [restoring, setRestoring] = reactExports.useState(!1), [errorText2, setErrorText] = reactExports.useState(""), backups = useSync(() => getBackupList(deviceID), subscribeBackupList(deviceID)), hasBackups = backups && backups.success && backups !== void 0, restore = /* @__PURE__ */ __name(() => {
    if (!hasBackups || !selectedBackup)
      return;
    const backup2 = backups.backups.find((b2) => b2.id === selectedBackup);
    backup2 && (setRestoring(!0), onSelectBackup && onSelectBackup(backup2), restoreBackup(deviceID, selectedBackup).then(({ success: success2 }) => {
      setRestoring(!1), setErrorText(success2 ? "" : t2("backup.restore.error.general")), onRestoreBackup && onRestoreBackup(success2);
    }));
  }, "restore");
  return hasBackups ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.stepContext, children: [
    errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toast, { theme: "warning", children: errorText2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, children: backups.backups.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backups.backups.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BackupsListItem,
      {
        disabled: restoring,
        backup: backup2,
        selectedBackup,
        handleChange: (b2) => setSelectedBackup(b2),
        onFocus: () => {
        },
        radio: showRadio
      }
    ) }, backup2.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.noBackups") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupButtons, children: [
      showRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          disabled: !selectedBackup || restoring,
          onClick: restore,
          children: t2("button.restore")
        }
      ),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(Create, { deviceID }),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Check,
        {
          deviceID,
          backups: backups.backups ? backups.backups : [],
          disabled: backups.backups.length === 0
        }
      ),
      children2
    ] })
  ] }) }) : hasBackups === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Error fetching backups" });
}, "BackupsV2"), SDCardCheck = /* @__PURE__ */ __name(({ deviceID, children: children2 }) => {
  const { t: t2 } = useTranslation(), [sdCardInserted, setSdCardInserted] = reactExports.useState(), check = reactExports.useCallback(() => checkSDCard(deviceID).then(setSdCardInserted), [deviceID]);
  return reactExports.useEffect(() => {
    check();
  }, [check]), sdCardInserted === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: sdCardInserted ? children2 : /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !sdCardInserted, title: "Check your device", small: !0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.insert") }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: check,
          children: t2("button.ok")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ButtonLink,
        {
          secondary: !0,
          to: `/settings/device-settings/${deviceID}`,
          children: t2("button.back")
        }
      )
    ] })
  ] }) });
}, "SDCardCheck"), _ManageBackups = class _ManageBackups extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "hasDevice", /* @__PURE__ */ __name(() => !!this.props.devices[this.props.deviceID], "hasDevice"));
    __publicField(this, "backButton", /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsx(
      ButtonLink,
      {
        secondary: !0,
        to: `/settings/device-settings/${this.props.deviceID}`,
        children: this.props.t("button.back")
      }
    ), "backButton"));
    __publicField(this, "listBackups", /* @__PURE__ */ __name(() => {
      switch (this.props.devices[this.props.deviceID]) {
        case "bitbox":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              deviceID: this.props.deviceID,
              showCreate: !0,
              showRestore: !1,
              children: this.backButton()
            }
          );
        case "bitbox02":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(SDCardCheck, { deviceID: this.props.deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            BackupsV2,
            {
              deviceID: this.props.deviceID,
              showCreate: !0,
              showRestore: !1,
              showRadio: !1,
              children: this.backButton()
            }
          ) });
        default:
          return;
      }
    }, "listBackups"));
    __publicField(this, "renderGuide", /* @__PURE__ */ __name((t2) => {
      switch (this.props.devices[this.props.deviceID]) {
        case "bitbox":
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.whatIsABackup") }, "guide.backups.whatIsABackup"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.encrypt") }, "guide.backups.encrypt"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.check") }, "guide.backups.check"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
          ] });
        case "bitbox02":
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.whatIsABackup") }, "guide.backupsBB02.whatIsABackup"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.encrypt"), shown: !0 }, "guide.backupsBB02.encrypt"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.check") }, "guide.backupsBB02.check"),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
          ] });
        default:
          return null;
      }
    }, "renderGuide"));
  }
  UNSAFE_componentWillMount() {
    this.hasDevice() || route("/", !0);
  }
  render() {
    const { t: t2 } = this.props;
    return this.hasDevice() ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("backup.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("backup.list") }),
          this.listBackups()
        ] })
      ] }) }),
      this.renderGuide(t2)
    ] }) : null;
  }
};
__name(_ManageBackups, "ManageBackups");
let ManageBackups = _ManageBackups;
const ManageBackups$1 = withTranslation()(ManageBackups), AccountGuide$1 = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatIsRememberWallet") }, "whatIsRememberWallet"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
}, "AccountGuide$1"), label$2 = "_label_g3ts4_1", labelText = "_labelText_g3ts4_5", style$f = {
  label: label$2,
  labelText
}, WatchonlySetting = /* @__PURE__ */ __name(({ keystore }) => {
  const { t: t2 } = useTranslation(), [disabled2, setDisabled] = reactExports.useState(!1), [watchonly, setWatchonly$1] = reactExports.useState(), [warningDialogOpen, setWarningDialogOpen] = reactExports.useState(!1), config = useLoad(getConfig);
  reactExports.useEffect(() => {
    config && setWatchonly$1(keystore.watchonly);
  }, [config, keystore]);
  const toggleWatchonly = /* @__PURE__ */ __name(async () => {
    if (!watchonly) {
      setDisabled(!0);
      const { success: success2 } = await setWatchonly(keystore.rootFingerprint, !watchonly);
      success2 && setWatchonly$1(!watchonly), setDisabled(!1);
      return;
    }
    setWarningDialogOpen(!0), setDisabled(!1);
  }, "toggleWatchonly"), handleCloseDialog = /* @__PURE__ */ __name(() => {
    setWarningDialogOpen(!1), setDisabled(!1);
  }, "handleCloseDialog"), handleConfirmDisableWatchonly = /* @__PURE__ */ __name(async () => {
    setDisabled(!0), await setWatchonly(keystore.rootFingerprint, !1), setWatchonly$1(!1), setDisabled(!1), setWarningDialogOpen(!1);
  }, "handleConfirmDisableWatchonly");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("newSettings.appearance.remebmerWallet.warningTitle"), medium: !0, onClose: handleCloseDialog, open: warningDialogOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.remebmerWallet.warning") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: handleConfirmDisableWatchonly, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: handleCloseDialog, children: t2("dialog.cancel") })
      ] })
    ] }),
    watchonly !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: style$f.label, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$f.labelText, children: t2("newSettings.appearance.remebmerWallet.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: watchonly,
          disabled: disabled2,
          onChange: toggleWatchonly
        }
      )
    ] }) : null
  ] });
}, "WatchonlySetting"), addAccountBtn = "_addAccountBtn_17bcq_2", walletHeader = "_walletHeader_17bcq_6", walletTitle = "_walletTitle_17bcq_14", setting = "_setting_17bcq_25", coinLogo = "_coinLogo_17bcq_39", acccountLink = "_acccountLink_17bcq_44", editBtn = "_editBtn_17bcq_52", toggleLabel$1 = "_toggleLabel_17bcq_64", toggleLabelText = "_toggleLabelText_17bcq_70", toggle$1 = "_toggle_17bcq_64", accountActive = "_accountActive_17bcq_87", tokenSection = "_tokenSection_17bcq_91", tokenContainer = "_tokenContainer_17bcq_100", tokenContainerOpen = "_tokenContainerOpen_17bcq_107", token$1 = "_token_17bcq_91", tokenIcon = "_tokenIcon_17bcq_149", tokenName = "_tokenName_17bcq_154", tokenInactive = "_tokenInactive_17bcq_160", expandBtn = "_expandBtn_17bcq_165", expandBtnOpen = "_expandBtnOpen_17bcq_173", watchOnlyContainer = "_watchOnlyContainer_17bcq_186", watchOnlyNote = "_watchOnlyNote_17bcq_193", watchOnlyAccountHidden = "_watchOnlyAccountHidden_17bcq_198", style$e = {
  addAccountBtn,
  walletHeader,
  walletTitle,
  setting,
  coinLogo,
  acccountLink,
  editBtn,
  toggleLabel: toggleLabel$1,
  toggleLabelText,
  toggle: toggle$1,
  accountActive,
  tokenSection,
  tokenContainer,
  tokenContainerOpen,
  token: token$1,
  tokenIcon,
  tokenName,
  tokenInactive,
  expandBtn,
  expandBtnOpen,
  watchOnlyContainer,
  watchOnlyNote,
  watchOnlyAccountHidden
}, _ManageAccounts = class _ManageAccounts extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      editErrorMessage: void 0,
      showTokens: {},
      currentlyEditedAccount: void 0
    }, this.renderAccounts = (accounts) => {
      const { showTokens } = this.state, { t: t2 } = this.props;
      return accounts.filter((account2) => !account2.isToken).map((account2) => {
        var _a46;
        const active2 = account2.active, tokensVisible = showTokens[account2.code];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.setting, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${style$e.acccountLink} ${active2 ? style$e.accountActive : ""}`,
              onClick: () => active2 && route(`/account/${account2.code}`),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: `${style$e.coinLogo} m-right-half`, coinCode: account2.coinCode, alt: account2.coinUnit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  account2.name,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "unit", children: [
                    "(",
                    account2.coinUnit,
                    ")"
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              className: style$e.editBtn,
              onClick: () => this.setState({ currentlyEditedAccount: account2 }),
              transparent: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(EditActive, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hide-on-small", children: t2("manageAccounts.editAccount") })
              ]
            }
          ),
          active2 && account2.coinCode === "eth" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.tokenSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$e.tokenContainer} ${tokensVisible ? style$e.tokenContainerOpen : ""}`, children: this.renderTokens(account2.code, account2.activeTokens) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: `${style$e.expandBtn} ${tokensVisible ? style$e.expandBtnOpen : ""}`,
                onClick: () => this.toggleShowTokens(account2.code),
                transparent: !0,
                children: t2(tokensVisible ? "manageAccounts.settings.hideTokens" : "manageAccounts.settings.showTokens", {
                  activeTokenCount: `${((_a46 = account2.activeTokens) == null ? void 0 : _a46.length) || 0}`
                })
              }
            )
          ] }) : null
        ] }, account2.code);
      });
    }, this.renderWatchOnlyToggle = () => {
      const { currentlyEditedAccount } = this.state;
      if (currentlyEditedAccount && currentlyEditedAccount.keystore.watchonly)
        return null;
    }, this.toggleAccount = (accountCode, active2) => setAccountActive(accountCode, active2).then(({ success: success2, errorMessage }) => {
      !success2 && errorMessage && alertUser(errorMessage);
    }), this.toggleShowTokens = (accountCode) => {
      this.setState(({ showTokens }) => ({
        showTokens: {
          ...showTokens,
          [accountCode]: accountCode in showTokens ? !showTokens[accountCode] : !0
        }
      }));
    }, this.erc20Tokens = [
      { code: "eth-erc20-usdt", name: "Tether USD", unit: "USDT" },
      { code: "eth-erc20-usdc", name: "USD Coin", unit: "USDC" },
      { code: "eth-erc20-link", name: "Chainlink", unit: "LINK" },
      { code: "eth-erc20-bat", name: "Basic Attention Token", unit: "BAT" },
      { code: "eth-erc20-mkr", name: "Maker", unit: "MKR" },
      { code: "eth-erc20-zrx", name: "0x", unit: "ZRX" },
      { code: "eth-erc20-wbtc", name: "Wrapped Bitcoin", unit: "WBTC" },
      { code: "eth-erc20-paxg", name: "Pax Gold", unit: "PAXG" },
      { code: "eth-erc20-dai0x6b17", name: "Dai", unit: "DAI" }
    ], this.renderTokens = (ethAccountCode, activeTokens) => this.erc20Tokens.map((token2) => {
      const activeToken = (activeTokens || []).find((t2) => t2.tokenCode === token2.code), active2 = activeToken !== void 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `${style$e.token} ${active2 ? "" : style$e.tokenInactive}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "div",
              {
                className: `${style$e.acccountLink} ${active2 ? style$e.accountActive : ""}`,
                onClick: () => activeToken !== void 0 && route(`/account/${activeToken.accountCode}`),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Logo,
                    {
                      active: active2,
                      alt: token2.name,
                      className: style$e.tokenIcon,
                      coinCode: token2.code,
                      stacked: !0
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$e.tokenName, children: [
                    token2.name,
                    " (",
                    token2.unit,
                    ")"
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Toggle,
              {
                checked: active2,
                className: style$e.toggle,
                id: token2.code,
                onChange: () => this.toggleToken(ethAccountCode, token2.code, !active2)
              }
            )
          ]
        },
        token2.code
      );
    }), this.toggleToken = (ethAccountCode, tokenCode, active2) => {
      setTokenActive(ethAccountCode, tokenCode, active2).then(({ success: success2, errorMessage }) => {
        !success2 && errorMessage && alertUser(errorMessage);
      });
    }, this.updateAccount = (event2) => {
      event2.preventDefault();
      const { accounts } = this.props, { currentlyEditedAccount } = this.state;
      currentlyEditedAccount && renameAccount(currentlyEditedAccount.code, currentlyEditedAccount.name).then((result) => {
        if (!result.success) {
          result.errorCode ? this.setState({ editErrorMessage: this.props.t(`error.${result.errorCode}`) }) : result.errorMessage && this.setState({ editErrorMessage: result.errorMessage });
          return;
        }
        const account2 = accounts.find(({ code }) => currentlyEditedAccount.code === code);
        currentlyEditedAccount.active !== (account2 == null ? void 0 : account2.active) && this.toggleAccount(currentlyEditedAccount.code, currentlyEditedAccount.active), this.setState({
          editErrorMessage: void 0,
          currentlyEditedAccount: void 0
        });
      });
    };
  }
  render() {
    const { t: t2, accounts, deviceIDs, hasAccounts } = this.props, { editErrorMessage, currentlyEditedAccount } = this.state, accountsByKeystore = getAccountsByKeystore(accounts);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SharedHeader,
          {
            hideSidebarToggler: !0,
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("settings.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("manageAccounts.title") })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { deviceIDs, hideMobileMenu: !0, hasAccounts, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: style$e.addAccountBtn,
              primary: !0,
              onClick: () => route("/add-account", !0),
              children: t2("addAccount.title")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: accountsByKeystore.map((keystore) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Column,
            {
              asCard: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$e.walletHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: style$e.walletTitle, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                      keystore.keystore.name,
                      isAmbiguiousName(keystore.keystore.name, accountsByKeystore) ? (
                        // Disambiguate accounts group by adding the fingerprint.
                        // The most common case where this would happen is when adding accounts from the
                        // same seed using different passphrases.
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                          " ",
                          keystore.keystore.rootFingerprint
                        ] })
                      ) : null
                    ] }),
                    keystore.keystore.connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Badge,
                      {
                        className: "m-right-quarter",
                        icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                        type: "success",
                        children: t2("device.keystoreConnected")
                      }
                    ) : null
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(WatchonlySetting, { keystore: keystore.keystore })
                ] }),
                this.renderAccounts(keystore.accounts)
              ]
            },
            keystore.keystore.rootFingerprint
          )) }),
          currentlyEditedAccount && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: !!currentlyEditedAccount,
              onClose: () => this.setState({ currentlyEditedAccount: void 0 }),
              title: t2("manageAccounts.editAccountNameTitle"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.updateAccount, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", hidden: !editErrorMessage, children: editErrorMessage }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$2,
                  {
                    onInput: (e2) => this.setState({ currentlyEditedAccount: { ...currentlyEditedAccount, name: e2.target.value } }),
                    value: currentlyEditedAccount.name
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    className: style$e.toggleLabel,
                    htmlFor: currentlyEditedAccount.code,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$e.toggleLabelText, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpenedDark, {}),
                        t2("newSettings.appearance.enableAccount.title")
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Toggle,
                        {
                          checked: currentlyEditedAccount.active,
                          className: style$e.toggle,
                          id: currentlyEditedAccount.code,
                          onChange: (event2) => {
                            event2.target.disabled = !0, this.setState({
                              currentlyEditedAccount: {
                                ...currentlyEditedAccount,
                                active: event2.target.checked
                              }
                            }, () => event2.target.disabled = !1);
                          }
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.enableAccount.description") }),
                this.renderWatchOnlyToggle(),
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    disabled: !currentlyEditedAccount.name,
                    primary: !0,
                    type: "submit",
                    children: t2("button.update")
                  }
                ) })
              ] })
            }
          )
        ] }) }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AccountGuide$1, {})
    ] });
  }
};
__name(_ManageAccounts, "ManageAccounts");
let ManageAccounts = _ManageAccounts;
const HOC$3 = translate()(ManageAccounts), title = "_title_ahh86_1", resetLink = "_resetLink_ahh86_7", serversContainer = "_serversContainer_ahh86_11", servers = "_servers_ahh86_11", server = "_server_ahh86_11", serverLabel = "_serverLabel_ahh86_32", primary = "_primary_ahh86_82", warning = "_warning_ahh86_93", textarea$1 = "_textarea_ahh86_104", block = "_block_ahh86_112", addServer = "_addServer_ahh86_116", badge$1 = "_badge_ahh86_140", miniSpinnerContainer = "_miniSpinnerContainer_ahh86_152", miniSpinner = "_miniSpinner_ahh86_152", changeContent$1 = "_changeContent_ahh86_1", style$d = {
  title,
  resetLink,
  serversContainer,
  servers,
  server,
  serverLabel,
  primary,
  warning,
  textarea: textarea$1,
  block,
  addServer,
  badge: badge$1,
  miniSpinnerContainer,
  miniSpinner,
  changeContent: changeContent$1
}, ElectrumAddServer = /* @__PURE__ */ __name(({
  onAdd
}) => {
  const { t: t2 } = useTranslation(), [valid, setValid] = reactExports.useState(), [electrumServer, setElectrumServer] = reactExports.useState(""), [electrumCert, setElectrumCert] = reactExports.useState(""), [loadingCheck, setLoadingCheck] = reactExports.useState(!1), [loadingCert, setLoadingCert] = reactExports.useState(!1), getServer = /* @__PURE__ */ __name(() => ({
    server: electrumServer.trim(),
    pemCert: electrumCert,
    tls: electrumCert !== ""
  }), "getServer"), add = /* @__PURE__ */ __name(() => {
    onAdd(getServer()), setElectrumServer(""), setElectrumCert("");
  }, "add"), downloadCert = /* @__PURE__ */ __name(async () => {
    setLoadingCert(!0);
    const data = await apiPost("certs/download", electrumServer.trim());
    data.success ? setElectrumCert(data.pemCert) : alertUser(data.errorMessage), setLoadingCert(!1);
  }, "downloadCert"), check = /* @__PURE__ */ __name(async () => {
    setLoadingCheck(!0);
    const { success: success2, errorMessage } = await apiPost("electrum/check", getServer());
    alertUser(success2 ? t2("settings.electrum.checkSuccess", { host: electrumServer }) : t2("settings.electrum.checkFailed") + `:
` + errorMessage), setValid(success2), setLoadingCheck(!1);
  }, "check"), downloadCertButtonDisabled = electrumServer.trim().length === 0 || electrumCert.trim().length > 0 || loadingCert, checkConnectionButtonDisabled = electrumServer.trim().length === 0 || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.addServer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step1-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        name: "electrumServer",
        onInput: (event2) => setElectrumServer(event2.target.value),
        value: electrumServer,
        placeholder: "host:port"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text-tcp") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: style$d.textarea,
        rows: 10,
        cols: 80,
        name: "electrumCert",
        onInput: (event2) => setElectrumCert(event2.target.value),
        value: electrumCert,
        placeholder: `-----BEGIN CERTIFICATE-----
...
-----END CERTIFICATE-----`
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$d.block, "flex flex-row flex-end"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: !0, disabled: downloadCertButtonDisabled, onClick: downloadCert, children: [
      loadingCert && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
      t2("settings.electrum.download-cert")
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step3-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-end spaced", style$d.block].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: !0, disabled: checkConnectionButtonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
        t2(loadingCheck ? "settings.electrum.checking" : "settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, disabled: !valid, onClick: add, children: t2("settings.electrum.add-server") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$d.badge, children: t2("settings.electrum.step4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step4-text") }) })
    ] })
  ] });
}, "ElectrumAddServer"), ElectrumServer = /* @__PURE__ */ __name(({
  onRemove,
  server: server2
}) => {
  const { t: t2 } = useTranslation(), [loadingCheck, setLoadingCheck] = reactExports.useState(!1), check = /* @__PURE__ */ __name(async () => {
    setLoadingCheck(!0);
    const { success: success2, errorMessage } = await apiPost("electrum/check", {
      server: server2.server.trim(),
      pemCert: server2.pemCert,
      tls: server2.tls
    });
    alertUser(success2 ? t2("settings.electrum.checkSuccess", { host: server2.server }) : t2("settings.electrum.checkFailed") + `:
` + errorMessage), setLoadingCheck(!1);
  }, "check"), buttonDisabled = server2.server === "" || server2.tls && server2.pemCert === "" || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.server, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.serverLabel, children: [
      server2.server,
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: server2.tls ? "TLS" : "TCP" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$d.primary, disabled: buttonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$d.miniSpinner }) }),
        t2(loadingCheck ? "settings.electrum.checking" : "settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$d.warning, onClick: onRemove, children: t2("settings.electrum.remove-server") })
    ] })
  ] }) });
}, "ElectrumServer"), ElectrumServers = /* @__PURE__ */ __name(({
  coin
}) => {
  const { t: t2 } = useTranslation(), [config, setConfigState] = reactExports.useState(), loadConfig = /* @__PURE__ */ __name(() => {
    getConfig().then(setConfigState);
  }, "loadConfig");
  if (reactExports.useEffect(loadConfig, []), config === void 0)
    return null;
  const electrumServers = config.backend[coin].electrumServers, save = /* @__PURE__ */ __name(async (newElectrumServers) => {
    const currentConfig = await getConfig();
    currentConfig.backend[coin].electrumServers = newElectrumServers, await setConfig(currentConfig), setConfigState(currentConfig);
  }, "save"), onAdd = /* @__PURE__ */ __name((server2) => {
    let newElectrumServers = [...electrumServers, server2];
    save(newElectrumServers);
  }, "onAdd"), onRemove = /* @__PURE__ */ __name((index) => {
    let newElectrumServers = [...electrumServers];
    newElectrumServers.splice(index, 1), save(newElectrumServers);
  }, "onRemove"), resetToDefault = /* @__PURE__ */ __name(() => {
    confirmation(t2("settings.electrum.resetConfirm"), (response) => {
      response && getDefaultConfig().then((config2) => {
        save(config2.backend[coin].electrumServers);
      });
    });
  }, "resetToDefault"), onRemoveCb = /* @__PURE__ */ __name((server2, index) => () => {
    confirmation(t2("settings.electrum.removeConfirm", { server: server2.server }), (confirmed) => {
      confirmed && onRemove(index);
    });
  }, "onRemoveCb");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$d.serversContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.servers") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            transparent: !0,
            className: style$d.resetLink,
            onClick: resetToDefault,
            children: t2("settings.electrum.reset")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$d.servers, children: electrumServers.map((server2, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ElectrumServer,
        {
          server: server2,
          onRemove: onRemoveCb(server2, index)
        },
        server2.server + server2.tls.toString() + "-" + index.toString()
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.add") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumAddServer, { onAdd })
    ] })
  ] });
}, "ElectrumServers"), ElectrumSettings = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [activeTab, setActiveTab] = reactExports.useState("btc"), testing = useLoad(() => getTesting()), handleTab = /* @__PURE__ */ __name((e2) => {
    const selectedTab = e2.currentTarget.getAttribute("data-tab");
    if (selectedTab !== "btc" && selectedTab !== "ltc") {
      console.error("Unrecognized tab ID");
      return;
    }
    setActiveTab(selectedTab);
  }, "handleTab");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.expert.electrum.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center tabs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "btc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "btc", children: t2(`settings.electrum.title-${testing ? "tbtc" : "btc"}`) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "ltc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "ltc", children: t2(`settings.electrum.title-${testing ? "tltc" : "ltc"}`) }) })
        ] }),
        activeTab === "btc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tbtc" : "btc"
          },
          testing ? "tbtc" : "btc"
        ),
        activeTab === "ltc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tltc" : "ltc"
          },
          testing ? "tltc" : "ltc"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonLink,
          {
            secondary: !0,
            to: "/settings",
            children: t2("button.back")
          }
        ) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.what") }, "guide.settings-electrum.what"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.options") }, "guide.settings-electrum.options"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.connection") }, "guide.settings-electrum.connection"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.settings-electrum.instructions.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/14-privatsphare/29-verbindung-der-bitboxapp-zu-meinem-bitcoin-full-node" : "https://shiftcrypto.support/help/en-us/14-privacy/29-how-to-connect-the-bitboxapp-to-my-own-full-node"
        },
        text: t2("guide.settings-electrum.instructions.text"),
        title: t2("guide.settings-electrum.instructions.title")
      } }, "guide.settings-electrum.instructions")
    ] })
  ] });
}, "ElectrumSettings"), INFO_STEPS_ENABLE = 5, INFO_STEPS_DISABLE = 0, CONTENT_MIN_HEIGHT = "38em", _Passphrase = class _Passphrase extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      infoStep: 0,
      status: "info",
      understood: !1
    }, this.togglePassphrase = async () => {
      const { deviceID, t: t2 } = this.props, enable = !this.state.passphraseEnabled;
      this.setState({ status: "progress" });
      try {
        const result = await setMnemonicPassphraseEnabled(deviceID, enable);
        if (!result.success) {
          route(`/settings/device-settings/${deviceID}`), alertUser(t2(`passphrase.error.e${result.code}`, {
            defaultValue: result.message || t2("genericError")
          }));
          return;
        }
        const deviceInfoResult = await getDeviceInfo(deviceID);
        deviceInfoResult.success && this.setState({
          passphraseEnabled: deviceInfoResult.deviceInfo.mnemonicPassphraseEnabled,
          status: "success"
        });
      } catch (error3) {
        console.error(error3);
      }
    }, this.stopInfo = () => route(`/settings/device-settings/${this.props.deviceID}`), this.continueInfo = () => {
      if (this.state.infoStep === 0) {
        this.togglePassphrase();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep - 1 }));
    }, this.backInfo = () => {
      if (this.state.infoStep === void 0)
        return;
      const enabled = this.state.passphraseEnabled;
      if (!enabled && this.state.infoStep >= INFO_STEPS_ENABLE || enabled && this.state.infoStep >= INFO_STEPS_DISABLE) {
        this.stopInfo();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep + 1 }));
    }, this.renderEnableInfo = () => {
      const { infoStep, understood } = this.state, { t: t2 } = this.props;
      switch (infoStep) {
        case 5:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.intro.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.intro.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.what.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-intro"
          );
        case 4:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.what.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.what.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.why.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-what"
          );
        case 3:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.why.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.why.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.considerations.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-why"
          );
        case 2:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.considerations.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.considerations.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.how.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-considerations"
          );
        case 1:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.how.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.how.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.summary.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-how"
          );
        case 0:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: !0,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: !0,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.summary.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.0") }, "info-1"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.1") }, "info-2"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.2") }, "info-3"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.3") }, "info-4")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: understood ? "success" : "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      onChange: (e2) => {
                        var _a46;
                        return this.setState({ understood: (_a46 = e2.target) == null ? void 0 : _a46.checked });
                      },
                      id: "understood",
                      checked: understood,
                      label: t2("passphrase.summary.understand"),
                      checkboxStyle: understood ? "success" : "warning"
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, disabled: !understood, children: t2("passphrase.enable") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-summary"
          );
        default:
          console.error(`invalid infoStep ${infoStep}`);
          return;
      }
    }, this.renderDisableInfo = () => {
      const { t: t2 } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          minHeight: CONTENT_MIN_HEIGHT,
          onClose: this.stopInfo,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.disable") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.disableInfo.message") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: this.continueInfo, children: t2("passphrase.disableInfo.button") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: this.backInfo, children: t2("button.back") })
            ] })
          ]
        },
        "step-disable-info1"
      );
    };
  }
  componentDidMount() {
    getDeviceInfo(this.props.deviceID).then((result) => {
      if (!result.success) {
        console.error(result.message), alertUser(this.props.t("genericError"));
        return;
      }
      const { mnemonicPassphraseEnabled } = result.deviceInfo;
      this.setState({
        // before enabling/disabling we show 1 or more pages to inform about the feature
        // each page has a continue button that jumps to the next or finally toggles passphrase
        // infoStep counts down in decreasing order
        infoStep: mnemonicPassphraseEnabled ? INFO_STEPS_DISABLE : INFO_STEPS_ENABLE,
        passphraseEnabled: mnemonicPassphraseEnabled
      });
    }).catch(console.error);
  }
  render() {
    const { t: t2 } = this.props, { passphraseEnabled, status: status2 } = this.state;
    return passphraseEnabled === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "info" && (passphraseEnabled ? this.renderDisableInfo() : this.renderEnableInfo()),
      status2 === "progress" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          minHeight: CONTENT_MIN_HEIGHT,
          textCenter: !0,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                title: t2(passphraseEnabled ? "passphrase.progressDisable.title" : "passphrase.progressEnable.title"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SimpleMarkup,
                  {
                    tagName: "p",
                    markup: t2(passphraseEnabled ? "passphrase.progressDisable.message" : "passphrase.progressEnable.message")
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
          ]
        },
        "progress"
      ),
      status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          verticallyCentered: !0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                small: !0,
                title: t2(passphraseEnabled ? "passphrase.successDisabled.title" : "passphrase.successEnabled.title")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2(passphraseEnabled ? "passphrase.successDisabled.message" : "passphrase.successEnabled.message") }),
              passphraseEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { paddingLeft: "var(--space-default)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.0") }, "tip-1"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.1") }, "tip-2")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2(
                passphraseEnabled ? "passphrase.successDisabled.messageEnd" : "passphrase.successEnabled.messageEnd"
              ) })
            ] })
          ]
        },
        "progress"
      )
    ] });
  }
};
__name(_Passphrase, "Passphrase");
let Passphrase = _Passphrase;
const HOC$2 = translate()(Passphrase);
function AccountGuide({
  account: account2,
  unit: unit2,
  hasNoBalance,
  hasIncomingBalance,
  hasTransactions
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountDescription") }, "accountDescription"),
    hasNoBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSendDisabled", {
      unit: unit2
    }) }, "accountSendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountReload") }, "accountReload"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionLabel") }, "accountTransactionLabel"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionTime") }, "accountTransactionTime"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesGeneric") }, "accountTransactionAttributesGeneric"),
    hasTransactions && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesBTC") }, "accountTransactionAttributesBTC"),
    hasIncomingBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountIncomingBalance") }, "accountIncomingBalance"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionConfirmation") }, "accountTransactionConfirmation"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountFiat") }, "accountFiat"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "accountRates"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "CoinTracking",
        url: "https://cointracking.info/import/bitbox/?ref=BITBOX"
      },
      text: t2("guide.cointracking.text"),
      title: t2("guide.cointracking.title")
    } }, "cointracking")
  ] });
}
__name(AccountGuide, "AccountGuide");
const syncContainer = "_syncContainer_nrzbt_1", progressBar = "_progressBar_nrzbt_8", progressValue = "_progressValue_nrzbt_14", syncMessage = "_syncMessage_nrzbt_21", syncText = "_syncText_nrzbt_33", spinnerContainer = "_spinnerContainer_nrzbt_39", spinner = "_spinner_nrzbt_39", changeContent = "_changeContent_nrzbt_1", style$c = {
  syncContainer,
  progressBar,
  progressValue,
  syncMessage,
  syncText,
  spinnerContainer,
  spinner,
  changeContent
}, HeadersSync = /* @__PURE__ */ __name(({ coinCode }) => {
  const { i18n, t: t2 } = useTranslation(), status2 = useSubscribe(subscribeCoinHeaders(coinCode)), [hidden, setHidden] = reactExports.useState(!1), mounted = useMountedRef();
  if (reactExports.useEffect(() => {
    mounted.current && status2 && status2.tip === status2.targetHeight && setTimeout(() => setHidden(!0), 4e3);
  }, [mounted, status2]), !status2 || hidden)
    return null;
  const total2 = status2.targetHeight - status2.tipAtInitTime, value = 100 * (status2.tip - status2.tipAtInitTime) / total2, loaded = !total2 || value >= 100, formatted = new Intl.NumberFormat(i18n.language).format(status2.tip);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncMessage, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.syncText, children: [
        t2("headerssync.blocksSynced", { blocks: formatted }),
        " ",
        !loaded && `(${Math.ceil(value)}%)`
      ] }),
      loaded ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "progress-bar", className: style$c.progressBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.progressValue, style: { width: `${value}%` } }) })
  ] });
}, "HeadersSync"), container$6 = "_container_13974_1", background = "_background_13974_6", foreground = "_foreground_13974_7", complete = "_complete_13974_19", pending = "_pending_13974_23", generic = "_generic_13974_24", error2 = "_error_13974_28", style$b = {
  container: container$6,
  background,
  foreground,
  complete,
  pending,
  generic,
  error: error2
}, ProgressRing = /* @__PURE__ */ __name(({
  className,
  generic: generic2,
  isComplete,
  isError,
  value,
  width
}) => {
  const radius = (width - 3) / 2, circumference = radius * 2 * Math.PI, progress = isError ? 100 : value / 100, offset = circumference * (1 - progress);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: [style$b.container, className || ""].join(" "),
      width,
      height: width,
      style: { minWidth: width },
      viewBox: `0 0 ${width} ${width}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: style$b.background,
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: [
              style$b.foreground,
              !generic2 && isComplete ? style$b.complete : style$b.pending,
              generic2 && style$b.generic,
              isError && style$b.error
            ].join(" "),
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3,
            strokeDashoffset: offset,
            strokeDasharray: circumference
          }
        )
      ]
    }
  );
}, "ProgressRing"), txArrowType = "_txArrowType_m24u9_1", txArrowTypeIn = "_txArrowTypeIn_m24u9_6", txArrowTypeOut = "_txArrowTypeOut_m24u9_10", txArrowTypeSelf = "_txArrowTypeSelf_m24u9_14", style$a = {
  txArrowType,
  txArrowTypeIn,
  txArrowTypeOut,
  txArrowTypeSelf
}, ArrowIn = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeIn}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
), "ArrowIn"), ArrowOut = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeOut}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
), "ArrowOut"), ArrowSelf = /* @__PURE__ */ __name(() => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$a.txArrowType} ${style$a.txArrowTypeSelf}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 5 19 12 12 19" })
    ]
  }
), "ArrowSelf"), container$5 = "_container_1j01g_1", header$1 = "_header_1j01g_5", columns = "_columns_1j01g_17", headers = "_headers_1j01g_27", columnGroup = "_columnGroup_1j01g_33", type = "_type_1j01g_46", date$1 = "_date_1j01g_52", activity = "_activity_1j01g_57", status$1 = "_status_1j01g_63", fiat$1 = "_fiat_1j01g_68", currency$1 = "_currency_1j01g_74", action$1 = "_action_1j01g_80", empty = "_empty_1j01g_87", hideOnMedium = "_hideOnMedium_1j01g_103", showOnMedium = "_showOnMedium_1j01g_113", style$9 = {
  container: container$5,
  header: header$1,
  columns,
  headers,
  columnGroup,
  type,
  date: date$1,
  activity,
  status: status$1,
  fiat: fiat$1,
  currency: currency$1,
  action: action$1,
  empty,
  hideOnMedium,
  showOnMedium
}, container$4 = "_container_1tutj_1", row = "_row_1tutj_5", date = "_date_1tutj_15", address$1 = "_address_1tutj_19", badge = "_badge_1tutj_24", statusIndicator = "_statusIndicator_1tutj_29", statusIndicatorComplete = "_statusIndicatorComplete_1tutj_37", statusIndicatorPending = "_statusIndicatorPending_1tutj_41", statusIndicatorFailed = "_statusIndicatorFailed_1tutj_45", status = "_status_1tutj_29", fiat = "_fiat_1tutj_53", amount = "_amount_1tutj_57", amountOverflow = "_amountOverflow_1tutj_62", send$1 = "_send_1tutj_74", receive$1 = "_receive_1tutj_78", currency = "_currency_1tutj_82", currencyUnit = "_currencyUnit_1tutj_86", action = "_action_1tutj_97", label$1 = "_label_1tutj_108", columnLabel = "_columnLabel_1tutj_113", inlineLabel = "_inlineLabel_1tutj_114", inlineValue = "_inlineValue_1tutj_128", fee = "_fee_1tutj_132", transactionId = "_transactionId_1tutj_136", detail = "_detail_1tutj_141", detailInput = "_detailInput_1tutj_142", textOnlyInput = "_textOnlyInput_1tutj_159", editButton = "_editButton_1tutj_167", addresses = "_addresses_1tutj_207", detailAddresses = "_detailAddresses_1tutj_218", detailAddress = "_detailAddress_1tutj_218", first = "_first_1tutj_231", style$8 = {
  container: container$4,
  row,
  date,
  address: address$1,
  badge,
  statusIndicator,
  statusIndicatorComplete,
  statusIndicatorPending,
  statusIndicatorFailed,
  status,
  fiat,
  amount,
  amountOverflow,
  send: send$1,
  receive: receive$1,
  currency,
  currencyUnit,
  action,
  label: label$1,
  columnLabel,
  inlineLabel,
  inlineValue,
  fee,
  transactionId,
  detail,
  detailInput,
  textOnlyInput,
  editButton,
  addresses,
  detailAddresses,
  detailAddress,
  first
}, _Transaction = class _Transaction extends reactExports.Component {
  constructor() {
    super(...arguments), this.input = reactExports.createRef(), this.editButton = reactExports.createRef(), this.state = {
      transactionDialog: !1,
      newNote: this.props.note,
      editMode: !this.props.note
    }, this.parseTimeShort = (time2) => {
      const options2 = {
        year: "numeric",
        month: "numeric",
        day: "numeric"
      };
      return new Date(Date.parse(time2)).toLocaleString(this.props.i18n.language, options2);
    }, this.showDetails = () => {
      getTransaction(this.props.accountCode, this.props.internalID).then((transaction2) => {
        if (!transaction2)
          return console.error("Unable to retrieve transaction " + this.props.internalID), null;
        this.setState({
          transactionInfo: transaction2,
          transactionDialog: !0,
          newNote: this.props.note,
          editMode: !this.props.note
        });
      }).catch(console.error);
    }, this.hideDetails = () => {
      this.setState({ transactionDialog: !1 });
    }, this.handleNoteInput = (e2) => {
      const target = e2.target;
      this.setState({ newNote: target.value });
    }, this.handleEdit = (e2) => {
      e2.preventDefault(), this.state.editMode && this.props.note !== this.state.newNote && postNotesTx(this.props.accountCode, {
        internalTxID: this.props.internalID,
        note: this.state.newNote
      }).catch(console.error), this.focusEdit(), this.setState(
        ({ editMode }) => ({ editMode: !editMode }),
        this.focusEdit
      );
    }, this.focusEdit = () => {
      this.editButton.current && this.editButton.current.blur(), this.state.editMode && this.input.current && (this.input.current.scrollLeft = this.input.current.scrollWidth, this.input.current.focus());
    };
  }
  render() {
    const {
      t: t2,
      index,
      explorerURL,
      type: type2,
      amount: amount2,
      feeRatePerKb,
      numConfirmations,
      numConfirmationsComplete,
      time: time2,
      addresses: addresses2,
      status: status2,
      note: note2 = ""
    } = this.props, {
      transactionDialog,
      newNote,
      editMode,
      transactionInfo
    } = this.state, arrow2 = type2 === "receive" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIn, {}) : type2 === "send" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowOut, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSelf, {}), sign = type2 === "send" && "−" || type2 === "receive" && "+" || "", typeClassName = type2 === "send" && style$8.send || type2 === "receive" && style$8.receive || "", sDate = time2 ? this.parseTimeShort(time2) : "---", statusText = {
      complete: t2("transaction.status.complete"),
      pending: t2("transaction.status.pending"),
      failed: t2("transaction.status.failed")
    }[status2], progress = numConfirmations < numConfirmationsComplete ? numConfirmations / numConfirmationsComplete * 100 : 100, darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.container, index === 0 ? style$8.first : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.columns, style$8.row].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.columnGroup, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.type, children: arrow2 }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.date, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.columnLabel, children: [
              t2("transaction.details.date"),
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.date, children: sDate })
          ] }),
          note2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.activity, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.address, children: note2 }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.activity, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.label, children: t2(type2 === "receive" ? "transaction.tx.received" : "transaction.tx.sent") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.address, children: [
              addresses2[0],
              addresses2.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.badge, children: [
                "(+",
                addresses2.length - 1,
                ")"
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$9.action, style$9.hideOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$8.action, onClick: this.showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.columnGroup, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.status, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.columnLabel, children: [
              t2("transaction.details.status"),
              ":"
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProgressRing,
              {
                className: "m-right-quarter",
                width: 14,
                value: progress,
                isComplete: numConfirmations >= numConfirmationsComplete
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.status, children: statusText })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.fiat, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: !0 }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$9.currency} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "span",
            {
              className: `${style$8.amount} ${style$8.amountOverflow}`,
              "data-unit": ` ${amount2.unit}`,
              children: [
                sign,
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.currencyUnit, children: [
                  " ",
                  amount2.unit
                ] })
              ]
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$9.action, style$9.showOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$8.action, onClick: this.showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: transactionDialog, title: "Transaction Details", onClose: this.hideDetails, slim: !0, medium: !0, children: transactionInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleEdit, className: style$8.detailInput, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "note", children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              align: "right",
              autoFocus: editMode,
              className: style$8.textOnlyInput,
              readOnly: !editMode,
              type: "text",
              id: "note",
              transparent: !0,
              placeholder: t2("note.input.placeholder"),
              value: newNote,
              maxLength: 256,
              onInput: this.handleNoteInput,
              ref: this.input
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$8.editButton,
              onClick: this.handleEdit,
              title: t2(`transaction.note.${editMode ? "save" : "edit"}`),
              type: "button",
              ref: this.editButton,
              children: editMode ? darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaveLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {}) : darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(EditLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Edit, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.type") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: arrow2 })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.confirmation") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: numConfirmations })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.status") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "flex flex-items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProgressRing,
              {
                className: "m-right-quarter",
                width: 14,
                value: progress,
                isComplete: numConfirmations >= numConfirmationsComplete
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.status, children: [
              statusText,
              " ",
              status2 === "pending" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                "(",
                numConfirmations,
                "/",
                numConfirmationsComplete,
                ")"
              ] })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.date") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: sDate })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiat") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: !0 }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiatAtTime") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$8.fiat} ${typeClassName}`, children: transactionInfo.amountAtTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: transactionInfo.amountAtTime, sign, noAction: !0 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { noAction: !0 }) }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.amount") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: typeClassName, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$8.amount, children: [
              sign,
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit })
            ] }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: transactionInfo.amount.unit })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.fee") }),
          transactionInfo.fee && transactionInfo.fee.amount ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { title: feeRatePerKb.amount ? feeRatePerKb.amount + " " + feeRatePerKb.unit + "/Kb" : "", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: transactionInfo.fee.amount, unit: transactionInfo.fee.unit }),
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: transactionInfo.fee.unit })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "---" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.detail, style$8.addresses].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.address") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.detailAddresses, children: transactionInfo.addresses.map((address2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            CopyableInput,
            {
              alignRight: !0,
              borderLess: !0,
              flexibleHeight: !0,
              className: style$8.detailAddress,
              value: address2
            },
            address2
          )) })
        ] }),
        transactionInfo.gas ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.gas") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.gas })
        ] }) : null,
        transactionInfo.nonce !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Nonce" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.nonce })
        ] }) : null,
        transactionInfo.weight ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.weight") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.weight,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "WU" })
          ] })
        ] }) : null,
        transactionInfo.vsize ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.vsize") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.vsize,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "b" })
          ] })
        ] }) : null,
        transactionInfo.size ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$8.detail, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.size") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            transactionInfo.size,
            " ",
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$8.currencyUnit, children: "b" })
          ] })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$8.detail, style$8.addresses].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.explorer") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.detailAddresses, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CopyableInput,
            {
              alignRight: !0,
              borderLess: !0,
              flexibleHeight: !0,
              className: style$8.detailAddress,
              value: transactionInfo.txID
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$8.detail, "flex-center"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          A$3,
          {
            href: explorerURL + transactionInfo.txID,
            title: `${t2("transaction.explorerTitle")}
${explorerURL}${transactionInfo.txID}`,
            children: t2("transaction.explorerTitle")
          }
        ) })
      ] }) })
    ] });
  }
};
__name(_Transaction, "Transaction");
let Transaction = _Transaction;
const HOC$1 = translate()(Transaction), Transactions = /* @__PURE__ */ __name(({
  accountCode,
  explorerURL,
  transactions: transactions2,
  handleExport
}) => {
  const { t: t2 } = useTranslation(), csvExportDisabled = runningInAndroid();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$9.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("accountSummary.transactionHistory") }),
      !csvExportDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          transparent: !0,
          onClick: handleExport,
          title: t2("account.exportTransactions"),
          children: t2("account.export")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.columns, style$9.headers, style$9.showOnMedium].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.type, children: t2("transaction.details.type") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.date, children: t2("transaction.details.date") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.activity, children: t2("transaction.details.activity") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.status, children: t2("transaction.details.status") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.fiat, children: t2("transaction.details.fiatAmount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.currency, children: t2("transaction.details.amount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.action, children: " " })
    ] }),
    transactions2 && transactions2.success && transactions2.list.length > 0 ? transactions2.list.map((props, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      HOC$1,
      {
        accountCode,
        explorerURL,
        index,
        ...props
      },
      props.internalID
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-row flex-center ${style$9.empty}`, children: transactions2 && !transactions2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.errorLoadTransactions") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.placeholder") }) })
  ] });
}, "Transactions"), container$3 = "_container_8wadt_1", header = "_header_8wadt_12", actionsContainer = "_actionsContainer_8wadt_23", buy = "_buy_8wadt_29", receive = "_receive_8wadt_30", walletConnect = "_walletConnect_8wadt_31", send = "_send_8wadt_32", withWalletConnect = "_withWalletConnect_8wadt_50", disabled = "_disabled_8wadt_62", accountIcon = "_accountIcon_8wadt_71", style$7 = {
  container: container$3,
  header,
  actionsContainer,
  buy,
  receive,
  walletConnect,
  send,
  withWalletConnect,
  disabled,
  accountIcon
}, ActionButtons = /* @__PURE__ */ __name(({ canSend, code, coinCode, exchangeBuySupported, account: account2 }) => {
  const { t: t2 } = useTranslation(), navigate2 = useNavigate(), walletConnectEnabled = isEthereumBased(account2.coinCode) && !account2.isToken, isLargeTablet = useMediaQuery("(max-width: 830px)"), sendLink = `/account/${code}/send`, maybeRouteSend = /* @__PURE__ */ __name(async (e2) => {
    e2.preventDefault(), (await connectKeystore(code)).success && navigate2(sendLink);
  }, "maybeRouteSend");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$7.actionsContainer} ${walletConnectEnabled ? style$7.withWalletConnect : ""}`, children: [
    canSend ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: sendLink, className: style$7.send, onClick: isEthereumBased(coinCode) ? maybeRouteSend : void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.send") }) }, "sendLink") : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$7.send} ${style$7.disabled}`, children: t2("button.send") }, "sendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/account/${code}/receive`, className: style$7.receive, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.receive") }) }, "receive"),
    exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/buy/info/${code}`, className: style$7.buy, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.buy") }) }, "buy"),
    walletConnectEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/wallet-connect/dashboard`, className: style$7.walletConnect, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 24 }),
      " ",
      !isLargeTablet && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
    ] }, "wallet-connect")
  ] });
}, "ActionButtons");
function Account({
  accounts,
  code,
  devices
}) {
  const { t: t2 } = useTranslation(), [balance2, setBalance] = reactExports.useState(), [status2, setStatus] = reactExports.useState(), [syncedAddressesCount, setSyncedAddressesCount] = reactExports.useState(), [transactions2, setTransactions] = reactExports.useState(), [usesProxy, setUsesProxy] = reactExports.useState(), [stateCode, setStateCode] = reactExports.useState(), supportedExchanges = useLoad(getExchangeBuySupported(code), [code]);
  reactExports.useEffect(() => {
    apiGet("config").then(({ backend }) => setUsesProxy(backend.proxy.useProxy));
  }, []);
  const hasCard = useSDCard(devices, [code]), onAccountChanged = reactExports.useCallback((code2, status22) => {
    if (!(!code2 || status22 === void 0 || status22.fatalError))
      if (status22.synced && status22.offlineError === null) {
        const currentCode = code2;
        Promise.all([
          getBalance(currentCode).then((newBalance) => {
            currentCode === code2 && setBalance(newBalance);
          }),
          getTransactionList(code2).then((newTransactions) => {
            currentCode === code2 && setTransactions(newTransactions);
          })
        ]).catch(console.error);
      } else
        setBalance(void 0), setTransactions(void 0);
  }, []), onStatusChanged = reactExports.useCallback(() => {
    const currentCode = code;
    currentCode && getStatus$2(currentCode).then(async (status22) => {
      currentCode === code && (setStatus(status22), !status22.disabled && !status22.synced && await init(currentCode).catch(console.error), onAccountChanged(code, status22));
    }).catch(console.error);
  }, [onAccountChanged, code]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      syncAddressesCount(code)(setSyncedAddressesCount),
      statusChanged$1((eventCode) => eventCode === code && onStatusChanged()),
      syncdone((eventCode) => eventCode === code && onAccountChanged(code, status2))
    ];
    return () => unsubscribe(subscriptions2);
  }, [code, onAccountChanged, onStatusChanged, status2]);
  function exportAccount$1() {
    status2 === void 0 || status2.fatalError || exportAccount(code).then((result) => {
      result !== null && !result.success && alertUser(result.errorMessage);
    }).catch(console.error);
  }
  __name(exportAccount$1, "exportAccount$1"), reactExports.useEffect(() => {
    setStateCode(code), setBalance(void 0), setStatus(void 0), setSyncedAddressesCount(0), setTransactions(void 0), onStatusChanged();
  }, [code, onStatusChanged]);
  const hasDataLoaded = balance2 !== void 0 && transactions2 !== void 0, account2 = accounts && accounts.find((acct) => acct.code === code);
  if (stateCode !== code || !account2 || status2 === void 0)
    return null;
  const canSend = balance2 && balance2.hasAvailable, initializingSpinnerText = syncedAddressesCount !== void 0 && syncedAddressesCount > 1 ? `
` + t2("account.syncedAddressesCount", {
    count: syncedAddressesCount.toString(),
    defaultValue: 0
  }) : "", offlineErrorTextLines = [];
  status2.offlineError !== null && (offlineErrorTextLines.push(t2("account.reconnecting")), offlineErrorTextLines.push(status2.offlineError), usesProxy && offlineErrorTextLines.push(t2("account.maybeProxyError")));
  const exchangeBuySupported = supportedExchanges && supportedExchanges.exchanges.length > 0, isAccountEmpty = balance2 && !balance2.hasAvailable && !balance2.hasIncoming && transactions2 && transactions2.success && transactions2.list.length === 0, actionButtonsProps = {
    code,
    coinCode: account2.coinCode,
    canSend,
    exchangeBuySupported,
    account: account2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        SharedHeader,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name }) }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/info`, title: t2("accountInfo.title"), className: "flex flex-row flex-items-center m-left-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$7.accountIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("accountInfo.label") })
            ] })
          ]
        }
      ),
      status2.synced && hasDataLoaded && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(HeadersSync, { coinCode: account2.coinCode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer scrollableContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-reverse-mobile", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile hide-on-small", children: t2("accountSummary.availableBalance") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-item-center flex-column-mobile flex-reverse-mobile", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile show-on-small", children: t2("accountSummary.availableBalance") }),
            !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtons, { ...actionButtonsProps })
          ] })
        ] }),
        isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          BuyReceiveCTA,
          {
            account: account2,
            code,
            exchangeBuySupported,
            unit: balance2.available.unit,
            balanceList: [balance2]
          }
        ),
        !status2.synced || offlineErrorTextLines.length || !hasDataLoaded || status2.fatalError ? /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: !0, text: status2.fatalError && t2("account.fatalError") || offlineErrorTextLines.join(`
`) || !status2.synced && t2("account.initializing") + initializingSpinnerText || "" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Transactions,
          {
            accountCode: code,
            handleExport: exportAccount$1,
            explorerURL: account2.blockExplorerTxPrefix,
            transactions: transactions2
          }
        ) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccountGuide,
      {
        account: account2,
        unit: balance2 == null ? void 0 : balance2.available.unit,
        hasIncomingBalance: balance2 && balance2.hasIncoming,
        hasTransactions: transactions2 !== void 0 && transactions2.success && transactions2.list.length > 0,
        hasNoBalance: balance2 && balance2.available.amount === "0"
      }
    )
  ] });
}
__name(Account, "Account");
const ReceiveAccountsSelector = /* @__PURE__ */ __name(({ activeAccounts }) => {
  const [options2, setOptions] = reactExports.useState([]), [code, setCode] = reactExports.useState(""), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    const options22 = activeAccounts.map((account2) => ({ label: account2.name, value: account2.code, disabled: !1, coinCode: account2.coinCode }));
    setOptions(options22), getBalances(options22).then((options3) => setOptions(options3));
  }, [activeAccounts]);
  const handleProceed = /* @__PURE__ */ __name(() => {
    route(`/account/${code}/receive`);
  }, "handleProceed"), hasOnlyBTCAccounts = activeAccounts.every(({ coinCode }) => isBitcoinOnly(coinCode)), title2 = t2("receive.title", { accountName: hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto") }), getBalances = /* @__PURE__ */ __name(async (options22) => Promise.all(options22.map((option) => getBalance(option.value).then((balance2) => ({ ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` })))), "getBalances");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AccountSelector, { onChange: setCode, onProceed: handleProceed, options: options2, title: t2("receive.selectAccount"), selected: code }) }) })
  ] });
}, "ReceiveAccountsSelector"), DarkmodeToggleSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { toggleDarkmode, isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("darkmode.toggle"),
      secondaryText: t2("newSettings.appearance.darkmode.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { checked: isDarkMode, onChange: () => toggleDarkmode(!isDarkMode) })
    }
  );
}, "DarkmodeToggleSetting"), dropdown = "_dropdown_1uw27_1", select$2 = "_select_1uw27_10", dropdownStyles = {
  dropdown,
  select: select$2
}, DropdownIndicator2 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) }), "DropdownIndicator"), Option2 = /* @__PURE__ */ __name((props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
}, "Option"), SingleValue2 = /* @__PURE__ */ __name((props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
}, "SingleValue"), SingleDropdown = /* @__PURE__ */ __name(({ options: options2, handleChange, defaultValue }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  StateManagedSelect$1,
  {
    className: dropdownStyles.select,
    classNamePrefix: "react-select",
    isSearchable: !0,
    defaultValue,
    components: { IndicatorSeparator: () => null, DropdownIndicator: DropdownIndicator2, SingleValue: SingleValue2, Option: Option2 },
    onChange: (selected2) => {
      if (selected2) {
        const value = (selected2 == null ? void 0 : selected2.value) || "";
        handleChange(value);
      }
    },
    options: options2
  }
), "SingleDropdown"), DefaultCurrencyDropdownSetting = /* @__PURE__ */ __name(() => {
  var _a46;
  const { t: t2 } = useTranslation(), { selectFiat, updateDefaultFiat, defaultCurrency: defaultCurrency2, activeCurrencies } = reactExports.useContext(RatesContext), valueLabel = (_a46 = currenciesWithDisplayName.find((fiat2) => fiat2.currency === defaultCurrency2)) == null ? void 0 : _a46.displayName, defaultValueLabel = valueLabel ? `${valueLabel} (${defaultCurrency2})` : defaultCurrency2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.defaultCurrency.title"),
      secondaryText: t2("newSettings.appearance.defaultCurrency.description"),
      collapseOnSmall: !0,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedCurrencies,
          handleChange: async (fiat2) => {
            updateDefaultFiat(fiat2), activeCurrencies.includes(fiat2) || await selectFiat(fiat2);
          },
          defaultValue: {
            label: defaultValueLabel,
            value: defaultCurrency2
          }
        }
      )
    }
  );
}, "DefaultCurrencyDropdownSetting"), DisplaySatsToggleSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), fetchedConfig = useLoad(getConfig), [displayAsSAT, setDisplayAsSAT] = reactExports.useState(), { updateRatesConfig } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    fetchedConfig && setDisplayAsSAT(fetchedConfig.backend.btcUnit === "sat");
  }, [fetchedConfig]);
  const handleToggleSatsUnit = /* @__PURE__ */ __name(async () => {
    const toggleDdisplayAsSAT = !displayAsSAT, unit2 = toggleDdisplayAsSAT ? "sat" : "default";
    setDisplayAsSAT(toggleDdisplayAsSAT), await setConfig({
      backend: { btcUnit: unit2 }
    }), updateRatesConfig(), (await setBtcUnit(unit2)).success || alertUser(t2("genericError"));
  }, "handleToggleSatsUnit");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.useSats"),
      secondaryText: t2("newSettings.appearance.toggleSats.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: displayAsSAT !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: displayAsSAT,
          onChange: handleToggleSatsUnit
        }
      ) : null })
    }
  ) });
}, "DisplaySatsToggleSetting"), LanguageDropdownSetting = /* @__PURE__ */ __name(() => {
  const { i18n, t: t2 } = useTranslation(), selectedLanguage = defaultLanguages[getSelectedIndex(defaultLanguages, i18n)], formattedLanguages = defaultLanguages.map((lang) => ({ label: lang.display, value: lang.code }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.language.title"),
      secondaryText: t2("newSettings.appearance.language.description"),
      collapseOnSmall: !0,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedLanguages,
          handleChange: i18n.changeLanguage,
          defaultValue: { label: selectedLanguage.display, value: selectedLanguage.code }
        }
      )
    }
  );
}, "LanguageDropdownSetting"), select$1 = "_select_1j2fm_1", hideMultiSelect = "_hideMultiSelect_1j2fm_30", defaultCurrency = "_defaultCurrency_1j2fm_51", defaultLabel = "_defaultLabel_1j2fm_55", activeCurrenciesDropdownStyle = {
  select: select$1,
  hideMultiSelect,
  defaultCurrency,
  defaultLabel
}, ActiveCurrenciesDropdown = /* @__PURE__ */ __name(({
  options: options2,
  defaultCurrency: defaultCurrency2,
  activeCurrencies
}) => {
  const [formattedActiveCurrencies, setFormattedActiveCurrencies] = reactExports.useState([]), [search, setSearch] = reactExports.useState(""), { t: t2 } = useTranslation(), { unselectFiat, selectFiat } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (activeCurrencies.length > 0) {
      const formattedSelectedCurrencies = activeCurrencies.map((currency2) => ({ label: currency2, value: currency2 }));
      setFormattedActiveCurrencies(formattedSelectedCurrencies);
    }
  }, [activeCurrencies]);
  const DropdownIndicator3 = /* @__PURE__ */ __name((props) => /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) }), "DropdownIndicator"), Option3 = /* @__PURE__ */ __name((props) => {
    const { label: label2, value } = props.data, selected2 = formattedActiveCurrencies.findIndex((currency2) => currency2.value === value) >= 0, isDefaultCurrency = defaultCurrency2 === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(components.Option, { ...props, className: `${isDefaultCurrency ? activeCurrenciesDropdownStyle.defaultCurrency : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }),
      isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: activeCurrenciesDropdownStyle.defaultLabel, children: t2("fiat.default") }) : null,
      selected2 && !isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedCheckLight, {}) : null
    ] });
  }, "Option");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: `
         ${dropdownStyles.select}
         ${activeCurrenciesDropdownStyle.select}
         ${search.length > 0 ? activeCurrenciesDropdownStyle.hideMultiSelect : ""}
         `,
      classNamePrefix: "react-select",
      isSearchable: !0,
      isClearable: !1,
      components: { DropdownIndicator: DropdownIndicator3, IndicatorSeparator: () => null, MultiValueRemove: () => null, Option: Option3 },
      isMulti: !0,
      closeMenuOnSelect: !1,
      hideSelectedOptions: !1,
      value: [...formattedActiveCurrencies].reverse(),
      onInputChange: (newValue) => setSearch(newValue),
      onChange: async (_24, meta) => {
        switch (meta.action) {
          case "select-option":
            meta.option && await selectFiat(meta.option.value);
            break;
          case "deselect-option":
            meta.option && meta.option.value !== defaultCurrency2 && await unselectFiat(meta.option.value);
        }
      },
      options: options2
    }
  );
}, "ActiveCurrenciesDropdown"), ActiveCurrenciesDropdownSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), { activeCurrencies, defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      collapseOnSmall: !0,
      settingName: t2("newSettings.appearance.activeCurrencies.title"),
      secondaryText: t2("newSettings.appearance.activeCurrencies.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActiveCurrenciesDropdown,
        {
          options: formattedCurrencies,
          defaultCurrency: defaultCurrency2,
          activeCurrencies
        }
      )
    }
  );
}, "ActiveCurrenciesDropdownSetting"), HideAmountsSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [allowHideAmounts, setAllowHideAmounts] = reactExports.useState(), config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      if (config.frontend.allowHideAmounts === void 0) {
        setAllowHideAmounts(!1);
        return;
      }
      setAllowHideAmounts(config.frontend.allowHideAmounts);
    }
  }, [config]);
  const toggleAllowHideAmounts = /* @__PURE__ */ __name(async () => {
    setAllowHideAmounts(!allowHideAmounts), await setConfig({
      frontend: { allowHideAmounts: !allowHideAmounts }
    });
  }, "toggleAllowHideAmounts");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.hideAmounts.title"),
      secondaryText: t2("newSettings.appearance.hideAmounts.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: allowHideAmounts !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: allowHideAmounts,
          onChange: toggleAllowHideAmounts
        }
      ) : null })
    }
  );
}, "HideAmountsSetting"), Appearance = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.appearance") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { hasAccounts, hideMobileMenu: !0, deviceIDs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultCurrencyDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActiveCurrenciesDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DarkmodeToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySatsToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsSetting, {})
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppearanceGuide, {})
  ] });
}, "Appearance"), AppearanceGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.sats") }, "guide.settings.sats"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "guide.accountRates")
  ] });
}, "AppearanceGuide"), MobileSettings = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const isMobile = useMediaQuery("(max-width: 768px)"), { t: t2 } = useTranslation();
  return reactExports.useEffect(() => {
    isMobile || route("/settings/appearance");
  }, [isMobile]), /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { deviceIDs, hasAccounts }) }) })
  ] });
}, "MobileSettings"), AppVersion = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), version = useLoad(getVersion$1), update = useLoad(getUpdate), secondaryText2 = t2(update ? "settings.info.out-of-date" : "settings.info.up-to-date"), icon2 = update ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}), versionNumber = version || "-";
  return update === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.about.appVersion.title"),
      secondaryText: secondaryText2,
      displayedValue: versionNumber,
      extraComponent: icon2,
      onClick: update ? () => open(downloadLinkByLanguage()) : void 0
    }
  );
}, "AppVersion"), About = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.about") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WithSettingsTabs, { deviceIDs, hideMobileMenu: !0, hasAccounts, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppVersion, {}) }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AboutGuide, {})
  ] });
}, "About"), AboutGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Guide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.servers") }, "guide.settings.servers") });
}, "AboutGuide"), EnableCustomFeesToggleSetting = /* @__PURE__ */ __name(({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleFee = /* @__PURE__ */ __name(async (e2) => {
    const config = await setConfig({
      frontend: {
        expertFee: e2.target.checked
      }
    });
    onChangeConfig(config);
  }, "handleToggleFee");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.fee"),
      secondaryText: t2("newSettings.advancedSettings.customFees.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.expertFee) || !1,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
}, "EnableCustomFeesToggleSetting"), EnableCoinControlSetting = /* @__PURE__ */ __name(({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleFee = /* @__PURE__ */ __name(async (e2) => {
    const config = await setConfig({
      frontend: {
        coinControl: e2.target.checked
      }
    });
    onChangeConfig(config);
  }, "handleToggleFee");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.coinControl"),
      secondaryText: t2("newSettings.advancedSettings.coinControl.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.coinControl) || !1,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
}, "EnableCoinControlSetting"), ConnectFullNodeSetting = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.electrum.title"),
      onClick: () => route("/settings/electrum"),
      secondaryText: t2("settings.expert.electrum.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChevronRightDark,
        {
          width: 24,
          height: 24
        }
      )
    }
  );
}, "ConnectFullNodeSetting"), TorProxyDialog = /* @__PURE__ */ __name(({ open: open2, proxyConfig, onCloseDialog, onChangeConfig, handleShowRestartMessage }) => {
  const [proxyAddress, setProxyAddress] = reactExports.useState(), { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    proxyConfig && setProxyAddress(proxyConfig.proxyAddress);
  }, [proxyConfig]);
  const handleSetProxyButton = /* @__PURE__ */ __name(async () => {
    if (!proxyConfig || proxyAddress === void 0)
      return;
    const proxy = proxyConfig;
    proxy.proxyAddress = proxyAddress.trim();
    const result = await socksProxyCheck(proxy.proxyAddress), { success: success2, errorMessage } = result;
    success2 ? await setProxyConfig(proxy) : alertUser(errorMessage || t2("account.fatalError"));
  }, "handleSetProxyButton"), setProxyConfig = /* @__PURE__ */ __name(async (proxyConfig2) => {
    const config = await setConfig({
      backend: { proxy: proxyConfig2 }
    });
    setProxyAddress(proxyConfig2.proxyAddress), onChangeConfig(config), handleShowRestartMessage(!0);
  }, "setProxyConfig"), handleToggleProxy = /* @__PURE__ */ __name(async (e2) => {
    if (!proxyConfig)
      return;
    const proxy = { ...proxyConfig, useProxy: e2.target.checked };
    await setProxyConfig(proxy);
  }, "handleToggleProxy"), handleInputChange = /* @__PURE__ */ __name((e2) => {
    setProxyAddress(e2.target.value), handleShowRestartMessage(!1);
  }, "handleInputChange");
  return !proxyConfig || proxyConfig === void 0 || proxyAddress === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, onClose: onCloseDialog, title: t2("settings.expert.setProxyAddress"), small: !0, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("settings.expert.useProxy") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          id: "useProxy",
          checked: proxyConfig.useProxy,
          onChange: handleToggleProxy
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          name: "proxyAddress",
          onInput: handleInputChange,
          value: proxyAddress,
          placeholder: "127.0.0.1:9050",
          disabled: !proxyConfig.useProxy
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: !0,
          onClick: handleSetProxyButton,
          disabled: !proxyConfig.useProxy || proxyAddress === proxyConfig.proxyAddress,
          children: t2("settings.expert.setProxyAddress")
        }
      ) })
    ] })
  ] });
}, "TorProxyDialog"), inlineMessage = "_inlineMessage_gi9x3_1", success = "_success_gi9x3_7", left = "_left_gi9x3_12", close = "_close_gi9x3_16", style$6 = {
  inlineMessage,
  success,
  left,
  close
}, _InlineMessage = class _InlineMessage extends reactExports.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "deactivate", /* @__PURE__ */ __name(() => {
      this.props.onEnd();
    }, "deactivate"));
  }
  render() {
    const {
      type: type2,
      message: message2,
      align
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$6.inlineMessage, style$6[type2], align ? style$6[align] : ""].join(" "), children: [
      message2,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$6.close, onClick: this.deactivate, children: "✕" })
    ] });
  }
};
__name(_InlineMessage, "InlineMessage");
let InlineMessage = _InlineMessage;
const settingItem = "_settingItem_6ge6v_3", styles$c = {
  settingItem
}, EnableTorProxySetting = /* @__PURE__ */ __name(({ proxyConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), [showTorProxyDialog, setShowTorProxyDialog] = reactExports.useState(!1), [showRestartMessage, setShowRestartMessage] = reactExports.useState(!1), proxyEnabled = proxyConfig ? proxyConfig.useProxy : !1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showRestartMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineMessage,
      {
        type: "success",
        align: "left",
        message: t2("settings.restart"),
        onEnd: () => setShowRestartMessage(!1)
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        className: styles$c.settingItem,
        settingName: t2("settings.expert.useProxy"),
        onClick: () => setShowTorProxyDialog(!0),
        secondaryText: t2("newSettings.advancedSettings.torProxy.description"),
        displayedValue: t2(proxyEnabled ? "generic.enabled_true" : "generic.enabled_false"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, { width: 24, height: 24 })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TorProxyDialog,
      {
        open: showTorProxyDialog,
        proxyConfig,
        onCloseDialog: () => setShowTorProxyDialog(!1),
        onChangeConfig,
        handleShowRestartMessage: setShowRestartMessage
      }
    )
  ] });
}, "EnableTorProxySetting"), EnableAuthSetting = /* @__PURE__ */ __name(({ backendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation(), handleToggleAuth = /* @__PURE__ */ __name(async (e2) => {
    const unsubscribe2 = subscribeAuth((data) => {
      data.typ === "auth-ok" && (updateConfig(!e2.target.checked), unsubscribe2()), data.typ === "auth-canceled" && unsubscribe2();
    });
    forceAuth();
  }, "handleToggleAuth"), updateConfig = /* @__PURE__ */ __name(async (auth2) => {
    const config = await setConfig({
      backend: { authentication: auth2 }
    });
    onAuthSettingChanged(), onChangeConfig(config);
  }, "updateConfig");
  return runningInAndroid() ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.advancedSettings.authentication.title"),
      secondaryText: t2("newSettings.advancedSettings.authentication.description"),
      extraComponent: backendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (backendConfig == null ? void 0 : backendConfig.authentication) || !1,
          onChange: handleToggleAuth
        }
      ) : null
    }
  ) : null;
}, "EnableAuthSetting"), AdvancedSettings = /* @__PURE__ */ __name(({ deviceIDs, hasAccounts }) => {
  var _a46;
  const { t: t2 } = useTranslation(), fetchedConfig = useLoad(getConfig), [config, setConfig2] = reactExports.useState(), frontendConfig = config == null ? void 0 : config.frontend, backendConfig = config == null ? void 0 : config.backend, proxyConfig = (_a46 = config == null ? void 0 : config.backend) == null ? void 0 : _a46.proxy;
  return reactExports.useEffect(() => {
    setConfig2(fetchedConfig);
  }, [fetchedConfig]), /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          hideSidebarToggler: !0,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: !0, title: t2("settings.advancedSettings") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: !0,
          hasAccounts,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCustomFeesToggleSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCoinControlSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableAuthSetting, { backendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableTorProxySetting, { proxyConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectFullNodeSetting, {})
          ]
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSettingsGuide, {})
  ] });
}, "AdvancedSettings"), AdvancedSettingsGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor")
  ] });
}, "AdvancedSettingsGuide"), WCWeb3WalletContext = reactExports.createContext({}), WCGuide = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.whatIsWalletConnect")
      },
      "guide.walletConnect.whatIsWalletConnect"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.supportedNetworks")
      },
      "guide.walletConnect.supportedNetworks"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.noPreviousConnections")
      },
      "guide.walletConnect.noPreviousConnections"
    )
  ] });
}, "WCGuide"), SUPPORTED_CHAINS = {
  "eip155:1": {
    name: "Etherum mainnet",
    icon: reactExports.createElement(ETHLogo)
  },
  "eip155:5": {
    name: "Ethereum goerli",
    icon: reactExports.createElement(ETHLogo)
  }
}, EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  /**
     * Many dapps will request an 'eth_signTypedData' but in reality expect 'eth_signTypedData_v4'
     * because that's basically the standard. V4 is assumed, but not necessarily asked for specifically.
     * There aren't many uses of V3 in the wild, but leaving in just in case and returning a v4 signature instead,
     * the dapp can validate this anyway
     */
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction"
}, getAddressFromEIPString = /* @__PURE__ */ __name((address2) => {
  const parts = address2.split(":");
  return parts.length > 2 ? parts[2] : "";
}, "getAddressFromEIPString"), truncateAddress = /* @__PURE__ */ __name((address2) => address2 ? `${address2.substring(0, 6)}...${address2.substring(address2.length - 6)}` : "", "truncateAddress"), getTopicFromURI = /* @__PURE__ */ __name((wcURI) => {
  try {
    return wcURI.split(":")[1].split("@")[0];
  } catch {
    return "";
  }
}, "getTopicFromURI"), pairingHasEverBeenRejected = /* @__PURE__ */ __name((topic, web3wallet) => web3wallet.core.history.values.findIndex((history) => history.topic === topic && history.response && "error" in history.response) >= 0, "pairingHasEverBeenRejected"), rejectMessage = /* @__PURE__ */ __name((id2) => ({
  id: id2,
  jsonrpc: "2.0",
  error: {
    code: 5e3,
    message: "User rejected."
  }
}), "rejectMessage"), decodeEthMessage = /* @__PURE__ */ __name((hex) => {
  if (hex = hex.trim(), hex.startsWith("0x") && (hex = hex.substring(2)), hex.length % 2 !== 0 || !/^[0-9a-fA-F]*$/.test(hex))
    return console.error("Invalid hex string"), null;
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const byte = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
    if (isNaN(byte))
      return console.error("Invalid byte in hex string"), null;
    bytes[i] = byte;
  }
  return new TextDecoder("utf-8").decode(bytes);
}, "decodeEthMessage"), headerContainer$1 = "_headerContainer_wug0g_1", accountName$2 = "_accountName_wug0g_28", receiveAddress$3 = "_receiveAddress_wug0g_32", styles$b = {
  headerContainer: headerContainer$1,
  accountName: accountName$2,
  receiveAddress: receiveAddress$3
}, WCHeader = /* @__PURE__ */ __name(({ receiveAddress: receiveAddress2, accountName: accountName2 }) => {
  const displayedReceiveAddress = truncateAddress(receiveAddress2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$b.headerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDefaultLogo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "WalletConnect" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$b.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$b.receiveAddress, children: displayedReceiveAddress })
  ] });
}, "WCHeader"), formContainer = "_formContainer_1wrji_1", formButtonsContainer = "_formButtonsContainer_1wrji_6", inputWithIcon = "_inputWithIcon_1wrji_11", mobileQRScanner = "_mobileQRScanner_1wrji_28", scanQRLabel = "_scanQRLabel_1wrji_41", styles$a = {
  formContainer,
  formButtonsContainer,
  inputWithIcon,
  mobileQRScanner,
  scanQRLabel
}, MobileQRScanner = /* @__PURE__ */ __name(({ onQRScanned }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.mobileQRScanner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.scanQRLabel, children: t2("send.scanQR") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRVideo, { onResult: onQRScanned })
  ] });
}, "MobileQRScanner"), WCConnectForm = /* @__PURE__ */ __name(({
  code,
  uri,
  onInputChange,
  onSubmit,
  connectLoading
}) => {
  const { t: t2 } = useTranslation(), isMobile = useMediaQuery("(max-width: 768px)"), [activeScanQR, setActiveScanQR] = reactExports.useState(isMobile), showMobileQRReader = isMobile, showQRButton = !isMobile, toggleScanQR = /* @__PURE__ */ __name(() => {
    if (activeScanQR) {
      setActiveScanQR(!1);
      return;
    }
    setActiveScanQR(!0);
  }, "toggleScanQR");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.formContainer, children: [
    showMobileQRReader && /* @__PURE__ */ jsxRuntimeExports.jsx(MobileQRScanner, { onQRScanned: onSubmit }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        onSubmit: (e2) => {
          e2.preventDefault(), onSubmit(uri);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              label: t2("walletConnect.connect.dappLabel"),
              className: showQRButton ? styles$a.inputWithIcon : "",
              value: uri,
              readOnly: connectLoading,
              onInput: (e2) => onInputChange(e2.target.value.replace(/\s/g, "")),
              children: showQRButton && !connectLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ScanQRDialog,
            {
              activeScanQR: activeScanQR && !isMobile,
              toggleScanQR,
              onChangeActiveScanQR: setActiveScanQR,
              parseQRResult: (uri2) => onSubmit(uri2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.formButtonsContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading,
                secondary: !0,
                onClick: () => route(`/account/${code}/wallet-connect/dashboard`),
                children: t2("dialog.cancel")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading || !uri,
                type: "submit",
                primary: !0,
                children: t2("walletConnect.connect.button")
              }
            )
          ] })
        ]
      }
    )
  ] });
}, "WCConnectForm");
var chacha20poly1305 = {}, chacha = {}, binary = {}, int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  function imulShim(a2, b2) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535, bh2 = b2 >>> 16 & 65535, bl2 = b2 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  __name(imulShim, "imulShim"), exports.mul = Math.imul || imulShim;
  function add(a2, b2) {
    return a2 + b2 | 0;
  }
  __name(add, "add"), exports.add = add;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  __name(sub, "sub"), exports.sub = sub;
  function rotl(x2, n2) {
    return x2 << n2 | x2 >>> 32 - n2;
  }
  __name(rotl, "rotl"), exports.rotl = rotl;
  function rotr(x2, n2) {
    return x2 << 32 - n2 | x2 >>> n2;
  }
  __name(rotr, "rotr"), exports.rotr = rotr;
  function isIntegerShim(n2) {
    return typeof n2 == "number" && isFinite(n2) && Math.floor(n2) === n2;
  }
  __name(isIntegerShim, "isIntegerShim"), exports.isInteger = Number.isInteger || isIntegerShim, exports.MAX_SAFE_INTEGER = 9007199254740991, exports.isSafeInteger = function(n2) {
    return exports.isInteger(n2) && n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER;
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: !0 });
var int_1 = int;
function readInt16BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
__name(readInt16BE, "readInt16BE");
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
__name(readUint16BE, "readUint16BE");
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
__name(readInt16LE, "readInt16LE");
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 1] << 8 | array[offset]) >>> 0;
}
__name(readUint16LE, "readUint16LE");
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(2)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 8, out[offset + 1] = value >>> 0, out;
}
__name(writeUint16BE, "writeUint16BE");
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(2)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 0, out[offset + 1] = value >>> 8, out;
}
__name(writeUint16LE, "writeUint16LE");
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  return offset === void 0 && (offset = 0), array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
__name(readInt32BE, "readInt32BE");
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
__name(readUint32BE, "readUint32BE");
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  return offset === void 0 && (offset = 0), array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
__name(readInt32LE, "readInt32LE");
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  return offset === void 0 && (offset = 0), (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
__name(readUint32LE, "readUint32LE");
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 24, out[offset + 1] = value >>> 16, out[offset + 2] = value >>> 8, out[offset + 3] = value >>> 0, out;
}
__name(writeUint32BE, "writeUint32BE");
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0), out[offset + 0] = value >>> 0, out[offset + 1] = value >>> 8, out[offset + 2] = value >>> 16, out[offset + 3] = value >>> 24, out;
}
__name(writeUint32LE, "writeUint32LE");
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var hi2 = readInt32BE(array, offset), lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
__name(readInt64BE, "readInt64BE");
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var hi2 = readUint32BE(array, offset), lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
__name(readUint64BE, "readUint64BE");
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var lo = readInt32LE(array, offset), hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
__name(readInt64LE, "readInt64LE");
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var lo = readUint32LE(array, offset), hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
__name(readUint64LE, "readUint64LE");
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0), writeUint32BE(value / 4294967296 >>> 0, out, offset), writeUint32BE(value >>> 0, out, offset + 4), out;
}
__name(writeUint64BE, "writeUint64BE");
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  return out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0), writeUint32LE(value >>> 0, out, offset), writeUint32LE(value / 4294967296 >>> 0, out, offset + 4), out;
}
__name(writeUint64LE, "writeUint64LE");
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  if (bitLength / 8 > array.length - offset)
    throw new Error("readUintBE: array is too short for the given bitLength");
  for (var result = 0, mul = 1, i = bitLength / 8 + offset - 1; i >= offset; i--)
    result += array[i] * mul, mul *= 256;
  return result;
}
__name(readUintBE, "readUintBE");
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  if (bitLength / 8 > array.length - offset)
    throw new Error("readUintLE: array is too short for the given bitLength");
  for (var result = 0, mul = 1, i = offset; i < offset + bitLength / 8; i++)
    result += array[i] * mul, mul *= 256;
  return result;
}
__name(readUintLE, "readUintLE");
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0 && (out = new Uint8Array(bitLength / 8)), offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(value))
    throw new Error("writeUintBE value must be an integer");
  for (var div = 1, i = bitLength / 8 + offset - 1; i >= offset; i--)
    out[i] = value / div & 255, div *= 256;
  return out;
}
__name(writeUintBE, "writeUintBE");
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0 && (out = new Uint8Array(bitLength / 8)), offset === void 0 && (offset = 0), bitLength % 8 !== 0)
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  if (!int_1.isSafeInteger(value))
    throw new Error("writeUintLE value must be an integer");
  for (var div = 1, i = offset; i < offset + bitLength / 8; i++)
    out[i] = value / div & 255, div *= 256;
  return out;
}
__name(writeUintLE, "writeUintLE");
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
__name(readFloat32BE, "readFloat32BE");
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, !0);
}
__name(readFloat32LE, "readFloat32LE");
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
__name(readFloat64BE, "readFloat64BE");
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  offset === void 0 && (offset = 0);
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, !0);
}
__name(readFloat64LE, "readFloat64LE");
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat32(offset, value), out;
}
__name(writeFloat32BE, "writeFloat32BE");
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(4)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat32(offset, value, !0), out;
}
__name(writeFloat32LE, "writeFloat32LE");
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat64(offset, value), out;
}
__name(writeFloat64BE, "writeFloat64BE");
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  out === void 0 && (out = new Uint8Array(8)), offset === void 0 && (offset = 0);
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  return view.setFloat64(offset, value, !0), out;
}
__name(writeFloat64LE, "writeFloat64LE");
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: !0 });
function wipe(array) {
  for (var i = 0; i < array.length; i++)
    array[i] = 0;
  return array;
}
__name(wipe, "wipe");
wipe$1.wipe = wipe;
Object.defineProperty(chacha, "__esModule", { value: !0 });
var binary_1 = binary, wipe_1$3 = wipe$1, ROUNDS = 20;
function core(out, input2, key) {
  for (var j0 = 1634760805, j1 = 857760878, j2 = 2036477234, j3 = 1797285236, j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0], j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4], j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8], j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12], j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16], j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20], j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24], j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28], j12 = input2[3] << 24 | input2[2] << 16 | input2[1] << 8 | input2[0], j13 = input2[7] << 24 | input2[6] << 16 | input2[5] << 8 | input2[4], j14 = input2[11] << 24 | input2[10] << 16 | input2[9] << 8 | input2[8], j15 = input2[15] << 24 | input2[14] << 16 | input2[13] << 8 | input2[12], x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, i = 0; i < ROUNDS; i += 2)
    x0 = x0 + x4 | 0, x12 ^= x0, x12 = x12 >>> 32 - 16 | x12 << 16, x8 = x8 + x12 | 0, x4 ^= x8, x4 = x4 >>> 32 - 12 | x4 << 12, x1 = x1 + x5 | 0, x13 ^= x1, x13 = x13 >>> 32 - 16 | x13 << 16, x9 = x9 + x13 | 0, x5 ^= x9, x5 = x5 >>> 32 - 12 | x5 << 12, x2 = x2 + x6 | 0, x14 ^= x2, x14 = x14 >>> 32 - 16 | x14 << 16, x10 = x10 + x14 | 0, x6 ^= x10, x6 = x6 >>> 32 - 12 | x6 << 12, x3 = x3 + x7 | 0, x15 ^= x3, x15 = x15 >>> 32 - 16 | x15 << 16, x11 = x11 + x15 | 0, x7 ^= x11, x7 = x7 >>> 32 - 12 | x7 << 12, x2 = x2 + x6 | 0, x14 ^= x2, x14 = x14 >>> 32 - 8 | x14 << 8, x10 = x10 + x14 | 0, x6 ^= x10, x6 = x6 >>> 32 - 7 | x6 << 7, x3 = x3 + x7 | 0, x15 ^= x3, x15 = x15 >>> 32 - 8 | x15 << 8, x11 = x11 + x15 | 0, x7 ^= x11, x7 = x7 >>> 32 - 7 | x7 << 7, x1 = x1 + x5 | 0, x13 ^= x1, x13 = x13 >>> 32 - 8 | x13 << 8, x9 = x9 + x13 | 0, x5 ^= x9, x5 = x5 >>> 32 - 7 | x5 << 7, x0 = x0 + x4 | 0, x12 ^= x0, x12 = x12 >>> 32 - 8 | x12 << 8, x8 = x8 + x12 | 0, x4 ^= x8, x4 = x4 >>> 32 - 7 | x4 << 7, x0 = x0 + x5 | 0, x15 ^= x0, x15 = x15 >>> 32 - 16 | x15 << 16, x10 = x10 + x15 | 0, x5 ^= x10, x5 = x5 >>> 32 - 12 | x5 << 12, x1 = x1 + x6 | 0, x12 ^= x1, x12 = x12 >>> 32 - 16 | x12 << 16, x11 = x11 + x12 | 0, x6 ^= x11, x6 = x6 >>> 32 - 12 | x6 << 12, x2 = x2 + x7 | 0, x13 ^= x2, x13 = x13 >>> 32 - 16 | x13 << 16, x8 = x8 + x13 | 0, x7 ^= x8, x7 = x7 >>> 32 - 12 | x7 << 12, x3 = x3 + x4 | 0, x14 ^= x3, x14 = x14 >>> 32 - 16 | x14 << 16, x9 = x9 + x14 | 0, x4 ^= x9, x4 = x4 >>> 32 - 12 | x4 << 12, x2 = x2 + x7 | 0, x13 ^= x2, x13 = x13 >>> 32 - 8 | x13 << 8, x8 = x8 + x13 | 0, x7 ^= x8, x7 = x7 >>> 32 - 7 | x7 << 7, x3 = x3 + x4 | 0, x14 ^= x3, x14 = x14 >>> 32 - 8 | x14 << 8, x9 = x9 + x14 | 0, x4 ^= x9, x4 = x4 >>> 32 - 7 | x4 << 7, x1 = x1 + x6 | 0, x12 ^= x1, x12 = x12 >>> 32 - 8 | x12 << 8, x11 = x11 + x12 | 0, x6 ^= x11, x6 = x6 >>> 32 - 7 | x6 << 7, x0 = x0 + x5 | 0, x15 ^= x0, x15 = x15 >>> 32 - 8 | x15 << 8, x10 = x10 + x15 | 0, x5 ^= x10, x5 = x5 >>> 32 - 7 | x5 << 7;
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0), binary_1.writeUint32LE(x1 + j1 | 0, out, 4), binary_1.writeUint32LE(x2 + j2 | 0, out, 8), binary_1.writeUint32LE(x3 + j3 | 0, out, 12), binary_1.writeUint32LE(x4 + j4 | 0, out, 16), binary_1.writeUint32LE(x5 + j5 | 0, out, 20), binary_1.writeUint32LE(x6 + j6 | 0, out, 24), binary_1.writeUint32LE(x7 + j7 | 0, out, 28), binary_1.writeUint32LE(x8 + j8 | 0, out, 32), binary_1.writeUint32LE(x9 + j9 | 0, out, 36), binary_1.writeUint32LE(x10 + j10 | 0, out, 40), binary_1.writeUint32LE(x11 + j11 | 0, out, 44), binary_1.writeUint32LE(x12 + j12 | 0, out, 48), binary_1.writeUint32LE(x13 + j13 | 0, out, 52), binary_1.writeUint32LE(x14 + j14 | 0, out, 56), binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
__name(core, "core");
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0 && (nonceInplaceCounterLength = 0), key.length !== 32)
    throw new Error("ChaCha: key size must be 32 bytes");
  if (dst.length < src2.length)
    throw new Error("ChaCha: destination is shorter than source");
  var nc2, counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12)
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    nc2 = new Uint8Array(16), counterLength = nc2.length - nonce.length, nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16)
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    nc2 = nonce, counterLength = nonceInplaceCounterLength;
  }
  for (var block2 = new Uint8Array(64), i = 0; i < src2.length; i += 64) {
    core(block2, nc2, key);
    for (var j2 = i; j2 < i + 64 && j2 < src2.length; j2++)
      dst[j2] = src2[j2] ^ block2[j2 - i];
    incrementCounter(nc2, 0, counterLength);
  }
  return wipe_1$3.wipe(block2), nonceInplaceCounterLength === 0 && wipe_1$3.wipe(nc2), dst;
}
__name(streamXOR, "streamXOR");
chacha.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  return nonceInplaceCounterLength === void 0 && (nonceInplaceCounterLength = 0), wipe_1$3.wipe(dst), streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
__name(stream, "stream");
chacha.stream = stream;
function incrementCounter(counter, pos, len) {
  for (var carry = 1; len--; )
    carry = carry + (counter[pos] & 255) | 0, counter[pos] = carry & 255, carry >>>= 8, pos++;
  if (carry > 0)
    throw new Error("ChaCha: counter overflow");
}
__name(incrementCounter, "incrementCounter");
var poly1305 = {}, constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: !0 });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
__name(select, "select");
constantTime.select = select;
function lessOrEqual(a2, b2) {
  return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
__name(lessOrEqual, "lessOrEqual");
constantTime.lessOrEqual = lessOrEqual;
function compare(a2, b2) {
  if (a2.length !== b2.length)
    return 0;
  for (var result = 0, i = 0; i < a2.length; i++)
    result |= a2[i] ^ b2[i];
  return 1 & result - 1 >>> 8;
}
__name(compare, "compare");
constantTime.compare = compare;
function equal$1(a2, b2) {
  return a2.length === 0 || b2.length === 0 ? !1 : compare(a2, b2) !== 0;
}
__name(equal$1, "equal$1");
constantTime.equal = equal$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var constant_time_12 = constantTime, wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH, this._buffer = new Uint8Array(16), this._r = new Uint16Array(10), this._h = new Uint16Array(10), this._pad = new Uint16Array(8), this._leftover = 0, this._fin = 0, this._finished = !1;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255, this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191, this._r[9] = t7 >>> 5 & 127, this._pad[0] = key[16] | key[17] << 8, this._pad[1] = key[18] | key[19] << 8, this._pad[2] = key[20] | key[21] << 8, this._pad[3] = key[22] | key[23] << 8, this._pad[4] = key[24] | key[25] << 8, this._pad[5] = key[26] | key[27] << 8, this._pad[6] = key[28] | key[29] << 8, this._pad[7] = key[30] | key[31] << 8;
      }
      return __name(Poly13052, "Poly1305"), Poly13052.prototype._blocks = function(m2, mpos, bytes) {
        for (var hibit = this._fin ? 0 : 2048, h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9], r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9]; bytes >= 16; ) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191, h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191, h9 += t7 >>> 5 | hibit;
          var c2 = 0, d0 = c2;
          d0 += h0 * r0, d0 += h1 * (5 * r9), d0 += h2 * (5 * r8), d0 += h3 * (5 * r7), d0 += h4 * (5 * r6), c2 = d0 >>> 13, d0 &= 8191, d0 += h5 * (5 * r5), d0 += h6 * (5 * r4), d0 += h7 * (5 * r3), d0 += h8 * (5 * r2), d0 += h9 * (5 * r1), c2 += d0 >>> 13, d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1, d1 += h1 * r0, d1 += h2 * (5 * r9), d1 += h3 * (5 * r8), d1 += h4 * (5 * r7), c2 = d1 >>> 13, d1 &= 8191, d1 += h5 * (5 * r6), d1 += h6 * (5 * r5), d1 += h7 * (5 * r4), d1 += h8 * (5 * r3), d1 += h9 * (5 * r2), c2 += d1 >>> 13, d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2, d2 += h1 * r1, d2 += h2 * r0, d2 += h3 * (5 * r9), d2 += h4 * (5 * r8), c2 = d2 >>> 13, d2 &= 8191, d2 += h5 * (5 * r7), d2 += h6 * (5 * r6), d2 += h7 * (5 * r5), d2 += h8 * (5 * r4), d2 += h9 * (5 * r3), c2 += d2 >>> 13, d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3, d3 += h1 * r2, d3 += h2 * r1, d3 += h3 * r0, d3 += h4 * (5 * r9), c2 = d3 >>> 13, d3 &= 8191, d3 += h5 * (5 * r8), d3 += h6 * (5 * r7), d3 += h7 * (5 * r6), d3 += h8 * (5 * r5), d3 += h9 * (5 * r4), c2 += d3 >>> 13, d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4, d4 += h1 * r3, d4 += h2 * r2, d4 += h3 * r1, d4 += h4 * r0, c2 = d4 >>> 13, d4 &= 8191, d4 += h5 * (5 * r9), d4 += h6 * (5 * r8), d4 += h7 * (5 * r7), d4 += h8 * (5 * r6), d4 += h9 * (5 * r5), c2 += d4 >>> 13, d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5, d5 += h1 * r4, d5 += h2 * r3, d5 += h3 * r2, d5 += h4 * r1, c2 = d5 >>> 13, d5 &= 8191, d5 += h5 * r0, d5 += h6 * (5 * r9), d5 += h7 * (5 * r8), d5 += h8 * (5 * r7), d5 += h9 * (5 * r6), c2 += d5 >>> 13, d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6, d6 += h1 * r5, d6 += h2 * r4, d6 += h3 * r3, d6 += h4 * r2, c2 = d6 >>> 13, d6 &= 8191, d6 += h5 * r1, d6 += h6 * r0, d6 += h7 * (5 * r9), d6 += h8 * (5 * r8), d6 += h9 * (5 * r7), c2 += d6 >>> 13, d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7, d7 += h1 * r6, d7 += h2 * r5, d7 += h3 * r4, d7 += h4 * r3, c2 = d7 >>> 13, d7 &= 8191, d7 += h5 * r2, d7 += h6 * r1, d7 += h7 * r0, d7 += h8 * (5 * r9), d7 += h9 * (5 * r8), c2 += d7 >>> 13, d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8, d8 += h1 * r7, d8 += h2 * r6, d8 += h3 * r5, d8 += h4 * r4, c2 = d8 >>> 13, d8 &= 8191, d8 += h5 * r3, d8 += h6 * r2, d8 += h7 * r1, d8 += h8 * r0, d8 += h9 * (5 * r9), c2 += d8 >>> 13, d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9, d9 += h1 * r8, d9 += h2 * r7, d9 += h3 * r6, d9 += h4 * r5, c2 = d9 >>> 13, d9 &= 8191, d9 += h5 * r4, d9 += h6 * r3, d9 += h7 * r2, d9 += h8 * r1, d9 += h9 * r0, c2 += d9 >>> 13, d9 &= 8191, c2 = (c2 << 2) + c2 | 0, c2 = c2 + d0 | 0, d0 = c2 & 8191, c2 = c2 >>> 13, d1 += c2, h0 = d0, h1 = d1, h2 = d2, h3 = d3, h4 = d4, h5 = d5, h6 = d6, h7 = d7, h8 = d8, h9 = d9, mpos += 16, bytes -= 16;
        }
        this._h[0] = h0, this._h[1] = h1, this._h[2] = h2, this._h[3] = h3, this._h[4] = h4, this._h[5] = h5, this._h[6] = h6, this._h[7] = h7, this._h[8] = h8, this._h[9] = h9;
      }, Poly13052.prototype.finish = function(mac, macpos) {
        macpos === void 0 && (macpos = 0);
        var g2 = new Uint16Array(10), c2, mask, f2, i;
        if (this._leftover) {
          for (i = this._leftover, this._buffer[i++] = 1; i < 16; i++)
            this._buffer[i] = 0;
          this._fin = 1, this._blocks(this._buffer, 0, 16);
        }
        for (c2 = this._h[1] >>> 13, this._h[1] &= 8191, i = 2; i < 10; i++)
          this._h[i] += c2, c2 = this._h[i] >>> 13, this._h[i] &= 8191;
        for (this._h[0] += c2 * 5, c2 = this._h[0] >>> 13, this._h[0] &= 8191, this._h[1] += c2, c2 = this._h[1] >>> 13, this._h[1] &= 8191, this._h[2] += c2, g2[0] = this._h[0] + 5, c2 = g2[0] >>> 13, g2[0] &= 8191, i = 1; i < 10; i++)
          g2[i] = this._h[i] + c2, c2 = g2[i] >>> 13, g2[i] &= 8191;
        for (g2[9] -= 8192, mask = (c2 ^ 1) - 1, i = 0; i < 10; i++)
          g2[i] &= mask;
        for (mask = ~mask, i = 0; i < 10; i++)
          this._h[i] = this._h[i] & mask | g2[i];
        for (this._h[0] = (this._h[0] | this._h[1] << 13) & 65535, this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535, this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535, this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535, this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535, this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535, this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535, this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535, f2 = this._h[0] + this._pad[0], this._h[0] = f2 & 65535, i = 1; i < 8; i++)
          f2 = (this._h[i] + this._pad[i] | 0) + (f2 >>> 16) | 0, this._h[i] = f2 & 65535;
        return mac[macpos + 0] = this._h[0] >>> 0, mac[macpos + 1] = this._h[0] >>> 8, mac[macpos + 2] = this._h[1] >>> 0, mac[macpos + 3] = this._h[1] >>> 8, mac[macpos + 4] = this._h[2] >>> 0, mac[macpos + 5] = this._h[2] >>> 8, mac[macpos + 6] = this._h[3] >>> 0, mac[macpos + 7] = this._h[3] >>> 8, mac[macpos + 8] = this._h[4] >>> 0, mac[macpos + 9] = this._h[4] >>> 8, mac[macpos + 10] = this._h[5] >>> 0, mac[macpos + 11] = this._h[5] >>> 8, mac[macpos + 12] = this._h[6] >>> 0, mac[macpos + 13] = this._h[6] >>> 8, mac[macpos + 14] = this._h[7] >>> 0, mac[macpos + 15] = this._h[7] >>> 8, this._finished = !0, this;
      }, Poly13052.prototype.update = function(m2) {
        var mpos = 0, bytes = m2.length, want;
        if (this._leftover) {
          want = 16 - this._leftover, want > bytes && (want = bytes);
          for (var i = 0; i < want; i++)
            this._buffer[this._leftover + i] = m2[mpos + i];
          if (bytes -= want, mpos += want, this._leftover += want, this._leftover < 16)
            return this;
          this._blocks(this._buffer, 0, 16), this._leftover = 0;
        }
        if (bytes >= 16 && (want = bytes - bytes % 16, this._blocks(m2, mpos, want), mpos += want, bytes -= want), bytes) {
          for (var i = 0; i < bytes; i++)
            this._buffer[this._leftover + i] = m2[mpos + i];
          this._leftover += bytes;
        }
        return this;
      }, Poly13052.prototype.digest = function() {
        if (this._finished)
          throw new Error("Poly1305 was finished");
        var mac = new Uint8Array(16);
        return this.finish(mac), mac;
      }, Poly13052.prototype.clean = function() {
        return wipe_12.wipe(this._buffer), wipe_12.wipe(this._r), wipe_12.wipe(this._h), wipe_12.wipe(this._pad), this._leftover = 0, this._fin = 0, this._finished = !0, this;
      }, Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data) {
    var h2 = new Poly1305(key);
    h2.update(data);
    var digest = h2.digest();
    return h2.clean(), digest;
  }
  __name(oneTimeAuth, "oneTimeAuth"), exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b2) {
    return a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH ? !1 : constant_time_12.equal(a2, b2);
  }
  __name(equal2, "equal"), exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var chacha_1 = chacha, poly1305_1 = poly1305, wipe_12 = wipe$1, binary_12 = binary, constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32, exports.NONCE_LENGTH = 12, exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16), ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key) {
        if (this.nonceLength = exports.NONCE_LENGTH, this.tagLength = exports.TAG_LENGTH, key.length !== exports.KEY_LENGTH)
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        this._key = new Uint8Array(key);
      }
      return __name(ChaCha20Poly13052, "ChaCha20Poly1305"), ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength, result;
        if (dst) {
          if (dst.length !== resultLength)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          result = dst;
        } else
          result = new Uint8Array(resultLength);
        return chacha_1.streamXOR(this._key, counter, plaintext, result, 4), this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData), wipe_12.wipe(counter), result;
      }, ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16)
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        if (sealed.length < this.tagLength)
          return null;
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        if (this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData), !constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length)))
          return null;
        var resultLength = sealed.length - this.tagLength, result;
        if (dst) {
          if (dst.length !== resultLength)
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          result = dst;
        } else
          result = new Uint8Array(resultLength);
        return chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4), wipe_12.wipe(counter), result;
      }, ChaCha20Poly13052.prototype.clean = function() {
        return wipe_12.wipe(this._key), this;
      }, ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h2 = new poly1305_1.Poly1305(authKey);
        associatedData && (h2.update(associatedData), associatedData.length % 16 > 0 && h2.update(ZEROS.subarray(associatedData.length % 16))), h2.update(ciphertext), ciphertext.length % 16 > 0 && h2.update(ZEROS.subarray(ciphertext.length % 16));
        var length2 = new Uint8Array(8);
        associatedData && binary_12.writeUint64LE(associatedData.length, length2), h2.update(length2), binary_12.writeUint64LE(ciphertext.length, length2), h2.update(length2);
        for (var tag = h2.digest(), i = 0; i < tag.length; i++)
          tagOut[i] = tag[i];
        h2.clean(), wipe_12.wipe(tag), wipe_12.wipe(length2);
      }, ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {}, hmac$1 = {}, hash = {};
Object.defineProperty(hash, "__esModule", { value: !0 });
function isSerializableHash(h2) {
  return typeof h2.saveState < "u" && typeof h2.restoreState < "u" && typeof h2.cleanSavedState < "u";
}
__name(isSerializableHash, "isSerializableHash");
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: !0 });
var hash_1 = hash, constant_time_1 = constantTime, wipe_1$2 = wipe$1, HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key) {
      this._finished = !1, this._inner = new hash2(), this._outer = new hash2(), this.blockSize = this._outer.blockSize, this.digestLength = this._outer.digestLength;
      var pad = new Uint8Array(this.blockSize);
      key.length > this.blockSize ? this._inner.update(key).finish(pad).clean() : pad.set(key);
      for (var i = 0; i < pad.length; i++)
        pad[i] ^= 54;
      this._inner.update(pad);
      for (var i = 0; i < pad.length; i++)
        pad[i] ^= 106;
      this._outer.update(pad), hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer) && (this._innerKeyedState = this._inner.saveState(), this._outerKeyedState = this._outer.saveState()), wipe_1$2.wipe(pad);
    }
    return __name(HMAC2, "HMAC"), HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      return this._inner.restoreState(this._innerKeyedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, HMAC2.prototype.clean = function() {
      hash_1.isSerializableHash(this._inner) && this._inner.cleanSavedState(this._innerKeyedState), hash_1.isSerializableHash(this._outer) && this._outer.cleanSavedState(this._outerKeyedState), this._inner.clean(), this._outer.clean();
    }, HMAC2.prototype.update = function(data) {
      return this._inner.update(data), this;
    }, HMAC2.prototype.finish = function(out) {
      return this._finished ? (this._outer.finish(out), this) : (this._inner.finish(out), this._outer.update(out.subarray(0, this.digestLength)).finish(out), this._finished = !0, this);
    }, HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      return this.finish(out), out;
    }, HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      return this._inner.saveState();
    }, HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer))
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      return this._inner.restoreState(savedState), this._outer.restoreState(this._outerKeyedState), this._finished = !1, this;
    }, HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner))
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      this._inner.cleanSavedState(savedState);
    }, HMAC2;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(hash2, key, data) {
  var h2 = new HMAC(hash2, key);
  h2.update(data);
  var digest = h2.digest();
  return h2.clean(), digest;
}
__name(hmac, "hmac");
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: !0 });
var hmac_1 = hmac$1, wipe_1$1 = wipe$1, HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key, salt, info2) {
      salt === void 0 && (salt = new Uint8Array(0)), this._counter = new Uint8Array(1), this._hash = hash2, this._info = info2;
      var okm = hmac_1.hmac(this._hash, salt, key);
      this._hmac = new hmac_1.HMAC(hash2, okm), this._buffer = new Uint8Array(this._hmac.digestLength), this._bufpos = this._buffer.length;
    }
    return __name(HKDF2, "HKDF"), HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0)
        throw new Error("hkdf: cannot expand more");
      this._hmac.reset(), ctr > 1 && this._hmac.update(this._buffer), this._info && this._hmac.update(this._info), this._hmac.update(this._counter), this._hmac.finish(this._buffer), this._bufpos = 0;
    }, HKDF2.prototype.expand = function(length2) {
      for (var out = new Uint8Array(length2), i = 0; i < out.length; i++)
        this._bufpos === this._buffer.length && this._fillBuffer(), out[i] = this._buffer[this._bufpos++];
      return out;
    }, HKDF2.prototype.clean = function() {
      this._hmac.clean(), wipe_1$1.wipe(this._buffer), wipe_1$1.wipe(this._counter), this._bufpos = 0;
    }, HKDF2;
  }()
), HKDF_1 = hkdf.HKDF = HKDF, random = {}, system = {}, browser = {};
Object.defineProperty(browser, "__esModule", { value: !0 });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536, _BrowserRandomSource = class _BrowserRandomSource {
  constructor() {
    this.isAvailable = !1, this.isInstantiated = !1;
    const browserCrypto = typeof self < "u" ? self.crypto || self.msCrypto : null;
    browserCrypto && browserCrypto.getRandomValues !== void 0 && (this._crypto = browserCrypto, this.isAvailable = !0, this.isInstantiated = !0);
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Browser random byte generator is not available.");
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i += QUOTA)
      this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
    return out;
  }
};
__name(_BrowserRandomSource, "BrowserRandomSource");
let BrowserRandomSource = _BrowserRandomSource;
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
__name(commonjsRequire, "commonjsRequire");
var node = {};
const __viteBrowserExternal = {}, __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" })), require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", { value: !0 });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1, _NodeRandomSource = class _NodeRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.isInstantiated = !1, typeof commonjsRequire < "u") {
      const nodeCrypto = require$$0$1;
      nodeCrypto && nodeCrypto.randomBytes && (this._crypto = nodeCrypto, this.isAvailable = !0, this.isInstantiated = !0);
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto)
      throw new Error("Node.js random byte generator is not available.");
    let buffer = this._crypto.randomBytes(length2);
    if (buffer.length !== length2)
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i++)
      out[i] = buffer[i];
    return (0, wipe_1.wipe)(buffer), out;
  }
};
__name(_NodeRandomSource, "NodeRandomSource");
let NodeRandomSource = _NodeRandomSource;
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: !0 });
system.SystemRandomSource = void 0;
const browser_1 = browser, node_1 = node, _SystemRandomSource = class _SystemRandomSource {
  constructor() {
    if (this.isAvailable = !1, this.name = "", this._source = new browser_1.BrowserRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Browser";
      return;
    }
    if (this._source = new node_1.NodeRandomSource(), this._source.isAvailable) {
      this.isAvailable = !0, this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable)
      throw new Error("System random byte generator is not available.");
    return this._source.randomBytes(length2);
  }
};
__name(_SystemRandomSource, "SystemRandomSource");
let SystemRandomSource = _SystemRandomSource;
system.SystemRandomSource = SystemRandomSource;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system, binary_12 = binary, wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  __name(randomBytes, "randomBytes"), exports.randomBytes = randomBytes;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf = randomBytes(4, prng), result = (0, binary_12.readUint32LE)(buf);
    return (0, wipe_12.wipe)(buf), result;
  }
  __name(randomUint32, "randomUint32"), exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2)
      throw new Error("randomString charset is too short");
    if (charset.length > 256)
      throw new Error("randomString charset is too long");
    let out = "";
    const charsLen = charset.length, maxByte = 256 - 256 % charsLen;
    for (; length2 > 0; ) {
      const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i = 0; i < buf.length && length2 > 0; i++) {
        const randomByte = buf[i];
        randomByte < maxByte && (out += charset.charAt(randomByte % charsLen), length2--);
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  __name(randomString, "randomString"), exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  __name(randomStringForEntropy, "randomStringForEntropy"), exports.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  var binary_12 = binary, wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32, exports.BLOCK_SIZE = 64;
  var SHA256 = (
    /** @class */
    function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH, this.blockSize = exports.BLOCK_SIZE, this._state = new Int32Array(8), this._temp = new Int32Array(64), this._buffer = new Uint8Array(128), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this.reset();
      }
      return __name(SHA2562, "SHA256"), SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703, this._state[1] = 3144134277, this._state[2] = 1013904242, this._state[3] = 2773480762, this._state[4] = 1359893119, this._state[5] = 2600822924, this._state[6] = 528734635, this._state[7] = 1541459225;
      }, SHA2562.prototype.reset = function() {
        return this._initState(), this._bufferLength = 0, this._bytesHashed = 0, this._finished = !1, this;
      }, SHA2562.prototype.clean = function() {
        wipe_12.wipe(this._buffer), wipe_12.wipe(this._temp), this.reset();
      }, SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0 && (dataLength = data.length), this._finished)
          throw new Error("SHA256: can't update because hash was finished.");
        var dataPos = 0;
        if (this._bytesHashed += dataLength, this._bufferLength > 0) {
          for (; this._bufferLength < this.blockSize && dataLength > 0; )
            this._buffer[this._bufferLength++] = data[dataPos++], dataLength--;
          this._bufferLength === this.blockSize && (hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize), this._bufferLength = 0);
        }
        for (dataLength >= this.blockSize && (dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength), dataLength %= this.blockSize); dataLength > 0; )
          this._buffer[this._bufferLength++] = data[dataPos++], dataLength--;
        return this;
      }, SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed, left2 = this._bufferLength, bitLenHi = bytesHashed / 536870912 | 0, bitLenLo = bytesHashed << 3, padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left2] = 128;
          for (var i = left2 + 1; i < padLength - 8; i++)
            this._buffer[i] = 0;
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8), binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4), hashBlocks(this._temp, this._state, this._buffer, 0, padLength), this._finished = !0;
        }
        for (var i = 0; i < this.digestLength / 4; i++)
          binary_12.writeUint32BE(this._state[i], out, i * 4);
        return this;
      }, SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        return this.finish(out), out;
      }, SHA2562.prototype.saveState = function() {
        if (this._finished)
          throw new Error("SHA256: cannot save finished state");
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      }, SHA2562.prototype.restoreState = function(savedState) {
        return this._state.set(savedState.state), this._bufferLength = savedState.bufferLength, savedState.buffer && this._buffer.set(savedState.buffer), this._bytesHashed = savedState.bytesHashed, this._finished = !1, this;
      }, SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state), savedState.buffer && wipe_12.wipe(savedState.buffer), savedState.bufferLength = 0, savedState.bytesHashed = 0;
      }, SHA2562;
    }()
  );
  exports.SHA256 = SHA256;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len) {
    for (; len >= 64; ) {
      for (var a2 = v2[0], b2 = v2[1], c2 = v2[2], d2 = v2[3], e2 = v2[4], f2 = v2[5], g2 = v2[6], h2 = v2[7], i = 0; i < 16; i++) {
        var j2 = pos + i * 4;
        w2[i] = binary_12.readUint32BE(p2, j2);
      }
      for (var i = 16; i < 64; i++) {
        var u2 = w2[i - 2], t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i] = (t1 + w2[i - 7] | 0) + (t2 + w2[i - 16] | 0);
      }
      for (var i = 0; i < 64; i++) {
        var t1 = (((e2 >>> 6 | e2 << 26) ^ (e2 >>> 11 | e2 << 21) ^ (e2 >>> 25 | e2 << 7)) + (e2 & f2 ^ ~e2 & g2) | 0) + (h2 + (K2[i] + w2[i] | 0) | 0) | 0, t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
        h2 = g2, g2 = f2, f2 = e2, e2 = d2 + t1 | 0, d2 = c2, c2 = b2, b2 = a2, a2 = t1 + t2 | 0;
      }
      v2[0] += a2, v2[1] += b2, v2[2] += c2, v2[3] += d2, v2[4] += e2, v2[5] += f2, v2[6] += g2, v2[7] += h2, pos += 64, len -= 64;
    }
    return pos;
  }
  __name(hashBlocks, "hashBlocks");
  function hash2(data) {
    var h2 = new SHA256();
    h2.update(data);
    var digest = h2.digest();
    return h2.clean(), digest;
  }
  __name(hash2, "hash"), exports.hash = hash2;
})(sha256);
var x25519 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 }), exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random, wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32, exports.SECRET_KEY_LENGTH = 32, exports.SHARED_KEY_LENGTH = 32;
  function gf(init2) {
    const r2 = new Float64Array(16);
    if (init2)
      for (let i = 0; i < init2.length; i++)
        r2[i] = init2[i];
    return r2;
  }
  __name(gf, "gf");
  const _92 = new Uint8Array(32);
  _92[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i = 0; i < 16; i++) {
      let v2 = o2[i] + c2 + 65535;
      c2 = Math.floor(v2 / 65536), o2[i] = v2 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  __name(car25519, "car25519");
  function sel25519(p2, q2, b2) {
    const c2 = ~(b2 - 1);
    for (let i = 0; i < 16; i++) {
      const t2 = c2 & (p2[i] ^ q2[i]);
      p2[i] ^= t2, q2[i] ^= t2;
    }
  }
  __name(sel25519, "sel25519");
  function pack25519(o2, n2) {
    const m2 = gf(), t2 = gf();
    for (let i = 0; i < 16; i++)
      t2[i] = n2[i];
    car25519(t2), car25519(t2), car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i = 1; i < 15; i++)
        m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1), m2[i - 1] &= 65535;
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535, sel25519(t2, m2, 1 - b2);
    }
    for (let i = 0; i < 16; i++)
      o2[2 * i] = t2[i] & 255, o2[2 * i + 1] = t2[i] >> 8;
  }
  __name(pack25519, "pack25519");
  function unpack25519(o2, n2) {
    for (let i = 0; i < 16; i++)
      o2[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
    o2[15] &= 32767;
  }
  __name(unpack25519, "unpack25519");
  function add(o2, a2, b2) {
    for (let i = 0; i < 16; i++)
      o2[i] = a2[i] + b2[i];
  }
  __name(add, "add");
  function sub(o2, a2, b2) {
    for (let i = 0; i < 16; i++)
      o2[i] = a2[i] - b2[i];
  }
  __name(sub, "sub");
  function mul(o2, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0], t0 += v2 * b0, t1 += v2 * b1, t2 += v2 * b22, t3 += v2 * b3, t4 += v2 * b4, t5 += v2 * b5, t6 += v2 * b6, t7 += v2 * b7, t8 += v2 * b8, t9 += v2 * b9, t10 += v2 * b10, t11 += v2 * b11, t12 += v2 * b12, t13 += v2 * b13, t14 += v2 * b14, t15 += v2 * b15, v2 = a2[1], t1 += v2 * b0, t2 += v2 * b1, t3 += v2 * b22, t4 += v2 * b3, t5 += v2 * b4, t6 += v2 * b5, t7 += v2 * b6, t8 += v2 * b7, t9 += v2 * b8, t10 += v2 * b9, t11 += v2 * b10, t12 += v2 * b11, t13 += v2 * b12, t14 += v2 * b13, t15 += v2 * b14, t16 += v2 * b15, v2 = a2[2], t2 += v2 * b0, t3 += v2 * b1, t4 += v2 * b22, t5 += v2 * b3, t6 += v2 * b4, t7 += v2 * b5, t8 += v2 * b6, t9 += v2 * b7, t10 += v2 * b8, t11 += v2 * b9, t12 += v2 * b10, t13 += v2 * b11, t14 += v2 * b12, t15 += v2 * b13, t16 += v2 * b14, t17 += v2 * b15, v2 = a2[3], t3 += v2 * b0, t4 += v2 * b1, t5 += v2 * b22, t6 += v2 * b3, t7 += v2 * b4, t8 += v2 * b5, t9 += v2 * b6, t10 += v2 * b7, t11 += v2 * b8, t12 += v2 * b9, t13 += v2 * b10, t14 += v2 * b11, t15 += v2 * b12, t16 += v2 * b13, t17 += v2 * b14, t18 += v2 * b15, v2 = a2[4], t4 += v2 * b0, t5 += v2 * b1, t6 += v2 * b22, t7 += v2 * b3, t8 += v2 * b4, t9 += v2 * b5, t10 += v2 * b6, t11 += v2 * b7, t12 += v2 * b8, t13 += v2 * b9, t14 += v2 * b10, t15 += v2 * b11, t16 += v2 * b12, t17 += v2 * b13, t18 += v2 * b14, t19 += v2 * b15, v2 = a2[5], t5 += v2 * b0, t6 += v2 * b1, t7 += v2 * b22, t8 += v2 * b3, t9 += v2 * b4, t10 += v2 * b5, t11 += v2 * b6, t12 += v2 * b7, t13 += v2 * b8, t14 += v2 * b9, t15 += v2 * b10, t16 += v2 * b11, t17 += v2 * b12, t18 += v2 * b13, t19 += v2 * b14, t20 += v2 * b15, v2 = a2[6], t6 += v2 * b0, t7 += v2 * b1, t8 += v2 * b22, t9 += v2 * b3, t10 += v2 * b4, t11 += v2 * b5, t12 += v2 * b6, t13 += v2 * b7, t14 += v2 * b8, t15 += v2 * b9, t16 += v2 * b10, t17 += v2 * b11, t18 += v2 * b12, t19 += v2 * b13, t20 += v2 * b14, t21 += v2 * b15, v2 = a2[7], t7 += v2 * b0, t8 += v2 * b1, t9 += v2 * b22, t10 += v2 * b3, t11 += v2 * b4, t12 += v2 * b5, t13 += v2 * b6, t14 += v2 * b7, t15 += v2 * b8, t16 += v2 * b9, t17 += v2 * b10, t18 += v2 * b11, t19 += v2 * b12, t20 += v2 * b13, t21 += v2 * b14, t22 += v2 * b15, v2 = a2[8], t8 += v2 * b0, t9 += v2 * b1, t10 += v2 * b22, t11 += v2 * b3, t12 += v2 * b4, t13 += v2 * b5, t14 += v2 * b6, t15 += v2 * b7, t16 += v2 * b8, t17 += v2 * b9, t18 += v2 * b10, t19 += v2 * b11, t20 += v2 * b12, t21 += v2 * b13, t22 += v2 * b14, t23 += v2 * b15, v2 = a2[9], t9 += v2 * b0, t10 += v2 * b1, t11 += v2 * b22, t12 += v2 * b3, t13 += v2 * b4, t14 += v2 * b5, t15 += v2 * b6, t16 += v2 * b7, t17 += v2 * b8, t18 += v2 * b9, t19 += v2 * b10, t20 += v2 * b11, t21 += v2 * b12, t22 += v2 * b13, t23 += v2 * b14, t24 += v2 * b15, v2 = a2[10], t10 += v2 * b0, t11 += v2 * b1, t12 += v2 * b22, t13 += v2 * b3, t14 += v2 * b4, t15 += v2 * b5, t16 += v2 * b6, t17 += v2 * b7, t18 += v2 * b8, t19 += v2 * b9, t20 += v2 * b10, t21 += v2 * b11, t22 += v2 * b12, t23 += v2 * b13, t24 += v2 * b14, t25 += v2 * b15, v2 = a2[11], t11 += v2 * b0, t12 += v2 * b1, t13 += v2 * b22, t14 += v2 * b3, t15 += v2 * b4, t16 += v2 * b5, t17 += v2 * b6, t18 += v2 * b7, t19 += v2 * b8, t20 += v2 * b9, t21 += v2 * b10, t22 += v2 * b11, t23 += v2 * b12, t24 += v2 * b13, t25 += v2 * b14, t26 += v2 * b15, v2 = a2[12], t12 += v2 * b0, t13 += v2 * b1, t14 += v2 * b22, t15 += v2 * b3, t16 += v2 * b4, t17 += v2 * b5, t18 += v2 * b6, t19 += v2 * b7, t20 += v2 * b8, t21 += v2 * b9, t22 += v2 * b10, t23 += v2 * b11, t24 += v2 * b12, t25 += v2 * b13, t26 += v2 * b14, t27 += v2 * b15, v2 = a2[13], t13 += v2 * b0, t14 += v2 * b1, t15 += v2 * b22, t16 += v2 * b3, t17 += v2 * b4, t18 += v2 * b5, t19 += v2 * b6, t20 += v2 * b7, t21 += v2 * b8, t22 += v2 * b9, t23 += v2 * b10, t24 += v2 * b11, t25 += v2 * b12, t26 += v2 * b13, t27 += v2 * b14, t28 += v2 * b15, v2 = a2[14], t14 += v2 * b0, t15 += v2 * b1, t16 += v2 * b22, t17 += v2 * b3, t18 += v2 * b4, t19 += v2 * b5, t20 += v2 * b6, t21 += v2 * b7, t22 += v2 * b8, t23 += v2 * b9, t24 += v2 * b10, t25 += v2 * b11, t26 += v2 * b12, t27 += v2 * b13, t28 += v2 * b14, t29 += v2 * b15, v2 = a2[15], t15 += v2 * b0, t16 += v2 * b1, t17 += v2 * b22, t18 += v2 * b3, t19 += v2 * b4, t20 += v2 * b5, t21 += v2 * b6, t22 += v2 * b7, t23 += v2 * b8, t24 += v2 * b9, t25 += v2 * b10, t26 += v2 * b11, t27 += v2 * b12, t28 += v2 * b13, t29 += v2 * b14, t30 += v2 * b15, t0 += 38 * t16, t1 += 38 * t17, t2 += 38 * t18, t3 += 38 * t19, t4 += 38 * t20, t5 += 38 * t21, t6 += 38 * t22, t7 += 38 * t23, t8 += 38 * t24, t9 += 38 * t25, t10 += 38 * t26, t11 += 38 * t27, t12 += 38 * t28, t13 += 38 * t29, t14 += 38 * t30, c2 = 1, v2 = t0 + c2 + 65535, c2 = Math.floor(v2 / 65536), t0 = v2 - c2 * 65536, v2 = t1 + c2 + 65535, c2 = Math.floor(v2 / 65536), t1 = v2 - c2 * 65536, v2 = t2 + c2 + 65535, c2 = Math.floor(v2 / 65536), t2 = v2 - c2 * 65536, v2 = t3 + c2 + 65535, c2 = Math.floor(v2 / 65536), t3 = v2 - c2 * 65536, v2 = t4 + c2 + 65535, c2 = Math.floor(v2 / 65536), t4 = v2 - c2 * 65536, v2 = t5 + c2 + 65535, c2 = Math.floor(v2 / 65536), t5 = v2 - c2 * 65536, v2 = t6 + c2 + 65535, c2 = Math.floor(v2 / 65536), t6 = v2 - c2 * 65536, v2 = t7 + c2 + 65535, c2 = Math.floor(v2 / 65536), t7 = v2 - c2 * 65536, v2 = t8 + c2 + 65535, c2 = Math.floor(v2 / 65536), t8 = v2 - c2 * 65536, v2 = t9 + c2 + 65535, c2 = Math.floor(v2 / 65536), t9 = v2 - c2 * 65536, v2 = t10 + c2 + 65535, c2 = Math.floor(v2 / 65536), t10 = v2 - c2 * 65536, v2 = t11 + c2 + 65535, c2 = Math.floor(v2 / 65536), t11 = v2 - c2 * 65536, v2 = t12 + c2 + 65535, c2 = Math.floor(v2 / 65536), t12 = v2 - c2 * 65536, v2 = t13 + c2 + 65535, c2 = Math.floor(v2 / 65536), t13 = v2 - c2 * 65536, v2 = t14 + c2 + 65535, c2 = Math.floor(v2 / 65536), t14 = v2 - c2 * 65536, v2 = t15 + c2 + 65535, c2 = Math.floor(v2 / 65536), t15 = v2 - c2 * 65536, t0 += c2 - 1 + 37 * (c2 - 1), c2 = 1, v2 = t0 + c2 + 65535, c2 = Math.floor(v2 / 65536), t0 = v2 - c2 * 65536, v2 = t1 + c2 + 65535, c2 = Math.floor(v2 / 65536), t1 = v2 - c2 * 65536, v2 = t2 + c2 + 65535, c2 = Math.floor(v2 / 65536), t2 = v2 - c2 * 65536, v2 = t3 + c2 + 65535, c2 = Math.floor(v2 / 65536), t3 = v2 - c2 * 65536, v2 = t4 + c2 + 65535, c2 = Math.floor(v2 / 65536), t4 = v2 - c2 * 65536, v2 = t5 + c2 + 65535, c2 = Math.floor(v2 / 65536), t5 = v2 - c2 * 65536, v2 = t6 + c2 + 65535, c2 = Math.floor(v2 / 65536), t6 = v2 - c2 * 65536, v2 = t7 + c2 + 65535, c2 = Math.floor(v2 / 65536), t7 = v2 - c2 * 65536, v2 = t8 + c2 + 65535, c2 = Math.floor(v2 / 65536), t8 = v2 - c2 * 65536, v2 = t9 + c2 + 65535, c2 = Math.floor(v2 / 65536), t9 = v2 - c2 * 65536, v2 = t10 + c2 + 65535, c2 = Math.floor(v2 / 65536), t10 = v2 - c2 * 65536, v2 = t11 + c2 + 65535, c2 = Math.floor(v2 / 65536), t11 = v2 - c2 * 65536, v2 = t12 + c2 + 65535, c2 = Math.floor(v2 / 65536), t12 = v2 - c2 * 65536, v2 = t13 + c2 + 65535, c2 = Math.floor(v2 / 65536), t13 = v2 - c2 * 65536, v2 = t14 + c2 + 65535, c2 = Math.floor(v2 / 65536), t14 = v2 - c2 * 65536, v2 = t15 + c2 + 65535, c2 = Math.floor(v2 / 65536), t15 = v2 - c2 * 65536, t0 += c2 - 1 + 37 * (c2 - 1), o2[0] = t0, o2[1] = t1, o2[2] = t2, o2[3] = t3, o2[4] = t4, o2[5] = t5, o2[6] = t6, o2[7] = t7, o2[8] = t8, o2[9] = t9, o2[10] = t10, o2[11] = t11, o2[12] = t12, o2[13] = t13, o2[14] = t14, o2[15] = t15;
  }
  __name(mul, "mul");
  function square(o2, a2) {
    mul(o2, a2, a2);
  }
  __name(square, "square");
  function inv25519(o2, inp) {
    const c2 = gf();
    for (let i = 0; i < 16; i++)
      c2[i] = inp[i];
    for (let i = 253; i >= 0; i--)
      square(c2, c2), i !== 2 && i !== 4 && mul(c2, c2, inp);
    for (let i = 0; i < 16; i++)
      o2[i] = c2[i];
  }
  __name(inv25519, "inv25519");
  function scalarMult(n2, p2) {
    const z2 = new Uint8Array(32), x2 = new Float64Array(80), a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e2 = gf(), f2 = gf();
    for (let i = 0; i < 31; i++)
      z2[i] = n2[i];
    z2[31] = n2[31] & 127 | 64, z2[0] &= 248, unpack25519(x2, p2);
    for (let i = 0; i < 16; i++)
      b2[i] = x2[i];
    a2[0] = d2[0] = 1;
    for (let i = 254; i >= 0; --i) {
      const r2 = z2[i >>> 3] >>> (i & 7) & 1;
      sel25519(a2, b2, r2), sel25519(c2, d2, r2), add(e2, a2, c2), sub(a2, a2, c2), add(c2, b2, d2), sub(b2, b2, d2), square(d2, e2), square(f2, a2), mul(a2, c2, a2), mul(c2, b2, e2), add(e2, a2, c2), sub(a2, a2, c2), square(b2, a2), sub(c2, d2, f2), mul(a2, c2, _121665), add(a2, a2, d2), mul(c2, c2, a2), mul(a2, d2, f2), mul(d2, b2, x2), square(b2, e2), sel25519(a2, b2, r2), sel25519(c2, d2, r2);
    }
    for (let i = 0; i < 16; i++)
      x2[i + 16] = a2[i], x2[i + 32] = c2[i], x2[i + 48] = b2[i], x2[i + 64] = d2[i];
    const x32 = x2.subarray(32), x16 = x2.subarray(16);
    inv25519(x32, x32), mul(x16, x16, x32);
    const q2 = new Uint8Array(32);
    return pack25519(q2, x16), q2;
  }
  __name(scalarMult, "scalarMult"), exports.scalarMult = scalarMult;
  function scalarMultBase(n2) {
    return scalarMult(n2, _92);
  }
  __name(scalarMultBase, "scalarMultBase"), exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed2) {
    if (seed2.length !== exports.SECRET_KEY_LENGTH)
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    const secretKey = new Uint8Array(seed2);
    return {
      publicKey: scalarMultBase(secretKey),
      secretKey
    };
  }
  __name(generateKeyPairFromSeed, "generateKeyPairFromSeed"), exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed2 = (0, random_1.randomBytes)(32, prng), result = generateKeyPairFromSeed(seed2);
    return (0, wipe_12.wipe)(seed2), result;
  }
  __name(generateKeyPair, "generateKeyPair"), exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = !1) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect secret key length");
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH)
      throw new Error("X25519: incorrect public key length");
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i = 0; i < result.length; i++)
        zeros |= result[i];
      if (zeros === 0)
        throw new Error("X25519: invalid shared key");
    }
    return result;
  }
  __name(sharedKey, "sharedKey"), exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf) {
  return globalThis.Buffer != null ? new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength) : buf;
}
__name(asUint8Array, "asUint8Array");
function allocUnsafe(size2 = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? asUint8Array(globalThis.Buffer.allocUnsafe(size2)) : new Uint8Array(size2);
}
__name(allocUnsafe, "allocUnsafe");
function concat(arrays, length2) {
  length2 || (length2 = arrays.reduce((acc, curr) => acc + curr.length, 0));
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays)
    output2.set(arr, offset), offset += arr.length;
  return asUint8Array(output2);
}
__name(concat, "concat");
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var BASE_MAP = new Uint8Array(256), j2 = 0; j2 < BASE_MAP.length; j2++)
    BASE_MAP[j2] = 255;
  for (var i = 0; i < ALPHABET.length; i++) {
    var x2 = ALPHABET.charAt(i), xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255)
      throw new TypeError(x2 + " is ambiguous");
    BASE_MAP[xc2] = i;
  }
  var BASE = ALPHABET.length, LEADER = ALPHABET.charAt(0), FACTOR = Math.log(BASE) / Math.log(256), iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array || (ArrayBuffer.isView(source) ? source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength) : Array.isArray(source) && (source = Uint8Array.from(source))), !(source instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (source.length === 0)
      return "";
    for (var zeroes = 0, length2 = 0, pbegin = 0, pend = source.length; pbegin !== pend && source[pbegin] === 0; )
      pbegin++, zeroes++;
    for (var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0, b58 = new Uint8Array(size2); pbegin !== pend; ) {
      for (var carry = source[pbegin], i2 = 0, it1 = size2 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++)
        carry += 256 * b58[it1] >>> 0, b58[it1] = carry % BASE >>> 0, carry = carry / BASE >>> 0;
      if (carry !== 0)
        throw new Error("Non-zero carry");
      length2 = i2, pbegin++;
    }
    for (var it2 = size2 - length2; it2 !== size2 && b58[it2] === 0; )
      it2++;
    for (var str = LEADER.repeat(zeroes); it2 < size2; ++it2)
      str += ALPHABET.charAt(b58[it2]);
    return str;
  }
  __name(encode2, "encode");
  function decodeUnsafe(source) {
    if (typeof source != "string")
      throw new TypeError("Expected String");
    if (source.length === 0)
      return new Uint8Array();
    var psz = 0;
    if (source[psz] !== " ") {
      for (var zeroes = 0, length2 = 0; source[psz] === LEADER; )
        zeroes++, psz++;
      for (var size2 = (source.length - psz) * FACTOR + 1 >>> 0, b256 = new Uint8Array(size2); source[psz]; ) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255)
          return;
        for (var i2 = 0, it3 = size2 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++)
          carry += BASE * b256[it3] >>> 0, b256[it3] = carry % 256 >>> 0, carry = carry / 256 >>> 0;
        if (carry !== 0)
          throw new Error("Non-zero carry");
        length2 = i2, psz++;
      }
      if (source[psz] !== " ") {
        for (var it4 = size2 - length2; it4 !== size2 && b256[it4] === 0; )
          it4++;
        for (var vch = new Uint8Array(zeroes + (size2 - it4)), j3 = zeroes; it4 !== size2; )
          vch[j3++] = b256[it4++];
        return vch;
      }
    }
  }
  __name(decodeUnsafe, "decodeUnsafe");
  function decode2(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer)
      return buffer;
    throw new Error(`Non-${name} character`);
  }
  return __name(decode2, "decode"), {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
__name(base, "base");
var src = base, _brrp__multiformats_scope_baseX = src;
const coerce = /* @__PURE__ */ __name((o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2))
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  throw new Error("Unknown type, must be binary type");
}, "coerce"), fromString$1 = /* @__PURE__ */ __name((str) => new TextEncoder().encode(str), "fromString$1"), toString$1 = /* @__PURE__ */ __name((b2) => new TextDecoder().decode(b2), "toString$1"), _Encoder = class _Encoder {
  constructor(name, prefix2, baseEncode) {
    this.name = name, this.prefix = prefix2, this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(bytes)}`;
    throw Error("Unknown type, must be binary type");
  }
};
__name(_Encoder, "Encoder");
let Encoder = _Encoder;
const _Decoder = class _Decoder {
  constructor(name, prefix2, baseDecode) {
    if (this.name = name, this.prefix = prefix2, prefix2.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = prefix2.codePointAt(0), this.baseDecode = baseDecode;
  }
  decode(text2) {
    if (typeof text2 == "string") {
      if (text2.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(text2.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(decoder) {
    return or(this, decoder);
  }
};
__name(_Decoder, "Decoder");
let Decoder = _Decoder;
const _ComposedDecoder = class _ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input2) {
    const prefix2 = input2[0], decoder = this.decoders[prefix2];
    if (decoder)
      return decoder.decode(input2);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(input2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
__name(_ComposedDecoder, "ComposedDecoder");
let ComposedDecoder = _ComposedDecoder;
const or = /* @__PURE__ */ __name((left2, right) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right.decoders || { [right.prefix]: right }
}), "or"), _Codec = class _Codec {
  constructor(name, prefix2, baseEncode, baseDecode) {
    this.name = name, this.prefix = prefix2, this.baseEncode = baseEncode, this.baseDecode = baseDecode, this.encoder = new Encoder(name, prefix2, baseEncode), this.decoder = new Decoder(name, prefix2, baseDecode);
  }
  encode(input2) {
    return this.encoder.encode(input2);
  }
  decode(input2) {
    return this.decoder.decode(input2);
  }
};
__name(_Codec, "Codec");
let Codec = _Codec;
const from = /* @__PURE__ */ __name(({ name, prefix: prefix2, encode: encode2, decode: decode2 }) => new Codec(name, prefix2, encode2, decode2), "from"), baseX = /* @__PURE__ */ __name(({ prefix: prefix2, name, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix: prefix2,
    name,
    encode: encode2,
    decode: (text2) => coerce(decode2(text2))
  });
}, "baseX"), decode$2 = /* @__PURE__ */ __name((string2, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i)
    codes[alphabet2[i]] = i;
  let end2 = string2.length;
  for (; string2[end2 - 1] === "="; )
    --end2;
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0, buffer = 0, written = 0;
  for (let i = 0; i < end2; ++i) {
    const value = codes[string2[i]];
    if (value === void 0)
      throw new SyntaxError(`Non-${name} character`);
    buffer = buffer << bitsPerChar | value, bits += bitsPerChar, bits >= 8 && (bits -= 8, out[written++] = 255 & buffer >> bits);
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits)
    throw new SyntaxError("Unexpected end of data");
  return out;
}, "decode$2"), encode$1 = /* @__PURE__ */ __name((data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=", mask = (1 << bitsPerChar) - 1;
  let out = "", bits = 0, buffer = 0;
  for (let i = 0; i < data.length; ++i)
    for (buffer = buffer << 8 | data[i], bits += 8; bits > bitsPerChar; )
      bits -= bitsPerChar, out += alphabet2[mask & buffer >> bits];
  if (bits && (out += alphabet2[mask & buffer << bitsPerChar - bits]), pad)
    for (; out.length * bitsPerChar & 7; )
      out += "=";
  return out;
}, "encode$1"), rfc4648 = /* @__PURE__ */ __name(({ name, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => from({
  prefix: prefix2,
  name,
  encode(input2) {
    return encode$1(input2, alphabet2, bitsPerChar);
  },
  decode(input2) {
    return decode$2(input2, alphabet2, bitsPerChar, name);
  }
}), "rfc4648"), identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
}), identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" })), base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
}), base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" })), base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
}), base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" })), base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
}), base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" })), base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
}), base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
}), base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" })), base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
}), base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
}), base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
}), base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
}), base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
}), base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
}), base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
}), base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
}), base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
}), base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" })), base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
}), base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
}), base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" })), base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
}), base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
}), base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" })), base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
}), base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
}), base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
}), base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
}), base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" })), alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂"), alphabetBytesToChars = alphabet.reduce((p2, c2, i) => (p2[i] = c2, p2), []), alphabetCharsToBytes = alphabet.reduce((p2, c2, i) => (p2[c2.codePointAt(0)] = i, p2), []);
function encode(data) {
  return data.reduce((p2, c2) => (p2 += alphabetBytesToChars[c2], p2), "");
}
__name(encode, "encode");
function decode$1(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0)
      throw new Error(`Non-base256emoji character: ${char2}`);
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
__name(decode$1, "decode$1");
const base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode,
  decode: decode$1
}), base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name, prefix2, encode2, decode2) {
  return {
    name,
    prefix: prefix2,
    encoder: {
      name,
      prefix: prefix2,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
__name(createCodec, "createCodec");
const string = createCodec("utf8", "u", (buf) => "u" + new TextDecoder("utf8").decode(buf), (str) => new TextEncoder().encode(str.substring(1))), ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++)
    string2 += String.fromCharCode(buf[i]);
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++)
    buf[i] = str.charCodeAt(i);
  return buf;
}), BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3)
    throw new Error(`Unsupported encoding "${encoding}"`);
  return (encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? asUint8Array(globalThis.Buffer.from(string2, "utf-8")) : base3.decoder.decode(`${base3.prefix}${string2}`);
}
__name(fromString, "fromString");
function toString(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3)
    throw new Error(`Unsupported encoding "${encoding}"`);
  return (encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8") : base3.encoder.encode(array).substring(1);
}
__name(toString, "toString");
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++)
      (ar || !(i in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i)), ar[i] = from2[i]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}, BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version, os2) {
      this.name = name, this.version = version, this.os = os2, this.type = "browser";
    }
    return __name(BrowserInfo2, "BrowserInfo"), BrowserInfo2;
  }()
), NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version, this.type = "node", this.name = "node", this.os = process.platform;
    }
    return __name(NodeInfo2, "NodeInfo"), NodeInfo2;
  }()
), SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version, os2, bot) {
      this.name = name, this.version = version, this.os = os2, this.bot = bot, this.type = "bot-device";
    }
    return __name(SearchBotDeviceInfo2, "SearchBotDeviceInfo"), SearchBotDeviceInfo2;
  }()
), BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot", this.bot = !0, this.name = "bot", this.version = null, this.os = null;
    }
    return __name(BotInfo2, "BotInfo"), BotInfo2;
  }()
), ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native", this.name = "react-native", this.version = null, this.os = null;
    }
    return __name(ReactNativeInfo2, "ReactNativeInfo"), ReactNativeInfo2;
  }()
), SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/, SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/, REQUIRED_VERSION_PARTS = 3, userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
], operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  return userAgent ? parseUserAgent(userAgent) : typeof document > "u" && typeof navigator < "u" && navigator.product === "ReactNative" ? new ReactNativeInfo() : typeof navigator < "u" ? parseUserAgent(navigator.userAgent) : getNodeVersion();
}
__name(detect, "detect");
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a46) {
    var browser2 = _a46[0], regex = _a46[1];
    if (matched)
      return matched;
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, !1);
}
__name(matchUserAgent, "matchUserAgent");
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule)
    return null;
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot")
    return new BotInfo();
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  versionParts ? versionParts.length < REQUIRED_VERSION_PARTS && (versionParts = __spreadArray(__spreadArray([], versionParts, !0), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), !0)) : versionParts = [];
  var version = versionParts.join("."), os2 = detectOS(ua2), searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  return searchBotMatch && searchBotMatch[1] ? new SearchBotDeviceInfo(name, version, os2, searchBotMatch[1]) : new BrowserInfo(name, version, os2);
}
__name(parseUserAgent, "parseUserAgent");
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a46 = operatingSystemRules[ii2], os2 = _a46[0], regex = _a46[1], match2 = regex.exec(ua2);
    if (match2)
      return os2;
  }
  return null;
}
__name(detectOS, "detectOS");
function getNodeVersion() {
  var isNode2 = typeof process < "u" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
__name(getNodeVersion, "getNodeVersion");
function createVersionParts(count) {
  for (var output2 = [], ii2 = 0; ii2 < count; ii2++)
    output2.push("0");
  return output2;
}
__name(createVersionParts, "createVersionParts");
var cjs$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = /* @__PURE__ */ __name(function(d2, b2) {
  return extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      b3.hasOwnProperty(p2) && (d3[p2] = b3[p2]);
  }, extendStatics(d2, b2);
}, "extendStatics");
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  __name(__, "__"), d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
__name(__extends, "__extends");
var __assign = /* @__PURE__ */ __name(function() {
  return __assign = Object.assign || /* @__PURE__ */ __name(function(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        Object.prototype.hasOwnProperty.call(s, p2) && (t2[p2] = s[p2]);
    }
    return t2;
  }, "__assign"), __assign.apply(this, arguments);
}, "__assign");
function __rest(s, e2) {
  var t2 = {};
  for (var p2 in s)
    Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0 && (t2[p2] = s[p2]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++)
      e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]) && (t2[p2[i]] = s[p2[i]]);
  return t2;
}
__name(__rest, "__rest");
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      (d2 = decorators[i]) && (r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2);
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
__name(__decorate, "__decorate");
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(__param, "__param");
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect == "object" && typeof Reflect.metadata == "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
__name(__metadata, "__metadata");
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return __name(adopt, "adopt"), new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value) {
      try {
        step2(generator.throw(value));
      } catch (e2) {
        reject2(e2);
      }
    }
    __name(rejected, "rejected");
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step2, "step"), step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
__name(__awaiter, "__awaiter");
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), throw: verb(1), return: verb(2) }, typeof Symbol == "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    for (; _24; )
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2.return : op[0] ? y2.throw || ((t2 = y2.return) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        switch (y2 = 0, t2 && (op = [op[0] & 2, t2.value]), op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            return _24.label++, { value: op[1], done: !1 };
          case 5:
            _24.label++, y2 = op[1], op = [0];
            continue;
          case 7:
            op = _24.ops.pop(), _24.trys.pop();
            continue;
          default:
            if (t2 = _24.trys, !(t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1], t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2], _24.ops.push(op);
              break;
            }
            t2[2] && _24.ops.pop(), _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e2) {
        op = [6, e2], y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: !0 };
  }
}
__name(__generator, "__generator");
function __createBinding(o2, m2, k2, k22) {
  k22 === void 0 && (k22 = k2), o2[k22] = m2[k2];
}
__name(__createBinding, "__createBinding");
function __exportStar(m2, exports) {
  for (var p2 in m2)
    p2 !== "default" && !exports.hasOwnProperty(p2) && (exports[p2] = m2[p2]);
}
__name(__exportStar, "__exportStar");
function __values(o2) {
  var s = typeof Symbol == "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length == "number")
    return {
      next: function() {
        return o2 && i >= o2.length && (o2 = void 0), { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
__name(__values, "__values");
function __read(o2, n2) {
  var m2 = typeof Symbol == "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e2;
  try {
    for (; (n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done; )
      ar.push(r2.value);
  } catch (error3) {
    e2 = { error: error3 };
  } finally {
    try {
      r2 && !r2.done && (m2 = i.return) && m2.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
__name(__read, "__read");
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
__name(__spread, "__spread");
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
__name(__spreadArrays, "__spreadArrays");
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
__name(__await, "__await");
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    g2[n2] && (i[n2] = function(v2) {
      return new Promise(function(a2, b2) {
        q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
      });
    });
  }
  function resume(n2, v2) {
    try {
      step2(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  function step2(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    f2(v2), q2.shift(), q2.length && resume(q2[0][0], q2[0][1]);
  }
}
__name(__asyncGenerator, "__asyncGenerator");
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
__name(__asyncDelegator, "__asyncDelegator");
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values == "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject2) {
        v2 = o2[n2](v2), settle(resolve, reject2, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject2, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject2);
  }
}
__name(__asyncValues, "__asyncValues");
function __makeTemplateObject(cooked, raw) {
  return Object.defineProperty ? Object.defineProperty(cooked, "raw", { value: raw }) : cooked.raw = raw, cooked;
}
__name(__makeTemplateObject, "__makeTemplateObject");
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null)
    for (var k2 in mod)
      Object.hasOwnProperty.call(mod, k2) && (result[k2] = mod[k2]);
  return result.default = mod, result;
}
__name(__importStar, "__importStar");
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
__name(__importDefault, "__importDefault");
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to get private field on non-instance");
  return privateMap.get(receiver);
}
__name(__classPrivateFieldGet, "__classPrivateFieldGet");
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver))
    throw new TypeError("attempted to set private field on non-instance");
  return privateMap.set(receiver, value), value;
}
__name(__classPrivateFieldSet, "__classPrivateFieldSet");
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" })), require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {}, delay = {}, hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1, Object.defineProperty(delay, "__esModule", { value: !0 }), delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(!0);
      }, timeout);
    });
  }
  return __name(delay$1, "delay$1"), delay.delay = delay$1, delay;
}
__name(requireDelay, "requireDelay");
var convert = {}, constants = {}, misc = {}, hasRequiredMisc;
function requireMisc() {
  return hasRequiredMisc || (hasRequiredMisc = 1, Object.defineProperty(misc, "__esModule", { value: !0 }), misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0, misc.ONE_HUNDRED = 100, misc.ONE_THOUSAND = 1e3), misc;
}
__name(requireMisc, "requireMisc");
var time = {}, hasRequiredTime;
function requireTime() {
  return hasRequiredTime || (hasRequiredTime = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 }), exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0, exports.ONE_SECOND = 1, exports.FIVE_SECONDS = 5, exports.TEN_SECONDS = 10, exports.THIRTY_SECONDS = 30, exports.SIXTY_SECONDS = 60, exports.ONE_MINUTE = exports.SIXTY_SECONDS, exports.FIVE_MINUTES = exports.ONE_MINUTE * 5, exports.TEN_MINUTES = exports.ONE_MINUTE * 10, exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30, exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60, exports.ONE_HOUR = exports.SIXTY_MINUTES, exports.THREE_HOURS = exports.ONE_HOUR * 3, exports.SIX_HOURS = exports.ONE_HOUR * 6, exports.TWELVE_HOURS = exports.ONE_HOUR * 12, exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24, exports.ONE_DAY = exports.TWENTY_FOUR_HOURS, exports.THREE_DAYS = exports.ONE_DAY * 3, exports.FIVE_DAYS = exports.ONE_DAY * 5, exports.SEVEN_DAYS = exports.ONE_DAY * 7, exports.THIRTY_DAYS = exports.ONE_DAY * 30, exports.ONE_WEEK = exports.SEVEN_DAYS, exports.TWO_WEEKS = exports.ONE_WEEK * 2, exports.THREE_WEEKS = exports.ONE_WEEK * 3, exports.FOUR_WEEKS = exports.ONE_WEEK * 4, exports.ONE_YEAR = exports.ONE_DAY * 365;
  }(time)), time;
}
__name(requireTime, "requireTime");
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireMisc(), exports), tslib_1.__exportStar(requireTime(), exports);
  }(constants)), constants;
}
__name(requireConstants, "requireConstants");
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1, Object.defineProperty(convert, "__esModule", { value: !0 }), convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  __name(toMiliseconds, "toMiliseconds"), convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  return __name(fromMiliseconds, "fromMiliseconds"), convert.fromMiliseconds = fromMiliseconds, convert;
}
__name(requireConvert, "requireConvert");
var hasRequiredUtils;
function requireUtils() {
  return hasRequiredUtils || (hasRequiredUtils = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireDelay(), exports), tslib_1.__exportStar(requireConvert(), exports);
  }(utils)), utils;
}
__name(requireUtils, "requireUtils");
var watch$1 = {}, hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1, Object.defineProperty(watch$1, "__esModule", { value: !0 }), watch$1.Watch = void 0;
  const _Watch = class _Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label2) {
      if (this.timestamps.has(label2))
        throw new Error(`Watch already started for label: ${label2}`);
      this.timestamps.set(label2, { started: Date.now() });
    }
    stop(label2) {
      const timestamp = this.get(label2);
      if (typeof timestamp.elapsed < "u")
        throw new Error(`Watch already stopped for label: ${label2}`);
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label2, { started: timestamp.started, elapsed });
    }
    get(label2) {
      const timestamp = this.timestamps.get(label2);
      if (typeof timestamp > "u")
        throw new Error(`No timestamp found for label: ${label2}`);
      return timestamp;
    }
    elapsed(label2) {
      const timestamp = this.get(label2);
      return timestamp.elapsed || Date.now() - timestamp.started;
    }
  };
  __name(_Watch, "Watch");
  let Watch = _Watch;
  return watch$1.Watch = Watch, watch$1.default = Watch, watch$1;
}
__name(requireWatch$1, "requireWatch$1");
var types = {}, watch = {}, hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1, Object.defineProperty(watch, "__esModule", { value: !0 }), watch.IWatch = void 0;
  const _IWatch = class _IWatch {
  };
  __name(_IWatch, "IWatch");
  let IWatch = _IWatch;
  return watch.IWatch = IWatch, watch;
}
__name(requireWatch, "requireWatch");
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(exports) {
    Object.defineProperty(exports, "__esModule", { value: !0 }), require$$0.__exportStar(requireWatch(), exports);
  }(types)), types;
}
__name(requireTypes, "requireTypes");
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: !0 });
  const tslib_1 = require$$0;
  tslib_1.__exportStar(requireUtils(), exports), tslib_1.__exportStar(requireWatch$1(), exports), tslib_1.__exportStar(requireTypes(), exports), tslib_1.__exportStar(requireConstants(), exports);
})(cjs$2);
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: !0 });
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0;
function getFromWindow(name) {
  let res;
  return typeof window < "u" && typeof window[name] < "u" && (res = window[name]), res;
}
__name(getFromWindow, "getFromWindow");
cjs$1.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
  const res = getFromWindow(name);
  if (!res)
    throw new Error(`${name} is not defined in Window`);
  return res;
}
__name(getFromWindowOrThrow, "getFromWindowOrThrow");
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
__name(getDocumentOrThrow, "getDocumentOrThrow");
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
__name(getDocument, "getDocument");
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
__name(getNavigatorOrThrow, "getNavigatorOrThrow");
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
__name(getNavigator, "getNavigator");
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
__name(getLocationOrThrow, "getLocationOrThrow");
cjs$1.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
__name(getLocation, "getLocation");
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
__name(getCryptoOrThrow, "getCryptoOrThrow");
cjs$1.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
__name(getCrypto, "getCrypto");
cjs$1.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
__name(getLocalStorageOrThrow, "getLocalStorageOrThrow");
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
__name(getLocalStorage, "getLocalStorage");
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: !0 });
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
  let doc, loc;
  try {
    doc = window_getters_1.getDocumentOrThrow(), loc = window_getters_1.getLocationOrThrow();
  } catch {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link"), icons2 = [];
    for (let i = 0; i < links.length; i++) {
      const link2 = links[i], rel = link2.getAttribute("rel");
      if (rel && rel.toLowerCase().indexOf("icon") > -1) {
        const href = link2.getAttribute("href");
        if (href)
          if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
            let absoluteHref = loc.protocol + "//" + loc.host;
            if (href.indexOf("/") === 0)
              absoluteHref += href;
            else {
              const path = loc.pathname.split("/");
              path.pop();
              const finalPath = path.join("/");
              absoluteHref += finalPath + "/" + href;
            }
            icons2.push(absoluteHref);
          } else if (href.indexOf("//") === 0) {
            const absoluteUrl = loc.protocol + href;
            icons2.push(absoluteUrl);
          } else
            icons2.push(href);
      }
    }
    return icons2;
  }
  __name(getIcons, "getIcons");
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i = 0; i < metaTags.length; i++) {
      const tag = metaTags[i], attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => attr ? args.includes(attr) : !1);
      if (attributes.length && attributes) {
        const content2 = tag.getAttribute("content");
        if (content2)
          return content2;
      }
    }
    return "";
  }
  __name(getWindowMetadataOfAny, "getWindowMetadataOfAny");
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    return name2 || (name2 = doc.title), name2;
  }
  __name(getName, "getName");
  function getDescription() {
    return getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
  }
  __name(getDescription, "getDescription");
  const name = getName(), description2 = getDescription(), url = loc.origin, icons = getIcons();
  return {
    description: description2,
    url,
    icons,
    name
  };
}
__name(getWindowMetadata, "getWindowMetadata");
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {}, strictUriEncode = /* @__PURE__ */ __name((str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`), "strictUriEncode"), token = "%[a-f0-9]{2}", singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi"), multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components2, split) {
  try {
    return [decodeURIComponent(components2.join(""))];
  } catch {
  }
  if (components2.length === 1)
    return components2;
  split = split || 1;
  var left2 = components2.slice(0, split), right = components2.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right));
}
__name(decodeComponents, "decodeComponents");
function decode(input2) {
  try {
    return decodeURIComponent(input2);
  } catch {
    for (var tokens = input2.match(singleMatcher) || [], i = 1; i < tokens.length; i++)
      input2 = decodeComponents(tokens, i).join(""), tokens = input2.match(singleMatcher) || [];
    return input2;
  }
}
__name(decode, "decode");
function customDecodeURIComponent(input2) {
  for (var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  }, match2 = multiMatcher.exec(input2); match2; ) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch {
      var result = decode(match2[0]);
      result !== match2[0] && (replaceMap[match2[0]] = result);
    }
    match2 = multiMatcher.exec(input2);
  }
  replaceMap["%C2"] = "�";
  for (var entries = Object.keys(replaceMap), i = 0; i < entries.length; i++) {
    var key = entries[i];
    input2 = input2.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input2;
}
__name(customDecodeURIComponent, "customDecodeURIComponent");
var decodeUriComponent = /* @__PURE__ */ __name(function(encodedURI) {
  if (typeof encodedURI != "string")
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  try {
    return encodedURI = encodedURI.replace(/\+/g, " "), decodeURIComponent(encodedURI);
  } catch {
    return customDecodeURIComponent(encodedURI);
  }
}, "decodeUriComponent"), splitOnFirst = /* @__PURE__ */ __name((string2, separator2) => {
  if (!(typeof string2 == "string" && typeof separator2 == "string"))
    throw new TypeError("Expected the arguments to be of type `string`");
  if (separator2 === "")
    return [string2];
  const separatorIndex = string2.indexOf(separator2);
  return separatorIndex === -1 ? [string2] : [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator2.length)
  ];
}, "splitOnFirst"), filterObj = /* @__PURE__ */ __name(function(obj, predicate) {
  for (var ret = {}, keys = Object.keys(obj), isArr = Array.isArray(predicate), i = 0; i < keys.length; i++) {
    var key = keys[i], val = obj[key];
    (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) && (ret[key] = val);
  }
  return ret;
}, "filterObj");
(function(exports) {
  const strictUriEncode$1 = strictUriEncode, decodeComponent = decodeUriComponent, splitOnFirst$1 = splitOnFirst, filterObject = filterObj, isNullOrUndefined = /* @__PURE__ */ __name((value) => value == null, "isNullOrUndefined"), encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options2) {
    switch (options2.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index = result.length;
          return value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), "[", index, "]"].join("")] : [
            ...result,
            [encode2(key, options2), "[", encode2(index, options2), "]=", encode2(value, options2)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), "[]"].join("")] : [...result, [encode2(key, options2), "[]=", encode2(value, options2)].join("")];
      case "colon-list-separator":
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, [encode2(key, options2), ":list="].join("")] : [...result, [encode2(key, options2), ":list=", encode2(value, options2)].join("")];
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : (value = value === null ? "" : value, result.length === 0 ? [[encode2(key, options2), keyValueSep, encode2(value, options2)].join("")] : [[result, encode2(value, options2)].join(options2.arrayFormatSeparator)]);
      }
      default:
        return (key) => (result, value) => value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "" ? result : value === null ? [...result, encode2(key, options2)] : [...result, [encode2(key, options2), "=", encode2(value, options2)].join("")];
    }
  }
  __name(encoderForArrayFormat, "encoderForArrayFormat");
  function parserForArrayFormat(options2) {
    let result;
    switch (options2.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          if (result = /\[(\d*)\]$/.exec(key), key = key.replace(/\[\d*\]$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] === void 0 && (accumulator[key] = {}), accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          if (result = /(\[\])$/.exec(key), key = key.replace(/\[\]$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          if (result = /(:list)$/.exec(key), key = key.replace(/:list$/, ""), !result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value == "string" && value.includes(options2.arrayFormatSeparator), isEncodedArray = typeof value == "string" && !isArray2 && decode2(value, options2).includes(options2.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options2) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2)) : value === null ? value : decode2(value, options2);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          if (key = key.replace(/\[\]$/, ""), !isArray2) {
            accumulator[key] = value && decode2(value, options2);
            return;
          }
          const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  __name(parserForArrayFormat, "parserForArrayFormat");
  function validateArrayFormatSeparator(value) {
    if (typeof value != "string" || value.length !== 1)
      throw new TypeError("arrayFormatSeparator must be single character string");
  }
  __name(validateArrayFormatSeparator, "validateArrayFormatSeparator");
  function encode2(value, options2) {
    return options2.encode ? options2.strict ? strictUriEncode$1(value) : encodeURIComponent(value) : value;
  }
  __name(encode2, "encode");
  function decode2(value, options2) {
    return options2.decode ? decodeComponent(value) : value;
  }
  __name(decode2, "decode");
  function keysSorter(input2) {
    return Array.isArray(input2) ? input2.sort() : typeof input2 == "object" ? keysSorter(Object.keys(input2)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input2[key]) : input2;
  }
  __name(keysSorter, "keysSorter");
  function removeHash(input2) {
    const hashStart = input2.indexOf("#");
    return hashStart !== -1 && (input2 = input2.slice(0, hashStart)), input2;
  }
  __name(removeHash, "removeHash");
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    return hashStart !== -1 && (hash2 = url.slice(hashStart)), hash2;
  }
  __name(getHash, "getHash");
  function extract(input2) {
    input2 = removeHash(input2);
    const queryStart = input2.indexOf("?");
    return queryStart === -1 ? "" : input2.slice(queryStart + 1);
  }
  __name(extract, "extract");
  function parseValue(value, options2) {
    return options2.parseNumbers && !Number.isNaN(Number(value)) && typeof value == "string" && value.trim() !== "" ? value = Number(value) : options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false") && (value = value.toLowerCase() === "true"), value;
  }
  __name(parseValue, "parseValue");
  function parse2(query, options2) {
    options2 = Object.assign({
      decode: !0,
      sort: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: !1,
      parseBooleans: !1
    }, options2), validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options2), ret = /* @__PURE__ */ Object.create(null);
    if (typeof query != "string" || (query = query.trim().replace(/^[?#&]/, ""), !query))
      return ret;
    for (const param of query.split("&")) {
      if (param === "")
        continue;
      let [key, value] = splitOnFirst$1(options2.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode2(value, options2), formatter(decode2(key, options2), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value == "object" && value !== null)
        for (const k2 of Object.keys(value))
          value[k2] = parseValue(value[k2], options2);
      else
        ret[key] = parseValue(value, options2);
    }
    return options2.sort === !1 ? ret : (options2.sort === !0 ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key) => {
      const value = ret[key];
      return value && typeof value == "object" && !Array.isArray(value) ? result[key] = keysSorter(value) : result[key] = value, result;
    }, /* @__PURE__ */ Object.create(null));
  }
  __name(parse2, "parse"), exports.extract = extract, exports.parse = parse2, exports.stringify = (object, options2) => {
    if (!object)
      return "";
    options2 = Object.assign({
      encode: !0,
      strict: !0,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options2), validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const shouldFilter = /* @__PURE__ */ __name((key) => options2.skipNull && isNullOrUndefined(object[key]) || options2.skipEmptyString && object[key] === "", "shouldFilter"), formatter = encoderForArrayFormat(options2), objectCopy = {};
    for (const key of Object.keys(object))
      shouldFilter(key) || (objectCopy[key] = object[key]);
    const keys = Object.keys(objectCopy);
    return options2.sort !== !1 && keys.sort(options2.sort), keys.map((key) => {
      const value = object[key];
      return value === void 0 ? "" : value === null ? encode2(key, options2) : Array.isArray(value) ? value.length === 0 && options2.arrayFormat === "bracket-separator" ? encode2(key, options2) + "[]" : value.reduce(formatter(key), []).join("&") : encode2(key, options2) + "=" + encode2(value, options2);
    }).filter((x2) => x2.length > 0).join("&");
  }, exports.parseUrl = (url, options2) => {
    options2 = Object.assign({
      decode: !0
    }, options2);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options2)
      },
      options2 && options2.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options2) } : {}
    );
  }, exports.stringifyUrl = (object, options2) => {
    options2 = Object.assign({
      encode: !0,
      strict: !0,
      [encodeFragmentIdentifier]: !0
    }, options2);
    const url = removeHash(object.url).split("?")[0] || "", queryFromUrl = exports.extract(object.url), parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: !1 }), query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options2);
    queryString2 && (queryString2 = `?${queryString2}`);
    let hash2 = getHash(object.url);
    return object.fragmentIdentifier && (hash2 = `#${options2[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`), `${url}${queryString2}${hash2}`;
  }, exports.pick = (input2, filter, options2) => {
    options2 = Object.assign({
      parseFragmentIdentifier: !0,
      [encodeFragmentIdentifier]: !1
    }, options2);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input2, options2);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options2);
  }, exports.exclude = (input2, filter, options2) => {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input2, exclusionFilter, options2);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function L(e2, n2) {
  return e2.includes(":") ? [e2] : n2.chains || [];
}
__name(L, "L");
const J = "base10", p = "base16", F = "base64pad", H = "utf8", Q = 0, _23 = 1, Dn = 0, Ie = 1, Z = 12, X = 32;
function kn() {
  const e2 = x25519.generateKeyPair();
  return { privateKey: toString(e2.secretKey, p), publicKey: toString(e2.publicKey, p) };
}
__name(kn, "kn");
function Vn() {
  const e2 = random.randomBytes(X);
  return toString(e2, p);
}
__name(Vn, "Vn");
function Mn(e2, n2) {
  const t2 = x25519.sharedKey(fromString(e2, p), fromString(n2, p), !0), r2 = new HKDF_1(sha256.SHA256, t2).expand(X);
  return toString(r2, p);
}
__name(Mn, "Mn");
function Kn(e2) {
  const n2 = sha256.hash(fromString(e2, p));
  return toString(n2, p);
}
__name(Kn, "Kn");
function Ln(e2) {
  const n2 = sha256.hash(fromString(e2, H));
  return toString(n2, p);
}
__name(Ln, "Ln");
function Pe(e2) {
  return fromString(`${e2}`, J);
}
__name(Pe, "Pe");
function $(e2) {
  return Number(toString(e2, J));
}
__name($, "$");
function xn(e2) {
  const n2 = Pe(typeof e2.type < "u" ? e2.type : Q);
  if ($(n2) === _23 && typeof e2.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e2.senderPublicKey < "u" ? fromString(e2.senderPublicKey, p) : void 0, r2 = typeof e2.iv < "u" ? fromString(e2.iv, p) : random.randomBytes(Z), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)).seal(r2, fromString(e2.message, H));
  return Re({ type: n2, sealed: o2, iv: r2, senderPublicKey: t2 });
}
__name(xn, "xn");
function Fn(e2) {
  const n2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e2.symKey, p)), { sealed: t2, iv: r2 } = ee(e2.encoded), o2 = n2.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, H);
}
__name(Fn, "Fn");
function Re(e2) {
  if ($(e2.type) === _23) {
    if (typeof e2.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e2.type, e2.senderPublicKey, e2.iv, e2.sealed]), F);
  }
  return toString(concat([e2.type, e2.iv, e2.sealed]), F);
}
__name(Re, "Re");
function ee(e2) {
  const n2 = fromString(e2, F), t2 = n2.slice(Dn, Ie), r2 = Ie;
  if ($(t2) === _23) {
    const d2 = r2 + X, l2 = d2 + Z, c2 = n2.slice(r2, d2), u2 = n2.slice(d2, l2), a2 = n2.slice(l2);
    return { type: t2, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o2 = r2 + Z, s = n2.slice(r2, o2), i = n2.slice(o2);
  return { type: t2, sealed: i, iv: s };
}
__name(ee, "ee");
function Hn(e2, n2) {
  const t2 = ee(e2);
  return Te({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
__name(Hn, "Hn");
function Te(e2) {
  const n2 = (e2 == null ? void 0 : e2.type) || Q;
  if (n2 === _23) {
    if (typeof (e2 == null ? void 0 : e2.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e2 == null ? void 0 : e2.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e2 == null ? void 0 : e2.senderPublicKey, receiverPublicKey: e2 == null ? void 0 : e2.receiverPublicKey };
}
__name(Te, "Te");
function qn(e2) {
  return e2.type === _23 && typeof e2.senderPublicKey == "string" && typeof e2.receiverPublicKey == "string";
}
__name(qn, "qn");
var Bn = Object.defineProperty, Ae = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn = Object.prototype.propertyIsEnumerable, Ue = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? Bn(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "Ue"), _e = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Gn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  if (Ae)
    for (var t2 of Ae(n2))
      Wn.call(n2, t2) && Ue(e2, t2, n2[t2]);
  return e2;
}, "_e");
const Ce = "ReactNative", m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, $e = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
__name(te, "te");
function C() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce;
}
__name(C, "C");
function D() {
  return !te() && !!getNavigator_1();
}
__name(D, "D");
function T() {
  return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
__name(T, "T");
function Jn() {
  var e2;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e2 = global.Application) == null ? void 0 : e2.applicationId : void 0;
  } catch {
    return;
  }
}
__name(Jn, "Jn");
function De(e2, n2) {
  let t2 = queryString.parse(e2);
  return t2 = _e(_e({}, t2), n2), e2 = queryString.stringify(t2), e2;
}
__name(De, "De");
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
__name(Qn, "Qn");
function ke() {
  if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e2 = detect();
  if (e2 === null)
    return "unknown";
  const n2 = e2.os ? e2.os.replace(" ", "").toLowerCase() : "unknown";
  return e2.type === "browser" ? [n2, e2.name, e2.version].join("-") : [n2, e2.version].join("-");
}
__name(ke, "ke");
function Ve() {
  var e2;
  const n2 = T();
  return n2 === m.browser ? [n2, ((e2 = getLocation_1()) == null ? void 0 : e2.host) || "unknown"].join(":") : n2;
}
__name(Ve, "Ve");
function Me(e2, n2, t2) {
  const r2 = ke(), o2 = Ve();
  return [[e2, n2].join("-"), [$e, t2].join("-"), r2, o2].join("/");
}
__name(Me, "Me");
function Xn({ protocol: e2, version: n2, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i, bundleId: d2 }) {
  const l2 = t2.split("?"), c2 = Me(e2, n2, r2), u2 = { auth: o2, ua: c2, projectId: s, useOnCloseEvent: i || void 0, origin: d2 || void 0 }, a2 = De(l2[1] || "", u2);
  return l2[0] + "?" + a2;
}
__name(Xn, "Xn");
function O(e2, n2) {
  return e2.filter((t2) => n2.includes(t2)).length === e2.length;
}
__name(O, "O");
function rt(e2) {
  return Object.fromEntries(e2.entries());
}
__name(rt, "rt");
function ot(e2) {
  return new Map(Object.entries(e2));
}
__name(ot, "ot");
function at(e2 = cjs$2.FIVE_MINUTES, n2) {
  const t2 = cjs$2.toMiliseconds(e2 || cjs$2.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i) => {
    s && r2 && (clearTimeout(s), r2(i));
  }, reject: (i) => {
    s && o2 && (clearTimeout(s), o2(i));
  }, done: () => new Promise((i, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t2), r2 = i, o2 = d2;
  }) };
}
__name(at, "at");
function ut(e2, n2, t2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(t2)), n2);
    try {
      const i = await e2;
      r2(i);
    } catch (i) {
      o2(i);
    }
    clearTimeout(s);
  });
}
__name(ut, "ut");
function re(e2, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e2}:`))
    return n2;
  if (e2.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e2.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e2}`);
}
__name(re, "re");
function lt(e2) {
  return re("topic", e2);
}
__name(lt, "lt");
function dt(e2) {
  return re("id", e2);
}
__name(dt, "dt");
function ft(e2) {
  const [n2, t2] = e2.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
__name(ft, "ft");
function pt(e2, n2) {
  return cjs$2.fromMiliseconds((n2 || Date.now()) + cjs$2.toMiliseconds(e2));
}
__name(pt, "pt");
function mt(e2) {
  return Date.now() >= cjs$2.toMiliseconds(e2);
}
__name(mt, "mt");
function yt(e2, n2) {
  return `${e2}${n2 ? `:${n2}` : ""}`;
}
__name(yt, "yt");
function S(e2 = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e2, ...n2])];
}
__name(S, "S");
async function ht({ id: e2, topic: n2, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2 == null ? void 0 : r2.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e2}&sessionTopic=${n2}`, i = T();
    i === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r2) {
    console.error(r2);
  }
}
__name(ht, "ht");
async function gt(e2, n2) {
  try {
    return await e2.getItem(n2) || (D() ? localStorage.getItem(n2) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
__name(gt, "gt");
const Fe = "irn";
function vt(e2) {
  return (e2 == null ? void 0 : e2.relay) || { protocol: Fe };
}
__name(vt, "vt");
function Et(e2) {
  const n2 = RELAY_JSONRPC[e2];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e2}`);
  return n2;
}
__name(Et, "Et");
var bt = Object.defineProperty, He = Object.getOwnPropertySymbols, Nt = Object.prototype.hasOwnProperty, Ot = Object.prototype.propertyIsEnumerable, qe = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? bt(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "qe"), St = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Nt.call(n2, t2) && qe(e2, t2, n2[t2]);
  if (He)
    for (var t2 of He(n2))
      Ot.call(n2, t2) && qe(e2, t2, n2[t2]);
  return e2;
}, "St");
function Be(e2, n2 = "-") {
  const t2 = {}, r2 = "relay" + n2;
  return Object.keys(e2).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i = e2[o2];
      t2[s] = i;
    }
  }), t2;
}
__name(Be, "Be");
function wt(e2) {
  e2 = e2.includes("wc://") ? e2.replace("wc://", "") : e2, e2 = e2.includes("wc:") ? e2.replace("wc:", "") : e2;
  const n2 = e2.indexOf(":"), t2 = e2.indexOf("?") !== -1 ? e2.indexOf("?") : void 0, r2 = e2.substring(0, n2), o2 = e2.substring(n2 + 1, t2).split("@"), s = typeof t2 < "u" ? e2.substring(t2) : "", i = queryString.parse(s);
  return { protocol: r2, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i.symKey, relay: Be(i) };
}
__name(wt, "wt");
function Ge(e2) {
  return e2.startsWith("//") ? e2.substring(2) : e2;
}
__name(Ge, "Ge");
function We(e2, n2 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e2).forEach((o2) => {
    const s = t2 + n2 + o2;
    e2[o2] && (r2[s] = e2[o2]);
  }), r2;
}
__name(We, "We");
function It(e2) {
  return `${e2.protocol}:${e2.topic}@${e2.version}?` + queryString.stringify(St({ symKey: e2.symKey }, We(e2.relay)));
}
__name(It, "It");
var Pt = Object.defineProperty, Rt = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, ze = Object.getOwnPropertySymbols, At = Object.prototype.hasOwnProperty, Ut = Object.prototype.propertyIsEnumerable, Ye = /* @__PURE__ */ __name((e2, n2, t2) => n2 in e2 ? Pt(e2, n2, { enumerable: !0, configurable: !0, writable: !0, value: t2 }) : e2[n2] = t2, "Ye"), _t = /* @__PURE__ */ __name((e2, n2) => {
  for (var t2 in n2 || (n2 = {}))
    At.call(n2, t2) && Ye(e2, t2, n2[t2]);
  if (ze)
    for (var t2 of ze(n2))
      Ut.call(n2, t2) && Ye(e2, t2, n2[t2]);
  return e2;
}, "_t"), Ct = /* @__PURE__ */ __name((e2, n2) => Rt(e2, Tt(n2)), "Ct");
function A(e2) {
  const n2 = [];
  return e2.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n2.push(`${r2}:${o2}`);
  }), n2;
}
__name(A, "A");
function Je(e2) {
  const n2 = [];
  return Object.values(e2).forEach((t2) => {
    n2.push(...A(t2.accounts));
  }), n2;
}
__name(Je, "Je");
function Qe(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.methods);
  }), t2;
}
__name(Qe, "Qe");
function Ze(e2, n2) {
  const t2 = [];
  return Object.values(e2).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.events);
  }), t2;
}
__name(Ze, "Ze");
function jt(e2, n2) {
  const t2 = un(e2, n2);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s] of Object.entries(e2))
    r2[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i) => `${i.split(":")[0]}:${i.split(":")[1]}`) };
  return r2;
}
__name(jt, "jt");
function $t(e2) {
  const { proposal: { requiredNamespaces: n2, optionalNamespaces: t2 = {} }, supportedNamespaces: r2 } = e2, o2 = se(n2), s = se(t2), i = {};
  Object.keys(r2).forEach((c2) => {
    const u2 = r2[c2].chains, a2 = r2[c2].methods, b2 = r2[c2].events, I2 = r2[c2].accounts;
    u2.forEach((y2) => {
      if (!I2.some((f2) => f2.includes(y2)))
        throw new Error(`No accounts provided for chain ${y2} in namespace ${c2}`);
    }), i[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  });
  const d2 = dn(n2, i, "approve()");
  if (d2)
    throw new Error(d2.message);
  const l2 = {};
  return !Object.keys(n2).length && !Object.keys(t2).length ? i : (Object.keys(o2).forEach((c2) => {
    const u2 = r2[c2].chains.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.chains) == null ? void 0 : g2.includes(y2);
    }), a2 = r2[c2].methods.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.methods) == null ? void 0 : g2.includes(y2);
    }), b2 = r2[c2].events.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.events) == null ? void 0 : g2.includes(y2);
    }), I2 = u2.map((y2) => r2[c2].accounts.filter((f2) => f2.includes(`${y2}:`))).flat();
    l2[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  }), Object.keys(s).forEach((c2) => {
    var u2, a2, b2, I2, y2, f2;
    if (!r2[c2])
      return;
    const g2 = (a2 = (u2 = s[c2]) == null ? void 0 : u2.chains) == null ? void 0 : a2.filter((P2) => r2[c2].chains.includes(P2)), vn2 = r2[c2].methods.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.methods) == null ? void 0 : j2.includes(P2);
    }), En2 = r2[c2].events.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.events) == null ? void 0 : j2.includes(P2);
    }), bn2 = g2 == null ? void 0 : g2.map((P2) => r2[c2].accounts.filter((R2) => R2.includes(`${P2}:`))).flat();
    l2[c2] = { chains: S((b2 = l2[c2]) == null ? void 0 : b2.chains, g2), methods: S((I2 = l2[c2]) == null ? void 0 : I2.methods, vn2), events: S((y2 = l2[c2]) == null ? void 0 : y2.events, En2), accounts: S((f2 = l2[c2]) == null ? void 0 : f2.accounts, bn2) };
  }), l2);
}
__name($t, "$t");
function oe(e2) {
  return e2.includes(":");
}
__name(oe, "oe");
function Xe(e2) {
  return oe(e2) ? e2.split(":")[0] : e2;
}
__name(Xe, "Xe");
function se(e2) {
  var n2, t2, r2;
  const o2 = {};
  if (!B(e2))
    return o2;
  for (const [s, i] of Object.entries(e2)) {
    const d2 = oe(s) ? [s] : i.chains, l2 = i.methods || [], c2 = i.events || [], u2 = Xe(s);
    o2[u2] = Ct(_t({}, o2[u2]), { chains: S(d2, (n2 = o2[u2]) == null ? void 0 : n2.chains), methods: S(l2, (t2 = o2[u2]) == null ? void 0 : t2.methods), events: S(c2, (r2 = o2[u2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
__name(se, "se");
const en = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, nn = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e2, n2) {
  const { message: t2, code: r2 } = nn[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
__name(N, "N");
function U(e2, n2) {
  const { message: t2, code: r2 } = en[e2];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
__name(U, "U");
function k(e2, n2) {
  return Array.isArray(e2) ? typeof n2 < "u" && e2.length ? e2.every(n2) : !0 : !1;
}
__name(k, "k");
function B(e2) {
  return Object.getPrototypeOf(e2) === Object.prototype && Object.keys(e2).length;
}
__name(B, "B");
function w(e2) {
  return typeof e2 > "u";
}
__name(w, "w");
function h(e2, n2) {
  return n2 && w(e2) ? !0 : typeof e2 == "string" && !!e2.trim().length;
}
__name(h, "h");
function G(e2, n2) {
  return n2 && w(e2) ? !0 : typeof e2 == "number" && !isNaN(e2);
}
__name(G, "G");
function Dt(e2, n2) {
  const { requiredNamespaces: t2 } = n2, r2 = Object.keys(e2.namespaces), o2 = Object.keys(t2);
  let s = !0;
  return O(o2, r2) ? (r2.forEach((i) => {
    const { accounts: d2, methods: l2, events: c2 } = e2.namespaces[i], u2 = A(d2), a2 = t2[i];
    (!O(L(i, a2), u2) || !O(a2.methods, l2) || !O(a2.events, c2)) && (s = !1);
  }), s) : !1;
}
__name(Dt, "Dt");
function V(e2) {
  return h(e2, !1) && e2.includes(":") ? e2.split(":").length === 2 : !1;
}
__name(V, "V");
function tn(e2) {
  if (h(e2, !1) && e2.includes(":")) {
    const n2 = e2.split(":");
    if (n2.length === 3) {
      const t2 = n2[0] + ":" + n2[1];
      return !!n2[2] && V(t2);
    }
  }
  return !1;
}
__name(tn, "tn");
function kt$1(e2) {
  if (h(e2, !1))
    try {
      return typeof new URL(e2) < "u";
    } catch {
      return !1;
    }
  return !1;
}
__name(kt$1, "kt$1");
function Vt(e2) {
  var n2;
  return (n2 = e2 == null ? void 0 : e2.proposer) == null ? void 0 : n2.publicKey;
}
__name(Vt, "Vt");
function Mt$1(e2) {
  return e2 == null ? void 0 : e2.topic;
}
__name(Mt$1, "Mt$1");
function Kt(e2, n2) {
  let t2 = null;
  return h(e2 == null ? void 0 : e2.publicKey, !1) || (t2 = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t2;
}
__name(Kt, "Kt");
function ie(e2) {
  let n2 = !0;
  return k(e2) ? e2.length && (n2 = e2.every((t2) => h(t2, !1))) : n2 = !1, n2;
}
__name(ie, "ie");
function rn(e2, n2, t2) {
  let r2 = null;
  return k(n2) && n2.length ? n2.forEach((o2) => {
    r2 || V(o2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V(e2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
__name(rn, "rn");
function on(e2, n2, t2) {
  let r2 = null;
  return Object.entries(e2).forEach(([o2, s]) => {
    if (r2)
      return;
    const i = rn(o2, L(o2, s), `${n2} ${t2}`);
    i && (r2 = i);
  }), r2;
}
__name(on, "on");
function sn(e2, n2) {
  let t2 = null;
  return k(e2) ? e2.forEach((r2) => {
    t2 || tn(r2) || (t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
__name(sn, "sn");
function cn(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = sn(r2 == null ? void 0 : r2.accounts, `${n2} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
__name(cn, "cn");
function an(e2, n2) {
  let t2 = null;
  return ie(e2 == null ? void 0 : e2.methods) ? ie(e2 == null ? void 0 : e2.events) || (t2 = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t2 = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t2;
}
__name(an, "an");
function ce(e2, n2) {
  let t2 = null;
  return Object.values(e2).forEach((r2) => {
    if (t2)
      return;
    const o2 = an(r2, `${n2}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
__name(ce, "ce");
function Lt(e2, n2, t2) {
  let r2 = null;
  if (e2 && B(e2)) {
    const o2 = ce(e2, n2);
    o2 && (r2 = o2);
    const s = on(e2, n2, t2);
    s && (r2 = s);
  } else
    r2 = N("MISSING_OR_INVALID", `${n2}, ${t2} should be an object with data`);
  return r2;
}
__name(Lt, "Lt");
function un(e2, n2) {
  let t2 = null;
  if (e2 && B(e2)) {
    const r2 = ce(e2, n2);
    r2 && (t2 = r2);
    const o2 = cn(e2, n2);
    o2 && (t2 = o2);
  } else
    t2 = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t2;
}
__name(un, "un");
function ln(e2) {
  return h(e2.protocol, !0);
}
__name(ln, "ln");
function xt(e2, n2) {
  let t2 = !1;
  return n2 && !e2 ? t2 = !0 : e2 && k(e2) && e2.length && e2.forEach((r2) => {
    t2 = ln(r2);
  }), t2;
}
__name(xt, "xt");
function Ft(e2) {
  return typeof e2 == "number";
}
__name(Ft, "Ft");
function Ht(e2) {
  return typeof e2 < "u" && typeof e2 !== null;
}
__name(Ht, "Ht");
function qt(e2) {
  return !(!e2 || typeof e2 != "object" || !e2.code || !G(e2.code, !1) || !e2.message || !h(e2.message, !1));
}
__name(qt, "qt");
function Bt(e2) {
  return !(w(e2) || !h(e2.method, !1));
}
__name(Bt, "Bt");
function Gt(e2) {
  return !(w(e2) || w(e2.result) && w(e2.error) || !G(e2.id, !1) || !h(e2.jsonrpc, !1));
}
__name(Gt, "Gt");
function Wt(e2) {
  return !(w(e2) || !h(e2.name, !1));
}
__name(Wt, "Wt");
function zt(e2, n2) {
  return !(!V(n2) || !Je(e2).includes(n2));
}
__name(zt, "zt");
function Yt(e2, n2, t2) {
  return h(t2, !1) ? Qe(e2, n2).includes(t2) : !1;
}
__name(Yt, "Yt");
function Jt(e2, n2, t2) {
  return h(t2, !1) ? Ze(e2, n2).includes(t2) : !1;
}
__name(Jt, "Jt");
function dn(e2, n2, t2) {
  let r2 = null;
  const o2 = Qt(e2), s = Zt(n2), i = Object.keys(o2), d2 = Object.keys(s), l2 = fn(Object.keys(e2)), c2 = fn(Object.keys(n2)), u2 = l2.filter((a2) => !c2.includes(a2));
  return u2.length && (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i, d2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b2 = A(n2[a2].accounts);
    b2.includes(a2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b2.toString()}`));
  }), i.forEach((a2) => {
    r2 || (O(o2[a2].methods, s[a2].methods) ? O(o2[a2].events, s[a2].events) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
__name(dn, "dn");
function Qt(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    var r2;
    t2.includes(":") ? n2[t2] = e2[t2] : (r2 = e2[t2].chains) == null || r2.forEach((o2) => {
      n2[o2] = { methods: e2[t2].methods, events: e2[t2].events };
    });
  }), n2;
}
__name(Qt, "Qt");
function fn(e2) {
  return [...new Set(e2.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
__name(fn, "fn");
function Zt(e2) {
  const n2 = {};
  return Object.keys(e2).forEach((t2) => {
    if (t2.includes(":"))
      n2[t2] = e2[t2];
    else {
      const r2 = A(e2[t2].accounts);
      r2 == null || r2.forEach((o2) => {
        n2[o2] = { accounts: e2[t2].accounts.filter((s) => s.includes(`${o2}:`)), methods: e2[t2].methods, events: e2[t2].events };
      });
    }
  }), n2;
}
__name(Zt, "Zt");
function Xt(e2, n2) {
  return G(e2, !1) && e2 <= n2.max && e2 >= n2.min;
}
__name(Xt, "Xt");
function er() {
  const e2 = T();
  return new Promise((n2) => {
    switch (e2) {
      case m.browser:
        n2(pn());
        break;
      case m.reactNative:
        n2(mn());
        break;
      case m.node:
        n2(yn());
        break;
      default:
        n2(!0);
    }
  });
}
__name(er, "er");
function pn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
__name(pn, "pn");
async function mn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e2 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e2 == null ? void 0 : e2.isConnected;
  }
  return !0;
}
__name(mn, "mn");
function yn() {
  return !0;
}
__name(yn, "yn");
function nr(e2) {
  switch (T()) {
    case m.browser:
      hn(e2);
      break;
    case m.reactNative:
      gn(e2);
      break;
  }
}
__name(nr, "nr");
function hn(e2) {
  !C() && D() && (window.addEventListener("online", () => e2(!0)), window.addEventListener("offline", () => e2(!1)));
}
__name(hn, "hn");
function gn(e2) {
  C() && typeof global < "u" && global != null && global.NetInfo && (global == null || global.NetInfo.addEventListener((n2) => e2(n2 == null ? void 0 : n2.isConnected)));
}
__name(gn, "gn");
const ae = {}, _tr = class _tr {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t2) {
    ae[n2] = t2;
  }
  static delete(n2) {
    delete ae[n2];
  }
};
__name(_tr, "tr");
let tr = _tr;
const buttonsContainer = "_buttonsContainer_yg3s8_1", container$2 = "_container_yg3s8_7", connectionRequest = "_connectionRequest_yg3s8_12", receiveAddress$2 = "_receiveAddress_yg3s8_16", pairingDetailContainer = "_pairingDetailContainer_yg3s8_21", metadata = "_metadata_yg3s8_32", styles$9 = {
  buttonsContainer,
  container: container$2,
  connectionRequest,
  receiveAddress: receiveAddress$2,
  pairingDetailContainer,
  metadata
}, PairingContainer = /* @__PURE__ */ __name(({ pairingMetadata }) => {
  const { name, description: description2, url, icons } = pairingMetadata, hasIcon = icons && icons.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.pairingDetailContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: description2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$9.metadata, children: url })
    ] }),
    hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icons[0], alt: "logo" })
  ] });
}, "PairingContainer"), WCIncomingPairing = /* @__PURE__ */ __name(({
  currentProposal,
  pairingMetadata,
  receiveAddress: receiveAddress2,
  onReject,
  onApprove
}) => {
  const [pairingLoading, setPairingLoading] = reactExports.useState(!1), { web3wallet } = reactExports.useContext(WCWeb3WalletContext), { t: t2 } = useTranslation(), handleApprovePairing = /* @__PURE__ */ __name(async () => {
    setPairingLoading(!0);
    try {
      const { id: id2, params } = currentProposal, { requiredNamespaces } = params, eipList = Object.values(requiredNamespaces), accounts = eipList.flatMap((eip) => {
        var _a46;
        return ((_a46 = eip.chains) == null ? void 0 : _a46.map((chain) => `${chain}:${receiveAddress2}`)) || [];
      }), chains = eipList.flatMap(
        (proposal) => proposal.chains ? proposal.chains.filter((chain) => Object.keys(SUPPORTED_CHAINS).includes(chain)) : []
      ), namespaces = $t({
        proposal: params,
        supportedNamespaces: {
          eip155: {
            chains,
            methods: ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "personal_sign", "eth_signTypedData", "eth_signTypedData_v4"],
            events: ["accountsChanged", "chainChanged"],
            accounts
          }
        }
      });
      await (web3wallet == null ? void 0 : web3wallet.approveSession({
        id: id2,
        namespaces
      })), onApprove();
    } catch (e2) {
      console.error(`Wallet connect approve pairing error ${e2}`), console.error(e2), e2.message.includes("Non conforming namespaces") ? alertUser(t2(
        "walletConnect.invalidPairingChain",
        {
          chains: `
•Ethereum 
•Ethereum (Goerli)`
        }
      )) : alertUser(e2.messsage), await handleRejectPairing();
    } finally {
      setPairingLoading(!1);
    }
  }, "handleApprovePairing"), handleRejectPairing = /* @__PURE__ */ __name(async () => {
    setPairingLoading(!0), await (web3wallet == null ? void 0 : web3wallet.rejectSession({
      id: currentProposal.id,
      reason: U("USER_REJECTED_METHODS")
    })), onReject(), setPairingLoading(!1);
  }, "handleRejectPairing");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$9.connectionRequest, children: [
      t2("walletConnect.pairingRequest.title"),
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PairingContainer, { pairingMetadata }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$9.receiveAddress, children: [
      t2("accountInfo.address"),
      ": ",
      receiveAddress2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.buttonsContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, secondary: !0, onClick: handleRejectPairing, children: t2("walletConnect.pairingRequest.reject") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, primary: !0, onClick: handleApprovePairing, children: t2("walletConnect.pairingRequest.approve") })
    ] })
  ] });
}, "WCIncomingPairing"), container$1 = "_container_1h5wj_1", successIcon$1 = "_successIcon_1h5wj_7", successText$1 = "_successText_1h5wj_12", styles$8 = {
  container: container$1,
  successIcon: successIcon$1,
  successText: successText$1
}, WCSuccessPairing = /* @__PURE__ */ __name(({ accountCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles$8.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.successText, children: t2("walletConnect.pairingSuccess") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: () => route(`/account/${accountCode}/wallet-connect/dashboard`), children: t2("button.done") })
  ] });
}, "WCSuccessPairing"), contentContainer = "_contentContainer_1iwqe_1", styles$7 = {
  contentContainer
}, ConnectScreenWalletConnect = /* @__PURE__ */ __name(({
  code,
  accounts
}) => {
  var _a46;
  const [uri, setUri] = reactExports.useState(""), [status2, setStatus] = reactExports.useState("connect"), [loading2, setLoading] = reactExports.useState(!1), { web3wallet, isWalletInitialized, pair } = reactExports.useContext(WCWeb3WalletContext), [currentProposal, setCurrentProposal] = reactExports.useState(), { t: t2 } = useTranslation(), receiveAddresses = useLoad(getReceiveAddressList(code)), onSessionProposal = reactExports.useCallback(
    (proposal) => {
      setUri(""), setLoading(!1), setStatus("incoming_pairing"), setCurrentProposal(proposal);
    },
    []
  );
  reactExports.useEffect(() => {
    if (isWalletInitialized)
      return web3wallet == null || web3wallet.on("session_proposal", onSessionProposal), () => {
        web3wallet == null || web3wallet.off("session_proposal", onSessionProposal);
      };
  }, [onSessionProposal, isWalletInitialized, web3wallet]);
  const handleApprovePairingStates = /* @__PURE__ */ __name(() => {
    setStatus("success"), setUri(""), setCurrentProposal(void 0);
  }, "handleApprovePairingStates"), handleRejectPairingStates = /* @__PURE__ */ __name(() => {
    setStatus("connect"), setUri(""), setCurrentProposal(void 0);
  }, "handleRejectPairingStates"), handleConnect = /* @__PURE__ */ __name(async (uri2) => {
    if (uri2) {
      setLoading(!0);
      try {
        await pair({ uri: uri2 });
      } catch (err) {
        err.message.includes("Missing or invalid. pair()") ? alertUser(`${t2("walletConnect.connect.invalidPairingUri")}: ${uri2}`) : alertUser(err.message), setUri(""), setLoading(!1);
      }
    }
  }, "handleConnect");
  if (!receiveAddresses || !isWalletInitialized)
    return null;
  const accountName2 = ((_a46 = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a46.name) || "", receiveAddress2 = receiveAddresses[0].addresses[0].address;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { verticallyCentered: !0, fullscreen: !1, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          WCHeader,
          {
            accountName: accountName2,
            receiveAddress: receiveAddress2
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.contentContainer, children: [
          status2 === "connect" && /* @__PURE__ */ jsxRuntimeExports.jsx(
            WCConnectForm,
            {
              connectLoading: loading2,
              code,
              uri,
              onInputChange: setUri,
              onSubmit: async (uri2) => {
                await handleConnect(uri2);
              }
            }
          ),
          status2 === "incoming_pairing" && currentProposal && /* @__PURE__ */ jsxRuntimeExports.jsx(
            WCIncomingPairing,
            {
              currentProposal,
              pairingMetadata: currentProposal.params.proposer.metadata,
              receiveAddress: receiveAddress2,
              onApprove: handleApprovePairingStates,
              onReject: handleRejectPairingStates
            }
          ),
          status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(WCSuccessPairing, { accountCode: code })
        ] })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
}, "ConnectScreenWalletConnect"), container = "_container_1jggi_1", textDataContainer = "_textDataContainer_1jggi_16", receiveAddress$1 = "_receiveAddress_1jggi_21", accountName$1 = "_accountName_1jggi_26", dAppMetadataAndIconContainer = "_dAppMetadataAndIconContainer_1jggi_33", dAppNameAndUrlContainer = "_dAppNameAndUrlContainer_1jggi_48", dappUrl = "_dappUrl_1jggi_54", accountNameAndWalletContainer = "_accountNameAndWalletContainer_1jggi_58", buttonAndIconContainer = "_buttonAndIconContainer_1jggi_63", buttonDisconnect = "_buttonDisconnect_1jggi_69", styles$6 = {
  container,
  textDataContainer,
  receiveAddress: receiveAddress$1,
  accountName: accountName$1,
  dAppMetadataAndIconContainer,
  dAppNameAndUrlContainer,
  dappUrl,
  accountNameAndWalletContainer,
  buttonAndIconContainer,
  buttonDisconnect
}, TextData = /* @__PURE__ */ __name(({ accountName: accountName2, receiveAddress: receiveAddress2, dAppName, dAppUrl, iconUrl }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.textDataContainer, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.accountNameAndWalletContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} hide-on-small`, children: receiveAddress2 })
  ] }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} show-on-small`, children: receiveAddress2 }),
  /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppMetadataAndIconContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppNameAndUrlContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: dAppName }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.dappUrl, children: dAppUrl })
    ] }),
    iconUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "hide-on-small", src: iconUrl, alt: "dApp icon" })
  ] })
] }), "TextData"), WCSessionCard = /* @__PURE__ */ __name(({ metadata: metadata2, receiveAddress: receiveAddress2, onDisconnect }) => {
  const { t: t2 } = useTranslation(), { name, url, icons } = metadata2, accountDetail = useLoad(() => getEthAccountCodeAndNameByAddress(receiveAddress2), []), truncatedAddress = truncateAddress(receiveAddress2), accountName2 = accountDetail && accountDetail.success ? accountDetail.name : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextData,
      {
        accountName: accountName2,
        receiveAddress: truncatedAddress,
        dAppName: name,
        dAppUrl: url,
        iconUrl: icons[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.buttonAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "show-on-small", src: icons[0], alt: "logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$6.buttonDisconnect, onClick: onDisconnect, danger: !0, children: t2("settings.electrum.remove-server") })
    ] })
  ] });
}, "WCSessionCard"), buttonNewConnection = "_buttonNewConnection_13so1_1", headerContainer = "_headerContainer_13so1_5", receiveAddress = "_receiveAddress_13so1_16", noConnectedSessions = "_noConnectedSessions_13so1_22", separator = "_separator_13so1_30", sessionCardsContainer = "_sessionCardsContainer_13so1_37", allSessionsHeading = "_allSessionsHeading_13so1_42", styles$5 = {
  buttonNewConnection,
  headerContainer,
  receiveAddress,
  noConnectedSessions,
  separator,
  sessionCardsContainer,
  allSessionsHeading
}, DashboardWalletConnect = /* @__PURE__ */ __name(({ code, accounts }) => {
  var _a46;
  const { t: t2 } = useTranslation(), { web3wallet, isWalletInitialized, initializeWeb3Wallet } = reactExports.useContext(WCWeb3WalletContext), [sessions, setSessions] = reactExports.useState(), receiveAddresses = useLoad(getReceiveAddressList(code)), updateSessions = reactExports.useCallback(() => {
    const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || []);
    setSessions(activeSessions);
  }, [web3wallet]);
  reactExports.useEffect(() => {
    if (!web3wallet) {
      initializeWeb3Wallet();
      return;
    }
    updateSessions();
  }, [initializeWeb3Wallet, updateSessions, web3wallet]), reactExports.useEffect(() => {
    if (isWalletInitialized)
      return web3wallet == null || web3wallet.on("session_delete", updateSessions), () => {
        web3wallet == null || web3wallet.off("session_delete", updateSessions);
      };
  }, [isWalletInitialized, updateSessions, web3wallet]);
  const handleDisconnectSession = /* @__PURE__ */ __name(async (topic) => {
    await (web3wallet == null ? void 0 : web3wallet.disconnectSession({
      topic,
      reason: U("USER_DISCONNECTED")
    })), updateSessions();
  }, "handleDisconnectSession");
  if (!receiveAddresses || !isWalletInitialized)
    return null;
  const receiveAddress2 = truncateAddress(receiveAddresses[0].addresses[0].address), accountName2 = ((_a46 = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a46.name) || "", hasSession = sessions && sessions.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Status,
        {
          type: "info",
          dismissible: "walletConnectDisclaimerDismissed",
          children: t2("walletConnect.dashboard.disclaimer")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SharedHeader,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("walletConnect.walletConnect") })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: accountName2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.receiveAddress, children: receiveAddress2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$5.buttonNewConnection, onClick: () => route(`/account/${code}/wallet-connect/connect`), primary: !0, children: t2("walletConnect.dashboard.newConnection") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: styles$5.separator }),
        hasSession && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.sessionCardsContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.allSessionsHeading, children: t2("walletConnect.dashboard.allSessions") }),
          sessions.map(
            (session) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCSessionCard,
              {
                receiveAddress: getAddressFromEIPString(session.namespaces.eip155.accounts[0]),
                metadata: session.peer.metadata,
                onDisconnect: () => handleDisconnectSession(session.topic)
              },
              session.topic
            )
          )
        ] }),
        !hasSession && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.noConnectedSessions, children: t2("walletConnect.dashboard.noConnectedSessions") })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
}, "DashboardWalletConnect"), InjectParams = /* @__PURE__ */ __name(({ children: children2 }) => {
  const params = useParams();
  return React.cloneElement(children2, params);
}, "InjectParams"), AppRouter = /* @__PURE__ */ __name(({ devices, deviceIDs, devicesKey, accounts, activeAccounts }) => {
  const hasAccounts = accounts.length > 0, Homepage = /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch-default")
  ), Device2 = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch")
  ) }), Acc = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Account,
    {
      code: "",
      devices,
      accounts: activeAccounts
    }
  ) }), AccountsSummaryEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AccountsSummary,
    {
      devices,
      accounts: activeAccounts
    }
  ) }), AccSend = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SendWrapper,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) }), AccReceive = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Receive,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) }), AccInfo = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Info,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), AccDashboardWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DashboardWalletConnect,
    {
      accounts: activeAccounts,
      code: ""
    }
  ) }), AccConnectScreenWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ConnectScreenWalletConnect,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), BuyInfoEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BuyInfo,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), MoonpayEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Moonpay,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), ExchangeEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Exchange,
    {
      code: "",
      accounts: activeAccounts
    }
  ) }), PocketEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Pocket,
    {
      code: ""
    }
  ) }), PassphraseEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC$2, { deviceID: "" }) }), ManageBackupsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ManageBackups$1,
    {
      devices
    },
    devicesKey("manage-backups")
  ) }), MobileSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MobileSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AppearanceEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Appearance,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AboutEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    About,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), AdvancedSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdvancedSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) }), ReceiveAccountsSelectorEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReceiveAccountsSelector, { activeAccounts }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: Homepage }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account/:code", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: Acc }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "send", element: AccSend }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "receive", element: AccReceive }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "info", element: AccInfo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/connect", element: AccConnectScreenWC }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/dashboard", element: AccDashboardWC })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "add-account", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccount, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account-summary", element: AccountsSummaryEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "buy", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "info", element: BuyInfoEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: BuyInfoEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BuyInfoEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "moonpay/:code", element: MoonpayEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pocket/:code", element: PocketEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "exchange/:code", element: ExchangeEl })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-backups/:deviceID", element: ManageBackupsEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "accounts/select-receive", element: ReceiveAccountsSelectorEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "settings", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: !0, element: MobileSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appearance", element: AppearanceEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "about", element: AboutEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/:deviceID", element: Device2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/passphrase/:deviceID", element: PassphraseEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "advanced-settings", element: AdvancedSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "electrum", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumSettings, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-accounts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(
        HOC$3,
        {
          accounts,
          deviceIDs,
          hasAccounts
        },
        "manage-accounts"
      ) })
    ] })
  ] }) });
}, "AppRouter"), FirmwareUpgradeRequired = /* @__PURE__ */ __name(({
  deviceID,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SharedHeader, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        verticallyCentered: !0,
        textCenter: !0,
        width: "840px",
        withBottomBar: !0,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("upgradeFirmware.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FirmwareSetting,
            {
              asButton: !0,
              deviceID,
              versionInfo
            }
          ) }) })
        ]
      }
    )
  ] });
}, "FirmwareUpgradeRequired"), PasswordGestureVideo = "" + new URL("password-gestures.webm", import.meta.url).href, passwordGesturesWrapper = "_passwordGesturesWrapper_mvckk_1", passwordGestures = "_passwordGestures_mvckk_1", styles$4 = {
  passwordGesturesWrapper,
  passwordGestures
};
function isVideoPlaying(video) {
  return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
}
__name(isVideoPlaying, "isVideoPlaying");
function replayVideo(ref) {
  ref && !isVideoPlaying(ref) && (ref.muted = !0, ref.play());
}
__name(replayVideo, "replayVideo");
const PasswordEntry = /* @__PURE__ */ __name(() => {
  let ref = reactExports.createRef();
  return reactExports.useEffect(() => {
    ref.current && replayVideo(ref.current);
  }, [ref]), /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.passwordGesturesWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      autoPlay: !0,
      ref,
      className: styles$4.passwordGestures,
      loop: !0,
      muted: !0,
      height: "338",
      width: "600",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: PasswordGestureVideo, type: "video/webm" })
    }
  ) });
}, "PasswordEntry"), Unlock = /* @__PURE__ */ __name(({ attestation }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "690px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("button.unlock"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepConnected.unlock") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: attestation === !1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { children: t2("bitbox02Wizard.attestationFailed") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
}, "Unlock"), Pairing = /* @__PURE__ */ __name(({
  attestation,
  deviceID,
  pairingFailed
}) => {
  const { t: t2 } = useTranslation(), [hash2, setHash] = reactExports.useState(""), [deviceVerified, setDeviceVerified] = reactExports.useState(!1), onChannelHashChanged = reactExports.useCallback(() => {
    getChannelHash(deviceID).then(({ hash: hash22, deviceVerified: deviceVerified2 }) => {
      setHash(hash22), setDeviceVerified(deviceVerified2);
    });
  }, [deviceID]);
  return reactExports.useEffect(onChannelHashChanged, [deviceID, onChannelHashChanged]), reactExports.useEffect(() => channelHashChanged(deviceID, onChannelHashChanged), [deviceID, onChannelHashChanged]), /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "670px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.pairing.title"), children: pairingFailed ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: t2("bitbox02Wizard.pairing.failed") }, "pairingFailed") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(deviceVerified ? "bitbox02Wizard.pairing.paired" : "bitbox02Wizard.pairing.unpaired") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { fullWidth: !0, children: [
          attestation === !1 && !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", className: "m-bottom-half", children: t2("bitbox02Wizard.attestationFailed") }),
          !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: hash2 }),
            !deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: !pairingFailed && deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: () => verifyChannelHash(deviceID, !0),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  );
}, "Pairing"), Wait = /* @__PURE__ */ __name(({ title: title2, text: text2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      width: "720px",
      verticallyCentered: !0,
      textCenter: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: title2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text2 || t2("bitbox02Interact.followInstructions") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
      ]
    }
  );
}, "Wait"), toggle = "_toggle_1lt1t_1", toggleLabel = "_toggleLabel_1lt1t_7", textIcon = "_textIcon_1lt1t_14", style$5 = {
  toggle,
  toggleLabel,
  textIcon
}, SetupOptions = /* @__PURE__ */ __name(({
  onSelectSetup,
  versionInfo
}) => {
  const { t: t2 } = useTranslation(), [advanced, setAdvanced] = reactExports.useState(!1), [withMnemonic, setWithMnemonic] = reactExports.useState(!1), [with12Words, setWith12Words] = reactExports.useState(!1);
  if (advanced) {
    const {
      canBackupWithRecoveryWords,
      // supported with firmware v9.13.0
      canCreate12Words
      // supported with firmware v9.6.0
    } = versionInfo;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: !0,
        textCenter: !0,
        verticallyCentered: !0,
        withBottomBar: !0,
        width: "1100px",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("seed.create") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", textAlign: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("bitbox02Wizard.advanced.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-mnemonic",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canBackupWithRecoveryWords && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.skipSDCardLabel") }),
                      " ",
                      !canBackupWithRecoveryWords && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: withMnemonic,
                    disabled: !canBackupWithRecoveryWords,
                    id: "with-mnemonic",
                    onChange: () => setWithMnemonic(!withMnemonic)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.skipSDCardText") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-12words",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canCreate12Words && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.seed12WordLabel") }),
                      " ",
                      !canCreate12Words && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: with12Words,
                    disabled: !canCreate12Words,
                    id: "with-12words",
                    onChange: () => setWith12Words(!with12Words)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.seed12WordText") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
                t2("bitbox02Wizard.advanced.seed12WordInfo")
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { inline: !0, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic,
                    with12Words
                  }),
                  primary: !0,
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setWithMnemonic(!1), setWith12Words(!1), setAdvanced(!1);
                  },
                  secondary: !0,
                  children: t2("button.back")
                }
              )
            ] })
          ] }) }) })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "1100px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("bitbox02Wizard.stepUninitialized.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
          t2("bitbox02Wizard.initialize.tip")
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: !0,
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic: !1,
                    with12Words: !1
                  }),
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => setAdvanced(!0),
                  style: { border: "none", marginTop: "var(--space-half)", height: "1.5rem" },
                  transparent: !0,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.button") })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: !0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-sdcard"),
                  secondary: !0,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMicroSD")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-mnemonic"),
                  style: { marginBottom: "40px" },
                  secondary: !0,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMnemonic")
                }
              )
            ] })
          ] })
        ] }) })
      ]
    }
  );
}, "SetupOptions"), wizardCheckbox = "_wizardCheckbox_1shxj_2", style$4 = {
  wizardCheckbox
}, ChecklistWalletCreate = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation(), [agree1, setAgree1] = reactExports.useState(!1), [agree2, setAgree2] = reactExports.useState(!1), [agree3, setAgree3] = reactExports.useState(!1), [agree4, setAgree4] = reactExports.useState(!1), [agree5, setAgree5] = reactExports.useState(!1), handleContinue = /* @__PURE__ */ __name(() => {
    setAgree1(!1), setAgree2(!1), setAgree3(!1), setAgree4(!1), setAgree5(!1), onContinue();
  }, "handleContinue");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackup") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
}, "ChecklistWalletCreate"), ChecklistWalletCreateMnemonic = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation(), [agree1, setAgree1] = reactExports.useState(!1), [agree2, setAgree2] = reactExports.useState(!1), [agree3, setAgree3] = reactExports.useState(!1), [agree4, setAgree4] = reactExports.useState(!1), [agree5, setAgree5] = reactExports.useState(!1), handleContinue = /* @__PURE__ */ __name(() => {
    setAgree1(!1), setAgree2(!1), setAgree3(!1), setAgree4(!1), setAgree5(!1), onContinue();
  }, "handleContinue");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackupMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5mnemonic")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: !0,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
}, "ChecklistWalletCreateMnemonic"), wizardLabel = "_wizardLabel_11dvu_2", style$3 = {
  wizardLabel
}, SetDeviceName = /* @__PURE__ */ __name(({
  onDeviceName,
  onBack,
  missingSDCardWarning
}) => {
  const { t: t2 } = useTranslation(), [deviceName, setDeviceName2] = reactExports.useState(""), handleDeviceNameInput = /* @__PURE__ */ __name((event2) => {
    const value = event2.target.value;
    setDeviceName2(value);
  }, "handleDeviceNameInput");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "form",
    {
      onSubmit: (event2) => {
        event2.preventDefault(), onDeviceName(deviceName);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: !0,
          textCenter: !0,
          withBottomBar: !0,
          verticallyCentered: !0,
          width: "600px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepCreate.title"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreate.description") }),
              missingSDCardWarning && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { className: "m-bottom-half", type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitbox02Wizard.stepCreate.toastMicroSD") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { minHeight: "90px", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: !0,
                className: style$3.wizardLabel,
                label: t2("bitbox02Wizard.stepCreate.nameLabel"),
                pattern: "^.{0,63}$",
                onInput: handleDeviceNameInput,
                placeholder: t2("bitbox02Wizard.stepCreate.namePlaceholder"),
                value: deviceName,
                id: "deviceName"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: !deviceName,
                  primary: !0,
                  type: "submit",
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onBack,
                  secondary: !0,
                  type: "button",
                  children: t2("button.back")
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, "SetDeviceName"), SetDeviceNameWithSDCard = /* @__PURE__ */ __name(({
  deviceID,
  onDeviceName,
  onBack
}) => {
  const [hasSDCard, setSDCard] = reactExports.useState();
  return reactExports.useEffect(() => {
    checkSDCard(deviceID).then(setSDCard);
  }, [deviceID]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    SetDeviceName,
    {
      onDeviceName,
      onBack,
      missingSDCardWarning: hasSDCard === !1
    }
  );
}, "SetDeviceNameWithSDCard"), SetPassword = /* @__PURE__ */ __name(({ errorText: errorText2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "600px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepPassword.title"), children: [
          errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorText2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
}, "SetPassword"), SetPasswordWithBackup = /* @__PURE__ */ __name(({
  forBackup
}) => {
  const { i18n, t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle"), children: forBackup ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "div", markup: t2("backup.restore.selectedBackup", {
            backupName: forBackup.name,
            createdDateTime: convertDateToLocaleString(forBackup.date, i18n.language)
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-small text-ellipsis", children: [
            "ID:",
            " ",
            forBackup.id
          ] })
        ] }) : null }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {})
        ] })
      ]
    }
  );
}, "SetPasswordWithBackup"), WithSDCard = /* @__PURE__ */ __name(({
  children: children2,
  deviceID
}) => {
  const { t: t2 } = useTranslation(), [hasSDCard, setSDCard] = reactExports.useState(), ensureSDCard = reactExports.useCallback(async () => {
    try {
      const sdCardInserted = await checkSDCard(deviceID);
      if (setSDCard(sdCardInserted), sdCardInserted)
        return;
      const result = await insertSDCard(deviceID);
      if (setSDCard(result.success), result.success)
        return;
      result.message && alertUser(result.message, { asDialog: !1 });
    } catch (error3) {
      console.error(error3);
    }
  }, [deviceID]);
  return reactExports.useEffect(() => {
    ensureSDCard();
  }, [ensureSDCard]), hasSDCard ? children2 : hasSDCard === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: !0, textCenter: !0, verticallyCentered: !0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: "Checking microSD card" }) }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Wizard.stepInsertSD.insertSDcardTitle"),
      text: t2("bitbox02Wizard.stepInsertSD.insertSDCard")
    }
  );
}, "WithSDCard"), CreateWallet = /* @__PURE__ */ __name(({
  backupType,
  backupSeedLength,
  deviceID,
  isSeeded,
  onAbort
}) => {
  const { t: t2 } = useTranslation(), isMounted = useMountedRef(), [status2, setStatus] = reactExports.useState("intro"), [errorText2, setErrorText] = reactExports.useState(""), ensurePassword = /* @__PURE__ */ __name(async () => {
    setStatus("setPassword");
    try {
      const result = await setPassword(deviceID, backupSeedLength);
      if (!result.success) {
        result.code === errUserAbort ? (alertUser(t2("bitbox02Wizard.stepPassword.e104"), {
          asDialog: !1,
          callback: () => onAbort()
        }), setErrorText("")) : (setErrorText(t2("bitbox02Wizard.noPasswordMatch")), isMounted.current && ensurePassword());
        return;
      }
      setErrorText(""), setStatus("showDisclaimer");
    } catch (error3) {
      console.error(error3);
    }
  }, "ensurePassword"), setDeviceName$1 = /* @__PURE__ */ __name(async (deviceName) => {
    setStatus("setName");
    try {
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText22 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText22 || t2("genericError"), {
          asDialog: !1,
          callback: () => onAbort()
        });
        return;
      }
      ensurePassword();
    } catch (error3) {
      console.error(error3);
    }
  }, "setDeviceName$1"), createBackup$1 = /* @__PURE__ */ __name(async () => {
    setStatus("createBackup");
    try {
      const result = await createBackup(
        deviceID,
        backupType === "mnemonic" ? "recovery-words" : "sdcard"
      );
      result.success || (result.code === errUserAbort ? alertUser(t2("bitbox02Wizard.createBackupAborted"), {
        asDialog: !1,
        callback: () => onAbort()
      }) : alertUser(t2("bitbox02Wizard.createBackupFailed"), { asDialog: !1 }));
    } catch (error3) {
      console.error(error3);
    }
  }, "createBackup$1");
  if (isSeeded) {
    if (status2 === "showDisclaimer")
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreate, { onContinue: createBackup$1 }) });
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreateMnemonic, { onContinue: createBackup$1 });
      }
    if (status2 === "createBackup")
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmDate"),
              text: t2("bitbox02Interact.confirmDateText")
            }
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmWords", {
                amount: backupSeedLength === 16 ? "12" : "24"
              }),
              text: t2("bitbox02Interact.confirmWordsText")
            }
          );
      }
  }
  switch (status2) {
    case "intro":
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceNameWithSDCard,
            {
              deviceID,
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-sdcard"
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceName,
            {
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-mnemonic"
          );
      }
      break;
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetPassword,
        {
          errorText: errorText2
        }
      );
    default:
      return null;
  }
}, "CreateWallet"), RestoreFromSDCardBackup = /* @__PURE__ */ __name(({
  deviceID,
  onSelectBackup,
  onRestoreBackup,
  onBack
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID,
            showRestore: !0,
            showRadio: !0,
            onSelectBackup,
            onRestoreBackup,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: !0,
                onClick: onBack,
                children: t2("button.back")
              }
            )
          }
        ) })
      ]
    }
  );
}, "RestoreFromSDCardBackup"), RestoreFromSDCard = /* @__PURE__ */ __name(({
  deviceID,
  onAbort
}) => {
  const [status2, setStatus] = reactExports.useState("restore"), [backup2, setBackup] = reactExports.useState(), onSelectBackup = /* @__PURE__ */ __name((backup22) => {
    setStatus("setPassword"), setBackup(backup22);
  }, "onSelectBackup"), onRestoreBackup = /* @__PURE__ */ __name((success2) => {
    if (!success2) {
      onAbort();
      return;
    }
    setBackup(void 0);
  }, "onRestoreBackup");
  switch (status2) {
    case "restore":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCardBackup,
        {
          deviceID,
          onSelectBackup,
          onRestoreBackup,
          onBack: onAbort
        }
      ) });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SetPasswordWithBackup, { forBackup: backup2 });
  }
}, "RestoreFromSDCard"), RestoreFromMnemonic = /* @__PURE__ */ __name(({
  deviceID,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  return reactExports.useEffect(() => {
    restoreFromMnemonic(deviceID).then((result) => {
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Wizard.restoreFromMnemonic.e104") : t2("bitbox02Wizard.restoreFromMnemonic.failed");
        alertUser(errorText2, {
          asDialog: !1,
          callback: () => onAbort()
        });
      }
    }).catch(console.error);
  }, [deviceID, onAbort, t2]), /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Interact.followInstructionsMnemonicTitle"),
      text: t2("bitbox02Interact.followInstructionsMnemonic")
    }
  );
}, "RestoreFromMnemonic"), CreateWalletSuccess = /* @__PURE__ */ __name(({
  backupType,
  onContinue
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: !0,
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.success.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.success") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { withIcon: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2(backupType === "sdcard" ? "bitbox02Wizard.stepCreateSuccess.removeMicroSD" : "bitbox02Wizard.stepCreateSuccess.storeMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "CreateWalletSuccess"), RestoreFromSDCardSuccess = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "RestoreFromSDCardSuccess"), RestoreFromMnemonicSuccess = /* @__PURE__ */ __name(({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5mnemonic") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
}, "RestoreFromMnemonicSuccess"), _Wizard = class _Wizard extends reactExports.Component {
  constructor(props) {
    super(props), this.unsubscribeList = [], this.updateAttestationCheck = () => {
      verifyAttestation(this.props.deviceID).then((attestation) => {
        this.setState({ attestation });
      });
    }, this.handleGetStarted = () => {
      this.setState({ status: "" }), route("/account-summary", !0);
    }, this.onStatusChanged = () => {
      const { showWizard, unlockOnly } = this.state;
      getStatus$1(this.props.deviceID).then((status2) => {
        !showWizard && ["connected", "unpaired", "pairingFailed", "uninitialized", "seeded"].includes(status2) && this.setState({ showWizard: !0 }), unlockOnly && ["uninitialized", "seeded"].includes(status2) && this.setState({ unlockOnly: !1 }), this.setState({ status: status2 });
      });
    }, this.handleAbort = () => {
      this.setState({
        appStatus: "",
        createOptions: void 0
      });
    }, this.state = {
      attestation: null,
      status: "",
      appStatus: "",
      unlockOnly: !0,
      showWizard: !1,
      waitDialog: void 0
    };
  }
  componentDidMount() {
    const { deviceID } = this.props;
    getVersion(deviceID).then((versionInfo) => {
      this.setState({ versionInfo });
    }), this.updateAttestationCheck(), this.onStatusChanged(), this.unsubscribeList = [
      statusChanged(deviceID, this.onStatusChanged),
      attestationCheckDone(deviceID, this.updateAttestationCheck)
    ];
  }
  componentWillUnmount() {
    unsubscribe(this.unsubscribeList);
  }
  render() {
    const { deviceID } = this.props, {
      attestation,
      createOptions,
      versionInfo,
      status: status2,
      appStatus,
      unlockOnly,
      showWizard,
      waitDialog
    } = this.state;
    return status2 === "" || !versionInfo ? null : status2 === "require_firmware_upgrade" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      FirmwareUpgradeRequired,
      {
        deviceID,
        versionInfo
      }
    ) : status2 === "require_app_upgrade" ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {}) : showWizard ? waitDialog ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Wait,
      {
        title: waitDialog.title,
        text: waitDialog.text
      },
      "wait-view"
    ) : appStatus === "" && status2 === "initialized" ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "connected" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Unlock,
        {
          attestation
        },
        "unlock"
      ) : null,
      (status2 === "unpaired" || status2 === "pairingFailed") && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Pairing,
        {
          deviceID,
          attestation,
          pairingFailed: status2 === "pairingFailed"
        },
        "pairing"
      ),
      !unlockOnly && appStatus === "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetupOptions,
        {
          versionInfo,
          onSelectSetup: (type2, createOptions2) => this.setState({ appStatus: type2, createOptions: createOptions2 })
        },
        "choose-setup"
      ),
      !unlockOnly && appStatus === "create-wallet" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        CreateWallet,
        {
          backupType: createOptions != null && createOptions.withMnemonic ? "mnemonic" : "sdcard",
          backupSeedLength: createOptions != null && createOptions.with12Words ? 16 : 32,
          deviceID,
          isSeeded: status2 === "seeded",
          onAbort: this.handleAbort
        }
      ),
      !unlockOnly && appStatus === "restore-sdcard" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCard,
        {
          deviceID,
          onAbort: this.handleAbort
        },
        "restore-sdcard"
      ),
      !unlockOnly && appStatus === "restore-mnemonic" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromMnemonic,
        {
          deviceID,
          onAbort: this.handleAbort
        },
        "restore-mnemonic"
      ),
      appStatus === "create-wallet" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
        CreateWalletSuccess,
        {
          backupType: createOptions != null && createOptions.withMnemonic ? "mnemonic" : "sdcard",
          onContinue: this.handleGetStarted
        },
        "success"
      ),
      appStatus === "restore-sdcard" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromSDCardSuccess, { onContinue: this.handleGetStarted }, "backup-success"),
      appStatus === "restore-mnemonic" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromMnemonicSuccess, { onContinue: this.handleGetStarted }, "backup-mnemonic-success")
    ] }) : null;
  }
};
__name(_Wizard, "Wizard");
let Wizard = _Wizard;
const syncNewTxs = /* @__PURE__ */ __name((cb2) => subscribe$1("newTxs", (event2) => {
  event2.type === "backend" && cb2(event2.meta);
}), "syncNewTxs"), _ConnectedApp = class _ConnectedApp extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      connected: !0
    };
  }
  componentDidMount() {
    this.unsubscribe = backendConnected((connected) => this.setState({ connected }));
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  render() {
    const { children: children2 } = this.props, { connected } = this.state;
    return connected ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: children2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", style: { padding: 40 }, children: "The WebSocket closed. Please restart the backend and reload this page." });
  }
};
__name(_ConnectedApp, "ConnectedApp");
let ConnectedApp = _ConnectedApp;
const cancel = /* @__PURE__ */ __name(() => apiPost("aopp/cancel"), "cancel"), approve = /* @__PURE__ */ __name(() => apiPost("aopp/approve"), "approve"), chooseAccount = /* @__PURE__ */ __name((accountCode) => apiPost("aopp/choose-account", { accountCode }), "chooseAccount");
function subscribe(endpointsObjectOrFunction, renderOnlyOnceLoaded = !0, subscribeWithoutLoading = !1) {
  return /* @__PURE__ */ __name(function(WrappedComponent) {
    var _a47;
    var _a46;
    return _a46 = (_a47 = class extends reactExports.Component {
      constructor() {
        super(...arguments), this.subscriptions = {}, this.component = subscribeWithoutLoading ? WrappedComponent : load(endpointsObjectOrFunction, renderOnlyOnceLoaded)(WrappedComponent);
      }
      determineEndpoints() {
        return typeof endpointsObjectOrFunction == "function" ? endpointsObjectOrFunction(this.props) : endpointsObjectOrFunction;
      }
      unsubscribeEndpoint(key) {
        const subscription = this.subscriptions[key];
        subscription !== void 0 && (subscription(), delete this.subscriptions[key], (subscribeWithoutLoading || !renderOnlyOnceLoaded) && this.setState({ [key]: void 0 }));
      }
      subscribeEndpoint(key, endpoint) {
        this.unsubscribeEndpoint(key), this.subscriptions[key] = apiSubscribe(endpoint, (event2) => {
          switch (event2.action) {
            case "replace":
              this.setState({ [key]: event2.object });
              break;
            case "reload":
              apiGet(event2.subject).then((object) => this.setState({ [key]: object }));
              break;
          }
        });
      }
      subscribeEndpoints() {
        const oldEndpoints = this.endpoints, newEndpoints = this.determineEndpoints();
        for (const key of Object.keys(newEndpoints))
          (oldEndpoints === void 0 || newEndpoints[key] !== oldEndpoints[key]) && this.subscribeEndpoint(key, newEndpoints[key]);
        if (oldEndpoints !== void 0)
          for (const key of Object.keys(oldEndpoints))
            newEndpoints[key] === void 0 && (this.unsubscribeEndpoint(key), this.setState({ [key]: void 0 }));
        this.endpoints = newEndpoints;
      }
      componentDidMount() {
        this.subscribeEndpoints();
      }
      componentDidUpdate() {
        this.subscribeEndpoints();
      }
      componentWillUnmount() {
        for (const key of Object.keys(this.subscriptions))
          this.unsubscribeEndpoint(key);
      }
      render() {
        const props = this.props, state = this.state, Component2 = this.component;
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Component2, { ...state, ...props });
      }
    }, __name(_a47, "_a"), _a47), _a46.displayName = `Subscribe(${getDisplayName(WrappedComponent)})`, _a46;
  }, "decorator");
}
__name(subscribe, "subscribe");
const isArray = Array.isArray, keyList = Object.keys, hasProp = Object.prototype.hasOwnProperty;
function equal(a2, b2) {
  if (Object.is(a2, b2))
    return !0;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    let arrA = isArray(a2), arrB = isArray(b2), i, length2, key;
    if (arrA && arrB) {
      if (length2 = a2.length, length2 !== b2.length)
        return !1;
      for (i = 0; i < length2; i++)
        if (!equal(a2[i], b2[i]))
          return !1;
      return !0;
    }
    if (arrA !== arrB)
      return !1;
    let keys = keyList(a2);
    if (length2 = keys.length, length2 !== keyList(b2).length)
      return !1;
    for (i = 0; i < length2; i++)
      if (!hasProp.call(b2, keys[i]))
        return !1;
    for (i = 0; i < length2; i++)
      if (key = keys[i], !equal(a2[key], b2[key]))
        return !1;
    return !0;
  }
  return !1;
}
__name(equal, "equal");
const VerifyAddress = /* @__PURE__ */ __name(({ accountCode, address: address2, addressID }) => {
  const [verifying, setVerifying] = reactExports.useState(!1), { t: t2 } = useTranslation(), verifyAddress2 = /* @__PURE__ */ __name(async () => {
    setVerifying(!0), await verifyAddress$1(accountCode, addressID), setVerifying(!1);
  }, "verifyAddress");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: verifyAddress2, children: t2("receive.verifyBitBox02") }),
    verifying ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("receive.verifyBitBox02"), children: address2 }) : null
  ] });
}, "VerifyAddress"), logo = "_logo_rqpye_1", prominent = "_prominent_rqpye_9", hostname = "_hostname_rqpye_22", capitalized = "_capitalized_rqpye_31", styles$3 = {
  logo,
  prominent,
  hostname,
  capitalized
}, AOPPGroupLogo = "" + new URL("aoppgroup.svg", import.meta.url).href, BitcoinSuisseLogo = "" + new URL("bitcoin_suisse.png", import.meta.url).href, BittrLogo = "" + new URL("bittr.png", import.meta.url).href, BityLogo = "" + new URL("bity.png", import.meta.url).href, PocketBitcoinLogo = "" + new URL("pocketbitcoin.svg", import.meta.url).href, VASPLogoMap = {
  "demo.aopp.group": AOPPGroupLogo,
  "testing.aopp.group": AOPPGroupLogo,
  "bitcoinsuisse.com": BitcoinSuisseLogo,
  "bity.com": BityLogo,
  "getbittr.com": BittrLogo,
  "pocketbitcoin.com": PocketBitcoinLogo
}, VASPHostnameMap = {
  "demo.aopp.group": "AOPP.group",
  "testing.aopp.group": "AOPP.group"
}, Vasp = /* @__PURE__ */ __name(({
  fallback,
  hostname: hostname2,
  prominent: prominent2,
  withLogoText
}) => {
  if (!(hostname2 in VASPLogoMap))
    return fallback || /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$3.hostname, children: hostname2 });
  const logoClasses = prominent2 ? `${styles$3.logo} ${styles$3.prominent}` : styles$3.logo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: logoClasses, src: VASPLogoMap[hostname2], alt: hostname2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$3.hostname} ${styles$3.capitalized}`, children: hostname2 in VASPHostnameMap ? VASPHostnameMap[hostname2] : hostname2 }),
    withLogoText ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: withLogoText }) : null
  ] });
}, "Vasp"), banner = "_banner_yebbr_1", smallIcon = "_smallIcon_yebbr_10", successText = "_successText_yebbr_15", proceed = "_proceed_yebbr_28", message = "_message_yebbr_33", styles$2 = {
  banner,
  smallIcon,
  successText,
  proceed,
  message
}, Banner$1 = /* @__PURE__ */ __name(({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.banner, children: children2 }), "Banner$1"), domain = /* @__PURE__ */ __name((callback2) => new URL(callback2).host, "domain"), _Aopp = class _Aopp extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      accountCode: ""
    }, this.chooseAccount = (e2) => {
      this.state.accountCode && chooseAccount(this.state.accountCode), e2.preventDefault();
    };
  }
  componentDidMount() {
    this.setAccountCodeDefault();
  }
  componentDidUpdate(prevProps) {
    var _a46;
    this.props.aopp !== void 0 && this.props.aopp.state === "choosing-account" && (((_a46 = prevProps.aopp) == null ? void 0 : _a46.state) !== "choosing-account" || !equal(this.props.aopp.accounts, prevProps.aopp.accounts)) && this.setAccountCodeDefault();
  }
  setAccountCodeDefault() {
    const { aopp: aopp2 } = this.props;
    aopp2 === void 0 || aopp2.state !== "choosing-account" || aopp2.accounts.length && this.setState({ accountCode: aopp2.accounts[0].code });
  }
  render() {
    const { t: t2, aopp: aopp2 } = this.props, { accountCode } = this.state;
    if (!aopp2)
      return null;
    switch (aopp2.state) {
      case "error":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.errorTitle"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "error", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$2.smallIcon }),
                t2(`error.${aopp2.errorCode}`, { host: domain(aopp2.callback) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: !0, onClick: cancel, children: t2("button.dismiss") }) })
            ]
          }
        );
      case "inactive":
        return null;
      case "user-approval":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), withAppLogo: !0 }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Vasp,
                {
                  prominent: !0,
                  hostname: domain(aopp2.callback),
                  fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("aopp.addressRequest", {
                    host: `<strong>${domain(aopp2.callback)}</strong>`
                  }) }),
                  withLogoText: t2("aopp.addressRequestWithLogo")
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: approve, children: t2("button.continue") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        );
      case "awaiting-keystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Banner$1, { children: t2("aopp.banner") });
      case "choosing-account": {
        const options2 = aopp2.accounts.map((account2) => ({
          text: account2.name,
          value: account2.code
        }));
        return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: this.chooseAccount, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  label: t2("buy.info.selectLabel"),
                  options: options2,
                  value: accountCode,
                  onChange: (e2) => {
                    var _a46;
                    return this.setState({ accountCode: (_a46 = e2.target) == null ? void 0 : _a46.value });
                  },
                  id: "account"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, type: "submit", children: t2("button.next") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        ) });
      }
      case "syncing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.syncing") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: cancel, children: t2("dialog.cancel") }) })
            ]
          }
        );
      case "signing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.signing") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: !0, flexibleHeight: !0, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
              ] })
            ]
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fitContent: !0,
            fullscreen: !0,
            textCenter: !0,
            verticallyCentered: !0,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { withIcon: "success", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.successText, children: t2("aopp.success.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.proceed, children: t2("aopp.success.message", { host: domain(aopp2.callback) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: !0, flexibleHeight: !0, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { style: { marginBottom: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: !0, onClick: cancel, children: t2("button.done") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VerifyAddress,
                  {
                    accountCode: aopp2.accountCode,
                    address: aopp2.address,
                    addressID: aopp2.addressID
                  }
                )
              ] })
            ]
          }
        );
    }
  }
};
__name(_Aopp, "Aopp");
let Aopp = _Aopp;
const subscribeHOC = subscribe(
  { aopp: "aopp" },
  !1,
  !1
)(Aopp), translateHOC = translate()(subscribeHOC), getBanner = /* @__PURE__ */ __name((msgKey) => apiGet(`banners/${msgKey}`), "getBanner"), syncBanner = /* @__PURE__ */ __name((msgKey, cb2) => subscribeEndpoint(`banners/${msgKey}`, cb2), "syncBanner"), link$1 = "_link_4u2en_1", style$2 = {
  link: link$1
}, Banner = /* @__PURE__ */ __name(({ msgKey }) => {
  const { i18n, t: t2 } = useTranslation(), [banner2, setBanner] = reactExports.useState();
  if (reactExports.useEffect(() => {
    getBanner(msgKey).then(setBanner), syncBanner(msgKey, setBanner);
  }, [msgKey]), !banner2 || !i18n.options.fallbackLng)
    return null;
  const { message: message2, link: link2 } = banner2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Status,
    {
      dismissible: banner2.dismissible ? `banner-${msgKey}-${banner2.id}` : "",
      type: banner2.type ? banner2.type : "warning",
      children: [
        message2[i18n.resolvedLanguage] || message2[i18n.options.fallbackLng[0]],
        " ",
        link2 && /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: link2.href, className: style$2.link, children: link2.text || t2("clickHere") })
      ]
    }
  );
}, "Banner"), bitboxContainer = "_bitboxContainer_1nxo8_1", failed = "_failed_1nxo8_18", bitboxImage = "_bitboxImage_1nxo8_24", cancelIcon = "_cancelIcon_1nxo8_29", text = "_text_1nxo8_35", styles$1 = {
  bitboxContainer,
  failed,
  bitboxImage,
  cancelIcon,
  text
};
function KeystoreConnectPrompt() {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), [data, reset2] = useSubscribeReset(syncConnectKeystore());
  if (!data)
    return null;
  switch (data.typ) {
    case "connect":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: !0, open: !0, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$1.text, children: [
          data.keystoreName === "" ? t2("connectKeystore.promptNoName") : t2("connectKeystore.promptWithName", { name: data.keystoreName }),
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.bitboxContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => cancelConnectKeystore(), children: t2("dialog.cancel") }) })
      ] });
    case "error":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: !0, open: !0, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$1.text, children: data.errorCode === "wrongKeystore" ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t2("error.wrongKeystore"),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          t2("error.wrongKeystore2")
        ] }) : data.errorMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$1.bitboxContainer} ${styles$1.failed}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$1.cancelIcon }),
          isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: styles$1.bitboxImage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: styles$1.bitboxImage })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: !0, onClick: () => reset2(), children: t2("dialog.cancel") }) })
      ] });
    default:
      return null;
  }
}
__name(KeystoreConnectPrompt, "KeystoreConnectPrompt");
const getUsingMobileData = /* @__PURE__ */ __name(() => apiGet("using-mobile-data"), "getUsingMobileData"), subscribeUsingMobileData = /* @__PURE__ */ __name((cb2) => subscribeEndpoint("using-mobile-data", cb2), "subscribeUsingMobileData"), MobileDataWarning = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), isUsingMobileData = useSync(getUsingMobileData, subscribeUsingMobileData);
  return isUsingMobileData === void 0 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Status,
    {
      dismissible: "mobile-data-warning",
      type: "warning",
      hidden: !isUsingMobileData,
      children: t2("mobile.usingMobileDataWarning")
    }
  );
}, "MobileDataWarning"), link = "_link_13in7_1", style$1 = {
  link
}, Update = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), file = useLoad(getUpdate);
  return file ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Status, { dismissible: `update-${file.version}`, type: "info", children: [
    t2("app.upgrade", {
      current: file.current,
      version: file.version
    }),
    file.description,
    " ",
    !runningInAndroid() && /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadLink, { className: style$1.link })
  ] }) : null;
}, "Update"), setDarkTheme = /* @__PURE__ */ __name((isDark) => apiPost("set-dark-theme", isDark), "setDarkTheme"), detectDarkTheme = /* @__PURE__ */ __name(() => apiGet("detect-dark-theme"), "detectDarkTheme"), DarkModeProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [isDarkMode, setIsDarkMode] = reactExports.useState(!1), androidPrefersDarkMode = useMediaQuery("(prefers-color-scheme: dark)"), setAppTheme = reactExports.useCallback(() => {
    setDarkTheme(isDarkMode), isDarkMode ? (document.body.classList.add("dark-mode"), document.body.classList.remove("light-mode")) : (document.body.classList.remove("dark-mode"), document.body.classList.add("light-mode"));
  }, [isDarkMode]);
  reactExports.useEffect(() => {
    getConfig().then((config) => {
      if (config.frontend && "darkmode" in config.frontend) {
        setIsDarkMode(config.frontend.darkmode);
        return;
      }
      runningInAndroid() ? setIsDarkMode(androidPrefersDarkMode) : detectDarkTheme().then(setIsDarkMode);
    }).catch(console.error);
  }, [androidPrefersDarkMode]), reactExports.useEffect(() => {
    setAppTheme();
  }, [isDarkMode, setAppTheme]);
  const toggleDarkmode = /* @__PURE__ */ __name((darkmode2) => {
    setIsDarkMode(darkmode2), getConfig().then(async (config) => {
      let preferredDarkMode;
      if (runningInAndroid() ? preferredDarkMode = androidPrefersDarkMode : preferredDarkMode = await detectDarkTheme(), preferredDarkMode === darkmode2) {
        const { darkmode: darkmode22, ...frontend } = config.frontend;
        setConfig({
          frontend: {
            ...frontend,
            darkmode: void 0
          }
        });
      } else
        setConfig({
          frontend: {
            ...config.frontend,
            darkmode: darkmode2
          }
        });
    });
  }, "toggleDarkmode");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeContext.Provider, { value: { isDarkMode, toggleDarkmode }, children: children2 });
}, "DarkModeProvider"), AppProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [guideShown, setGuideShown] = reactExports.useState(!1), [guideExists, setGuideExists] = reactExports.useState(!1), [hideAmounts, setHideAmounts] = reactExports.useState(!1), toggleGuide = /* @__PURE__ */ __name(() => {
    setConfig({ frontend: { guideShown: !guideShown } }), setGuideShown((prev2) => !prev2);
  }, "toggleGuide"), toggleHideAmounts = /* @__PURE__ */ __name(() => {
    setConfig({ frontend: { hideAmounts: !hideAmounts } }), setHideAmounts((prev2) => !prev2);
  }, "toggleHideAmounts");
  return reactExports.useEffect(() => {
    getConfig().then(({ frontend }) => {
      frontend ? (frontend.guideShown !== void 0 && setGuideShown(frontend.guideShown), frontend.hideAmounts !== void 0 && setHideAmounts(frontend.hideAmounts)) : setGuideShown(!0);
    });
  }, []), /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppContext.Provider,
    {
      value: {
        toggleGuide,
        guideShown,
        guideExists,
        hideAmounts,
        setGuideShown,
        setGuideExists,
        toggleHideAmounts
      },
      children: children2
    }
  );
}, "AppProvider"), auth = "_auth_xdrxz_1", style = {
  auth
}, AuthRequired = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation(), [authRequired, setAuthRequired] = reactExports.useState(!1), [authenticating, setAuthenticating] = reactExports.useState(!1), authForced = reactExports.useRef(!1), newAuthentication = /* @__PURE__ */ __name(() => {
    setAuthenticating(!0), authenticate(authForced.current);
  }, "newAuthentication");
  return reactExports.useEffect(() => {
    const unsubscribe2 = subscribeAuth((data) => {
      switch (data.typ) {
        case "auth-forced":
          authForced.current = !0;
          break;
        case "auth-required":
          setAuthRequired((prevAuthRequired) => (prevAuthRequired || newAuthentication(), !0));
          break;
        case "auth-err":
          setAuthenticating(!1);
          break;
        case "auth-canceled":
          authForced.current ? (setAuthRequired(!1), authForced.current = !1) : setAuthenticating(!1);
          break;
        case "auth-ok":
          setAuthRequired(!1), authForced.current = !1;
      }
    });
    return setAuthRequired(!0), newAuthentication(), unsubscribe2;
  }, []), authRequired ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style.auth, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: !0,
      textCenter: !0,
      verticallyCentered: !0,
      withBottomBar: !0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: !0, title: t2("auth.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: void 0, minHeight: "0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: !0,
            primary: !0,
            hidden: authForced.current,
            disabled: authenticating,
            onClick: newAuthentication,
            children: t2("auth.authButton")
          }
        ) })
      ]
    }
  ) }) : null;
}, "AuthRequired"), WCWeb3WalletProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const { t: t2 } = useTranslation(), [web3wallet, setWeb3wallet] = reactExports.useState(), [isWalletInitialized, setIsWalletInitialized] = reactExports.useState(!1), config = useLoad(getConfig), hasUsedWC = config && config.frontend && config.frontend.hasUsedWalletConnect, initializeWeb3Wallet = /* @__PURE__ */ __name(async () => {
    try {
      const { Core } = await __vitePreload(() => import("./index.es.js").then((n2) => n2.l), [], import.meta.url), { Web3Wallet } = await __vitePreload(() => import("./index.es2.js"), [], import.meta.url), core2 = new Core({
        projectId: "89733df088867a1a1bf644013addd6cc"
      }), wallet = await Web3Wallet.init({
        core: core2,
        metadata: {
          name: "BitBox",
          description: "BitBox02 hardware wallet",
          url: "https://bitbox.swiss",
          icons: ["https://bitbox.swiss/assets/images/logos/dbb-logo.png"]
        }
      });
      setWeb3wallet(wallet), setIsWalletInitialized(!0);
    } catch (err) {
      console.log("Error for initializing", err);
    }
  }, "initializeWeb3Wallet");
  reactExports.useEffect(() => {
    !web3wallet && !isWalletInitialized && hasUsedWC && initializeWeb3Wallet();
  }, [isWalletInitialized, web3wallet, hasUsedWC]);
  const pair = /* @__PURE__ */ __name(async (params) => {
    if (web3wallet)
      try {
        const { uri } = params, topic = getTopicFromURI(uri);
        if (pairingHasEverBeenRejected(topic, web3wallet))
          throw new Error(t2("walletConnect.useNewUri"));
        await (web3wallet == null ? void 0 : web3wallet.core.pairing.pair({ uri })), setConfig({ frontend: { hasUsedWalletConnect: !0 } });
      } catch (e2) {
        throw console.error(`Wallet connect attempt to pair error ${e2}`), e2.message.includes("Pairing already exists") ? new Error(t2("walletConnect.useNewUri")) : new Error(e2.message);
      }
  }, "pair");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCWeb3WalletContext.Provider,
    {
      value: {
        initializeWeb3Wallet,
        isWalletInitialized,
        web3wallet,
        pair
      },
      children: children2
    }
  );
}, "WCWeb3WalletProvider"), RatesProvider = /* @__PURE__ */ __name(({ children: children2 }) => {
  const [defaultCurrency2, setDefaultCurrency] = reactExports.useState("USD"), [activeCurrencies, setActiveCurrencies] = reactExports.useState(["USD", "EUR", "CHF"]), [btcUnit, setBtcUnit2] = reactExports.useState("default");
  reactExports.useEffect(() => {
    updateRatesConfig();
  }, []);
  const updateRatesConfig = /* @__PURE__ */ __name(async () => {
    var _a46, _b, _c;
    const appConf = await getConfig();
    (_a46 = appConf.backend) != null && _a46.mainFiat && setDefaultCurrency(appConf.backend.mainFiat), (_b = appConf.backend) != null && _b.fiatList && ((_c = appConf.backend) != null && _c.btcUnit) && (setActiveCurrencies(appConf.backend.fiatList), setBtcUnit2(appConf.backend.btcUnit));
  }, "updateRatesConfig"), rotateFiat = /* @__PURE__ */ __name(() => {
    const index = activeCurrencies.indexOf(defaultCurrency2), fiat2 = activeCurrencies[(index + 1) % activeCurrencies.length];
    setDefaultCurrency(fiat2);
  }, "rotateFiat"), updateDefaultFiat = /* @__PURE__ */ __name((fiat2) => {
    activeCurrencies.includes(fiat2) || selectFiat(fiat2), setDefaultCurrency(fiat2), setConfig({ backend: { mainFiat: fiat2 } });
  }, "updateDefaultFiat"), selectFiat = /* @__PURE__ */ __name(async (fiat2) => {
    const selected2 = [...activeCurrencies, fiat2];
    await setConfig({ backend: { fiatList: selected2 } }), handleChangeSelectedFiat(selected2);
  }, "selectFiat"), unselectFiat = /* @__PURE__ */ __name(async (fiat2) => {
    const selected2 = activeCurrencies.filter((item2) => !equal(item2, fiat2));
    await setConfig({ backend: { fiatList: selected2 } }), handleChangeSelectedFiat(selected2);
  }, "unselectFiat"), handleChangeSelectedFiat = /* @__PURE__ */ __name((selected2) => {
    setActiveCurrencies(selected2), reinitializeAccounts();
  }, "handleChangeSelectedFiat");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RatesContext.Provider,
    {
      value: {
        defaultCurrency: defaultCurrency2,
        activeCurrencies,
        btcUnit,
        rotateFiat,
        selectFiat,
        updateDefaultFiat,
        updateRatesConfig,
        unselectFiat
      },
      children: children2
    }
  );
}, "RatesProvider"), fetchAccountNameAndAddress = /* @__PURE__ */ __name(async (address2) => {
  const accountDetail = await getEthAccountCodeAndNameByAddress(address2);
  if (!accountDetail.success)
    return console.log("Failed in fetching account name and code"), { accountName: "", accountCode: "" };
  const { code, name } = accountDetail;
  return { accountName: name, accountCode: code };
}, "fetchAccountNameAndAddress");
async function handleWcEthSignRequest(method, args) {
  switch (method) {
    case EIP155_SIGNING_METHODS.ETH_SIGN:
    case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      await ethSignHandler(args, method);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      await ethSignTypedDataHandler(args);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
    case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      await ethSignOrSendTransactionHandler(args, method);
      break;
    default:
      console.log(`${method} is unsupported`);
  }
}
__name(handleWcEthSignRequest, "handleWcEthSignRequest");
async function ethSignHandler({ params, launchSignDialog, topic, id: id2, currentSession }, method) {
  const isPersonalSign = method === EIP155_SIGNING_METHODS.PERSONAL_SIGN, requestParams = params.request.params, accountAddress = isPersonalSign ? requestParams[1] : requestParams[0], signingData = isPersonalSign ? requestParams[0] : requestParams[1], decoded = decodeEthMessage(signingData);
  if (decoded === null) {
    alertUser(t$1("walletConnect.signingRequest.decodeError"));
    return;
  }
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  launchSignDialog({
    topic,
    id: id2,
    apiCaller: /* @__PURE__ */ __name(async () => {
      const result = await ethSignMessage(accountCode, signingData);
      return result.success ? {
        response: { id: id2, jsonrpc: "2.0", result: result.signature },
        success: !0
      } : { success: !1, error: result };
    }, "apiCaller"),
    dialogContent: {
      signingData: decoded,
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signMessage")
    }
  });
}
__name(ethSignHandler, "ethSignHandler");
async function ethSignTypedDataHandler({ params, launchSignDialog, topic, id: id2, currentSession }) {
  const requestParams = params.request.params, accountAddress = requestParams[0], data = requestParams[1];
  let typedData;
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  try {
    typedData = JSON.parse(data);
  } catch (e2) {
    console.error("Failed to parse JSON", e2), alertUser(t$1("walletConnect.signingRequest.dataParsingError"));
    return;
  }
  launchSignDialog({
    topic,
    id: id2,
    apiCaller: /* @__PURE__ */ __name(async () => {
      var _a46;
      const chainId = (_a46 = typedData == null ? void 0 : typedData.domain) != null && _a46.chainId ? Number(typedData.domain.chainId) : Number(params.chainId.replace(/^eip155:/, "")), result = await ethSignTypedMessage(accountCode, chainId, data);
      return result.success ? { response: { id: id2, jsonrpc: "2.0", result: result.signature }, success: !0 } : { success: !1, error: result };
    }, "apiCaller"),
    dialogContent: {
      signingData: JSON.stringify(typedData, null, 2),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signTypedData")
    }
  });
}
__name(ethSignTypedDataHandler, "ethSignTypedDataHandler");
async function ethSignOrSendTransactionHandler(args, method) {
  const isSendAndSign = method === EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION, { params, launchSignDialog, topic, id: id2, currentSession } = args, requestParams = params.request.params, accountAddress = requestParams[0].from, data = requestParams[0], { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress), apiCaller = /* @__PURE__ */ __name(async () => {
    const chainId = Number(params.chainId.replace(/^eip155:/, "")), result = await ethSignWalletConnectTx(accountCode, isSendAndSign, chainId, data);
    return result.success ? { response: { id: id2, jsonrpc: "2.0", result: isSendAndSign ? result.txHash : result.rawTx }, success: !0 } : { success: !1, error: result };
  }, "apiCaller"), formattedMethod = t$1(isSendAndSign ? "walletConnect.signingRequest.method.sendTransaction" : "walletConnect.signingRequest.method.signTransaction");
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(data),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: formattedMethod
    }
  });
}
__name(ethSignOrSendTransactionHandler, "ethSignOrSendTransactionHandler");
const accountName = "_accountName_gsa52_1", accountNameAndAddress = "_accountNameAndAddress_gsa52_6", address = "_address_gsa52_10", animationAndTextContainer = "_animationAndTextContainer_gsa52_16", chainContainer = "_chainContainer_gsa52_28", itemText = "_itemText_gsa52_33", dappIcon = "_dappIcon_gsa52_42", item = "_item_gsa52_33", label = "_label_gsa52_62", listContainer = "_listContainer_gsa52_68", outerContainer = "_outerContainer_gsa52_77", successIcon = "_successIcon_gsa52_84", textarea = "_textarea_gsa52_89", titleContainer = "_titleContainer_gsa52_97", styles = {
  accountName,
  accountNameAndAddress,
  address,
  animationAndTextContainer,
  chainContainer,
  itemText,
  dappIcon,
  item,
  label,
  listContainer,
  outerContainer,
  successIcon,
  textarea,
  titleContainer
}, ConfirmOnBB02 = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("confirmOnDevice") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
  ] });
}, "ConfirmOnBB02"), RequestSuccessfullySigned = /* @__PURE__ */ __name(() => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("walletConnect.signingRequest.successfullySigned") })
  ] });
}, "RequestSuccessfullySigned"), WCIncomingSignRequestDialog = /* @__PURE__ */ __name(({
  open: open2,
  onAccept,
  onReject,
  content: content2,
  stage
}) => {
  const { t: t2 } = useTranslation(), { isDarkMode } = useDarkmode(), { accountAddress, accountName: accountName2, signingData, chain, method, currentSession } = content2, formattedChain = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].name : chain, chainIcon = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].icon : null, metadata2 = currentSession.peer.metadata, maxTextAreaRows = 20, signingDataHeight = signingData.toString().split(`
`).length + 3, textAreaRows = signingDataHeight > maxTextAreaRows ? maxTextAreaRows : signingDataHeight;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, large: !0, onClose: onReject, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titleContainer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { height: 32, width: 32 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDark, { height: 40, width: 40 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("walletConnect.signingRequest.walletConnectRequest") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.outerContainer, children: [
      stage !== "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: styles.listContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.account") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles.accountNameAndAddress, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.accountName, children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: accountName2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.address, children: truncateAddress(accountAddress) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.chain") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.chainContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: formattedChain }),
              chainIcon
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.dapp") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: metadata2.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: method })
          ] }),
          signingData && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.data") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { rows: textAreaRows, className: styles.textarea, readOnly: !0, value: signingData.toString() })
          ] })
        ] }),
        stage === "confirming" && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmOnBB02, {}),
        stage === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onAccept, primary: !0, type: "submit", children: t2("button.continue") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onReject, secondary: !0, type: "submit", children: t2("dialog.cancel") })
        ] })
      ] }),
      stage === "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsx(RequestSuccessfullySigned, {})
    ] })
  ] });
}, "WCIncomingSignRequestDialog"), WCSigningRequest = /* @__PURE__ */ __name(() => {
  const { web3wallet, isWalletInitialized } = reactExports.useContext(WCWeb3WalletContext), [dialogOpen, setDialogOpen] = reactExports.useState(!1), [dialogContent, setDialogContent] = reactExports.useState(), [stage, setStage] = reactExports.useState("initial"), signMessageApiCallerRef = reactExports.useRef(), requestDataRef = reactExports.useRef(), launchSignDialog = /* @__PURE__ */ __name(({ topic, id: id2, apiCaller, dialogContent: dialogContent2 }) => {
    const { signingData, currentSession, accountAddress, accountName: accountName2, chain, method } = dialogContent2;
    requestDataRef.current = { topic, id: id2 }, signMessageApiCallerRef.current = apiCaller, setDialogContent({
      accountAddress,
      accountName: accountName2,
      signingData,
      chain,
      currentSession,
      method
    }), setDialogOpen(!0);
  }, "launchSignDialog");
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized)
      return;
    const onSessionRequest = /* @__PURE__ */ __name(async (requestEvent) => {
      const { topic, params, id: id2 } = requestEvent, currentSession = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || {}).find((session) => session.topic === topic);
      if (currentSession) {
        const handlerArgs = {
          topic,
          id: id2,
          params,
          currentSession,
          launchSignDialog
        };
        await handleWcEthSignRequest(params.request.method, handlerArgs);
      }
    }, "onSessionRequest");
    return web3wallet == null || web3wallet.on("session_request", onSessionRequest), () => {
      web3wallet == null || web3wallet.off("session_request", onSessionRequest);
    };
  }, [isWalletInitialized, web3wallet]);
  const handleRejectBtn = /* @__PURE__ */ __name(async () => {
    setDialogOpen(!1);
    const requestData = requestDataRef.current;
    if (requestData) {
      const { topic, id: id2 } = requestData;
      await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
    }
  }, "handleRejectBtn"), handleAcceptBtn = /* @__PURE__ */ __name(async () => {
    const apiCaller = signMessageApiCallerRef.current, requestData = requestDataRef.current;
    if (apiCaller && requestData) {
      setStage("confirming");
      const { topic, id: id2 } = requestData, { response, success: success2, error: error3 } = await apiCaller();
      if (success2)
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response })), setStage("accepted"), setTimeout(() => {
          setDialogOpen(!1), setStage("initial");
        }, 5e3);
      else if (error3.aborted)
        setStage("initial"), setDialogOpen(!1), await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
      else {
        setStage("initial");
        const { errorMessage } = error3;
        alertUser(errorMessage || t$1("pairing.error.text"));
      }
    }
  }, "handleAcceptBtn");
  return !dialogContent || !dialogOpen ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCIncomingSignRequestDialog,
    {
      content: dialogContent,
      open: dialogOpen,
      stage,
      onAccept: handleAcceptBtn,
      onReject: handleRejectBtn
    }
  );
}, "WCSigningRequest"), sillyFN = /* @__PURE__ */ __name(() => {
  let b2 = 1;
  return b2 = b2 + 1, (/* @__PURE__ */ __name(() => 40 + b2, "sillyFn2"))();
}, "sillyFN");
window.sillyVal = sillyFN();
const _App = class _App extends reactExports.Component {
  constructor() {
    super(...arguments), this.state = {
      accounts: [],
      devices: {}
    }, this.unsubscribeList = [], this.handleRoute = () => {
      panelStore.state.activeSidebar && toggleSidebar();
    }, this.maybeRoute = () => {
      const currentURL = window.location.pathname, isIndex = currentURL === "/" || currentURL === "/index.html" || currentURL === "/android_asset/web/index.html", inAccounts = currentURL.startsWith("/account/"), accounts = this.state.accounts;
      if (isIndex && currentURL !== "/" && (!accounts || accounts.length === 0)) {
        route("/", !0);
        return;
      }
      if (accounts.length === 0 && (currentURL.startsWith("/account-summary") || currentURL.startsWith("/add-account") || currentURL.startsWith("/settings/manage-accounts"))) {
        route("/", !0);
        return;
      }
      if (Object.keys(this.state.devices).length === 0 && currentURL.startsWith("/settings/device-settings/")) {
        route("/", !0);
        return;
      }
      if (inAccounts && !accounts.some((account2) => currentURL.startsWith("/account/" + account2.code))) {
        route("/", !0);
        return;
      }
      if (isIndex && accounts.length) {
        route("/account-summary", !0);
        return;
      }
      if (accounts.length === 0 && currentURL.startsWith("/buy/")) {
        route("/", !0);
        return;
      }
    }, this.devicesKey = (prefix2) => prefix2 + ":" + JSON.stringify(this.state.devices, Object.keys(this.state.devices).sort()), this.activeAccounts = () => this.state.accounts.filter((acct) => acct.active);
  }
  componentDidMount() {
    Promise.all([getDeviceList(), getAccounts()]).then(([devices, accounts]) => {
      this.setStateWithDeviceList({ accounts, devices });
    }).catch(console.error), this.unsubscribeList.push(
      syncNewTxs((meta) => {
        notifyUser(this.props.t("notification.newTxs", {
          count: meta.count,
          accountName: meta.accountName
        }));
      }),
      syncAccountsList((accounts) => {
        this.setState({ accounts }, () => this.maybeRoute());
      }),
      syncDeviceList((devices) => {
        this.setStateWithDeviceList({ devices });
      })
    );
  }
  setStateWithDeviceList(newState) {
    const oldDeviceIDList = Object.keys(this.state.devices);
    this.setState((currentState) => ({ ...currentState, ...newState }), () => {
      const newDeviceIDList = Object.keys(this.state.devices);
      if (newDeviceIDList.length > 0 && newDeviceIDList[0] !== oldDeviceIDList[0]) {
        const productName = this.state.devices[newDeviceIDList[0]];
        if (productName === "bitbox" || productName === "bitbox02-bootloader") {
          route(`settings/device-settings/${newDeviceIDList[0]}`, !0);
          return;
        }
      }
      this.maybeRoute();
    });
  }
  componentWillUnmount() {
    unsubscribe(this.unsubscribeList);
  }
  render() {
    const { accounts, devices } = this.state, deviceIDs = Object.keys(devices), activeAccounts = this.activeAccounts();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedApp, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RatesProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WCWeb3WalletProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Darkmode, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRequired, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          guideShareHOC,
          {
            accounts: activeAccounts,
            deviceIDs
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "appContent flex flex-column flex-1", style: { minWidth: 0 }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Update, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox01" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox02" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDataWarning, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(WCSigningRequest, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(translateHOC, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(KeystoreConnectPrompt, {}),
          Object.entries(devices).map(([deviceID, productName]) => productName === "bitbox02" ? /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wizard,
            {
              deviceID
            }
          ) }, deviceID) : null),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AppRouter,
            {
              accounts,
              activeAccounts,
              deviceIDs,
              devices,
              devicesKey: this.devicesKey
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(RouterWatcher, { onChange: this.handleRoute })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Confirm, {})
      ] })
    ] }) }) }) }) });
  }
};
__name(_App, "App");
let App = _App;
const HOC = translate()(App);
const rootEl = document.getElementById("root"), root = createRoot(rootEl);
root.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nextProvider, { i18n: instance, children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC, {}) }) }) }) })
);
export {
  Vn as $,
  Bt as A,
  B,
  ft as C,
  D,
  require$$0 as E,
  Ft as F,
  Gt as G,
  Ht as H,
  binary as I,
  Jt as J,
  Kn as K,
  Ln as L,
  wipe$1 as M,
  N,
  random as O,
  fromString as P,
  Qn as Q,
  toString as R,
  concat as S,
  rt as T,
  U,
  ot as V,
  Wt as W,
  Xt as X,
  Yt as Y,
  kn as Z,
  _23 as _,
  getAugmentedNamespace as a,
  Mn as a0,
  Te as a1,
  qn as a2,
  xn as a3,
  Hn as a4,
  Fn as a5,
  ee as a6,
  $ as a7,
  vt as a8,
  Et as a9,
  ut as aa,
  k as ab,
  Jn as ac,
  er as ad,
  Xn as ae,
  nr as af,
  Vt as ag,
  Mt$1 as ah,
  It as ai,
  wt as aj,
  lt as ak,
  dt as al,
  C as am,
  te as an,
  p as ao,
  cjs$2 as b,
  commonjsGlobal as c,
  at as d,
  gt as e,
  Dt as f,
  getDefaultExportFromCjs as g,
  ht as h,
  Lt as i,
  jt as j,
  kt$1 as k,
  dn as l,
  mt as m,
  h as n,
  ln as o,
  pt as p,
  qt as q,
  require$$0$1 as r,
  sha256 as s,
  tr as t,
  un as u,
  Kt as v,
  w,
  xt as x,
  yt as y,
  zt as z
};
