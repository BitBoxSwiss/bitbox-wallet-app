function _mergeNamespaces(n2, m2) {
  for (var i = 0; i < m2.length; i++) {
    const e3 = m2[i];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k2 in e3) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e3, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e3[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var f2 = n2.default;
  if (typeof f2 == "function") {
    var a2 = function a3() {
      if (this instanceof a3) {
        return Reflect.construct(f2, arguments, this.constructor);
      }
      return f2.apply(this, arguments);
    };
    a2.prototype = f2.prototype;
  } else
    a2 = {};
  Object.defineProperty(a2, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$2 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$3 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$1 = Symbol.for("react.context"), v$3 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$2 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$3 = Symbol.iterator;
function A$5(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$3 && a2[z$3] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$3 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$3 = Object.assign, D$3 = {};
function E$2(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e3 || B$3;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$2() {
}
F$2.prototype = E$2.prototype;
function G$3(a2, b2, e3) {
  this.props = a2;
  this.context = b2;
  this.refs = D$3;
  this.updater = e3 || B$3;
}
var H$3 = G$3.prototype = new F$2();
H$3.constructor = G$3;
C$3(H$3, E$2.prototype);
H$3.isPureReactComponent = true;
var I$2 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$2 = { current: null }, L$3 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e3) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$3.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$2.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$3(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$2(a2, b2, e3, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$3:
          case n$2:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$2(c2) ? (e3 = "", null != a2 && (e3 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e3, "", function(a3) {
      return a3;
    })) : null != c2 && (O$3(c2) && (c2 = N$3(c2, e3 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$3(k2, g2);
      h2 += R$2(k2, b2, e3, f2, c2);
    }
  else if (f2 = A$5(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$2(k2, b2, e3, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$3(a2, b2, e3) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$2(a2, d2, "", "", function(a3) {
    return b2.call(e3, a3, c2++);
  });
  return d2;
}
function T$3(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$3 = { current: null }, V$3 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$3, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$2 };
react_production_min.Children = { map: S$3, forEach: function(a2, b2, e3) {
  S$3(a2, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a2) {
  var b2 = 0;
  S$3(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$3(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$3;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$4;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.cloneElement = function(a2, b2, e3) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$2.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$3.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$1, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$2, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$3, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$3 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$2, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$3.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$3.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$3.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$3.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$3.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e3) {
  return U$3.current.useImperativeHandle(a2, b2, e3);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$3.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$3.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$3.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e3) {
  return U$3.current.useReducer(a2, b2, e3);
};
react_production_min.useRef = function(a2) {
  return U$3.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$3.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e3) {
  return U$3.current.useSyncExternalStore(a2, b2, e3);
};
react_production_min.useTransition = function() {
  return U$3.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$3 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$2(c2, a2, g2) {
  var b2, d2 = {}, e3 = null, h2 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a2.key && (e3 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$3, type: c2, key: e3, ref: h2, props: d2, _owner: n$1.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e3 = a2[d2];
        if (0 < g2(e3, b2))
          a2[d2] = b2, a2[c2] = e3, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e3 = a2.length, w2 = e3 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e3 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e3 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F3 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H3(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H3, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e3 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H3, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F3)
    S2 = function() {
      F3(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c2 + e3;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e3, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H3, c2 - d2))) : (a2.sortIndex = e3, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$2(a2, b2, c2, d2, e3, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e3;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$2 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$2[b2] = new v$2(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$2[b2] = new v$2(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$2[b2] = new v$2(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$2.xlinkHref = new v$2("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$2[a2] = new v$2(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e3 = z$2.hasOwnProperty(b2) ? z$2[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e3, d2) && (c2 = null), d2 || null === e3 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e3.mustUseProperty ? a2[e3.propertyName] = null === c2 ? 3 === e3.type ? false : "" : c2 : (b2 = e3.attributeName, d2 = e3.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e3 = e3.type, c2 = 3 === e3 || 4 === e3 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$4 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e3.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e3[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e3[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e3[g2] !== f2[h2]) {
                var k2 = "\n" + e3[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e3 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$4({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c2.length; e3++)
      b2["$" + c2[e3]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e3 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e3 && (a2[c2].selected = e3), e3 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e3 = 0; e3 < a2.length; e3++) {
      if (a2[e3].value === c2) {
        a2[e3].selected = true;
        d2 && (a2[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e3].disabled || (b2 = a2[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$3(91));
  return A$4({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e3);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e3 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e3) : a2[c2] = e3;
    }
}
var tb = A$4({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e3 = c2.return;
    if (null === e3)
      break;
    var f2 = e3.alternate;
    if (null === f2) {
      d2 = e3.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c2)
          return Xb(e3), a2;
        if (f2 === d2)
          return Xb(e3), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return)
      c2 = e3, d2 = f2;
    else {
      for (var g2 = false, h2 = e3.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e3;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e3;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e3;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e3;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$3(190));
  }
  if (3 !== c2.tag)
    throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e3 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e3;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e3, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e3) && (e3 = d2 & -d2, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e3 = 1 << c2, d2 |= a2[c2], b2 &= ~e3;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e3 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e3[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e3[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e3 = 31 - oc(c2), f2 = 1 << e3;
    b2[e3] = 0;
    d2[e3] = -1;
    a2[e3] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e3 = 1 << d2;
    e3 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e3;
  }
}
var C$2 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e3, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a2;
}
function Uc(a2, b2, c2, d2, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e3)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e3 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e3, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e3 = C$2, f2 = cd.transition;
  cd.transition = null;
  try {
    C$2 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$2 = e3, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e3 = Yc(a2, b2, c2, d2);
    if (null === e3)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e3, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e3)
          break;
        e3 = f2;
      }
      null !== e3 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e3[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e3[f2 - d2]; d2++)
    ;
  return md = e3.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e3, f2, g2) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$4(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$4({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$4({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$4({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$4({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$4({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$4({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$4({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$4({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$4({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$4({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$4({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$4({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$2 = ia && "CompositionEvent" in window, be$1 = null;
ia && "documentMode" in document && (be$1 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$1, de$1 = ia && (!ae$2 || be$1 && 8 < be$1 && 11 >= be$1), ee$2 = String.fromCharCode(32), fe$1 = false;
function ge$1(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$1(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$2 = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$1(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$1 = true;
      return ee$2;
    case "textInput":
      return a2 = b2.data, a2 === ee$2 && fe$1 ? null : a2;
    default:
      return null;
  }
}
function ke$2(a2, b2) {
  if (ie$2)
    return "compositionend" === a2 || !ae$2 && ge$1(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$2 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$1 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$1[a2.type] : "textarea" === b2 ? true : false;
}
function ne$1(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$1 = null, qe$1 = null;
function re$2(a2) {
  se$2(a2, 0);
}
function te$2(a2) {
  var b2 = ue$1(a2);
  if (Wa(b2))
    return a2;
}
function ve$1(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$1 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$1 = "oninput" in document;
    if (!ye$1) {
      var ze$1 = document.createElement("div");
      ze$1.setAttribute("oninput", "return;");
      ye$1 = "function" === typeof ze$1.oninput;
    }
    xe$1 = ye$1;
  } else
    xe$1 = false;
  we$1 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$1 && (pe$1.detachEvent("onpropertychange", Be$1), qe$1 = pe$1 = null);
}
function Be$1(a2) {
  if ("value" === a2.propertyName && te$2(qe$1)) {
    var b2 = [];
    ne$1(b2, qe$1, a2, xb(a2));
    Jb(re$2, b2);
  }
}
function Ce$2(a2, b2, c2) {
  "focusin" === a2 ? (Ae$1(), pe$1 = b2, qe$1 = c2, pe$1.attachEvent("onpropertychange", Be$1)) : "focusout" === a2 && Ae$1();
}
function De$1(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$2(qe$1);
}
function Ee(a2, b2) {
  if ("click" === a2)
    return te$2(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$2(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$1 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$1(a2, b2) {
  if (He$1(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e3 = c2[d2];
    if (!ja.call(b2, e3) || !He$1(a2[e3], b2[e3]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e3 = c2.textContent.length, f2 = Math.min(d2.start, e3);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e3);
        !a2.extend && f2 > d2 && (e3 = d2, d2 = f2, f2 = e3);
        e3 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e3 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e3.node || a2.anchorOffset !== e3.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$1 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$1 = null, Re$1 = null, Se$1 = null, Te$1 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$1 || null == Qe$1 || Qe$1 !== Xa(d2) || (d2 = Qe$1, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$1 && Ie$1(Se$1, d2) || (Se$1 = d2, d2 = oe$2(Re$1, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$1)));
}
function Ve$1(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$1 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$1 = {}, Ye$1 = {};
ia && (Ye$1 = document.createElement("div").style, "AnimationEvent" in window || (delete We$1.animationend.animation, delete We$1.animationiteration.animation, delete We$1.animationstart.animation), "TransitionEvent" in window || delete We$1.transitionend.transition);
function Ze$1(a2) {
  if (Xe$1[a2])
    return Xe$1[a2];
  if (!We$1[a2])
    return a2;
  var b2 = We$1[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$1)
      return Xe$1[a2] = b2[c2];
  return a2;
}
var $e$1 = Ze$1("animationend"), af = Ze$1("animationiteration"), bf = Ze$1("animationstart"), cf = Ze$1("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e3 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e3.isPropagationStopped())
            break a;
          nf(e3, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$2(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c2 = e3.bind(null, b2, c2, a2);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d2 ? void 0 !== e3 ? a2.addEventListener(b2, c2, { capture: true, passive: e3 }) : a2.addEventListener(b2, c2, true) : void 0 !== e3 ? a2.addEventListener(b2, c2, { passive: e3 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e3) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e3 || 8 === h2.nodeType && h2.parentNode === e3)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e3 || 8 === k2.nodeType && k2.parentNode === e3)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e4 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F3 = u2.stateNode;
          5 === u2.tag && null !== F3 && (u2 = F3, null !== x2 && (F3 = Kb(w2, x2), null != F3 && t2.push(tf(w2, F3, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e4), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e4.window === e4 ? e4 : (h3 = e4.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F3 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F3 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$1(k3);
            u2 = null == n2 ? h3 : ue$1(n2);
            h3 = new t2(F3, w2 + "leave", k3, c2, e4);
            h3.target = J2;
            h3.relatedTarget = u2;
            F3 = null;
            Wc(e4) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e4), t2.target = u2, t2.relatedTarget = J2, F3 = t2);
            J2 = F3;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F3 = x2; F3; F3 = vf(F3))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$1(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$1;
        else if (me$1(h3))
          if (we$1)
            na = Fe$1;
          else {
            na = De$1;
            var xa = Ce$2;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne$1(g3, na, c2, e4);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$1(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable)
            Qe$1 = xa, Re$1 = d3, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re$1 = Qe$1 = null;
          break;
        case "mousedown":
          Te$1 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$1 = false;
          Ue$1(g3, c2, e4);
          break;
        case "selectionchange":
          if (Pe$1)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e4);
      }
      var $a;
      if (ae$2)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$2 ? ge$1(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$2 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$2 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$2 = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$1(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je(a2, c2) : ke$2(a2, c2))
        d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c2, e4), g3.push({ event: e4, listeners: d3 }), e4.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e3 = a2, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e3)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e3)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e3) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e3 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e3 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e3 = c2.nextSibling;
    a2.removeChild(c2);
    if (e3 && 8 === e3.nodeType)
      if (c2 = e3.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e3);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e3;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$1(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$2(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c2)
    e3[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$3(168));
  G$2(H$2, b2);
  G$2(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e3 in d2)
    if (!(e3 in b2))
      throw Error(p$3(108, Ra(a2) || "Unknown", e3));
  return A$4({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$2(H$2, a2);
  G$2(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H$2), G$2(H$2, a2)) : E$1(Wf);
  G$2(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$2;
    try {
      var c2 = eg;
      for (C$2 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e3;
    } finally {
      C$2 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e3 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e3);
  c2 += 1;
  var f2 = 32 - oc(b2) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b2) + e3 | c2 << e3 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e3 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I$1 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$1)
    return Fg(a2), I$1 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$3(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$4({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$1(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$3(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e3 = b2.interleaved;
  null === e3 ? (c2.next = c2, Xg(b2)) : (c2.next = e3.next, e3.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$1 & 2)) {
    var e3 = d2.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e3 = d2.interleaved;
  null === e3 ? (b2.next = b2, Xg(d2)) : (b2.next = e3.next, e3.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e3 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
    } else
      e3 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e3 = a2.updateQueue;
  $g = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h2 = e3.shared.pending;
  if (null !== h2) {
    e3.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e3.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$4({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e3.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e3.baseState = k2;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m2;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else
      null === f2 && (e3.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e3 = d2.callback;
      if (null !== e3) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e3)
          throw Error(p$3(191, e3));
        e3.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$4({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$2(), e3 = lh(a2), f2 = ch(d2, e3);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e3);
  null !== b2 && (mh(b2, a2, e3, d2), eh(b2, a2, e3));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$2(), d2 = lh(a2), e3 = ch(c2, d2);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = dh(a2, e3, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e3, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$1(c2, d2) || !Ie$1(e3, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e3 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e3 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e3) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e3, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e3 = a2.stateNode;
  e3.props = c2;
  e3.state = a2.memoizedState;
  e3.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e3.context = Yf(a2, f2));
  e3.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e3.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && nh.enqueueReplaceState(e3, e3.state, null), gh(a2, c2, e3, d2), e3.state = a2.memoizedState);
  "function" === typeof e3.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$3(147, a2));
      var e3 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e3.refs;
        b3 === jh && (b3 = e3.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$3(284));
    if (!c2._owner)
      throw Error(p$3(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e3(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e3(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e3(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e3(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e4 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e4 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e4 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e4 = c3._init, r2(
            a3,
            b3,
            e4(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e4 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e4) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e4);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e4);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e4);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e4);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e4, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e4, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e4, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e4, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e4, u2), I$1 && tg(e4, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e4, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (u2 = d2(e4, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e4, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function t2(e4, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e4, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e4, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e4,
        m3
      ), I$1 && tg(e4, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e4, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e4, w2);
      return l3;
    }
    for (m3 = d2(e4, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e4, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e4, a3);
    });
    I$1 && tg(e4, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e3(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e3(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e3(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e3(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$3(174));
  return a2;
}
function Ih(a2, b2) {
  G$2(Gh, b2);
  G$2(Fh, a2);
  G$2(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(Eh);
  G$2(Eh, b2);
}
function Jh() {
  E$1(Eh);
  E$1(Fh);
  E$1(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$2(Fh, a2), G$2(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$1(Eh), E$1(Fh));
}
var M$1 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$1 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$2() {
  throw Error(p$3(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$1(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e3, f2) {
  Rh = f2;
  N$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e3);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$3(301));
      f2 += 1;
      P$1 = O$2 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e3);
    } while (Th);
  }
  Ph.current = ai$1;
  b2 = null !== O$2 && null !== O$2.next;
  Rh = 0;
  P$1 = O$2 = N$2 = null;
  Sh = false;
  if (b2)
    throw Error(p$3(300));
  return a2;
}
function bi$1() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  return P$1;
}
function di$1() {
  if (null === O$2) {
    var a2 = N$2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = null === P$1 ? N$2.memoizedState : P$1.next;
  if (null !== b2)
    P$1 = b2, O$2 = a2;
  else {
    if (null === a2)
      throw Error(p$3(310));
    O$2 = a2;
    a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
    null === P$1 ? N$2.memoizedState = P$1 = a2 : P$1 = P$1.next = a2;
  }
  return P$1;
}
function ei$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e3 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e3 = f2;
    c2.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$2.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$1(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e3 = a2;
    do
      f2 = e3.lane, N$2.lanes |= f2, hh |= f2, e3 = e3.next;
    while (e3 !== a2);
  } else
    null === e3 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e3 = c2.pending, f2 = b2.memoizedState;
  if (null !== e3) {
    c2.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He$1(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi$1() {
}
function ii$1(a2, b2) {
  var c2 = N$2, d2 = di$1(), e3 = b2(), f2 = !He$1(d2.memoizedState, e3);
  f2 && (d2.memoizedState = e3, Ug = true);
  d2 = d2.queue;
  ji$1(ki$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$1 && P$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li$1(9, mi$1.bind(null, c2, d2, e3, b2), void 0, null);
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(c2, b2, e3);
  }
  return e3;
}
function ni$1(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi$1(b2) && pi$1(a2);
}
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$1(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi$1(a2) {
  var b2 = ci$1();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri$1.bind(null, N$2, a2);
  return [b2.memoizedState, a2];
}
function li$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si$1() {
  return di$1().memoizedState;
}
function ti$1(a2, b2, c2, d2) {
  var e3 = ci$1();
  N$2.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui$1(a2, b2, c2, d2) {
  var e3 = di$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$2) {
    var g2 = O$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e3.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2;
  e3.memoizedState = li$1(1 | b2, c2, f2, d2);
}
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
function ji$1(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
function yi$1(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi$1(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
function Ai$1() {
}
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di$1(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$1(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei$1(a2, b2) {
  var c2 = C$2;
  C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$2 = c2, Qh.transition = d2;
  }
}
function Fi$1() {
  return di$1().memoizedState;
}
function Gi$1(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e3 = L$2();
    mh(c2, a2, d2, e3);
    Ji$1(c2, b2, d2);
  }
}
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e3 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi$1(a2))
    Ii$1(b2, e3);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e3.hasEagerState = true;
        e3.eagerState = h2;
        if (He$1(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e3.next = e3, Xg(b2)) : (e3.next = k2.next, k2.next = e3);
          b2.interleaved = e3;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e3, d2);
    null !== c2 && (e3 = L$2(), mh(c2, a2, d2, e3), Ji$1(c2, b2, d2));
  }
}
function Hi$1(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || null !== b2 && b2 === N$2;
}
function Ii$1(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji$1(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai$1 = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi$1.bind(null, N$2, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi$1, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi$1(false), b2 = a2[0];
  a2 = Ei$1.bind(null, a2[1]);
  ci$1().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e3 = ci$1();
  if (I$1) {
    if (void 0 === c2)
      throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$1)
      throw Error(p$3(349));
    0 !== (Rh & 30) || ni$1(d2, b2, c2);
  }
  e3.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e3.queue = f2;
  vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$1.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji$1,
  useImperativeHandle: zi$1,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci$1,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai$1,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di$1(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi$1,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji$1, useImperativeHandle: zi$1, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci$1, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai$1, useDeferredValue: function(a2) {
  var b2 = di$1();
  return null === O$2 ? b2.memoizedState = a2 : Di$1(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi$1, unstable_isNewReconciler: false };
function Ki$1(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e3 = c2;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e3, digest: null };
}
function Li$1(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi$1(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni$1 = "function" === typeof WeakMap ? WeakMap : Map;
function Oi$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi$1 || (Pi$1 = true, Qi$1 = d2);
    Mi$1(a2, b2);
  };
  return c2;
}
function Ri$1(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e3 = b2.value;
    c2.payload = function() {
      return d2(e3);
    };
    c2.callback = function() {
      Mi$1(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi$1(a2, b2);
    "function" !== typeof d2 && (null === Si$1 ? Si$1 = /* @__PURE__ */ new Set([this]) : Si$1.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni$1();
    var e3 = /* @__PURE__ */ new Set();
    d2.set(b2, e3);
  } else
    e3 = d2.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d2.set(b2, e3));
  e3.has(c2) || (e3.add(c2), a2 = Ui$1.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi$1(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi$1(a2, b2, c2, d2, e3) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e3;
  return a2;
}
var Xi$1 = ua.ReactCurrentOwner, Ug = false;
function Yi$1(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi$1(a2, b2, c2, d2, e3) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e3);
  d2 = Xh(a2, b2, c2, d2, f2, e3);
  c2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, d2, e3);
  return b2.child;
}
function aj(a2, b2, c2, d2, e3) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e3);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e3);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$1;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i$1(a2, b2, e3);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e3) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$1(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e3))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i$1(a2, b2, e3);
  }
  return dj(a2, b2, c2, d2, e3);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$2(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$2(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$2(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$2(fj, gj), gj |= d2;
  Yi$1(a2, b2, e3, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e3) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e3);
  c2 = Xh(a2, b2, c2, d2, f2, e3);
  d2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e3, $i$1(a2, b2, e3);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Yi$1(a2, b2, c2, e3);
  return b2.child;
}
function ij(a2, b2, c2, d2, e3) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e3);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e3), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e3);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e3);
}
function kj(a2, b2, c2, d2, e3, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e3 && dg(b2, c2, false), $i$1(a2, b2, f2);
  d2 = b2.stateNode;
  Xi$1.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi$1(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e3 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Yi$1(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = M$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e3 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e3 |= 1;
  G$2(M$1, e3 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e3 = a2.memoizedState;
  if (null !== e3 && (h2 = e3.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e3, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e3 = a2.child;
    h2 = e3.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e3 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e3, k2), d2.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e3, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li$1(Error(p$3(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e3 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e3, 0, null);
    f2 = Ah(f2, e3, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e3.data) {
    d2 = e3.nextSibling && e3.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Li$1(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$1;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d2.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, Zg(a2, e3), mh(d2, a2, e3, -1));
    }
    uj();
    d2 = Li$1(Error(p$3(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e3.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e3._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e3) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e3);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e3 = d2.revealOrder, f2 = d2.tail;
  Yi$1(a2, b2, d2.children, c2);
  d2 = M$1.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$2(M$1, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e3) {
      case "forwards":
        c2 = b2.child;
        for (e3 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e3 = c2), c2 = c2.sibling;
        c2 = e3;
        null === c2 ? (e3 = b2.child, b2.child = null) : (e3 = c2.sibling, c2.sibling = null);
        xj(b2, false, e3, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e3 = b2.child;
        for (b2.child = null; null !== e3; ) {
          a2 = e3.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e3;
            break;
          }
          a2 = e3.sibling;
          e3.sibling = c2;
          c2 = e3;
          e3 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i$1(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e3 = b2.memoizedProps.value;
      G$2(Mg, d2._currentValue);
      d2._currentValue = e3;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$2(M$1, M$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$2(M$1, M$1.current & 1);
        a2 = $i$1(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$2(M$1, M$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G$2(M$1, M$1.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i$1(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e3 = a2.memoizedProps;
  if (e3 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e3 = Ya(a2, e3);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e3 = A$4({}, e3, { value: void 0 });
        d2 = A$4({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a2, e3);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e3)
      if (!d2.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2])
        if ("style" === l2) {
          var h2 = e3[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e3 ? e3[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$2("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$1)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$2(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags & 14680064, d2 |= e3.flags & 14680064, e3.return = a2, e3 = e3.sibling;
  else
    for (e3 = a2.child; null !== e3; )
      c2 |= e3.lanes | e3.childLanes, d2 |= e3.subtreeFlags, d2 |= e3.flags, e3.return = a2, e3 = e3.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$2(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$1(Wf);
      E$1(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$2(b2);
      return null;
    case 5:
      Lh(b2);
      var e3 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e3), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$3(166));
          S$2(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$2("cancel", d2);
              D$2("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$2("load", d2);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++)
                D$2(lf[e3], d2);
              break;
            case "source":
              D$2("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$2(
                "error",
                d2
              );
              D$2("load", d2);
              break;
            case "details":
              D$2("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$2("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$2("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$2("invalid", d2);
          }
          ub(c2, f2);
          e3 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e3 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e3 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$2("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e3;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$2("cancel", a2);
                D$2("close", a2);
                e3 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$2("load", a2);
                e3 = d2;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++)
                  D$2(lf[e3], a2);
                e3 = d2;
                break;
              case "source":
                D$2("error", a2);
                e3 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$2(
                  "error",
                  a2
                );
                D$2("load", a2);
                e3 = d2;
                break;
              case "details":
                D$2("toggle", a2);
                e3 = d2;
                break;
              case "input":
                Za(a2, d2);
                e3 = Ya(a2, d2);
                D$2("invalid", a2);
                break;
              case "option":
                e3 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e3 = A$4({}, d2, { value: void 0 });
                D$2("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e3 = gb(a2, d2);
                D$2("invalid", a2);
                break;
              default:
                e3 = d2;
            }
            ub(c2, e3);
            h2 = e3;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$2("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$2(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$3(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$2(b2);
      return null;
    case 13:
      E$1(M$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$3(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$2(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$1.current & 1) ? 0 === T$2 && (T$2 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$2(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$2(b2), null;
    case 10:
      return Rg(b2.type._context), S$2(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$2(b2), null;
    case 19:
      E$1(M$1);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$2(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$2 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$2(M$1, M$1.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$2() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1)
              return S$2(b2), null;
          } else
            2 * B$2() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$2(), b2.sibling = null, c2 = M$1.current, G$2(M$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$2(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$2(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$2(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$1(Wf), E$1(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$1(M$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(M$1), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$2 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$1(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$1(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$2();
  if (Ne(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e3 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F3) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e3 && 3 !== q2.nodeType || (h2 = g2 + e3);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e3 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$2 = b2; null !== V$2; )
    if (b2 = V$2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$2 = a2;
    else
      for (; null !== V$2; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$3(163));
            }
        } catch (F3) {
          W$1(b2, b2.return, F3);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e3 = d2 = d2.next;
    do {
      if ((e3.tag & a2) === a2) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e3 = e3.next;
    } while (e3 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$2 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$2 || Mj(c2, b2);
    case 6:
      var d2 = X$2, e3 = Yj;
      X$2 = null;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e3;
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$2.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$2 && (Yj ? (a2 = X$2, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$2, c2.stateNode));
      break;
    case 4:
      d2 = X$2;
      e3 = Yj;
      X$2 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$2 = d2;
      Yj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$2 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e3 = d2 = d2.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e3 = e3.next;
        } while (e3 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$2 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$1(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$2 = (d2 = U$2) || null !== c2.memoizedState, Zj(a2, b2, c2), U$2 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e3 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$2 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$2 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$2)
          throw Error(p$3(160));
        ak(f2, g2, e3);
        X$2 = null;
        Yj = false;
        var k2 = e3.alternate;
        null !== k2 && (k2.return = null);
        e3.return = null;
      } catch (l2) {
        W$1(e3, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e3 = a2.stateNode;
        try {
          ob(e3, "");
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e3 = a2.stateNode, null != e3)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e3, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e3, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e3, q2) : "children" === m2 ? ob(e3, q2) : ta(e3, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e3, f2);
                break;
              case "textarea":
                ib(e3, f2);
                break;
              case "select":
                var r2 = e3._wrapperState.wasMultiple;
                e3._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e3, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e3,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e3[Pf] = f2;
          } catch (t2) {
            W$1(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$3(162));
        e3 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$1(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e3 = a2.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (gk = B$2()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$2 = (l2 = U$2) || m2, dk(b2, a2), U$2 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$2 = m2; null !== V$2; ) {
              r2 = V$2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$1(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e3 = q2.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$1(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e3 = d2.stateNode;
          d2.flags & 32 && (ob(e3, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W$1(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$2 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$2; ) {
    var e3 = V$2, f2 = e3.child;
    if (22 === e3.tag && d2) {
      var g2 = null !== e3.memoizedState || Kj;
      if (!g2) {
        var h2 = e3.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$2;
        h2 = Kj;
        var l2 = U$2;
        Kj = g2;
        if ((U$2 = k2) && !l2)
          for (V$2 = e3; null !== V$2; )
            g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e3) : null !== k2 ? (k2.return = g2, V$2 = k2) : kk(e3);
        for (; null !== f2; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e3;
        Kj = h2;
        U$2 = l2;
      }
      lk(a2);
    } else
      0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$2 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$2 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$2)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e3 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e3, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$3(163));
          }
        U$2 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$1(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e3 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$1(b2, e3, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$1(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$1(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$1 = 0, R$1 = null, Y$1 = null, Z$2 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi$1 = false, Qi$1 = null, Si$1 = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$2() {
  return 0 !== (K$1 & 6) ? B$2() : -1 !== Bk ? Bk : Bk = B$2();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$1 & 2) && 0 !== Z$2)
    return Z$2 & -Z$2;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$2;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K$1 & 2) || a2 !== R$1)
    a2 === R$1 && (0 === (K$1 & 2) && (rk |= c2), 4 === T$2 && Dk(a2, Z$2)), Ek(a2, d2), 1 === c2 && 0 === K$1 && 0 === (b2.mode & 1) && (Hj = B$2() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$1 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$1 ? Z$2 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e3 = K$1;
    K$1 |= 2;
    var f2 = Kk();
    if (R$1 !== a2 || Z$2 !== b2)
      vk = null, Hj = B$2() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$1 = e3;
    null !== Y$1 ? b2 = 0 : (R$1 = null, Z$2 = 0, b2 = T$2);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a2), 0 !== e3 && (d2 = e3, b2 = Ok(a2, e3)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e3 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e3) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$2()), c2;
      a2.finishedWork = e3;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$2(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e3 = a2.suspendedLanes;
            if ((e3 & d2) !== d2) {
              L$2();
              a2.pingedLanes |= a2.suspendedLanes & e3;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e3 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e3 && (e3 = g2);
            d2 &= ~f2;
          }
          d2 = e3;
          d2 = B$2() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Ek(a2, B$2());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e3 = c2[d2], f2 = e3.getSnapshot;
          e3 = e3.value;
          try {
            if (!He$1(f2(), e3))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$2()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$2()), c2;
  if (6 === c2)
    throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$2());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$1;
  K$1 |= 1;
  try {
    return a2(b2);
  } finally {
    K$1 = c2, 0 === K$1 && (Hj = B$2() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$1 & 6) && Ik();
  var b2 = K$1;
  K$1 |= 1;
  var c2 = pk.transition, d2 = C$2;
  try {
    if (pk.transition = null, C$2 = 1, a2)
      return a2();
  } finally {
    C$2 = d2, pk.transition = c2, K$1 = b2, 0 === (K$1 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$1(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$1(Wf);
          E$1(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$1(M$1);
          break;
        case 19:
          E$1(M$1);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$1 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$2 = gj = b2;
  T$2 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e3 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e3;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai$1;
      if (Sh) {
        for (var d2 = N$2.memoizedState; null !== d2; ) {
          var e3 = d2.queue;
          null !== e3 && (e3.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$1 = O$2 = N$2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$2 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$2;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi$1(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi$1(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti$1(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti$1(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Vi$1(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi$1(J2, g2, h2, f2, b2);
            Jg(Ki$1(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki$1(k2, h2);
        4 !== T$2 && (T$2 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi$1(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si$1 || !Si$1.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F3 = Ri$1(f2, h2, b2);
                fh(f2, F3);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai$1;
  return null === a2 ? ai$1 : a2;
}
function uj() {
  if (0 === T$2 || 3 === T$2 || 2 === T$2)
    T$2 = 4;
  null === R$1 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$1, Z$2);
}
function Jk(a2, b2) {
  var c2 = K$1;
  K$1 |= 2;
  var d2 = Kk();
  if (R$1 !== a2 || Z$2 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e3) {
      Nk(a2, e3);
    }
  while (1);
  Qg();
  K$1 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$3(261));
  R$1 = null;
  Z$2 = 0;
  return T$2;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$2 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$2 && (T$2 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$2, e3 = pk.transition;
  try {
    pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e3, C$2 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$1 & 6))
    throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e3 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$1 && (Y$1 = R$1 = null, Z$2 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$2;
    C$2 = 1;
    var h2 = K$1;
    K$1 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$1 = h2;
    C$2 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e3);
  f2 = a2.pendingLanes;
  0 === f2 && (Si$1 = null);
  mc(c2.stateNode);
  Ek(a2, B$2());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e3 = b2[c2], d2(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Pi$1)
    throw Pi$1 = false, a2 = Qi$1, Qi$1 = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
    try {
      pk.transition = null;
      C$2 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$1 & 6))
          throw Error(p$3(331));
        var e3 = K$1;
        K$1 |= 4;
        for (V$2 = a2.current; null !== V$2; ) {
          var f2 = V$2, g2 = f2.child;
          if (0 !== (V$2.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; null !== V$2; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; null !== V$2; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$2 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; null !== V$2; ) {
                f2 = V$2;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$2 = x2;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; null !== V$2; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; null !== V$2; ) {
                h2 = V$2;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$1(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F3 = h2.sibling;
                if (null !== F3) {
                  F3.return = h2.return;
                  V$2 = F3;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        K$1 = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$2 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki$1(c2, b2);
  b2 = Oi$1(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$2();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$1(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si$1 || !Si$1.has(d2))) {
          a2 = Ki$1(c2, a2);
          a2 = Ri$1(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$2();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui$1(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$2();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$1 === a2 && (Z$2 & c2) === c2 && (4 === T$2 || 3 === T$2 && (Z$2 & 130023424) === Z$2 && 500 > B$2() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$2();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e3 = a2.memoizedState;
      null !== e3 && (c2 = e3.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e3 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e3 = Xh(null, b2, d2, a2, e3, c2);
      var f2 = bi$1();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, ah(b2), e3.updater = nh, b2.stateNode = e3, e3._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Yi$1(null, b2, e3, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e3 = d2._init;
        d2 = e3(d2._payload);
        b2.type = d2;
        e3 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e3) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi$1(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), dj(a2, b2, d2, e3, c2);
    case 1:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), ij(a2, b2, d2, e3, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e3 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e3 = Ki$1(Error(p$3(423)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else if (d2 !== e3) {
            e3 = Ki$1(Error(p$3(424)), b2);
            b2 = mj(a2, b2, d2, c2, e3);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e3) {
            b2 = $i$1(a2, b2, c2);
            break a;
          }
          Yi$1(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e3 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e3.children, Ef(d2, e3) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi$1(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi$1(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), Zi$1(a2, b2, d2, e3, c2);
    case 7:
      return Yi$1(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi$1(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e3 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e3.value;
        G$2(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$1(f2.value, g2)) {
            if (f2.children === e3.children && !Wf.current) {
              b2 = $i$1(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$3(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi$1(a2, b2, e3.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e3 = Vg(e3), d2 = d2(e3), b2.flags |= 1, Yi$1(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e3 = Lg(d2, b2.pendingProps), e3 = Lg(d2.type, e3), aj(a2, b2, d2, e3, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d2 ? e3 : Lg(d2, e3), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e3), rh(b2, d2, e3, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e3, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e3, f2, b2);
        case za:
          g2 = 8;
          e3 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e3 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e3), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e3), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e3, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e3);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e3) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e3, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e3, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$2();
  e3 = lh(c2);
  f2 = ch(d2, e3);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e3);
  a2.current.lanes = e3;
  Ac(a2, e3, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e3 = b2.current, f2 = L$2(), g2 = lh(e3);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e3, b2, g2);
  null !== a2 && (mh(a2, e3, g2, f2), eh(a2, e3, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$3(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e3) {
  if (e3) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e3 = a2.lastChild; )
    a2.removeChild(e3);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e3) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h2 = e3;
      e3 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e3);
  } else
    g2 = rl(c2, b2, a2, e3, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$2()), 0 === (K$1 & 6) && (Hj = B$2() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$2();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$2();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$2();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$2;
};
Ic = function(a2, b2) {
  var c2 = C$2;
  try {
    return C$2 = a2, b2();
  } finally {
    C$2 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e3 = Db(d2);
            if (!e3)
              throw Error(p$3(90));
            Wa(d2);
            bb(d2, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$1, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$3(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$3(299));
  var c2 = false, d2 = "", e3 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e3);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e3 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e3 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e3, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e3 = c2._getVersion, e3 = e3(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e3] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e3
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$3(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$3(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$3(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
var createRoot;
var m$3 = reactDomExports;
{
  createRoot = m$3.createRoot;
  m$3.hydrateRoot;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toPrimitive(t2, r2) {
  if ("object" != _typeof(t2) || !t2)
    return t2;
  var e3 = t2[Symbol.toPrimitive];
  if (void 0 !== e3) {
    var i = e3.call(t2, r2 || "default");
    if ("object" != _typeof(i))
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r2 ? String : Number)(t2);
}
function toPropertyKey(t2) {
  var i = toPrimitive(t2, "string");
  return "symbol" == _typeof(i) ? i : String(i);
}
function _defineProperty(obj, key, value) {
  key = toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck(instance2, Constructor) {
  if (!(instance2 instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
var defaultOptions = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true
};
var i18nInstance;
var I18nContext = React.createContext();
function getDefaults() {
  return defaultOptions;
}
var ReportNamespaces = function() {
  function ReportNamespaces2() {
    _classCallCheck(this, ReportNamespaces2);
    this.usedNamespaces = {};
  }
  _createClass(ReportNamespaces2, [{
    key: "addUsedNamespaces",
    value: function addUsedNamespaces(namespaces) {
      var _this = this;
      namespaces.forEach(function(ns2) {
        if (!_this.usedNamespaces[ns2])
          _this.usedNamespaces[ns2] = true;
      });
    }
  }, {
    key: "getUsedNamespaces",
    value: function getUsedNamespaces() {
      return Object.keys(this.usedNamespaces);
    }
  }]);
  return ReportNamespaces2;
}();
function getI18n() {
  return i18nInstance;
}
function warn() {
  if (console && console.warn) {
    var _console;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[0] === "string")
      args[0] = "react-i18next:: ".concat(args[0]);
    (_console = console).warn.apply(_console, args);
  }
}
var alreadyWarned = {};
function warnOnce() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  if (typeof args[0] === "string" && alreadyWarned[args[0]])
    return;
  if (typeof args[0] === "string")
    alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn.apply(void 0, args);
}
function loadNamespaces(i18n, ns2, cb2) {
  i18n.loadNamespaces(ns2, function() {
    if (i18n.isInitialized) {
      cb2();
    } else {
      var initialized = function initialized2() {
        setTimeout(function() {
          i18n.off("initialized", initialized2);
        }, 0);
        cb2();
      };
      i18n.on("initialized", initialized);
    }
  });
}
function oldI18nextHasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var lng = i18n.languages[0];
  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;
  var lastLng = i18n.languages[i18n.languages.length - 1];
  if (lng.toLowerCase() === "cimode")
    return true;
  var loadNotPending = function loadNotPending2(l2, n2) {
    var loadState = i18n.services.backendConnector.state["".concat(l2, "|").concat(n2)];
    return loadState === -1 || loadState === 2;
  };
  if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns2))
    return false;
  if (i18n.hasResourceBundle(lng, ns2))
    return true;
  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages)
    return true;
  if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)))
    return true;
  return false;
}
function hasLoadedNamespace(ns2, i18n) {
  var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  var isNewerI18next = i18n.options.ignoreJSONStructure !== void 0;
  if (!isNewerI18next) {
    return oldI18nextHasLoadedNamespace(ns2, i18n, options2);
  }
  return i18n.hasLoadedNamespace(ns2, {
    precheck: function precheck(i18nInstance2, loadNotPending) {
      if (options2.bindI18n && options2.bindI18n.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns2))
        return false;
    }
  });
}
function getDisplayName(Component) {
  return Component.displayName || Component.name || (typeof Component === "string" && Component.length > 0 ? Component : "Unknown");
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(r2, l2) {
  var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
  if (null != t2) {
    var e3, n2, i, u2, a2 = [], f2 = true, o2 = false;
    try {
      if (i = (t2 = t2.call(r2)).next, 0 === l2) {
        if (Object(t2) !== t2)
          return;
        f2 = false;
      } else
        for (; !(f2 = (e3 = i.call(t2)).done) && (a2.push(e3.value), a2.length !== l2); f2 = true)
          ;
    } catch (r3) {
      o2 = true, n2 = r3;
    } finally {
      try {
        if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2))
          return;
      } finally {
        if (o2)
          throw n2;
      }
    }
    return a2;
  }
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function ownKeys$8(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function useTranslation(ns2) {
  var props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var i18nFromProps = props.i18n;
  var _ref3 = reactExports.useContext(I18nContext) || {}, i18nFromContext = _ref3.i18n, defaultNSFromContext = _ref3.defaultNS;
  var i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces)
    i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    var notReadyT = function notReadyT2(k2) {
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    var retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react && i18n.options.react.wait !== void 0)
    warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  var i18nOptions = _objectSpread$8(_objectSpread$8(_objectSpread$8({}, getDefaults()), i18n.options.react), props);
  var useSuspense = i18nOptions.useSuspense, keyPrefix = i18nOptions.keyPrefix;
  var namespaces = ns2 || defaultNSFromContext || i18n.options && i18n.options.defaultNS;
  namespaces = typeof namespaces === "string" ? [namespaces] : namespaces || ["translation"];
  if (i18n.reportNamespaces.addUsedNamespaces)
    i18n.reportNamespaces.addUsedNamespaces(namespaces);
  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function(n2) {
    return hasLoadedNamespace(n2, i18n, i18nOptions);
  });
  function getT() {
    return i18n.getFixedT(null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  }
  var _useState = reactExports.useState(getT), _useState2 = _slicedToArray(_useState, 2), t2 = _useState2[0], setT = _useState2[1];
  var isMounted = reactExports.useRef(true);
  reactExports.useEffect(function() {
    var bindI18n = i18nOptions.bindI18n, bindI18nStore = i18nOptions.bindI18nStore;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      loadNamespaces(i18n, namespaces, function() {
        if (isMounted.current)
          setT(getT);
      });
    }
    function boundReset() {
      if (isMounted.current)
        setT(getT);
    }
    if (bindI18n && i18n)
      i18n.on(bindI18n, boundReset);
    if (bindI18nStore && i18n)
      i18n.store.on(bindI18nStore, boundReset);
    return function() {
      isMounted.current = false;
      if (bindI18n && i18n)
        bindI18n.split(" ").forEach(function(e3) {
          return i18n.off(e3, boundReset);
        });
      if (bindI18nStore && i18n)
        bindI18nStore.split(" ").forEach(function(e3) {
          return i18n.store.off(e3, boundReset);
        });
    };
  }, [i18n, namespaces.join()]);
  var isInitial = reactExports.useRef(true);
  reactExports.useEffect(function() {
    if (isMounted.current && !isInitial.current) {
      setT(getT);
    }
    isInitial.current = false;
  }, [i18n]);
  var ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready)
    return ret;
  if (!ready && !useSuspense)
    return ret;
  throw new Promise(function(resolve) {
    loadNamespaces(i18n, namespaces, function() {
      resolve();
    });
  });
}
var _excluded$8 = ["forwardedRef"];
function ownKeys$7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function withTranslation(ns2) {
  var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function Extend(WrappedComponent) {
    function I18nextWithTranslation(_ref3) {
      var forwardedRef = _ref3.forwardedRef, rest = _objectWithoutProperties(_ref3, _excluded$8);
      var _useTranslation = useTranslation(ns2, rest), _useTranslation2 = _slicedToArray(_useTranslation, 3), t2 = _useTranslation2[0], i18n = _useTranslation2[1], ready = _useTranslation2[2];
      var passDownProps = _objectSpread$7(_objectSpread$7({}, rest), {}, {
        t: t2,
        i18n,
        tReady: ready
      });
      if (options2.withRef && forwardedRef) {
        passDownProps.ref = forwardedRef;
      } else if (!options2.withRef && forwardedRef) {
        passDownProps.forwardedRef = forwardedRef;
      }
      return React.createElement(WrappedComponent, passDownProps);
    }
    I18nextWithTranslation.displayName = "withI18nextTranslation(".concat(getDisplayName(WrappedComponent), ")");
    I18nextWithTranslation.WrappedComponent = WrappedComponent;
    var forwardRef = function forwardRef2(props, ref) {
      return React.createElement(I18nextWithTranslation, Object.assign({}, props, {
        forwardedRef: ref
      }));
    };
    return options2.withRef ? React.forwardRef(forwardRef) : I18nextWithTranslation;
  };
}
function I18nextProvider(_ref3) {
  var i18n = _ref3.i18n, defaultNS = _ref3.defaultNS, children2 = _ref3.children;
  var value = reactExports.useMemo(function() {
    return {
      i18n,
      defaultNS
    };
  }, [i18n, defaultNS]);
  return reactExports.createElement(I18nContext.Provider, {
    value
  }, children2);
}
/**
 * @remix-run/router v1.0.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options2);
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location) {
  return {
    usr: location.state,
    key: location.key
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$3({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location;
}
function createPath(_ref3) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref3;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function createURL(location) {
  let base3 = typeof window !== "undefined" && typeof window.location !== "undefined" && window.location.origin !== "null" ? window.location.origin : "unknown://unknown";
  let href = typeof location === "string" ? location : createPath(location);
  return new URL(href, base3);
}
function getUrlBasedHistory(getLocation2, createHref, validateLocation, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options2;
  let globalHistory = window2.history;
  let action2 = Action.Pop;
  let listener = null;
  function handlePop() {
    action2 = Action.Pop;
    if (listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  function push(to, state) {
    action2 = Action.Push;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error3) {
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  function replace2(to, state) {
    action2 = Action.Replace;
    let location = createLocation(history.location, to, state);
    if (validateLocation)
      validateLocation(location, to);
    let historyState = getHistoryState(location);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action: action2,
        location: history.location
      });
    }
  }
  let history = {
    get action() {
      return action2;
    },
    get location() {
      return getLocation2(window2, globalHistory);
    },
    listen(fn3) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn3;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    encodeLocation(location) {
      let url = createURL(createPath(location));
      return _extends$3({}, location, {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      });
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i = 0; matches == null && i < branches.length; ++i) {
    matches = matchRouteBranch(
      branches[i],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  routes.forEach((route2, index2) => {
    let meta = {
      relativePath: route2.path || "",
      caseSensitive: route2.caseSensitive === true,
      childrenIndex: index2,
      route: route2
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route2.children && route2.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route2.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route2.children, branches, routesMeta, path);
    }
    if (route2.path == null && !route2.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route2.index),
      routesMeta
    });
  });
  return branches;
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s) => s === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s) => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i) => n2 === b2[i]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i = 0; i < routesMeta.length; ++i) {
    let meta = routesMeta[i];
    let end2 = i === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route2 = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route: route2
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning$p(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/:(\w+)/g, (_24, paramName) => {
    paramNames.push(paramName);
    return "([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error3) {
    warning$p(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error3 + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error3) {
    warning$p(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error3 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function invariant(value, message2) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message2);
  }
}
function warning$p(cond, message2) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message2);
    try {
      throw new Error(message2);
    } catch (e3) {
    }
  }
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field2, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field2 + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$3({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
class ErrorResponse {
  constructor(status2, statusText, data) {
    this.status = status2;
    this.statusText = statusText || "";
    this.data = data;
  }
}
function isRouteErrorResponse(e3) {
  return e3 instanceof ErrorResponse;
}
const validActionMethods = /* @__PURE__ */ new Set(["POST", "PUT", "PATCH", "DELETE"]);
/* @__PURE__ */ new Set(["GET", "HEAD", ...validActionMethods]);
/**
 * React Router v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function isPolyfill(x2, y2) {
  return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
}
const is$1 = typeof Object.is === "function" ? Object.is : isPolyfill;
const {
  useState,
  useEffect,
  useLayoutEffect,
  useDebugValue
} = React$1;
function useSyncExternalStore$2(subscribe2, getSnapshot, getServerSnapshot) {
  const value = getSnapshot();
  const [{
    inst
  }, forceUpdate] = useState({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe2, value, getSnapshot]);
  useEffect(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe2(handleStoreChange);
  }, [subscribe2]);
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is$1(prevValue, nextValue);
  } catch (error3) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe2, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
const canUseDOM$1 = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const isServerEnvironment = !canUseDOM$1;
const shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
"useSyncExternalStore" in React$1 ? ((module) => module.useSyncExternalStore)(React$1) : shim;
const DataStaticRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: []
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    activeRef.current = true;
  });
  let navigate2 = reactExports.useCallback(function(to, options2) {
    if (options2 === void 0) {
      options2 = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options2.relative === "path");
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options2.replace ? navigator2.replace : navigator2.push)(path, options2.state, options2);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate2;
}
function useParams() {
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterStateContext = reactExports.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([parentPathnameBase, match2.pathname]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([parentPathnameBase, match2.pathnameBase])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$2({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorElement() {
  let error3 = useRouteError();
  let message2 = isRouteErrorResponse(error3) ? error3.status + " " + error3.statusText : error3 instanceof Error ? error3.message : JSON.stringify(error3);
  let stack = error3 instanceof Error ? error3.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unhandled Thrown Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message2), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, /* @__PURE__ */ reactExports.createElement("p", null, "💿 Hey developer 👋"), /* @__PURE__ */ reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "errorElement"), " props on ", /* @__PURE__ */ reactExports.createElement("code", {
    style: codeStyles
  }, "<Route>")));
}
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error3) {
    return {
      error: error3
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error3, errorInfo) {
    console.error("React Router caught the following error during render", error3, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    }) : this.props.children;
  }
}
function RenderedRoute(_ref3) {
  let {
    routeContext,
    match: match2,
    children: children2
  } = _ref3;
  let dataStaticRouterContext = reactExports.useContext(DataStaticRouterContext);
  if (dataStaticRouterContext && match2.route.errorElement) {
    dataStaticRouterContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children2);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error3 = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = dataRouterState ? match2.route.errorElement || /* @__PURE__ */ reactExports.createElement(DefaultErrorElement, null) : null;
    let getChildren = () => /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
      match: match2,
      routeContext: {
        outlet,
        matches: parentMatches.concat(renderedMatches.slice(0, index2 + 1))
      }
    }, error3 ? errorElement : match2.route.element !== void 0 ? match2.route.element : outlet);
    return dataRouterState && (match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error3,
      children: getChildren()
    }) : getChildren();
  }, null);
}
var DataRouterHook$1;
(function(DataRouterHook2) {
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterHook$1 || (DataRouterHook$1 = {}));
var DataRouterStateHook$1;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook$1 || (DataRouterStateHook$1 = {}));
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteError() {
  var _state$errors;
  let error3 = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let route2 = reactExports.useContext(RouteContext);
  let thisRoute = route2.matches[route2.matches.length - 1];
  if (error3) {
    return error3;
  }
  !route2 ? invariant(false) : void 0;
  !thisRoute.route.id ? invariant(false) : void 0;
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[thisRoute.route.id];
}
function Route(_props) {
  invariant(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children: children2 = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let location = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      pathname: trailingPathname,
      search,
      hash: hash2,
      state,
      key
    };
  }, [basename, pathname, search, hash2, state, key]);
  if (location == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children: children2,
    value: {
      location,
      navigationType
    }
  }));
}
function Routes(_ref5) {
  let {
    children: children2,
    location
  } = _ref5;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let routes = dataRouterContext && !children2 ? dataRouterContext.router.routes : createRoutesFromChildren(children2);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
new Promise(() => {
});
function createRoutesFromChildren(children2, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children2, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, parentPath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let treePath = [...parentPath, index2];
    let route2 = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      hasErrorBoundary: element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle
    };
    if (element.props.children) {
      route2.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route2);
  });
  return routes;
}
/**
 * React Router DOM v6.4.3
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event2) {
  return !!(event2.metaKey || event2.altKey || event2.ctrlKey || event2.shiftKey);
}
function shouldProcessLinkClick(event2, target) {
  return event2.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event2);
}
const _excluded$7 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
function BrowserRouter(_ref3) {
  let {
    basename,
    children: children2,
    window: window2
  } = _ref3;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  reactExports.useLayoutEffect(() => history.listen(setState), [history]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children: children2,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose(_ref4, _excluded$7);
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event2) {
    if (onClick)
      onClick(event2);
    if (!event2.defaultPrevented) {
      internalOnClick(event2);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$1({}, rest, {
      href,
      onClick: reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to,
    children: children2
  } = _ref5, rest = _objectWithoutPropertiesLoose(_ref5, _excluded2$2);
  let path = useResolvedPath(to, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let toPathname = path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link, _extends$1({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to
  }), typeof children2 === "function" ? children2({
    isActive,
    isPending
  }) : children2);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate2 = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event2) => {
    if (shouldProcessLinkClick(event2, target)) {
      event2.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate2(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate2, path, replaceProp, state, target, to, preventScrollReset, relative]);
}
const useMountedRef = () => {
  const isMountedRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  return isMountedRef;
};
const useSubscribeReset = (subscription) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const subscribe2 = () => {
    return subscription((data) => {
      if (mounted.current) {
        setResponse(data);
      }
    });
  };
  reactExports.useEffect(
    () => subscribe2(),
    // empty dependencies because it's only subscribed once
    []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return [response, () => setResponse(void 0)];
};
const useSubscribe = (subscription) => {
  const [response] = useSubscribeReset(subscription);
  return response;
};
const useLoad = (apiCall, dependencies) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const load = () => {
    if (apiCall === null) {
      return;
    }
    apiCall().then((data) => {
      if (mounted.current) {
        setResponse(data);
      }
    });
  };
  reactExports.useEffect(
    () => load(),
    // By default no dependencies are passed to only query once
    dependencies || []
    // eslint-disable-line react-hooks/exhaustive-deps
  );
  return response;
};
const useSync = (apiCall, subscription) => {
  const [response, setResponse] = reactExports.useState();
  const mounted = useMountedRef();
  const onData = (data) => {
    if (mounted.current) {
      setResponse(data);
    }
  };
  reactExports.useEffect(
    () => {
      apiCall().then(onData);
      return subscription(onData);
    },
    // we pass no dependencies because it's only queried once
    []
  );
  return response;
};
function useDefault(value, defaultValue) {
  return value !== void 0 ? value : defaultValue;
}
const usePrevious = (value) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
};
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
    return call2;
  } else if (call2 !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error(args) {
    this.output("error", args);
  },
  output: function output(type2, args) {
    if (console && console[type2])
      console[type2].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init2(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error3() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix2, debugOnly) {
      if (debugOnly && !this.debug)
        return null;
      if (typeof args[0] === "string")
        args[0] = "".concat(prefix2).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create(moduleName) {
      return new Logger2(this.logger, _objectSpread(_objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }), this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on2(events, listener) {
      var _this = this;
      events.split(" ").forEach(function(event2) {
        _this.observers[event2] = _this.observers[event2] || [];
        _this.observers[event2].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event2, listener) {
      if (!this.observers[event2])
        return;
      if (!listener) {
        delete this.observers[event2];
        return;
      }
      this.observers[event2] = this.observers[event2].filter(function(l2) {
        return l2 !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event2) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event2]) {
        var cloned = [].concat(this.observers[event2]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event2].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise = new Promise(function(resolve, reject2) {
    res = resolve;
    rej = reject2;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy$1(a2, s, t2) {
  a2.forEach(function(m2) {
    if (s[m2])
      t2[m2] = s[m2];
  });
}
function getLastOfPath(object, path, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  var stack = typeof path !== "string" ? [].concat(path) : path.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper())
      return {};
    var key = cleanKey(stack.shift());
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack.shift())
  };
}
function setPath(object, path, newValue) {
  var _getLastOfPath = getLastOfPath(object, path, Object), obj = _getLastOfPath.obj, k2 = _getLastOfPath.k;
  obj[k2] = newValue;
}
function pushPath(object, path, newValue, concat2) {
  var _getLastOfPath2 = getLastOfPath(object, path, Object), obj = _getLastOfPath2.obj, k2 = _getLastOfPath2.k;
  obj[k2] = obj[k2] || [];
  if (concat2)
    obj[k2] = obj[k2].concat(newValue);
  if (!concat2)
    obj[k2].push(newValue);
}
function getPath(object, path) {
  var _getLastOfPath3 = getLastOfPath(object, path), obj = _getLastOfPath3.obj, k2 = _getLastOfPath3.k;
  if (!obj)
    return void 0;
  return obj[k2];
}
function getPathWithDefaults(data, defaultData, key) {
  var value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var chars = [" ", ",", "?", "!", ";"];
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  var possibleChars = chars.filter(function(c2) {
    return nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0;
  });
  if (possibleChars.length === 0)
    return true;
  var r2 = new RegExp("(".concat(possibleChars.map(function(c2) {
    return c2 === "?" ? "\\?" : c2;
  }).join("|"), ")"));
  var matched = !r2.test(key);
  if (!matched) {
    var ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
}
function ownKeys$1$1(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$1$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function deepFind(obj, path) {
  var keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  var paths = path.split(keySeparator);
  var current = obj;
  for (var i = 0; i < paths.length; ++i) {
    if (!current)
      return void 0;
    if (typeof current[paths[i]] === "string" && i + 1 < paths.length) {
      return void 0;
    }
    if (current[paths[i]] === void 0) {
      var j2 = 2;
      var p2 = paths.slice(i, i + j2).join(keySeparator);
      var mix = current[p2];
      while (mix === void 0 && paths.length > i + j2) {
        j2++;
        p2 = paths.slice(i, i + j2).join(keySeparator);
        mix = current[p2];
      }
      if (mix === void 0)
        return void 0;
      if (path.endsWith(p2)) {
        if (typeof mix === "string")
          return mix;
        if (p2 && typeof mix[p2] === "string")
          return mix[p2];
      }
      var joinedPath = paths.slice(i + j2).join(keySeparator);
      if (joinedPath)
        return deepFind(mix, joinedPath, keySeparator);
      return void 0;
    }
    current = current[paths[i]];
  }
  return current;
}
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  var _super = _createSuper$1(ResourceStore2);
  function ResourceStore2(data) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    if (_this.options.ignoreJSONStructure === void 0) {
      _this.options.ignoreJSONStructure = true;
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns2) {
      if (this.options.ns.indexOf(ns2) < 0) {
        this.options.ns.push(ns2);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns2) {
      var index2 = this.options.ns.indexOf(ns2);
      if (index2 > -1) {
        this.options.ns.splice(index2, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var ignoreJSONStructure = options2.ignoreJSONStructure !== void 0 ? options2.ignoreJSONStructure : this.options.ignoreJSONStructure;
      var path = [lng, ns2];
      if (key && typeof key !== "string")
        path = path.concat(key);
      if (key && typeof key === "string")
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
      }
      var result = getPath(this.data, path);
      if (result || !ignoreJSONStructure || typeof key !== "string")
        return result;
      return deepFind(this.data && this.data[lng] && this.data[lng][ns2], key, keySeparator);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns2, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0)
        keySeparator = ".";
      var path = [lng, ns2];
      if (key)
        path = path.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        value = ns2;
        ns2 = path[1];
      }
      this.addNamespaces(ns2);
      setPath(this.data, path, value);
      if (!options2.silent)
        this.emit("added", lng, ns2, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns2, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m2 in resources) {
        if (typeof resources[m2] === "string" || Object.prototype.toString.apply(resources[m2]) === "[object Array]")
          this.addResource(lng, ns2, m2, resources[m2], {
            silent: true
          });
      }
      if (!options2.silent)
        this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns2, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path = [lng, ns2];
      if (lng.indexOf(".") > -1) {
        path = lng.split(".");
        deep = resources;
        resources = ns2;
        ns2 = path[1];
      }
      this.addNamespaces(ns2);
      var pack = getPath(this.data, path) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread$1(_objectSpread$1({}, pack), resources);
      }
      setPath(this.data, path, pack);
      if (!options2.silent)
        this.emit("added", lng, ns2, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns2) {
      if (this.hasResourceBundle(lng, ns2)) {
        delete this.data[lng][ns2];
      }
      this.removeNamespaces(ns2);
      this.emit("removed", lng, ns2);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns2) {
      return this.getResource(lng, ns2) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns2) {
      if (!ns2)
        ns2 = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1")
        return _objectSpread$1(_objectSpread$1({}, {}), this.getResource(lng, ns2));
      return this.getResource(lng, ns2);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "hasLanguageSomeTranslations",
    value: function hasLanguageSomeTranslations(lng) {
      var data = this.getDataByLanguage(lng);
      var n2 = data && Object.keys(data) || [];
      return !!n2.find(function(v2) {
        return data[v2] && Object.keys(data[v2]).length > 0;
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options2, translator) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor])
        value = _this.processors[processor].process(value, key, options2, translator);
    });
    return value;
  }
};
function ownKeys$2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$1$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$1$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  var _super = _createSuper$1$1(Translator2);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy$1(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng)
        this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      if (key === void 0 || key === null) {
        return false;
      }
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0)
        nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS || [];
      var wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
      var seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options2.keySeparator && !this.options.userDefinedNsSeparator && !options2.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
      if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
        var m2 = key.match(this.interpolator.nestingRegexp);
        if (m2 && m2.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
          namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate2(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2)
        options2 = {};
      if (keys === void 0 || keys === null)
        return "";
      if (!Array.isArray(keys))
        keys = [String(keys)];
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          if (!this.options.returnedObjectHandler) {
            this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          }
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, _objectSpread$2(_objectSpread$2({}, options2), {}, {
            ns: namespaces
          })) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m2 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m2)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m2);
              copy2[m2] = this.translate(deepKey, _objectSpread$2(_objectSpread$2({}, options2), {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m2] === deepKey)
                copy2[m2] = res[m2];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res)
          res = this.extendTranslation(res, keys, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count, options2) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var missingKeyNoValueFallbackToKey = options2.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
        var resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk2 = this.resolve(key, _objectSpread$2(_objectSpread$2({}, options2), {}, {
              keySeparator: false
            }));
            if (fk2 && fk2.res)
              this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send2 = function send3(l2, k2, specificDefaultValue) {
            var defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options2);
            }
            _this2.emit("missingKey", l2, namespace, k2, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language2) {
                _this2.pluralResolver.getSuffixes(language2, options2).forEach(function(suffix) {
                  send2([language2], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send2(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
          res = "".concat(namespace, ":").concat(key);
        if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
          if (this.options.compatibilityAPI !== "v1") {
            res = this.options.parseMissingKeyHandler(key, usedDefault ? res : void 0);
          } else {
            res = this.options.parseMissingKeyHandler(res);
          }
        }
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), options2), resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation)
          this.interpolator.init(_objectSpread$2(_objectSpread$2({}, options2), {
            interpolation: _objectSpread$2(_objectSpread$2({}, this.options.interpolation), options2.interpolation)
          }));
        var skipOnVariables = typeof res === "string" && (options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
        var nestBef;
        if (skipOnVariables) {
          var nb2 = res.match(this.interpolator.nestingRegexp);
          nestBef = nb2 && nb2.length;
        }
        var data = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables)
          data = _objectSpread$2(_objectSpread$2({}, this.options.interpolation.defaultVariables), data);
        res = this.interpolator.interpolate(res, data, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft)
            options2.nest = false;
        }
        if (options2.nest !== false)
          res = this.interpolator.nest(res, function() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (lastKey && lastKey[0] === args[0] && !options2.context) {
              _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
              return null;
            }
            return _this3.translate.apply(_this3, args.concat([key]));
          }, options2);
        if (options2.interpolation)
          this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread$2({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string")
        keys = [keys];
      keys.forEach(function(k2) {
        if (_this4.isValidLookup(found))
          return;
        var extracted = _this4.extractFromKey(k2, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS)
          namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsZeroSuffixLookup = needsPluralHandling && !options2.ordinal && options2.count === 0 && _this4.pluralResolver.shouldUseIntlApi();
        var needsContextHandling = options2.context !== void 0 && (typeof options2.context === "string" || typeof options2.context === "number") && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns2) {
          if (_this4.isValidLookup(found))
            return;
          usedNS = ns2;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns2)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found))
              return;
            usedLng = code;
            var finalKeys = [key];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns2, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling)
                pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count, options2);
              var zeroSuffix = "_zero";
              if (needsPluralHandling) {
                finalKeys.push(key + pluralSuffix);
                if (needsZeroSuffixLookup) {
                  finalKeys.push(key + zeroSuffix);
                }
              }
              if (needsContextHandling) {
                var contextKey = "".concat(key).concat(_this4.options.contextSeparator).concat(options2.context);
                finalKeys.push(contextKey);
                if (needsPluralHandling) {
                  finalKeys.push(contextKey + pluralSuffix);
                  if (needsZeroSuffixLookup) {
                    finalKeys.push(contextKey + zeroSuffix);
                  }
                }
              }
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns2, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns2, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource)
        return this.i18nFormat.getResource(code, ns2, key, options2);
      return this.resourceStore.getResource(code, ns2, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix2 = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options2[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string2) {
  return string2.charAt(0).toUpperCase() + string2.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return null;
      var p2 = code.split("-");
      if (p2.length === 2)
        return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x")
        return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0)
        return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2)
            p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2)
            p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1)
            p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1)
            p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes)
        return null;
      var found;
      codes.forEach(function(code) {
        if (found)
          return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng))
          found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found)
            return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly))
            return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0)
              return supportedLng;
          });
        });
      }
      if (!found)
        found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks)
        return [];
      if (typeof fallbacks === "function")
        fallbacks = fallbacks(code);
      if (typeof fallbacks === "string")
        fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
        return fallbacks;
      if (!code)
        return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found)
        found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found)
        found = fallbacks[this.formatLanguageCode(code)];
      if (!found)
        found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found)
        found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c2) {
        if (!c2)
          return;
        if (_this2.isSupportedCode(c2)) {
          codes.push(c2);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c2));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly")
          addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
          addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly")
          addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc2) {
        if (codes.indexOf(fc2) < 0)
          addCode(_this2.formatLanguageCode(fc2));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n2) {
    return Number(n2 > 1);
  },
  2: function _2(n2) {
    return Number(n2 != 1);
  },
  3: function _3(n2) {
    return 0;
  },
  4: function _4(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : n2 == 2 ? 2 : n2 % 100 >= 3 && n2 % 100 <= 10 ? 3 : n2 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n2) {
    return Number(n2 == 1 ? 0 : n2 >= 2 && n2 <= 4 ? 1 : 2);
  },
  7: function _7(n2) {
    return Number(n2 == 1 ? 0 : n2 % 10 >= 2 && n2 % 10 <= 4 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 != 8 && n2 != 11 ? 2 : 3);
  },
  9: function _9(n2) {
    return Number(n2 >= 2);
  },
  10: function _10(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 < 7 ? 2 : n2 < 11 ? 3 : 4);
  },
  11: function _11(n2) {
    return Number(n2 == 1 || n2 == 11 ? 0 : n2 == 2 || n2 == 12 ? 1 : n2 > 2 && n2 < 20 ? 2 : 3);
  },
  12: function _12(n2) {
    return Number(n2 % 10 != 1 || n2 % 100 == 11);
  },
  13: function _13(n2) {
    return Number(n2 !== 0);
  },
  14: function _14(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : n2 == 3 ? 2 : 3);
  },
  15: function _15(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 % 10 >= 2 && (n2 % 100 < 10 || n2 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n2) {
    return Number(n2 % 10 == 1 && n2 % 100 != 11 ? 0 : n2 !== 0 ? 1 : 2);
  },
  17: function _17(n2) {
    return Number(n2 == 1 || n2 % 10 == 1 && n2 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n2) {
    return Number(n2 == 0 ? 0 : n2 == 1 ? 1 : 2);
  },
  19: function _19(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 1 && n2 % 100 < 11 ? 1 : n2 % 100 > 10 && n2 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n2) {
    return Number(n2 == 1 ? 0 : n2 == 0 || n2 % 100 > 0 && n2 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n2) {
    return Number(n2 % 100 == 1 ? 1 : n2 % 100 == 2 ? 2 : n2 % 100 == 3 || n2 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n2) {
    return Number(n2 == 1 ? 0 : n2 == 2 ? 1 : (n2 < 0 || n2 > 10) && n2 % 10 == 0 ? 2 : 3);
  }
};
var deprecatedJsonVersions = ["v1", "v2", "v3"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  var rules = {};
  sets.forEach(function(set) {
    set.lngs.forEach(function(l2) {
      rules[l2] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || this.options.compatibilityJSON === "v4") && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (this.shouldUseIntlApi()) {
        try {
          return new Intl.PluralRules(code, {
            type: options2.ordinal ? "ordinal" : "cardinal"
          });
        } catch (_unused) {
          return;
        }
      }
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options2);
      if (this.shouldUseIntlApi()) {
        return rule && rule.resolvedOptions().pluralCategories.length > 1;
      }
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return this.getSuffixes(code, options2).map(function(suffix) {
        return "".concat(key).concat(suffix);
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var rule = this.getRule(code, options2);
      if (!rule) {
        return [];
      }
      if (this.shouldUseIntlApi()) {
        return rule.resolvedOptions().pluralCategories.sort(function(pluralCategory1, pluralCategory2) {
          return suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2];
        }).map(function(pluralCategory) {
          return "".concat(_this.options.prepend).concat(pluralCategory);
        });
      }
      return rule.numbers.map(function(number) {
        return _this.getSuffix(code, number, options2);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var rule = this.getRule(code, options2);
      if (rule) {
        if (this.shouldUseIntlApi()) {
          return "".concat(this.options.prepend).concat(rule.select(count));
        }
        return this.getSuffixRetroCompatible(rule, count);
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }, {
    key: "getSuffixRetroCompatible",
    value: function getSuffixRetroCompatible(rule, count) {
      var _this2 = this;
      var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
      var suffix = rule.numbers[idx];
      if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        if (suffix === 2) {
          suffix = "plural";
        } else if (suffix === 1) {
          suffix = "";
        }
      }
      var returnSuffix = function returnSuffix2() {
        return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
      };
      if (this.options.compatibilityJSON === "v1") {
        if (suffix === 1)
          return "";
        if (typeof suffix === "number")
          return "_plural_".concat(suffix.toString());
        return returnSuffix();
      } else if (this.options.compatibilityJSON === "v2") {
        return returnSuffix();
      } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
        return returnSuffix();
      }
      return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
    }
  }, {
    key: "shouldUseIntlApi",
    value: function shouldUseIntlApi() {
      return !deprecatedJsonVersions.includes(this.options.compatibilityJSON);
    }
  }]);
  return PluralResolver2;
}();
function ownKeys$3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init2() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation)
        options2.interpolation = {
          escapeValue: true
        };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this.options)
        this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate(str, data, lng, options2) {
      var _this = this;
      var match2;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val) {
        return val.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path = getPathWithDefaults(data, defaultData, key);
          return _this.alwaysFormat ? _this.format(path, void 0, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
            interpolationkey: key
          })) : path;
        }
        var p2 = key.split(_this.formatSeparator);
        var k2 = p2.shift().trim();
        var f2 = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data, defaultData, k2), f2, lng, _objectSpread$3(_objectSpread$3(_objectSpread$3({}, options2), data), {}, {
          interpolationkey: k2
        }));
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables !== void 0 ? options2.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val) {
          return regexSafe(val);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val) {
          return _this.escapeValue ? regexSafe(_this.escape(val)) : regexSafe(val);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match2 = todo.regex.exec(str)) {
          var matchedVar = match2[1].trim();
          value = handleFormat(matchedVar);
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match2, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (options2 && options2.hasOwnProperty(matchedVar)) {
              value = "";
            } else if (skipOnVariables) {
              value = match2[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(matchedVar, " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          var safeValue = todo.safeValue(value);
          str = str.replace(match2[0], safeValue);
          if (skipOnVariables) {
            todo.regex.lastIndex += safeValue.length;
            todo.regex.lastIndex -= match2[0].length;
          } else {
            todo.regex.lastIndex = 0;
          }
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc2) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match2;
      var value;
      var clonedOptions = _objectSpread$3({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0)
          return key;
        var c2 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c2[1]);
        key = c2[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions)
            clonedOptions = _objectSpread$3(_objectSpread$3({}, inheritedOptions), clonedOptions);
        } catch (e3) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e3);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match2 = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match2[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match2[1])) {
          var r2 = match2[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match2[1] = r2.shift();
          formatters = r2;
          doReduce = true;
        }
        value = fc2(handleHasOptions.call(this, match2[1].trim(), clonedOptions), clonedOptions);
        if (value && match2[0] === str && typeof value !== "string")
          return value;
        if (typeof value !== "string")
          value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match2[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v2, f2) {
            return _this2.format(v2, f2, options2.lng, _objectSpread$3(_objectSpread$3({}, options2), {}, {
              interpolationkey: match2[1].trim()
            }));
          }, value.trim());
        }
        str = str.replace(match2[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function ownKeys$4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function parseFormatStr(formatStr) {
  var formatName = formatStr.toLowerCase().trim();
  var formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    var p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    var optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      var opts = optStr.split(";");
      opts.forEach(function(opt) {
        if (!opt)
          return;
        var _opt$split = opt.split(":"), _opt$split2 = _toArray(_opt$split), key = _opt$split2[0], rest = _opt$split2.slice(1);
        var val = rest.join(":");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val.trim();
        if (val.trim() === "false")
          formatOptions[key.trim()] = false;
        if (val.trim() === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val.trim()))
          formatOptions[key.trim()] = parseInt(val.trim(), 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
var Formatter = function() {
  function Formatter2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Formatter2);
    this.logger = baseLogger.create("formatter");
    this.options = options2;
    this.formats = {
      number: function number(val, lng, options3) {
        return new Intl.NumberFormat(lng, options3).format(val);
      },
      currency: function currency2(val, lng, options3) {
        return new Intl.NumberFormat(lng, _objectSpread$4(_objectSpread$4({}, options3), {}, {
          style: "currency"
        })).format(val);
      },
      datetime: function datetime(val, lng, options3) {
        return new Intl.DateTimeFormat(lng, _objectSpread$4({}, options3)).format(val);
      },
      relativetime: function relativetime(val, lng, options3) {
        return new Intl.RelativeTimeFormat(lng, _objectSpread$4({}, options3)).format(val, options3.range || "day");
      },
      list: function list2(val, lng, options3) {
        return new Intl.ListFormat(lng, _objectSpread$4({}, options3)).format(val);
      }
    };
    this.init(options2);
  }
  _createClass(Formatter2, [{
    key: "init",
    value: function init2(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var iOpts = options2.interpolation;
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    }
  }, {
    key: "add",
    value: function add(name, fc2) {
      this.formats[name.toLowerCase().trim()] = fc2;
    }
  }, {
    key: "format",
    value: function format(value, _format, lng, options2) {
      var _this = this;
      var formats = _format.split(this.formatSeparator);
      var result = formats.reduce(function(mem, f2) {
        var _parseFormatStr = parseFormatStr(f2), formatName = _parseFormatStr.formatName, formatOptions = _parseFormatStr.formatOptions;
        if (_this.formats[formatName]) {
          var formatted = mem;
          try {
            var valOptions = options2 && options2.formatParams && options2.formatParams[options2.interpolationkey] || {};
            var l2 = valOptions.locale || valOptions.lng || options2.locale || options2.lng || lng;
            formatted = _this.formats[formatName](mem, l2, _objectSpread$4(_objectSpread$4(_objectSpread$4({}, formatOptions), options2), valOptions));
          } catch (error3) {
            _this.logger.warn(error3);
          }
          return formatted;
        } else {
          _this.logger.warn("there was no format function for ".concat(formatName));
        }
        return mem;
      }, value);
      return result;
    }
  }]);
  return Formatter2;
}();
function ownKeys$5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function remove(arr, what) {
  var found = arr.indexOf(what);
  while (found !== -1) {
    arr.splice(found, 1);
    found = arr.indexOf(what);
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  var _super = _createSuper$2(Connector2);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages, namespaces, options2, callback2) {
      var _this2 = this;
      var toLoad = [];
      var pending2 = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns2) {
          var name = "".concat(lng, "|").concat(ns2);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns2)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0)
            ;
          else if (_this2.state[name] === 1) {
            if (pending2.indexOf(name) < 0)
              pending2.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending2.indexOf(name) < 0)
              pending2.push(name);
            if (toLoad.indexOf(name) < 0)
              toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns2) < 0)
              toLoadNamespaces.push(ns2);
          }
        });
        if (!hasAllNamespaces)
          toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending2.length) {
        this.queue.push({
          pending: pending2,
          loaded: {},
          errors: [],
          callback: callback2
        });
      }
      return {
        toLoad,
        pending: pending2,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err, data) {
      var s = name.split("|");
      var lng = s[0];
      var ns2 = s[1];
      if (err)
        this.emit("failedLoading", lng, ns2, err);
      if (data) {
        this.store.addResourceBundle(lng, ns2, data);
      }
      this.state[name] = err ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q2) {
        pushPath(q2.loaded, [lng], ns2);
        remove(q2.pending, name);
        if (err)
          q2.errors.push(err);
        if (q2.pending.length === 0 && !q2.done) {
          Object.keys(q2.loaded).forEach(function(l2) {
            if (!loaded2[l2])
              loaded2[l2] = [];
            if (q2.loaded[l2].length) {
              q2.loaded[l2].forEach(function(ns3) {
                if (loaded2[l2].indexOf(ns3) < 0)
                  loaded2[l2].push(ns3);
              });
            }
          });
          q2.done = true;
          if (q2.errors.length) {
            q2.callback(q2.errors);
          } else {
            q2.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q2) {
        return !q2.done;
      });
    }
  }, {
    key: "read",
    value: function read(lng, ns2, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback2 = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length)
        return callback2(null, {});
      return this.backend[fcName](lng, ns2, function(err, data) {
        if (err && data && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns2, fcName, tried + 1, wait2 * 2, callback2);
          }, wait2);
          return;
        }
        callback2(err, data);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback2 = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback2 && callback2();
      }
      if (typeof languages === "string")
        languages = this.languageUtils.toResolveHierarchy(languages);
      if (typeof namespaces === "string")
        namespaces = [namespaces];
      var toLoad = this.queueLoad(languages, namespaces, options2, callback2);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length)
          callback2();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {}, callback2);
    }
  }, {
    key: "reload",
    value: function reload(languages, namespaces, callback2) {
      this.prepareLoading(languages, namespaces, {
        reload: true
      }, callback2);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns2 = s[1];
      this.read(lng, ns2, "read", void 0, void 0, function(err, data) {
        if (err)
          _this5.logger.warn("".concat(prefix2, "loading namespace ").concat(ns2, " for language ").concat(lng, " failed"), err);
        if (!err && data)
          _this5.logger.log("".concat(prefix2, "loaded namespace ").concat(ns2, " for language ").concat(lng), data);
        _this5.loaded(name, err, data);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "")
        return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages, namespace, key, fallbackValue, null, _objectSpread$5(_objectSpread$5({}, options2), {}, {
          isUpdate
        }));
      }
      if (!languages || !languages[0])
        return;
      this.store.addResource(languages[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string")
    options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string")
    options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string")
    options2.fallbackNS = [options2.fallbackNS];
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function ownKeys$6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function noop$1() {
}
function bindMemberFunctions(inst) {
  var mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach(function(mem) {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  var _super = _createSuper$3(I18n2);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback2 = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _super.call(this);
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    bindMemberFunctions(_assertThisInitialized(_this));
    if (callback2 && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback2);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback2);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init2() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback2 = options2;
        options2 = {};
      }
      if (!options2.defaultNS && options2.ns) {
        if (typeof options2.ns === "string") {
          options2.defaultNS = options2.ns;
        } else if (options2.ns.indexOf("translation") < 0) {
          options2.defaultNS = options2.ns[0];
        }
      }
      var defOpts = get();
      this.options = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, defOpts), this.options), transformOptions(options2));
      if (this.options.compatibilityAPI !== "v1") {
        this.options.interpolation = _objectSpread$6(_objectSpread$6({}, defOpts.interpolation), this.options.interpolation);
      }
      if (options2.keySeparator !== void 0) {
        this.options.userDefinedKeySeparator = options2.keySeparator;
      }
      if (options2.nsSeparator !== void 0) {
        this.options.userDefinedNsSeparator = options2.nsSeparator;
      }
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject)
          return null;
        if (typeof ClassOrObject === "function")
          return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var formatter;
        if (this.modules.formatter) {
          formatter = this.modules.formatter;
        } else if (typeof Intl !== "undefined") {
          formatter = Formatter;
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
          s.formatter = createClassOnDemand(formatter);
          s.formatter.init(s, this.options);
          this.options.interpolation.format = s.formatter.format.bind(s.formatter);
        }
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event2) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init)
            s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event2) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event2].concat(args));
        });
        this.modules.external.forEach(function(m2) {
          if (m2.init)
            m2.init(_this2);
        });
      }
      this.format = this.options.interpolation.format;
      if (!callback2)
        callback2 = noop$1;
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev")
          this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish2 = function finish3(err, t2) {
          if (_this2.isInitialized && !_this2.initializedStoreOnce)
            _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone)
            _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t2);
          callback2(err, t2);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized)
          return finish2(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish2);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language2) {
      var _this3 = this;
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
      var usedCallback = callback2;
      var usedLng = typeof language2 === "string" ? language2 : this.language;
      if (typeof language2 === "function")
        usedCallback = language2;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode")
          return usedCallback();
        var toLoad = [];
        var append2 = function append3(lng) {
          if (!lng)
            return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l2) {
            if (toLoad.indexOf(l2) < 0)
              toLoad.push(l2);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l2) {
            return append2(l2);
          });
        } else {
          append2(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l2) {
            return append2(l2);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, function(e3) {
          if (!e3 && !_this3.resolvedLanguage && _this3.language)
            _this3.setResolvedLanguage(_this3.language);
          usedCallback(e3);
        });
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns2, callback2) {
      var deferred = defer();
      if (!lngs)
        lngs = this.languages;
      if (!ns2)
        ns2 = this.options.ns;
      if (!callback2)
        callback2 = noop$1;
      this.services.backendConnector.reload(lngs, ns2, function(err) {
        deferred.resolve();
        callback2(err);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module)
        throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type)
        throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "formatter") {
        this.modules.formatter = module;
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "setResolvedLanguage",
    value: function setResolvedLanguage(l2) {
      if (!l2 || !this.languages)
        return;
      if (["cimode", "dev"].indexOf(l2) > -1)
        return;
      for (var li2 = 0; li2 < this.languages.length; li2++) {
        var lngInLngs = this.languages[li2];
        if (["cimode", "dev"].indexOf(lngInLngs) > -1)
          continue;
        if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
          this.resolvedLanguage = lngInLngs;
          break;
        }
      }
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback2) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var setLngProps = function setLngProps2(l2) {
        _this4.language = l2;
        _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l2);
        _this4.resolvedLanguage = void 0;
        _this4.setResolvedLanguage(l2);
      };
      var done = function done2(err, l2) {
        if (l2) {
          setLngProps(l2);
          _this4.translator.changeLanguage(l2);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l2);
          _this4.logger.log("languageChanged", l2);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback2)
          callback2(err, function() {
            return _this4.t.apply(_this4, arguments);
          });
      };
      var setLng = function setLng2(lngs) {
        if (!lng && !lngs && _this4.services.languageDetector)
          lngs = [];
        var l2 = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l2) {
          if (!_this4.language) {
            setLngProps(l2);
          }
          if (!_this4.translator.language)
            _this4.translator.changeLanguage(l2);
          if (_this4.services.languageDetector)
            _this4.services.languageDetector.cacheUserLanguage(l2);
        }
        _this4.loadResources(l2, function(err) {
          done(err, l2);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns2, keyPrefix) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread$6({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        var keySeparator = _this5.options.keySeparator || ".";
        var resultKey = keyPrefix ? "".concat(keyPrefix).concat(keySeparator).concat(key) : key;
        return _this5.t(resultKey, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns2;
      fixedT.keyPrefix = keyPrefix;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t2() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns2) {
      this.options.defaultNS = ns2;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace2(ns2) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.resolvedLanguage || this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode")
        return true;
      var loadNotPending = function loadNotPending2(l2, n2) {
        var loadState = _this6.services.backendConnector.state["".concat(l2, "|").concat(n2)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0)
          return preResult;
      }
      if (this.hasResourceBundle(lng, ns2))
        return true;
      if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
        return true;
      if (loadNotPending(lng, ns2) && (!fallbackLng || loadNotPending(lastLng, ns2)))
        return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces2(ns2, callback2) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback2 && callback2();
        return Promise.resolve();
      }
      if (typeof ns2 === "string")
        ns2 = [ns2];
      ns2.forEach(function(n2) {
        if (_this7.options.ns.indexOf(n2) < 0)
          _this7.options.ns.push(n2);
      });
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback2) {
      var deferred = defer();
      if (typeof lngs === "string")
        lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback2)
          callback2();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err) {
        deferred.resolve();
        if (callback2)
          callback2(err);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng)
        lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
      if (!lng)
        return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop$1;
      var mergedOptions = _objectSpread$6(_objectSpread$6(_objectSpread$6({}, this.options), options2), {
        isClone: true
      });
      var clone = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m2) {
        clone[m2] = _this8[m2];
      });
      clone.services = _objectSpread$6({}, this.services);
      clone.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      clone.translator = new Translator(clone.services, clone.options);
      clone.translator.on("*", function(event2) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone.emit.apply(clone, [event2].concat(args));
      });
      clone.init(mergedOptions, callback2);
      clone.translator.options = clone.options;
      clone.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
      };
      return clone;
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        options: this.options,
        store: this.store,
        language: this.language,
        languages: this.languages,
        resolvedLanguage: this.resolvedLanguage
      };
    }
  }]);
  return I18n2;
}(EventEmitter);
_defineProperty(I18n, "createInstance", function() {
  var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var callback2 = arguments.length > 1 ? arguments[1] : void 0;
  return new I18n(options2, callback2);
});
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
var t$1 = instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const getNativeLocale = () => {
  return apiGet("native-locale");
};
const account$i = {
  disconnect: "انقطع الاتصال. جاري اعادة المحاولة...",
  "export": "تصدير",
  exportTransactions: "تصدير التداولات الى مجلد الداونلود على شكل ملف CSV",
  fatalError: "حدث خطأ غير متوقع",
  incoming: "قادمة الآن",
  initializing: "جلب البيانات من البلوكشين...",
  maybeProxyError: "تم تفعيل بروكسي تور. يرجى التأكد من ان بروكسي تور يعمل بشكل صحيح او قم بايقاف اعدادات البروكسي",
  reconnecting: "انقطع الاتصال, جاري محاولة اعادة الاتصال...",
  syncedAddressesCount: "تم فحص {{count}} عنوان"
};
const accountInfo$i = {
  address: "عنوان",
  buyCTA: {
    buy: "شراء {{unit}}",
    buyCrypto: "شراء كريبتو",
    information: {
      looksEmpty: "يبدو ان هذه المحفظة فارغة",
      start: "إبدأ عن طريق ايداع بعض العملات في المحفظة او شراء العملات مباشرةً في تطبيق BitBoxApp"
    }
  },
  extendedPublicKey: "المفتاح العام المتشعب",
  label: "معلومات الحساب",
  scriptType: "نوع النص البرمجي",
  title: "معلومات الحساب",
  verify: "قم بالتأكيد عن طريق الجهاز",
  xpubTypeChangeBtn: {
    p2pkh: "عرض المفتاح العام المتشعب عن طريق P2PKH القديم",
    p2tr: "عرض تابروت",
    p2wpkh: "عرض Segwit الاصلي",
    "p2wpkh-p2sh": "عرض المفتاح العام المتشعب عن طريق Segwit القديم"
  },
  xpubTypeInfo: "الآن يتم عرض {{scriptType}} للمفتاح العلني المتشعب ({{current}} من {{numberOfXPubs}})"
};
const accountSummary$i = {
  availableBalance: "الرصيد المتبقي",
  balance: "الرصيد",
  exportSummary: "قم بتصدير خلاصة الحسابات الى مجلد الداونلود على شكل ملف CSV",
  fiatBalance: "رصيد العملة النقدية",
  name: "اسم الحساب",
  noAccount: "لا توجد حسابات للعرض",
  subtotalWithCoinName: "مجموع ({{coinName}})",
  title: "بورتفوليو حسابي",
  total: "المجموع",
  transactionHistory: "تاريخ التداولات"
};
const addAccount$j = {
  chooseName: {
    nextButton: "اضافة حساب",
    step: "تسمية الحساب",
    title: "قم بتسمية الحساب"
  },
  selectCoin: {
    nextButton: "التالي",
    step: "اختر عملة",
    title: "اختر عملة كريبتو"
  },
  success: {
    message: "تمت اضافة <strong>{{accountName}}</strong> الى حساباتك",
    nextButton: "اكتمل",
    step: "انتهى",
    title: "تم اضافة الحساب"
  },
  title: "اضافة حساب"
};
const aopp$c = {
  addressRequest: "الـ{{host}} يطلب عنوان استلام",
  addressRequestWithLogo: "يطلب عنوان استلام",
  banner: "جاري طلب عنوان",
  errorTitle: "حدث خطأ اثناء عملية طلب العنوان",
  labelAddress: "عنوان",
  labelMessage: "رسالة",
  reverifyInfoText: "تأكيد العنوان",
  signing: "للاستمرار, قم بتوقيع الرسالة على جهاز BitBox02",
  success: {
    message: "استمر على {{host}}",
    title: "تم ارسال العنوان بنجاح"
  },
  syncing: "يتم الآن عمل مزامنة للحساب, يرجى الانتظار",
  title: "طلب عنوان"
};
const app$i = {
  upgrade: "تتوفر الآن نسخة جديدة لهذا التطبيق. يرجى التحديث من {{current}} الى {{version}}"
};
const backup$i = {
  check: {
    checking: "التحقق من النسخة الاحتياطية...",
    confirmTitle: "قم بالتحقق من النسخة الاحتياطية",
    notOK: "النسخة الاحتياطية لا تطابق المحفظة",
    ok: "النسخة الاحتياطية تطابق المحفظة",
    password: {
      label: "استعادة كلمة المرور",
      placeholder: "استعادة كلمة المرور",
      showLabel: "استعادة كلمة المرور"
    },
    success: "تم التأكد بنجاح من النسخة الاحتياطية",
    title: "قم بالتحقق من النسخة الاحتياطية"
  },
  create: {
    alreadyExists: "يوجد لديك نسخة احتياطية صالحة, هل تريد انشاء نسخة جديدة؟",
    fail: "فشلت عملية انشاء نسخة احتياطية",
    info: "يرجى ادخال كلمة استعادة المرور لهذه المحفظة من اجل التحقق",
    name: {
      label: "اسم النسخة الاحتياطية",
      placeholder: "يرجى تسمية النسخة الاحتياطية"
    },
    password: {
      label: "استعادة كلمة المرور",
      placeholder: "يرجى ادخال كلمة استعادة المرور"
    },
    title: "قم بانشاء نسخة الاحتياطية",
    verificationFailed: "كلمة استعادة المرور لا تطابق هذه المحفظة. تم انشاء النسخة الاحتياطية. يرجى استخدام ‘التحقق من النسخة الاحتياطية‘ لتأكيد كلمة استعادة المرور مرة ثانية"
  },
  description: "اختر<strong>ملف النسخة الاحتياطية للمحفظة</strong>",
  insert: "قم بادخال شريحة microSD لإدارة النسخ الاحتياطية",
  insertButton: "لقد قمت بإدخال شريحة microSD",
  list: "هذه النسخ الاحتياطية في شريحة microSD الخاصة بك",
  noBackups: "لا توجد نسخ احتياطية في هذه الشريحة microSD",
  restore: {
    confirmTitle: "استرجاع النسخة الاحتياطية",
    error: {
      e200: "لا توجد شريحة microSD",
      general: "حدث خطأ عند عملية استرجاع النسخة الاحتياطية"
    },
    password: {
      label: "كلمة استعادة المرور او كلمة استعادة المرور المخفية",
      placeholder: "كلمة استعادة المرور",
      repeatPlaceholder: "تكرار كلمة استعادة المرور",
      showLabel: "كلمة استعادة المرور"
    },
    restoring: "استرجاع النسخة الاحتياطية...",
    selectedBackup: "<strong>{{backupName}}</strong> تم انشاءها في {{createdDateTime}} سيتم استرجاعها",
    title: "استرجاع",
    understand: "انا افهم ان ادخال كلمة استعادة مرور خاطئة يعني انشاء محفظة مختلفة"
  },
  showMnemonic: {
    description: "سيتم إظهار ٢٤ كلمة استرجاع لك, و هذه الكلمات تمثل النسخة الاحتياطية لمحفظتك. قم بكتابة هذه الكلمات على الورق\n<strong> لا تقم بخزن الكلمات بشكل رقمي و لا تأخذ صورة للكلمات</strong>\n<strong> لا تقم بالنطق الشفوي بصوت مسموع للكلمات</strong>\n<strong>هذه النسخة الاحتياطية ليست محمية بكلمة مرور</strong>\nبعد ذلك سيتم سؤالك لتأكيد كل كلمة",
    title: "اظهار كلمات الاسترجاع"
  },
  title: "ادارة النسخ الاحتياطية"
};
const bb02Bootloader$i = {
  abort: "لا تقم بالتحديث - اود الرجوع",
  abort_noUpgrade: "اريد الرجوع",
  advanced: {
    label: "اعدادات متقدمة",
    toggleShowFirmwareHash: "قم بإظهار هاش البرنامج المثبت عند كل تشغيل للتطبيق\n"
  },
  flipscreen: "قلب الشاشة",
  orientation: "هل تم وضع الجهاز في الاتجاه الخاطئ؟",
  success: "التحديث تم بنجاح! سيتم الاستمرار خلال {{rebootSeconds}} ثانية...",
  success_install: "التثبيت تم بنجاح! سيتم الاستمرار خلال {{rebootSeconds}} ثانية..."
};
const bitbox$i = {
  error: {
    e10000: "كلمة المرور الحالية للجهاز خاطئة",
    e10001: "فشلت محاولة استبدال كلمة المرور للجهاز",
    e102: "يجب ان تحتوي كلمة المرور على ٤ رموز على الاقل",
    e112: "لا يمكن لكلمة المرور المخفية للجهاز ان تكون نفس كلمة المرور الرئيسية للجهاز"
  }
};
const bitbox02Interact$i = {
  confirmDate: "قم بتأكيد تاريخ اليوم في جهازك BitBox02",
  confirmDateText: "سيتم استخدام هذا التاريخ لإنشاء النسخة الاحتياطية",
  confirmName: "قم بتأكيد الاسم في جهاز BitBox02",
  followInstructions: "يرجى اتباع التعليمات في جهاز BitBox02",
  followInstructionsMnemonic: "قم بإتباع التعليمات في جهازك BitBox02 من اجل ادخال كلمات الاسترجاع من النسخة الاحتياطية و استعادة محفظتك",
  followInstructionsMnemonicTitle: "قم بالاستعادة من خلال كلمات الاسترجاع"
};
const bitbox02Settings$i = {
  deviceName: {
    current: "اسم الجهاز الحالي",
    input: "اسم الـBitBox02",
    placeholder: "اسم جهاز جديد",
    title: "قم باختيار اسم BitBox02"
  },
  gotoStartupSettings: {
    description: "هذا الشي سيقوم بإعادة تشغيل جهاز BitBox02 و الدخول الى اعدادات بدء التشغيل",
    title: "إذهب الى اعدادات بدء التشغيل"
  }
};
const bitbox02Wizard$i = {
  attestationFailed: "التحقق الاصلي قد فشل, مما قد يكون بسبب اعادة تشغيل التطبيق اثناء انتظار الجهاز لإدخال البيانات من المستخدم. يرجى اعادة الربط و المحاولة مجدداً. يرجى الاتصال عن طريق support@shiftcrypto.ch اذا تكررت المشكلة باستمرار",
  backup: {
    point1: "قم باختيار نسخة احتياطية من شريحة microSD",
    point2: "قم باختيار كلمة مرور لجهازك",
    restoreText: "حسناً لنبدأ باستعادة نسخة احتياطية",
    text1: "ممتاز, تم تثبيت كلمة المرور لجهازك BitBox02 و صنع المحفظة. الآن حان وقت انشاء اول نسخة احتياطية. يرجى التأكد من ادخال شريحة microSD في جهازك BitBox02 و الاستمرار",
    text2: "يرجى اتباع التعليمات التي تظهر على الشاشة على جهازك لإنشاء نسخة احتياطية",
    text3: "بعد إنشاء النسخة الاحتياطية، يرجى إزالة شريحة microSD خزنها في <strong>مكان آمن</strong>. محتويات شريحة microSD ليست محمية بكلمة مرور. لا تقم ابداً بإدخال الشريحة في اي جهاز آخر غير BitBox02 الخاص بك.",
    userConfirmation1: "يجب أن أقوم بتخزين النسخة الاحتياطية الخاصة بي في مكان آمن",
    userConfirmation2: "النسخة الاحتياطية الخاصة بي ليست محمية بكلمة مرور. يمكن لأي شخص قادر على الحصول على النسخة الاحتياطية من الدخول الى محفظتي",
    userConfirmation3: "إذا اضعت أو أتلفت جهاز BitBox02 فإن الطريقة الوحيدة لاسترداد أموالي هي عن طريق الاستعادة من النسخة الاحتياطية الخاصة بي",
    userConfirmation4: "إذا اضعت أو أتلفت كلاً من النسخة الاحتياطية و جهاز BitBox02 الخاصة بي فسأفقد أموالي",
    userConfirmation5: "يجب أن لا أقوم بإدخال النسخة الاحتياطية لشريحة microSD في جهاز كمبيوتر أو هاتف أو طابعة أو أي جهاز آخر غير BitBox02"
  },
  create: {
    button: "قم بتسمية الجهاز ثم الاستمرار",
    info: "فيما يلي الخطوات الأساسية التي ستتبعها من اجل إعداد BitBox الخاص بك: ",
    inputTitle: "اسم المحفظة",
    point1: "قم بتسمية جهازك",
    point2: "قم بتعيين كلمة مرور لجهازك",
    point3: "قم بإنشاء نسخة احتياطية",
    text: "حسنًا ، لنقم بإنشاء محفظة جديدة"
  },
  createBackupFailed: "فشل إنشاء نسخة احتياطية ، حاول مرة أخرى",
  initialize: {
    passwordText: "لنقم الآن بتعيين كلمة مرور لجهازك. استخدم ازرار التحكم في BitBox لإدخال كلمة مرور",
    passwordTitle: "قم بتعيين كلمة مرور لـ BitBox الخاص بك",
    text: "تم بنجاح ربط جهازك BitBox02 الخاص بك! لنبدأ الآن في تهيئة جهازك. ابدأ باختيار إنشاء محفظة جديدة، أو استعادة محفظة من نسخة احتياطية موجودة. <strong>يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك</strong>",
    tip: "نوصي بالاستمرار في مكان آمن",
    title: "قم بتهيئة BitBox الخاص بك"
  },
  insertSDCard: "<strong>يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك.</strong>",
  noPasswordMatch: "كلمات المرور غير متطابقة. حاول مرة اخرى",
  pairing: {
    failed: "لم يتم تأكيد الربط. يرجى إعادة توصيل BitBox02 الخاص بك",
    paired: "لقد قمت بالتأكيد على جهازك أن الرمز مطابق. إذا كان هذا صحيحًا يمكنك المتابعة بالكبس على الزر أدناه",
    title: "قم بتأكيد رمز الربط",
    unpaired: "تم اكتشاف BitBox02 جديد. يرجى التحقق من أن الكود التالي يطابق ما هو معروض على شاشة جهازك. قم بالكبس باللمس أسفل علامة الاختيار الموجودة على BitBox02 الخاص بك إذا تطابق الرمز، ثم اكبس فوق الزر أدناه للاستمرار"
  },
  restoreFromMnemonic: {
    failed: "فشلت الاستعادة من كلمات الاسترداد ، يرجى المحاولة مرة أخرى"
  },
  stepBackup: {
    beforeProceed: "قبل الاستمرار، يرجى قراءة هذه الاعتبارات الأمنية الهامة:",
    createBackup: "ستقوم الآن بإنشاء نسخة احتياطية على شريحة microSD الخاصة بك"
  },
  stepBackupSuccess: {
    fundsSafe: "للحفاظ على أموالك آمنة، يجب التذكير بما يلي:",
    title: "تمت استعادة النسخة الاحتياطية بنجاح"
  },
  stepConnected: {
    unlock: "أدخل كلمة مرور BitBox02 من اجل الدخول"
  },
  stepCreate: {
    description: "يتم استخدام هذا الاسم للجهاز و ايضاً للنسخة الاحتياطية",
    nameLabel: "اسم جهاز الـBitBox02",
    namePlaceholder: "جهازي الـBitBox02",
    title: "قم باختيار اسم لجهاز BitBox02",
    toastMicroSD: "يرجى التأكد من إدخال شريحة microSD في BitBox02 الخاص بك"
  },
  stepCreateSuccess: {
    removeMicroSD: "يرجى إزالة شريحة microSD من BitBox02 وتخزينها في مكان آمن",
    success: "لقد نجحت في إنشاء نسختك الاحتياطية"
  },
  stepInsertSD: {
    insertSDCard: "الرجاء إدخال شريحة microSD في BitBox02 للاستمرار",
    insertSDcardTitle: "قم بإدخال شريحة microSD"
  },
  stepPassword: {
    title: "قم باختيار كلمة مرور BitBox02",
    useControls: "استخدم ازرار التحكم في جهاز BitBox02 لاختيار كلمة مرور"
  },
  stepUninitialized: {
    create: "أرغب في إعداد BitBox02 جديد",
    restore: "أريد استعادة محفظتي من نسخة احتياطية",
    restoreMicroSD: "الاستعادة من شريحة microSD",
    restoreMnemonic: "استعادة من كلمات الاسترجاع",
    title: "قم بإعداد BitBox02 الخاص بك"
  },
  success: {
    text: "ممتاز! أصبح BitBox02 جاهزًا للاستخدام الآن\n\nلمزيد من المعلومات حول كيفية استخدام تطبيق BitBox ، يرجى استخدام دليل التطبيق عن طريق الكبس فوق علامة الاستفهام في الزاوية اليمنى في الاعلى",
    title: "انت جاهز الآن"
  }
};
const blink$i = {
  button: "رمش"
};
const bootloader$i = {
  button: "قم بتحديث البرنامج الثابت الآن",
  button_install: "قم بتثبيت البرنامج الثابت الآن",
  progress: "التحديث: {{progress}}٪",
  progress_install: "التثبيت: {{progress}}٪",
  success: "تم التحديث بنجاح! يرجى إعادة توصيل الجهاز. و هذه المرة، لا تلمس الزر"
};
const button$n = {
  abort: "الايقاف",
  back: "العودة",
  buy: "الشراء",
  changepin: "قم بتغيير كلمة مرور الجهاز",
  check: "قم بالتحقق من النسخة الاحتياطية",
  "continue": "الاستمرار",
  copy: "النسخ",
  create: "الانشاء",
  dismiss: "رفض",
  done: "اكتمل",
  download: "تحميل",
  hiddenwallet: "إنشاء محفظة مخفية",
  next: "التالي",
  ok: "حسناً",
  previous: "سابق",
  receive: "استلام",
  restore: "استرجاع",
  select: "اختر",
  send: "إرسال",
  unlock: "فتح القفل",
  update: "تحديث",
  upgrade: "تحديث النسخة"
};
const buy$e = {
  info: {
    "continue": "الموافقة و الاستمرار",
    crypto: "كريبتو",
    disclaimer: {
      intro: [
        "لدينا شراكة مع MoonPay لنقدم لك طريقة سلسة لشراء {{name}} مباشرة داخل تطبيق BitBox. العملية تستغرق خطوات قليلة",
        "منصة MoonPay  تجعل شراء {{name}} سهلاً وسريعًا في أكثر من 160 دولة"
      ],
      payment: {
        details: "يمكنك شراء {{name}} على الفور عبر MoonPay باستخدام طرق الدفع التالية.  بطاقات الائتمان فورية و سهلة، ولكنها أكثر تكلفة بسبب زيادة مخاطر رد المبالغ المدفوعة. نوصي باستخدام خيار التحويل المصرفي لمبالغ أكبر. الحد الأدنى للرسوم هو 4 دولارات أمريكية / او يورو بما يعادلها",
        footnote: "يرجى ملاحظة أن أسعار صرف MoonPay يمكن أن تختلف عن تلك المستخدمة في BitBoxApp ، مما ينتج عنه مبالغ مختلفة قليلاً",
        table: {
          "1_description": "الرسوم الارخص تستغرق مدة قد تصل الى 3 أيام عمل",
          "1_method": "التحويلات المصرفية (SEPA)",
          "2_description": "رسوم أعلى ولكن سريعة وفورية",
          "2_method": "بطاقات الائتمان والخصم",
          description: "الوصف",
          fee: "العمولة",
          method: "طريقة"
        },
        title: "طرق الدفع والرسوم"
      },
      privacyPolicy: "سياسة الخصوصية لـ MoonPay",
      protection: {
        description: "لا يقوم BitBoxApp بجمع أي بيانات عند شراء {{name}} و يتم التعامل مع الأموال الواردة معاملة عادية. يحتاج MoonPay إلى جمع بعض البيانات الشخصية للعمل. توضح سياسة الخصوصية الخاصة بهم بالتفصيل كيفية التعامل مع هذه البيانات",
        title: "حماية البيانات"
      },
      security: {
        description: "عند شراء {{name}} عبر MoonPay ، أنت تستخدم خدمة خارجية. هذه الخدمة خارج نطاق نظام حماية التهديد الامني في BitBox02 وتعتمد على سلامة وأمن البيئة التي يعمل بها برنامج BitBoxApp",
        link: "نظام الحماية للتهديد الأمني",
        title: "نظام الامن"
      },
      title: "مرحبًا بكم في متجرك الوحيد لشراء {{name}}"
    },
    next: "التالي",
    selectLabel: "اختر حسابك",
    selectPlaceholder: "اختر عملة",
    skip: "لا تظهر مرة أخرى",
    title: "شراء {{name}}"
  },
  title: "شراء {{name}}"
};
const changePin$i = {
  newTitle: "كلمة مرور جديدة للجهاز",
  oldLabel: "كلمة مرور الجهاز الحالية"
};
const chart$e = {
  dataMissing: "جمع البيانات التاريخية ... يرجى الانتظار",
  dataUpdating: "تحديث البيانات...",
  filter: {
    all: "الكل",
    month: "شهر",
    week: "أسبوع",
    year: "سنة"
  }
};
const checkSDcard$i = "التحقق من شريحة microSD";
const clickHere$i = "اكبس هنا";
const confirm$k = {
  abortInfo: "اضغط من اجل",
  abortInfoRedText: "الغاء",
  approveInfo: "استمر في الضغط لمدة 4 ثواني من اجل ",
  approveInfoGreenText: "التأكيد",
  info: "استمر في جهاز BitBox الخاص بك",
  infoWhenPaired: "أولاً على الهاتف المحمول المربوط ثم جهاز BitBox الخاص بك"
};
const confirmOnDevice$i = "يرجى التأكيد على جهازك";
const device$i = {
  appUpradeRequired: "جهاز BitBox الخاص بك غير متوافق مع تطبيق الكومبيوتر هذا. يرجى تنزيل وتثبيت أحدث إصدار"
};
const deviceLock$i = {
  button: "تمكين المصادقة الثنائية (2FA)",
  condition1: "هل لديك نسخة احتياطية؟",
  condition2: "هل تعمل آلية التحقق من تطبيق الجوال؟",
  condition3: "المصادقة الثنائية 2FA تعطل النسخ الاحتياطية و الربط بتطبيقات الهاتف المحمول. يجب إعادة ضبط الجهاز للخروج من خاصية 2FA!",
  confirm: "تفعيل خاصية المصادقة الثنائية (2FA)",
  title: "تفعيل خاصية المصادقة الثنائية (2FA)"
};
const deviceSettings$i = {
  firmware: {
    newVersion: {
      label: "الإصدار المتوفر"
    },
    title: "البرنامج الثابت",
    upToDate: "تم تحديث جهازك",
    version: {
      label: "إصدار"
    }
  },
  hardware: {
    attestation: {
      "false": "فشل التحقق من التصديق",
      label: "التحقق من التصديق",
      "true": "جهاز BitBox02 الخاص بك موثوق"
    },
    sdcard: {
      "false": "لم يتم الادخال",
      label: "شريحة microSD",
      "true": "تم إدخالها"
    },
    securechip: "شريحة آمنة",
    title: "المعدات"
  },
  loading: "جاري استلام معلومات الجهاز ...",
  pairing: {
    lock: {
      "false": "عاطل",
      label: "نظام المصادقة الثنائية (2FA)",
      "true": "مفعلة"
    },
    mobile: {
      "false": "مغلق",
      label: "تطبيق موبايل",
      "true": "مفتوح"
    },
    status: {
      "false": "غير مرتبط",
      label: "الحالة",
      "true": "مرتبط"
    },
    title: "جاري الارتباط"
  },
  secrets: {
    manageBackups: "ادارة النسخ الاحتياطية",
    title: "أسرار"
  }
};
const deviceTampered$i = "هل تم تزويد BitBox الخاص بك بكلمة مرور للاسترداد؟ إذا كان الأمر كذلك، فأوقف عملية الإعداد واتصل بالدعم على الفور. لن تمنحك شركة Shift أبدًا محفظة باعدادات جاهزة و لن تقدم لك توصيات بكلمة مرور";
const dialog$j = {
  cancel: "الغاء",
  confirm: "تأكيد",
  confirmTitle: "تأكيد"
};
const error$e = {
  accountAlreadyExists: "الحساب موجود مسبقاً",
  accountLimitReached: "لا يمكن إضافة حساب. تم الوصول إلى الحد الأقصى لعدد الحسابات لهذه العملة",
  aoppCallback: "حدث خطأ في ايصال العنوان إلى {{host}}",
  aoppInvalidRequest: "طلب غير صالح",
  aoppNoAccounts: "لا توجد حسابات متاحة",
  aoppSigningAborted: "تم إلغاء طلب ملكية العنوان",
  aoppUnknown: "حدث خطأ غير معروف",
  aoppUnsupportedAsset: "العملة غير مدعومة",
  aoppUnsupportedFormat: "لا توجد حسابات متوفرة تدعم صياغة العنوان المطلوب",
  aoppUnsupportedKeystore: "لا يمكن للجهاز المتصل توقيع رسائل لهذه العملة",
  aoppVersion: "نسخة غير معروفة"
};
const fiat$k = {
  "default": "الخيار الاصلي",
  setDefault: "تعيين {{code}} كخيار اصلي",
  title: "العملات"
};
const footer$k = {
  appVersion: "نسخة التطبيق:"
};
const generic$e = {
  enabled_false: "عاطل",
  enabled_true: "مفعلة"
};
const genericError$i = "حدث خطأ. إذا لاحظت حصول أي مشاكل فيرجى إعادة تشغيل التطبيق";
const goal$i = {
  buttons: {
    create: "أنشئ محفظة جديدة",
    restore: "استعادة محفظة من نسخة احتياطية"
  },
  paragraph: "الرجاء اختيار واحد من الخيارات التالية:",
  step: {
    "1": {
      title: "حماية المعلومات"
    },
    "2": {
      description: "قم بتعيين كلمة مرور للجهاز",
      title: "جهاز"
    },
    "3-create": {
      description: "أنشئ محفظة جديدة",
      title: "محفظة"
    },
    "3-restore": {
      description: "من نسخة احتياطية",
      title: "استرجاع"
    },
    "4-create": {
      title: "خلاصة"
    },
    "4-restore": {
      title: "خلاصة"
    }
  }
};
const guide$j = {
  accountDescription: {
    text: 'خاصية النظرة العامة لحسابك ستظهر رصيدك وكذلك المعاملات الواردة والصادرة. يحتوي دليلنا في "الإعدادات" على مزيد من المعلومات حول كل نوع من الحسابات',
    title: "ما الذي يظهر لي في هذه الصفحة؟"
  },
  accountFiat: {
    text: "نعم. اكبس فوق أي شريط للاختيار من قائمة العملات التقليدية. يمكنك تغيير قائمة العملات في الإعدادات",
    title: "هل يمكنني عرض أسعار التحويل الأخرى؟"
  },
  accountIncomingBalance: {
    text: "مبلغ الوارد هو مجموع المبالغ المرسلة لحسابك ولكن لم يتم تأكيدها على الشبكة بعد",
    title: "ماذا يعني المبلغ الوارد؟"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'يرتبط كل ملف xpub بـ"النوع" المعروض: إما "Segwit (bech32) على الجهاز" أو "Segwit مبطن" أو "Taproot" (للبتكوين فقط). هذه هي أنواع البرامج النصية المستخدمة من قبل {{coinName}}. يقوم BitBoxApp بدمجها ، و ايضاً دعم أنواع نصوص متعددة في نفس الحساب. نظرًا لأن كل نوع نص برمجي يعطي xpub مختلف، فهناك عدة xpub لكل حساب.\n\nإذا كنت تستلم تحويلات مستمرة على العنوان الافتراضي (Native Segwit) ، فأنت تحتاج فقط إلى xpub "bech32". ومع ذلك ، إذا استلمت أيضًا أموالًا إلى "Wrapped Segwit" أو "Taproot" ، فستحتاج أيضًا إلى استخدام المفتاحين العلنيين الموسعين "Wrapped Segwit" و "Taproot" ',
      title: "لماذا يوجد العديد من ملفات xpub؟"
    },
    privacy: {
      text: "يكشف المفتاح العلني الموسع لهذا الحساب بالتحديد التاريخ المالي بالكامل ورصيد حسابك وجميع المعاملات المستقبلية. لكن xpub لا يسمح لأي شخص بإنفاق عملاتك\n\nإذا أعطيت xpub لشخص ما ، فيجب أن تدرك أن هذا الشخص أو الشركة يمكنها رؤية جميع المعاملات الأخرى لنفس الحساب. لذلك، ننصح باستخدام هذا الحساب لهذا الغرض فقط والاحتفاظ بأموال أخرى في حسابات مختلفة",
      title: "هل أحتاج إلى الاحتفاظ بسرية xpub؟"
    },
    verify: {
      text: "نعم ، من الأفضل دائمًا إعادة التحقق من xpub الخاص بك. فهذا مهم بشكل خاص إذا قام شخص آخر بإنشاء عناوين استلام من xpub هذا لإرسال الأموال إليك. تحتاج إلى التحقق من ذلك على الجهاز للتأكد من أن xpub هذا ملك لك. خلاف ذلك فيمكن أن تذهب جميع الأموال إلى عناوين خاطئة.",
      title: "هل أحتاج إلى التحقق من xpub على الجهاز؟"
    },
    xpub: {
      text: "المفتاح العلني الموسع (xpub) هو مفتاح جذر تُشتق منه جميع عناوين الاستلام الخاصة بالحساب.\n\nيتم توفيرها هنا للاستخدام المتقدم وقابلية التشغيل البيني مع محفظات المراقبة فقط ، مثل Electrum أو Sentinel. إذا تلقيت أنواع عناوين مختلفة ، فيرجى استيراد جميع تنسيقات xpub المختلفة إلى محفظة المراقبة فقط لمتابعة جميع عملاتك.\n\nيرجى ملاحظة أن محافظ الطرف الثالث قد لا دعم Taproot xpubs حتى الآن",
      title: "ما هو المفتاح العلني الموسع؟"
    }
  },
  accountRates: {
    text: "نقوم بتحديث أسعار الصرف كل دقيقة من CoinGecko",
    title: "ما هي أسعار الصرف المعتمدة؟"
  },
  accountReload: {
    text: "ليس هناك حاجة. يتم تحديث معلومات معاملاتك تلقائيًا",
    title: "هل يمكنني إعادة تحميل سجل المعاملات؟"
  },
  accountSendDisabled: {
    text: 'يتم تنشيط الزر "إرسال" عندما يكون رصيدك أكثر من صفر',
    title: "لماذا لا يمكنني إرسال أي {{unit}}؟"
  },
  accountSummaryAmount: {
    text: "المبلغ الإجمالي هو مجموع جميع حسابات الكريبتو الخاصة بك. يتم الحصول على أسعار الصرف من موقع coingecko.com\n\nملاحظة: إذا كنت تستخدم محفظة MyEtherWallet للتوكينات الغير مدعومة في BitBoxApp ، فلن يتم تضمينها في المبلغ المعروض",
    title: "كيف يتم حساب المبلغ الإجمالي؟"
  },
  accountSummaryDescription: {
    text: "هنا يمكنك مشاهدة أداء محفظتك مع مرور الوقت. يتم عرض ملخص لحساباتك الكريبتو تحت الشارت",
    title: "ما الذي يظهر لي في هذه الصفحة؟"
  },
  accountTransactionAttributesBTC: {
    text: "الحجم الافتراضي: يحدد رسوم الشبكة. لقد نجحت في التوفير اذا كانت الرسوم اقل من حجم المعاملة.\nالحجم: الحجم الفعلي للمعاملة بالبايت عند إجراء تسلسل وفقًا للبلوكشين الأساسية.\nالوزن: مقياس جديد تم تقديمه مع Segwit لتقييم أحجام المعاملات والكتل. يتم احتساب كل بايت في Segwit كواحد ، وكل شيء آخر كأربع وحدات وزن. بدلاً من واحد ميغا بايت بالحجم الفعلي ، أصبح حد حجم الكتلة الآن أربعة ملايين وحدة وزن",
    title: "ماذا عن تفاصيل المعاملات الخاصة ببيتكوين؟"
  },
  accountTransactionAttributesGeneric: {
    text: "التأكيدات: لا يتم تأكيد بث معاملتك حتى يقوم احد المعدنين بإدراجه عشوائياً في كتلة، وبعد ذلك يحصل تأكيد واحد للمعاملة. تضيف كل كتلة يتم بثها على الشبكة تأكيدًا آخر لمعاملتك. بشكل عام ، يقوم المتداولون والجهات الفاعلة الأخرى في الشبكة بتسوية المعاملات خلال ما بين ثلاثة إلى ستة تأكيدات فقط.\nمعرف المعاملة: رقم تعريف فريد يسمح لك بالبحث عن معاملة في مستكشف البلوكشين.\nالرسوم: يتم دفع رسوم للمعدنين على المعاملات كحافز لتضمين المعاملات في الكتل التي يقومون بتعدينها. لمعرفة المزيد ، اكبس على زر الإرسال.",
    title: "ما هي المعلومات الواردة في تفاصيل المعاملة؟"
  },
  accountTransactionConfirmation: {
    text: "تم بث معاملة على الشبكة ولكن لم يتم تأكيدها بعد",
    title: "ما هي المعاملة المعلقة؟"
  },
  accountTransactionLabel: {
    text: "إنه العنوان الذي تلقيت منه عملات أو أرسلت إليه عملات",
    title: "ما هو العنوان الذي يتم عرضه لكل معاملة؟"
  },
  accountTransactionTime: {
    text: "وقت تأكيد المعاملة على البلوكشين",
    title: "ما هو الوقت المعروض؟"
  },
  accounts: {
    howManyAccounts: {
      text: "يمكن أن يكون لكل عملة خمسة حسابات بحد أقصى",
      title: "كم عدد الحسابات التي يمكنني إنشاؤها؟"
    },
    howtoAddTokens: {
      text: 'ترتبط العملات التي تستخدم بروتوكول ERC20 مرتبطة بحساب Ethereum معين. لتمكين أو تعطيل عملة معينة، افتح شاشة "إدارة الحسابات" ، وقم بتوسيع حساب Ethereum الخاص بك وقم بتشغيل العملة المطلوبة أو إيقاف تشغيلها',
      title: "كيف يمكنني إضافة عملات إضافية؟"
    },
    moveFunds: {
      text: "نعم. ولكن نظرًا لأن الحسابات مستقلة، فأنت بحاجة إلى إرسال أموالك باستخدام معاملة عادية",
      title: "هل يمكنني نقل الأموال بين الحسابات؟"
    },
    recoverAccounts: {
      text: "نعم. يقوم تطبيق BitBoxApp بإنشاء حسابات باستخدام معايير راسخة متوافقة مع معظم محافظ التشفير الأخرى",
      title: "هل يمكنني استعادة حساباتي بمحفظات أخرى؟"
    },
    whatAreAccounts: {
      text: "يمكن لمحفظتك إدارة حسابات متعددة لنفس العملة. الحسابات مفيدة عندما تريد فصل الاحتفاظ بالأموال عن بعضها",
      title: "ما هي الحسابات؟"
    },
    whyIsThisUseful: {
      text: 'الحسابات ممتازة لإدارة الأموال لأشخاص أو أغراض مختلفة لأنها منفصلة. يمكنك أيضًا مشاركة "المفتاح العلني الموسع" لحساب ما دون الكشف عن أي شيء عن حساباتك الأخرى. يتيح لك ذلك تلقي الأموال بشكل متكرر دون إعادة استخدام العناوين، مثل تلقي راتبك أو شراء العملات المشفرة بانتظام',
      title: "لماذا هذا مفيد؟"
    }
  },
  appendix: {
    link: "اتصل بنا!",
    text: "سؤال آخر؟"
  },
  backups: {
    check: {
      text: 'يسمح لك "التحقق من النسخة الاحتياطية" بالتحقق من أن لديك نسخة احتياطية صالحة للعمل تتوافق مع محفظتك الحالية. يمكن استخدامها أيضًا للتحقق من أنه لا يزال لديك كلمة مرور الاسترداد الصحيحة. يمكنك التحقق من كلمة مرور الاسترداد الرئيسية أو كلمة مرور الاسترداد المخفية',
      title: 'ما هو "فحص النسخة الاحتياطية"؟'
    },
    encrypt: {
      text: "لا ، ولكن كلمة مرور الاسترداد مطلوبة لاشتقاق المحفظة من المفاتيح السرية المخزنة",
      title: "هل يمكنني تشفير النسخة الاحتياطية؟"
    },
    howOften: {
      text: "يتم إنشاء النسخة الاحتياطية تلقائيًا عند إنشاء محفظة جديدة. ما عليك سوى عمل نسخة احتياطية جديدة في حالة فقدان شريحة microSD أو تلفها ، أو إذا كنت تريد استخدام عدة شرائح microSD كنسخ احتياطية.\nلا تحتاج إلى إنشاء نسخة احتياطية جديدة بعد اكتمال المعاملة. يمكن إعادة إنشاء جميع بيانات المعاملات الخاصة بك عن طريق النسخة الاحتياطية الفردية التي تم إنشاؤها تلقائيًا لك",
      title: "كم مرة يجب علي عمل نسخة احتياطية؟"
    },
    whatIsABackup: {
      text: "إنها نسخة من المفاتيح السرية الموجودة على شريحة microSD. تنشئ المفاتيح مع كلمة مرور الاسترداد محفظتك",
      title: "ما هي النسخة الاحتياطية؟"
    }
  },
  backupsBB02: {
    check: {
      text: 'يسمح لك "التحقق من النسخة الاحتياطية" بالتحقق من أن لديك نسخة احتياطية صالحة للعمل تتوافق مع محفظتك الحالية',
      title: 'ما هو "فحص النسخة الاحتياطية"؟'
    },
    encrypt: {
      text: 'لا. يرجى الحفاظ على شريحة microSD في مكان آمن ، لأنها تحتوي على المفاتيح غير المشفرة لاستعادة محفظتك. إذا كنت ترغب في حماية المفاتيح بكلمة مرور ، فيمكنك تمكين عبارة مرور اختيارية في الإعدادات المتقدمة ضمن "إدارة الجهاز"',
      title: "هل يمكنني تشفير النسخة الاحتياطية؟"
    },
    whatIsABackup: {
      text: "إنها نسخة من المفاتيح السرية الموجودة على شريحة microSD",
      title: "ما هي النسخة الاحتياطية؟"
    }
  },
  bitbox: {
    "2FA": {
      text: "عند تمكين المصادقة الثنائية (2FA) ، يجب الموافقة على جميع المعاملات على الهاتف المحمول المقترن من أجل إنفاق العملات. عند التعمق اكثر، يتم إرسال رقم مشفر للاستخدام الفردي إلى تطبيق الهاتف المحمول ، ويتم فك تشفيره هناك ، وإعادته إلى BitBox عند الضغط على زر القبول. يتم إجراء هذا الاتصال بالجهاز عبر القناة بين الهاتف المحمول وتطبيق سطح المكتب هذا الذي تم إنشاؤه أثناء الاقتران\n\nتأكد من عمل نسخة احتياطية من محفظتك وإقران تطبيق الهاتف المحمول قبل تمكين 2FA. بمجرد التمكين ، يتم تعطيل فتحة microSD وإقران تطبيق الهاتف المحمول. يمكن إعادة تمكينها عن طريق إعادة تعيين BitBox ، مما يمحي الجهاز",
      title: "كيف يعمل المصادقة الثنائية (2FA)؟"
    },
    disable2FA: {
      text: 'لتعطيل المصادقة الثنائية (2FA) ، تحتاج إلى إعادة تعيين BitBox الخاص بك ثم استعادة المحفظة من النسخة الاحتياطية الخاصة بها. تأكد من أنه لا يزال لديك شريحة microSD مع النسخة الاحتياطية وأنك ما زلت تتذكر كلمة مرور الاسترداد. ثم اضغط على "إعادة تعيين الجهاز". قم بتعيين كلمة مرور جديدة للجهاز واختر "أو استعادة نسخة احتياطية". حدد النسخة الاحتياطية التي قمت بإنشائها من المحفظة ، وانقر فوق "استعادة" وأدخل كلمة مرور الاسترداد التي استخدمتها عند إنشاء المحفظة',
      title: "كيف يمكنني تعطيل المصادقة الثنائية (2FA)؟"
    },
    ejectBitbox: {
      text: "يمكنك فصل BitBox في أي وقت دون الحاجة إلى ازالتها أولاً",
      title: "كيف يمكنني ازالة BitBox؟"
    },
    ejectSD: {
      text: "يمكنك إزالة بطاقة microSD من BitBox في أي وقت طالما أنك لست بصدد إنشاء نسخة احتياطية أو استعادتها",
      title: "كيف يمكنني إخراج شريحة microSD؟"
    },
    hiddenWallet: {
      text: "إنها محفظة ثانية على نفس الجهاز محمية بكلمة مرور مختلفة للجهاز وكلمة مرور استرداد ، والتي يمكنك استخدامها للإنكار القانوني المقبول. يتم استخدام نفس المفاتيح الاحتياطية لكل من محفظتك العادية والمخفية ، لذلك لا يلزم نسخة احتياطية إضافية",
      title: "ما هي المحفظة المخفية؟"
    },
    legacyHiddenWallet: {
      text: "أولاً ، إكبس فوق الزر أدناه (متاح إذا تم إلغاء تأمين BitBox باستخدام كلمة مرور الجهاز الرئيسية وتعطيل 2FA) ، ثم أعد توصيل Bitbox الخاص بك وقم بإلغاء قفله بكلمة مرور جهازك المخفية",
      title: "كيف يمكنني الوصول إلى المحفظة المخفية القديمة؟"
    },
    pairing: {
      text: "بعد تنزيل تطبيق الهاتف المحمول الخاص بنا لنظام التشغيل iOS أو Android ، تقوم بمسح رمز الاستجابة السريعة المعروض ، والذي ينشئ قناة آمنة بين تطبيق الهاتف المحمول وهذا التطبيق. بمجرد المسح ، اتبع التعليمات الموجودة في تطبيق الهاتف",
      title: "كيفية الربط بأمان مع هاتفك"
    }
  },
  cointracking: {
    text: 'اكبس فوق الزر "تصدير" وافتح مجلد التنزيلات حيث ستجد تصدير ملف CSV. ثم اكبس فوق الرابط أدناه ، وقم بتحميل ملف BitBox CSV الخاص بك واستورد البيانات من أجل استخدامها لإدارة بورتفوليو خاص بك في CoinTracking ولإنشاء تقاريرك الضريبية',
    title: "كيف أستورد معاملاتي إلى CoinTracking؟"
  },
  device: {
    attestation: {
      link: {
        text: "اقرأ المزيد عن مسألة التحقق من المصداقية"
      },
      text: "يقوم تطبيق BitBoxApp بإجراء فحص المصادقة على جهاز BitBox02 للتحقق مما إذا كان الجهاز أصليًا. يتم الفحص محليًا ولا يتصل بأي سيرفيرات",
      title: "كيف يعمل نظام التحقق من المصداقية؟"
    },
    name: {
      text: "هذا هو اسم محفظتك والنسخة الاحتياطية. يستخدم الاسم للنسخة الاحتياطية المستقبلية ويمكن استخدامه للمساعدة في التمييز بين المحفظات المختلفة. يمكن تغييره في أي وقت ولكن لاحظ أن النسخة الاحتياطية التي تم إجراؤها قبل التغيير ستظل تستخدم الاسم السابق",
      title: "ما هو اسم جهاز BitBox02 المستخدم؟"
    },
    "secure-chip": {
      link: {
        text: "اقرأ المزيد عن الشريحة الآمنة"
      },
      text: "توضح هذه المعلومات رقم طراز الشريحة الآمنة. والشريحة الأحدث هي ATECC608B مع ميزات أمان محسّنة مقارنة بالطرازات القديمة",
      title: "لماذا يظهر نموذج الشريحة الآمنة؟"
    }
  },
  receive: {
    address: {
      text: "يمكنك إعطاء العنوان للآخرين لإرسال بعض العملات إليك. فقط تأكد من أنك ترسل إلى العنوان الصحيح",
      title: "ماذا أفعل بالعنوان؟"
    },
    addressChange: {
      text: "بمجرد إجراء المعاملة ، يتم إضافة عنوان جديد تلقائيًا إلى القائمة، لذلك هناك دائمًا 20 عنوان جديد متاح لم تستلم أي عملات مطلقًا",
      title: "متى تتغير العناوين؟"
    },
    addressFormats: {
      text: "في الاعدادت الاساسية، يكون نوع العنوان هو Native Segwit. يتم اعتماد هذا النوع من العناوين على نطاق واسع من قبل مختلف المحفظات و المنصات الاخرى ويمنحك أفضل معدلات الرسوم للمعاملات اليومية. ومع ذلك ، يمكنك أيضًا اختيار الإرسال إلى عنوان نوع Taproot (للبتكوين فقط) ، وهو أحدث نوع من العناوين، ولكن قد لا يكون مدعومًا على نطاق واسع حتى الآن. بدلاً من ذلك ، إذا كنت تواجه مشكلات في الإرسال إلى Native Segwit (النوع الاساسي) ، فيمكنك محاولة التبديل إلى نوع عنوان Segwit مبطن و هو النوع الأقدم الذي قد يكون متوافقًا مع اغلبية انواع المحفظات و المنصات.",
      title: 'متى يجب ان أستخدم خاصية "تغيير نوع العنوان"؟'
    },
    howVerify: {
      text: "بالنسبة إلى جهاز BitBox01 ، اكبس فوق رمز BitBox في الشريط الجانبي على اليسار و سترى قسم الاقتران (الربط). سيتم تحديث الدليل ويمكنك الاستمرار في متابعة التعليمات من هناك.\nبالنسبة إلى جهاز BitBox02 ، يمكنك التحقق من العناوين مباشرة على الجهاز أثناء عملية الإرسال و الاستلام",
      title: "كيف يمكنني التحقق من العنوان بأمان؟"
    },
    plugout: {
      text: "لا ، بمجرد إرسال العملات إلى عنوان BitBox الخاص بك ، لن تحتاج إلى ترك BitBox الخاص بك متصلاً. أنت حر في فصل جهاز BitBox الخاص بك",
      title: "هل أحتاج إلى ترك جهاز BitBox الخاص بي متصلاً أثناء الاستلام؟"
    },
    why20: {
      text: 'أثناء بدء التشغيل ، يُنشئ التطبيق عناوين مشتقة من مفاتيحك (١٢ او ٢٤ كلمة) لمعرفة ما إذا كانوا قد تلقوا أموالاً في الماضي. نظرًا لأن التطبيق يمكنه إنشاء عدد لا نهائي تقريبًا من العناوين ، فقد يقضي سنوات في تحديد الرصيد. للحد من هذا البحث ، يتوقف هذا البحث بعد أن يرى 20 عنوانًا لم تتلق أموالًا مطلقًا. هذا هو "حد الفجوة" و 20 هو معيار واقعي على الرغم من أن الرقم عشوائي. هذه هي 20 عنوانًا يمكنك الاختيار من بينها',
      title: "لماذا يوجد 20 عنوان فقط؟"
    },
    whyMany: {
      text: "للحفاظ على الخصوصية والأمان ، لا تقم أبدًا بإعطاء نفس العنوان مرتين. إذا كنت قد استخدمت عنوانًا ، فقم بالكبس فوق السهم الأيمن للحصول على عنوان جديد. يمكنك إنشاء ما يصل إلى 20 عنوانًا في المرة الواحدة. فكر في العناوين مثل أرقام الوصولات. جميع العناوين مشتقة من المفاتيح نسخة احتياطية واحدة.",
      title: "لماذا توجد الكثير من العناوين؟"
    },
    whyVerify: {
      text: "يجب أن لا تثق في جهاز الكمبيوتر الخاص بك لإنشاء وعرض عناوين أصلية. الكومبيوتر ساحة هجوم كبيرة و مستهدفة و يجعلها أكثر عرضة للخطر بشكل ملحوظ و هي اضعف من اجهزة المحفظات الباردة. بالنسبة لجهاز BitBox01 ، يرسل الزر للتحقق من العنوان بشكل آمن العنوان إلى هاتف محمول مقترن بالمحفظة ، حيث يمكنك أيضًا مسح رمز الاستجابة السريعة والتحقق منه. بالنسبة لـ BitBox02 ، يمكن التحقق من العنوان مباشرة على شاشة BitBox02 نفسها",
      title: "لماذا يجب علي التحقق من العنوان بأمان؟"
    }
  },
  send: {
    change: {
      text: "سيتم إرجاع التغيير إلى عنوان Taproot إذا كان لديك Taproot UTXO واحدة على الأقل. إذا كنت تستخدم خاصية التحكم في العملة Coin Control، فسيتم إرجاع التغيير إلى عنوان Taproot إذا كان هناك على الأقل  Taproot UTXO واحدة بين UTXOs المحددة. في جميع الحالات الأخرى ، يتم إرجاع التغيير إلى عنوان Segwit الأصلي.",
      title: "كيف يتم تحديد ناتج التغيير؟"
    },
    fee: {
      text: "تعتمد الرسوم على حجم بيانات المعاملة وليس قيمتها. يتم حساب أهداف الرسوم بواسطة خوارزمية تقدير الرسوم في كود او برمجة Bitcoin Core لكل أولوية شبكة انت تختارها. يتم عرضها إذا كانت لها قيمة مختلفة عن الهدف أدناه.\nالخيار التوفيري: التأكيد خلال 24 كتلة (حوالي 4 ساعات للبيتكوين ، وساعة واحدة للايتكوين)\nمنخفض: التأكيد خلال 12 كتلة (حوالي ساعتين للبيتكوين ، و 30 دقيقة للايتكوين)\nعادي: التأكيد خلال 6 كتل (حوالي ساعة واحدة للبيتكوين ، و 15 دقيقة للايتكوين)\nمرتفع: التأكيد خلال كتلتان (حوالي 20 دقيقة للبيتكوين ، و 5 دقائق للايتكوين)\n(تستغرق الكتلة في المتوسط عشر دقائق للبيتكوين (2.5 دقيقة في للايتكوين) وقد يختلف الزخم على الشبكة بشكل كبير في الفترات المذكورة أعلاه)",
      title: "كيف يتم تحديد الرسوم؟"
    },
    plugout: {
      text: "لا ، بمجرد إجراء معاملة ، لن تحتاج إلى ترك BitBox الخاص بك متصلاً. ولك مطلق الحرية في فصل BitBox الخاص بك",
      title: "هل أحتاج إلى ترك BitBox الخاص بي متصلاً أثناء الإرسال؟"
    },
    priority: {
      text: "كلما زادت الرسوم التي ترغب في دفعها ، زادت سرعة تأكيد معاملتك على الشبكة",
      title: "ما هي أولوية الشبكة؟"
    },
    revert: {
      text: "بمجرد توقيع المعاملة وإرسالها (أي بثها إلى الشبكة) ، لم يعد من الممكن التراجع عنها. تحقق من المعاملات (بما في ذلك الرسوم) بشكل صحيح قبل التوقيع!\nإذا كنت تعرف المستلم وكان مستعدًا لإرسال نفس المبلغ (مطروحًا منه رسوم المعاملة) إليك ، فيمكنك إرسال عنوان استلام جديد له",
      title: "هل يمكنني التراجع عن معاملة (ارسال او تداول)؟"
    },
    whyFee: {
      text: "تتنافس المعاملات على أن يؤكدها المعدنين. يختار المعدنون المعاملات ليتم تضمينها في البلوكشين بناءً على رسومهم.\nيصوت المعدنين على تاريخ المعاملات. نظرًا لعدم وجود طرف ثالث موثوق به لفرض صوت واحد لكل شخص (وهذا هو الهدف الكامل من تقنية البلوكشين) ، يصوت المعدنون على المعاملات من خلال التضحية بمورد مكلف مثل قوة الحوسبة (صعوبة التعدين). كمكافأة على عملهم (اثبات الجهد)، يمكنهم المطالبة بالعملات التي تم إنشاؤها حديثًا ورسوم جميع المعاملات التي تضمنتها",
      title: "لماذا توجد رسوم على الشبكة؟"
    }
  },
  "settings-electrum": {
    connection: {
      text: "إذا كنت تنوي الاتصال بالنود الخاصة بك فقط عندما تكون على نفس الشبكة (على سبيل المثال على انرنت wifi المنزلي الخاص بك) ، فإن استخدام اتصال الشبكة المنتظم كافي.\nفي هذه الحالة ، من المستحسن أن يوفر سيرفير Electrum الخاص بك شهادة TLS لتشفير الاتصال.\nإذا كنت تنوي الاتصال بالنود الخاصة بك من أي مكان آخر، فإن استخدام Tor هو الخيار الأفضل. لا يلزم وجود شهادة TLS في هذه الحالة.",
      title: "هل يجب أن أستخدم انترنت مفتوح TCP أو TLS أو Tor؟"
    },
    instructions: {
      link: {
        text: "الدليل لتوصيل النود الخاصة بك"
      },
      text: "للحصول على برنامج تعليمي كامل، يرجى زيارة دليلنا:",
      title: "كيف أقوم بتوصيل تطبيق BitBox الخاص بي بالنود الخاصة بي؟"
    },
    options: {
      text: "هناك العديد من الخيارات لتشغيل النود الخاصة بك ، مثل شراء جهاز مكتمل ، أو بناء Bitcoin Core الخاص بك أو تشغيله.\nإذا كنت ترغب في توصيل تطبيق BitBoxApp بالنود الخاصة بك ، فتأكد من انها تشغل سيرفير Electrum و هو  برنامج مخصص يسمح لتطبيق المحفظة بالاتصال بالنود الكاملة.\nتشمل الخيارات المدعومة Electrs أو Electrum Personal Server (EPS) أو Bitcoin Wallet Tracker (BTW).",
      title: "ما هي الخيارات المتاحة لتشغيل النود؟"
    },
    tor: {
      text: 'يرمز Tor إلى "The Onion Router" ، وهو برنامج مجاني ومفتوح المصدر يوفر الكثير من مزايا الخصوصية وهو مفيد بشكل خاص عند استخدام Bitcoin.\nإذا كنت تنوي الاتصال بالنود الخاصة بك عبر Tor ، فتأكد من تثبيت Tor على جهاز الكمبيوتر الخاص بك ثم قم بتمكين Tor Proxy في إعدادات BitBoxApp.\nفي معظم أنظمة التشغيل ، توجد طريقتان لتشغيل Tor:\n1. عن طريق متصفح Tor: قم بتنزيل متصفح Tor من الانترنت وافتحه. سيسمح هذا لتطبيق BitBoxApp بالاتصال بشبكة Tor عن طريق ضبط المنفذ الالكتروني رقم 9150 في إعدادات Tor Proxy .\n2. خدمة Tor التي تعمل في الخلفية: قم بتثبيت Tor daemon ، والتي تعمل دائمًا في الخلفية. يمكن لتطبيق BitBoxApp الاتصال عن طريق ضبط المنفذ الالكتروني رقم 9050 في إعدادات Tor Proxy.',
      title: "ما هو Tor و Tor proxy وأي منفذ الكتروني يجب أن أستخدمه؟"
    },
    what: {
      text: "من الممكن تشغيل محفظتك عن طريق النود الخاصة بك بدلاً من استخدام سيرفيرات شركة Shift",
      title: "ما هذا؟"
    },
    why: {
      text: "تشغيل النود الخاصة بك ليس ضروريًا ولكنه يرفع درجة الخصوصية ويقلل من الحاجة إلى الثقة بالآخرين.\nأولاً ، هذا يعني أنك تستخدم Bitcoin بشكل أكثر خصوصية لأن تطبيق BitBox لن يتصل بالسيرفرات لجلب سجل معاملاتك ؛ بدلاً من ذلك ، سيتم جلب هذه المعلومات من النود الخاصة بك.\nثانيًا ، تشغيل النود الخاصة بك يعني أن النود الخاصة بك تتحقق من جميع المعاملات نفسها ، مع التأكد من تطبيق قواعد الإجماع.",
      title: "لماذا يجب علي تشغيل النود الخاصة بي؟"
    }
  },
  settings: {
    sats: {
      text: "ساتوشي ('sat' للاختصار) هي أصغر وحدة من البيتكوين. ساتوشي واحد يعادل مائة مليون من البيتكوين (0.00000001 BTC). تم تسميته على اسم مبتكر البيتكوين، ساتوشي ناكاموتو",
      title: "ما هو الساتوشي؟"
    },
    servers: {
      text: "يتواصل هذا التطبيق مع سيرفيرات Shift Crypto للتحقق من التحديثات وتحميل المعاملات وإرسال المعلومات إلى تطبيقات الهواتف المحمولة المقترنة.\nيسترجع التطبيق أيضًا أحدث أسعار الصرف من CoinGecko. يتم حساب جميع التحويلات محليًا مما يعني أنه لا يتم إرسال أي بيانات حول حجم معاملتك على الإطلاق.\nملاحظة: بالنسبة لرموز Ethereum و توكينات ERC20 ، نستخدم واجهات برمجة تطبيقات من Etherscan.io.",
      title: "مع أي سيرفيرات يتحدث هذا التطبيق؟"
    }
  },
  title: "الدليل",
  toggle: {
    close: "اغلاق الدليل",
    open: "الدليل"
  },
  trackingModePortfolioChart: {
    text: "على كومبيوتر سطح المكتب، مرر سهم الماوس فوق الشارت. على الهاتف المحمول، ضع إصبعك على الشارت واسحب أفقيًا",
    title: "كيف يمكنني ان ارى القيم التاريخية على الشارت؟"
  },
  unlock: {
    forgotDevicePassword: {
      text: "يجب عليك إعادة ضبط الجهاز واستعادة المحفظة من نسخة احتياطية باستخدام كلمة مرور الاسترداد",
      title: "ماذا أفعل إذا نسيت كلمة مرور الجهاز؟"
    },
    reset: {
      text: "أدخل كلمة مرور خاطئة للجهاز 15 مرة. تتطلب المحاولات القليلة الأخيرة لمسة طويلة على الجهاز",
      title: "كيف يمكنني إعادة ضبط الجهاز؟"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "يجب أن يومض الجهاز مرة واحدة عند إدخاله. تأكد من إدخاله بالطريقة الصحيحة. إذا كنت تواجه مشكلة ، يرجى الاتصال بنا من خلال الرابط أدناه.\n\nBitBox01 غير مدعوم على الهاتف المحمول. يرجى استخدام تطبيق BitBox على سطح المكتب لتوصيل BitBox01 الخاص بك",
      title: "لم يتم التعرف على جهاز BitBox01 الخاص بي"
    },
    getDevice: {
      link: {
        text: "شراء BitBox"
      },
      text: "يمكنك شراء جهاز BitBox من متجرنا على موقعنا في الإنترنت:",
      title: "كيف يمكنني الحصول على جهاز؟"
    },
    internet: {
      text: "نعم ، يلزم الاتصال بالإنترنت لمزامنة المحفظة وإرسال المعاملات واسترداد أحدث أسعار الصرف",
      title: "هل يحتاج هذا التطبيق اتصالاً بالإنترنت؟"
    },
    lostDevice: {
      link: {
        text: "مركز النسخة الاحتياطية"
      },
      text: "يمكنك استرداد حساباتك على جهاز BitBox جديد أو من خلال مركز النسخة الاحتياطية الخاص بنا",
      title: "لقد فقدت جهازي. ماذا افعل الآن؟"
    },
    useWithoutDevice: {
      text: "للأسف هذا غير ممكن في الوقت الحالي",
      title: "هل يمكنني استخدام التطبيق بدون جهاز؟"
    },
    welcome: {
      text: "شكرًا لاستخدام هذا التطبيق الذي صممته شركة Shift Crypto في سويسرا. نحن نقدر أي اقتراح لديك لمشاركته معنا. يرجى تقديم الملاحظات باستخدام الرابط في الأسفل",
      title: "مرحبًا بك في تطبيق BitBoxApp!"
    }
  }
};
const headerssync$i = {
  blocksSynced: "{{blocks}} عدد البلوكات التي تم مطابقتها"
};
const hiddenWallet$i = {
  info1HTML: "لأغراض الإنكار القانوني ، يمكن إنشاء محفظة مخفية بناءاً على <strong>اختلاف</strong> كلمة مرور الجهاز +  كلمة مرور الاسترداد",
  info2HTML: "حدد كلمة مرور الجهاز وكلمة مرور الاسترداد التي تريد ربطها بمحفظتك المخفية أدناه. يجب أن تكون كلمة مرور الجهاز وكلمة مرور الاسترداد <strong>مختلفة</strong> من تلك التي حددتها لمحفظتك الأساسية",
  passwordLabel: "كلمة مرور استرداد المحفظة المخفية",
  passwordPlaceholder: "يرجى تأكيد كلمة مرور استرداد المحفظة المخفية",
  pinLabel: "كلمة مرور جهاز المحفظة المخفية",
  pinRepeatLabel: "كرر كلمة مرور جهاز المحفظة المخفية",
  pinRepeatPlaceholder: "يرجى تأكيد كلمة مرور جهاز المحفظة المخفية",
  success: "تم إنشاء المحفظة المخفية بنجاح. أعد توصيل BitBox للدخول للمحفظة"
};
const initialize$i = {
  create: "تعيين كلمة مرور الجهاز",
  creating: "جاري تعيين كلمة مرور الجهاز ...",
  error: {
    e102: "يجب أن تتكون كلمة مرور الجهاز من 4 أحرف على الأقل"
  },
  info: {
    description1: "اختر كلمة مرور جهازك. سيتم استخدامها للدخول الى جهاز BitBox الخاص بك",
    description2: "يمكنك استخدام الأرقام والحروف والرموز. توفر كلمات المرور الأطول مستوى أمن أعلى",
    description3: "إذا فقدت كلمة مرور الجهاز ، فسيتعين عليك إعادة ضبط جهازك واستعادة النسخة الاحتياطية من محفظتك",
    subtitle: "الآن ستقوم بتعيين كلمة مرور جهازك",
    title: "جاري تهيئة جهازك"
  },
  input: {
    label: "كلمه مرور الجهاز",
    labelRepeat: "كرر كلمة مرور الجهاز",
    placeholderRepeat: "يرجى تأكيد كلمة مرور الجهاز"
  }
};
const invalidFormat$i = "صيغة غير صالحة";
const language$j = {
  title: "اختر اللغة"
};
const legacyhiddenwallet$i = {
  disable: "تعطيل خاصية المحفظة القديمة المخفية ",
  enable: "تفعيل خاصية المحفظة القديمة المخفية ",
  successDisable: "تم تعطيل خاصية المحفظة القديمة المخفية",
  successEnable: "تم تفعيل المحفظة القديمة المخفية. أعد توصيل BitBox وأدخل كلمة مرور الجهاز المخفية للوصول إلى المحفظة المخفية القديمة"
};
const loading$i = "جاري التحميل…";
const manageAccounts$c = {
  editAccount: "تعديل",
  editAccountNameTitle: "تعديل اسم الحساب",
  noAccounts: "لم يتم العثور على حسابات",
  settings: {
    hideTokens: "إخفاء العملات",
    showTokens: "إظهار العملات ({{activeTokenCount}})"
  },
  settingsButtonDescription: "إضافة وإظهار او إخفاء الحسابات",
  title: "إدارة الحسابات"
};
const mobile$d = {
  usingMobileDataWarning: "استخدام بيانات الهاتف المحمول: قد يقوم هذا التطبيق بتنزيل ما يصل إلى بضع مئات من الميجابايت من بيانات تعريفية للبلوكشين بعد فتح الحساب. يرجى الاتصال بالانترنت Wi-Fi لتجنب الضغط على  انترنت الجوال. لن تظهر هذه الرسالة لك مرة أخرى بعد هذه المرة"
};
const note$e = {
  input: {
    description: "(اختياري)",
    placeholder: "اضف ملاحظة…"
  },
  title: "ملاحظة"
};
const notification$i = {
  newTxs_one: "معاملة جديدة في: {{accountName}}",
  newTxs_other: "{{count}} معاملات جديدة في: {{accountName}}"
};
const pairing$i = {
  aborted: {
    text: "تم إلغاء الاقتران من تطبيق الهاتف المحمول",
    title: "تم الايقاف"
  },
  button: "إقران تطبيق الهاتف المحمول",
  confirm: "هل أنت متأكد أنك تريد إقران BitBox الخاص بك؟ يرجى ملاحظة انك ستحتاج الهاتف المحمول لتنفيذ اي تداول بعد إقران الهاتف",
  connectOnly: {
    button: "ربط تطبيق الهاتف المحمول",
    title: 'امسح باستخدام تطبيق الهاتف المحمول الخاص بالجهاز عن طريق تحديد الخيار من القائمة "الاتصال بتطبيق سطح المكتب الجديد"'
  },
  error: {
    text: "حدث خطأ ما. يرجى البدء مرة أخرى",
    title: "خطأ"
  },
  pullFailed: {
    text: "فشلت محاولة جلب الرسالة من هاتفك المحمول عبر سيرفير التوصيل. قد يكون سيرفير التوصيل غير متصل بالإنترنت، يرجى الاتصال بالدعم",
    title: "فشل الجلب"
  },
  reconnectOnly: {
    button: "أعد توصيل تطبيق الهاتف المحمول"
  },
  scanningFailed: {
    text: "لم يستطع الهاتف المحمول من مسح الرسالة بنجاح. حاول مرة اخرى",
    title: "فشل المسح"
  },
  start: {
    hideAppQRCode: "إخفاء رمز الاستجابة السريعة QR",
    revealAppQRCode: "إظهار رمز الاستجابة السريعة QR",
    step1: "إذا لم يكن لديك تطبيق الهاتف المحمول، فيمكنك مسح رمز الاستجابة السريعة QR لـ Apple App Store أو Google Play Store اعتمادًا على نوع الهاتف الذي لديك",
    step2: 'قم بالمسح باستخدام تطبيق الهاتف المحمول الخاص بنا، والذي يمكنك العثور عليه تحت اسم "Digital Bitbox 2FA" في متاجر التطبيقات لنظامي التشغيل iOS و Android:'
  },
  started: {
    text: "الآن يرجى اتباع التعليمات الموجودة في تطبيق الهاتف المحمول",
    title: "رائع"
  },
  success: {
    text: "مبروك، لقد نجحت في إقران (ربط) جهاز BitBox الخاص بك بتطبيق الهاتف المحمول!",
    title: "نجاح"
  },
  timeout: {
    text: "انتهت مهلة الاقتران (الربط) بعد دقيقتين. ابدأ مرة أخرى إذا كنت لا تزال تريد إقران تطبيق الهاتف المحمول",
    title: "نفاذ الوقت"
  },
  title: "ربط الهاتف المحمول"
};
const passphrase$c = {
  considerations: {
    button: "اعتبارات النسخة الاحتياطية",
    message: "تضيف كلمة المرور طبقة من الحماية إلى النسخة الاحتياطية من محفظتك (شريحة microSD أو 24 كلمة). إذا كان لدى شخص ما حق الوصول إلى نسختك الاحتياطية ، فسيحتاج أيضًا إلى كلمة المرور للوصول إلى محفظتك.\n\nومع ذلك ، هذا يعني أنك ستحتاج <strong>كلا من عبارة المرور + النسخة الاحتياطية للمحفظة</strong> لاستعادة محفظتك التي تدعم كلمة المرور ، في حالة فقدان او عطل BitBox02. إذا نسيت أو فقدت كلمة مرورك ، فستفقد إمكانية الوصول إلى جميع العملات الموجودة في تلك المحفظة.\n\nعند تخزين كلمة مرورك ، ضع في اعتبارك وضعها في مكان منفصل عن النسخة الاحتياطية. بهذه الطريقة ، إذا وجد شخص ما النسخة الاحتياطية الخاصة بك ، فلن يجد كلمة مرورك أيضًا.",
    title: "اعتبارات النسخة الاحتياطية"
  },
  disable: "تعطيل كلمة المرور",
  disableInfo: {
    button: "تعطيل",
    message: "بعد تعطيل خاصية طلب كلمة المرور ، لن يتم الطلب منك لإدخال كلمة مرور بعد إلغاء القفل BitBox02. لذلك ، سوف تدخل محفظتك الافتراضية.\n\nستظل جميع العملات في المحفظة ذات كلمة المرور كما هي في المحفظة ، ولكن لن تتمكن من الوصول إليها لأنه بعد فتح BitBox02 ، ستفتح محفظتك الاساسية الاولى.\n\nللوصول إلى المحفظة ذات كلمة المرور الخاصة بك مرة أخرى ، ما عليك سوى إعادة تمكين ميزة كلمة المرور وإدخال كلمة المرور الخاصة بها بعد إلغاء قفل BitBox02.\n\n<strong>نصيحة:</strong> لا يزال بإمكانك دخول محفظتك الأصلية عن طريق ترك كلمة المرور فارغة."
  },
  enable: "تفعيل كلمة المرور",
  error: {
    e104: "تم إيقاف تغيير إعداد كلمة المرور"
  },
  how: {
    button: "كيف تظهر",
    message: "لا تعمل كلمة المرور مثل كلمة المرور التي اعتدت عليها. إذا أخطأت في كتابة كلمة مرورك ، فلن يتم تنبيهك. هذا بسبب <strong>كل كلمة مرور تنشئ محفظة مختلفة ولكنها صالحة</strong>. هذا يعني أنه يمكنك استخدام كلمات مرور متعددة لأي عدد تريده من المحفظات. ولكن لا يمكن الوصول إلى كل محفظة إلا عند كتابة كلمة المرور المقابلة.\n\nعند توصيل BitBox02 ، ستتم مطالبتك بكلمة مرور الجهاز كالمعتاد. بعد ذلك ، سيُطلب منك إدخال كلمة مرور على الجهاز.\n\nبعد إدخال كلمة المرور ، ستظهر لك كلمة المرور التي أدخلتها. هذا حتى تتمكن من تأكيد أنك أدخلته بشكل صحيح.",
    title: "كيف تعمل"
  },
  intro: {
    message: "توفر كلمة المرور طبقة إضافية من الأمان على محفظتك.\nدعونا نتعلم كيف تعمل",
    title: "إعداد كلمة المرور"
  },
  progressDisable: {
    message: "قم بتأكيد الاختيار على جهاز المحفظة <strong>لايقاف تفعيل</strong> كلمة المرور الاختيارية",
    title: "قم بالتأكيد على الجهاز"
  },
  progressEnable: {
    message: "قم بتأكيد الاختيار على جهاز المحفظة <strong>لتفعيل</strong> كلمة المرور الاختيارية",
    title: "قم بالتأكيد على الجهاز"
  },
  successDisabled: {
    message: "<strong>تم التفعيل بنجاح</strong> لكلمة المرور الاختيارية!\nسيبدأ طلب كلمة مرور منك من الآن فصاعدًا.",
    messageEnd: "يرجى إعادة توصيل BitBox02 الآن",
    title: "تم تفعيل خاصية كلمة المرور"
  },
  successEnabled: {
    message: "<strong>تم ايقاف التفعيل بنجاح</strong> لكلمة المرور الاختيارية!\n\nلن يتم طلب كلمة مرور منك بعد الآن.",
    messageEnd: "يرجى إعادة توصيل BitBox02 الخاص بك الآن",
    tips: "نصائح",
    tipsList: [
      "نقترح إرسال مبلغ صغير إلى المحفظة التي فيها كلمة المرور أولاً. ثم افصل جهاز BitBox02 وأعد توصيله وأدخل كلمة السر وكلمة المرور الخاصة بك. إذا أدخلت كلمة المرور بشكل صحيح فستجد العملات في محفظتك",
      "إذا كنت تريد الدخول الى محفظتك الأصلية بدون كلمة مرور ، فلا يزال بإمكانك القيام بذلك عن طريق عدم إدخال أي شيء عند مطالبتك بإدخال كلمة المرور. أو يمكنك تعطيل ميزة كلمة المرور"
    ],
    title: "الغاء تفعيل كلمة المرور"
  },
  summary: {
    button: "تفعيل كلمة المرور",
    title: "خلاصة",
    understand: "انا أفهم كيف تعمل كلمة المرور والمخاطر المرتبطة بها",
    understandList: [
      "كلمة المرور هي طبقة أمان إضافةً الى النسخة الاحتياطية",
      "سيؤدي إدخال كلمة مرور مختلفة إلى إنشاء محفظة مختلفة",
      "لاستعادة محفظتك تحتاج <strong>كل من كلمة المرور والنسخة الاحتياطية</strong>",
      "إذا نسيت كلمة مرورك ، فلن يكون بإمكانك الوصول إلى عملاتك"
    ]
  },
  what: {
    button: "تعلم كيف يعمل هذا الشي",
    message: "يتم إنشاء (اشتقاق) المحفظة من رقم عشوائي كبير جدًا ، يُعرف أيضًا باسم المفاتيح. يتم إنشاء هذه المفاتيح عند إعداد BitBox02 لأول مرة ويتم نسخها احتياطيًا باستخدام شريحة microSD أو 24 كلمة. أي شخص لديه حق الوصول إلى البذور لديه سيطرة كاملة على الأموال الموجودة في تلك المحفظة.\n\nعبارة المرور هي ملف <strong>سر اختياري</strong>، يضاف إلى المفاتيح (الكلمات السرية). عند استخدام كلمة مرور ، تُنشئ كل كلمة مرور محفظة جديدة بناءاً على المفاتيح + كلمة المرور (سر اختياري). يمكن أن تكون كلمة المرور أي شيء: أحرف أو كلمات أو أحرف خاصة أو يمكن أن تكون فارغة. المحفظة الاصلية مشتقة في الواقع من المفاتيح + كلمة مرور فارغة.\n\nتعد كلمة المرور جزءًا من معيار BIP39 ، مما يعني أنها متوافقة مع جميع المحفظات التي تدعم نفس المعيار",
    title: "ما هي كلمة المرور؟"
  },
  why: {
    button: "لماذا استخدام كلمة المرور",
    message: 'يحمي BitBox02 المفاتيح من الاستخراج من الجهاز نفسه ، لكن النسخة الاحتياطية (شريحة microSD أو 24 كلمة) تتيح الوصول الكامل إلى المحفظة. لهذا يجب تخزينها في مكان آمن!\n\nنظرًا لأن كلمة المرور تنشئ محفظة جديدة باستخدام مفاتيحك الحالية ، فإن محفظة كلمة المرور تتطلب كلاً من ملف <strong>النسخة الاحتياطية و كلمة المرور للاستعادة</strong>. وتتمثل فائدة ذلك في أنه إذا وجد شخص ما النسخة الاحتياطية الخاصة بك ، فسيظل بحاجة إلى كلمة المرور للوصول إلى المحفظة المحمية بكلمة المرور.\n\nبالإضافة إلى ذلك ، تتيح لك ميزة كلمة المرور إنشاء محفظات متعددة على نفس الجهاز ، أو "محفظات مخفية" بالإضافة إلى المحفظة الافتراضية.',
    title: "لماذا استخدام كلمة المرور؟"
  }
};
const password$i = {
  show: "عرض {{label}}",
  warning: {
    caps: "تحذير: تم تمكين caps lock (⇪)",
    paste: 'للصق النص، قم بتمكين "إظهار {{label}}"'
  }
};
const random$j = {
  button: "صناعة رقم عشوائي",
  description: "أنشأ BitBox الخاص بك الرقم العشوائي {{bits}}-بت التالي:"
};
const receive$k = {
  changeScriptType: "تغيير نوع العنوان",
  label: "عنوانك",
  onlyThisCoin: {
    description: "لتلقي العملات الأخرى ، قم بتمكينها في الإعدادات. إذا قمت بإيداع عملات مختلفة ، فقد يتعذر الوصول إليها",
    warning: "تأكد من أنك تستلم {{coinName}} فقط على هذا العنوان"
  },
  scriptType: {
    p2tr: "Taproot (أحدث صيغة)",
    p2wpkh: "Native Segwit (اصلي)",
    "p2wpkh-p2sh": "الـ Segwit المبطن (صيغة متوافقة)"
  },
  showFull: "إظهار العنوان الكامل على الجهاز والتحقق منه",
  taprootWarning: "ملاحظة: Taproot هي ميزة بروتوكول جديدة من بتكوين ولم يتم اعتمادها على نطاق واسع بعد. قد لا تظهر الأموال المستلمة على عناوين Taproot في محفظات المراقبة فقط التابعة لجهات خارجية. العديد من المحفظات والتبادلات ليست قادرة بعد على الإرسال إلى عناوين Taproot",
  title: "استلم {{accountName}}",
  verify: "تحقق من العنوان بشكل آمن",
  verifyBitBox01: "تحقق من العنوان على تطبيق الهاتف المحمول",
  verifyBitBox02: "تحقق من العنوان على BitBox02",
  verifyInstruction: "يرجى التحقق من أن العنوان التالي يطابق العنوان المعروض على جهازك",
  warning: {
    secureOutput: 'يرجى إقران BitBox بجهازك المحمول لتمكين التحقق من العنوان الآمن. انتقل إلى "إدارة الجهاز" في الشريط الجانبي'
  }
};
const reset$i = {
  description: "سيتم حذف جميع البيانات الموجودة على الجهاز. بما يتضمن مفتاحك الخاص!",
  notReset: "لم يتم إعادة ضبط الجهاز",
  title: "جهاز إعادة ضبط المصنع",
  understand: "لدي نسخة احتياطية وأعرف كلمة مرور الاسترداد الخاصة بي",
  understandBB02: "لدي نسخة احتياطية صالحة"
};
const securityInformation$i = {
  create: {
    description1: "نوصيك بإعداد جهازك في مكان آمن، مما يعني أنك بعيد عن الأشخاص الآخرين الذين يمكنهم رؤية كلمة المرور التي تختارها",
    description2: "سيُطلب منك إنشاء كلمتين من كلمات المرور",
    description3: "الأول هو <strong>كلمه مرور الجهاز</strong> الذي يفتح جهاز BitBox الخاص بك ويمكن تغييره لاحقاً",
    description4: "والثاني هو <strong>استعادة كلمة المرور</strong> الذي يفتح محفظتك. لا يمكن تغيير كلمة المرور هذه لاحقاً",
    description5: "سيتم نسخ المحفظة التي تقوم بإنشائها احتياطيًا في ملف موجود على شريحة microSD المتوفرة. يمكن استخدام هذا في حالات الطوارئ لاسترداد أموالك باستخدام <strong>استعادة كلمة المرور</strong>.",
    title: "بيانات امنية"
  },
  restore: {
    description1: "سيُطلب منك إدخال شريحة microSD التي استخدمتها لتخزين النسخة الاحتياطية",
    description2: "لاستعادة جهازك ، ستحتاج إلى كلمة مرور الاسترداد الخاصة بك",
    description3: "يرجى توخي الحذر عند إدخال كلمة مرور الاسترداد. أي كلمة مرور تدخلها ستنشئ محفظة صالحة. إذا أدخلت كلمة مرور خاطئة ، فقد يظهر لك رصيد خاطئ في المحفظة",
    title: "بيانات امنية"
  }
};
const seed$i = {
  agreements: {
    "funds-access": "لن أتمكن من الوصول إلى أموالي إذا نسيت كلمة مرور الاسترداد الخاصة بي",
    "password-change": "لا يمكنني تغيير كلمة مرور الاسترداد لاحقاً",
    "password-required": "كلمة مرور الاسترداد مطلوبة لاستعادة المحفظة من نسخة احتياطية"
  },
  create: "صنع المحفظة",
  creating: "إنشاء المحفظة",
  description: "انا افهم التالي:",
  error: {
    e102: "يجب ان تحتوي كلمة المرور على 4 رموز على الاقل",
    e200: "تحتاج إلى إدخال شريحة microSD في BitBox الخاص بك من أجل إنشاء محفظة، بحيث يمكن إنشاء نسخة احتياطية تلقائيًا"
  },
  info: {
    button: "قم بتعيين كلمة مرور الاسترداد الآن",
    description1: "أدخل شريحة microSD في BitBox",
    description2: 'اختر كلمة مرور استرداد للمحفظة و حدد "تعيين كلمة مرور الاسترداد الآن"',
    description3: "النسخة الاحتياطة لشريحة microSD وكلمة مرور الاسترداد هي الطريقة الوحيدة لاسترداد أموالك في حالة فقدان جهاز BitBox أو سرقته",
    description4: "لا يمكنك تغيير كلمة مرور الاسترداد الخاصة بك لاحقًا دون تحويل أموالك",
    title: "أنشئ محفظة جديدة"
  },
  password: {
    label: "استعادة كلمة المرور",
    repeatPlaceholder: "تكرار كلمة استعادة المرور"
  },
  walletName: {
    label: "اسم المحفظة"
  }
};
const seedRestore$i = {
  error: {
    e200: "تتطلب عملية استعادة محفظة من نسخة احتياطية وجود شريحة microSD"
  },
  info: {
    description1: 'أدخل شريحة microSD في BitBox و اكبس على "استمرار"',
    description2: 'اختر نسخة احتياطية و اكبس على "استعادة"',
    description3: "أدخل كلمة مرور الاسترداد",
    description4: "تحتاج إلى التأكيد لفهم أن كلمة المرور غير الصحيحة ستؤدي إلى إنشاء محفظة مختلفة",
    title: "كيفية استعادة محفظة من نسخة احتياطية"
  }
};
const send$k = {
  abort: "تم إيقاف المعاملة",
  address: {
    label: "عنوان المستلم",
    placeholder: "أدخل العنوان"
  },
  amount: {
    label: "المبلغ",
    placeholder: "أدخل المبلغ"
  },
  availableBalance: "الرصيد المتبقي",
  button: "إعادة التدقيق",
  coincontrol: {
    address: "عنوان",
    outpoint: "نقطة الخروج",
    title: "أرسل من الإخراج"
  },
  confirm: {
    "selected-coins": "عملات مختارة",
    title: "تأكيد و إرسال المعاملة",
    total: "المجموع"
  },
  error: {
    erc20InsufficientGasFunds: "يبدو أنه ليس لديك ما يكفي من الاثيريوم للدفع مقابل معاملة ERC20 هذه. يرجى التأكد من أن لديك ما يكفي من الاثيريوم في محفظتك",
    feeTooLow: "رسوم منخفضة للغاية",
    feesNotAvailable: "لا يمكن تقييم الرسوم",
    insufficientFunds: "رصيد غير كافي",
    invalidAddress: "عنوان خاطئ",
    invalidAmount: "مبلغ غير صحيح",
    invalidData: "بيانات غير صالحة"
  },
  fee: {
    customPlaceholder: "أدخل المبلغ",
    label: "رسوم الشبكة",
    placeholder: "غير متوفر"
  },
  feeTarget: {
    customLabel: "معدل الرسوم",
    customLabel_eth: "سعر عمولة الجاز",
    description: {
      economy: "4 ساعات (24 بلوك)",
      economy_eth: "30 دقيقة أو أقل",
      economy_ltc: "ساعة واحدة (24 بلوك)",
      high: "20 دقيقة (بلوكين)",
      high_eth: "30 ثانية أو أقل",
      high_ltc: "5 دقائق (بلوكين)",
      low: "ساعتان (12 بلوك)",
      low_eth: "5 دقائق أو أقل",
      low_ltc: "30 دقيقة (12 بلوك)",
      normal: "1 ساعة (6 بلوكات)",
      normal_eth: "دقيقتان أو أقل",
      normal_ltc: "15 دقيقة (6 بلوكات)"
    },
    estimate: "تقدير مدة التأكيد:",
    label: {
      custom: "معدلة",
      economy: "توفيري",
      high: "عالية",
      low: "منخفضة",
      normal: "عادي"
    },
    placeholder: "جاري حساب الرسوم ..."
  },
  maximum: "أرسل كل شيء",
  maximumSelectedCoins: "أرسل العملات المختارة",
  priority: "أولوية",
  scanQR: "مسح رمز الاستجابة السريعة QR",
  signprogress: {
    description: "هذه معاملة تحتوي على الكثير من البيانات. لتوقيع المعاملة بالكامل ، سيُطلب منك التأكيد {{steps}} مرات",
    label: "تقدم"
  },
  success: "تم توقيع المعاملة وإرسالها",
  title: "إرسال {{accountName}}",
  toggleCoinControl: "تبديل خاصية التحكم في العملة coin control",
  transactionDetails: "تفاصيل المعاملة"
};
const settings$j = {
  electrum: {
    add: "أضف السيرفير",
    "add-server": "اضافة",
    check: "تأكد",
    checkFailed: "فشلت المحاولة",
    checkSuccess: "تم بنجاح إنشاء اتصال بـ {{host}}",
    checking: "التأكد",
    "download-cert": "قم بتنزيل الشهادة عن بعد",
    "remove-server": "حذف",
    removeConfirm: "حذف {{server}}؟",
    reset: "إعادة الحالة إلى الحالة الاصلية",
    resetConfirm: "هل تريد إزالة جميع السيرفيرات وتثبيت السيرفيرات الافتراضية؟",
    servers: "سيرفيرات",
    step1: "1",
    "step1-text": "قم بإدخال نقطة النهاية",
    step2: "2",
    "step2-text": "أدخل شهادة من سلسلة شهادات السيرفير. أو بدلاً من ذلك ، قم بتنزيل الشهادة عن بُعد ومقارنتها بصريًا",
    "step2-text-tcp": "يمكنك تخطي هذه الخطوة إذا كنت لا تريد استخدام TLS",
    step3: "3",
    "step3-text": "تحقق من الاتصال وأضف السيرفير",
    step4: "4",
    "step4-text": "أعد تشغيل المحفظة. إذا لم تقم بإزالة السيرفيرات الاولية، فستتم إضافة النود الخاصة بك كاحتياط",
    "title-btc": "سيرفيرات Electrum لعملة بتكوين ",
    "title-ltc": "سيرفيرات Electrum لعملة لايتكوين ",
    "title-tbtc": "سيرفيرات Electrum للشبكة التجريبية لعملة بتكوين ",
    "title-tltc": "سيرفيرات Electrum للشبكة التجريبية لعملة لايتكوين "
  },
  expert: {
    coinControl: "تفعيل خاصية التحكم في العملة coin control",
    electrum: {
      title: "قم بتوصيل النود الخاصة بك"
    },
    fee: "تفعيل الرسوم القابلة للتعديل",
    setProxyAddress: "تعيين عنوان بروكسي",
    title: "الإعدادات المتقدمة",
    useProxy: "تفعيل tor proxy",
    useSats: "عرض قيم البتكوين بوحدة Satoshi"
  },
  header: {
    home: "الواجهة الرئيسية"
  },
  info: {
    "out-of-date": "هنالك تحديث جديد",
    title: "معلومات",
    "up-to-date": "تطبيقك فيه آخر تحديث",
    version: "نسخة التطبيق"
  },
  restart: "يرجى إعادة تشغيل تطبيق BitBox من اجل تفعيل التغييرات",
  services: {
    title: "الخدمات"
  },
  success: "يرجى فصل BitBox وإعادة توصيله من اجل تفعيل التغييرات",
  title: "الإعدادات"
};
const setup$i = "إعداد الجهاز";
const sidebar$j = {
  buy: "شراء العملات المشفرة",
  device: "إدارة الجهاز",
  leave: "الخروج",
  settings: "إعدادات"
};
const success$p = {
  create: {
    info1: "تم نسخ محفظتك احتياطيًا بشكل آمن إلى شريحة microSD. قم بإزالته واحتفظ به بشكل آمن في مكان آمن",
    info2: "لقد أنشأت كلمة مرور آمنة للجهاز لفتح قفل BitBox",
    info3: "لقد أنشأت كلمة مرور آمنة لاسترداد محفظتك و الدخول الى أموالك و استعادة نسختك الاحتياطية",
    summary: "هنا ملخص لما قمت به",
    title: "نجاح"
  },
  getstarted: "البدء",
  restore: {
    summary: "لقد نجحت في استعادة محفظة من نسختك الاحتياطية",
    title: "النجاح"
  }
};
const transaction$j = {
  confirmation: "التأكيدات",
  details: {
    activity: "النشاط",
    address: "عنوان",
    amount: "المبلغ",
    date: "التاريخ",
    fiat: "العملة التقليدية (فيات)",
    fiatAmount: "كمية مبلغ العملة التقليدية",
    fiatAtTime: "العملة التقليدية في وقت التداول",
    status: "الحالة",
    type: "النوع"
  },
  explorer: "رقم المعاملة",
  explorerTitle: "فتح في مستكشف البلوكشين",
  fee: "العمولة",
  fiatHistorical: "تاريخي",
  gas: "عمولة الجاز",
  note: {
    edit: "تعديل مذكرة",
    save: "احفظ المذكرة"
  },
  pending: "عملية تداول معلقة",
  size: "حجم",
  status: {
    complete: "اكتملت",
    failed: "فشلت المحاولة",
    pending: "قيد الانتظار"
  },
  tx: {
    received: "تم الاستلام الى",
    sent: "تم الارسال الى"
  },
  vsize: "الحجم الافتراضي",
  weight: "وزن"
};
const transactions$i = {
  placeholder: "لا توجد معاملات حتى الآن"
};
const unknownError$i = "حدث خطأ غير معروف: {{errorMessage}}";
const unlock$i = {
  description: "أدخل كلمة مرور جهازك لفتح قفل جهازك",
  error: {
    e109_normal: "كلمة مرور الجهاز خاطئة. {{remainingAttempts}} محاولات متبقية قبل إعادة ضبط الجهاز",
    e109_touch: "$t(unlock.error.e109_normal) يتطلب تسجيل الدخول التالي الضغط على زر اللمس",
    e113: "نظرًا لمحاولات تسجيل الدخول العديدة ، يتطلب في محاولة تسجيل الدخول التالية ان تضغط على زر اللمس لمدة 4 ثواني"
  },
  input: {
    label: "كلمه مرور الجهاز",
    placeholder: "أدخل كلمة مرور جهازك لفتح قفل الجهاز"
  },
  unlocking: "جاري فتح القفل ..."
};
const upgradeFirmware$j = {
  button: "تحديث البرنامج الثابت",
  description: "هل تريد ترقية البرنامج الثابت من الإصدار {{currentVersion}} إلى {{newVersion}}؟",
  label: "يتطلب جهازك BitBox تحديث البرنامج الثابت",
  locked: "للتحديث من {{currentVersion}} إلى {{newVersion}}، من فضلك قم بلمسة طويلة",
  title: "تحديث البرنامج الثابت",
  unlocked: "محمل التشغيل للبرنامج مفتوح. للاستمرار، يرجى:",
  unlocked1: "افصل وأعد توصيل Bitbox",
  unlocked2: "سيضيء LED عند توصيل BitBox مرة أخرى",
  unlocked3: "اضغط على زر اللمس عندما يضيء ضوء LED"
};
const warning$o = {
  receivePairing: 'يرجى ربط BitBox لتمكين التحقق من العنوان الآمن. انتقل إلى "إدارة الجهاز" في الشريط الجانبي',
  sdcard: "احتفظ بشريحة microSD المخزونة منفصلة عن BitBox ، إلا إذا كنت تريد إدارة النسخة الاحتياطية",
  sendPairing: "يرجى ربط جهاز BitBox من اجل التأكد من تفاصيل التداولات بشكل آمن. إذهب الى ‘لتحكم بالجهاز‘ في القائمة الجانبية"
};
const welcome$i = {
  getStarted: "لنبدأ بتثبيت نظام تشغيل جهاز محفظة BitBox02",
  insertBitBox02: "يرجى الكبس على جهاز المحفظة للاستمرار في محفظة BitBox02 ",
  insertDevice: "يرجى ربط جهازك للبدء",
  title: "مرحباً"
};
const appTranslationsAR = {
  account: account$i,
  accountInfo: accountInfo$i,
  accountSummary: accountSummary$i,
  addAccount: addAccount$j,
  aopp: aopp$c,
  app: app$i,
  backup: backup$i,
  bb02Bootloader: bb02Bootloader$i,
  bitbox: bitbox$i,
  bitbox02Interact: bitbox02Interact$i,
  bitbox02Settings: bitbox02Settings$i,
  bitbox02Wizard: bitbox02Wizard$i,
  blink: blink$i,
  bootloader: bootloader$i,
  button: button$n,
  buy: buy$e,
  changePin: changePin$i,
  chart: chart$e,
  checkSDcard: checkSDcard$i,
  clickHere: clickHere$i,
  confirm: confirm$k,
  confirmOnDevice: confirmOnDevice$i,
  device: device$i,
  deviceLock: deviceLock$i,
  deviceSettings: deviceSettings$i,
  deviceTampered: deviceTampered$i,
  dialog: dialog$j,
  error: error$e,
  fiat: fiat$k,
  footer: footer$k,
  generic: generic$e,
  genericError: genericError$i,
  goal: goal$i,
  guide: guide$j,
  headerssync: headerssync$i,
  hiddenWallet: hiddenWallet$i,
  initialize: initialize$i,
  invalidFormat: invalidFormat$i,
  language: language$j,
  legacyhiddenwallet: legacyhiddenwallet$i,
  loading: loading$i,
  manageAccounts: manageAccounts$c,
  mobile: mobile$d,
  note: note$e,
  notification: notification$i,
  pairing: pairing$i,
  passphrase: passphrase$c,
  password: password$i,
  random: random$j,
  receive: receive$k,
  reset: reset$i,
  securityInformation: securityInformation$i,
  seed: seed$i,
  seedRestore: seedRestore$i,
  send: send$k,
  settings: settings$j,
  setup: setup$i,
  sidebar: sidebar$j,
  success: success$p,
  transaction: transaction$j,
  transactions: transactions$i,
  unknownError: unknownError$i,
  unlock: unlock$i,
  upgradeFirmware: upgradeFirmware$j,
  warning: warning$o,
  welcome: welcome$i
};
const account$h = {
  disconnect: "Ztráta spojení. Pokus o opětovné připojení...",
  "export": "Export",
  exportTransactions: "Export transakcí do složky ke stažení jako soubor CSV",
  fatalError: "Došlo k neočekávané chybě.",
  incoming: "Přicházející",
  initializing: "Získávání informací z blockchainu...",
  insuranceExpired: "<strong>Účet již není pojištěn</strong>\n\nPlán pojištění tohoto účtu byl změněn.\nPodrobnosti naleznete na stránkách týkající se pojištění.",
  insured: "Pojištěný účet",
  maybeProxyError: "Tor proxy aktivní. Ujistěte se, že proxy server Tor běží správně, nebo nastavení proxy serveru deaktivujte.",
  reconnecting: "Ztráta spojení. Pokus o opětovné připojení...",
  syncedAddressesCount: "Naskenováno {{count}} adres",
  uncoveredFunds: "Máte prostředky na následujících nepokrytých typech adresách vašeho <strong>{{name}}</strong> účtu: {{uncovered}}.\nVzhledem k tomu, že účet je pojištěný, vztahuje se pouze na prostředky přijaté prostřednictvím adresy typu <strong>Native  Segwit</strong>. Prostředky na odlišných typech adres, i když jsou na stejném účtu, pojištěny nejsou.\nPřesuňte prosím všechny své mince z nepodporovaných typů adres na adresy typu <strong>Native Segwit</strong>, aby byly všechny vaše prostředky na tomto účtu pojištěny.",
  uncoveredFundsLink: "Postupujte podle tohoto průvodce, jak přesunout své prostředky.",
  warning: "Varování! "
};
const accountInfo$h = {
  address: "Adresa",
  buyCTA: {
    buy: "Koupit  {{unit}}",
    buyCrypto: "Koupit Krypto",
    information: {
      looksEmpty: "Zdá se, že tato peněženka je prázdná.",
      start: "Začněte vkladem do peněženky, nebo nákupem přímo v BitBoxApp."
    }
  },
  extendedPublicKey: "Veřejný klíč",
  label: "Detaily účtu",
  scriptType: "Typ účtu",
  title: "Detaily účtu",
  verify: "Ověřte na zařízení",
  xpubTypeChangeBtn: {
    p2pkh: "Zobrazit legacy P2PKH veřejný klíč",
    p2tr: "Zobrazit Taproot",
    p2wpkh: "Zobrazit nativní Segwit",
    "p2wpkh-p2sh": "Zobrazit starší Segwit veřejný klíč"
  },
  xpubTypeInfo: "Aktuálně se zobrazuje {{scriptType}} veřejný klíč ({{current}} z {{numberOfXPubs}})"
};
const accountSummary$h = {
  availableBalance: "Dostupný zůstatek",
  balance: "Zůstatek",
  exportSummary: "Exportovat přehled účtů do složky ke stažení jako soubor CSV",
  fiatBalance: "Fiat zůstatek",
  name: "Název účtu",
  noAccount: "Žádné účty k zobrazení.",
  subtotalWithCoinName: "Celkem ({{coinName}})",
  title: "Moje portfolio",
  total: "Celkem",
  transactionHistory: "Transakční historie"
};
const addAccount$i = {
  chooseName: {
    nextButton: "Přidat účet",
    step: "Pojmenujte účet",
    title: "Pojmenujte svůj účet"
  },
  selectCoin: {
    nextButton: "Další",
    step: "Vybrat kryptoměnu",
    title: "Vybrat kryptoměnu"
  },
  success: {
    addAnotherAccount: "Přidat další účet",
    message: "<strong>{{accountName}}</strong> byl nyní přidán k vašim účtům.",
    nextButton: "Hotovo",
    step: "Dokončeno",
    title: "Účet přidán"
  },
  title: "Přidat účet"
};
const aopp$b = {
  addressRequest: "{{host}} požaduje přijímací adresu.",
  addressRequestWithLogo: "požaduje přijímací adresu.",
  banner: "Probíhá žádost o adresu. Pro pokračování připojte zařízení.",
  errorTitle: "Chyba při požadavku na adresu ",
  labelAddress: "Adresa",
  labelMessage: "Zpráva",
  reverifyInfoText: "Ověřit adresu",
  signing: "Chcete-li pokračovat, podepište zprávu na svém BitBoxu",
  success: {
    message: "Pokračovat na {{host}}",
    title: "Adresa byla úspěšně odeslána"
  },
  syncing: "Synchronizace účtu, vyčkejte prosím.",
  title: "Požadavek na adresu"
};
const app$h = {
  upgrade: "K dispozici je nová verze této aplikace! Aktualizuje prosím z {{current}} na {{version}}."
};
const auth$b = {
  authButton: "Ověřit",
  title: "Chcete-li pokračovat, proveďte ověření"
};
const backup$h = {
  check: {
    checking: "Kontrola zálohy...",
    confirmTitle: "Zkontrolovat zálohu",
    notOK: "Záloha NEODPOVÍDÁ peněžence.",
    ok: "Záloha odpovídá peněžence.",
    password: {
      label: "Heslo pro obnovení",
      placeholder: "Heslo pro obnovení",
      showLabel: "heslo pro obnovení"
    },
    success: "Záloha byla úspěšně ověřena:",
    title: "Zkontrolovat zálohu"
  },
  create: {
    alreadyExists: "Již máte platnou zálohu. Chcete ji znovu vytvořit?",
    fail: "Vytvoření zálohy SELHALO!",
    info: "Pro ověření zadejte heslo pro obnovení aktuální peněženky.",
    name: {
      label: "Název zálohy",
      placeholder: "Pojmenujte prosím zálohu"
    },
    password: {
      label: "Heslo pro obnovení",
      placeholder: "Zadejte prosím heslo pro obnovení"
    },
    title: "Vytvořit zálohu",
    verificationFailed: 'Heslo pro obnovení se NESHODUJE s aktuální peněženkou. Záloha byla vytvořena. Pro opětovné ověření hesla pro obnovení použijte funkci "Zkontrolovat zálohu".'
  },
  description: "Vyberte <strong>soubor zálohy peněženky</strong>",
  insert: "Pro správu záloh prosím vložte microSD kartu.",
  insertButton: "Vložil jsem microSD kartu.",
  list: "Vaše zálohy na microSD kartě",
  noBackups: "Na této microSD kartě nejsou žádné zálohy.",
  restore: {
    confirmTitle: "Obnovit ze zálohy",
    error: {
      e200: "Karta microSD nenalezena",
      general: "Chyba při obnově ze zálohy"
    },
    password: {
      label: "Heslo pro obnovení nebo skryté heslo pro obnovení",
      placeholder: "Heslo pro obnovení",
      repeatPlaceholder: "Zopakujte heslo pro obnovení",
      showLabel: "Heslo pro obnovení"
    },
    restoring: "Obnova ze zálohy...",
    selectedBackup: "<strong>{{backupName}}</strong> vytvořena {{createdDateTime}} bude obnovena.",
    title: "Obnovit",
    understand: "Rozumím, že nesprávné heslo pro obnovení vytvoří jinou peněženku."
  },
  showMnemonic: {
    description: "Zobrazí se vám slova pro obnovení - obnovovací seed, ten tvoří zálohu vaší peněženky. Napište si je na papír.\n\n<strong>Neukládejte je digitálně ani je nefoťte.</strong>\n\n<strong>Neříkejte tato slova nahlas.</strong>\n\n<strong>Tato záloha není chráněna heslem.</strong>\n\nPoté budete vyzváni k potvrzení každého slova.",
    title: "Zobrazit slova pro obnovení",
    warning: "<strong> Nikdy nikomu nesdělujte svá slova pro obnovení.</strong> Vaše slova pro obnovení poskytují plný přístup k vaší peněžence. Pokud vás někdo žádá o vaše slova pro obnovení, jedná se o podvodníka, nesdílejte je!"
  },
  title: "Spravovat zálohy"
};
const bb02Bootloader$h = {
  abort: "Neaktualizovat - zpět",
  abort_noUpgrade: "Zpět",
  advanced: {
    label: "Rozšířená nastavení",
    toggleShowFirmwareHash: "Zobrazit hash firmwaru při každém spuštění"
  },
  flipscreen: "Otoč obrazovku",
  orientation: "Špatná orientace zařízení?",
  success: "Aktualizace úspěšná! Pokračování za {{rebootSeconds}} sekund...",
  success_install: "Instalace proběhla úspěšně! Pokračování za {{rebootSeconds}} sekund..."
};
const bitbox$h = {
  error: {
    e10000: "Heslo pro aktuální zařízení není správné.",
    e10001: "Nepodařilo se nahradit heslo zařízení",
    e102: "Heslo musí obsahovat alespoň 4 znaky.",
    e112: "Skryté heslo zařízení nemůže být stejné jako heslo hlavního zařízení."
  }
};
const bitbox02Interact$h = {
  confirmDate: "Potvrďte dnešní datum na svém BitBox02",
  confirmDateText: "Toto datum se použije pro vytvoření zálohy.",
  confirmName: "Potvrďte název na BitBox02",
  confirmWords: "Zapište si {{amount}} slov pro obnovení z vašeho BitBox02",
  confirmWordsText: "Poté vás BitBox02 požádá o potvrzení každého slova, aby se ověřilo, že záloha je správná.",
  followInstructions: "Postupujte podle pokynů na vašem BitBox02.",
  followInstructionsMnemonic: "Postupujte dle pokynů na Vašem BitBox02 – zadejte slova pro obnovení z vaší zálohy a obnovte peněženku.",
  followInstructionsMnemonicTitle: "Obnovit ze slov pro obnovení"
};
const bitbox02Settings$h = {
  deviceName: {
    current: "Aktuální název zařízení",
    error: "Název zařízení se nepodařilo nastavit",
    error_104: "Potvrzení názvu zařízení bylo na zařízení zrušeno.",
    input: "Název BitBox02",
    placeholder: "Nový název zařízení",
    title: "Nastavit název pro BitBox02"
  },
  gotoStartupSettings: {
    description: "Tím se zařízení BitBox02 restartuje a vstoupí do nastavení při spuštění.",
    title: "Přejít do nastavení při spuštění"
  }
};
const bitbox02Wizard$h = {
  advanced: {
    button: "Pokročilé nastavení",
    outOfDate: "Firmware je pro tuto funkci zastaralý",
    seed12WordInfo: "Upozorňujeme, že počet slov nelze po vytvoření peněženky změnit.",
    seed12WordLabel: "Vytvořit 12slovný namísto 24slovného seed",
    seed12WordText: "Ve výchozím nastavení používá BitBox02 seed s 24 slovy. Obě délky seedů jsou v praxi bezpečné proti brute force útoku. Někteří uživatelé mohou místo toho upřednostnit 12slovný seed.",
    skipSDCardLabel: "Přeskočte zálohování na microSD kartu a místo toho si zapište slova pro obnovení.",
    skipSDCardText: "Po nastavení máte vždy možnost vytvořit zálohu karty microSD nebo zapsat slova pro obnovení. To lze provést z nastavení.",
    title: "Pokročilé možnosti zálohování"
  },
  attestationFailed: "Kontrola originality selhala, což mohlo být způsobeno restartováním aplikace v době, kdy zařízení čekalo na vstup uživatele. Znovu se připojte a zkuste to znovu. Pokud tento problém přetrvává, obraťte se prosím na support@bitbox.swiss.",
  backup: {
    point1: "Vyberte zálohu na microSD kartě",
    point2: "Nastavit heslo pro zařízení",
    restoreText: "Ok, obnovíme ze zálohy!",
    text1: "Skvělé, vaše heslo pro BitBox02 je nyní nastaveno a peněženka vytvořena. Nyní je čas vytvořit první zálohu. Ujistěte se, že je vaše microSD karta vložena do vašeho BitBox02 a pokračujte.",
    text2: "Vytvořte zálohu podle pokynů na obrazovce zařízení.",
    text3: "Po vytvoření zálohy vyjměte microSD kartu a uložte ji na <strong>bezpečné místo</strong>. Obsah microSD karty není chráněn heslem. Nikdy jej nevkládejte do jiného zařízení než do vašeho BitBox02.",
    userConfirmation1: "Zálohu bych měl uložit na bezpečném místě.",
    userConfirmation2: "Moje záloha není chráněna heslem. Kdokoli, kdo k ní má přístup, má přístup k mé peněžence.",
    userConfirmation3: "Pokud ztratím nebo poškodím svůj BitBox02, jediný způsob, jak získat zpět své prostředky, je obnovit peněženku ze zálohy.",
    userConfirmation4: "Pokud ztratím nebo poškodím zálohu i BitBox02, přijdu o své prostředky.",
    userConfirmation5: "MicroSD kartu s mou zálohou bych neměl vkládat do počítače, telefonu, tiskárny nebo jiného zařízení než BitBox02.",
    userConfirmation5mnemonic: "Neměl bych vkládat slova pro obnovení do počítače, telefonu, tiskárny nebo jiného zařízení, než je BitBox02."
  },
  create: {
    button: "Pojmenujte zařízení a pokračujte",
    info: "Zde jsou základní kroky, které je třeba udělat pro nastavení vašeho BitBoxu: ",
    inputTitle: "Název peněženky",
    point1: "Pojmenujte své zařízení",
    point2: "Nastavte heslo pro své zařízení",
    point3: "Vytvořit zálohu",
    text: "Ok, pojďme vytvořit novou peněženku!"
  },
  createBackupAborted: "Vytváření zálohy bylo zrušeno.",
  createBackupFailed: "Vytvoření zálohy se nezdařilo, zkuste to znovu.",
  initialize: {
    passwordText: "Nyní nastavíme heslo pro vaše zařízení. K zadání a výběru hesla použijte ovládací prvky na BitBoxu.",
    passwordTitle: "Nastavte heslo pro svůj BitBox",
    text: "Váš BitBox02 byl úspěšně spárován! Nyní inicializujeme vaše zařízení. Začněte výběrem vytvořit novou peněženku nebo obnovit peněženku ze zálohy. <strong>Ujistěte se, že je v Bitboxu vložena microSD karta</strong>",
    tip: "Doporučujeme, abyste pokračovali na bezpečném místě.",
    title: "Inicializujte svůj BitBox"
  },
  insertSDCard: "<strong>Ujistěte se, že je ve vašem BitBoxu vložena microSD karta.</strong>",
  noPasswordMatch: "Hesla se neshodují, zkuste to prosím znovu.",
  pairing: {
    failed: "Spárování nepotvrzeno. Znovu připojte svůj BitBox02.",
    paired: "Na svém zařízení jste potvrdili následující kód. Prosím pokračujte.",
    title: "Ověřte párovací kód",
    unpaired: "Byl zjištěn nespárovaný BitBox02. Prosím ověřte, že párovací kód odpovídá tomu, co je zobrazeno na vašem BitBoxu."
  },
  restoreFromMnemonic: {
    e104: "Obnovení ze slov pro obnovení bylo zrušeno.",
    failed: "Obnovení ze slov pro obnovení se nezdařilo, zkuste to prosím znovu."
  },
  stepBackup: {
    beforeProceed: "Než budete pokračovat, přečtěte si tato důležitá bezpečnostní opatření:",
    createBackup: "Nyní vytvoříte zálohu na microSD kartě.",
    createBackupMnemonic: "Nyní si zapíšete slova pro obnovení."
  },
  stepBackupSuccess: {
    fundsSafe: "Aby byly vaše prostředky v bezpečí, mějte na paměti následující:",
    title: "Záloha obnovena!"
  },
  stepConnected: {
    unlock: "Pro odemknutí zadejte heslo."
  },
  stepCreate: {
    description: "Tento název se používá jako název zařízení a pro zálohu. ",
    error: {
      genericMessage: "Používejte písmena, čísla, základní symboly, mezery. Maximálně 30 znaků.",
      invalidChars: "Název obsahuje neplatné znaky: {{invalidChars}}.",
      tooLong: "Název je příliš dlouhý."
    },
    nameLabel: "Název BitBox02",
    namePlaceholder: "Můj BitBox02",
    title: "Vyberte název pro BitBox02",
    toastMicroSD: "Vložte prosím svou microSD kartu do vašeho BitBox02, která bude použita k uložení zálohy peněženky."
  },
  stepCreateSuccess: {
    removeMicroSD: "Vyjměte microSD kartu z vašeho BitBox02 a uložte ji na bezpečné místo.",
    storeMnemonic: "Uložte svá slova pro obnovení na bezpečném místě",
    success: "Vaše záloha byla úspěšně vytvořena."
  },
  stepInsertSD: {
    insertSDCard: "Chcete-li pokračovat, vložte do svého BitBox02 microSD kartu.",
    insertSDcardTitle: "Vložte microSD kartu"
  },
  stepPassword: {
    e104: "Nastavení hesla bylo zrušeno.",
    title: "Nastavte heslo pro váš Bitbox02",
    useControls: "K nastavení hesla použijte ovládací prvky na vašem BitBox02."
  },
  stepUninitialized: {
    create: "Chci nastavit nový BitBox02.",
    restore: "Chci obnovit svou peněženku ze zálohy.",
    restoreMicroSD: "Obnovit z microSD karty",
    restoreMnemonic: "Obnovit ze slov pro obnovení",
    title: "Nastavte svůj BitBox02"
  },
  success: {
    text: "Hurá! Váš BitBox02 je nyní připraven k použití.\n\nChcete-li získat další informace o tom, jak používat BitBoxApp, použijte průvodce v aplikaci kliknutím na otazník v pravém horním rohu.",
    title: "Jste připraveni!"
  }
};
const bitsurance$a = {
  dashboard: {
    active: "Pojistka aktivní",
    button: "Pojistit nový účet",
    canceled: "Zrušeno",
    coverage: "Maximální pokrytí",
    inactive: "Neaktivní",
    processing: "Zpracovává se",
    refused: "Odmítnuto",
    supportLink: "Spravovat smlouvu",
    title: "Pojištěné účty",
    waitpayment: "Čekání na platbu"
  },
  detect: {
    button: "Zkontrolujte stávající pojištění",
    insured: "Zjištěn pojištěný účet:",
    notInsured: "Nebyly zjištěny žádné pojištěné účty. Pokud jste si jisti, že máte pojištěný účet, zkontrolujte, zda máte připojenou správnou peněženku.",
    text: "Pokud jste se již zaregistrovali u Bitsurance, aplikace BitBoxApp může automaticky synchronizovat vaše stávající pojištění.",
    title: "Už jste pojištěni?"
  },
  insure: {
    button: "Zkontrolujte dostupnost a cenu",
    faq: "Přečtěte si více na Bitsurance FAQ",
    listItem1: "Vloupání",
    listItem2: "Vydírání (např.$5 wrench attack)",
    listItem3: "Zničení v důsledku požáru, vody nebo přírodních katastrof",
    month: "měsíc",
    text: "Pojistěte si svůj BitBox02 a bitcoiny v hodnotě až 100 000 EUR",
    text2: "Pojistné plány začínají na 30 €/rok (2,50 €/měsíc). Více informací o společnosti Bitsurance a její přesné nabídce pojištění se dozvíte na stránce",
    text3: "V současné době k dispozici v Německu, další regiony budou následovat.",
    title: "Začněte"
  },
  intro: {
    link: "Web Bitsurance",
    text1: "BitBox spolupracuje s Bitsurance na přidání další vrstvy ochrany pro vaše bitcoiny. Zatímco BitBox02 udržuje vaše finanční prostředky v bezpečí, Bitsurance pokrývá domácí hrozby, které nelze zmírnit samotnou technologií, jako je vloupání, vydírání nebo zničení samotné hardwarové peněženky."
  },
  terms: {
    link: "Zásady ochrany osobních údajů Bitsurance",
    text1: "Bitsurance je nezávislá služba třetí strany. S dotazy týkajícími se jejich nabídky a pojistných nároků kontaktujte přímo Bitsurance.",
    text2: "Pojištění je aktuálně dostupné v Německu a další regiony budou následovat.",
    text3: "Maximální aktuálně dostupné pokrytí bitcoinů je 100 000 EUR na osobu. Do budoucna se plánují vyšší částky.",
    text4: "Osobní údaje a rozšířený veřejný klíč (xpub) vašeho pojištěného účtu jsou součástí pojistné smlouvy a budou sdíleny s Bitsurance a poskytovatelem pojištění.",
    text5: "Další informace o ochraně osobních údajů a zachování soukromí naleznete na"
  },
  title: "Pojištění"
};
const bitsuranceAccount$a = {
  errorNoXpub: "Chyba: Nepodařilo se získat xpub z účtu.",
  noAccount: "Neexistují žádné účty, které lze pojistit.",
  select: "Vybrat účet",
  title: "Pojištění"
};
const blink$h = {
  button: "Blik"
};
const bootloader$h = {
  button: "Nyní aktualizujte firmware",
  button_install: "Nyní nainstalujte firmware",
  progress: "Aktualizace: {{progress}}%",
  progress_install: "Instalace: {{progress}}%",
  success: "Aktualizace proběhla úspěšně! Zařízení znovu zapojte. Tentokrát se tlačítka nedotýkejte."
};
const button$m = {
  abort: "Zrušit",
  back: "Zpět",
  buy: "Koupit",
  changepin: "Změňit heslo zařízení",
  check: "Zkontrolovat zálohu",
  "continue": "Pokračovat",
  copy: "Kopírovat",
  create: "Vytvořit",
  dismiss: "Odmítnout",
  done: "Hotovo",
  download: "Stáhnout",
  hiddenwallet: "Vytvořit skrytou peněženku",
  next: "Další",
  ok: "OK",
  previous: "Předchozí",
  receive: "Přijmout",
  restore: "Obnovit",
  select: "Vybrat",
  send: "Poslat",
  unlock: "Odemknout",
  update: "Aktualizovat",
  upgrade: "Aktualizovat"
};
const buy$d = {
  exchange: {
    bankTransfer: "Bankovní převod",
    bestDeal: "Nejvýhodnější nabídka",
    creditCard: "Kreditní karta",
    fast: "Rychle",
    fee: "poplatek",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankovní převod: {{fee}}%",
          creditDebitCard: "Kreditní / Debetní karta: {{fee}}%",
          learnMore: "Zjistěte více o Moonpay",
          title: "Poplatky"
        },
        fullCurrenciesList: "Kompletní seznam měn naleznete zde",
        payment: {
          asteriskText: "* Není k dispozici pro rezidenty USA",
          bankTransfer: "Bankovní převod*",
          bankTransferDetails: {
            pix: "PIX (transakce BR pouze v Brazílii)",
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemích SEPA)",
            uk: "Faster Payments - Spojené království (transakce v GBP pouze ve Spojeném království)"
          },
          creditDebitCard: "Kreditní / Debetní karta",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa a Maestro"
          },
          learnMore: "Další podrobnosti o způsobech platby",
          title: "Platební metody"
        },
        supportedCurrencies: "Podpora všech hlavních fiat měn: USD, EUR, CHF a další."
      },
      pocket: {
        fees: {
          info: "Bankovní převod: {{fee}}%",
          title: "Poplatky"
        },
        learnMore: "Zjistěte více o službě Pocket",
        payment: {
          bankTransfer: "Bankovní převod",
          bankTransferDetails: {
            sepa: "SEPA a SEPA Instant (transakce v EUR pouze v zemích SEPA)",
            sic: "Swiss Interbank Clearing (transakce v CHF pouze v CH/LI)",
            uk: "Faster Payments - Spojené království (transakce v GBP pouze ve Spojeném království)"
          },
          bankTransferReccuring: "Jak nastavit opakované nákupy pomocí trvalého příkazu?",
          title: "Platební metody"
        },
        supportedCurrencies: "Podpora evropských měn: EUR, GBP a CHF.",
        verification: {
          info: "Vyžaduje ověření identity pouze pokud jsou překročeny denní a roční limity.",
          link: "Aktuální limity zde",
          title: "Ověření identity"
        }
      },
      region: {
        title: "Vyberte oblast, ve které je váš bankovní účet registrován, a zjistěte, které možnosti máte k dispozici."
      }
    },
    noExchanges: "Je nám líto, ale v této oblasti nejsou k dispozici žádné burzy.",
    region: "Oblast",
    selectRegion: "Není uvedeno",
    title: "Koupit {{name}}"
  },
  info: {
    "continue": "Souhlasím, pokračovat",
    crypto: "krypto",
    disclaimer: {
      intro: [
        "Spolupracujeme s MoonPay, abychom vám nabídli bezproblémový způsob nákupu {{name}} přímo v BitBoxApp. Je to jen pár kliknutí.",
        "MoonPay je platforma, která usnadňuje a urychluje nákup {{name}} ve více než 160 zemích."
      ],
      payment: {
        details: "{{name}} si můžete okamžitě zakoupit přes MoonPay pomocí následujících platebních metod. Nákupy kreditní nebo debetní kartou jsou okamžité a pohodlné, ale dražší kvůli zvýšenému riziku chargebacku. Pro větší částky doporučujeme použít možnost bankovního převodu. Minimální poplatek je 4 USD/EUR nebo ekvivalentní částka.",
        footnote: "Vezměte prosím na vědomí, že směnné kurzy MoonPay se mohou lišit od kurzů používaných v BitBoxApp, což vede k mírně odlišným částkám.",
        table: {
          "1_description": "Nejnižší poplatky, může trvat až tři pracovní dny",
          "1_method": "Bankovní převody (SEPA)",
          "2_description": "Vyšší poplatky, ale rychlé a okamžité",
          "2_method": "Kreditní a debetní karty",
          description: "Popis",
          fee: "Poplatek",
          method: "Metoda"
        },
        title: "Platební metody a poplatky"
      },
      privacyPolicy: "Zásady ochrany osobních údajů MoonPay",
      protection: {
        description: "BitBoxApp při nákupu {{name}} neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. MoonPay potřebuje ke své činnosti shromažďovat některé osobní údaje. Jejich Zásady ochrany osobních údajů podrobně vysvětlují, jak je s těmito údaji nakládáno.",
        descriptionGeneric: "BitBoxApp při nákupu {{name}} neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. Partnerské burzy však ke svému fungování potřebují shromažďovat určité informace. Podrobnější informace o tom, jak je s daty nakládáno, naleznete v jejich zásadách ochrany osobních údajů.",
        title: "Ochrana dat"
      },
      security: {
        description: "Při nákupu {{name}} přes MoonPay využíváte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštena BitBoxApp.",
        descriptionGeneric: "Při nákupu {{name}} prostřednictvím partnerské burzy využíváte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštena BitBoxApp.",
        link: "Model bezpečnostních hrozeb",
        title: "Bezpečnostní model"
      },
      title: "Vítejte ve vašem obchodě pro nákup {{name}}"
    },
    next: "Další",
    selectLabel: "Vyberte svůj účet",
    selectPlaceholder: "Vyberte měnu",
    skip: "Znovu nezobrazovat",
    title: "Koupit {{name}}"
  },
  pocket: {
    data: {
      link: "Zásady ochrany osobních údajů Pocket",
      p1: "BitBoxApp při nákupu bitcoinů neshromažďuje žádné údaje, s příchozími prostředky se zachází jako s běžnou transakcí. Pocket potřebuje ke svému fungování shromažďovat některé osobní údaje. Jejich zásady ochrany osobních údajů podrobně vysvětlují, jak se s těmito údaji nakládá.",
      title: "Ochrana dat"
    },
    kyc: {
      link: "Přečtěte si Pocket FAQ",
      p1: "Pocket se snaží omezit KYC na minimum. U nákupů do 950 EUR (1000 CHF) denně nejsou vyžadovány žádné další dokumenty. Při nákupech nad tuto částku si budete muset s Pocket domluvit hovor, abyste mohli dokončit potřebný proces KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin si můžete koupit okamžitě pomocí služby Pocket bankovním převodem SEPA. Poplatek činí 1,5 % a bitcoiny jsou poslány do vašeho BitBoxu ihned poté, co Pocket obdrží bankovní převod (obvykle během téhož dne).",
      p2: "Upozorňujeme, že směnné kurzy v aplikaci Pocket se mohou lišit od kurzů používaných v aplikaci BitBoxApp, což vede k mírně odlišným částkám.",
      title: "Platební metody a poplatky"
    },
    previousTransactions: "Historie transakcí tohoto účtu není prázdná. Sdílením tohoto účtu se všechny jeho minulé a budoucí transakce stanou viditelnými pro Pocket. Pokračovat?",
    security: {
      link: "Model bezpečnostních hrozeb BitBox02",
      p1: "Při nákupu bitcoinů přes Pocket používáte externí službu. Tato služba je mimo oblast působnosti modelu bezpečnostních hrozeb BitBox02 a spoléhá se na bezpečnost a zabezpečení prostředí, ve kterém je spuštěn BitBoxApp. Společně pracujeme na zvýšení bezpečnosti pomocí dvoufaktorového ověřovacího mechanismu, který ověřuje adresu, na kterou přijímáte.",
      title: "Bezpečnostní model"
    },
    usedAddress: "Adresa {{address}} již byla použita, začněte prosím znovu s novou adresou.",
    verifyBitBox02: "Zkontrolujte, zda adresa, kterou jste obdrželi e-mailem, odpovídá adrese zobrazené na vašem Bitboxu. Pokud je to možné, měli byste e-mail otevřít na druhém zařízení kvůli lepšímu zabezpečení.",
    welcome: {
      p1: "Spolupracujeme se společností Pocket, abychom vám nabídli bezproblémový způsob nákupu bitcoinů přímo v BitBoxApp. Je to jen pár kliknutí.",
      p2: "Pocket je švýcarská platforma, která umožňuje rychlý a snadný nákup bitcoinů ve většině Evropy (kdekoli, kde jsou podporovány bankovní převody SEPA).",
      p3: "S Pocket můžete také provádět pravidelné nákupy prostřednictvím trvalých bankovních příkazů, takže můžete snadno zprůměrovat své náklady (DCA - dollar-cost averaging).",
      title: "Vítejte ve svém obchodě pro nákup bitcoinů"
    }
  },
  title: "Koupit {{name}}"
};
const changePin$h = {
  newTitle: "Nové heslo zařízení",
  oldLabel: "Aktuální heslo zařízení"
};
const chart$d = {
  dataMissing: "Sbíráme historická data... zůstaňte s námi.",
  dataOldTimestamp: "Aktualizace historických směnných kurzů. V grafu se nezobrazují data po {{time}}.",
  dataUpdating: "aktualizace dat...",
  filter: {
    all: "Všechny",
    month: "Měsíc",
    week: "Týden",
    year: "Rok"
  }
};
const checkSDcard$h = "kontrola microSD karty";
const clickHere$h = "Klikněte zde.";
const confirm$j = {
  abortInfo: "Klepněte na ",
  abortInfoRedText: "zrušit",
  approveInfo: "Podržte 4 a více sekund ",
  approveInfoGreenText: "potvrdit",
  info: "Pokračujte na svém BitBoxu. ",
  infoWhenPaired: "Nejprve na spárovaném mobilu a poté na vašem BitBoxu"
};
const confirmOnDevice$h = "Potvrďte na svém zařízení.";
const connectKeystore$b = {
  promptNoName: "Chcete-li pokračovat, připojte svůj BitBox02",
  promptWithName: 'Chcete-li pokračovat, připojte prosím svůj BitBox02 s názvem "{{name}}" '
};
const darkmode$b = {
  toggle: "Tmavý režim"
};
const device$h = {
  appUpradeRequired: "Váš BitBox není kompatibilní s touto aplikací. Stáhněte si a nainstalujte nejnovější verzi.",
  keystoreConnected: "Připojená peněženka"
};
const deviceLock$h = {
  button: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  condition1: "Máte zálohu?",
  condition2: "Funguje ověření mobilní aplikace?",
  condition3: "2FA ZABRÁNÍ zálohování a párování s mobilní aplikaci. Pro ukončení 2FA je nutné zařízení RESETOVAT!",
  confirm: "Aktivovat dvoufaktorovou autorizaci (2FA)",
  title: "Aktivovat dvoufaktorovou autorizaci (2FA)"
};
const deviceSettings$h = {
  backups: {
    manageBackups: {
      description: "Vytvořte nebo ověřte zálohu na microSD kartě."
    },
    showRecoveryWords: {
      description: "Zobrazit a ověřit slova pro obnovení."
    },
    title: "Zálohy"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp kontroluje, zda je vaše zařízení pravé."
    },
    deviceName: {
      description: "Změňte název zařízení."
    },
    rootFingerprint: {
      description: "Otisk je jedinečný identifikátor právě používané peněženky. Může vám pomoci rozlišit různé peněženky, pokud používáte přístupové fráze."
    },
    securechip: {
      description: "Model bezpečného čipu."
    },
    title: "Informace o zařízení"
  },
  expert: {
    factoryReset: {
      description: "Obnovte zařízení do továrního nastavení. Tím se smaže peněženka z vašeho BitBox02! ",
      title: "Obnovit do továrního nastavení"
    },
    goToStartupSettings: {
      description: "Vstoupit do bootloaderu BitBox02. Zde můžete povolit hash firmwaru."
    },
    passphrase: {
      description: "Aktivovat nebo deaktivovat funkci přístupové fráze.",
      title: "Přístupová fráze"
    }
  },
  firmware: {
    firmwareVersion: "Verze firmwaru",
    newVersion: {
      label: "Dostupná verze"
    },
    title: "Firmware",
    upToDate: "Vaše zařízení je aktuální",
    upgradeAvailable: "K dispozici je nová aktualizace",
    version: {
      label: "Verze"
    }
  },
  hardware: {
    attestation: {
      "false": "Kontrola pravosti se nezdařila",
      label: "Kontrola pravosti",
      "true": "Váš BitBox02 je autentický"
    },
    sdcard: {
      "false": "Není vložena",
      label: "microSD karta",
      "true": "Vložena"
    },
    securechip: "Bezpečný čip",
    title: "Hardware"
  },
  loading: "Načítání informací o zařízení…",
  pairing: {
    lock: {
      "false": "Vypnuto",
      label: "Dvoufaktorová autorizace (2FA)",
      "true": "Zapnuto"
    },
    mobile: {
      "false": "Zavřeno",
      label: "Mobilní aplikace",
      "true": "Otevřeno"
    },
    status: {
      "false": "Nespárováno",
      label: "Stav",
      "true": "Spárováno"
    },
    title: "Párování"
  },
  secrets: {
    manageBackups: "Spravovat zálohy",
    title: "Secrets"
  }
};
const deviceTampered$h = "Bylo k vašemu BitBoxu dodáno heslo pro obnovení? Pokud ano, zastavte proces nastavení a okamžitě kontaktujte podporu. Společnost Shift vám nikdy neposkytne hotovou peněženku ani vám nedá doporučení ohledně hesla.";
const dialog$i = {
  cancel: "Zrušit",
  confirm: "Potvrdit",
  confirmTitle: "Potvrzení"
};
const error$d = {
  accountAlreadyExists: "Účet již existuje.",
  accountLimitReached: "Nelze přidat účet. Maximální počet účtů pro tuto měnu byl dosažen.",
  aoppCallback: "Při doručování adresy na {{host}} došlo k chybě.",
  aoppInvalidRequest: "Neplatný požadavek.",
  aoppNoAccounts: "Nejsou k dispozici žádné účty.",
  aoppSigningAborted: "Žádost o potvrzení vlastnictví adresy zrušena.",
  aoppUnknown: "Nastala neznámá chyba.",
  aoppUnsupportedAsset: "Toto aktivum není podporováno.",
  aoppUnsupportedFormat: "Nejsou k dispozici žádné účty, které by podporovaly požadovaný formát adresy.",
  aoppUnsupportedKeystore: "Připojené zařízení nemůže podepisovat zprávy pro toto aktivum.",
  aoppVersion: "Neznámá verze.",
  keystoreTimeout: "Platnost požadavku vypršela. Prosím zkuste to znovu.",
  wrongKeystore: "Byla připojena špatná peněženka. Ujistěte se, že jste vložili správné zařízení odpovídající tomuto účtu.",
  wrongKeystore2: " Pokud používáte přístupovou frázi, zkontrolujte, zda jste zadali správnou přístupovou frázi pro tento účet."
};
const fiat$j = {
  "default": "výchozí",
  setDefault: "Nastavit {{code}} jako výchozí",
  title: "Měny"
};
const footer$j = {
  appVersion: "Verze aplikace:"
};
const generic$d = {
  enabled_false: "Vypnuto",
  enabled_true: "Zapnuto"
};
const genericError$h = "Došlo k chybě. Pokud zaznamenáte nějaké problémy, restartujte prosím aplikaci.";
const goal$h = {
  buttons: {
    create: "Vytvořit novou peněženku",
    restore: "Obnovte peněženku ze zálohy"
  },
  paragraph: "Vyberte prosím jednu z následujících možností:",
  step: {
    "1": {
      title: "Informace o zabezpečení"
    },
    "2": {
      description: "Nastavit heslo zařízení",
      title: "Zařízení"
    },
    "3-create": {
      description: "Vytvořit novou peněženku",
      title: "Peněženka"
    },
    "3-restore": {
      description: "ze zálohy",
      title: "Obnovit"
    },
    "4-create": {
      title: "Přehled"
    },
    "4-restore": {
      title: "Přehled"
    }
  }
};
const guide$i = {
  accountDescription: {
    text: 'V přehledu účtu se zobrazuje disponibilní zůstatek a příchozí a odchozí transakce. Více informací o jednotlivých typech účtů najdete v našem průvodci v části "Nastavení". ',
    title: "Co se mi na této stránce zobrazuje?"
  },
  accountFiat: {
    text: "Ano. Kliknutím na libovolný ticker můžete volit mezi fiat měnami. Seznam měn můžete změnit v nastavení.",
    title: "Mohu zobrazit jiné směnné kurzy?"
  },
  accountIncomingBalance: {
    text: "Přicházející transakce zahrnují částky, které vám byly převedeny, ale ještě nebyly potvrzeny sítí.",
    title: "Co znamená přicházející transakce?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Každý xpub je svázán se zobrazeným typem: buď "Native Segwit (bech32)", "Wrapped Segwit" nebo "Taproot" (pouze u Bitcoinu). Jedná se o typy skriptů, které používá {{coinName}}. BitBoxApp je kombinuje a podporuje více typů skriptů v rámci jednoho účtu. Protože každý typ skriptu dává jiný xpub, existuje více xpubů pro jeden účet.\n\nPokud soustavně přijímáte na výchozí adrese (Native Segwit), potřebujete pouze "bech32" xpub. Pokud však přijímáte prostředky také na "Wrapped Segwit" nebo "Taproot", musíte používat také další veřejné klíče "Wrapped Segwit", xpub respektive "Taproot" xpub.',
      title: "Proč existuje více xpubů?"
    },
    privacy: {
      text: "U tohoto konkrétního účtu odhaluje xpub veřejný klíč celou finanční historii, zůstatek na účtu a všechny budoucí transakce. Xpub však nikomu neumožňuje utrácet vaše prostředky.\n\nPokud xpub někomu předáte, měli byste si být vědomi toho, že tato osoba nebo společnost může vidět všechny ostatní transakce tohoto účtu. Proto je dobré používat tento účet pouze k tomuto účelu a ostatní prostředky držet na jiných účtech.",
      title: "Musím svůj xpub držet v tajnosti?"
    },
    verify: {
      text: "Ano, vždy je dobré si xpub překontrolovat. Pokud z tohoto xpubu bude někdo jiný generovat adresy a posílat vám peníze, je to obzvlášť důležité. Musíte ho ověřit na zařízení, abyste se ujistili, že tento xpub patří vám; jinak by všechny prostředky mohly jít na nesprávné adresy.",
      title: "Musím ověřit xpub na zařízení?"
    },
    xpub: {
      text: "Veřejný klíč (xpub) je základní klíč, z něhož jsou odvozeny všechny adresy účtu.\n\nJe zde uveden pro pokročilé používání a interoperabilitu s peněženkami určenými pouze pro sledování (watch-only wallets), jako je Electrum nebo Sentinel. Pokud jste přijímali na různé typy adres, importujte prosím všechny různé formáty xpubů do watch-only peněženky, abyste viděli všechny své prostředky.\n\nUpozorňujeme, že peněženky třetích stran nemusí zatím podporovat Taproot xpub.",
      title: "Co je veřejný klíč (xpub)?"
    }
  },
  accountRates: {
    text: "Směnné kurzy aktualizujeme každou minutu z CoinGecko.",
    title: "Jaké směnné kurzy platí?"
  },
  accountReload: {
    text: "To není potřeba. Informace o transakci se aktualizují automaticky.",
    title: "Mohu znovu načíst historii transakcí?"
  },
  accountSendDisabled: {
    text: "Tlačítko „Odeslat“ se aktivuje, když je váš zůstatek vyšší než nula.",
    title: "Proč nemůžu poslat žádný {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Celková částka je součtem všech vašich účtů. Směnné kurzy jsou získávány z coingecko.com.\n\nPoznámka: Pokud používáte MyEtherWallet pro tokeny, které nejsou podporovány v aplikaci BitBoxApp, nebudou do zobrazené částky zahrnuty.",
    title: "Jak se vypočítá celková částka?"
  },
  accountSummaryDescription: {
    text: "Zde můžete sledovat výkonnost svého portfolia v průběhu času. Pod grafem se zobrazuje přehled vašich jednotlivých účtů.",
    title: "Co se mi na této stránce zobrazuje?"
  },
  accountTransactionAttributesBTC: {
    text: "Virtuální velikost: Určuje síťový poplatek. Úspěšně jste ušetřili na poplatcích, pokud je menší než velikost transakce.\nVelikost: Skutečná velikost transakce v bajtech při serializaci podle příslušného blockchainu.\nVáha: Nová metrika zavedená se Segwitem pro vyhodnocování velikosti transakcí a bloků. Každý byte segregovaného svědka {segregated witness) se počítá jako jedna, vše ostatní jako čtyři jednotky váhy. Místo jednoho megabajtu ve skutečné velikosti je nyní limit velikosti bloku čtyři miliony váhových jednotek.",
    title: "A co podrobnosti transakce specifické pro bitcoiny?"
  },
  accountTransactionAttributesGeneric: {
    text: "Potvrzení: Vaše první transakce je nepotvrzená, dokud ji těžař nezařadí do bloku, poté má jedno potvrzení. Každý další blok v síti přidává k vaší transakci další potvrzení. Obecně platí, že obchodníci a další účastníci sítě akceptují transakce jako vypořádané s minimem tří až šesti potvrzení.\nID transakce: Jedinečné identifikační číslo, které umožňuje vyhledat transakci v blok exploreru.\nPoplatek: Těžařům se platí transakční poplatek jako pobídka k zahrnutí transakcí do bloků, které vytěží. Chcete-li se dozvědět více, klikněte na tlačítko odeslat.",
    title: "Jaké jsou informace v detailech transakce?"
  },
  accountTransactionConfirmation: {
    text: "Transakce odeslaná do sítě, ale dosud nepotvrzená.",
    title: "Co je to čekající transakce?"
  },
  accountTransactionLabel: {
    text: "Je to adresa, ze které jste obdrželi prostředky nebo na kterou jste je odeslali.",
    title: "Jaká adresa se zobrazuje u každé transakce?"
  },
  accountTransactionTime: {
    text: "Doba potvrzení transakce v blockchainu.",
    title: "Jaký čas se zobrazuje?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin a Litecoin mohou mít libovolné množství účtů. Po pěti účtech můžete přidat další účet pouze v případě, že předchozí účet byl použit. \nOstatní měny mohou mít maximálně pět účtů.",
      title: "Kolik účtů mohu vytvořit?"
    },
    howtoAddTokens: {
      text: 'Tokeny využívající standard ERC20 jsou vázány na konkrétní účet Etherea. Chcete-li aktivovat nebo deaktivovat konkrétní token, otevřete obrazovku "Správa účtů", rozbalte svůj účet Ethereum a zapněte nebo vypněte požadovaný token.',
      title: "Jak mohu přidat další tokeny?"
    },
    moveFunds: {
      text: "Ano, ale protože jsou účty nezávislé, musíte své prostředky poslat pomocí běžné transakce.",
      title: "Mohu přesouvat prostředky mezi účty?"
    },
    recoverAccounts: {
      text: "Ano, BitBoxApp vytváří účty pomocí zavedených standardů kompatibilních s většinou ostatních kryptopeněženek.",
      title: "Mohu obnovit své účty v jiných peněženkách?"
    },
    whatAreAccounts: {
      text: "Vaše peněženka umí spravovat více účtů jedné měny. Účty jsou užitečné, když chcete mít prostředky oddělené.",
      title: "Co jsou účty?"
    },
    whatIsRememberWallet: {
      text: `Povolením možnosti "Zapamatovat si peněženku" můžete v aplikaci BitBoxApp vidět účty této peněženky, i když není BitBox02 připojen. Díky tomu můžete kdykoli zkontrolovat svůj zůstatek a portfolio. BitBox02 musí být stále připojen a odemčen, aby bylo možné odesílat nebo přijímat prostředky.

Pokud je možnost "Zapamatovat si peněženku' vypnutá, musíte znovu zapojit svůj BitBox02 (nebo peněženku s přístupovou fráz) aby jste účty znovu viděli v aplikaci BitBoxApp.`,
      title: "Co se stane, když povolím nebo vypnu „Zapamatovat peněženku“?"
    },
    whyIsThisUseful: {
      text: "Účty jsou skvělé pro správu prostředků pro různé osoby nebo účely, protože jsou oddělené. Můžete také sdílet veřejný klíč (xpub) účtu, aniž byste prozradili cokoli o svých ostatních účtech. To vám umožňuje opakovaně přijímat finanční prostředky bez opakovaného používání adres, například při pobírání mzdy nebo pravidelném nákupu kryptoměn.",
      title: "Proč je to užitečné?"
    }
  },
  appendix: {
    link: "Kontaktujte nás!",
    text: "Další otázka?"
  },
  backups: {
    check: {
      text: '"Zkontrolovat zálohu" umožňuje ověřit, zda máte funkční zálohu odpovídající vaší aktuální peněžence. Lze ji také použít k ověření, zda máte stále správné heslo pro obnovení. Můžete zkontrolovat hlavní heslo pro obnovení nebo skryté heslo pro obnovení.',
      title: "Co je to „Zkontrolovat zálohu“?"
    },
    encrypt: {
      text: "Ne, ale k získání peněženky z uloženého seedu {slov pro obnovení) je nutné vaše heslo pro obnovení.",
      title: "Mohu zálohu zaheslovat?"
    },
    howOften: {
      text: "Záloha se generuje automaticky při vytvoření nové peněženky. Novou zálohu musíte vytvořit pouze v případě, že microSD kartu ztratíte nebo poškodíte, nebo pokud chcete jako zálohu použít více microSD karet.\nPo uskutečnění transakcí nemusíte vytvářet nové zálohy. Všechna data transakcí lze znovu vytvořit pomocí jediné zálohy, která byla pro vás automaticky vytvořena.",
      title: "Jak často musím vytvářet zálohu?"
    },
    whatIsABackup: {
      text: "Jedná se o kopii obnovovacího seedu na microSD kartě. Seed {slova pro obnovení) spolu s heslem pro obnovení vytváří vaši peněženku.",
      title: "Co je záloha?"
    }
  },
  backupsBB02: {
    check: {
      text: "„Zkontrolovat zálohu“ vám umožňuje ověřit, že máte funkční zálohu odpovídající vaší aktuální peněžence.",
      title: "Co je to „Zkontrolovat zálohu“?"
    },
    encrypt: {
      text: 'Ne. microSD kartu uchovávejte v bezpečí, protože obsahuje nezašifrovaný obnovovací seed k obnovení peněženky. Pokud si přejete chránit seed heslem, můžete aktivovat volitelnou přístupovou frázi v expertním nastavení v části "Správa zařízení".',
      title: "Mohu zálohu zašifrovat?"
    },
    whatIsABackup: {
      text: "Jedná se o kopii obnovovacího seedu na microSD kartě.",
      title: "Co je záloha?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Když je aktivní funkce 2FA, musí být všechny transakce schváleny na spárovaném mobilním telefonu, aby bylo možné utrácet prostředky. Do mobilní aplikace je odesláno zašifrované jednorázové číslo, které je tam dešifrováno a po stisknutí tlačítka Přijmout je odesláno zpět do BitBoxu. Tato komunikace se zařízením probíhá prostřednictvím kanálu mezi mobilním telefonem a touto desktopovou aplikací vytvořeného během párování.\n\nPřed zapnutím funkce 2FA nezapomeňte zálohovat peněženku a spárovat mobilní aplikaci. Po aktivování jsou microSD slot a párování s mobilní aplikací vypnuty. Lze je znovu aktivovat resetováním BitBoxu, čímž se zařízení vymaže.",
      title: "Jak funguje dvoufaktorová autorizace (2FA)?"
    },
    disable2FA: {
      text: `Chcete-li 2FA deaktivovat, musíte resetovat BitBox a poté obnovit peněženku ze zálohy. Ujistěte se, že stále máte microSD kartu se zálohou a že si stále pamatujete heslo pro obnovení. Poté stiskněte tlačítko "Resetovat zařízení". Nastavte nové heslo zařízení a zvolte 'Nebo obnovit ze zálohy'. Vyberte zálohu peněženky, klikněte na 'Obnovit' a zadejte heslo pro obnovení, které jste použili při vytváření peněženky.`,
      title: "Jak mohu deaktivovat dvoufaktorovou autorizaci (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox můžete kdykoli odpojit, aniž byste jej museli nejprve vysunout.",
      title: "Jak mohu vysunout BitBox?"
    },
    ejectSD: {
      text: "MicroSD kartu můžete z BitBoxu kdykoli vyjmout, pokud právě nevytváříte nebo neobnovujete zálohu.",
      title: "Jak mohu microSD kartu vysunout?"
    },
    hiddenWallet: {
      text: "Jedná se o druhou peněženku na stejném zařízení chráněnou jiným heslem zařízení a heslem pro obnovení, které můžete použít pro hodnověrné popření (plausible deniability). Pro normální i skrytou peněženku se používá stejný seed, takže není třeba žádné další zálohování.",
      title: "Co je to skrytá peněženka?"
    },
    legacyHiddenWallet: {
      text: "Nejprve klikněte na níže uvedené tlačítko (je k dispozici, pokud je BitBox odemčen hlavním heslem zařízení a funkce 2FA je vypnutá), poté Bitbox znovu připojte a odemkněte jej skrytým heslem.",
      title: "Jak se dostanu k legacy skryté peněžence?"
    },
    pairing: {
      text: "Po stažení naší mobilní aplikace pro iOS nebo Android naskenujete zobrazený QR kód, čímž se vytvoří zabezpečený kanál mezi mobilní aplikací a touto aplikací. Po naskenování postupujte podle pokynů v mobilní aplikaci.",
      title: "Jak bezpečně spárovat s telefonem"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Další podrobnosti naleznete na webových stránkách Bitsurance a jejich FAQ.",
      title: "Další otázky?"
    },
    privacy: {
      link: {
        text: "Zásady ochrany osobních údajů Bitsurance"
      },
      text: "Jako každá běžná pojistka obsahuje vaše celé jméno a adresu a specifikuje pojištěný objekt (definovaný rozšířeným veřejným klíčem (xpub) pojištěného bitcoinového účtu). Tato data jsou odesílána přímo společnosti Bitsurance a nejsou sdílena se společností Shift Crypto. Další informace naleznete v zásadách ochrany osobních údajů Bitsurance",
      title: "Jaké osobní údaje jsou pro pojištění potřeba?"
    },
    renew: {
      text: "Pojištění se automaticky obnoví na další rok. Obnovení můžete kdykoli zrušit kliknutím na „Spravovat smlouvu“ v aplikaci BitBoxApp, která vás přenese na zákaznický portál Bitsurance.",
      title: "Jak mohu obnovit nebo zrušit pojištění?"
    },
    status: {
      text: 'Úspěšně pojištěné účty jsou označeny zeleným odznakem "pojištěno" v levém horním rohu na každé stránce účtu Bitcoin. V sekci "Pojištění" si můžete prohlédnout přehled všech pojištěných účtů Bitcoin a jejich aktuální stav pojištění. Aktualizace stavu pojištění může trvat až 48 hodin.',
      title: "Mohu zkontrolovat stav pojištěného účtu?"
    },
    what: {
      text: "Každá bitcoinová pojistná smlouva se vztahuje na konkrétní účet peněženky. Sjednáním více pojistek můžete pojistit více účtů. Pojištěné účty jsou omezeny na používání bitcoinových adres „Native Segwit“.",
      title: "Je pojištěna celá peněženka BitBox?"
    },
    who: {
      text: "Pojištění nabízí Bitsurance, pojišťovací makléř postavený bitcoinery. Spolupracují s pojištěním ELEMENT, aby poskytovali pojištění bitcoinů. Obě společnosti sídlí v Německu.",
      title: "Kdo pojišťuje moje bitcoiny?"
    },
    why: {
      text: "Bitsurance pokrývá některá rizika vlastní úschovy (self-custody), která nespadají ani do té nejbezpečnější peněženky, např. vloupání, vydírání nebo zničení peněženky. Je to vaše osobní rozhodnutí, zda potřebujete pojištění pro tato rizika.",
      title: "Potřebuji pojištění bitcoinů?"
    }
  },
  cointracking: {
    text: 'Klikněte na tlačítko "Export" a otevřete složku se staženými soubory, kde najdete export CSV. Poté klikněte na níže uvedený odkaz, nahrajte svůj BitBox CSV soubor a importujte data, abyste je mohli použít pro správce portfolia CoinTracking a pro vytváření daňových výkazů.',
    title: "Jak importovat mé transakce do služby CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Přečtěte si více o kontrole pravosti"
      },
      text: "BitBoxApp provede atestační kontrolu BitBox02, aby ověřila, zda je zařízení pravé. Kontrola se provádí lokálně a nepřipojuje se k žádným serverům.",
      title: "Jak probíhá kontrola pravosti?"
    },
    name: {
      text: "Jedná se o název vaší peněženky a zálohy. Název se používá pro budoucí zálohy a může sloužit k rozlišení různých peněženek. Lze jej kdykoli změnit, ale mějte na paměti, že zálohy vytvořené před změnou budou stále používat předchozí název.",
      title: "K čemu slouží název BitBoxu?"
    },
    "secure-chip": {
      link: {
        text: "Další informace o bezpečném čipu"
      },
      text: "Tato informace zobrazuje číslo modelu zabezpečeného čipu, nejnovější čip je ATECC608B s vylepšenými bezpečnostními funkcemi ve srovnání se staršími modely.",
      title: "Proč zobrazovat model bezpečného čipu?"
    }
  },
  receive: {
    address: {
      text: "Adresu můžete dát ostatním, aby vám poslali nějaké prostředky. Jen se ujistěte, že je posílají na správnou adresu.",
      title: "Co mohu dělat s adresou?"
    },
    addressChange: {
      text: "Jakmile provedete transakci, do seznamu se automaticky přidá nová adresa, takže je vždy k dispozici 20 adres, které nikdy neobdržely žádné prostředky.",
      title: "Kdy se adresy mění?"
    },
    addressFormats: {
      text: "Ve výchozím nastavení je typ adresy Native Segwit. Tento typ adresy je široce rozšířený mezi ostatními peněženkami/burzami poskytuje nejlepší sazby poplatků za každodenní transakce. Můžete si však také zvolit odesílání na Taproot (jen pro Bitcoin), což je nejnovější typ adresy, který však ještě nemusí být všude podporován. Případně, pokud máte problémy s odesíláním na Native Segwit (výchozí typ), můžete zkusit přejít na starší typ adresy Wrapped Segwit, který může být kompatibilní s více peněženkami/burzami.",
      title: 'Kdy mám použít "Změnit typ adresy"?'
    },
    howVerify: {
      text: "V případě BitBox01 klikněte na ikonu BitBox v postranním panelu vlevo a podívejte se do části Párování. Průvodce se aktualizuje a vy můžete pokračovat podle pokynů odtud.\nU BitBox02 můžete adresy ověřit přímo v zařízení během procesu odesílání/přijímání.",
      title: "Jak mohu bezpečně ověřit adresu?"
    },
    plugout: {
      text: "Ne, po odeslání prostředků na adresu BitBoxu nemusíte nechávat BitBox připojený. Svůj BitBox můžete kdykoli odpojit.",
      title: "Musím nechat svůj BitBox během přijímání zapojený?"
    },
    why20: {
      text: 'Během spuštění aplikace generuje adresy odvozené z vašeho seedu a zjišťuje, zda obdržely prostředky. Protože aplikace může generovat téměř nekonečné množství adres, mohla by zjišťováním zůstatku strávit roky. Aby se toto hledání omezilo, zastaví se, jakmile uvidí 20 adres, které nikdy neobdržely žádné prostředky. To je "gap limit" a 20 je de facto standard, i když toto číslo je libovolné. Z těchto 20 adres si můžete vybrat.',
      title: "Proč jenom 20 adres?"
    },
    whyMany: {
      text: "V zájmu zachování soukromí a bezpečnosti nikdy pro přijímaní nepoužívejte stejnou adresu dvakrát. Pokud jste adresu použili, klikněte na šipku vpravo pro novou adresu. Najednou můžete vygenerovat až 20 adres. Představte si adresy jako čísla faktur. Všechny adresy jsou odvozeny z vašeho jediného obnovovacího seedu.",
      title: "Proč tolik adres?"
    },
    whyVerify: {
      text: "Neměli byste věřit, že váš počítač generuje a zobrazuje autentické adresy. Jeho útočná plocha (attack surface) jej činí podstatně zranitelnějším než hardwarovou peněženku. U BitBox01 Tlačítko pro ověření adresy bezpečně odešle adresu do spárovaného mobilního telefonu, ze kterého můžete také naskenovat a ověřit kód QR. U BitBox02 lze adresu ověřit přímo na displeji BitBoxu.",
      title: "Proč bych měl adresu bezpečně ověřit?"
    }
  },
  send: {
    change: {
      text: "Zůstatek bude vrácen na adresu Taproot, pokud máte alespoň jedno  Taproot UTXO. Pokud použijete coin control, bude zůstatek vrácen na adresu Taproot, pokud je mezi vybranými UTXO alespoň jedno Taproot UTXO. Ve všech ostatních případech se změna vrátí na nativní adresu Segwit.",
      title: "Jak se určuje change output (hodnota zůstatku)?"
    },
    fee: {
      text: "Poplatek se odvíjí od velikosti dat transakce, nikoli od její výše. Cílové hodnoty poplatků jsou vypočítávány algoritmem pro odhad poplatků v Bitcoin Core pro každou vámi zvolenou prioritu sítě. Jsou zobrazeny, pokud mají jinou hodnotu než cíl uvedený níže.\nÚsporné: 24 bloků (přibližně 4 hodiny u Bitcoinu, 1 hodina u Litecoinu).\nNízké: 12 bloků (přibližně 2 hodiny pro Bitcoin, 30 minut pro Litecoin).\nNormální: 6 bloků (přibližně 1 hodina pro Bitcoin, 15 minut pro Litecoin).\nVysoké: 2 bloky (přibližně 20 minut pro Bitcoin, 5 minut pro Litecoin)\n(Vytěžení jednoho bloku trvá u Bitcoinu v průměru deset minut (u Litecoinu 2,5 minuty) a zatížení sítě se může ve výše uvedených obdobích značně lišit).",
      title: "Jak se určuje poplatek?"
    },
    plugout: {
      text: "Ne, jakmile provedete transakci, nemusíte nechávat svůj BitBox připojený. Můžete svůj BitBox kdykoli odpojit.",
      title: "Musím nechat svůj BitBox během odesílání připojený?"
    },
    priority: {
      text: "Čím vyšší poplatek jste ochotni zaplatit, tím rychleji je obvykle vaše transakce potvrzena sítí.",
      title: "Co je to priorita sítě (network priority)?"
    },
    revert: {
      text: "Jakmile je transakce podepsána a odeslána (tj. vyslána do sítě), nelze ji již vrátit zpět. Před podpisem transakce (včetně poplatku) ji pořádně ověřte!\nPokud příjemce znáte a je ochoten vám poslat stejnou částku (po odečtení transakčních poplatků) zpět, můžete mu poslat novou přijímací adresu.",
      title: "Mohu transakci vrátit zpět?"
    },
    whyFee: {
      text: "Transakce soutěží o jejich potvrzení těžařem. Těžaři vybírají transakce, které mají být zařazeny do blockchainu, na základě jejich poplatků.\nTěžaři hlasují o historii transakcí. Protože neexistuje důvěryhodná třetí strana, která by vynucovala jeden hlas na osobu (což je celý smysl blockchainů), hlasují těžaři o transakcích tak, že obětují nákladný zdroj, jako je výpočetní výkon. Jako odměnu za svou práci si mohou nárokovat nově vytvořené mince a poplatek za všechny zahrnuté transakce.",
      title: "Proč se platí síťový poplatek?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Pokud se k uzlu hodláte připojit pouze tehdy, když jste ve stejné síti (např. domácí wifi), pak vám postačí běžná síťová komunikace.\nV takovém případě je vhodné, aby váš Electrum server poskytoval certifikát TLS pro šifrování komunikace.\nPokud se hodláte k uzlu připojit odkudkoli, je lepší volbou použití sítě Tor. V takovém případě není certifikát TLS nutný.",
      title: "Mám použít clearnet TCP, TLS nebo Tor?"
    },
    instructions: {
      link: {
        text: "Průvodce pro připojení uzlu"
      },
      text: "Úplný návod naleznete v našem průvodci:",
      title: "Jak připojím BitBoxApp k vlastnímu uzlu?"
    },
    options: {
      text: "Existuje více možností, jak provozovat vlastní uzel, například zakoupit hotové zařízení, postavit si vlastní nebo používat Bitcoin Core.\nPokud chcete k uzlu připojit BitBoxApp, ujistěte se, že na něm běží server Electrum. Jedná se o specializovaný program, který umožňuje  peněžence komunikovat s vaším uzlem.\nMezi podporované možnosti patří Electrs, Electrum Personal Server (EPS) nebo Bitcoin Wallet Tracker (BTW).",
      title: "Jaké jsou možnosti provozování uzlu?"
    },
    tor: {
      text: 'Tor je zkratka pro "The Onion Router", což je bezplatný software s open source kódem, který nabízí mnoho výhod v oblasti ochrany soukromí a je užitečný zejména při používání Bitcoinu.\nPokud se hodláte připojit k uzlu prostřednictvím Toru, ujistěte se, že je Tor na vašem počítači nainstalován, a poté aktivujte Tor Proxy v nastavení BitBoxApp.\nU většiny operačních systémů existují dva způsoby, jak Tor spustit:\n1. Prohlížeč Tor: Stáhněte si a otevřete prohlížeč Tor Browser. To umožní aplikaci BitBoxApp připojit se k síti Tor nastavením portu 9150 v nastavení proxy serveru Tor.\n2. Služba Tor na pozadí: nainstalujte Tor daemon, který vždy běží na pozadí. BitBoxApp se pak může připojit nastavením portu 9050 v nastavení proxy serveru Tor.',
      title: "Co je Tor, Tor proxy a jaký port mám použít?"
    },
    what: {
      text: "Peněženku je možné provozovat s vlastním uzlem namísto serverů Shift.",
      title: "Co to je?"
    },
    why: {
      text: "Provozování vlastního uzlu není nutné, ale zlepšuje soukromí a snižuje potřebu důvěřovat někomu jinému.\nZaprvé to znamená, že používáte Bitcoin soukroměji, protože BitBoxApp se nebude připojovat k našim serverům, aby získala historii vašich transakcí; místo toho bude tyto informace získávat z vašeho vlastního uzlu.\nZa druhé, spuštění vlastního uzlu znamená, že váš uzel sám ověřuje všechny transakce a zajišťuje tak dodržování pravidel konsensu (consensus rules).",
      title: "Proč bych měl provozovat vlastní uzel?"
    }
  },
  settings: {
    sats: {
      text: 'Satoshi (zkráceně "sat") je nejmenší jednotka bitcoinu. Jeden satoshi je jedna stamiliontina bitcoinu (0,00000001 BTC). Je pojmenována po tvůrci bitcoinu Satoshi Nakamotovi.',
      title: "Co je to Satoshi?"
    },
    servers: {
      text: "Tato aplikace komunikuje se servery Shift Crypto a kontroluje aktualizace, načítá transakce a odesílá informace spárovaným mobilním aplikacím.\nAplikace také načítá nejnovější směnné kurzy z CoinGecko. Všechny konverze se počítají lokálně, což znamená, že se nikdy neodesílají žádné údaje o výši vaší transakce.\nPoznámka: Pro tokeny Ethereum a ERC20 používáme Etherscan.io API.",
      title: "S kterými servery tato aplikace komunikuje?"
    }
  },
  title: "Průvodce",
  toggle: {
    close: "Zavřít průvodce",
    open: "Průvodce"
  },
  trackingModePortfolioChart: {
    text: "Na počítači najeďte kurzorem na graf. Na mobilním telefonu podržte prst na grafu a potáhněte vodorovně.",
    title: "Jak zobrazit historické hodnoty na grafu?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Musíte zařízení resetovat a obnovit peněženku ze zálohy pomocí hesla pro obnovení.",
      title: "Co mám dělat, když jsem zapomněl heslo k zařízení?"
    },
    reset: {
      text: "Zadejte 15krát špatné heslo zařízení. Několik posledních pokusů vyžaduje dlouhý dotyk na zařízení.",
      title: "Jak resetuji zařízení?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Zařízení by mělo po připojení jednou bliknout. Ujistěte se, že je zapojeno správnou stranou. Pokud máte potíže, kontaktujte nás prostřednictvím níže uvedeného odkazu.\n\nZařízení BitBox01 není podporováno v mobilních zařízeních. K připojení zařízení BitBox01 použijte aplikaci BitBoxApp na stolním počítači.",
      title: "Můj BitBox01 nebyl rozpoznán"
    },
    getDevice: {
      link: {
        text: "Objednejte si BitBox"
      },
      text: "BitBox si můžete zakoupit v našem internetovém obchodě:",
      title: "Jak si mohu zařízení pořídit?"
    },
    internet: {
      text: "Ano, k synchronizaci peněženky, odesílání transakcí a načítání nejnovějších směnných kurzů je nutné připojení k internetu.",
      title: "Vyžaduje tato aplikace připojení k internetu?"
    },
    lostDevice: {
      link: {
        text: "Centrum zálohování"
      },
      text: "Své účty můžete obnovit na novém BitBoxu nebo v našem centru zálohování.",
      title: "Ztratil jsem zařízení. Co teď?"
    },
    useWithoutDevice: {
      text: "V současné době to bohužel není možné.",
      title: "Mohu aplikaci používat i bez zařízení?"
    },
    welcome: {
      text: "Děkujeme za používání této aplikace vytvořené společností Shift Crypto ve Švýcarsku. Jsme rádi za jakýkoli příspěvek, o který se s námi podělíte. Poskytněte prosím zpětnou vazbu pomocí odkazu v dolní části.",
      title: "Vítejte v BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Pokud používáte nový telefon/počítač s BitBoxApp, budete se muset k dapps připojit znovu. Poté opět uvidíte své prostředky v dapp jako obvykle.",
      title: "Nevidím svá předchozí spojení."
    },
    supportedNetworks: {
      text: "V současné době je pomocí WalletConnect v BitBoxApp podporován pouze Ethereum mainnet . Chcete-li používat jiné sítě kompatibilní s EVM, použijte prosím peněženku z rozšíření prohlížeče Rabby.",
      title: "Které sítě jsou podporovány?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikační protokol pro aplikace web3. Umožňuje pohodlné připojení k DApps a webovým peněženkám založeným na Ethereu bez použití aplikace třetí strany, což je užitečné zejména pro uživatele BitBoxApp pro Android.",
      title: "Co je WalletConnect?"
    }
  }
};
const headerssync$h = {
  blocksSynced: "{{blocks}} bloků zesynchronizováno"
};
const hiddenWallet$h = {
  info1HTML: "Pro účely hodnověrného popření (plausible deniability) lze skrytou peněženku vytvořit na základě kombinace <strong>odlišného</strong> hesla zařízení + hesla pro obnovení.",
  info2HTML: "Níže definujte heslo zařízení a heslo pro obnovení, které chcete přiřadit ke své skryté peněžence. Heslo zařízení a heslo pro obnovení musí být <strong>odlišné</strong> od těch, které jste definovali pro svou primární peněženku.",
  passwordLabel: "Skryté heslo pro obnovení",
  passwordPlaceholder: "Potvrďte prosím skryté heslo pro obnovení",
  pinLabel: "Heslo pro skryté zařízení",
  pinRepeatLabel: "Zopakujte heslo pro skryté zařízení",
  pinRepeatPlaceholder: "Potvrďte prosím heslo pro skryté zařízení",
  success: "Skrytá peněženka byla úspěšně vytvořena. Znovu připojte svůj BitBox, abyste jej odemkli."
};
const initialize$h = {
  create: "Nastavit heslo zařízení",
  creating: "Nastavování hesla zařízení…",
  error: {
    e102: "Heslo zařízení musí obsahovat alespoň 4 znaky."
  },
  info: {
    description1: "Zvolte heslo zařízení. To bude použito k odemknutí vašeho BitBoxu.",
    description2: "Můžete používat čísla, písmena a symboly. Delší hesla poskytují vyšší bezpečnost.",
    description3: "Pokud heslo k zařízení ztratíte, budete muset zařízení resetovat a obnovit ze zálohy.",
    subtitle: "Nyní nastavíte heslo svého zařízení",
    title: "Inicializace zařízení"
  },
  input: {
    label: "Heslo zařízení",
    labelRepeat: "Opakujte heslo zařízení",
    placeholderRepeat: "Potvrďte heslo zařízení"
  }
};
const invalidFormat$h = "Nesprávný formát";
const language$i = {
  title: "Zvolte jazyk"
};
const legacyhiddenwallet$h = {
  disable: "Deaktivovat legacy skrytou peněženku",
  enable: "Aktivovat legacy skrytou peněženku",
  successDisable: "Úspěšně deaktivována legacy skrytá peněženka.",
  successEnable: "Starší legacy peněženka byla úspěšně aktivována. Znovu zapojte svůj BitBox a zadejte heslo skrytého zařízení pro přístup k legacy skryté peněžence."
};
const loading$h = "načítání…";
const manageAccounts$b = {
  accountHidden: "Tento účet byl skryt z vašich watch-only účtů. Chcete-li jej znovu zobrazit, připojte prosím svůj BitBox02.",
  editAccount: "Upravit",
  editAccountNameTitle: "Upravit název účtu",
  noAccounts: "nebyly nalezeny žádné účty",
  settings: {
    hideTokens: "Skrýt tokeny",
    showTokens: "Zobrazit tokeny ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Přidat a zobrazit/skrýt účty",
  title: "Spravovat účty",
  watchAccount: "Sledovat účet",
  watchAccountDescription: "Tento účet je součástí watch-only účtů. Můžete jej skrýt ze svých watch-only účtů pomocí přepínače."
};
const mobile$c = {
  usingMobileDataWarning: "Využití mobilních dat: tato aplikace může po odemčení účtu stáhnout až několik set megabajtů dat z blockchainu. Abyste se vyhnuli používání mobilních dat, připojte se k Wi-Fi. Po jejím zavření se tato zpráva již nebude zobrazovat."
};
const newSettings$a = {
  about: {
    appVersion: {
      title: "Verze aplikace"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Uzamčení přístupu k aplikaci pomocí zámku obrazovky/otisku prstu.",
      title: "Uzamčení obrazovky"
    },
    coinControl: {
      description: "Vyberte, které UTXO jsou součástí transakce, abyste zlepšili soukromí."
    },
    customFees: {
      description: "Umožňuje zadat vlastní poplatek při odesílání."
    },
    torProxy: {
      description: "Připojte se přes Tor pro lepší soukromí."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Tyto další měny můžete přepínat na stránce svého účtu.",
      title: "Aktivní měny"
    },
    darkmode: {
      description: "Podívejte se na BitBoxApp v tmavém režimu."
    },
    defaultCurrency: {
      description: "Vyberte výchozí měnu",
      title: "Výchozí měna"
    },
    enableAccount: {
      description: "Deaktivace účtu znamená, že se nezobrazí v postranním panelu ani v portfoliu. Zde jej můžete kdykoli znovu aktivovat. Prostředky na tomto účtu nebudou ovlivněny a zůstanou v bezpečí.",
      title: "Aktivovat/deaktivovat účet"
    },
    hideAmounts: {
      description: "Zobrazuje přepínač pro skrytí zůstatku a částek pro ochranu soukromí při používání aplikace na veřejnosti.",
      hideAmounts: "Skrýt částky",
      showAmounts: "Zobrazit částky",
      title: "Povolit skrytí částek"
    },
    language: {
      description: "Jaký jazyk chcete v BitBoxApp používat.",
      title: "Jazyk"
    },
    remebmerWallet: {
      name: "Zapamatovat peněženku",
      warning: "Tím odstraníte zapamatovanou peněženku. Chcete-li ji znovu zobrazit, musíte připojit BitBox02 pro tuto peněženku. Žádné prostředky v této peněžence nebudou ovlivněny. Chcete pokračovat?",
      warningTitle: "Deaktivovat zapamatování peněženky"
    },
    toggleSats: {
      description: "Aktivovat nebo deaktivovat Satoshi."
    }
  }
};
const note$d = {
  input: {
    description: "(volitelný)",
    placeholder: "Přidat poznámku…"
  },
  title: "Poznámka"
};
const notification$h = {
  newTxs_one: "Nová transakce v: {{accountName}}",
  newTxs_other: "{{count}} nové transakce v: {{accountName}}"
};
const pairing$h = {
  aborted: {
    text: "Párování bylo z mobilní aplikace zrušeno.",
    title: "Zrušeno"
  },
  button: "Spárovat mobilní aplikaci",
  confirm: "Jste si jisti, že chcete spárovat svůj BitBox? Pamatujte, že poté je k provedení transakce vyžadován mobilní telefon.",
  connectOnly: {
    button: "Připojte mobilní aplikaci",
    title: 'Naskenujte pomocí naší mobilní aplikace výběrem položky "Připojit k nové aplikaci".'
  },
  error: {
    text: "Něco se pokazilo. Začněte prosím znovu.",
    title: "Chyba"
  },
  pullFailed: {
    text: "Nepodařilo se stáhnout zprávu z mobilního telefonu prostřednictvím serveru. Server může být offline, kontaktujte prosím podporu.",
    title: "Vytažení se nezdařilo"
  },
  reconnectOnly: {
    button: "Znovu připojte mobilní aplikaci"
  },
  scanningFailed: {
    text: "Mobilní telefon nebyl schopen zprávu úspěšně naskenovat. Zkuste to prosím znovu.",
    title: "Skenování se nezdařilo "
  },
  start: {
    hideAppQRCode: "Skrýt QR kód",
    revealAppQRCode: "Zobrazit QR kód",
    step1: "Pokud mobilní aplikaci nemáte, můžete naskenovat QR kód pro Apple App Store nebo Google Play Store podle toho, který telefon máte.",
    step2: 'Naskenujte pomocí naší mobilní aplikace, kterou najdete pod názvem "Digital Bitbox 2FA" v obchodech s aplikacemi pro iOS a Android:'
  },
  started: {
    text: "Nyní postupujte podle pokynů v mobilní aplikaci.",
    title: "Skvělý"
  },
  success: {
    text: "Gratulujeme, úspěšně jste spárovali svůj BitBox s mobilní aplikací!",
    title: "Hotovo"
  },
  timeout: {
    text: "Párování se po dvou minutách přerušilo. Pokud chcete ještě spárovat mobilní aplikaci, spusťte ji znovu.",
    title: "Timeout"
  },
  title: "Párování mobilního telefonu"
};
const passphrase$b = {
  considerations: {
    button: "Úvahy ohledně zálohování",
    message: "Přístupová fráze přidává vrstvu ochrany k vaší záloze peněženky (záloha na microSD kartě nebo obnovovací slova). Pokud má někdo přístup k vaší záloze, bude k přístupu do peněženky potřebovat také přístupovou frázi.\n\nTo však znamená, že v případě ztráty nebo rozbití vašeho BitBoxu budete potřebovat <strong>i přístupovou frázi i zálohu peněženky</strong> pro obnovení vaší peněženky s přístupovou frází. Pokud zapomenete nebo ztratíte svou přístupovou frázi, ztratíte přístup ke všem prostředkům v této peněžence.\n\nPři ukládání přístupové fráze zvažte její umístění na jiné místo než kde máte zálohu. Pokud někdo najde vaši zálohu, nenajde tak vaši přístupovou frázi.",
    title: "Úvahy ohledně zálohování"
  },
  disable: "Deaktivovat přístupovou frázi",
  disableInfo: {
    button: "Deaktivovat",
    message: "Po vypnutí přístupové fráze již nebudete po odemknutí BitBoxu vyzváni k zadání přístupové fráze. Proto vstoupíte do své výchozí peněženky.\n\nVeškeré prostředky ve vaší peněžence s přístupovou frází budou stále v této peněžence, avšak nebudete k nim mít přístup, protože po odemknutí vašeho BitBoxu otevřete svou výchozí peněženku.\n\nPro opětovný přístup k vašim peněženkám s přístupovou frází jednoduše znovu zapněte funkci přístupové fráze a po odemknutí BitBoxu zadejte příslušnou přístupovou frázi.\n\n<strong>Tip:</strong> Do své výchozí peněženky můžete přistoupit i ponecháním prázdné přístupové fráze, když ji máte aktivovanou."
  },
  enable: "Aktivovat přístupovou frázi",
  error: {
    e104: "Změna nastavení přístupové fráze byla zrušena."
  },
  how: {
    button: "Jak to vypadá",
    message: "A přístupová fráze nefunguje jako heslo, na které jste zvyklí. Pokud heslo zadáte chybně, nebudete na to upozorněni. Je to proto, že <strong>každá přístupová fráze vytváří jinou, avšak platnou peněženku.</strong> To znamená, že můžete používat více přístupových frází pro libovolný počet peněženek. Každá peněženka je však přístupná pouze po zadání příslušné přístupové fráze.\n\nPo připojení BitBoxu budete jako obvykle vyzváni k zadání hesla zařízení. Poté budete vyzváni k zadání přístupové fráze.\n\nPo zadání přístupové fráze se zobrazí vámi zadaná přístupová fráze. To proto, abyste mohli potvrdit, že jste ji zadali správně.",
    title: "Jak to funguje"
  },
  intro: {
    message: "Přístupová fráze poskytuje další vrstvu zabezpečení nad vaší peněženkou.\nPojďme se naučit, jak to funguje.",
    title: "Nastavení přístupové fráze"
  },
  progressDisable: {
    message: "Potvrďte na svém BitBoxu, že chcete <strong>deaktivovat</strong> volitelnou přístupovou frázi.",
    title: "Potvrďte na zařízení"
  },
  progressEnable: {
    message: "Potvrďte na svém BitBoxu, že chcete <strong>aktivovat</strong> volitelnou přístupovou frázi.",
    title: "Potvrďte na zařízení"
  },
  successDisabled: {
    message: "Volitelná přístupová fráze <strong>byla úspěšně aktivována</strong>!\nOd této chvíle budete vyzváni k zadání přístupové fráze.",
    messageEnd: "Nyní znovu připojte BitBox02.",
    title: "Přístupová fráze aktivní"
  },
  successEnabled: {
    message: "Volitelná přístupová fráze <strong>byla úspěšně deaktivována</strong>!\n\nJiž nebudete vyzváni k zadání přístupové fráze.",
    messageEnd: "Nyní znovu připojte svůj BitBox02.",
    tips: "Tipy",
    tipsList: [
      "Doporučujeme nejprve odeslat malou částku do peněženky s přístupovou frází. Poté odpojte a znovu zapojte BitBox02 a zadejte heslo a přístupovou frázi. Pokud jste zadali přístupovou frázi správně, měli byste prostředky vidět ve své peněžence.",
      "Pokud chcete vstoupit do své původní peněženky bez přístupové fráze, můžete to provést tak, že po výzvě k zadání přístupové fráze nezadáte nic. Nebo můžete funkci přístupové fráze vypnout."
    ],
    title: "Přístupová fráze deaktivována"
  },
  summary: {
    button: "Aktivovat přístupovou frázi",
    title: "Přehled",
    understand: "Rozumím fungování přístupové fráze a rizikům s tím spojeným.",
    understandList: [
      "Přístupová fráze představuje další vrstvu zabezpečení nad vaší zálohou.",
      "Zadáním jiné přístupové fráze se vždy vygeneruje jiná peněženka.",
      "K obnovení peněženky potřebujete <strong>přístupovou frázi i zálohu</strong>.",
      "Pokud zapomenete přístupovou frázi, <strong>ztratíte přístup ke svým prostředkům</strong>."
    ]
  },
  what: {
    button: "Přečtěte si, jak to funguje",
    message: "Peněženka je vytvořena (odvozena) z velmi velkého náhodného čísla, známého také jako seed. Tento seed, nebo slova pro obnovení, je vytvořen při prvním nastavení BitBoxu a je zálohován pomocí microSD karty anebo prostřednictvím jiné zálohy (papír, steelwallet apod.). Každý, kdo má přístup k seedu, má plnou kontrolu nad prostředky v této peněžence.\n\nPřístupová fráze je <strong>volitelné tajemství</strong>, které se přidává k seedu. Při použití přístupové fráze se při každém použití vytvoří nová peněženka na základě seedu + přístupové fráze (nepovinného tajemství). Passphrase může být jakákoli: písmena, slova, speciální znaky nebo může být i prázdná. Výchozí peněženka je ve skutečnosti odvozena od seedu + prázdné přístupové fráze.\n\nPřístupová fráze je součástí standardu BIP39, což znamená, že je kompatibilní se všemi peněženkami, které tento standard podporují.",
    title: "Co je přístupová fráze?"
  },
  why: {
    button: "Proč používat přístupovou frázi",
    message: 'BitBox02 chrání seed před stažením ze samotného zařízení, ale záloha (uložena na microSD kartě nebo obnovovací slova zapsaná na papíře) umožňuje plný přístup k peněžence. Proto by měla být uložena na bezpečném místě!\n\nVzhledem k tomu, že přístupová fráze vytváří novou peněženku pomocí vašeho stávajícího seedu, vyžaduje peněženka s přístupovou frází k obnovení <strong>zálohu i přístupovou frázi</strong>. Výhodou je, že pokud někdo najde vaši zálohu, bude k přístupu do peněženky s přístupovou frází stále potřebovat přístupovou frázi.\n\nFunkce přístupové fráze navíc umožňuje vytvořit na stejném zařízení více peněženek nebo "skrytých peněženek" kromě té výchozí.',
    title: "Proč používat přístupovou frázi?"
  }
};
const password$h = {
  show: "Zobrazit {{label}}",
  warning: {
    caps: "VAROVÁNÍ: Caps Lock (⇪) je zapnutý",
    paste: 'pro vložení textu povolte "ZOBRAZIT {{label}}"'
  }
};
const random$i = {
  button: "Vygenerujovat náhodné číslo",
  description: "Váš BitBox vygeneroval následující {{bits}}-bit náhodné číslo:"
};
const receive$j = {
  bitsuranceWarning: "Toto je pojištěný účet, což znamená, že může přijímat pouze na Native Segwit. Je to proto, abyste náhodou neobdrželi Wrapped Segwit nebo Taproot, které nejsou pojištěny.",
  changeScriptType: "Změňit typ adresy",
  label: "Vaše adresa",
  onlyThisCoin: {
    description: "Chcete-li přijímat další tokeny, aktivujte je v nastavení. Pokud vložíte jiné tokeny, nemusí být přístupné.",
    warning: "Ujistěte se, že přijímáte pouze {{coinName}} na této adrese."
  },
  scriptType: {
    p2tr: "Taproot (nejnovější formát)",
    p2wpkh: "Nativní Segwit (výchozí)",
    "p2wpkh-p2sh": "Wrapped Segwit (kompatibilní formát)"
  },
  selectAccount: "Vybrat účet",
  showFull: "Zobrazit a ověřit celou adresu na zařízení",
  taprootWarning: "Poznámka: Taproot je nová funkce Bitcoinu a zatím není široce používána. Prostředky přijaté na adresy Taproot nemusí být viditelné v peněženkách třetích stran, které jsou určeny pouze pro sledování (watch-only wallets). Mnoho peněženek a burz zatím není schopno posílat na adresy Taproot.",
  title: "Přijmout {{accountName}}",
  verify: "Bezpečně ověřit adresu",
  verifyBitBox01: "Ověřit adresu v mobilní aplikaci",
  verifyBitBox02: "Ověřit adresu na BitBox02",
  verifyInstruction: "Zkontrolujte, zda se následující adresa shoduje s adresou zobrazenou na vašem zařízení.",
  warning: {
    secureOutput: 'Spárujte prosím svůj BitBox s mobilním zařízením, abyste mohli bezpečně ověřit adresu. Přejděte na "Spravovat zařízení" v postranním panelu.'
  }
};
const reset$h = {
  description: "Všechna data v zařízení budou smazána. Včetně vašeho soukromého klíče!",
  notReset: "Zařízení nebylo resetováno",
  title: "Resetovat zařízení do továrního nastavení",
  understand: "Mám zálohu a znám heslo pro obnovení",
  understandBB02: "Mám platnou zálohu"
};
const securityInformation$h = {
  create: {
    description1: "Doporučujeme nastavovat zařízení v bezpečném prostředí, to znamená mimo dosah dalších osob, které by mohly vidět vámi zvolené heslo.",
    description2: "Budete vyzváni k vytvoření dvou hesel.",
    description3: "První je <strong>heslo zařízení</strong>, které odemkne váš BitBox a které lze později změnit.",
    description4: "Druhým je <strong>heslo pro obnovení</strong>, které odemkne vaši peněženku. Toto heslo nelze později změnit.",
    description5: "Peněženka, kterou vytvoříte, bude zálohována do souboru na dodané microSD kartě. Ten můžete v případě nouze použít k obnovení svých prostředků pomocí hesla pro obnovení.",
    title: "Informace o zabezpečení"
  },
  restore: {
    description1: "Budete vyzváni k vložení microSD karty, kterou jste použili k uložení zálohy.",
    description2: "K obnovení zařízení budete potřebovat heslo pro obnovení. ",
    description3: "Při zadávání hesla pro obnovení buďte opatrní. Jakékoli zadané heslo vytvoří platnou peněženku. Pokud zadáte špatné heslo, může se vám zobrazit zůstatek peněženky, který neočekáváte.",
    title: "Informace o zabezpečení"
  }
};
const seed$h = {
  agreements: {
    "funds-access": "Pokud zapomenu heslo pro obnovení, ZTRATÍM přístup ke svým finančním prostředkům.",
    "password-change": "Heslo pro obnovení NEMŮŽU později změnit",
    "password-required": "Heslo pro obnovení je nutné pro obnovení peněženky ze zálohy."
  },
  create: "Vytvořit peněženku",
  creating: "Vytváření peněženky",
  description: "Rozumím, že:",
  error: {
    e102: "Heslo musí obsahovat alespoň 4 znaky.",
    e200: "Pro vytvoření peněženky je třeba do BitBoxu vložit microSD kartu, aby se mohla automaticky vytvořit záloha."
  },
  info: {
    button: "Nastavit heslo pro obnovení",
    description1: "Vložte microSD kartu do zařízení BitBox",
    description2: 'Zvolte heslo pro obnovení peněženky a vyberte možnost "Nastavit heslo pro obnovení".',
    description3: "Zálohování na microSD kartu a heslo pro obnovení je jedinou metodou, jak obnovit své prostředky v případě ztráty nebo krádeže BitBoxu.",
    description4: "Heslo pro obnovení nelze později změnit bez převodu finančních prostředků.",
    title: "Vytvořit novou peněženku"
  },
  password: {
    label: "Heslo pro obnovení",
    repeatPlaceholder: "Zopakujte heslo pro obnovení"
  },
  walletName: {
    label: "Název peněženky"
  }
};
const seedRestore$h = {
  error: {
    e200: "Obnovení peněženky ze zálohy vyžaduje microSD kartu."
  },
  info: {
    description1: 'Vložte microSD kartu do BitBoxu a klikněte na tlačítko "Pokračovat".',
    description2: 'Vyberte zálohu a klikněte na tlačítko "Obnovit".',
    description3: "Zadejte heslo pro obnovení",
    description4: "Je zapotřebí potvrdit, abyste si uvědomili, že nesprávné heslo vytvoří jinou peněženku.",
    title: "Jak obnovit peněženku ze zálohy"
  }
};
const send$j = {
  abort: "Transakce byla zrušena.",
  address: {
    label: "Adresa přijemce",
    placeholder: "Zadejte adresu"
  },
  amount: {
    label: "Částka",
    placeholder: "Zadejte částku"
  },
  availableBalance: "Dostupný zůstatek",
  button: "Překontrolování",
  coincontrol: {
    address: "Adresa",
    outpoint: "Outpoint",
    title: "Odeslat z outputu"
  },
  confirm: {
    "selected-coins": "Vybrané mince",
    title: "Potvrďte a odešlete transakci",
    total: "Celkem"
  },
  error: {
    erc20InsufficientGasFunds: "Zdá se, že nemáte dostatek etherů na zaplacení této ERC20 transakce. Ujistěte se prosím, že máte v peněžence dostatek etherů.",
    feeTooLow: "poplatek příliš nízký",
    feesNotAvailable: "Nelze odhadnout poplatky",
    insufficientFunds: "nedostatek finančních prostředků",
    invalidAddress: "neplatná adresa",
    invalidAmount: "neplatná částka",
    invalidData: "neplatná data"
  },
  fee: {
    customPlaceholder: "Zadejte částku",
    label: "Síťový poplatek",
    placeholder: "Není dostupný"
  },
  feeTarget: {
    customLabel: "Výše poplatku",
    customLabel_eth: "Gas cena",
    description: {
      economy: "4 hodiny (24 bloků)",
      economy_eth: "30 minut nebo méně",
      economy_ltc: "1 hodina (24 bloků)",
      high: "20 minut (2 bloky)",
      high_eth: "30 sekund nebo méně",
      high_ltc: "5 minut (2 bloky)",
      low: "2 hodiny (12 bloků)",
      low_eth: "5 minut nebo méně",
      low_ltc: "30 minut (12 bloků)",
      normal: "1 hodina (6 bloků)",
      normal_eth: "2 minuty nebo méně",
      normal_ltc: "15 minut (6 bloků)"
    },
    estimate: "Odhadovaný čas potvrzení:",
    label: {
      custom: "Vlastní",
      economy: "Úsporný",
      high: "Vysoký",
      low: "Nízký",
      normal: "Normální"
    },
    placeholder: "Výpočet poplatku…"
  },
  maximum: "Poslat vše",
  maximumSelectedCoins: "Poslat vybrané mince",
  noFeeTargets: "Odhady výše poplatků nejsou v současné době k dispozici. Zkuste to prosím později nebo zadejte vlastní poplatek.",
  priority: "Priorita",
  scanQR: "Naskenujte QR kód",
  signprogress: {
    description: "Jedná se o transakci obsahující velké množství dat. Chcete-li transakci plně podepsat, budete vyzváni k potvrzení {{steps}}krát.",
    label: "Průběh"
  },
  success: "Transakce byla podepsána a odeslána.",
  title: "Poslat {{accountName}}",
  toggleCoinControl: "Přepnout na coin control",
  transactionDetails: "Detaily transakce"
};
const settings$i = {
  about: "O aplikaci",
  accounts: "Účty",
  advancedSettings: "Pokročilé nastavení",
  appearance: "Vzhled",
  electrum: {
    add: "Přidat server",
    "add-server": "Přidat",
    check: "Kontrola",
    checkFailed: "Kontrola selhala",
    checkSuccess: "Úspěšně navázáno spojení s {{host}}",
    checking: "Kontroluji",
    "download-cert": "Stáhnout vzdálený certifikát",
    "remove-server": "Odstranit",
    removeConfirm: "Odstranit {{server}}?",
    reset: "Obnovit do základního nastavení",
    resetConfirm: "Chcete odebrat všechny servery a nainstalovat výchozí servery?",
    servers: "Servery",
    step1: "1",
    "step1-text": "Zadejte endpoint.",
    step2: "2",
    "step2-text": "Zadejte certifikát řetězce certifikátů serveru. Případně stáhněte vzdálený certifikát a vizuálně jej porovnejte.",
    "step2-text-tcp": "Pokud nechcete používat TLS, můžete tento krok přeskočit.",
    step3: "3",
    "step3-text": "Zkontrolujte připojení a přidejte server.",
    step4: "4",
    "step4-text": "Restartujte peněženku. Pokud neodstraníte výchozí servery, bude váš vlastní uzel přidán jako nadbytečný.",
    "title-btc": "Bitcoinové Electrum servery",
    "title-ltc": "Litecoin Electrum servery",
    "title-tbtc": "Bitcoin Testnet Electrum servery",
    "title-tltc": "Litecoin Testnet Electrum servery"
  },
  expert: {
    coinControl: "Aktivovat coin control",
    electrum: {
      description: "Můžete se připojit ke svému vlastnímu Electrum uzlu (full node).",
      title: "Připojte svůj vlastní uzel (full node)"
    },
    fee: "Aktivovat vlastní poplatky",
    setProxyAddress: "Nastavit adresu proxy",
    title: "Expertní nastavení",
    useProxy: "Aktivovat tor proxy",
    useSats: "Zobrazit hodnoty BTC v satoshi"
  },
  header: {
    home: "Domů"
  },
  info: {
    "out-of-date": "K dispozici je nová aktualizace",
    title: "Info",
    "up-to-date": "Vaše aplikace je aktuální",
    version: "Verze aplikace"
  },
  restart: "Restartujte BitBoxApp, aby se změny projevily.",
  services: {
    title: "Služby"
  },
  success: "Aby se změny projevily, odpojte a znovu připojte BitBox.",
  title: "Nastavení"
};
const setup$h = "Nastavení zařízení";
const sidebar$i = {
  buy: "Koupit krypto",
  device: "Spravovat zařízení",
  insurance: "Pojištění",
  leave: "Odejít",
  settings: "Nastavení"
};
const success$o = {
  create: {
    info1: "Vaše peněženka byla bezpečně zálohována na microSD kartu. Vyjměte ji a uschovejte v bezpečí.",
    info2: "Vytvořili jste bezpečné heslo zařízení, které odemyká BitBox.",
    info3: "Pro svou peněženku jste si vytvořili bezpečné heslo pro obnovení, které odemkne vaše prostředky a obnoví vaše zálohy.",
    summary: "Zde je shrnutí toho, co jste udělali",
    title: "Hotovo"
  },
  getstarted: "Začněte",
  restore: {
    summary: "Úspěšně jste obnovili peněženku ze zálohy.",
    title: "Hotovo"
  }
};
const transaction$i = {
  confirmation: "Konfirmace",
  details: {
    activity: "Přehled aktivit",
    address: "Adresa",
    amount: "Částka",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Částka ve fiatu",
    fiatAtTime: "Fiat v době transakce",
    status: "Stav",
    title: "Detaily transakce",
    type: "Typ"
  },
  explorer: "ID transakce",
  explorerTitle: "Otevřít v externím block exploreru",
  fee: "Poplatek",
  fiatHistorical: "Historický",
  gas: "Gas",
  note: {
    edit: "Upravit poznámku",
    save: "Uložit poznámku"
  },
  pending: "Čekající transakce",
  size: "Velikost",
  status: {
    complete: "Dokončená",
    failed: "Neúspěšná",
    pending: "Čekající"
  },
  tx: {
    received: "Přijata na",
    sent: "Odeslána na"
  },
  vsize: "Virtuální velikost",
  weight: "Váha"
};
const transactions$h = {
  errorLoadTransactions: "Při načítání transakcí došlo k chybě",
  placeholder: "Zatím žádné transakce."
};
const unknownError$h = "Nastala neznámá chyba: {{errorMessage}}";
const unlock$h = {
  description: "Pro odemknutí zadejte heslo zařízení.",
  error: {
    e109_normal: "Nesprávné heslo. Zbývá ještě {{remainingAttempts}} pokusů, než bude zařízení resetováno.",
    e109_touch: "$t(unlock.error.e109_normal) Další přihlášení vyžaduje podržení dotykového tlačítka.",
    e113: "Vzhledem k mnoha pokusům o přihlášení vyžaduje další přihlášení podržení dotykového tlačítka po dobu 4 sekund."
  },
  input: {
    label: "Heslo zařízení",
    placeholder: "Zadejte heslo zařízení pro odemknutí"
  },
  unlocking: "Odemykání..."
};
const upgradeFirmware$i = {
  button: "Aktualizovat firmware",
  description: "Chcete aktualizovat firmware z {{currentVersion}} verze na {{newVersion}}?",
  label: "Váš BitBox vyžaduje upgrade firmwaru.",
  locked: "Chcete-li provést upgrade z {{currentVersion}} na {{newVersion}}, proveďte dlouhý dotyk.",
  title: "Upgradovat firmware",
  unlocked: "Bootloader je odemčený. Chcete-li pokračovat, prosím:",
  unlocked1: "Odpojte a znovu zapojte váš Bitbox",
  unlocked2: "Po opětovném zapojení vašeho BitBoxu se rozsvítí LED dioda.",
  unlocked3: "Když se rozsvítí LED dioda, klepněte na dotykové tlačítko"
};
const walletConnect$c = {
  connect: {
    button: "Připojit",
    dappLabel: "Zadejte URI adresu dapp",
    invalidPairingUri: "Neplatné párování uri"
  },
  dashboard: {
    allSessions: "Všechny relace",
    disclaimer: "Walletconnect je protokol pro připojení k Dapps založeným na Ethereu. Tyto dapps jsou provozovány službami třetích stran, takže se připojujte pouze k dapps, kterým důvěřujete, a vždy se ujistěte, že víte, co podepisujete při provádění transakce.",
    newConnection: "Nové připojení",
    noConnectedSessions: "V této chvíli nejsou k dapps připojeny žádné účty."
  },
  invalidPairingChain: "Chyba při schvalování párování. Ujistěte se, že používáte jednu z podporovaných sítí: {{chains}}",
  pairingRequest: {
    approve: "Schválit připojení",
    reject: "Odmítnout",
    title: "Nový požadavek na připojení od"
  },
  pairingSuccess: "Dapp se úspěšně připojil. Pokračovat můžete na dapp webu",
  signingRequest: {
    account: "Účet",
    chain: "Síť",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Nepodařilo se zpracovat data",
    decodeError: "Zprávu se nepodařilo dekódova",
    method: {
      sendTransaction: "Podepište a odešlete transakci",
      signMessage: "Podepsat zprávu",
      signTransaction: "Podepsat transakci",
      signTypedData: "Podepište zadaná data"
    },
    successfullySigned: "Žádost byla úspěšně podepsána",
    walletConnectRequest: "Žádost o připojení k WalletConnect"
  },
  useNewUri: "Tento URI již byl použit k pokusu o připojení. Použijte prosím nový URI.",
  walletConnect: "WalletConnect"
};
const warning$n = {
  receivePairing: 'Spárujte BitBox, abyste mohli bezpečně ověřit adresu. Přejděte na "Spravovat zařízení" v postranním panelu.',
  sdcard: "MicroSD kartu mějte uloženou odděleně od BitBoxu, pokud ovšem nechcete spravovat zálohy.",
  sendPairing: 'Spárujte prosím BitBox a bezpečně ověřte údaje o transakci. Přejděte na "Spravovat zařízení" v postranním panelu.'
};
const welcome$h = {
  connect: "Připojte BitBox02",
  getStarted: "Začněme instalací firmwaru na váš BitBox02.",
  insertBitBox02: "Pro BitBox02 klepněte na zařízení a pokračujte.",
  insertDevice: "Připojte své zařízení a začněte",
  title: "Vítejte"
};
const appTranslationsCS = {
  account: account$h,
  accountInfo: accountInfo$h,
  accountSummary: accountSummary$h,
  addAccount: addAccount$i,
  aopp: aopp$b,
  app: app$h,
  auth: auth$b,
  backup: backup$h,
  bb02Bootloader: bb02Bootloader$h,
  bitbox: bitbox$h,
  bitbox02Interact: bitbox02Interact$h,
  bitbox02Settings: bitbox02Settings$h,
  bitbox02Wizard: bitbox02Wizard$h,
  bitsurance: bitsurance$a,
  bitsuranceAccount: bitsuranceAccount$a,
  blink: blink$h,
  bootloader: bootloader$h,
  button: button$m,
  buy: buy$d,
  changePin: changePin$h,
  chart: chart$d,
  checkSDcard: checkSDcard$h,
  clickHere: clickHere$h,
  confirm: confirm$j,
  confirmOnDevice: confirmOnDevice$h,
  connectKeystore: connectKeystore$b,
  darkmode: darkmode$b,
  device: device$h,
  deviceLock: deviceLock$h,
  deviceSettings: deviceSettings$h,
  deviceTampered: deviceTampered$h,
  dialog: dialog$i,
  error: error$d,
  fiat: fiat$j,
  footer: footer$j,
  generic: generic$d,
  genericError: genericError$h,
  goal: goal$h,
  guide: guide$i,
  headerssync: headerssync$h,
  hiddenWallet: hiddenWallet$h,
  initialize: initialize$h,
  invalidFormat: invalidFormat$h,
  language: language$i,
  legacyhiddenwallet: legacyhiddenwallet$h,
  loading: loading$h,
  manageAccounts: manageAccounts$b,
  mobile: mobile$c,
  newSettings: newSettings$a,
  note: note$d,
  notification: notification$h,
  pairing: pairing$h,
  passphrase: passphrase$b,
  password: password$h,
  random: random$i,
  receive: receive$j,
  reset: reset$h,
  securityInformation: securityInformation$h,
  seed: seed$h,
  seedRestore: seedRestore$h,
  send: send$j,
  settings: settings$i,
  setup: setup$h,
  sidebar: sidebar$i,
  success: success$o,
  transaction: transaction$i,
  transactions: transactions$h,
  unknownError: unknownError$h,
  unlock: unlock$h,
  upgradeFirmware: upgradeFirmware$i,
  walletConnect: walletConnect$c,
  warning: warning$n,
  welcome: welcome$h
};
const account$g = {
  disconnect: "Verbindung unterbrochen. Erneut verbinden... ",
  "export": "Export",
  exportTransactions: "Exportiere Transaktionen im Download Ordner als CSV Datei",
  fatalError: "Ein unerwarteter Fehler ist aufgetreten.",
  incoming: "Eingehend",
  initializing: "Informationen werden von der Blockchain geladen…",
  insuranceExpired: "<strong>Konto nicht mehr versichert</strong>\n\nDer Versicherungsplan für dieses Konto wurde geändert.\nBitte sehe dir die Versicherungsseite für Details an.",
  insured: "Versichertes Konto",
  maybeProxyError: "Tor-Proxy aktiviert. Stelle sicher, dass Tor-Proxy ordnungsgemäß ausgeführt wird, oder deaktiviere die Proxy-Einstellung.",
  reconnecting: "Verbindung abgebrochen, neue Verbindung wird aufgebaut…",
  syncedAddressesCount: "{{count}} Adressen gescannt",
  uncoveredFunds: "Du hast Coins auf den folgenden nicht abgesicherten Adresstypen von deinem <strong>{{name}}</strong> Konto: {{uncovered}}.\nDa das Konto versichert ist, sind nur Coins welche via den <strong>Native Segwit</strong> Adresstyp empfangen werden abgesichert. Coins auf anderen Adresstypen, auch wenn sie sich auf demselben Konto befinden, sind nicht versichert.\nBitte verschiebe alle deine Coins von den nicht unterstützten Adresstypen auf den <strong>Native Segwit</strong> Adresstyp, damit alle deine Coins auf diesem Konto versichert sind.",
  uncoveredFundsLink: "Folge dieser Anleitung für das Verschieben deiner Coins.",
  warning: "Warnung!"
};
const accountInfo$g = {
  address: "Adresse",
  buyCTA: {
    buy: "{{unit}} kaufen",
    buyCrypto: "Krypto kaufen",
    information: {
      looksEmpty: "Sieht so aus, als wäre dieses Wallet leer.",
      start: "Lege los, indem du einige Coins auf das Wallet einzahlst oder direkt in der BitBoxApp kaufst."
    }
  },
  extendedPublicKey: "Erweiterter Public Key",
  label: "Konto Informationen",
  scriptType: "Script-Typ",
  title: "Konto Informationen",
  verify: "Auf Gerät bestätigen",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy-P2PKH erweiterten Public Key anzeigen",
    p2tr: "Taproot anzeigen",
    p2wpkh: "Native Segwit anzeigen",
    "p2wpkh-p2sh": "Älteren Segwit erweiterten öffentlichen Schlüssel anzeigen"
  },
  xpubTypeInfo: "Derzeit wird der {{scriptType}} erweiterte Public Key angezeigt ({{current}} von {{numberOfXPubs}})"
};
const accountSummary$g = {
  availableBalance: "Kontostand",
  balance: "Saldo",
  exportSummary: "Kontozusammenfassung als CSV Datei zum Download Ordner exportieren",
  fiatBalance: "Fiat Kontostand",
  name: "Konto Name",
  noAccount: "Keine Konten verfügbar",
  subtotalWithCoinName: "Summe ({{coinName}})",
  title: "Kontenübersicht",
  total: "Gesamt",
  transactionHistory: "Transaktionsübersicht"
};
const addAccount$h = {
  chooseName: {
    nextButton: "Konto hinzufügen",
    step: "Konto benennen",
    title: "Benenne dein Konto"
  },
  selectCoin: {
    nextButton: "Weiter",
    step: "Coin wählen",
    title: "Kryptowährung wählen"
  },
  success: {
    addAnotherAccount: "Neues Konto hinzufügen",
    message: "<strong>{{accountName}}</strong> wurde zu deinen Konten hinzugefügt.",
    nextButton: "Fertig",
    step: "Erledigt",
    title: "Konto hinzugefügt"
  },
  title: "Konto hinzufügen"
};
const aopp$a = {
  addressRequest: "{{host}} fordert eine Empfangsadresse an.",
  addressRequestWithLogo: "fordert eine Empfangsadresse an",
  banner: "Adressanfrage in Bearbeitung. Bitte verbinde dein Gerät um fortzufahren.",
  errorTitle: "Fehler während Adressanfrage",
  labelAddress: "Adresse",
  labelMessage: "Nachricht",
  reverifyInfoText: "Adresse überprüfen",
  signing: "Signiere die Nachricht auf deiner BitBox um fortzufahren",
  success: {
    message: "Weiter auf {{host}}",
    title: "Adresse erfolgreich übermittelt"
  },
  syncing: "Konto wird synchronisiert, bitte warten.",
  title: "Adressanfrage"
};
const app$g = {
  upgrade: "Eine neue Version der App ist verfügbar! Bitte aktualisiere von {{current}} auf {{version}}."
};
const auth$a = {
  authButton: "Authentifizieren",
  title: "Bitte authentifiziere dich, um fortzufahren"
};
const backup$g = {
  check: {
    checking: "Backup wird geprüft…",
    confirmTitle: "Backup überprüfen",
    notOK: "Dein Backup entspricht NICHT deiner aktuellen Wallet.",
    ok: "Erfolg! Dein Backup entspricht deiner aktuellen Wallet.",
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Wiederherstellungspasswort",
      showLabel: "Wiederherstellungspasswort"
    },
    success: "Backup erfolgreich überprüft:",
    title: "Backup überprüfen"
  },
  create: {
    alreadyExists: "Du hast schon ein gültiges Backup. Willst du trotzdem ein weiteres Backup erstellen?",
    fail: "Erstellung des Backups FEHLGESCHLAGEN!",
    info: "Bitte gib dein Wiederherstellungspasswort ein, um deine aktuelle Wallet zu verifizieren.",
    name: {
      label: "Backup Name",
      placeholder: "Bitte benenne dein Backup."
    },
    password: {
      label: "Wiederherstellungspasswort",
      placeholder: "Bitte gib dein Wiederherstellungspasswort ein."
    },
    title: "Backup erstellen",
    verificationFailed: "Das Wiederherstellungspasswort entspricht NICHT der aktuellen Wallet. Das Backup wurde erstellt. Bitte nutze „Backup prüfen“ um dein Wiederherstellungspasswort erneut zu überprüfen. "
  },
  description: "Wähle eine  <strong>Wallet Backup</strong> Datei aus.",
  insert: "Bitte stecke die Micro-SD-Karte ein um deine Backups zu verwalten.",
  insertButton: "Ich habe die Mikro-SD-Karte eingesteckt.",
  list: "Deine Backups auf der microSD Karte",
  noBackups: "Es befinden sich keine Backups auf der microSD Karte.",
  restore: {
    confirmTitle: "Von Backup wiederherstellen",
    error: {
      e200: "microSD Karte nicht gefunden",
      general: "Fehler beim Wiederherstellen von Backup"
    },
    password: {
      label: "Wiederherstellungspasswort oder verstecktes Wiederherstellungspasswort. ",
      placeholder: "Wiederherstellungspasswort",
      repeatPlaceholder: "Wiederherstellungspasswort erneut eingeben",
      showLabel: "Wiederherstellungspasswort"
    },
    restoring: "Wiederherstellen des Backups…",
    selectedBackup: "<strong>{{backupName}}</strong>, erstellt am {{createdDateTime}}, wird wiederhergestellt.",
    title: "Wiederherstellen",
    understand: "Ich habe verstanden, dass ein falsches Wiederherstellungspasswort eine neue/andere Wallet erstellt."
  },
  showMnemonic: {
    description: "Dir werden Wiederherstellungswörter angezeigt, die ein Backup deiner Wallet sind. Schreibe diese auf ein Stück Papier. \n\n<strong>Bewahre diese Wörter nicht digital auf und mache kein Foto von ihnen.</strong>\n\n<strong>Sprich die Wörter nicht laut aus.</strong>\n\n<strong>Dieses Backup ist nicht Passwort geschützt.</strong>\n\nNachdem du die Wörter aufgeschrieben hast wirst du gefragt werden sie nochmals zu bestätigen.\n",
    title: "Recovery-Wörter anzeigen",
    warning: "<strong>Teile deine Wiederherstellungswörter niemals mit irgendjemandem.</strong> Deine Wiederherstellungswörter ermöglichen vollen Zugriff zu deinem Wallet . Wenn dich jemand nach deinen Wiederherstellungswörtern fragt, handelt es sich um einen Betrüger. Gebe diese nicht weiter!"
  },
  title: "Backups verwalten"
};
const bb02Bootloader$g = {
  abort: "Nicht upgraden - Zurück!",
  abort_noUpgrade: "Zurück",
  advanced: {
    label: "Erweiterte Einstellungen",
    toggleShowFirmwareHash: "Zeig mir den Hash der Firmware bei jedem Anstecken der BitBox"
  },
  flipscreen: "Bildschirm spiegeln",
  orientation: "Ist der Bildschirm kopfüber?",
  success: "Upgrade erfolgreich. In {{rebootSeconds}}  geht es weiter....",
  success_install: "Installation erfolgreich! Es geht weiter in {{rebootSeconds}} Sekunden..."
};
const bitbox$g = {
  error: {
    e10000: "Aktuelles Gerätepasswort ist falsch.",
    e10001: "Fehler beim Ändern des Gerätepassworts",
    e102: "Das Passwort muss aus 4 Zeichen bestehen.",
    e112: "Das versteckte Gerätepasswort und das normale Gerätepasswort können nicht identisch sein."
  }
};
const bitbox02Interact$g = {
  confirmDate: "Bestätige das heutige Datum auf deiner BitBox02",
  confirmDateText: "Dieses Datum wird mit deinem Backup gespeichert. ",
  confirmName: "Bestätige den Namen auf deiner BitBox02",
  confirmWords: "Notiere die {{amount}} Wiederherstellungswörter von deiner BitBox02",
  confirmWordsText: "Danach fordert dich die BitBox02 auf, jedes Wort zu bestätigen, um zu überprüfen, ob dein Backup korrekt ist.",
  followInstructions: "Bitte folge den Anweisungen auf deiner BitBox02.",
  followInstructionsMnemonic: "Bitte folge den Anweisungen auf deiner BitBox02 um deine Wallet mit deinen Wiederherstellungswörtern wieder herzustellen.",
  followInstructionsMnemonicTitle: "Mit Wiederherstellungs-Wörtern wiederherstellen"
};
const bitbox02Settings$g = {
  deviceName: {
    current: "Aktueller Gerätename",
    error: "Gerätename konnte nicht festgelegt werden",
    error_104: "Die Bestätigung des Gerätenamens wurde auf dem Gerät abgebrochen.",
    input: "BitBox02 Name",
    placeholder: "Neuer Gerätename",
    title: "BitBox02 Namen einstellen"
  },
  gotoStartupSettings: {
    description: "Dadurch wird deine BitBox02 neu gestartet und die Starteinstellungen angezeigt.",
    title: "Gehe zu den Starteinstellungen"
  }
};
const bitbox02Wizard$g = {
  advanced: {
    button: "Erweiterte Optionen",
    outOfDate: "Die Firmware ist für diese Funktion zu veraltet",
    seed12WordInfo: "Bitte beachte, dass die Anzahl der Wörter nach dem Erstellen des Wallets nicht mehr geändert werden kann.",
    seed12WordLabel: "Erstelle einen Seed mit 12 Wörtern statt mit 24 Wörtern",
    seed12WordText: "Standardmäßig verwendet die BitBox02 einen 24-Wörter-Seed. Beide Seed-Längen sind in der Praxis sicher gegen Brute-Forcing. Einige Benutzer bevorzugen möglicherweise die Bequemlichkeit eines 12-Wörter-Seeds.",
    skipSDCardLabel: "Überspringe die Sicherung auf der MicroSD-Karte und notiere stattdessen die Wiederherstellungswörter",
    skipSDCardText: "Du hast jederzeit die Möglichkeit, nach der Einrichtung ein Backup auf der MicroSD-Karte zu erstellen und deine Wiederherstellungswörter aufzuschreiben. Dies kannst über die Einstellungen tun.",
    title: "Erweiterte Backup-Optionen"
  },
  attestationFailed: "Echtheitsprüfung fehlgeschlagen. Bitte stecke die BitBox aus und wieder ein.  Bitte kontaktiere support@bitbox.swiss, falls dieses Problem weiterhin besteht.",
  backup: {
    point1: "Wähle ein Backup von der microSD Karte aus",
    point2: "Setze ein Passwort für dein Gerät",
    restoreText: "Ok, lass uns deine Wallet von deinem Backup wiederherstellen!",
    text1: "Perfekt, dein BitBox02 Passwort ist jetzt festgelegt und deine Wallet wurde erstellt. Jetzt ist es Zeit ein Backup der Wallet zu erstellen. Bitte stelle dazu sicher, dass die microSD Karte eingesteckt ist. ",
    text2: 'Sobald du "Backup erstellen" geklickt hast folge bitte den Anweisungen auf deiner BitBox um ein Backup zu erstellen. ',
    text3: "Nachdem das Backup erstellt wurde, bewahre die microSD-Karte bitte an einem <strong>sicheren Ort auf und stecke die microSD-Karte niemals in ein anderes Gerät, das nicht eine BitBox ist. </strong> Das Backup auf der microSD-Karte ist nicht Passwort-geschützt!",
    userConfirmation1: "Ich muss mein Backup an einem sicheren Ort aufbewahren.",
    userConfirmation2: "Mein Backup ist nicht passwortgeschützt. Jeder, der Zugriff darauf hat, kann auf meine Wallet zugreifen.",
    userConfirmation3: "Wenn ich meine BitBox02 verliere oder beschädige, ist die Wiederherstellung von meinem Backup der einzige Weg wieder Zugriff auf mein Guthaben zu bekommen. ",
    userConfirmation4: "Sollte ich sowohl meine BitBox02 als auch mein Backup verlieren oder zerstören ist der Zugang zu meinen Coins für immer verloren. ",
    userConfirmation5: "Ich darf meine microSD Karte nicht in einen Computer, Handy, Drucker oder anderes (nicht BitBox02) Gerät stecken. ",
    userConfirmation5mnemonic: "Ich sollte meine Wiederherstellungswörter nicht in einen Computer, ein Telefon, einen Drucker oder irgendein anderes Gerät als eine BitBox02 stecken."
  },
  create: {
    button: "Gerät bennenen & weiter",
    info: "Hier sind die Schritte, die wir dazu durchlaufen werden:",
    inputTitle: "Wallet Name ",
    point1: "Gerät benennen",
    point2: "Gerätepasswort einstellen",
    point3: "Backup erstellen",
    text: "Ok, lass uns eine neue Wallet erstellen!"
  },
  createBackupAborted: "Backup-Erstellung abgebrochen.",
  createBackupFailed: "Erstellung des Backups fehlgeschlagen, erneut versuchen.",
  initialize: {
    passwordText: "Lass uns nun ein Passwort für deine BitBox festlegen. Schaue dir die Animation unten an und benutze dann die Touch Slider auf den Seiten deiner BitBox, um ein Passwort einzugeben. ",
    passwordTitle: "Setze ein Passwort für deine BitBox",
    text: "BitBox02 erfolgreich gekoppelt. Jetzt initialisieren wir deine BitBox02. Wähle zuerst aus, ob du eine neue Wallet erstellen oder von einem Backup wieder herstellen möchtest.  <strong>Wenn du von einem Backup wieder herstellen möchtest, stelle sicher, dass deine microSD Karte in deiner BitBox02 eingesteckt ist.</strong>",
    tip: "Bitte fahre in einer sichern Umgebung fort. ",
    title: "Initialisiere deine BitBox"
  },
  insertSDCard: "<strong>Bitte stelle sicher, dass du die microSD Karte in der BitBox02 eingesteckt hast.</strong>",
  noPasswordMatch: "Passwörter stimmen nicht überein. Bitte versuche es erneut.",
  pairing: {
    failed: "Kopplungscode nicht bestätigt. Bitte BitBox02 aus und wieder ein stecken.",
    paired: "Kopplungscode bestätigt. Bitte fahre fort.",
    title: "Kopplungscode bestätigen",
    unpaired: "Eine nicht gekoppelte BitBox02 wurde erkannt. Bitte bestätige, dass der Kopplungscode mit dem auf der BitBox02 übereinstimmt. "
  },
  restoreFromMnemonic: {
    e104: "Die Wiederherstellung durch Wiederherstellungswörter wurde abgebrochen.",
    failed: "Wiederherstellung von Wiederherstellungswörtern fehlgeschlagen. Bitte versuche es erneut."
  },
  stepBackup: {
    beforeProceed: "Bevor du fortfährst, lies bitte die folgenden wichtigen Sicherheitsaspekte:",
    createBackup: "Du erstellst jetzt ein Backup auf deiner microSD-Karte.",
    createBackupMnemonic: "Du wirst nun die Wiederherstellungswörter notieren."
  },
  stepBackupSuccess: {
    fundsSafe: "Beachte bitte Folgendes, um deine Coins zu schützen:",
    title: "Backup wiederhergestellt!"
  },
  stepConnected: {
    unlock: "BitBox02 Passwort eingeben "
  },
  stepCreate: {
    description: "Dieser Name wird als Gerätename und für das Backup verwendet.",
    error: {
      genericMessage: "Verwende Buchstaben, Zahlen, einfache Symbole und Leerzeichen. Max. 30 Zeichen.",
      invalidChars: "Der Name enthält ungültige Zeichen: {{invalidChars}}.",
      tooLong: "Name ist zu lang."
    },
    nameLabel: "BitBox02 Name",
    namePlaceholder: "Meine BitBox02",
    title: "Wähle BitBox02 Name",
    toastMicroSD: "Bitte stelle sicher, dass deine microSD Karte in die BitBox02 eingesteckt ist. "
  },
  stepCreateSuccess: {
    removeMicroSD: "Bitte entnehme deine microSD Karte und bewahre diese an einem sicheren Ort auf.",
    storeMnemonic: "Bitte bewahre deine Wiederherstellungs-Wörter an einem sicheren Ort auf.",
    success: "Dein Backup wurde erfolgreich erstellt."
  },
  stepInsertSD: {
    insertSDCard: "Bitte stecke die microSD Karte in deine BitBox02 um fortzufahren",
    insertSDcardTitle: "MicroSD Karte einstecken"
  },
  stepPassword: {
    e104: "Das Festlegen des Passworts wurde abgebrochen.",
    title: "BitBox02 Passwort wählen",
    useControls: "Verwende die Touch Sensoren an den Seiten deiner BitBox02 um ein Passwort zu wählen."
  },
  stepUninitialized: {
    create: "Ich möchte eine neue BitBox02 einrichten.",
    restore: "Ich möchte meine Wallet von einem Backup wiederherstellen.",
    restoreMicroSD: "Von microSD Karte wiederherstellen",
    restoreMnemonic: "Von Wiederherstellungswörtern wiederherstellen",
    title: "BitBox02 einrichten"
  },
  success: {
    text: "Hurra! Deine BitBox02 ist bereit.\n\nFür weitere Informationen klicke auf das Fragezeichen Symbol in der oberen rechten Ecke. ",
    title: "Es kann los gehen!"
  }
};
const bitsurance$9 = {
  dashboard: {
    active: "Versicherungsvertrag aktiv",
    button: "Versichere ein neues Konto",
    canceled: "Abgebrochen",
    coverage: "Maximale Abdeckung",
    inactive: "Inaktiv",
    processing: "In Bearbeitung",
    refused: "Abgelehnt",
    supportLink: "Vertrag verwalten",
    title: "Versicherte Konten",
    waitpayment: "Warte auf Zahlung"
  },
  detect: {
    button: "Prüfe auf bestehende Versicherungen",
    insured: "Versichertes Konto entdeckt:",
    notInsured: "Keine versicherten Konten gefunden. Wenn du sicher bist, dass du ein versichertes Konto hast, vergewissere dich bitte, dass du die richtige Wallet verbunden hast.",
    text: "Wenn du bereits bei Bitsurance angemeldet bist, kann die BitBoxApp deinen bestehenden Versicherungsschutz automatisch synchronisieren.",
    title: "Bereits versichert?"
  },
  insure: {
    button: "Verfügbarkeit und Preis prüfen",
    faq: "Lese mehr in den Bitsurance FAQs",
    listItem1: "Diebstahl",
    listItem2: 'Erpressung (bspw. "$5 wrench attack")',
    listItem3: "Zerstörung durch Feuer, Wasser oder Naturkatastrophen",
    month: "Monat",
    text: "Versichere deine BitBox02 und Bitcoin im Wert von bis zu 100.000 € gegen",
    text2: "Versicherungs-Pläne beginnen ab 30 €/Jahr (2,50 €/Monat). Mehr über Bitsurance und ihre genauen Versicherungsangebote erfährst du auf der",
    text3: "Derzeit in Deutschland verfügbar, weitere Regionen werden folgen.",
    title: "Los geht's"
  },
  intro: {
    link: "Bitsurance Website",
    text1: "Die BitBox arbeitet mit Bitsurance zusammen, um deinen Bitcoin zusätzlich zu schützen. Während die BitBox02 dein Guthaben schützt, deckt Bitsurance Bedrohungen zu Hause ab, die mit Technologie alleine nicht abgewehrt werden können, wie z.B. Einbruch, Erpressung oder die Zerstörung der Hardware-Wallet selbst."
  },
  terms: {
    link: "Bitsurance Datenschutzrichtlinie",
    text1: "Bitsurance ist ein unabhängiger Service von Dritten. Bei Fragen zu ihren Angeboten und Versicherungsansprüchen wende dich bitte direkt an Bitsurance.",
    text2: "Versicherung ist derzeit in Deutschland verfügbar, weitere Regionen werden folgen.",
    text3: "Die maximale Bitcoin-Absicherung liegt derzeit bei 100.000 € pro Person. Für die Zukunft sind höhere Beträge geplant.",
    text4: "Persönliche Informationen und der erweiterte öffentliche Schlüssel deines versicherten Kontos sind Teil der Versicherungspolice und werden mit Bitsurance und dem Versicherungsanbieter geteilt.",
    text5: "Weitere Informationen zum Datenschutz findest du in der"
  },
  title: "Versicherung"
};
const bitsuranceAccount$9 = {
  errorNoXpub: "Fehler: Es war nicht möglich, den xpub vom Konto zu erhalten.",
  noAccount: "Es gibt keine Konten, die versichert werden können.",
  select: "Konto wählen",
  title: "Versicherung"
};
const blink$g = {
  button: "Blinken"
};
const bootloader$g = {
  button: "Firmware jetzt aktualisieren",
  button_install: "Firmware jetzt installieren",
  progress: "Aktualisiere: {{progress}}%",
  progress_install: "Installation: {{progress}}%",
  success: "Aktualisierung erfolgreich! Bitte ziehe das Gerät ab und stecke es dann wieder ein. Dieses mal brauchst du den Knopf nicht zu berühren. "
};
const button$l = {
  abort: "Abbrechen",
  back: "Zurück",
  buy: "Kaufen",
  changepin: "Gerätepasswort ändern",
  check: "Backup überprüfen",
  "continue": "Weiter",
  copy: "Kopieren",
  create: "Erstellen",
  dismiss: "Ausblenden",
  done: "Fertig",
  download: "Herunterladen",
  hiddenwallet: "Versteckte Wallet erstellen",
  next: "Weiter",
  ok: "OK",
  previous: "Zurück",
  receive: "Erhalten",
  restore: "Wiederherstellen",
  select: "Auswählen",
  send: "Senden",
  unlock: "Entsperren",
  update: "Update",
  upgrade: "Aktualisieren"
};
const buy$c = {
  exchange: {
    bankTransfer: "Überweisung",
    bestDeal: "Bestes Angebot",
    creditCard: "Kreditkarte",
    fast: "Schnell",
    fee: "Gebühr",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Banküberweisung: {{fee}}%",
          creditDebitCard: "Kredit-/Debitkarte: {{fee}}%",
          learnMore: "Erfahre mehr über Moonpay",
          title: "Gebühren"
        },
        fullCurrenciesList: "Eine vollständige Liste der Währungen findest du hier",
        payment: {
          asteriskText: "* Nicht verfügbar für Einwohner der USA",
          bankTransfer: "Banküberweisung*",
          bankTransferDetails: {
            pix: "PIX (BR-Transaktionen nur in Brasilien)",
            sepa: "SEPA und SEPA Instant (EUR-Transaktionen nur in SEPA-Ländern)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Großbritannien)"
          },
          creditDebitCard: "Kredit-/Debitkarte",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa und Maestro"
          },
          learnMore: "Weitere Details zu den Zahlungsmethoden findest du hier",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Unterstützt alle gängigen Fiat-Währungen: USD, EUR, CHF und mehr."
      },
      pocket: {
        fees: {
          info: "Banküberweisung: {{fee}}%",
          title: "Gebühren"
        },
        learnMore: "Erfahre mehr über Pocket",
        payment: {
          bankTransfer: "Banküberweisung",
          bankTransferDetails: {
            sepa: "SEPA und SEPA Echtzeit (EUR-Transaktionen nur in SEPA-Ländern)",
            sic: "Swiss Interbank Clearing (CHF-Transaktionen nur in CH/LI)",
            uk: "UK Faster Payments (GBP-Transaktionen nur in Großbritannien)"
          },
          bankTransferReccuring: "Wie richte ich wiederkehrende Käufe mit einem Dauerauftrag ein?",
          title: "Zahlungsmethoden"
        },
        supportedCurrencies: "Unterstützt europäische Währungen: EUR, GBP und CHF.",
        verification: {
          info: "Identitätsprüfung nur bei Überschreitung der täglichen und jährlichen Schwellenwerte nötig.",
          link: "Aktuelle Schwellenwerte hier einsehen",
          title: "Identitätsprüfung"
        }
      },
      region: {
        title: "Wähle die Region aus, in der dein Bankkonto registriert ist, um zu sehen, welche Optionen dir zur Verfügung stehen."
      }
    },
    noExchanges: "Leider sind in dieser Region keine Börsen verfügbar.",
    region: "Region",
    selectRegion: "Nicht angegeben",
    title: "{{name}} kaufen "
  },
  info: {
    "continue": "Zustimmen und fortfahren",
    crypto: "Krypto",
    disclaimer: {
      intro: [
        "Wir arbeiten mit MoonPay zusammen, damit du mit nur ein paar Klicks ganz einfach {{name}} direkt in der BitBoxApp kaufen kannst. ",
        "MoonPay ist eine vollständig regulierte Finanzdienstleistungsplattform, die den Kauf von {{name}} in über 160 Ländern einfach und schnell macht."
      ],
      payment: {
        details: "Du kannst {{name}} über MoonPay mit den folgenden Zahlungsmethoden kaufen. Mit Kredit- oder Debitkarten geht es sofort und bequem, ist aber aufgrund des erhöhten Rückbuchungsrisikos teurer. Wir empfehlen die Verwendung der Überweisungsoption für größere Beträge. Die Mindestgebühr beträgt 4 USD / EUR oder gleichwertig.",
        footnote: "Bitte beachte, dass die Wechselkurse von MoonPay von den in der BitBoxApp verwendeten abweichen können, was zu geringfügig unterschiedlichen Beträgen führen kann.",
        table: {
          "1_description": "Niedrigste Gebühren, kann bis zu 3 Werktage dauern",
          "1_method": "Banküberweisungen (SEPA)",
          "2_description": "Höhere Gebühren, aber schnell und sofort",
          "2_method": "Kredit & Debitkarten",
          description: "Beschreibung",
          fee: "Gebühr",
          method: "Methode"
        },
        title: "Zahlungsmethoden und Gebühren"
      },
      privacyPolicy: "MoonPay-Datenschutzrichtlinie",
      protection: {
        description: "Die BitBoxApp sammelt beim Kauf von {{name}} keine Daten. Die eingehenden Transaktionen werden wie reguläre Transaktion behandelt. MoonPay muss einige persönliche Daten sammeln, um funktionieren zu können. In deren Datenschutzbestimmungen wird ausführlich erläutert, wie mit diesen Daten umgegangen wird.",
        descriptionGeneric: "Die BitBoxApp erhebt beim Kauf von {{name}} keinerlei Daten, die eingehenden Gelder werden wie eine normale Transaktion behandelt. Partnerbörsen müssen jedoch einige Informationen sammeln, um zu funktionieren. Einzelheiten zum Umgang mit Daten kannst du der jeweiligen Datenschutzerklärung entnehmen.",
        title: "Datenschutz"
      },
      security: {
        description: "Wenn du {{name}} über MoonPay kaufst, dann nutzt du einen externen Dienst. Dieser Dienst liegt außerhalb des Anwendungsbereichs des BitBox02 Sicherheitsbedrohungsmodells und verlässt sich auf die Sicherheit des Geräts, auf dem die BitBoxApp Software läuft.",
        descriptionGeneric: "Wenn du {{name}} über eine Partnerbörse kaufst, nutzt du einen externen Dienst. Dieser Dienst liegt außerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hängt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgeführt wird.",
        link: "Sicherheitsbedrohungsmodells",
        title: "Sicherheitsmodell"
      },
      title: "Willkommen in deinem One-Stop-Shop zum Kauf von {{name}}"
    },
    next: "Weiter",
    selectLabel: "Konto wählen",
    selectPlaceholder: "Wähle einen Coin",
    skip: "Nicht mehr anzeigen",
    title: "{{name}} kaufen "
  },
  pocket: {
    data: {
      link: "Pocket-Datenschutzrichtlinie",
      p1: "Die BitBoxApp sammelt beim Kauf von Bitcoin keine Daten. Die eingehenden Gelder werden wie eine reguläre Transaktion behandelt. Pocket muss einige personenbezogene Daten sammeln, um zu agieren. Ihre Datenschutzrichtlinie erklärt im Detail, wie diese Daten verwendet werden.",
      title: "Datenschutz"
    },
    kyc: {
      link: "Pocket-FAQ lesen",
      p1: "Pocket versucht, KYC auf ein Minimum zu beschränken. Für Einkäufe unter 950 EUR (1000 CHF) pro Tag sind keine zusätzlichen Dokumente erforderlich. Für Käufe über diesem Betrag musst du einen Anruf bei Pocket vereinbaren, um den erforderlichen KYC/AML-Prozess abzuschließen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Du kannst Bitcoin sofort mit Pocket per SEPA-Überweisung kaufen. Die Gebühr beträgt 1,5 % und die Bitcoin werden so schnell wie möglich nach Eingang der Banküberweisung bei Pocket (normalerweise am selben Tag) auf deiner BitBox hinterlegt.",
      p2: "Bitte beachte, dass die Wechselkurse von Pocket von denen in der BitBoxApp abweichen können, was zu leicht unterschiedlichen Beträgen führen kann.",
      title: "Zahlungsmethoden und Gebühren"
    },
    previousTransactions: "Der Transaktionsverlauf dieses Kontos ist nicht leer. Durch die gemeinsame Nutzung dieses Kontos werden alle vergangenen und zukünftigen Transaktionen für Pocket sichtbar. Dennoch fortfahren?",
    security: {
      link: "BitBox02 Bedrohungsmodell",
      p1: "Wenn du Bitcoin über Pocket kaufst, verwendest du einen externen Dienst. Dieser Dienst liegt außerhalb des Geltungsbereichs des BitBox02-Sicherheitsbedrohungsmodells und hängt von der Sicherheit der Umgebung ab, in der die BitBoxApp-Software ausgeführt wird. Wir arbeiten jedoch zusammen, um die Sicherheit zu verbessern, indem wir einen Zwei-Faktor-Authentifizierungsmechanismus verwenden, um deine Empfangs-Adresse zu überprüfen.",
      title: "Sicherheitsmodell"
    },
    usedAddress: "Die Adresse {{address}} wurde bereits verwendet. Bitte beginne erneut mit einer neuen Adresse.",
    verifyBitBox02: "Bitte vergewissere dich, dass die Adresse, die du per E-Mail erhalten hast, mit der auf deiner Bitbox angezeigten übereinstimmt. Wenn möglich, solltest du die E-Mail zur besseren Sicherheit auf einem zweiten Gerät öffnen.",
    welcome: {
      p1: "Wir arbeiten mit Pocket zusammen, um dir eine nahtlose Möglichkeit zu bieten, Bitcoins direkt in der BitBoxApp zu kaufen. Es sind nur ein paar Klicks.",
      p2: "Pocket ist eine schweizer Plattform, mit der man fast in ganz Europa schnell und einfach Bitcoin kaufen kann (überall dort, wo SEPA-Banküberweisungen unterstützt werden).",
      p3: "Mit Pocket kannst du auch Sparpläne über Daueraufträge betreiben, sodass du mit Leichtigkeit DCA (Dollar-Cost-Average) durchführen kannst.",
      title: "Willkommen in deinem One-Stop-Shop für den Kauf von Bitcoin"
    }
  },
  title: "{{name}} kaufen"
};
const changePin$g = {
  newTitle: "Neues Gerätepasswort",
  oldLabel: "Aktuelles Gerätepasswort"
};
const chart$c = {
  dataMissing: "Historische Daten werden gesammelt... gleich fertig.",
  dataOldTimestamp: "Historische Wechselkurse werden aktualisiert. Das Diagramm zeigt nach {{time}} keine Daten mehr an.",
  dataUpdating: "Daten aktualisieren…",
  filter: {
    all: "Alles",
    month: "Monat",
    week: "Woche",
    year: "Jahr"
  }
};
const checkSDcard$g = "Micro-SD-Karte wird überprüft";
const clickHere$g = "Hier klicken.";
const confirm$i = {
  abortInfo: "Tippe zum ",
  abortInfoRedText: "abbrechen",
  approveInfo: "4 Sekunden lang halten um zu ",
  approveInfoGreenText: "bestätigen",
  info: "Fahre auf deiner BitBox fort.",
  infoWhenPaired: "Zuerst auf deinem gepaarten Mobiltelefon und dann auf deiner BitBox"
};
const confirmOnDevice$g = "Bitte bestätige auf deinem Gerät.";
const connectKeystore$a = {
  promptNoName: "Bitte verbinde deine BitBox02 um fortzufahren",
  promptWithName: 'Bitte verbinde deine BitBox02 mit dem Namen „{{name}}" um fortzufahren'
};
const darkmode$a = {
  toggle: "Dark mode"
};
const device$g = {
  appUpradeRequired: "Deine BitBox ist mit dieser Desktopanwendung nicht kompatibel. Bitte lade die neueste Version herunter und installiere diese..",
  keystoreConnected: "Verbundene Wallet"
};
const deviceLock$g = {
  button: "Zwei-Faktor-Autorisierung (2FA) aktivieren",
  condition1: "Hast du ein Backup?",
  condition2: "Funktioniert die Verifikation auf deinem Smartphone?",
  condition3: 'Wenn du 2FA aktivierst wird "Backups verwalten", "Versteckte Wallet erstellen" und "Mit Smartphone App" koppeln deaktiviert. Um 2FA zu deaktivieren muss das Gerät auf Werkseinstellungen zurück gesetzt werden.   ',
  confirm: "Zwei-Faktor Authentifizierung (2FA) aktivieren\n",
  title: "Zwei-Faktor-Autorisierung (2FA) aktivieren"
};
const deviceSettings$g = {
  backups: {
    manageBackups: {
      description: "Erstelle oder überprüfe das MicroSD-Karten-Backup."
    },
    showRecoveryWords: {
      description: "Zeige und überprüfe die Wiederherstellungswörter."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "Die BitBoxApp prüft, ob dein Gerät authentisch ist."
    },
    deviceName: {
      description: "Ändere den Namen deines Geräts."
    },
    rootFingerprint: {
      description: "Der Root-Fingerabdruck ist eine eindeutige Kennung für das aktuell verwendete Wallet. Es kann dir helfen, zwischen verschiedenen Wallets zu unterscheiden, falls du Passphrasen verwendest."
    },
    securechip: {
      description: "Das Modell des Secure-Chips."
    },
    title: "Geräteinformationen"
  },
  expert: {
    factoryReset: {
      description: "Setze dein Gerät auf die Werkseinstellungen zurück. Dadurch wird das Wallet auf deiner BitBox02 gelöscht!",
      title: "Auf Werkseinstellungen zurücksetzen"
    },
    goToStartupSettings: {
      description: "Den Bootloader der BitBox02 starten. Dort kannst du den Firmware-Hash aktivieren."
    },
    passphrase: {
      description: "Aktiviere oder deaktiviere die Passphrasen-Funktion.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Verfügbare Version"
    },
    title: "Firmware",
    upToDate: "Dein Gerät ist auf dem aktuellen Stand  ",
    upgradeAvailable: "Neues Upgrade verfügbar",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "Echtheitscheck fehlgeschlagen",
      label: "Echtheitsprüfung",
      "true": "Deine BitBox02 ist echt"
    },
    sdcard: {
      "false": "Nicht eingesteckt",
      label: "microSD Karte",
      "true": "Eingesteckt"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Geräteinformationen werden abgerufen...\n\n",
  pairing: {
    lock: {
      "false": "Deaktiviert",
      label: "Zwei-Faktor Autorisierung (2FA)",
      "true": "Eingeschaltet"
    },
    mobile: {
      "false": "Geschlossen",
      label: "Smartphone App",
      "true": "Offen"
    },
    status: {
      "false": "Nicht gekoppelt",
      label: "Status",
      "true": "Gekoppelt"
    },
    title: "Zwei-Faktor Autorisierung (2FA)"
  },
  secrets: {
    manageBackups: "Backups verwalten",
    title: "Sicherheit"
  }
};
const deviceTampered$g = "Falls deine BitBox mit einem Wiederherstellungspasswort geliefert wurde, beende das Setup SOFORT und kontaktiere den Support. \nSHIFT versendet niemals BitBoxen, die schon ein Passwort haben und wird nie Passwortempfehlungen aussprechen. \nBenutze diese BitBox auf keinen Fall !";
const dialog$h = {
  cancel: "Abbrechen",
  confirm: "Bestätigen",
  confirmTitle: "Bestätigung"
};
const error$c = {
  accountAlreadyExists: "Dieses Konto existiert bereits.",
  accountLimitReached: "Konto kann nicht hinzugefügt werden. Die maximale Kontenanzahl für diese Währung wurde erreicht.",
  aoppCallback: "Beim Übermitteln der Adresse an {{host}} ist ein Fehler aufgetreten.",
  aoppInvalidRequest: "Ungültige Anfrage.",
  aoppNoAccounts: "Es sind keine Konten verfügbar.",
  aoppSigningAborted: "Adressinhaberanfrage wurde abgebrochen.",
  aoppUnknown: "Ein unbekannter Fehler ist aufgetreten.",
  aoppUnsupportedAsset: "Diese Kryptowährung wird nicht unterstützt.",
  aoppUnsupportedFormat: "Es sind keine Konten verfügbar, die das angeforderte Adressformat unterstützen.",
  aoppUnsupportedKeystore: "Das verbundene Gerät kann keine Nachrichten für diese Kryptowährung signieren.",
  aoppVersion: "Unbekannte Version.",
  keystoreTimeout: "Die Wallet-Anfrage ist abgelaufen. Bitte versuche es erneut.",
  wrongKeystore: "Falsches Wallet verbunden. Bitte verbinde das richtige Gerät, zu dem diese Konto gehört.",
  wrongKeystore2: "Falls du ein optionale Passphrase nutzt, stelle sicher, dass du die richtige Passphrase für dieses Konto eingegeben hast."
};
const fiat$i = {
  "default": "Standard",
  setDefault: "{{code}} als Standard speichern\n",
  title: "Währungen"
};
const footer$i = {
  appVersion: "App Version:"
};
const generic$c = {
  enabled_false: "Deaktiviert",
  enabled_true: "Aktiviert"
};
const genericError$g = "Ein Fehler ist aufgetreten. Falls du Probleme bemerkst, starte die Applikation bitte neu.";
const goal$g = {
  buttons: {
    create: "Neue Wallet erstellen",
    restore: "Wallet von Backup wiederherstellen "
  },
  paragraph: "Bitte wähle eine der folgenden Optionen:",
  step: {
    "1": {
      title: "Sicherheitsinformationen"
    },
    "2": {
      description: "Passwort",
      title: "Gerät"
    },
    "3-create": {
      description: "Neue Wallet erstellen",
      title: "Wallet"
    },
    "3-restore": {
      description: "von einem Backup",
      title: "Wiederherstellen"
    },
    "4-create": {
      title: "Zusammenfassung"
    },
    "4-restore": {
      title: "Zusammenfassung"
    }
  }
};
const guide$h = {
  accountDescription: {
    text: "Deine Kontoübersicht zeigt deinen Kontostand und deine Transaktionen an. Stöbere durch diesen Guide um mehr über die verschiedenen Kontoarten zu erfahren. ",
    title: "Was wird mir auf dieser Seite angezeigt?"
  },
  accountFiat: {
    text: "Ja, du kannst auf das Währungssymbol klicken, um zwischen den verschiedenen Währungen zu wechseln. Die verfügbaren Währungen kannst du in den Einstellungen anpassen.",
    title: "Können auch andere Wechselkurse angezeigt werden?"
  },
  accountIncomingBalance: {
    text: "Eingehend summiert alle eingehenden Transaktionen, die noch nicht bestätigt sind. ",
    title: 'Was bedeutet "Eingehend"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Jeder xpub ist an den angezeigten "Typ" gebunden: Entweder "Native SegWit (bech32)", "Wrapped segwit" oder "Taproot". Dies sind Skripttypen, die von {{coinName}} verwendet werden. Die BitBoxApp kombiniert sie und unterstützt mehrere Skripttypen im selben Konto. Da jeder Skripttyp einen anderen xpub verwendet, gibt es mehrere xpubs pro Konto.\n\nWenn du nur auf den Standardadressen empfängst, benötigst du nur den "bech32" xpub. Wenn du jedoch auch Coins auf "kompatible Adresse" erhältst, werden diese auf dem xpub "wrapped SegWit" angezeigt.',
      title: "Warum gibt es mehrere xpubs?"
    },
    privacy: {
      text: "Für dieses Konto zeigt der erweiterte öffentliche Schlüssel die gesamte Transaktionshistorie, deinen Kontostand und alle zukünftigen Transaktionen an. Aber der xpub erlaubt niemandem, deine Coins auszugeben.\n\nWenn du jemandem ein xpub gibst, solltest du dir bewusst sein, dass diese Person oder Firma alle anderen Transaktionen desselben Kontos sehen kann. Daher ist es eine gute Idee, dieses Konto nur für diesen Zweck zu verwenden und andere Coins in anderen Konten zu halten.",
      title: "Muss ich mein xpub geheim halten?"
    },
    verify: {
      text: "Ja, es ist immer eine gute Idee, deinen xpub zu überprüfen. Wenn jemand anderes Empfangsadressen von diesem xpub generiert, um dir Coins zu senden, ist dies besonders wichtig. Du musst ihn auf deiner BitBox überprüfen, um sicherzustellen, dass dieser xpub dir gehört. Andernfalls könnten alle Coins an die falschen Adressen gehen.",
      title: "Muss ich den xpub auf dem Gerät überprüfen?"
    },
    xpub: {
      text: "Ein erweiterter öffentlicher Schlüssel (xpub) ist ein Stammschlüssel, von dem alle Empfängeradressen eines Kontos abgeleitet werden.\n\nEr wird hier für die erweiterte Nutzung und die Interoperabilität mit Watch-Only-Wallets wie Electrum oder Sentinel bereitgestellt. Wenn du auf verschiedene Adresstypen empfängst, importiere bitte alle verschiedenen xpub-Formate in die Watch-only-Wallet, damit du alle deine Coins sehen kannst.\n\nBitte beachte, dass Wallets von Drittanbietern Taproot xpubs möglicherweise noch nicht unterstützen.\n",
      title: "Was ist ein erweiterter Public Key?"
    }
  },
  accountRates: {
    text: "Die Wechselkurse werden minütlich von CoinGecko aktualisiert.",
    title: "Welche Wechselkurse werden benutzt?"
  },
  accountReload: {
    text: "Das ist nicht nötig. Alle Transaktionsinformationen werden automatisch aktualisiert. ",
    title: "Wie kann ich die Transaktionshistorie erneut laden?"
  },
  accountSendDisabled: {
    text: 'Der "Senden" Knopf wird aktiviert, wenn dein Guthaben größer als Null ist.',
    title: "Warum kann ich keine {{unit}} senden?"
  },
  accountSummaryAmount: {
    text: "Der Gesamtbetrag ist die Summe aller deiner Kryptokonten. Die Wechselkurse werden von coingecko.com abgerufen.\n\nHinweis: Wenn du MyEtherWallet für Token verwendest, die in der BitBoxApp nicht unterstützt werden, dann sind diese nicht in dem angezeigten Gesamtbetrag einberechnet.",
    title: "Wie berechnet sich der Gesamtbetrag?"
  },
  accountSummaryDescription: {
    text: "Hier kannst du die Entwicklung deines Portfolios im Laufe der Zeit sehen. Eine Übersicht über deine einzelnen Krypto-Konten wird unter dem Diagramm angezeigt.",
    title: "Was kann ich auf dieser Seite sehen?"
  },
  accountTransactionAttributesBTC: {
    text: 'Virtuelle Größe: Wird zur Ermittlung der Netzwerkgebühr verwendet. Du hast erfolgreich Gebühren gespart, wenn sie kleiner als die Transaktion sind.\nGröße: Aktuelle Transaktionsgröße in Bytes nach der Serialisierung gemäß der zugrunde liegenden Blockchain.\nGewicht: Mit Segwit eingeführt, ist dies eine neue Metrik zur Bewertung von Transaktions- und Blockgrößen. Jedes Segwit Byte zählt als eins, alles andere als vier "Gewichtseinheiten". Statt eines Megabytes, beträgt die Blockgrößenbegrenzung nun vier Millionen "Gewichtseinheiten".',
    title: "Was hat es mit den Bitcoin-spezifischen Transaktionsdetails  auf sich?"
  },
  accountTransactionAttributesGeneric: {
    text: 'Bestätigungen: Nachdem du deine Transaktion gesendet hast ist diese zuerst unbestätigt. Du musst warten, bis sie von einem Miner in einen Block aufgenommen wird. Dann hat deine Transaktion die erste Bestätigung. Jeder nachfolgende Block fügt deiner Transaktion eine weitere Bestätigung hinzu. Meist sehen Händler und andere Netzwerkakteure Transaktionen erst mit 3 bis 6 Bestätigungen als erledigt.\nTransaktions-ID: Eine eindeutige Identifikationsnummer, die zum Nachschlagen einer Transaktion in einem Blockexplorer verwendet werden kann.\nGebühr: Miner erhalten eine Transaktionsgebühr als Anreiz, Transaktionen in die von ihnen erzeugten Blöcke aufzunehmen. Um mehr zu erfahren, klicke auf  "Senden".',
    title: "Welche Informationen werden in den Transaktionsdetails angezeigt?"
  },
  accountTransactionConfirmation: {
    text: "Dies ist eine Transaktionen die ins Netzwerk geschickt wurde und darauf wartet bestätigt zu werden.",
    title: "Was ist eine ausstehende Transaktion?"
  },
  accountTransactionLabel: {
    text: "Es ist die Adresse an die du Coins erhalten oder geschickt hast.",
    title: "Welche Adresse wird bei jeder Transaktion angezeigt?"
  },
  accountTransactionTime: {
    text: "Der Zeitpunkt, zu dem die Transaktion in der Blockchain bestätigt wurde.",
    title: "Welche Zeit wird angezeigt?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin und Litecoin können eine beliebige Anzahl an Konten haben. Nach fünf Konten kannst du nur dann ein weiteres Konto hinzufügen, wenn das vorherige Konto verwendet wurde.\nAndere Coins können maximal fünf Konten haben.",
      title: "Wie viele Konten kann ich erstellen?"
    },
    howtoAddTokens: {
      text: 'ERC-20 Token sind an ein bestimmtes Ethereum-Konto gebunden. Um einen Token zu aktivieren oder zu deaktivieren, gehe zu "Konten verwalten", klicke auf das Ethereum-Konto und schalte den gewünschten Token ein oder aus.',
      title: "Wie kann ich zusätzliche Token hinzufügen?"
    },
    moveFunds: {
      text: "Ja. Da Konten jedoch eigenständig sind, müssen Coins mit einer reguläre Transaktion zwischen den Konten verschoben werden.",
      title: "Kann ich Geld zwischen Konten verschieben?"
    },
    recoverAccounts: {
      text: "Ja. Die BitBoxApp erstellt Konten nach bewährten Standards, die mit den meisten Krypto-Wallets kompatibel sind.",
      title: "Kann ich meine Konten in anderen Wallets wiederherstellen?"
    },
    whatAreAccounts: {
      text: "Deine Wallet kann mehrere Konten derselben Währung verwalten. Konten machen es einfach, Coins separiert zu halten.",
      title: "Was sind Konten?"
    },
    whatIsRememberWallet: {
      text: "Durch die Aktivierung von „Wallet merken“ kannst du die Konten von diesem Wallet in der BitBoxApp sehen, auch wenn die BitBox02 nicht verbunden ist. So kannst du deinen Kontostand und dein Portfolio jederzeit überprüfen. Zum Senden oder Empfangen von Coins muss die BitBox02 jedoch eingesteckt und entsperrt werden.\n\nWenn du „Wallet merken“ deaktivierst, musst du die BitBox02 (oder Passphrase-Wallet) verbinden, um diese Konten in der BitBoxApp zu sehen.",
      title: "Was passiert, wenn ich „Wallet merken“ aktiviere/deaktiviere?"
    },
    whyIsThisUseful: {
      text: 'Separate Konten eignen sich hervorragend für die Verwaltung von Coins für verschiedene Personen oder Zwecke. Du kannst auch den "erweiterten öffentlichen Schlüssel" (extended public key) eines Kontos freigeben, ohne etwas über deine anderen Konten preiszugeben. Auf diese Weise kannst du wiederholt Geld erhalten, ohne Adressen wiederzuverwenden, z. B. um deinen Lohn zu erhalten oder um regelmäßig Krypto zu kaufen.',
      title: "Warum ist das nützlich?"
    }
  },
  appendix: {
    link: "Kontaktiere uns!",
    text: "Du hast Fragen?"
  },
  backups: {
    check: {
      text: 'Mit "Check Backup" kannst du überprüfen, ob du über ein gültiges Backup für deine aktuelle Wallet verfügst. Es kann auch verwendet werden, um zu überprüfen, ob du das korrekte Wiederherstellungspasswort kennst.',
      title: 'Was bedeutet "Check Backup"?'
    },
    encrypt: {
      text: "Nein, aber dein Wiederherstellungspasswort wird benötigt, um deine Wallet aus dem gespeicherten Seed zu erzeugen.",
      title: "Kann ich mein Backup verschlüsseln?"
    },
    howOften: {
      text: "Das Backup wird automatisch erstellt, wenn eine neue Wallet erstellt wird. Du musst nur dann ein neues Backup erstellen, wenn deine microSD-Karte verloren ist, beschädigt wurde oder wenn du dein Backup auf mehreren microSD Karten speichern willst.\nDu musst nach der Transaktionsaktivität keine neuen Backups erstellen. Alle deine Transaktionsdaten können durch ein einzelnes Backup, das automatisch für dich erstellt wurde, wiederhergestellt werden.",
      title: "Wie oft muss ich ein Backup erstellen?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie des Seed auf einer microSD-Karte. Der Seed zusammen mit deinem Wiederherstellungspasswort stellen dein Wallet wieder her.",
      title: "Was ist ein Backup?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Backup überprüfen" checkt, dass sich auf deiner microSD Karte ein gütiges Backup zu deiner aktuell verwendeten Wallet befindet.',
      title: 'Was bedeutet "Backup überprüfen"?'
    },
    encrypt: {
      text: 'Nein. Bitte bewahre deine microSD-Karte sicher auf, da sie den unverschlüsseltes Seed enthält, der zur Wiederherstellung deiner Wallet benötigt wird. Falls du dein Backup mit einem Passwort schützen willst, aktiviere die "Optionale Passphrase" in den Geräteeinstellungen.',
      title: "Kann ich das Backup verschlüsseln?"
    },
    whatIsABackup: {
      text: "Es ist eine Kopie deines Seeds auf deiner microSD Karte.",
      title: "Was ist das Backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: 'Wenn 2FA aktiviert ist, müssen alle Transaktionen auf dem gekoppelten Mobiltelefon genehmigt werden, um Coins zu versenden. Unter der Haube: Eine verschlüsselte einmalige Nummer wird an die App gesendet, dort wird sie entschlüsselt und beim Drücken der Schaltfläche "Akzeptieren" zur BitBox zurückgegeben. Diese Kommunikation mit der BitBox erfolgt über den Kanal zwischen dem Mobiltelefon und dieser Desktop-App, der während des Pairings eingerichtet wurde.  \n\nStelle sicher, dass du ein Backup deiner Wallet erstellst und die App verbindest, bevor du 2FA aktivierst. Nach der Aktivierung werden der Mikro-SD Kartenslot und das Mobile-App-Pairing deaktiviert. Du kannst es nur erneut aktivieren, indem du die BitBox zurücksetzt, wodurch das Gerät gelöscht wird.',
      title: "Wie funktioniert die Zwei-Faktor-Autorisierung (2FA)?"
    },
    disable2FA: {
      text: `Um 2FA zu deaktivieren, musst du deine BitBox zurücksetzen und anschließend deine Wallet von deinem Backup wiederherstellen. Stelle sicher, dass du deine MicroSD-Karte mit deinem Backup hast und du das Wiederherstellungspasswort kennst. Dann drücke 'Reset Device'. Lege ein neues Gerätekennwort fest und wähle "Backup wiederherstellen". Wähle Backup aus und klicke auf "Wiederherstellen". Dann gib dein Wiederherstellungskennwort ein, das du beim Erstellen der Wallet verwendet hast.`,
      title: "Wie schalte ich die Zwei-Faktor-Autorisierung (2FA) aus?"
    },
    ejectBitbox: {
      text: "Du kannst deine BitBox einfach aus dem Computer ziehen ohne sie vorher auszuwerfen.",
      title: "Wie werfe ich meine BitBox aus?"
    },
    ejectSD: {
      text: "Du kannst die Micro SD Karte jederzeit aus der BitBox entfernen, solange du nicht dabei bist, ein Backup zu erstellen oder zu überprüfen",
      title: "Wie kann ich die Micro-SD-Karte auswerfen?"
    },
    hiddenWallet: {
      text: "Es ist eine sekundäre Wallet, auf der selben BitBox, das mit einem anderen Passwort geschützt ist. Dies erlaubt dir, einem Erpresser ein anderes Wallet zu öffnen, in welchem sich nur eine geringe Menge Coins befindet. Info: Für beide Wallets, normal und versteckt, wird der selbe Seed verwendet, somit muss kein weiteres Backup erzeugt werden",
      title: "Was ist eine versteckte Wallet?"
    },
    legacyHiddenWallet: {
      text: "Klicke zunächst auf den Knopf unten (dazu muss die BitBox mit dem Hauptgerätekennwort entsperrt sein und 2FA deaktiviert sein), schließe dann deine Bitbox an und entsperre diese mit deinem versteckten Gerätekennwort.",
      title: "Wie greife ich auf die versteckte Wallet des Legacy Kontos zu?"
    },
    pairing: {
      text: "Nachdem du unsere mobile App für iOS oder Android heruntergeladen hast, scanne den angezeigten QR-Code. Dadurch wird ein sicherer Kanal zwischen der mobilen App und dieser Anwendung eingerichtet. Befolge nach dem Scannen die Anweisungen in der Smartphone App.",
      title: "So, koppelst du dein Telefon sicher mit der BitBox"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Bitte besuche Bitsurance’s Website und deren FAQ für mehr Details.",
      title: "Weitere Fragen?"
    },
    privacy: {
      link: {
        text: "Bitsurance Datenschutzrichtlinie"
      },
      text: "Wie jede reguläre Versicherungspolice enthält sie deinen vollständigen Namen und deine Adresse und gibt das versicherte Objekt an (definiert durch den erweiterten öffentlichen Schlüssel des versicherten Bitcoin-Kontos). Diese Daten werden direkt an Bitsurance übermittelt und nicht mit Shift Crypto geteilt. Weitere Informationen findest du in den Datenschutzbestimmungen von Bitsurance",
      title: "Welche persönlichen Informationen werden für die Versicherung benötigt?"
    },
    renew: {
      text: 'Die Versicherung wird automatisch für das nächste Jahr verlängert. Du kannst die Verlängerung jederzeit kündigen, indem du in der BitBoxApp auf "Vertrag verwalten" klickst, wodurch du zum Bitsurance-Kundenportal gelangst.',
      title: "Wie kann ich die Versicherung verlängern oder kündigen?"
    },
    status: {
      text: "Erfolgreich versicherte Konten sind auf jeder Bitcoin-Kontoseite in der oberen linken Ecke mit einem grünen „versicherten“ Abzeichen gekennzeichnet. Im Bereich „Versicherung“ siehst du die Übersicht aller versicherten Bitcoin-Konten und dem aktuellen Versicherungsstatus. Die Aktualisierung des Versicherungsstatus kann bis zu 48 Stunden dauern.",
      title: "Kann ich den Status eines versicherten Kontos überprüfen?"
    },
    what: {
      text: 'Jeder Bitcoin-Versicherungsvertrag deckt ein bestimmtes Wallet-Konto ab. Du kannst mehrere Konten versichern, indem du mehrere Versicherungsverträge abschließt. Versicherte Konten dürfen nur "Native Segwit"-Bitcoin-Adressen verwenden.',
      title: "Ist die gesamte BitBox Wallet versichert?"
    },
    who: {
      text: "Die Versicherung wird von Bitsurance angeboten, einem Versicherungsmakler, der von Bitcoinern gegründet wurde. Sie arbeiten mit dem ELEMENT Versicherer zusammen, um Bitcoin-Versicherungen anzubieten. Beide Unternehmen sind in Deutschland ansässig.",
      title: "Wer versichert meine Bitcoin?"
    },
    why: {
      text: "Bitsurance deckt einige Risiken der Selbstverwahrung ab, die selbst bei der sichersten Wallet nicht abgedeckt werden können, z. B. Einbruch, Erpressung oder Zerstörung der Wallet. Es ist deine persönliche Entscheidung, ob du einen Versicherungsschutz für diese Risiken brauchst.",
      title: "Brauche ich eine Bitcoin-Versicherung?"
    }
  },
  cointracking: {
    text: 'Klicke auf "Exportieren" und öffne den Download-Ordner. Dort findest du die exportierte CSV Datei. Klicke dann auf den untenstehenden Link, lade deine BitBox-CSV-Datei hoch und importiere die Daten, um sie für deinen CoinTracking-Portfoliomanager zu verwenden und deine Steuerberichte zu erstellen.',
    title: "Wie importiere ich meine Transaktionen in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lese mehr über den Echtheitscheck"
      },
      text: "Die BitBoxApp führt eine Überprüfung der BitBox02 durch, um festzustellen, ob das Gerät echt ist. Die Prüfung wird lokal durchgeführt und stellt keine Verbindung zu unseren Servern her.",
      title: "Wie funktioniert die Echtheitsprüfung?"
    },
    name: {
      text: "Dies ist der Name deiner Wallet und deines Backups. Der Name wird für zukünftige Backups verwendet und kann dazu dienen, verschiedene Wallets zu unterscheiden. Er kann jederzeit geändert werden, aber beachte, dass Backups, die vor der Änderung erstellt wurden, weiterhin den vorherigen Namen verwenden.",
      title: "Wofür wird der BitBox02-Name verwendet?"
    },
    "secure-chip": {
      link: {
        text: "Lese mehr über den Secure-Chip"
      },
      text: "Diese Information zeigt die Modellnummer des Sicherheitschips. Der aktuellste Chip ist der ATECC608B mit verbesserten Sicherheitsfunktionen im Vergleich zu älteren Modellen.",
      title: "Warum das Modell des Secure-Chips anzeigen?"
    }
  },
  receive: {
    address: {
      text: "Du kannst die Adresse an andere weitergeben, damit sie dir Coins schicken können. Achte darauf, dass sie an die richtige Adresse schicken.",
      title: "Was mache ich mit einer Adresse?"
    },
    addressChange: {
      text: "Sobald eine Adresse für eine Transaktion benutzt wurde, wird eine neue Adresse zu der Liste hinzugefügt um die Alte zu ersetzen. Es werden immer 20 ungenutzte Adressen angezeigt. ",
      title: "Wann ändern sich die Adressen?"
    },
    addressFormats: {
      text: "Standardmäßig ist der Adresstyp Native Segwit. Dieser Adresstyp wird von vielen anderen Wallets/Börsen akzeptiert und bietet dir die besten Gebührensätze für alltägliche Transaktionen. Du kannst aber auch an Taproot (nur Bitcoin) senden, den neuesten Adresstyp, der aber noch nicht überall unterstützt wird. Wenn du Probleme hast, an Native Segwit (den Standard-Adresstyp) zu senden, kannst du auch auf den älteren Wrapped Segwit-Adresstyp umsteigen, der möglicherweise mit mehr Wallets/Börsen kompatibel ist.",
      title: "Wann sollte ich den Adresstyp ändern?"
    },
    howVerify: {
      text: 'BitBox01: Klicke auf das BitBox-Symbol in der Seitenleiste links und siehe dir den Abschnitt "Zwei-Faktor Autorisierung" an. Die Anleitung wird aktualisiert und du kannst von dort aus den Anweisungen folgen.\n\nBitBox02: Dank des eingebauten Displays kannst du die Adresse direkt auf dem Gerät während des Send-/Empfangsprozesses verifizieren. ',
      title: "Wie kann ich die Adresse sicher verifizieren?"
    },
    plugout: {
      text: "Nein, sobald du die Adresse auf dem Display bestätigt und kopiert hast, musst du deine BitBox nicht mehr eingesteckt haben. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox während des Empfangs eingesteckt lassen?"
    },
    why20: {
      text: 'Die BitBoxApp generiert automatisch eine gewisse Anzahl an Adressen, die von deinem Seed abgeleitet werden. Sie überprüft dann, ob diese Adressen schon Coins erhalten haben. Die App kann theoretisch eine nahezu unbegrenzte Anzahl von Adressen generieren, wodurch es Jahre dauern würde, bis dein Kontostand ermittelt ist. Um diese Suche einzuschränken stoppt die App diesen Prozess, nachdem sie 20 Adressen generiert hat, die noch nie Coins erhalten haben. Dies wird "gap-limit" genannt und 20 ist ein der de-facto-Standard. Deswegen siehst du immer nur 20 Adressen, aus denen du auswählen kannst. ',
      title: "Warum werden nur 20 Adressen angezeigt?"
    },
    whyMany: {
      text: "Aus Gründen des Datenschutzes und der Sicherheit solltest du niemals dieselbe Empfangsadresse zweimal verwenden. Klicke auf 'Weiter', um eine neue Adresse zu erhalten. Du kannst bis zu 20 Adressen gleichzeitig generieren. Alle Adressen werden von deinem Backup abgeleitet. (Stell dir Adressen wie Rechnungsnummern vor.)",
      title: "Warum gibt es mehrere Adressen?"
    },
    whyVerify: {
      text: "Einer der Gründe für den Kauf einer Hardwarewallet, ist dass du deinem Computer aufgrund der großen Angriffsfläche nicht vertrauen solltest. Daher solltest du nicht darauf vertrauen, dass dein Computer authentische Adressen generiert und anzeigt. \nBitbox01: Mit dem Knopf zur sicheren Überprüfung der Adresse sendet die BitBox01 die Adresse an ein gekoppeltes Mobiltelefon, auf welchem du die Adresse  überprüfen kannst. \nBitBox02: Die BitBox02 hat ein eingebautes Display, auf dem die Adresse sicher angezeigt werden kann. ",
      title: "Warum sollte ich die Adresse verifizieren?"
    }
  },
  send: {
    change: {
      text: "Der Change wird an eine Taproot-Adresse gesendet, wenn du mindestens eine Taproot UTXO besitzt. Wenn du Coin-Control verwendest, wird der Change an eine Taproot-Adresse gesendet, wenn mindestens eine der ausgewählten UTXOs eine Taproot-UTXO ist. In allen anderen Fällen wird der Change an eine Native-Segwit-Adresse gesendet. ",
      title: "Wie wird der Change-Output bestimmt?"
    },
    fee: {
      text: "Die Gebühr basiert auf der Transaktionsdatengröße und nicht auf dem Transaktionsbetrag. Die Gebühren werden durch den Gebührenschätzungsalgorithmus von Bitcoin Core für jede von dir gewählte Netzwerkpriorität berechnet. Sie werden explizit angezeigt, wenn du einen anderen Wert als die unten stehenden Ziele haben.\nEconomy: 24 Blöcke (ca. 4 Stunden für Bitcoin, 1 Stunde für Litecoin)\nNiedrig: 12 Blöcke (etwa 2 Stunden für Bitcoin, 30 Minuten für Litecoin)\nNormal: 6 Blöcke (ca. 1 Stunde für Bitcoin, 15 Minuten für Litecoin)\nHoch: 2 Blöcke (ca. 20 Minuten für Bitcoin, 5 Minuten für Litecoin)\n(Ein Block benötigt durchschnittlich zehn Minuten für Bitcoin (2,5 Minuten für Litecoin)), und die Netzwerklast kann in den oben genannten Zeiträumen erheblich variieren.)",
      title: "Wie wird die Gebühr ermittelt?"
    },
    plugout: {
      text: "Nein, nachdem du eine Transaktion durchgeführt hast, musst du deine BitBox nicht eingesteckt lassen. Du kannst die BitBox problemlos vom Computer trennen.",
      title: "Muss ich meine BitBox beim Senden eingesteckt lassen?"
    },
    priority: {
      text: "Je höher die Gebühr ist, die du bereit bist zu zahlen, desto schneller wird deine Transaktion vom Netzwerk bestätigt. ",
      title: "Was ist Netzwerk Priorität?"
    },
    revert: {
      text: "Sobald eine Transaktion signiert und gesendet (d.h. An das Netzwerk gesendet) wurde, kann sie nicht mehr rückgängig gemacht werden. Überprüfe die Transaktionen (einschließlich der Gebühr) deswegen, bevor du die Transaktion bestätigst!\nWenn du den Empfänger kennst und dieser bereit ist, denselben Betrag (abzüglich der Transaktionsgebühren) an dich zurückzuschicken, kannst du ihm eine neue Empfängeradresse senden.",
      title: "Kann ich eine Transaktion rückgängig machen?"
    },
    whyFee: {
      text: 'Transaktionen stehen im Wettbewerb, um von einem Miner bestätigt zu werden. Die Miner wählen Transaktionen, die in die Blockchain aufgenommen werden sollen, basierend auf ihrer Gebühr aus. Miner bevorzugen Transaktionen mit höheren Gebühren. Deswegen wird eine Transaktion die bereit ist, eine höhere Gebühr zu bezahlen auch schneller in einem Block aufgenommen. \nDa es keinen Mittelsmann gibt, der eine Regelung, wie eine Stimme pro Person erzwingen kann, stimmen die Miner über Transaktionen ab, indem sie eine kostspielige Ressource, wie Rechenleistung opfern. Als Belohnung dafür erhalten sie neu erstellte Coins und die Gebühren der Transaktionen in dem von ihnen "gemineten" Block (english: to mine a Block) .',
      title: "Warum gibt es eine Netzwerk Gebühr?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Wenn du nur dann eine Verbindung zu deinem Full Node herstellen möchtest, wenn du dich im selben Netzwerk befindest (z. B. in deinem Heim-WLAN), ist die Verwendung einer regulären Netzwerkkommunikation ausreichend.\nIn diesem Fall ist es ratsam, dass dein Electrum-Server ein TLS-Zertifikat zum Verschlüsseln der Kommunikation bereitstellt.\nWenn du von überall aus eine Verbindung zu deinem Full Node herstellen möchtest, ist die Verwendung von Tor die bessere Option. In diesem Fall ist kein TLS-Zertifikat erforderlich.",
      title: "Soll ich Clearnet TCP, TLS oder Tor verwenden?"
    },
    instructions: {
      link: {
        text: "Anleitung zum Verbinden deines Full Nodes"
      },
      text: "Für eine vollständiges Anleitung, besuche bitte unseren Guide:",
      title: "Wie verbinde ich meine BitBoxApp mit meinem Full Node?"
    },
    options: {
      text: "Es gibt mehrere Möglichkeiten, einen eigenen Full Node zu betreiben, z. B. ein fertiges Gerät zu kaufen, einen eigenen zu bauen oder Bitcoin Core auszuführen.\nWenn du deine BitBoxApp mit deinem Full Node verbinden möchtest, stelle sicher, dass dieser einen Electrum-Server bereitstellt. Dies ist ein spezielles Programm, mit dem eine Wallet-App mit deinem Full Node kommunizieren kann.\nUnterstützte Optionen sind Electrs, Electrum Personal Server (EPS) oder Bitcoin Wallet Tracker (BTW).",
      title: "Welche Optionen gibt es, um einen Full Node zu betreiben?"
    },
    tor: {
      text: 'Tor steht für "The Onion Router", eine kostenlose Open-Source-Software, die viele Datenschutzvorteile bietet und besonders bei der Verwendung von Bitcoin nützlich ist.\nWenn du über Tor eine Verbindung zu deinem Full Node herstellen möchtest, stelle sicher, dass Tor auf deinem Computer installiert ist, und aktiviere dann den Tor-Proxy in den BitBoxApp-Einstellungen.\nAuf den meisten Betriebssystemen gibt es zwei Möglichkeiten, Tor auszuführen:\n1. Tor Browser: Lade den Tor Browser herunter und öffne ihn. Dadurch kann die BitBoxApp eine Verbindung zum Tor-Netzwerk herstellen, indem Port 9150 in den Tor-Proxy-Einstellungen festgelegt wird.\n2. Tor-Hintergrunddienst: Installiere den Tor-Daemon, der immer im Hintergrund ausgeführt wird. Die BitBoxApp kann dann eine Verbindung herstellen, indem Port 9050 in den Tor-Proxy-Einstellungen festgelegt wird.',
      title: "Was ist Tor, Tor-Proxy und welchen Port soll ich verwenden?"
    },
    what: {
      text: "Es ist möglich, deine Wallet mit einem eigenen Fullnode zu betreiben, anstatt den Shift-Server zu verwenden.",
      title: "Was ist das?"
    },
    why: {
      text: "Einen eigenen Full Node zu betreiben ist nicht erforderlich. Er verbessert jedoch deine Privatsphäre und verringert die Notwendigkeit, anderen Netzwerkteilnehmern zu vertrauen.\nZum einen erlaubt er dir Bitcoin privater verwenden, da die BitBoxApp dann keine Verbindung zu unseren Servern herstellt, um deinen Transaktionsverlauf abzurufen. Stattdessen werden diese Informationen von deinem eigenen Full Node abgerufen.\nDes Weiteren, verifiziert dein Full Node alle Transaktionen selbst, wodurch sichergestellt wird, dass die Konsensregeln eingehalten werden. ",
      title: "Warum sollte ich meinen eigenen Full Node betreiben?"
    }
  },
  settings: {
    sats: {
      text: 'Ein Satoshi (kurz "sat") ist die kleinste Einheit eines Bitcoins. Ein Satoshi ist ein Hundertmillionstel eines Bitcoins (0,00000001 BTC). Benannt ist er nach dem Erfinder von Bitcoin, Satoshi Nakamoto.',
      title: "Was ist ein Satoshi?"
    },
    servers: {
      text: "Diese App kommuniziert mit Servern von Shift Crypto, um nach Updates zu suchen, Transaktionen zu laden und Informationen an verbundene Smartphone Apps zu senden.\nAußerdem werden die neuesten Wechselkurse von CoinGecko abgerufen. (Die Conversions werden lokal berechnet, es werden keine Beträge von dir übertragen.)\nInfo: Für Ethereum und ERC-20 tokens verwenden wir die Etherscan.io APIs.",
      title: "Mit welchen Servern kommuniziert die Applikation?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Guide schließen",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Bewege auf dem Desktop den Mauszeiger über das Diagramm. Halte auf Mobilgeräten deinen Finger auf dem Diagramm und ziehe ihn horizontal.",
    title: "Wie kann man historische Werte auf dem Chart sehen?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Du musst das Gerät zurücksetzen und die Wallet mithilfe des Wiederherstellungskennworts aus deinem Backup wiederherstellen.",
      title: "Was mache ich, wenn ich mein Passwort vergessen habe?"
    },
    reset: {
      text: "Gib 15 Mal ein falsches Gerätekennwort ein. Die letzten Versuche erfordern eine lange Berührung des Geräts.",
      title: "Wie stelle ich mein Gerät wieder her?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Das Gerät sollte beim Einstecken einmal blinken. Stelle sicher, dass es richtig herum eingesetzt ist. Bei Problemen kontaktiere uns bitte über den untenstehenden Link.",
      title: "Meine BitBox01 wurde nicht erkannt"
    },
    getDevice: {
      link: {
        text: "Bestellen einer BitBox"
      },
      text: "Du kannst eine BitBox in unserem Online Shop bestellen:",
      title: "Wie bekomme ich ein Gerät?"
    },
    internet: {
      text: "Ja, eine Internetverbindung ist erforderlich, um die Wallet zu synchronisieren, Transaktionen zu senden und die neuesten Wechselkurse abzurufen.",
      title: "Braucht diese Applikation eine Internet Verbindung?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Du kannst deine Konten auf einer neuen BitBox oder in unserem Backup-center wiederherstellen.",
      title: "Ich habe mein Gerät verloren. Was nun?"
    },
    useWithoutDevice: {
      text: "Leider ist dies zum aktuellen Zeitpunkt nicht möglich. ",
      title: "Kann ich die App auch ohne Gerät benutzen?"
    },
    welcome: {
      text: "Vielen Dank, dass du diese App benutzt. Sie wird von Shift Crypto in der Schweiz entwickelt. Wir freuen uns über Anregungen und Fragen. Zögere nicht, uns zu kontaktieren.",
      title: "Willkommen in der BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Wenn du ein neues Telefon/Computer mit der BitBoxApp verwendest, musst du dich erneut mit den DApps verbinden. Anschließend siehst du deine Coins wieder wie gewohnt auf der DApp.",
      title: "Ich sehe meine vorherigen Verbindungen nicht."
    },
    supportedNetworks: {
      text: "Derzeit wird nur das Ethereum-Mainnet mit WalletConnect in der BitBoxApp unterstützt. Um andere EVM-kompatible Netzwerke zu verwenden, verwende bitte das Rabby Browser-Extension Wallet.",
      title: "Welche Netzwerke werden unterstützt?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ist ein Kommunikationsprotokoll für Web3-Anwendungen. Damit kannst du bequem eine Verbindung zu Ethereum basierten DApps und Web-Wallets herstellen, ohne eine Drittanbieter-App zu verwenden. Dies ist besonders nützlich für Android Nutzer der BitBoxApp.",
      title: "Was ist WalletConnect?"
    }
  }
};
const headerssync$g = {
  blocksSynced: "{{blocks}} Blöcke synchronisiert\n"
};
const hiddenWallet$g = {
  info1HTML: "Zur glaubhaften Abstreitbarkeit kann eine versteckte Wallet erstellt werden, das auf einer <strong> anderen </strong> Geräte- und Wiederherstellungspasswort Kombination basiert.",
  info2HTML: "Gib das Gerätepasswort und das Wiederherstellungspasswort ein, die du für deine versteckte Wallet verwenden möchtest. Das Gerätepasswort und das Wiederherstellungspasswort müssen sich von <strong> denen unterscheiden </strong> , die du für dein primäres Wallet verwendest.",
  passwordLabel: "Versteckte Wallet Passwort",
  passwordPlaceholder: "Bitte bestätige das versteckte Wiederherstellungspasswort",
  pinLabel: "Verstecktes Gerätepasswort",
  pinRepeatLabel: "Wiederhole das versteckte Gerätepasswort",
  pinRepeatPlaceholder: "Bitte bestätige das versteckte Gerätepasswort",
  success: "Versteckte Wallet erfolgreich erstellt. Stecke die BitBox erneut ein und gib das versteckete Gerätepasswort ein, um diese zu entsperren."
};
const initialize$g = {
  create: "Gerätepasswort speichern",
  creating: "Gerätekennwort wird eingestellt...",
  error: {
    e102: "Das Gerätekennwort muss aus mindestens 4 Zeichen bestehen."
  },
  info: {
    description1: "Wähle dein Gerätekennwort. Dieses wird zum Entsperren deiner BitBox verwendet.",
    description2: "Du kannst Zahlen und Buchstaben verwenden. Längere Passwörter sind in der Regel sicherer.",
    description3: "Wenn du das Gerätepasswort vergisst, musst du dein Gerät zurücksetzen und deine Wallet von deinem Backup wiederherstellen.",
    subtitle: "Jetzt legst du dein Gerätepasswort fest",
    title: "Initialisierung deines Gerätes"
  },
  input: {
    label: "Gerätepasswort",
    labelRepeat: "Wiederhole das Gerätepasswort",
    placeholderRepeat: "Bitte bestätige das Gerätepasswort"
  }
};
const invalidFormat$g = "Ungültiges Format";
const language$h = {
  title: "Sprache auswählen"
};
const legacyhiddenwallet$g = {
  disable: "Versteckte Legacy Wallet deaktivieren",
  enable: "Versteckte Legacy Wallet aktivieren",
  successDisable: "Versteckte Legacy Wallet erfolgreich deaktiviert",
  successEnable: "Die versteckte legacy Wallet wurde erfolgreich aktiviert. Stecke deine BitBox erneut ein und gib das versteckte Gerätepasswort ein, um auf die versteckte Wallet zuzugreifen."
};
const loading$g = "laden...";
const manageAccounts$a = {
  accountHidden: "Dieses Konto wurde aus deinen watch-only Konten ausgeblendet. Verbinde deine BitBox02 um es wieder anzuzeigen.",
  editAccount: "Bearbeiten",
  editAccountNameTitle: "Kontonamen bearbeiten",
  noAccounts: "Keine Konten gefunden",
  settings: {
    hideTokens: "Token ausblenden",
    showTokens: "Token anzeigen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Konten hinzufügen und aktivieren / deaktivieren",
  title: "Konten verwalten",
  watchAccount: "Konto merken",
  watchAccountDescription: "Dieses Konto ist Teil deines watch-only Kontos. Du kannst es mit diesem Schalter vor den watch-only Konten verstecken."
};
const mobile$b = {
  usingMobileDataWarning: "Mobile Datennutzung: Diese App downloaded ein paar hundert Megabytes an Blockchain Daten nachdem ein Konto geöffnet wurde. Bitte verbinde dein Handy für diesen einmaligen Download mit deinem Wifi. "
};
const newSettings$9 = {
  about: {
    appVersion: {
      title: "App-Version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Sperre den Zugriff zur App mit Displaysperre/Fingerabdruck.",
      title: "Displaysperre"
    },
    coinControl: {
      description: "Wähle aus, welche UTXOs Teil einer Transaktion sind, um die Privatsphäre zu verbessern."
    },
    customFees: {
      description: "Ermöglicht es dir, beim Senden deine eigene Gebühr festzulegen."
    },
    torProxy: {
      description: "Stelle für mehr Privatsphäre eine Verbindung über Tor her."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Diese zusätzlichen Währungen können auf Ihrer Kontoseite eingeschaltet werden.",
      title: "Aktive Währungen"
    },
    darkmode: {
      description: "Aktiviere den dunklen Modus der BitBoxApp."
    },
    defaultCurrency: {
      description: "Wähle deine Standardwährung aus",
      title: "Standardwährung"
    },
    enableAccount: {
      description: "Wenn du dein Konto deaktivierst, wird es weder in der Seitenleiste noch im Portfolio angezeigt. Du kannst es jederzeit von hier aus wieder aktivieren. Die Coins auf diesem Konto sind davon nicht betroffen und bleiben sicher.",
      title: "Konto aktivieren/deaktivieren"
    },
    hideAmounts: {
      description: "Zeigt einen Schalter zum Ausblenden deines Guthabens und Beträgen an, um deine Privatsphäre zu verbessern, wenn du die App in der Öffentlichkeit nutzt.",
      hideAmounts: "Beträge ausblenden",
      showAmounts: "Beträge anzeigen",
      title: "Ausblenden von Beträgen zulassen"
    },
    language: {
      description: "Welche Sprache die BitBoxApp verwenden soll.",
      title: "Sprache"
    },
    remebmerWallet: {
      name: "Wallet merken",
      warning: "Dies wird dein gemerktes Wallet entfernen. Um es wieder zu sehen musst du die BitBox02 für dieses Wallet verbinden. Alle Coins auf diesem Wallet werden nicht beeinflusst. Möchtest du fortfahren?",
      warningTitle: 'Deaktiviere "Wallet merken"'
    },
    toggleSats: {
      description: "Aktiviere oder deaktiviere Satoshis."
    }
  }
};
const note$c = {
  input: {
    description: "(optional)",
    placeholder: "Notiz hinzufügen..."
  },
  title: "Notiz"
};
const notification$g = {
  newTxs_one: "Neue Transaktion in: {{accountName}}",
  newTxs_other: "{{count}} neue Transaktionen in: {{accountName}}"
};
const pairing$g = {
  aborted: {
    text: "Der Kopplungsprozess wurde von der Smartphone App abgebrochen.",
    title: "Abgebrochen"
  },
  button: "Mit Smartphone App koppeln",
  confirm: "Möchtest du deine BitBox wirklich koppeln? Danach wird dein Mobiltelefon zur Durchführung einer Transaktion unbedingt erforderlich sein.",
  connectOnly: {
    button: "Smartphone App verbinden",
    title: "Scanne den Code mit der Smartphone App. "
  },
  error: {
    text: "Etwas ist schief gelaufen. Bitte fang erneut an.",
    title: "Fehler"
  },
  pullFailed: {
    text: "Fehler beim Abrufen einer Nachricht von deinem Mobiltelefon über den Relay-Server. Der Relay-Server ist möglicherweise offline. Wende dich an den Support.",
    title: "Laden fehlgeschlagen"
  },
  reconnectOnly: {
    button: "Smartphone App erneut verbinden"
  },
  scanningFailed: {
    text: "Das Handy konnte die Nachricht nicht scannen. Bitte versuche es erneut.",
    title: "Scannen fehlgeschlagen"
  },
  start: {
    hideAppQRCode: "QR Code ausblenden",
    revealAppQRCode: "QR Code anzeigen",
    step1: "Wenn du nicht über die Smartphone App verfügst, kannst du den QR-Code für den Apple App Store oder den Google Play Store scannen.",
    step2: "Scanne den Code mit der Smartphone App, die du im App Stores für iOS und Android findst, wenn du nach 'Digital Bitbox 2FA' suchst."
  },
  started: {
    text: "Folge nun den Anweisungen in der mobilen App.",
    title: "Gut gemacht!"
  },
  success: {
    text: "Herzlichen Glückwunsch, du hast deine BitBox erfolgreich mit der mobilen App gekoppelt!",
    title: "Erfolg"
  },
  timeout: {
    text: "Der Kopplungsprozess ist nach 2 Minuten abgelaufen. Bitte versuche es erneut.",
    title: "Zeitüberschreitung"
  },
  title: "Smartphone Kopplung"
};
const passphrase$a = {
  considerations: {
    button: "Backup-Hinweise",
    message: "Die Passphrase bietet zusätzlichen Schutz für dein Wallet-Backup (MicroSD oder 24 Wörter). Falls jemand Zugriff auf dein Backup hat, benötigt er zusätzlich die Passphrase, um auf dein Wallet zuzugreifen. \n\nDies bedeutet jedoch, dass du <strong>sowohl die Passphrase als auch das Wallet Backup</strong> benötigst, um dein Passphrase-Wallet wiederherzustellen, falls deine BitBox02 verloren oder kaputt geht. Falls du die Passphrase verlierst, verlierst du auch Zugriff auf alle Coins in diesem Wallet.\n\nErwäge, deine Passphrase an einem anderen Ort als dein Backup zu sichern. Falls jemand dein Backup findet, fehlt ihm immer noch die Passphrase. ",
    title: "Backup-Hinweise"
  },
  disable: "Passphrase deaktivieren",
  disableInfo: {
    button: "Deaktivieren",
    message: "Nachdem du die Passphrase deaktiviert hast, wirst du nach dem Entsperren deiner BitBox02 nicht mehr aufgefordert, eine Passphrase einzugeben. Daher wirst du deine Standard-Wallet aufrufen.\n\nAlle Coins in deiner Passphrase-Wallet befinden sich weiterhin in dieser Wallet, aber du kannst nicht darauf zugreifen, weil du nach dem Entsperren deiner BitBox02 deine Standard-Wallet öffnest.\n\nUm wieder auf deine Passphrase-Wallet zuzugreifen, aktiviere einfach wieder die Passphrase-Funktion und gib die entsprechende Passphrase ein, nachdem du die BitBox02 entsperrt hast.\n\n<strong>Tipp:</strong> Du kannst deine ursprüngliche Wallet immer noch öffnen, indem du die Passphrase leer lässt."
  },
  enable: "Passphrase aktivieren",
  error: {
    e104: "Änderung der Passphrase-Einstellung wurde abgebrochen. "
  },
  how: {
    button: "So sieht es aus",
    message: "Eine Passphrase funktioniert nicht wie ein Passwort, wie du es kennst. Wenn du deine Passphrase falsch eingibst, wirst du nicht benachrichtigt. Das liegt daran, dass <strong>jede Passphrase eine andere, aber gültige Wallet</strong> erstellt. Das heißt, du kannst mehrere Passphrasen für so viele Wallets verwenden, wie du willst. Auf jede Wallet kannst du aber nur zugreifen, wenn du die entsprechende Passphrase eingibst.\n\nWenn du deine BitBox02 einsteckst, wirst du wie üblich nach dem Gerätepasswort gefragt. Danach wirst du aufgefordert, eine Passphrase auf dem Gerät einzugeben.\n\nNachdem du die Passphrase eingegeben hast, wird dir die eingegebene Passphrase angezeigt. So kannst du bestätigen, dass du sie richtig eingegeben hast.",
    title: "Wie funktioniert die Passphrase?"
  },
  intro: {
    message: "Eine Passphrase bietet zusätzliche Sicherheit für deine Wallet.\nHier erfährst du, wie sie funktioniert.",
    title: "Passphrase einrichten"
  },
  progressDisable: {
    message: "Bestätige auf deiner BitBox, dass du die optionale Passphrase <strong>deaktivieren</strong> möchtest.",
    title: "Bestätige am Gerät"
  },
  progressEnable: {
    message: "Bestätige auf deiner BitBox, dass du die optionale Passphrase <strong>aktivieren</strong> möchtest.",
    title: "Bestätige am Gerät"
  },
  successDisabled: {
    message: "Optionale Passphrase <strong>erfolgreich aktiviert</strong>!\nVon nun an wirst du dazu aufgefordert, eine Passphrase anzugeben.",
    messageEnd: "Bitte stecke die BitBox02 jetzt wieder ein.",
    title: "Passphrase aktiviert"
  },
  successEnabled: {
    message: "Optionale Passphrase <strong>erfolgreich deaktiviert</strong>!\nVon nun an wirst du nicht mehr dazu aufgefordert, eine Passphrase anzugeben.",
    messageEnd: "Bitte stecke deine BitBox02 jetzt wieder ein.",
    tips: "Tipps",
    tipsList: [
      "Wir empfehlen, zuerst einen kleinen Betrag in die Passphrase-Wallet zu senden. Dann musst du die BitBox02 aus- und wieder einstecken und dein Passwort und deine Passphrase eingeben. Wenn du die Passphrase richtig eingegeben hast, solltest du die Coins in deinem Wallet sehen.",
      "Wenn du deine ursprüngliche Wallet ohne Passphrase betreten willst, kannst du das immer noch tun, indem du nichts eingibst, wenn du zur Eingabe der Passphrase aufgefordert wirst. Oder du kannst die Passphrase-Funktion deaktivieren."
    ],
    title: "Passphrase deaktiviert"
  },
  summary: {
    button: "Passphrase aktivieren",
    title: "Übersicht",
    understand: "Ich verstehe, wie die Passphrase funktioniert und welche Risiken damit verbunden sind.",
    understandList: [
      "Die Passphrase ist eine zusätzliche Sicherheitsmaßnahme für mein Backup.",
      "Wenn ich eine andere Passphrase eingebe, wird immer ein anderes Wallet erstellt.",
      "Um mein Wallet wiederherzustellen benötige ich <strong>sowohl die Passphrase als auch das Backup</strong>.",
      "Wenn ich meine Passphrase vergesse, habe ich <strong>keinen Zugriff mehr auf meine Coins</strong>."
    ]
  },
  what: {
    button: "Verstehe, wie es funktioniert",
    message: "Eine Wallet wird aus einer sehr großen Zufallszahl erstellt (abgeleitet), die auch als Seed bezeichnet wird. Dieser Seed wird erstellt, wenn du deine BitBox02 zum ersten Mal einrichtest, und mit der microSD-Karte oder 24 Wörtern gesichert. Jeder, der Zugriff auf den Seed hat, hat die volle Kontrolle über das Geld auf dieser Wallet.\n\nEine Passphrase ist ein <strong>optionales Geheimnis</strong>, das zum Seed hinzugefügt wird. Wenn du eine Passphrase verwendest, erstellt jede Passphrase eine neue Wallet, die auf dem Seed + Passphrase (optionales Geheimnis) basiert. Eine Passphrase kann alles sein: Buchstaben, Wörter, Sonderzeichen oder auch leer. Die Standard-Wallet wird aus dem Seed und der leeren Passphrase erstellt.\n\nDie Passphrase ist Teil des BIP39-Standards, was bedeutet, dass sie mit allen Wallets kompatibel ist, die denselben Standard unterstützen.",
    title: "Was ist eine Passphrase?"
  },
  why: {
    button: "Warum sollte man eine Passphrase benutzen?",
    message: 'Die BitBox02 schützt den Seed vor der Extraktion aus dem Gerät selbst, doch das Backup (microSD-Karte oder 24 Wörter) gibt vollen Zugriff auf die Wallet. Deshalb sollte es an einem sicheren Ort aufbewahrt werden!\n\nDa eine Passphrase eine neue Wallet mit deinem bestehenden Seed erstellt, benötigt die Passphrase-Wallet <strong>sowohl dein Backup als auch deine Passphrase zur Wiederherstellung</strong>. Das hat den Vorteil, dass jemand, der dein Backup findet, trotzdem die Passphrase braucht, um auf die Passphrase-Wallet zuzugreifen.\n\nAußerdem kannst du mit der Passphrase-Funktion mehrere Wallets auf demselben Gerät erstellen, also "versteckte Wallets" zusätzlich zur Standard-Wallet.',
    title: "Warum sollte man eine Passphrase benutzen?"
  }
};
const password$g = {
  show: "{{label}} anzeigen",
  warning: {
    caps: "WARNUNG: Feststelltaste  (⇪) ist aktiviert",
    paste: 'Um Text einzufügen, aktiviere "Anzeigen" {{label}}".'
  }
};
const random$h = {
  button: "Zufallszahl generieren",
  description: "Deine BitBox hat die folgende {{bits}}-Bit-Zufallszahl generiert:"
};
const receive$i = {
  bitsuranceWarning: "Dies ist ein versichertes Konto, das heißt, es kann nur an Native Segwit empfangen. Dadurch wird verhinderst, dass du versehentlich an Wrapped Segwit oder Taproot empfängst, welche nicht versichert sind.",
  changeScriptType: "Adresstyp ändern",
  label: "Meine Adresse",
  onlyThisCoin: {
    description: "Um andere Token empfangen zu können, aktiviere diese in den Einstellungen. Solltest du Token empfangen, welche die BitBoxApp nicht unterstützt, hast du möglicherweise keinen Zugang mehr zu diesen. ",
    warning: "Stelle sicher, dass du nur {{coinName}} auf diese Adresse sendest."
  },
  scriptType: {
    p2tr: "Taproot (neuestes Format)",
    p2wpkh: "Native-Segwit (standard)",
    "p2wpkh-p2sh": "Wrapped-Segwit (kompatibles Format)"
  },
  selectAccount: "Konto auswählen",
  showFull: "Adresse auf BitBox bestätigen",
  taprootWarning: "Hinweis: Taproot ist ein neues Adressformat und noch nicht weit verbreitet. Gelder, die über Taproot-Adressen eingehen, sind möglicherweise nicht in Watch-Only-Wallets von Drittanbietern sichtbar. Viele Wallets und Börsen sind noch nicht in der Lage, an Taproot-Adressen zu senden.",
  title: "{{accountName}} empfangen",
  verify: "Adresse sicher verifizieren",
  verifyBitBox01: "Adresse auf Smartphone überprüfen",
  verifyBitBox02: "Adresse auf BitBox02 überprüfen",
  verifyInstruction: "Bitte bestätige, dass die folgende Adresse mit der Adresse auf deinem Gerät übereinstimmt.",
  warning: {
    secureOutput: 'Bitte koppele deine BitBox mit deinem Smartphone, um eine sichere Adressüberprüfung zu ermöglichen. Klicke in der Seitenleiste auf "Gerät verwalten".'
  }
};
const reset$g = {
  description: "Alle Daten auf dem Gerät werden gelöscht. Inklusive deiner Private-Keys!",
  notReset: "Gerät NICHT zurück gesetzt.",
  title: "Gerät in Werkszustand zurücksetzen",
  understand: "Ich habe ein Backup und kenne mein Wiederherstellungskennwort",
  understandBB02: "Ich habe ein valides Backup"
};
const securityInformation$g = {
  create: {
    description1: "Bitte richte dein Gerät in einer sicheren Umgebung ein, sodass niemand sehen kann, welches Passwort du wählst.",
    description2: "Während der Einrichtung wirst du aufgefordert, zwei verschiendene Passworter zu erstellen. ",
    description3: "Das erste Passwort ist das <strong> Gerätepasswort </strong>, welches deine BitBox entsperrt und später geändert werden kann.",
    description4: "Das zweite ist das <strong> Wiederherstellungspasswort </strong>, mit dem dein Wallet gesichert wird. Dieses Passwort kann später nicht geändert werden",
    description5: "Die von dir erstellte Wallet wird in einer Datei auf der mitgelieferten microSD Karte gespeichert. Dieses Backup kann im Notfall verwendet werden, um den Zugriff auf deine Coins mithilfe deines <strong> Wiederherstellungskennworts </strong> wieder herzustellen.",
    title: "Sicherheitsinformationen"
  },
  restore: {
    description1: "Du wirst aufgefordert, die Micro-SD-Karte einzustecken, die du zum Speichern deines Backups verwendet hast.",
    description2: "Um dein Gerät wiederherzustellen, benötigst du dein Wiederherstellungskennwort.",
    description3: "Bitte sei bei der Eingabe des Wiederherstellungskennworts aufmerksam. Jedes von dir eingegebene Passwort erstellt eine gültige Wallet, welche dann aber leer sind. Gibst du also ein falsches Kennwort ein, wird dir nicht die erwartete Wallet, sondern eine andere Wallet angezeigt.",
    title: "Sicherheitsinformationen"
  }
};
const seed$g = {
  agreements: {
    "funds-access": "Ich kann NICHT auf mein Geld zugreifen, wenn ich mein Wiederherstellungspasswort vergessen habe.",
    "password-change": "Ich kann das Wiederherstellungspasswort später NICHT ändern.",
    "password-required": "Ich brauche mein Wiederherstellungspasswort, um meine Wallet von meinem Backup wiederherzustellen."
  },
  create: "Neue Wallet erstellen",
  creating: "Wallet wird erstellt",
  description: "Ich bestätige, dass ich folgendes zu Kenntnis genommen habe:",
  error: {
    e102: "Das Passwort muss aus mindestens 4 Zeichen bestehen.",
    e200: "Du musst eine microSD Karte in deine BitBox einsetzen, damit ein Backup deiner Wallet erstellt und auf der Micro-SD Karte gespeichert werden kann."
  },
  info: {
    button: " Wiederherstellungspasswort festlegen",
    description1: "Steck die microSD Karte in die BitBox ein.",
    description2: 'Wähle ein Wiederherstellungspasswort für die Wallet und klicke "Wiederherstellungspasswort speichern".',
    description3: "Das Backup auf der microSD Karte, zusammen mit deinem Wiederherstellungspasswort, ist die einzige Methode, wie deine Wallet (= der Zugang zu deinen Coins) wieder hergestellt werden kann, falls deine BitBox gestohlen wird oder du dein Gerätepasswort vergisst!",
    description4: "Das Wiederherstellungspasswort lässt sich später nicht ohne Weiteres ändern. Dazu müsstest du dein Coins auf ein neues Konto transferieren. Deswegen solltest du von Anfang an ein gutes Passwort wählen.",
    title: "Neue Wallet erstellen "
  },
  password: {
    label: "Wiederherstellungspasswort",
    repeatPlaceholder: "Wiederhestellungspasswort wiederholen"
  },
  walletName: {
    label: "Wallet Name"
  }
};
const seedRestore$g = {
  error: {
    e200: "Um eine Wallet von einem Backup wieder herzustellen wird deine microSD Karte benötigt."
  },
  info: {
    description1: 'Stecke die microSD-Karte in die BitBox ein und klicke auf "Weiter".',
    description2: 'Wähle ein Backup aus und klicke "Wiederherstellen"',
    description3: "Gib das Wiederherstellungspasswort ein",
    description4: "Du musst bestätigen, dass du zu Kenntnis genommen hast, dass ein falsches Passwort eine andere Wallet erstellt/öffnet.",
    title: "Wie wird eine Wallet von einem Backup wieder hergestellt?"
  }
};
const send$i = {
  abort: "Die Transaktion wurde abgebrochen",
  address: {
    label: "Empfangsadresse",
    placeholder: "Adresse eingeben oder scannen"
  },
  amount: {
    label: "Betrag",
    placeholder: "Betrag eingeben"
  },
  availableBalance: "Kontostand",
  button: "Prüfen",
  coincontrol: {
    address: "Adresse",
    outpoint: "ID",
    title: "Outputs wählen"
  },
  confirm: {
    "selected-coins": "Ausgewählte Coins",
    title: "Bestätige und sende die Transaktion",
    total: "Gesamt"
  },
  error: {
    erc20InsufficientGasFunds: "Es scheint, als hättest du nicht genug Ether, um für diese ERC20-Transaktion zu bezahlen. Bitte vergewissere dich, dass du genug Ether in deiner Wallet hast.",
    feeTooLow: "Gebühr zu niedrig",
    feesNotAvailable: "Gebühren konnten nicht geschätzt werden",
    insufficientFunds: "Unzureichende Mittel",
    invalidAddress: "ungültige Adresse",
    invalidAmount: "ungültige Menge",
    invalidData: "ungültige Daten"
  },
  fee: {
    customPlaceholder: "Betrag eingeben",
    label: "Netzwerk Gebühr",
    placeholder: "Nicht verfügbar"
  },
  feeTarget: {
    customLabel: "Gebühren-Rate",
    customLabel_eth: "Gas-Preis",
    description: {
      economy: "4 Stunden (24 Blöcke)",
      economy_eth: "30 Minuten oder weniger",
      economy_ltc: "1 Stunde (24 Blöcke)",
      high: "20 Minuten (2 Blöcke)",
      high_eth: "30 Sekunden oder weniger",
      high_ltc: "5 Minuten (2 Blöcke)",
      low: "2 Stunden (12 Blöcke)",
      low_eth: "5 Minuten oder weniger",
      low_ltc: "30 Minuten (12 Blöcke)",
      normal: "1 Stunde (6 Blöcke)",
      normal_eth: "2 Minuten oder weniger",
      normal_ltc: "15 Minuten (6 Blöcke)"
    },
    estimate: "Geschätzte Wartezeit:",
    label: {
      custom: "Eigene Gebühr",
      economy: "Sehr niedrig",
      high: "Hoch",
      low: "Niedrig",
      normal: "Normal"
    },
    placeholder: "Gebühr wird berechnet...."
  },
  maximum: "Alles senden",
  maximumSelectedCoins: "Ausgewählte Coins senden",
  noFeeTargets: "Gebührenschätzungen sind derzeit nicht verfügbar. Bitte versuche es später erneut oder gib eine benutzerdefinierte Gebühr ein.",
  priority: "Priorität",
  scanQR: "QR Code scannen",
  signprogress: {
    description: "Dies ist eine Transaktion, die viele Daten enthält. Um die Transaktion vollständig zu signieren, wirst du aufgefordert, {{steps}} mal auf der BitBox zu bestätigen.",
    label: "Fortschritt"
  },
  success: "Die Transaktion wurde signiert und versendet.",
  title: "{{accountName}} senden",
  toggleCoinControl: "Coin Control",
  transactionDetails: "Transaktionsdetails"
};
const settings$h = {
  about: "Über die App",
  accounts: "Konten",
  advancedSettings: "Erweiterte Einstellungen",
  appearance: "Ansicht",
  electrum: {
    add: "Server hinzufügen",
    "add-server": "Hinzufügen",
    check: "Überprüfen",
    checkFailed: "Fehlgeschlagen",
    checkSuccess: "Verbindung zu {{host}} wurde erfolgreich hergestellt",
    checking: "Überprüfen",
    "download-cert": "Remote-Zertifikat herunterladen",
    "remove-server": "Entfernen",
    removeConfirm: "Entfernen {{server}}?",
    reset: "In Werkszustand zurücksetzen",
    resetConfirm: "Möchtest du alle Server entfernen und die Standardserver installieren?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Gib den Endpunkt ein",
    step2: "2",
    "step2-text": "Gib ein Zertifikat der Zertifikatskette des Servers ein. Lade alternativ das Remote-Zertifikat herunter und vergleiche es visuell.",
    "step2-text-tcp": "Überspringe diesen Schritt, wenn du kein TLS verwenden möchtest.",
    step3: "3",
    "step3-text": "Überprüfe die Verbindung und füge den Server hinzu.",
    step4: "4",
    "step4-text": "Starte die BitBoxApp neu. Wenn du die Standardserver nicht entfernst, wird dein eigener Node als Redundanz hinzugefügt.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Coin Control aktivieren",
    electrum: {
      description: "Du kannst dich mit deinem eigenen Electrum-Fullnode verbinden.",
      title: "Eigenen Full Node verbinden"
    },
    fee: "Eigene Gebühr aktivieren",
    setProxyAddress: "Proxy Adresse eingeben",
    title: "Erweiterte Einstellungen",
    useProxy: "Tor Proxy aktivieren",
    useSats: "BTC-Werte in Satoshis anzeigen"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Neues Update verfügbar",
    title: "Info",
    "up-to-date": "Deine App ist auf dem neuesten Stand",
    version: "App-Version"
  },
  restart: "Bitte starte die BitBoxApp neu, damit die Änderungen wirksam werden.",
  services: {
    title: "Dienste"
  },
  success: "Bitte trenne die BitBox und stecke sie wieder ein, damit die Änderungen wirksam werden.",
  title: "Einstellungen"
};
const setup$g = "Gerätepasswort festlegen";
const sidebar$h = {
  buy: "Krypto kaufen",
  device: "Gerät verwalten",
  insurance: "Versicherung",
  leave: "Verlassen",
  settings: "Einstellungen"
};
const success$n = {
  create: {
    info1: "Ein Backup deiner Wallet wurde sicher auf der microSD Karte gesichert. Entferne die Karte und bewahre diese an einem sicheren Ort auf.",
    info2: "Du hast ein Gerätepasswort erstellt, mit dem die BitBox entsperrt wird.",
    info3: "Du hast ein Wiederherstellungspasswort für deine Wallet erstellt, das deine Coins freigibt und dein Backup wiederherstellt.",
    summary: "Hier ist eine Zusammenfassung von dem, was du getan hast:",
    title: "Erfolg"
  },
  getstarted: "Loslegen",
  restore: {
    summary: "Du hast erfolgreich deine Wallet aus einem Backup wiederhergestellt.",
    title: "Erfolg"
  }
};
const transaction$h = {
  confirmation: "Bestätigungen",
  details: {
    activity: "Aktivität",
    address: "Adresse",
    amount: "Betrag",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Fiatbetrag",
    fiatAtTime: "Fiat zur Transaktionszeit",
    status: "Status",
    title: "Transaktionsdetails",
    type: "Typ"
  },
  explorer: "Transaktions ID",
  explorerTitle: "In externem Block Explorer öffnen.",
  fee: "Gebühr",
  fiatHistorical: "Historisch",
  gas: "Gas",
  note: {
    edit: "Notiz bearbeiten",
    save: "Notiz speichern"
  },
  pending: "Ausstehende Transaktion",
  size: "Größe",
  status: {
    complete: "Bestätigt",
    failed: "Fehlgeschlagen",
    pending: "Ausstehend"
  },
  tx: {
    received: "Empfangen an",
    sent: "Gesendet an"
  },
  vsize: "Virtuelle Größe",
  weight: "Gewicht"
};
const transactions$g = {
  errorLoadTransactions: "Beim Laden der Transaktionen ist ein Fehler aufgetreten",
  placeholder: "Noch keine Transaktionen."
};
const unknownError$g = "Ein unbekannter Fehler ist aufgetreten {{errorMessage}}\n\n";
const unlock$g = {
  description: "Gib dein Gerätepasswort ein um dein Gerät zu entsperren.",
  error: {
    e109_normal: "Gerätepasswort inkorrekt.  {{remainingAttempts}} Versuche verbleibend, bevor sich das Gerät in den Werkszustand zurücksetzt. ",
    e109_touch: "$t(unlock.error.e109_normal) Beim nächsten Loginversuch musst du die LED lange halten.",
    e113: "Aufgrund zu vieler Loginversuche musst du beim nächsten Versuch die LED 4 Sekunden lang drücken."
  },
  input: {
    label: "Gerätepasswort",
    placeholder: "Gib dein Gerätepasswort ein um das Gerät zu entsperren."
  },
  unlocking: "Entsperren..."
};
const upgradeFirmware$h = {
  button: "Firmware aktualisieren",
  description: "Möchtest du von Version  {{currentVersion}} zu Version {{newVersion}} upgraden?",
  label: "Deine BitBox benötigt eine Firmware Aktualisierung.",
  locked: "Um von Version  {{currentVersion}} zu Version  {{newVersion}} upzugraden, drücke die LED bitte lange. ",
  title: "Firmware upgraden",
  unlocked: "Der Bootloader ist gesperrt. Um fortzufahren:",
  unlocked1: "Steck deine BitBox aus und dann wieder ein.",
  unlocked2: "Die LED wird aufleuchten, wenn deine BitBox wieder eingesteckt ist.",
  unlocked3: "Tippe auf die LED, wenn diese aufleuchtet."
};
const walletConnect$b = {
  connect: {
    button: "Verbinden",
    dappLabel: "Gebe die URI-Adresse der Dapp ein",
    invalidPairingUri: "Ungültige Pairing-URI"
  },
  dashboard: {
    allSessions: "Alle Sitzungen",
    disclaimer: "Walletconnect ist ein Protokoll zur Verbindung mit Ethereum basierten Dapps. Diese Dapps werden von Drittanbieterdiensten betrieben. Stelle daher nur eine Verbindung zu Dapps her, denen du vertraust, und stelle sicher, dass du bei einer Transaktion immer weißt, was du signierst.",
    newConnection: "Neue Verbindung",
    noConnectedSessions: "Derzeit sind keine Konten mit Dapps verbunden."
  },
  invalidPairingChain: "Fehler beim Genehmigen des Pairing. Bitte stelle sicher, dass du eines der unterstützten Netzwerke verwendest: {{chains}}",
  pairingRequest: {
    approve: "Verbindung erlauben",
    reject: "Ablehnen",
    title: "Neue Verbindungsanfrage von"
  },
  pairingSuccess: "Dapp erfolgreich verbunden. Du kannst auf der Dapp-Website fortfahren.",
  signingRequest: {
    account: "Konto",
    chain: "Netzwerk",
    dapp: "Dapp",
    data: "Daten",
    dataParsingError: "Parsen der Daten fehlgeschlagen",
    decodeError: "Nachricht konnte nicht dekodiert werden",
    method: {
      sendTransaction: "Transaktion signieren und senden",
      signMessage: "Nachricht signieren",
      signTransaction: "Transaktion signieren",
      signTypedData: "Signiere eingegebene Daten"
    },
    successfullySigned: "Anfrage erfolgreich signiert",
    walletConnectRequest: "WalletConnect Anfrage"
  },
  useNewUri: "Dieser URI wurde bereits für den Verbindungsversuch verwendet. Bitte verwende eine neue URI.",
  walletConnect: "WalletConnect"
};
const warning$m = {
  receivePairing: 'Bitte aktiviere 2FA, um Adressen sicher zu verifizieren. Klicke dazu auf "Geräte verwalten" im Menü auf der linken Seite.',
  sdcard: "Bewahre deine microSD Karte separat von deiner BitBox auf. Die microSD Karte wird nur benötigt, wenn du deine Backups verwalten willst. Für den normalen Betrieb ist sie nicht erforderlich.",
  sendPairing: 'Bitte koppele deine BitBox mit einem Smartphone um Transaktionen sicher verifizieren zu können. Klicke dazu auf "Geräte verwalten" im Menü auf der linken Seite.'
};
const welcome$g = {
  connect: "Verbinde eine BitBox02",
  getStarted: "Beginnen wir mit der Installation der Firmware auf deiner BitBox02.",
  insertBitBox02: "Tippe dann auf die BitBox02 zum weiter machen. ",
  insertDevice: "Bitte verbinde dein Gerät, um loszulegen",
  title: "Willkommen"
};
const appTranslationsDE = {
  account: account$g,
  accountInfo: accountInfo$g,
  accountSummary: accountSummary$g,
  addAccount: addAccount$h,
  aopp: aopp$a,
  app: app$g,
  auth: auth$a,
  backup: backup$g,
  bb02Bootloader: bb02Bootloader$g,
  bitbox: bitbox$g,
  bitbox02Interact: bitbox02Interact$g,
  bitbox02Settings: bitbox02Settings$g,
  bitbox02Wizard: bitbox02Wizard$g,
  bitsurance: bitsurance$9,
  bitsuranceAccount: bitsuranceAccount$9,
  blink: blink$g,
  bootloader: bootloader$g,
  button: button$l,
  buy: buy$c,
  changePin: changePin$g,
  chart: chart$c,
  checkSDcard: checkSDcard$g,
  clickHere: clickHere$g,
  confirm: confirm$i,
  confirmOnDevice: confirmOnDevice$g,
  connectKeystore: connectKeystore$a,
  darkmode: darkmode$a,
  device: device$g,
  deviceLock: deviceLock$g,
  deviceSettings: deviceSettings$g,
  deviceTampered: deviceTampered$g,
  dialog: dialog$h,
  error: error$c,
  fiat: fiat$i,
  footer: footer$i,
  generic: generic$c,
  genericError: genericError$g,
  goal: goal$g,
  guide: guide$h,
  headerssync: headerssync$g,
  hiddenWallet: hiddenWallet$g,
  initialize: initialize$g,
  invalidFormat: invalidFormat$g,
  language: language$h,
  legacyhiddenwallet: legacyhiddenwallet$g,
  loading: loading$g,
  manageAccounts: manageAccounts$a,
  mobile: mobile$b,
  newSettings: newSettings$9,
  note: note$c,
  notification: notification$g,
  pairing: pairing$g,
  passphrase: passphrase$a,
  password: password$g,
  random: random$h,
  receive: receive$i,
  reset: reset$g,
  securityInformation: securityInformation$g,
  seed: seed$g,
  seedRestore: seedRestore$g,
  send: send$i,
  settings: settings$h,
  setup: setup$g,
  sidebar: sidebar$h,
  success: success$n,
  transaction: transaction$h,
  transactions: transactions$g,
  unknownError: unknownError$g,
  unlock: unlock$g,
  upgradeFirmware: upgradeFirmware$h,
  walletConnect: walletConnect$b,
  warning: warning$m,
  welcome: welcome$g
};
const account$f = {
  disconnect: "Connection lost. Retrying…",
  "export": "Export",
  exportTransactions: "Export transactions to downloads folder as CSV file",
  fatalError: "There was an unexpected error.",
  incoming: "Incoming",
  initializing: "Getting information from the blockchain…",
  insuranceExpired: "<strong>Account no longer insured</strong>\n\nThe insurance plan for this account has been modified.\nPlease check the insurance page for details.",
  insured: "Insured account",
  maybeProxyError: "Tor proxy enabled. Ensure that your Tor proxy is running properly, or disable the proxy setting.",
  reconnecting: "Lost connection, trying to reconnect…",
  syncedAddressesCount: "Scanned {{count}} addresses",
  uncoveredFunds: "You have coins on the following uncovered address types of your <strong>{{name}}</strong> account: {{uncovered}}.\nSince the account is insured, only coins received via the <strong>Native Segwit</strong> address type are covered. Coins on different address types, even if they are on the same account, are not insured.\nPlease move all your coins from the unsupported address types to the <strong>Native Segwit</strong> address type, so all your coins on this account are insured.",
  uncoveredFundsLink: "Follow this guide on how to move your coins.",
  warning: "Warning!"
};
const accountInfo$f = {
  address: "Address",
  buyCTA: {
    buy: "Buy {{unit}}",
    buyCrypto: "Buy Crypto",
    information: {
      looksEmpty: "Looks like this wallet is empty.",
      start: "Get started by depositing some coins to the wallet or buying directly in the BitBoxApp."
    }
  },
  extendedPublicKey: "Extended public key",
  label: "Account info",
  scriptType: "Script type",
  title: "Account information",
  verify: "Verify on device",
  xpubTypeChangeBtn: {
    p2pkh: "View legacy P2PKH extended public key",
    p2tr: "View Taproot",
    p2wpkh: "View Native Segwit",
    "p2wpkh-p2sh": "View older Segwit extended public key"
  },
  xpubTypeInfo: "Currently displaying {{scriptType}} extended public key ({{current}} of {{numberOfXPubs}})"
};
const accountSummary$f = {
  availableBalance: "Available balance",
  balance: "Balance",
  exportSummary: "Export accounts summary to downloads folder as CSV file",
  fiatBalance: "Fiat balance",
  name: "Account name",
  noAccount: "There are no accounts to show.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "My portfolio",
  total: "Total",
  transactionHistory: "Transaction history"
};
const addAccount$g = {
  chooseName: {
    nextButton: "Add account",
    step: "Name account",
    title: "Name your account"
  },
  selectCoin: {
    nextButton: "Next",
    step: "Select coin",
    title: "Select cryptocurrency"
  },
  success: {
    addAnotherAccount: "Add another account",
    message: "<strong>{{accountName}}</strong> has now been added to your accounts.",
    nextButton: "Done",
    step: "Finished",
    title: "Account added"
  },
  title: "Add account"
};
const aopp$9 = {
  addressRequest: "{{host}} is requesting a receiving address.",
  addressRequestWithLogo: "is requesting a receiving address",
  banner: "Address request in progress. Please connect your device to continue.",
  errorTitle: "Error during address request ",
  labelAddress: "Address",
  labelMessage: "Message",
  reverifyInfoText: "Verify address",
  signing: "To proceed, sign message on your BitBox02",
  success: {
    message: "Proceed on {{host}}",
    title: "Address successfully sent"
  },
  syncing: "Syncing the account, please wait.",
  title: "Address request"
};
const app$f = {
  upgrade: "A new version of this app is available! Please upgrade from {{current}} to {{version}}."
};
const auth$9 = {
  authButton: "Authenticate",
  title: "Please authenticate to continue"
};
const backup$f = {
  check: {
    checking: "Checking backup…",
    confirmTitle: "Check backup",
    notOK: "Backup does NOT match the wallet.",
    ok: "Backup matches the wallet.",
    password: {
      label: "Recovery password",
      placeholder: "Recovery password",
      showLabel: "recovery password"
    },
    success: "Successfully verified backup:",
    title: "Check backup"
  },
  create: {
    alreadyExists: "You already have a valid backup. Do you wish to re-create it?",
    fail: "Creating the backup FAILED!",
    info: "Please enter the recovery password of the current wallet for verification.",
    name: {
      label: "Backup name",
      placeholder: "Please name the backup"
    },
    password: {
      label: "Recovery password",
      placeholder: "Please enter your recovery password"
    },
    title: "Create backup",
    verificationFailed: "The recovery password does NOT MATCH the current wallet. The backup has been created. Please use 'Check backup' to verify your recovery password again."
  },
  description: "Select <strong>wallet backup file</strong>",
  insert: "Please insert the microSD card to manage backups.",
  insertButton: "I have inserted the microSD card",
  list: "Your microSD card backups",
  noBackups: "There are no backups on this microSD card.",
  restore: {
    confirmTitle: "Restore backup",
    error: {
      e200: "microSD card not found",
      general: "Error restoring the backup"
    },
    password: {
      label: "Recovery password or hidden recovery password",
      placeholder: "Recovery password",
      repeatPlaceholder: "Repeat recovery password",
      showLabel: "Recovery password"
    },
    restoring: "Restoring backup…",
    selectedBackup: "<strong>{{backupName}}</strong> created on {{createdDateTime}} will be restored.",
    subtitle: "Please select backup to continue",
    title: "Restore",
    understand: "I understand that an incorrect recovery password will create a different wallet"
  },
  showMnemonic: {
    description: "You will be presented with your recovery words on your BitBox02, which form a backup of your wallet. Write them down on paper.\n\n<strong>Do not store them digitally or take pictures of it.</strong>\n\n<strong>Do not say the words out loud.</strong>\n\n<strong>This backup is not password-protected.</strong>\n\nAfterwards, you will be asked to confirm each word.",
    title: "Show recovery words",
    warning: "<strong>Never share your recovery words with anyone.</strong> Your recovery words give full access to your wallet. If someone is asking you for your recovery words, it's a scammer, do not share them!"
  },
  title: "Manage backups"
};
const bb02Bootloader$f = {
  abort: "Don't upgrade – take me back",
  abort_noUpgrade: "Take me back",
  advanced: {
    label: "Advanced settings",
    toggleShowFirmwareHash: "Show the firmware hash every time on startup"
  },
  flipscreen: "Flip screen",
  orientation: "Device oriented the wrong way?",
  success: "Upgrade successful! Continuing in {{rebootSeconds}} seconds...",
  success_install: "Installation successful! Continuing in {{rebootSeconds}} seconds..."
};
const bitbox$f = {
  error: {
    e10000: "Current device password incorrect.",
    e10001: "Failed to replace device password",
    e102: "The password must consist of at least 4 characters.",
    e112: "Hidden device password cannot be the same as the main device password."
  }
};
const bitbox02Interact$f = {
  confirmDate: "Confirm today's date on your BitBox02",
  confirmDateText: "This date will be used to create your backup.",
  confirmName: "Confirm name on BitBox02",
  confirmWords: "Write down the {{amount}} recovery words from your BitBox02",
  confirmWordsText: "After that the BitBox02 asks you to confirm each word to verify that the backup is correct.",
  followInstructions: "Please follow the instructions on your BitBox02.",
  followInstructionsMnemonic: "Follow the instructions on your BitBox02 to enter the recovery words from your backup and restore your wallet.",
  followInstructionsMnemonicTitle: "Restore from recovery words"
};
const bitbox02Settings$f = {
  deviceName: {
    current: "Current device name",
    error: "Device name could not be set",
    error_104: "Confirming device name was aborted on device.",
    input: "BitBox02 name",
    placeholder: "New device name",
    title: "Set BitBox02 name"
  },
  gotoStartupSettings: {
    description: "This will reboot your BitBox02 and enter the startup settings.",
    title: "Go to startup settings"
  }
};
const bitbox02Wizard$f = {
  advanced: {
    button: "Advanced options",
    outOfDate: "Firmware out of date for this feature",
    seed12WordInfo: "Please note that the number of words cannot be changed after creating the wallet.",
    seed12WordLabel: "Create 12-word instead of 24-word seed",
    seed12WordText: "By default the BitBox02 uses a 24-word seed. Both seed lengths are secure against brute forcing in practice. Some users may prefer the convenience of the 12-word seed instead.",
    skipSDCardLabel: "Skip microSD card backup and write down recovery words instead",
    skipSDCardText: "You always have the option to create a microSD card backup or write your recovery words after setup. This can be done from settings.",
    title: "Advanced backup options"
  },
  attestationFailed: "Genuine check failed, which could be due to restarting the app while the device was waiting for user input. Please reconnect and try again. Please contact support@bitbox.swiss if this persists.",
  backup: {
    point1: "Select a backup on the microSD card",
    point2: "Set a password for your device",
    restoreText: "Ok, let's restore a backup!",
    text1: "Great, your BitBox02 password is now set and wallet created. Now it's time to create your first backup. Please make sure your microSD card is inserted into your BitBox02 and continue.",
    text2: "Please follow the on-screen instruction on your device to create a backup.",
    text3: "After your backup is created, please remove the microSD card and store it in a <strong>secure location</strong>. The contents of the microSD card is not password-protected. Never insert it into any other device but your BitBox02.",
    userConfirmation1: "I should store my backup in a secure location.",
    userConfirmation2: "My backup is not password protected. Anyone with access to it can access my wallet.",
    userConfirmation3: "If I lose or damage my BitBox02, the only way to recover my funds is to restore from my backup.",
    userConfirmation4: "If I lose or damage both my backup and my BitBox02 then my funds will be lost.",
    userConfirmation5: "I should not insert my microSD card backup into a computer, phone, printer or any device other than a BitBox02.",
    userConfirmation5mnemonic: "I should not put my recovery words in a computer, phone, printer or any device other than a BitBox02."
  },
  create: {
    button: "Name device & continue",
    info: "Here are the basics steps you will be taking to set up your BitBox: ",
    inputTitle: "Wallet name",
    point1: "Name your device",
    point2: "Set a password for your device",
    point3: "Create a backup",
    text: "Ok, let's create a new wallet!"
  },
  createBackupAborted: "Creating backup aborted.",
  createBackupFailed: "Creating backup failed, try again.",
  initialize: {
    passwordText: "Now let's set a password for your device. Use the controls on your BitBox to enter and choose a password.",
    passwordTitle: "Set a password for your BitBox",
    text: "Successfully paired your BitBox02! Now let's initialize your device. Get started by choosing to create a new wallet, or to restore a wallet from an existing backup. <strong>Please make sure you have a microSD card inserted in your BitBox02</strong>",
    tip: "We recommend that you proceed in a secure location.",
    title: "Initialize your BitBox"
  },
  insertSDCard: "<strong>Please make sure you have a microSD card inserted in your BitBox02.</strong>",
  noPasswordMatch: "Passwords did not match, please try again.",
  pairing: {
    failed: "Unconfirmed pairing. Please replug your BitBox02.",
    paired: "You have confirmed the following code on your device. Please continue.",
    title: "Verify pairing code",
    unpaired: "An unpaired BitBox02 has been detected. Please verify the pairing code matches what is shown on your BitBox02."
  },
  restoreFromMnemonic: {
    e104: "Restoring from recovery words was canceled.",
    failed: "Restoring from recovery words failed, please try again."
  },
  stepBackup: {
    beforeProceed: "Before proceeding, please read these important security considerations:",
    createBackup: "You will now create a backup on your microSD card.",
    createBackupMnemonic: "You will now write down the recovery words."
  },
  stepBackupSuccess: {
    fundsSafe: "To keep your funds safe, please remember the following:",
    title: "Backup Restored!"
  },
  stepConnected: {
    unlock: "Enter BitBox02 password to unlock."
  },
  stepCreate: {
    description: "This name is used as the device name and for backups.",
    error: {
      genericMessage: "Use letters, numbers, basic symbols, spaces. Max 30 characters.",
      invalidChars: "Name contains invalid characters: {{invalidChars}}.",
      tooLong: "Name is too long."
    },
    nameLabel: "BitBox02 name",
    namePlaceholder: "My BitBox02",
    title: "Choose BitBox02 name",
    toastMicroSD: "Please insert your microSD card into your BitBox02 which will be used to store a backup of the wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Please remove the microSD card from your BitBox02 and store it in a secure location.",
    storeMnemonic: "Please store your recovery words in a secure location",
    success: "You’ve successfully created your backup."
  },
  stepInsertSD: {
    insertSDCard: "Please insert a microSD card into your BitBox02 to continue.",
    insertSDcardTitle: "Insert microSD card"
  },
  stepPassword: {
    e104: "Setting password was canceled.",
    title: "Set BitBox02 password",
    useControls: "Use the controls on your BitBox02 to set a password."
  },
  stepUninitialized: {
    create: "I want to create a new wallet on my BitBox02.",
    restore: "I want to restore my wallet from a backup.",
    restoreMicroSD: "Restore from microSD card",
    restoreMnemonic: "Restore from recovery words",
    title: "Setup your wallet"
  },
  success: {
    text: "Hooray! Your BitBox02 is now ready to use. \n\nFor further information on how to use the BitBoxApp, please use the in-app guide by clicking the question mark on the top right corner.",
    title: "You're ready to go!"
  }
};
const bitsurance$8 = {
  dashboard: {
    active: "Insurance policy active",
    button: "Insure a new account",
    canceled: "Canceled",
    coverage: "Maximum coverage",
    inactive: "Inactive",
    processing: "Processing",
    refused: "Refused",
    supportLink: "Manage contract",
    title: "Insured accounts",
    waitpayment: "Waiting for payment"
  },
  detect: {
    button: "Check for existing insurance",
    insured: "Insured account detected:",
    notInsured: "No insured accounts detected. If you are sure you have an insured account, please make sure you have the correct wallet connected.",
    text: "If you already signed up with Bitsurance, the BitBoxApp can automatically synchronize your existing insurance coverage.",
    title: "Already insured?"
  },
  insure: {
    button: "Check availability and pricing",
    faq: "Read more on Bitsurance FAQs",
    listItem1: "Burglary",
    listItem2: "Extortion (e.g., $5 wrench attack)",
    listItem3: "Destruction due to fire, water or natural disasters",
    month: "month",
    text: "Insure your BitBox02 and up to €100,000 worth of bitcoin against",
    text2: "Insurance plans start at €30/year (€2.50/month). You can learn more about Bitsurance and their exact insurance offerings on the",
    text3: "Currently available in Germany, with more regions to follow.",
    title: "Get started"
  },
  intro: {
    link: "Bitsurance website",
    text1: "BitBox works with Bitsurance to add an additional layer of protection for your bitcoin. While the BitBox02 keeps your funds secure, Bitsurance covers threats at home that can’t be mitigated with technology alone, like burglary, extortion, or destruction of the hardware wallet itself."
  },
  terms: {
    link: "Bitsurance Privacy Policy",
    text1: "Bitsurance is an independent third-party service. For questions regarding their offerings and insurance claims, please contact Bitsurance directly.",
    text2: "Insurance is currently available in Germany, with more regions to follow.",
    text3: "The maximum Bitcoin coverage currently available is €100,000 per person. Higher amounts are planned for the future.",
    text4: "Personal information and the extended public key of your insured account is part of the insurance policy and will be shared with Bitsurance and the insurance provider.",
    text5: "For more on privacy, please consult the"
  },
  title: "Insurance"
};
const bitsuranceAccount$8 = {
  errorNoXpub: "Error: Was not able to get xpub from account.",
  noAccount: "There are no accounts that can be insured.",
  select: "Select account",
  title: "Insurance"
};
const blink$f = {
  button: "Blink"
};
const bootloader$f = {
  button: "Upgrade firmware now",
  button_install: "Install firmware now",
  progress: "Upgrading: {{progress}}%",
  progress_install: "Installing: {{progress}}%",
  success: "Upgrade successful! Please replug the device. This time, do not touch the button."
};
const button$k = {
  abort: "Abort",
  back: "Back",
  buy: "Buy",
  changepin: "Change device password",
  check: "Check backup",
  "continue": "Continue",
  copy: "Copy",
  create: "Create",
  dismiss: "Dismiss",
  done: "Done",
  download: "Download",
  hiddenwallet: "Create hidden wallet",
  next: "Next",
  ok: "OK",
  previous: "Previous",
  receive: "Receive",
  restore: "Restore",
  select: "Select",
  send: "Send",
  unlock: "Unlock",
  update: "Update",
  upgrade: "Upgrade"
};
const buy$b = {
  exchange: {
    bankTransfer: "Bank transfer",
    bestDeal: "Best deal",
    creditCard: "Credit card",
    fast: "Fast",
    fee: "fee",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bank Transfer: {{fee}}%",
          creditDebitCard: "Credit/debit card: {{fee}}%",
          learnMore: "Learn more about Moonpay",
          title: "Fees"
        },
        fullCurrenciesList: "See full list of currencies here",
        payment: {
          asteriskText: "* Not available for US residents",
          bankTransfer: "Bank transfer*",
          bankTransferDetails: {
            pix: "PIX (BR transactions in Brazil only)",
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          creditDebitCard: "Credit/debit Card",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "See more details about payment methods",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports all major fiat currencies: USD, EUR, CHF, and more."
      },
      pocket: {
        fees: {
          info: "Bank transfer: {{fee}}%",
          title: "Fees"
        },
        learnMore: "Learn more about Pocket",
        payment: {
          bankTransfer: "Bank transfer",
          bankTransferDetails: {
            sepa: "SEPA and SEPA Instant (EUR transactions in SEPA countries only)",
            sic: "Swiss Interbank Clearing (CHF transactions in CH/LI only)",
            uk: "UK Faster Payments (GBP transactions in the UK only)"
          },
          bankTransferReccuring: "How to set up recurring purchases with a standing order?",
          title: "Payment methods"
        },
        supportedCurrencies: "Supports European currencies: EUR, GBP, and CHF.",
        verification: {
          info: "Only requires identity verification above daily and annual thresholds.",
          link: "Find current thresholds here",
          title: "Identity verification"
        }
      },
      region: {
        title: "Select the region your bank account is registered in to see which options are available to you."
      }
    },
    noExchanges: "Sorry, there are no available exchanges in this region.",
    region: "Region",
    selectRegion: "Not specified",
    title: "Buy {{name}}"
  },
  info: {
    "continue": "Agree and continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "We partner with MoonPay to offer you a seamless way to buy {{name}} directly within the BitBoxApp. It's just a few clicks.",
        "MoonPay is a platform that makes it easy and quick to buy {{name}} in over 160+ countries."
      ],
      payment: {
        details: "You can buy {{name}} instantly via MoonPay with the following payment methods. Credit or debit card orders are instant and convenient, but more expensive due to increased chargeback risk. We recommend using the bank transfer option for larger amounts. The minimum fee is 4 USD/EUR or equivalent.",
        footnote: "Please note that MoonPay's exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
        table: {
          "1_description": "Lowest fees, can take up to 3 working days",
          "1_method": "Bank transfers (SEPA)",
          "2_description": "Higher fees but quick and instant",
          "2_method": "Credit & debit cards",
          description: "Description",
          fee: "Fee",
          method: "Method"
        },
        title: "Payment methods and fees"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. MoonPay needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
        descriptionGeneric: "The BitBoxApp does not collect any data when buying {{name}}, the incoming funds are treated like a regular transaction. However partner exchanges need to collect some information to operate. Please refer to their respective privacy policies to see in more detail how the data is handled.",
        title: "Data protection"
      },
      security: {
        description: "When you buy {{name}} via MoonPay, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        descriptionGeneric: "When you buy {{name}} via a partner exchange, you are using an external service. This service is out of scope of the BitBox02 security threat model and relies on the safety and security of the environment which the BitBoxApp software is running in.",
        link: "Security threat model",
        title: "Security model"
      },
      title: "Welcome to your one stop shop for buying {{name}}"
    },
    next: "Next",
    selectLabel: "Choose your account",
    selectPlaceholder: "Select a coin",
    skip: "Do not show again",
    title: "Buy {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket privacy policy",
      p1: "The BitBoxApp does not collect any data when buying bitcoin, the incoming funds are treated like a regular transaction. Pocket needs to collect some personal data to operate. Their Privacy Policy explains in detail how that data is handled.",
      title: "Data protection"
    },
    kyc: {
      link: "Read Pocket FAQs",
      p1: "Pocket tries to keep KYC to a minimum. For purchases under 950 EUR (1000 CHF) a day, no additional documents are required. For purchases over this amount, you will need to schedule a call with Pocket to complete the necessary KYC/AML process.",
      title: "KYC/AML"
    },
    payment: {
      p1: "You can buy bitcoin instantly with Pocket via SEPA bank transfer. The fee is 1.5% and the bitcoin is deposited to your BitBox as soon as possible after Pocket receives the bank transfer (usually within the same day).",
      p2: "Please note that Pocket’s exchange rates can differ from the ones used in the BitBoxApp, resulting in slightly different amounts.",
      title: "Payment methods and fees"
    },
    previousTransactions: "The transaction history of this account is not empty. Sharing this account will make all its past and future transactions visible for Pocket. Proceed anyway?",
    security: {
      link: "BitBox02 security threat model",
      p1: "When you buy bitcoin via Pocket, you are using an external service. This service is out of scope of the BitBox02 Security Threat model and relies on the safety and security of the environment which the BitBoxApp software is running in. However we work together to improve security by using a two factor authentication mechanism to verify the address you are receiving to.",
      title: "Security model"
    },
    usedAddress: "The address {{address}} has been already used, please start again with a new address.",
    verifyBitBox02: "Please verify that the address you received via email matches the one displayed on your Bitbox. If possible, you should open the email on a second device for better security.",
    welcome: {
      p1: "We partner with Pocket to offer you a seamless way to buy bitcoin directly within the BitBoxApp. It's just a few clicks.",
      p2: "Pocket is a Swiss platform that makes it quick and easy to buy bitcoin in most of Europe (anywhere where SEPA bank transfers are supported).",
      p3: "With Pocket, you can also do regular buys through standing bank orders, so you can DCA (dollar-cost averaging) with ease.",
      title: "Welcome to your one stop shop for buying bitcoin"
    }
  },
  title: "Buy {{name}}"
};
const changePin$f = {
  newTitle: "New device password",
  oldLabel: "Current device password"
};
const chart$b = {
  dataMissing: "Gathering historical data... stay tuned.",
  dataOldTimestamp: "Historical exchange rates updating. The chart is not displaying data after {{time}}.",
  dataUpdating: "updating data…",
  filter: {
    all: "All",
    month: "Month",
    week: "Week",
    year: "Year"
  }
};
const checkSDcard$f = "checking microSD card";
const clickHere$f = "Click here.";
const confirm$h = {
  abortInfo: "Tap to ",
  abortInfoRedText: "abort",
  approveInfo: "Hold 4+ secs to ",
  approveInfoGreenText: "confirm",
  info: "Continue on your BitBox. ",
  infoWhenPaired: "First on the paired mobile and then your BitBox"
};
const confirmOnDevice$f = "Please confirm on your device.";
const connectKeystore$9 = {
  promptNoName: "Please connect your BitBox02 to continue",
  promptWithName: 'Please connect your BitBox02 named "{{name}}" to continue'
};
const darkmode$9 = {
  toggle: "Dark mode"
};
const device$f = {
  appUpradeRequired: "Your BitBox is not compatible with this desktop application. Please download and install the latest version.",
  keystoreConnected: "Connected wallet"
};
const deviceLock$f = {
  button: "Enable two factor authorization (2FA)",
  condition1: "Do you have a backup?",
  condition2: "Is mobile app verification working?",
  condition3: "2FA DISABLES backups and mobile app pairing. The device must be RESET to exit 2FA!",
  confirm: "Enable two factor authorization (2FA)",
  title: "Enable two factor authorization (2FA)"
};
const deviceSettings$f = {
  backups: {
    manageBackups: {
      description: "Create or verify your microSD card backup."
    },
    showRecoveryWords: {
      description: "Show and verify recovery words."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "The BitBoxApp checks if your device is authentic."
    },
    deviceName: {
      description: "Change the name of your device."
    },
    rootFingerprint: {
      description: "The root fingerprint is a unique identifier for the wallet currently in use. It can help you distinguish between different wallets if you use passphrases."
    },
    securechip: {
      description: "The model of the secure chip."
    },
    title: "Device information"
  },
  expert: {
    factoryReset: {
      description: "Reset your device to factory settings. This deletes the wallet from your BitBox02!",
      title: "Factory reset"
    },
    goToStartupSettings: {
      description: "Enter the bootloader of the BitBox02. You can enable the firmware hash from here."
    },
    passphrase: {
      description: "Enable or disable the passphrase feature.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware Version",
    newVersion: {
      label: "Available version"
    },
    title: "Firmware",
    upToDate: "Your device is up to date",
    upgradeAvailable: "New upgrade available",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "Authenticity check failed",
      label: "Authenticity check",
      "true": "Your BitBox02 is authentic"
    },
    sdcard: {
      "false": "Not inserted",
      label: "microSD card",
      "true": "Inserted"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Retrieving device info…",
  pairing: {
    lock: {
      "false": "Disabled",
      label: "Two factor authorization (2FA)",
      "true": "Enabled"
    },
    mobile: {
      "false": "Closed",
      label: "Mobile app",
      "true": "Open"
    },
    status: {
      "false": "Not paired",
      label: "Status",
      "true": "Paired"
    },
    title: "Pairing"
  },
  secrets: {
    manageBackups: "Manage backups",
    title: "Secrets"
  }
};
const deviceTampered$f = "Has your BitBox been supplied with a recovery password? If so, stop the setup process and contact support immediately. Shift will never give you a ready made wallet or make password recommendations.";
const dialog$g = {
  cancel: "Cancel",
  confirm: "Confirm",
  confirmTitle: "Confirmation"
};
const error$b = {
  accountAlreadyExists: "The account already exists.",
  accountLimitReached: "Cannot add account. The maximum number of accounts for this coin has been reached.",
  aoppCallback: "There was an error delivering the address to {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "There are no available accounts.",
  aoppSigningAborted: "Address ownership request cancelled.",
  aoppUnknown: "An unknown error occurred.",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "There are no available accounts that support the requested address format.",
  aoppUnsupportedKeystore: "The connected device cannot sign messages for this asset.",
  aoppVersion: "Unknown version.",
  keystoreTimeout: "Wallet request expired. Please try again.",
  wrongKeystore: "Wrong wallet connected. Please make sure to insert the correct device matching this account.",
  wrongKeystore2: " If you are using the optional passphrase, make sure you have entered the correct passphrase for the account."
};
const fiat$h = {
  "default": "default",
  setDefault: "Set {{code}} as default",
  title: "Currencies"
};
const footer$h = {
  appVersion: "App version:"
};
const generic$b = {
  enabled_false: "Disabled",
  enabled_true: "Enabled"
};
const genericError$f = "An error occurred. If you notice any issues, please restart the application.";
const goal$f = {
  buttons: {
    create: "Create a new wallet",
    restore: "Restore a wallet from a backup"
  },
  paragraph: "Please select one of the following options:",
  step: {
    "1": {
      title: "Security information"
    },
    "2": {
      description: "Set a device password",
      title: "Device"
    },
    "3-create": {
      description: "Create a new wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "from a backup",
      title: "Restore"
    },
    "4-create": {
      title: "Summary"
    },
    "4-restore": {
      title: "Summary"
    }
  }
};
const guide$g = {
  accountDescription: {
    text: "Your account overview shows your available balance as well as incoming and outgoing transactions. Our guide in ‘Settings’ has more information about each account type. ",
    title: "What does this page show me?"
  },
  accountFiat: {
    text: "Yes. Click on any ticker to rotate through fiat currencies. You can change the list of currencies in the settings.",
    title: "Can I display other conversion rates?"
  },
  accountIncomingBalance: {
    text: "Incoming sums up the amounts transferred to you but not yet confirmed by the network.",
    title: "What does incoming mean?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Each xpub is tied to the "Type" shown: either "Native Segwit (bech32)", "Wrapped Segwit" or “Taproot” (Bitcoin only). These are script types used by {{coinName}}. The BitBoxApp combines them, supporting multiple script types in the same account. Because each script type gives a different xpub, there are multiple xpubs per account.\n\nIf you consistently receive on the default address (Native Segwit), you only need the "bech32" xpub. However, if you also receive funds to "Wrapped Segwit" or “Taproot”, you also need to use the "Wrapped Segwit" and “Taproot” extended public keys respectively.',
      title: "Why are there multiple xpubs?"
    },
    privacy: {
      text: "For this specific account, the extended public key reveals the entire financial history, your account balance, and all future transactions. But the xpub does not allow anyone to spend your coins.\n\nIf you give an xpub to someone, you should be aware that this person or company can see all other transactions of the same account. Therefore, it’s a good idea to use that account only for this purpose and keep other funds in different accounts.",
      title: "Do I need to keep my xpub secret?"
    },
    verify: {
      text: "Yes, it’s always a good idea to double-check your xpub. If someone else will generate receive addresses from this xpub to send you money, this is especially important. You need to verify it on the device to ensure that this xpub belongs to you; otherwise, all funds could go to the wrong addresses.",
      title: "Do I need to verify the xpub on the device?"
    },
    xpub: {
      text: "An extended public key (xpub) is a root key from which all receiving addresses of an account are derived.\n\nIt is provided here for advanced use and interoperability with watch-only wallets, such as Electrum or Sentinel. If you received to different address types, please import all the different xpub formats into the watch-only wallet in order to see all your coins.\n\nPlease note, third party wallets may not support Taproot xpubs yet.",
      title: "What is an extended public key?"
    }
  },
  accountRates: {
    text: "We update exchange rates every minute from CoinGecko.",
    title: "Which exchange rates apply?"
  },
  accountReload: {
    text: "There’s no need. Your transaction information is updated automatically.",
    title: "Can I reload the transaction history?"
  },
  accountSendDisabled: {
    text: "The ‘Send’ button is activated when your balance is more than zero.",
    title: "Why can't I send any {{unit}}?"
  },
  accountSummaryAmount: {
    text: "The total amount is the sum of all your crypto accounts. Exchange rates are obtained from coingecko.com.\n\nNote: If you use MyEtherWallet for tokens not supported in the BitBoxApp, they will not be included in the amount displayed.",
    title: "How is the total amount calculated?"
  },
  accountSummaryDescription: {
    text: "Here you can see the performance of your portfolio over time. A summary of your individual crypto accounts is displayed under the chart.",
    title: "What does this page show me?"
  },
  accountTransactionAttributesBTC: {
    text: "Virtual size: Determines the network fee. You successfully saved on fees if it is smaller than the transaction size.\nSize: Actual transaction size in bytes when serialized according to the underlying blockchain.\nWeight: A new metric introduced with Segwit to evaluate transaction and block sizes. Each segregated witness byte counts as one, everything else as four weight units. Instead of one megabyte in actual size, the block size limit is now four million weight units.",
    title: "What about the Bitcoin-specific transaction details?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmations: Your first transaction broadcast is unconfirmed until a miner includes it in a block, after which it has one confirmation. Each block broadcast on the network adds another confirmation to your transaction. Generally merchants and other network actors will only settle transactions with between three to six confirmations.\nTransaction ID: A unique identification number that allows you to look up a transaction in a block explorer.\nFee: Miners are paid a transaction fee as an incentive to include transactions in the blocks they mine. To learn more, click on the send button.",
    title: "What’s the information in the transaction details?"
  },
  accountTransactionConfirmation: {
    text: "A transaction broadcast to the network but not yet confirmed.",
    title: "What is a pending transaction?"
  },
  accountTransactionLabel: {
    text: "It’s the address you received coins from or sent coins to.",
    title: "Which address is displayed for each transaction?"
  },
  accountTransactionTime: {
    text: "The blockchain transaction confirmation time.",
    title: "What time is displayed?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin and Litecoin can have an arbitrary amount of accounts. After five accounts, you can only add another account if the previous account has been used. \nOther coins can have a maximum of five accounts.",
      title: "How many accounts can I create?"
    },
    howtoAddTokens: {
      text: 'Tokens using the ERC20 standard are tied to a specific Ethereum account. To enable or disable a particular token, open the "Manage accounts" screen, expand your Ethereum account and switch the desired token on or off.',
      title: "How can I add additional tokens?"
    },
    moveFunds: {
      text: "Yes. But because accounts are independent, you need to send your funds using a regular transaction.",
      title: "Can I move funds between accounts?"
    },
    recoverAccounts: {
      text: "Yes. The BitBoxApp creates accounts using well-established standards compatible with most other crypto wallets.",
      title: "Can I recover my accounts with other wallets?"
    },
    supportedCoins: {
      link: {
        text: "View supported coins"
      },
      text: "The BitBoxApp supports Bitcoin, Litecoin, Ethereum as well as a selection of ERC20 token. For Cardano and other tokens, use your BitBox02 with alternative software such as AdaLite or Rabby. You can find an exhaustive list of all supported coins on our website:",
      title: "Which coins are supported?"
    },
    whatAreAccounts: {
      text: "Your wallet can manage multiple accounts of the same coin. Accounts are helpful when you want to keep funds separate.",
      title: "What are accounts?"
    },
    whatIsRememberWallet: {
      text: "Enabling “Remember wallet” lets you see the accounts for this wallet in the BitBoxApp even when the BitBox02 is not plugged in. This allows you to check your balance and portfolio whenever you want. The BitBox02 still needs to be plugged in and unlocked to send or receive coins.\n\nDisabling “Remember wallet” requires you to plug in the respective BitBox02 (or passphrase wallet) to see those accounts in the BitBoxApp.",
      title: "What happens when I enable/disable “Remember wallet”?"
    },
    whyIsThisUseful: {
      text: 'Accounts are great for managing funds for different people or purposes because they are separated. You can also share the "extended public key" of an account without revealing anything about your other accounts. This allows you to repeatedly receive funds without reusing addresses, such as receiving your wage or regularly buying crypto.',
      title: "Why is this useful?"
    }
  },
  appendix: {
    link: "Contact us!",
    text: "Another question?"
  },
  backups: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet. It can also be used to verify that you still have the correct recovery password. You can check your main recovery password or your hidden recovery password.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: "No but your recovery password is required to derive the wallet from the stored seed.",
      title: "Can I encrypt the backup?"
    },
    howOften: {
      text: "The backup is automatically generated when a new wallet is created. You only have to make a new backup if your microSD card is lost or damaged, or if you want to use multiple microSD cards as backups.\nYou do not need to create new backups after transaction activity. All your transaction data can be recreated by your single backup that was automatically generated for you.",
      title: "How often do I have to make a backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card. The seed together with your recovery password generates your wallet.",
      title: "What is a backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Check backup' allows you to verify that you have a working backup corresponding to your current wallet.",
      title: "What is 'Check backup'?"
    },
    encrypt: {
      text: 'No. Please keep the microSD card safe, as it contains the unencrypted seed to recover your wallet. If you wish to password-protect your seed, you can enable an optional passphrase in the expert settings under "Manage device".',
      title: "Can I encrypt the backup?"
    },
    whatIsABackup: {
      text: "It is a copy of the seed on an microSD card.",
      title: "What is a backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "When 2FA is enabled, all transactions have to be approved on the paired mobile phone in order to spend coins. Under the hood, an encrypted single-use number is sent to the mobile app, decrypted there, and returned to the BitBox when pressing the Accept button. This communication with the device is done via the channel between the mobile phone and this desktop app established during pairing.\n\nBe sure to backup your wallet and pair the mobile app before enabling 2FA. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.",
      title: "How does Two factor authorization (2FA) work?"
    },
    disable2FA: {
      text: "In order to disable 2FA, you need to reset your BitBox and then restore the wallet from its backup. Make sure that you still have the microSD card with the backup and that you still remember the recovery password. Then press 'Reset device'. Set a new device password and choose 'Or restore a backup'. Select the backup you have made from the wallet, click 'Restore' and enter the recovery password you used when creating the wallet.",
      title: "How can I disable two factor authorization (2FA)?"
    },
    ejectBitbox: {
      text: "You can unplug the BitBox at any time without having to eject it first.",
      title: "How can I eject the BitBox?"
    },
    ejectSD: {
      text: "You can remove the microSD card from the BitBox at any time as long as you are not in the process of creating or restoring a backup.",
      title: "How can I eject the microSD card?"
    },
    hiddenWallet: {
      text: "It is a second wallet on the same device protected by a different device password and recovery password, which you can use for plausible deniability. The same backup seed is used for both your normal and hidden wallet, so no additional backup is required.",
      title: "What is a hidden wallet?"
    },
    legacyHiddenWallet: {
      text: "First click the button below (available if the BitBox is unlocked with the main device password and 2FA is disabled), then replug your Bitbox and unlock it with your hidden device password.",
      title: "How do I access the legacy hidden wallet?"
    },
    pairing: {
      text: "After having downloaded our mobile app for either iOS or Android, you scan the displayed QR code, which sets up a secure channel between the mobile app and this application. Once scanned, follow the instructions in the mobile app.",
      title: "How to securely pair with your phone"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Please check Bitsurance’s website and their FAQ for more details.",
      title: "Additional questions?"
    },
    privacy: {
      link: {
        text: "Bitsurance privacy policy"
      },
      text: "Like any regular insurance policy, it contains your full name and address, and specifies the insured object (defined by the extended public key of the insured Bitcoin account). This data is submitted to Bitsurance directly and is not shared with Shift Crypto. Please consult the Bitsurance privacy policy for more information",
      title: "What personal information is needed for the insurance?"
    },
    renew: {
      text: "The insurance will automatically renew for the next year. You can cancel the renewal any time by clicking on “Manage contract” in the BitBoxApp, which takes you to the Bitsurance customer portal.",
      title: "How can I renew or cancel the insurance?"
    },
    status: {
      text: "Successfully insured accounts are marked with a green “insured” badge in the top left corner on each Bitcoin account page. In the “Insurance” section, you can see the overview of all insured Bitcoin accounts and their current insurance status. It can take up to 48 hours to update the insurance status.",
      title: "Can I check the status of an insured account?"
    },
    what: {
      text: "Each Bitcoin insurance contract covers a specific wallet account. You can insure multiple accounts by taking out multiple insurance policies. Insured accounts are limited to using “Native Segwit” Bitcoin addresses.",
      title: "Is the whole BitBox wallet insured?"
    },
    who: {
      text: "The insurance is offered by Bitsurance, an insurance broker built by bitcoiners. They work with ELEMENT insurance to provide Bitcoin insurance. Both companies are based in Germany.",
      title: "Who is insuring my bitcoin?"
    },
    why: {
      text: "Bitsurance covers some risks of self-custody that are not in-scope of even the most secure wallet, e.g. burglary, extortion or destruction of the wallet. It’s your personal decision if you need insurance coverage for these risks.",
      title: "Do I need Bitcoin insurance?"
    }
  },
  cointracking: {
    text: 'Click the "Export" button and open the downloads folder where you will find the CSV export. Then click the link below, upload your BitBox CSV file and import the data in order to use it for your CoinTracking portfolio manager and to create your tax reports.',
    title: "How to import my transactions into CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Read more about the authenticity check"
      },
      text: "The BitBoxApp performs an attestation check on the BitBox02 to verify if the device is genuine. The check is done locally and does not connect to any servers.",
      title: "How does the authenticity check work?"
    },
    name: {
      text: "This is the name of your wallet and backup. The name is used for future backups and can be used to help distinguish between different wallets. It can be changed at any time but note that backups made before the change will still use the previous name.",
      title: "What is the BitBox02 name used for?"
    },
    "secure-chip": {
      link: {
        text: "Read more about the secure chip"
      },
      text: "This information shows the model number of the secure chip, the most up to date chip is ATECC608B with improved security features compared to older models.",
      title: "Why show the secure chip model?"
    }
  },
  receive: {
    address: {
      text: "You can give the address to others to send you some coins. Just make sure they are sending to the correct address.",
      title: "What do I do with an address?"
    },
    addressChange: {
      text: "As soon as you transact, a new address is automatically added to the list so there are always 20 addresses available which have never received any coins.",
      title: "When do the addresses change?"
    },
    addressFormats: {
      text: "By default, the address type is Native Segwit. This address type is widely adopted by other wallets/exchanges and gives you the best fee rates for everyday transactions. However, you may also choose to send to Taproot (Bitcoin only), which is the newest address type, but may not be widely supported yet. Alternatively, if you are having issues sending to Native Segwit (the default type), you can try switching to the older Wrapped Segwit address type that may be compatible with more wallets/exchanges.",
      title: "When do I use “Change address type”?"
    },
    howVerify: {
      text: "For the BitBox01, click on the BitBox icon in the sidebar on the left and see the Pairing section. The guide will update and you can continue following the instructions from there.\nFor the BitBox02, you can verify addresses directly on the device during the send/receive process.",
      title: "How can I verify an address securely?"
    },
    plugout: {
      text: "No, once you sent coins to your BitBox address, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while receiving?"
    },
    why20: {
      text: 'During start-up the app generates addresses derived from your seed to see if they have received funds. As the app can generate an almost infinite number of addresses, it could spend years determining the balance. To limit this search it stops after it sees 20 addresses that have never received funds. This is the "gap limit" and 20 is a de-facto standard though the number is arbitrary. These are the 20 addresses you can choose from.',
      title: "Why only 20 addresses?"
    },
    whyMany: {
      text: "To maintain privacy and security, never hand out the same address twice. If you have used an address, click on on the right arrow for a new address. You can generate up to 20 addresses at a time. Think of addresses like invoice numbers. All addresses are derived from your single backup seed.",
      title: "Why so many addresses?"
    },
    whyVerify: {
      text: "You shouldn’t trust your computer to generate and display authentic addresses. It’s big attack surface makes it significantly more vulnerable than a hardware wallet. For the BitBox01, The button to verify the address securely sends the address to a paired mobile phone, from which you can also scan and verify the QR code. For the BitBox02, the address can be verified directly on the BitBox02 display.",
      title: "Why should I verify the address securely?"
    }
  },
  send: {
    change: {
      text: "The change will be returned to a Taproot address if you have at least one Taproot UTXO. If you use coin control, the change will be returned to a Taproot address if there is at least one Taproot UTXO among the selected UTXOs. In all other cases, the change is returned to a Native Segwit address.",
      title: "How is the change output determined?"
    },
    fee: {
      text: "The fee is based on the transaction data size and not its amount. The fee targets are calculated by Bitcoin Core's fee estimation algorithm for each network priority you chose. They are shown if they have a different value from the target below.\nEconomy: 24 blocks (around 4 hours for Bitcoin, 1 hour for Litecoin)\nLow: 12 blocks (around 2 hours for Bitcoin, 30 minutes for Litecoin)\nNormal: 6 blocks (around 1 hour for Bitcoin, 15 minutes for Litecoin)\nHigh: 2 blocks (around 20 minutes for Bitcoin, 5 minutes for Litecoin)\n(A block takes on average ten minutes for Bitcoin (2.5 minutes in Litecoin) to mine and the network load may vary considerably in the above periods.)",
      title: "How is the fee determined?"
    },
    plugout: {
      text: "No, once you have made a transaction, you do not need to leave your BitBox plugged in. You are free to disconnect your BitBox.",
      title: "Do I need to leave my BitBox plugged in while sending?"
    },
    priority: {
      text: "The higher fee you are willing to pay, the faster your transaction is typically confirmed by the network.",
      title: "What is the network priority?"
    },
    revert: {
      text: "Once a transaction is signed and sent (i.e. broadcasted to the network), it can no longer be reverted. Verify the transactions (including the fee) properly before signing!\nIf you know the recipient and he or she is willing to send the same amount (minus the transaction fees) back to you, you can send them a new receiving address.",
      title: "Can I revert a transaction?"
    },
    whyFee: {
      text: "Transactions are competing to be confirmed by a miner. Miners choose transactions to be included in the blockchain based on their fee.\nMiners vote on the history of transactions. Since there is no trusted third party to enforce one vote per person (which is the whole point of blockchains), miners vote on transactions by sacrificing a costly resource like computing power. As a reward for their work, they can claim newly created coins and the fee of all the transactions they included.",
      title: "Why is there a network fee?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "If you intend to only connect to your node when you are on the same network (e.g. your home wifi), then using regular network communication is sufficient.\nIn this case it is advisable that your Electrum server provides a TLS certificate to encrypt the communication.\nIf you intend to connect to your node from anywhere, using Tor is the better option. No TLS certificate is necessary in that case.",
      title: "Should I use clearnet TCP, TLS or Tor?"
    },
    instructions: {
      link: {
        text: "Guide to connect your node"
      },
      text: "For a full tutorial, please visit our guide:",
      title: "How do I connect my BitBoxApp to my own full node?"
    },
    options: {
      text: "There are multiple options to run your own node such as buying a finished device, building your own or running Bitcoin Core.\nIf you want to connect your BitBoxApp to your node, make sure that it runs an Electrum server. This is a dedicated program that allows a wallet app to communicate with your full node.\nSupported options include Electrs, Electrum Personal Server (EPS) or Bitcoin Wallet Tracker (BTW).",
      title: "What options are there to run a node?"
    },
    tor: {
      text: "Tor stands for 'The Onion Router', which is a free and open source software that offers a lot of privacy benefits and is especially useful when using Bitcoin.\nIf you intend to connect to your node via Tor, make sure that Tor is installed on your computer and then enable the Tor Proxy in the BitBoxApp settings.\nOn most operating systems there are two ways to run Tor:\n1. Tor Browser: download and open the Tor Browser. This will allow the BitBoxApp to connect to the Tor network by setting port 9150 in the Tor proxy settings.\n2. Tor background service: install the Tor daemon, which always runs in the background. The BitBoxApp can then connect by setting port 9050 in the Tor proxy settings.",
      title: "What is Tor, Tor proxy and which port should I use?"
    },
    what: {
      text: "It is possible to power your wallet with your own full nodes instead of using Shift servers.",
      title: "What is this?"
    },
    why: {
      text: "Running your own node is not necessary but improves privacy and reduces the need to trust others.\nFirstly, it means that you are using Bitcoin more privately as the BitBoxApp won't connect to our servers to fetch your transaction history; instead it will fetch that information from your own node.\nSecondly, running your own node means that your node verifies all transactions itself, making sure that the consensus rules are enforced.",
      title: "Why should I run my own node?"
    }
  },
  settings: {
    sats: {
      text: "A Satoshi ('sat' for short) is the smallest unit of Bitcoin. One Satoshi is a hundred millionth of a bitcoin (0.00000001 BTC). It is named after the creator of Bitcoin, Satoshi Nakamoto.",
      title: "What is a Satoshi?"
    },
    servers: {
      text: "This app communicates with the Shift Crypto servers to check for updates, load transactions, and send information to paired mobile apps.\nThe app also retrieves the latest exchange rates from CoinGecko. All conversions are calculated locally which means no data about the amount of your transaction is ever transmitted.\nNote: For Ethereum and ERC20 Tokens, we use Etherscan.io APIs.",
      title: "Which servers does this app talk to?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Close guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "On desktop, hover the cursor over the chart. On mobile, hold your finger on the chart and drag horizontally.",
    title: "How to see historical values on the chart?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "You have to reset the device and restore the wallet from a backup, using the recovery password.",
      title: "What do I do if I forgot the device password?"
    },
    reset: {
      text: "Enter a wrong device password 15 times. The last few attempts require a long touch on the device.",
      title: "How do I reset the device?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "The device should blink once when inserted. Make sure that it is inserted the right way around. If you are having trouble, please contact us through the link below.\n\nThe BitBox01 is not supported on mobile. Please use the BitBoxApp on desktop to connect your BitBox01.",
      title: "My BitBox01 is not recognized"
    },
    getDevice: {
      link: {
        text: "Order a BitBox"
      },
      text: "You can buy a BitBox in our online shop:",
      title: "How can I get a device?"
    },
    internet: {
      text: "Yes, an internet connection is required to synchronize the wallet, send transactions and retrieve the latest exchange rates.",
      title: "Does this app require an internet connection?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "You can recover your accounts on a new BitBox or with our backup center.",
      title: "I lost my device. Now what?"
    },
    useWithoutDevice: {
      text: "Unfortunately, this is not yet possible at the moment.",
      title: "Can I use the app without a device?"
    },
    welcome: {
      text: "Thanks for using this app built by Shift Crypto in Switzerland. We appreciate any input you have to share. Please give feedback using the link at the bottom.",
      title: "Welcome to the BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "If you are using a new phone/computer with the BitBoxApp, then you will need to connect to the DApps again. You will then see your coins on the dapp again like usual.",
      title: "I don't see my previous connections."
    },
    supportedNetworks: {
      text: "Currently, only Ethereum mainnet is supported using WalletConnect in the BitBoxApp. To use other EVM compatible chains please use the Rabby browser extension wallet.",
      title: "What networks are supported?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is a communication protocol for web3 applications. It allows you to conveniently connect to Ethereum based DApps and web wallets without using a third party app, which is particularly useful for Android users of the BitBoxApp.",
      title: "What is WalletConnect?"
    }
  }
};
const headerssync$f = {
  blocksSynced: "{{blocks}} blocks synced"
};
const hiddenWallet$f = {
  info1HTML: "For plausible deniability purposes, a hidden wallet can be created based on a <strong>different</strong> device password + recovery password combination.",
  info2HTML: "Define the device password and recovery password you want to associate with your hidden wallet below. The device password and recovery password must be <strong>different</strong> from the ones you defined for your primary wallet.",
  passwordLabel: "Hidden recovery password",
  passwordPlaceholder: "Please confirm hidden recovery password",
  pinLabel: "Hidden device password",
  pinRepeatLabel: "Repeat hidden device password",
  pinRepeatPlaceholder: "Please confirm hidden device password",
  success: "Hidden wallet created successfully. Replug your BitBox to unlock it."
};
const initialize$f = {
  create: "Set device password",
  creating: "Setting device password…",
  error: {
    e102: "The device password must consist of at least 4 characters."
  },
  info: {
    description1: "Choose your device password. This will be used to unlock your BitBox.",
    description2: "You can use numbers, letters & symbols. Longer passwords offer higher security.",
    description3: "If you lose the device password you will have to reset your device and restore your wallet backup.",
    subtitle: "Now you will set your device password",
    title: "Initializing your device"
  },
  input: {
    label: "Device password",
    labelRepeat: "Repeat device password",
    placeholderRepeat: "Please confirm device password"
  }
};
const invalidFormat$f = "Invalid format";
const language$g = {
  title: "Select language"
};
const legacyhiddenwallet$f = {
  disable: "Disable legacy hidden wallet",
  enable: "Enable legacy hidden wallet",
  successDisable: "Successfully disabled the legacy hidden wallet.",
  successEnable: "Successfully enabled the legacy hidden wallet. Replug your BitBox and enter the hidden device password to access the legacy hidden wallet."
};
const loading$f = "loading…";
const manageAccounts$9 = {
  accountHidden: "This account has been hidden from your watch-only accounts. To see it again, please plug in your BitBox02.",
  editAccount: "Edit",
  editAccountNameTitle: "Edit account name",
  noAccounts: "no accounts found",
  settings: {
    hideTokens: "Hide tokens",
    showTokens: "Show tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Add and show/hide accounts",
  title: "Manage accounts",
  watchAccount: "Watch account",
  watchAccountDescription: "This account is part of your watch-only accounts. You can hide it from your watch-only accounts using the toggle."
};
const mobile$a = {
  usingMobileDataWarning: "Mobile data usage: this app may download up to a few hundred megabytes of blockchain header data after unlocking an account. Please connect to Wi-Fi to avoid using mobile data. After dismissing it, this message won't be shown again."
};
const newSettings$8 = {
  about: {
    appVersion: {
      title: "App version"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Lock access to the app with screen lock/fingerprint.",
      title: "Screen lock"
    },
    coinControl: {
      description: "Select which UTXOs are part of a transaction to help improve privacy."
    },
    customFees: {
      description: "Lets you enter your own fee when sending."
    },
    torProxy: {
      description: "Connect over Tor for better privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "These additional currencies can be toggled through on your account page.",
      title: "Active currencies"
    },
    darkmode: {
      description: "See the BitBoxApp in dark mode."
    },
    defaultCurrency: {
      description: "Select your default currency",
      title: "Default currency"
    },
    enableAccount: {
      description: "Disabling your account means it will not appear in the sidebar or the portfolio. You can always enable it again from here. Coins on this account will not be affected and will remain safe.",
      title: "Enable/disable account"
    },
    hideAmounts: {
      description: "Displays a toggle to hide your balance and amounts to improve your privacy when using the app in public.",
      hideAmounts: "Hide amounts",
      showAmounts: "Show amounts",
      title: "Allow hiding amounts"
    },
    language: {
      description: "Which language you want the BitBoxApp to use.",
      title: "Language"
    },
    remebmerWallet: {
      name: "Remember wallet",
      warning: "This will remove your remembered wallet. To see it again, you will need to plug in the BitBox02 for this wallet. Any coins on this wallet are not affected. Do you want to continue?",
      warningTitle: "Disable remember wallet"
    },
    toggleSats: {
      description: "Enable or disable Satoshis."
    }
  }
};
const note$b = {
  input: {
    description: "(optional)",
    placeholder: "Add note…"
  },
  title: "Note"
};
const notification$f = {
  newTxs_one: "New transaction in: {{accountName}}",
  newTxs_other: "{{count}} new transactions in: {{accountName}}"
};
const pairing$f = {
  aborted: {
    text: "The pairing has been aborted from the mobile app.",
    title: "Aborted"
  },
  button: "Pair mobile app",
  confirm: "Are you sure you want to pair your BitBox? Note that after, the mobile phone is required to perform a transaction.",
  connectOnly: {
    button: "Connect mobile app",
    title: "Scan with our mobile app by selecting the menu item 'Connect to new desktop app'"
  },
  error: {
    text: "Something went wrong. Please start again.",
    title: "Error"
  },
  pullFailed: {
    text: "Failed to pull a message from your mobile through the relay server. The relay server might be offline, please contact support.",
    title: "Pull failed"
  },
  reconnectOnly: {
    button: "Reconnect mobile app"
  },
  scanningFailed: {
    text: "Mobile was not able to scan the message successfully. Please try again.",
    title: "Scanning Failed"
  },
  start: {
    hideAppQRCode: "Hide QR code",
    revealAppQRCode: "Show QR code",
    step1: "If you do not have the mobile app, you can scan the QR code for the Apple App Store or the Google Play Store depending on which phone you have.",
    step2: "Scan with our mobile app, which you can find under the name 'Digital Bitbox 2FA' in the app stores for iOS and Android:"
  },
  started: {
    text: "Now please follow the instructions in the mobile app.",
    title: "Great"
  },
  success: {
    text: "Congratulations, you successfully paired your BitBox with the mobile app!",
    title: "Success"
  },
  timeout: {
    text: "The pairing timed out after two minutes. Start again if you still want to pair the mobile app.",
    title: "Timeout"
  },
  title: "Mobile pairing"
};
const passphrase$9 = {
  considerations: {
    button: "Backup considerations",
    message: "The passphrase adds a layer of protection to your wallet backup (microSD card or recovery words). If someone has access to your backup they will also need the passphrase to access your wallet.\n\nHowever, this means you will need <strong>both the passphrase + wallet backup</strong> to restore your passphrase-enabled wallet, in case your BitBox02 is lost or broken. If you forget or lose your passphrase, you will lose access to all the coins on that wallet.\n\nWhen storing your passphrase, consider putting it in a separate location than your backup. That way if someone finds your backup they don’t find your passphrase as well.",
    title: "Backup considerations"
  },
  disable: "Disable passphrase",
  disableInfo: {
    button: "Disable",
    message: "After disabling the passphrase, you will no longer be asked to enter a passphrase after unlocking your BitBox02. Therefore, you will enter your default wallet.\n\nAny coins on your passphrase-wallet will still be on that wallet, however you won’t be able to access them because after unlocking your BitBox02, you will open your default wallet.\n\nTo access your passphrase-wallets again, simply re-enable the passphrase feature and enter the relevant passphrase after unlocking the BitBox02.\n\n<strong>Tip:</strong> You can still enter your original wallet by leaving the passphrase empty."
  },
  enable: "Enable passphrase",
  error: {
    e104: "Changing the passphrase setting was aborted."
  },
  how: {
    button: "What it looks like",
    message: "A passphrase doesn’t work like a password that you’re used to. If you mistype your passphrase, you will not be notified. This is because <strong>every passphrase creates a different, yet valid, wallet</strong>. This means you can use multiple passphrases for as many wallets as you want. But each wallet can only be accessed when typing in the corresponding passphrase.\n\nWhen plugging in your BitBox02, you’ll be prompted for the device password as usual. After that, you’ll be asked to enter a passphrase on the device.\n\nAfter entering the passphrase, you’ll be shown the passphrase you entered. This is so you can confirm you entered it correctly.",
    title: "How does it work"
  },
  intro: {
    message: "A passphrase provides an additional layer of security on top of your wallet.\nLet’s learn how it works.",
    title: "Setup passphrase"
  },
  progressDisable: {
    message: "Confirm on your BitBox that you want to <strong>disable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  progressEnable: {
    message: "Confirm on your BitBox that you want to <strong>enable</strong> the optional passphrase.",
    title: "Confirm on device"
  },
  successDisabled: {
    message: "Optional passphrase <strong>successfully enabled</strong>!\nYou’ll be asked to provide a passphrase from now on.",
    messageEnd: "Please replug the BitBox02 now.",
    title: "Passphrase enabled"
  },
  successEnabled: {
    message: "Optional passphrase <strong>successfully disabled</strong>!\n\nYou will not be asked to provide a passphrase anymore.",
    messageEnd: "Please replug your BitBox02 now.",
    tips: "Tips",
    tipsList: [
      "We suggest sending a small amount to the passphrase wallet first. Then unplug and replug the BitBox02 and enter your password and passphrase. If you entered the passphrase correctly, you should see the coins in your wallet.",
      "If you want to enter your original wallet without a passphrase, you can still do this by entering nothing when prompted to enter the passphrase. Or you can disable the passphrase feature."
    ],
    title: "Passphrase disabled"
  },
  summary: {
    button: "Enable passphrase",
    title: "Summary",
    understand: "I understand how the passphrase works and the risks associated with it.",
    understandList: [
      "The passphrase is an additional layer of security on top of your backup.",
      "Entering a different passphrase will always generate a different wallet.",
      "To restore your wallet you need <strong>both the passphrase and backup</strong>.",
      "If you forget your passphrase, you can <strong>no longer access your coins</strong>."
    ]
  },
  what: {
    button: "Learn how this works",
    message: "A wallet is created (derived) from a very big random number, also known as a seed. This seed is created when you first set up your BitBox02 and is backed up with the microSD card or recovery words. Anyone who has access to the seed has full control over the funds on that wallet.\n\nA passphrase is an <strong>optional secret</strong>, added to the seed. When using a passphrase, each passphrase creates a new wallet based on the seed + passphrase (optional secret). A passphrase can be anything: letters, words, special characters or it can even be empty. The default wallet is in fact derived from the seed + empty passphrase.\n\nThe passphrase is part of the BIP39 standard, which means it is compatible with all wallets that support the same standard.",
    title: "What is a passphrase?"
  },
  why: {
    button: "Why use a passphrase",
    message: "The BitBox02 protects the seed against extraction from the device itself, but the backup (microSD card or recovery words) gives full access to the wallet. That is why it should be stored in a secure location!\n\nSince a passphrase creates a new wallet using your existing seed, the passphrase-wallet requires both your <strong>backup AND passphrase to restore</strong>. The benefit of this is if someone finds your backup, they still need the passphrase to access the passphrase-wallet.\n\nAdditionally, the passphrase feature allows you to create multiple wallets on the same device, or “hidden wallets” in addition to the default one.",
    title: "Why use a passphrase?"
  }
};
const password$f = {
  show: "Show {{label}}",
  warning: {
    caps: "WARNING: caps lock (⇪) is enabled",
    paste: 'to paste text, enable "SHOW {{label}}"'
  }
};
const random$g = {
  button: "Generate random number",
  description: "Your BitBox generated the following {{bits}}-bit random number:"
};
const receive$h = {
  bitsuranceWarning: "This is an insured account, meaning it can only receive to Native Segwit. This is so you don't accidently receive to Wrapped Segwit or Taproot, which are not insured.",
  changeScriptType: "Change address type",
  label: "Your address",
  onlyThisCoin: {
    description: "To receive other tokens, enable them in the settings. If you deposit other tokens, they might not be accessible.",
    warning: "Make sure to only receive {{coinName}} on this address."
  },
  qrCodeCopiedMessage: "Copied!",
  scriptType: {
    p2tr: "Taproot (newest format)",
    p2wpkh: "Native Segwit (default)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatible format)"
  },
  selectAccount: "Select account",
  showFull: "Show and verify full address on device",
  taprootWarning: "Note: Taproot is a new Bitcoin feature and is not yet widely adopted. Funds received on Taproot addresses may not be visible in third party watch-only wallets. Many wallets and exchanges are not yet able to send to Taproot addresses.",
  title: "Receive {{accountName}}",
  verify: "Verify address securely",
  verifyBitBox01: "Verify address on mobile app",
  verifyBitBox02: "Verify address on BitBox02",
  verifyInstruction: "Please verify that the following address matches the one displayed on your device.",
  warning: {
    secureOutput: "Please pair your BitBox with your mobile device to enable secure address verification. Go to 'Manage device' in the sidebar."
  }
};
const reset$f = {
  description: "All data will be deleted from this device. That includes your Private Key!",
  notReset: "Device NOT reset.",
  title: "Factory reset device",
  understand: "I have a backup and know my recovery password",
  understandBB02: "I have a valid backup"
};
const securityInformation$f = {
  create: {
    description1: "We recommend you set up your device in a safe environment, meaning you are away from other people that could see what password you choose.",
    description2: "You will be asked to create two passwords.",
    description3: "The first is the <strong>device password</strong> which unlocks your BitBox device and can be changed later.",
    description4: "The second is the <strong>recovery password</strong> which unlocks your wallet. This password cannot be changed later.",
    description5: "The wallet you create will be backed up to a file on the microSD card provided. This can be used in an emergency to recover your funds using your <strong>recovery password</strong>.",
    title: "Security information"
  },
  restore: {
    description1: "You will be asked to insert the microSD card you used to store you backup.",
    description2: "To restore your device you will need your recovery password. ",
    description3: "Please take care when entering the recovery password. Any password you enter will create a valid wallet. If you enter the wrong password you may be shown a wallet balance that you do not expect.",
    title: "Security information"
  }
};
const seed$f = {
  agreements: {
    "funds-access": "I will NOT be able to access my funds if I forget my recovery password",
    "password-change": "I can NOT change the recovery password later",
    "password-required": "The recovery password is required to restore a wallet from a backup"
  },
  create: "Create wallet",
  creating: "Creating wallet",
  description: "I understand that:",
  error: {
    e102: "The password must consist of at least 4 characters.",
    e200: "You need to insert a microSD card into your BitBox in order to create a wallet, so a backup can be created automatically."
  },
  info: {
    button: "Set recovery password now",
    description1: "Insert the microSD card into the BitBox",
    description2: "Choose a recovery password for the wallet and select “Set recovery password now”",
    description3: "The back up to microSD card and your recovery password is the only method to recover your funds in case of lost or stolen BitBox device.",
    description4: "You cannot change your recovery password later on without transferring your funds.",
    title: "Create a new wallet"
  },
  password: {
    label: "Recovery password",
    repeatPlaceholder: "Repeat recovery password"
  },
  walletName: {
    label: "Wallet name"
  }
};
const seedRestore$f = {
  error: {
    e200: "Restoring a wallet from a backup requires the microSD card."
  },
  info: {
    description1: "Insert the microSD card into the BitBox and click “Continue”",
    description2: "Choose a backup and click “Restore”",
    description3: "Enter the recovery password",
    description4: "You need to confirm to understand that an incorrect password will create a different wallet.",
    title: "How to restore a wallet from a backup"
  }
};
const send$h = {
  abort: "The transaction has been aborted.",
  address: {
    label: "Receiver address",
    placeholder: "Enter address"
  },
  amount: {
    label: "Amount",
    placeholder: "Enter amount"
  },
  availableBalance: "Available balance",
  button: "Review",
  coincontrol: {
    address: "Address",
    outpoint: "Outpoint",
    title: "Send from output"
  },
  confirm: {
    "selected-coins": "Selected coins",
    title: "Confirm and send transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "It seems like you do not have enough Ether to pay for this ERC20 transaction. Please make sure you hold enough Ether in your wallet",
    feeTooLow: "fee too low",
    feesNotAvailable: "Could not estimate fees",
    insufficientFunds: "insufficient funds",
    invalidAddress: "invalid address",
    invalidAmount: "invalid amount",
    invalidData: "invalid data"
  },
  fee: {
    customPlaceholder: "Enter amount",
    label: "Network fee",
    placeholder: "Not available"
  },
  feeTarget: {
    customLabel: "Fee rate",
    customLabel_eth: "Gas price",
    description: {
      economy: "4 hours (24 blocks)",
      economy_eth: "30 minutes or less",
      economy_ltc: "1 hour (24 blocks)",
      high: "20 minutes (2 blocks)",
      high_eth: "30 seconds or less",
      high_ltc: "5 minutes (2 blocks)",
      low: "2 hours (12 blocks)",
      low_eth: "5 minutes or less",
      low_ltc: "30 minutes (12 blocks)",
      normal: "1 hour (6 blocks)",
      normal_eth: "2 minutes or less",
      normal_ltc: "15 minutes (6 blocks)"
    },
    estimate: "Estimated confirmation time:",
    label: {
      custom: "Custom",
      economy: "Economy",
      high: "High",
      low: "Low",
      normal: "Normal"
    },
    placeholder: "Calculating fee…"
  },
  maximum: "Send all",
  maximumSelectedCoins: "Send selected coins",
  noFeeTargets: "Fee rate estimations are currently unavailable. Please try again later or enter a custom fee.",
  priority: "Priority",
  scanQR: "Scan QR code",
  scanQRNoCameraMessage: "Camera not found. Please ensure that your device supports a camera and permissions are correctly set.",
  signprogress: {
    description: "This is a transaction containing a lot of data. To fully sign the transaction, you will be asked to confirm {{steps}} times.",
    label: "Progress"
  },
  success: "The transaction has been signed and sent.",
  title: "Send {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Transaction details"
};
const settings$g = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Advanced settings",
  appearance: "Appearance",
  electrum: {
    add: "Add a server",
    "add-server": "Add",
    check: "Check",
    checkFailed: "Failed",
    checkSuccess: "Successfully established a connection to {{host}}",
    checking: "Checking",
    "download-cert": "Download remote certificate",
    "remove-server": "Remove",
    removeConfirm: "Remove {{server}}?",
    reset: "Reset to default",
    resetConfirm: "Do you want to remove all servers and install the default servers?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Enter the endpoint.",
    step2: "2",
    "step2-text": "Enter a certificate of the server's certificate chain. Alternatively, download the remote certificate and compare it visually.",
    "step2-text-tcp": "You can skip this step if you do not want to use TLS.",
    step3: "3",
    "step3-text": "Check the connection and add the server.",
    step4: "4",
    "step4-text": "Restart the wallet. If you do not remove the default servers, your own node will be added as a redundancy.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Enable coin control",
    electrum: {
      description: "You can connect to your own Electrum full node.",
      title: "Connect your own full node"
    },
    fee: "Enable custom fees",
    setProxyAddress: "Set proxy address",
    title: "Expert settings",
    useProxy: "Enable tor proxy",
    useSats: "Display BTC values in Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "New update available",
    title: "Info",
    "up-to-date": "Your app is up to date",
    version: "App Version"
  },
  restart: "Please re-start the BitBoxApp for the changes to take effect.",
  services: {
    title: "Services"
  },
  success: "Please unplug and replug the BitBox for the changes to take effect.",
  title: "Settings"
};
const setup$f = "Setup device";
const sidebar$g = {
  buy: "Buy crypto",
  device: "Manage device",
  insurance: "Insurance",
  leave: "Leave",
  settings: "Settings"
};
const success$m = {
  create: {
    info1: "Your wallet has been securely backed up to the microSD Card. Remove it and keep it safe.",
    info2: "You have created a secure device password that unlocks the BitBox.",
    info3: "You have created a secure recovery password for your wallet that unlocks your funds and restores your backups.",
    summary: "Here is a summary of what you have done",
    title: "Success"
  },
  getstarted: "Get started",
  restore: {
    summary: "You have successfully restored a wallet from your backup.",
    title: "Success"
  }
};
const transaction$g = {
  confirmation: "Confirmations",
  details: {
    activity: "Activity",
    address: "Address",
    amount: "Amount",
    date: "Date",
    fiat: "Fiat",
    fiatAmount: "Fiat amount",
    fiatAtTime: "Fiat at time of transaction",
    status: "Status",
    title: "Transaction Details",
    type: "Type"
  },
  explorer: "Transaction ID",
  explorerTitle: "Open in external block explorer",
  fee: "Fee",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "Edit note",
    save: "Save note"
  },
  pending: "Pending transaction",
  size: "Size",
  status: {
    complete: "Complete",
    failed: "Failed",
    pending: "Pending"
  },
  tx: {
    received: "Received to",
    sent: "Sent to"
  },
  vsize: "Virtual size",
  weight: "Weight"
};
const transactions$f = {
  errorLoadTransactions: "There was an error loading the transactions",
  placeholder: "No transactions yet."
};
const unknownError$f = "An unknown error occurred: {{errorMessage}}";
const unlock$f = {
  description: "Enter your device password to unlock your device.",
  error: {
    e109_normal: "Wrong device password. {{remainingAttempts}} attempts remain before the device is reset.",
    e109_touch: "$t(unlock.error.e109_normal) The next login requires holding the touch button.",
    e113: "Due to many login attempts, the next login requires holding the touch button for 4 seconds."
  },
  input: {
    label: "Device password",
    placeholder: "Enter your device password to unlock the device"
  },
  unlocking: "Unlocking…"
};
const upgradeFirmware$g = {
  button: "Upgrade firmware",
  description: "Do you want to upgrade the firmware from version {{currentVersion}} to {{newVersion}}?",
  label: "Your BitBox requires a firmware upgrade.",
  locked: "To upgrade from {{currentVersion}} to {{newVersion}}, please do a long touch.",
  title: "Upgrade firmware",
  unlocked: "The bootloader is unlocked. To continue, please:",
  unlocked1: "Unplug and replug your Bitbox",
  unlocked2: "The LED will light up when your BitBox is plugged back in",
  unlocked3: "Tap the touch button when the LED lights up"
};
const walletConnect$a = {
  connect: {
    button: "Connect",
    dappLabel: "Enter URI address of dapp",
    invalidPairingUri: "Invalid pairing uri"
  },
  dashboard: {
    allSessions: "All sessions",
    disclaimer: "Walletconnect is a protocol to connect to Ethereum based Dapps. These dapps are run by third-party services, so only connect to dapps you trust and be sure to always know what you are signing when making a transaction.",
    newConnection: "New connection",
    noConnectedSessions: "No accounts are currently connected to any dapps."
  },
  invalidPairingChain: "Error in approving pairing. Please make sure to use one of the supported chains: {{chains}}",
  pairingRequest: {
    approve: "Approve Connection",
    reject: "Reject",
    title: "New connection request from"
  },
  pairingSuccess: "Dapp successfully connected. You can continue on the dapp website.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Failed to parse data",
    decodeError: "Failed to decode message",
    method: {
      sendTransaction: "Sign and send transaction",
      signMessage: "Sign message",
      signTransaction: "Sign transaction",
      signTypedData: "Sign typed data"
    },
    successfullySigned: "Request succesfully signed",
    walletConnectRequest: "WalletConnect request"
  },
  useNewUri: "This URI has already been used to attempt a connection. Please use a new URI.",
  walletConnect: "WalletConnect"
};
const warning$l = {
  receivePairing: "Please pair the BitBox to enable secure address verification. Go to 'Manage device' in the sidebar.",
  sdcard: "Keep the microSD card stored separate from the BitBox, unless you want to manage backups.",
  sendPairing: "Please pair the BitBox to securely verify transaction details. Go to 'Manage device' in the sidebar."
};
const welcome$f = {
  connect: "Connect BitBox02",
  getStarted: "Let's get started by installing firmware on your BitBox02.",
  insertBitBox02: "For the BitBox02, please tap the device to continue.",
  insertDevice: "Please connect your device to get started",
  title: "Welcome"
};
const appTranslationsEN = {
  account: account$f,
  accountInfo: accountInfo$f,
  accountSummary: accountSummary$f,
  addAccount: addAccount$g,
  aopp: aopp$9,
  app: app$f,
  auth: auth$9,
  backup: backup$f,
  bb02Bootloader: bb02Bootloader$f,
  bitbox: bitbox$f,
  bitbox02Interact: bitbox02Interact$f,
  bitbox02Settings: bitbox02Settings$f,
  bitbox02Wizard: bitbox02Wizard$f,
  bitsurance: bitsurance$8,
  bitsuranceAccount: bitsuranceAccount$8,
  blink: blink$f,
  bootloader: bootloader$f,
  button: button$k,
  buy: buy$b,
  changePin: changePin$f,
  chart: chart$b,
  checkSDcard: checkSDcard$f,
  clickHere: clickHere$f,
  confirm: confirm$h,
  confirmOnDevice: confirmOnDevice$f,
  connectKeystore: connectKeystore$9,
  darkmode: darkmode$9,
  device: device$f,
  deviceLock: deviceLock$f,
  deviceSettings: deviceSettings$f,
  deviceTampered: deviceTampered$f,
  dialog: dialog$g,
  error: error$b,
  fiat: fiat$h,
  footer: footer$h,
  generic: generic$b,
  genericError: genericError$f,
  goal: goal$f,
  guide: guide$g,
  headerssync: headerssync$f,
  hiddenWallet: hiddenWallet$f,
  initialize: initialize$f,
  invalidFormat: invalidFormat$f,
  language: language$g,
  legacyhiddenwallet: legacyhiddenwallet$f,
  loading: loading$f,
  manageAccounts: manageAccounts$9,
  mobile: mobile$a,
  newSettings: newSettings$8,
  note: note$b,
  notification: notification$f,
  pairing: pairing$f,
  passphrase: passphrase$9,
  password: password$f,
  random: random$g,
  receive: receive$h,
  reset: reset$f,
  securityInformation: securityInformation$f,
  seed: seed$f,
  seedRestore: seedRestore$f,
  send: send$h,
  settings: settings$g,
  setup: setup$f,
  sidebar: sidebar$g,
  success: success$m,
  transaction: transaction$g,
  transactions: transactions$f,
  unknownError: unknownError$f,
  unlock: unlock$f,
  upgradeFirmware: upgradeFirmware$g,
  walletConnect: walletConnect$a,
  warning: warning$l,
  welcome: welcome$f
};
const account$e = {
  disconnect: "Connexion perdue. Tentative de reconnexion…",
  "export": "Exporter",
  exportTransactions: "Exporter les transactions vers le dossier Téléchargements sous forme de fichier CSV",
  fatalError: "Une erreur inattendue s'est produite.",
  incoming: "Entrant",
  initializing: "Récupération d'informations de la blockchain…",
  insuranceExpired: "<strong>Le compte n'est plus assuré</strong>\n\nLe plan d'assurance pour ce compte a été modifié.\nVeuillez consulter la page d'assurance pour plus de détails.",
  insured: "Compte assuré",
  maybeProxyError: "Proxy Tor activé. Assurez-vous que votre proxy Tor fonctionne correctement, ou désactivez la configuration du proxy.",
  reconnecting: "Connexion perdue, tentative de reconnexion…",
  syncedAddressesCount: "{{count}} adresses scannées",
  uncoveredFundsLink: "Suivez ce guide pour savoir comment déplacer vos coins.",
  warning: "Avertissement !"
};
const accountInfo$e = {
  address: "Adresse",
  buyCTA: {
    buy: "Acheter {{unit}}",
    buyCrypto: "Acheter de la Crypto",
    information: {
      looksEmpty: "On dirait que ce portefeuille est vide",
      start: "Commencez par déposer des fonds dans le portefeuille ou bien achetez en directement dans l'application BitBoxApp."
    }
  },
  extendedPublicKey: "Clé publique étendue",
  label: "Informations du compte",
  scriptType: "Type de scrypt",
  title: "Informations sur le compte",
  verify: "Vérifier sur l'appareil",
  xpubTypeChangeBtn: {
    p2pkh: "Afficher la clé publique étendue (xpub) P2PKH legacy",
    p2tr: "Voir Taproot",
    p2wpkh: "Voir Native Segwit",
    "p2wpkh-p2sh": "Afficher l'ancienne clé publique étendue (xpub) Segwit"
  },
  xpubTypeInfo: "Affichage actuellement de la clé publique étendue {{scriptType}} ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$e = {
  availableBalance: "Solde disponible",
  balance: "Solde",
  exportSummary: "Exporter un extrait des comptes vers le dossier de Téléchargements sous forme de fichier CSV",
  fiatBalance: "Solde en devise",
  name: "Nom du compte",
  noAccount: "Il n'y a pas de compte à montrer.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Vue globale de mon portefeuille",
  total: "Total",
  transactionHistory: "Historique des transactions"
};
const addAccount$f = {
  chooseName: {
    nextButton: "Ajouter un compte",
    step: "Donner un nom au compte",
    title: "Donnez un nom à votre compte"
  },
  selectCoin: {
    nextButton: "Suivant",
    step: "Sélectionner un coin (pièce)",
    title: "Sélectionnez une crypto-monnaie"
  },
  success: {
    addAnotherAccount: "Ajouter un autre compte",
    message: "<strong>{{accountName}}</strong> a maintenant été ajouté à vos comptes.",
    nextButton: "Terminé",
    step: "Fini",
    title: "Compte ajouté"
  },
  title: "Ajouter un compte"
};
const aopp$8 = {
  addressRequest: "{{host}} exige une adresse de réception.",
  addressRequestWithLogo: "exige une adresse de réception.",
  banner: "Demande d'adresse en cours",
  errorTitle: "Erreur durant la demande d'adresse",
  labelAddress: "Adresse",
  labelMessage: "Message",
  reverifyInfoText: "Vérification de l'adresse",
  signing: "Afin de continuer, veuillez signer le message à l'aide de votre BitBox02",
  success: {
    message: "Continuer sur {{host}}",
    title: "Adresse envoyée avec succès"
  },
  syncing: "Synchronisation du compte, veuillez patienter.",
  title: "Demande d'adresse"
};
const app$e = {
  upgrade: "Une nouvelle version de cette application est disponible ! Veuillez mettre à jour de la {{current}} à la {{version}}."
};
const auth$8 = {
  authButton: "Authentification",
  title: "Veuillez vous authentifier pour continuer"
};
const backup$e = {
  check: {
    checking: "Vérification de la sauvegarde…",
    confirmTitle: "Vérifier la sauvegarde",
    notOK: "La sauvegarde ne correspond PAS à ce portefeuille.",
    ok: "La sauvegarde correspond au portefeuille.",
    password: {
      label: "Mot de passe de récupération",
      placeholder: "Mot de passe de récupération",
      showLabel: "mot de passe de récupération"
    },
    success: "Sauvegarde vérifiée avec succès :",
    title: "Vérifier la sauvegarde"
  },
  create: {
    alreadyExists: "Vous avez déjà une sauvegarde valide. Souhaitez-vous la recréer ?",
    fail: "La création de la sauvegarde a échoué !",
    info: "Veuillez saisir le mot de passe de récupération du portefeuille actuel pour vérification.",
    name: {
      label: "Nom de la sauvegarde",
      placeholder: "Veuillez nommer la sauvegarde"
    },
    password: {
      label: "Mot de passe de récupération",
      placeholder: "Veuillez entrer votre mot de passe de récupération"
    },
    title: "Créer une sauvegarde",
    verificationFailed: "Le mot de passe de récupération NE CORRESPOND PAS à ce portefeuille. La sauvegarde a été créée. Veuillez utiliser «Vérifier la sauvegarde» pour vérifier à nouveau votre mot de passe de récupération."
  },
  description: "Sélectionnez le <strong>fichier de sauvegarde du portefeuille</strong>.",
  insert: "Veuillez insérer la carte microSD pour gérer les sauvegardes.",
  insertButton: "J'ai inséré la carte microSD",
  list: "Vos sauvegardes sur la carte microSD",
  noBackups: "Il n'existe aucune sauvegarde sur cette carte micro SD.",
  restore: {
    confirmTitle: "Restaurer la sauvegarde",
    error: {
      e200: "Carte microSD non trouvée",
      general: "Erreur lors de la restauration de la sauvegarde"
    },
    password: {
      label: "Mot de passe de récupération ou mot de passe de récupération caché",
      placeholder: "Mot de passe de récupération",
      repeatPlaceholder: "Répéter le mot de passe de récupération",
      showLabel: "Mot de passe de récupération"
    },
    restoring: "Restauration de la sauvegarde…",
    selectedBackup: "<strong>{{backupName}}</strong> créé le {{createdDateTime}} sera restauré.",
    title: "Restaurer",
    understand: "Je comprends qu'un mot de passe de récupération incorrect créera un portefeuille différent."
  },
  showMnemonic: {
    description: "24 mots de récupération vont vous être présentés; ils constituent une sauvegarde de votre portefeuille. Notez-les sur papier.\n\n<strong>Ne les stockez pas sur un support numérique et ne les prenez pas en photo.</strong>\n\n<strong>Ne prononcez pas les mots à haute voix.</strong>\n\n<strong>Cette sauvegarde n'est pas protégée par un mot de passe.</strong>.\n\nIl vous sera demandé ensuite de confirmer chacun de ces mots.",
    title: "Montrer les mots de récupération",
    warning: "<strong>Ne partagez jamais vos mots de récupération avec qui que ce soit.</strong> Vos mots de récupération permettent un accès intégral à votre portefeuille. Si on vous demande vos mots de récupération, il s’agit d’une escroquerie, ne les partagez jamais !"
  },
  title: "Gérer les sauvegardes"
};
const bb02Bootloader$e = {
  abort: "Ne pas mettre à jour - Revenir en arrière",
  abort_noUpgrade: "Retour en arrière",
  advanced: {
    label: "Paramètres avancés",
    toggleShowFirmwareHash: "Afficher le hash du firmware à chaque démarrage de l'application"
  },
  flipscreen: "Retourner l'écran",
  orientation: "Appareil dans le mauvais sens ?",
  success: "Mise à jour réussie ! Continue dans {{rebootSeconds}} secondes...",
  success_install: "Installation réussie ! Poursuite dans {{rebootSeconds}} secondes..."
};
const bitbox$e = {
  error: {
    e10000: "Mot de passe de l'appareil incorrect.",
    e10001: "La tentative de remplacer le mot de passe de l'appareil a échoué",
    e102: "Le mot de passe doit comporter au minimum 4 caractères.",
    e112: "Le mot de passe caché ne peut pas être identique au mot de passe principal de l'appareil."
  }
};
const bitbox02Interact$e = {
  confirmDate: "Confirmez la date du jour sur votre BitBox02",
  confirmDateText: "Cette date sera utilisée pour créer votre sauvegarde.",
  confirmName: "Confirmez le nom sur le BitBox02",
  confirmWords: "Notez les {{amount}} mots de récupération depuis votre BitBox02",
  confirmWordsText: "Ensuite, la BitBox02 vous demandera de confirmer chaque mot afin de s’assurer que la sauvegarde a été correctement effectuée.",
  followInstructions: "Veuillez suivre les instructions sur votre BitBox02.",
  followInstructionsMnemonic: "Suivez les instructions sur votre BitBox02 afin de saisir les mots de récupération de votre sauvegarde et restaurer ainsi votre portefeuille.",
  followInstructionsMnemonicTitle: "Restaurer à partir des mots de récupération"
};
const bitbox02Settings$e = {
  deviceName: {
    current: "Nom du périphérique actuel",
    error: "Le nom de l'appareil n'a pas pu être configuré",
    error_104: "La confirmation du nom de l'appareil a été interrompu sur celui-ci.",
    input: "Nom du BitBox02",
    placeholder: "Nouveau nom de périphérique",
    title: "Définir le nom de votre BitBox02"
  },
  gotoStartupSettings: {
    description: "Cela va rebooter votre BitBox02 et entrer les paramètres de démarrage.",
    title: "Aller aux paramètres de démarrage"
  }
};
const bitbox02Wizard$e = {
  advanced: {
    button: "Options avancées",
    outOfDate: "Le micrologiciel n'est pas à jour et ne permet pas cette fonctionnalité",
    seed12WordInfo: "Veuillez noter que le nombre de mots ne peut pas être modifié après la création du portefeuille.",
    seed12WordLabel: "Créer une seed de 12 mots plutôt que de 24 mots",
    seed12WordText: "Par défaut, la BitBox02 utilise une seed de 24 mots. Dans la pratique, les deux longueurs de seed sont fiables contre les attaques par force brute. Toutefois, certains utilisateurs peuvent préférer la commodité inhérente à une seed de 12 mots.",
    skipSDCardLabel: "Sauter l’étape de sauvegarde sur la carte microSD et écrire les mots de récupération plutôt.",
    skipSDCardText: "Vous avez toujours la possibilité de créer une sauvegarde sur la carte microSD ou d'écrire vos mots de récupération après la configuration. Vous pouvez le faire à partir des paramètres.",
    title: "Options de sauvegarde avancées"
  },
  attestationFailed: "L'authentification a échoué. Ceci est potentiellement dû au redémarrage de l'application alors que l'appareil attendait une saisie de la part de l'utilisateur. Veuillez vous reconnecter et essayer à nouveau. Si cela persiste, veuillez contacter support@bitbox.swiss",
  backup: {
    point1: "Sélectionner une sauvegarde sur la carte micro SD",
    point2: "Définissez un mot de passe pour votre appareil",
    restoreText: "Ok, restaurons une sauvegarde !",
    text1: "Parfait, le mot de passe pour votre BitBox02 est défini et votre portefeuille est créé. Il est maintenant temps de procéder à votre première sauvegarde. Assurez-vous que la carte micro SD soit bien insérée dans l'appareil et continuez.",
    text2: "Veuillez suivre les instructions sur l'écran de votre appareil pour créer une sauvegarde.",
    text3: "Une fois votre sauvegarde créée, veuillez retirer la carte micro SD et la conserver dans un endroit <strong>sécurisé</strong>. Le contenu de la carte micro SD n'est pas protégé par mot de passe. Ne l'insérez jamais dans un appareil autre que votre BitBox02.",
    userConfirmation1: "Je devrais stocker ma sauvegarde dans un endroit sûr.",
    userConfirmation2: "Ma sauvegarde n'est pas protégée par mot de passe. Quiconque y a accès peut accéder à mon portefeuille.",
    userConfirmation3: "Si je perds ou endommage mon BitBox02, la seule façon de récupérer mes fonds est de restaurer à partir de ma sauvegarde.",
    userConfirmation4: "Si je perds ou endommage à la fois ma sauvegarde et ma BitBox02, mes fonds seront perdus.",
    userConfirmation5: "Je ne dois pas insérer ma carte de sauvegarde microSD dans un ordinateur, un téléphone, une imprimante ou tout appareil autre qu'un BitBox02.",
    userConfirmation5mnemonic: "Je ne dois pas saisir mes mots de récupération dans un ordinateur, un téléphone, une imprimante ou tout autre appareil autre qu'une BitBox02."
  },
  create: {
    button: "Nommer l'appareil et continuer",
    info: "Voici les étapes de base à suivre pour configurer votre BitBox :",
    inputTitle: "Nom du portefeuille",
    point1: "Nommez votre appareil",
    point2: "Définir un mot de passe pour votre appareil",
    point3: "Créer une sauvegarde",
    text: "Ok, créons un nouveau portefeuille !"
  },
  createBackupAborted: "Création de la sauvegarde interrompue.",
  createBackupFailed: "La création de la sauvegarde a échoué, veuillez réessayer.",
  initialize: {
    passwordText: "Définissons maintenant un mot de passe pour votre appareil. Utilisez les commandes de votre BitBox pour entrer et choisir un mot de passe.",
    passwordTitle: "Définissez un mot de passe pour votre BitBox",
    text: "Votre BitBox02 a été appairé avec succès ! Initialisons maintenant votre appareil. Commencez par choisir de créer un nouveau portefeuille ou de restaurer un portefeuille à partir d'une sauvegarde existante. <strong>Veuillez vous assurer que vous avez une carte micro SD insérée dans votre BitBox02</strong>.",
    tip: "Nous recommandons de continuer dans un environnement sécurisé.",
    title: "Initialiser votre BitBox"
  },
  insertSDCard: "<strong>Assurez-vous d'avoir une carte micro SD insérée dans votre BitBox02.</strong>",
  noPasswordMatch: "Le mot de ",
  pairing: {
    failed: "Appariement non confirmé. Veuillez rebrancher votre BitBox02.",
    paired: "Vous avez confirmé le code suivant sur votre appareil. Veuillez continuer.",
    title: "Vérifier le code d'appairage",
    unpaired: "Une BitBox02 non-associée a été détectée. Veuillez vérifier que le code d’association correspond à celui indiqué sur votre BitBox02."
  },
  restoreFromMnemonic: {
    e104: "La restauration à partir des mots de récupération a été annulée.",
    failed: "La restauration à partir des mots de récupération a échoué, veuillez réessayer."
  },
  stepBackup: {
    beforeProceed: "Avant de continuer, veuillez lire ces importantes mesures de sécurité :",
    createBackup: "Vous allez maintenant créer une sauvegarde sur votre carte microSD.",
    createBackupMnemonic: "Vous allez à présent noter les mots de récupération."
  },
  stepBackupSuccess: {
    fundsSafe: "Pour assurer la sécurité de vos fonds, n'oubliez pas ce qui suit :",
    title: "Sauvegarde restaurée !"
  },
  stepConnected: {
    unlock: "Entrez le mot de passe du BitBox02 pour le déverrouiller."
  },
  stepCreate: {
    description: "Ce nom est utilisé comme celui de l'appareil et pour la sauvegarde.",
    nameLabel: "Nom du BitBox02",
    namePlaceholder: "Mon BitBox02",
    title: "Choisissez le nom du BitBox02",
    toastMicroSD: "Veuillez insérer votre carte microSD dans votre BitBox02, elle sera utilisée pour stocker une sauvegarde du portefeuille."
  },
  stepCreateSuccess: {
    removeMicroSD: "Veuillez retirer la carte microSD de votre BitBox02 et la stocker dans un endroit sûr.",
    storeMnemonic: "Veuillez conserver vos mots de récupération dans un emplacement sûr",
    success: "Vous avez créé votre sauvegarde avec succès."
  },
  stepInsertSD: {
    insertSDCard: "Veuillez insérer une carte microSD dans votre BitBox02 pour continuer.",
    insertSDcardTitle: "Insérer une carte microSD"
  },
  stepPassword: {
    e104: "Le paramétrage du mot de passe a été abandonné.",
    title: "Définissez le mot de passe du BitBox02",
    useControls: "Utilisez les touches de votre BitBox02 pour définir un mot de passe."
  },
  stepUninitialized: {
    create: "Je veux configurer un nouveau BitBox02.",
    restore: "Je veux restaurer mon portefeuille à partir d'une sauvegarde.",
    restoreMicroSD: "Restauration à partir d'une carte microSD",
    restoreMnemonic: "Restaurer à partir des mots de récupération",
    title: "Configurez votre BitBox02"
  },
  success: {
    text: "Hourra ! Votre BitBox02 est maintenant prêt à l'emploi. \n\nPour plus d'informations sur l'utilisation de l'application BitBox, veuillez utiliser le guide d'utilisation en cliquant sur le point d'interrogation situé dans le coin supérieur droit.",
    title: "Vous êtes prêt !"
  }
};
const bitsurance$7 = {
  dashboard: {
    active: "Police d'assurance active",
    button: "Assurer un nouveau compte",
    canceled: "Annulé",
    coverage: "Couverture maximale",
    inactive: "Inactif",
    processing: "Traitement",
    refused: "Refusé",
    supportLink: "Gestion du contrat",
    title: "Comptes assurés",
    waitpayment: "En attente de paiement"
  },
  detect: {
    button: "Vérification de l'existence d'une assurance",
    insured: "Compte assuré détecté :",
    notInsured: "Aucun compte assuré n'a pu être détecté. Si vous êtes certain d'avoir un compte assuré, vérifiez d'avoir bien connecté le wallet correspondant.",
    text: "Si vous avez déjà souscrit à Bitsurance, l'application BitBoxapp peut se synchroniser automatiquement avec votre couverture d'assurance existante.",
    title: "Déjà assuré ?"
  },
  insure: {
    button: "Vérifier la disponibilité et les tarifs",
    faq: "Plus d'informations sur les FAQs de Bitsurance",
    listItem1: "Cambriolage",
    listItem2: "Extorsion (par exemple: attaque avec un objet contondant)",
    listItem3: "Destruction due au feu, à l'eau ou autres catastrophes naturelles",
    month: "mois",
    text: "Assurez votre BitBox02 et jusqu'à une valeur de 100 000 € en Bitcoin",
    text3: "Disponible actuellement en Allemagne, avec d'autres zones géographiques à suivre.",
    title: "Démarrer"
  },
  intro: {
    link: "Site web de Bitsurance",
    text1: "BitBox travaille conjointement avec Bitsurance pour ajouter une couche de protection supplémentaire à vos bitcoins. Alors que BitBox02 assure la sécurité de vos fonds, Bitsurance couvre les menaces domestiques qui ne peuvent être prises en charge par la technologie seule, comme par exemple le cambriolage, l'extorsion ou bien la destruction du hardware wallet lui-même."
  },
  terms: {
    link: "Politique de confidentialité de Bitsurance",
    text1: "Bitsurance est un service tiers indépendant. Pour toute question concernant leurs offres et les demandes d'assurance, veuillez contacter Bitsurance directement.",
    text2: "L'assurance est actuellement disponible en Allemagne, avec d'autres zones géographiques à suivre",
    text3: "La couverture Bitcoin maximale actuellement disponible est de 100 000 euros par personne. Des montants plus élevés sont prévus à l'avenir.",
    text4: "Des informations personnelles ainsi que la clé publique étendue de votre compte assuré font partie de la police d'assurance et seront partagées avec Bitsurance et le courtier."
  },
  title: "Assurance"
};
const bitsuranceAccount$7 = {
  errorNoXpub: "Erreur : Il n'a pas été possible d'obtenir la xpub de ce compte.",
  noAccount: "Aucun compte ne peut être assuré.",
  select: "Sélectionner un compte",
  title: "Assurance"
};
const blink$e = {
  button: "Clignoter"
};
const bootloader$e = {
  button: "Mettre à jour le micrologiciel maintenant",
  button_install: "Installer le firmware maintenant",
  progress: "Mise à jour : {{progress}}%",
  progress_install: "Installation : {{progress}}%",
  success: "Mise à jour réussie ! Veuillez rebrancher l'appareil. Cette fois, ne touchez pas le bouton."
};
const button$j = {
  abort: "Abandonner",
  back: "Retour",
  buy: "Acheter",
  changepin: "Changer le mot de passe de l'appareil",
  check: "Vérifier la sauvegarde",
  "continue": "Continuer",
  copy: "Copie",
  create: "Créer",
  dismiss: "Ignorer",
  done: "Terminé",
  download: "Télécharger",
  hiddenwallet: "Créer un portefeuille caché",
  next: "Suivant",
  ok: "D'accord",
  previous: "Précédent",
  receive: "Recevoir",
  restore: "Restaurer",
  select: "Sélectionner",
  send: "Envoyer",
  unlock: "Déverrouiller",
  update: "Mise à jour",
  upgrade: "Mettre à jour"
};
const buy$a = {
  exchange: {
    bankTransfer: "Virement bancaire",
    bestDeal: "Meilleure offre",
    creditCard: "Carte de crédit",
    fast: "Rapide",
    fee: "frais",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Virement Bancaire: {{fee}}%",
          creditDebitCard: "Carte de crédit/débit: {{fee}}%",
          learnMore: "En savoir plus sur Moonpay",
          title: "Frais"
        },
        fullCurrenciesList: "Voir la liste complète des devises ici",
        payment: {
          asteriskText: "* Non disponible pour les résidents américains",
          bankTransfer: "Virement bancaire*",
          bankTransferDetails: {
            pix: "PIX (transactions BR au Brésil uniquement)",
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          creditDebitCard: "Carte de crédit/débit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "Voir plus de détails sur les méthodes de paiement",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte toutes les principales devises fiat : USD, EUR, CHF, et autres."
      },
      pocket: {
        fees: {
          info: "Virement bancaire : {{fee}}%",
          title: "Frais"
        },
        learnMore: "En savoir plus sur Pocket",
        payment: {
          bankTransfer: "Virement bancaire",
          bankTransferDetails: {
            sepa: "SEPA et SEPA Instant (transactions en EUR dans les pays SEPA uniquement)",
            sic: "SIC - Swiss Interbank Clearing (Transactions CHF en Suisse/Liechtenstein uniquement)",
            uk: "UK Faster Payments (transactions en GBP au Royaume-Uni uniquement)"
          },
          bankTransferReccuring: "Comment mettre en place des achats récurrents avec un ordre permanent?",
          title: "Modes de paiement"
        },
        supportedCurrencies: "Accepte les devises Européennes : EUR, GBP et CHF",
        verification: {
          info: "La vérification de l'identité n'est requise qu'au-delà des limites quotidiennes et annuelles.",
          link: "Consulter les limites en vigueur, ici.",
          title: "Vérification de l'identité"
        }
      },
      region: {
        title: "Sélectionnez la zone géographique de domiciliation de votre compte bancaire afin de déterminer les options à votre disposition."
      }
    },
    noExchanges: "Désolé, aucun échange disponible dans cette zone géographique",
    region: "Zone Géographique",
    selectRegion: "Non spécifié",
    title: "Acheter du {{name}}"
  },
  info: {
    "continue": "Accepter et continuer",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nous avons un partenariat avec MoonPay afin de vous permettre d'acheter simplement des {{name}} directement depuis BitBoxApp. Quelques clics suffisent.",
        "MoonPay est une plateforme qui permet d’acheter des {{name}} de manière simple et rapide dans plus de 160 pays."
      ],
      payment: {
        details: "Vous pouvez acheter des {{name}} instantanément via MoonPay avec les méthodes de paiement suivantes. Les achats par carte de crédit ou de débit sont faciles et instantanés, mais plus chers en raison du risque de rétro-facturation plus élevé. Nous vous recommandons d'utiliser l'option du virement bancaire pour les montants plus importants. Les frais minimum sont de 4 USD/EUR ou équivalent.",
        footnote: "Veuillez noter que les taux de change de MoonPay peuvent différer de ceux utilisés dans BitBoxApp, ce qui peut entraîner potentiellement des montants légèrement différents.",
        table: {
          "1_description": "Frais les plus bas, peut prendre jusqu'à 3 jours ouvrables",
          "1_method": "Virements bancaires (SEPA)",
          "2_description": "Frais plus élevés mais rapides et directs",
          "2_method": "Cartes de crédit et de débit",
          description: "Description",
          fee: "Frais",
          method: "Méthode"
        },
        title: "Modes de paiement et frais"
      },
      privacyPolicy: "Politique de confidentialité de MoonPay",
      protection: {
        description: "BitBoxApp ne collecte aucune donnée lors de l'achat de {{name}}, les fonds entrants sont traités comme une transaction normale. MoonPay a besoin de collecter certaines données personnelles afin de fonctionner. Leur politique de confidentialité décrit en détail la façon dont ces données sont traitées.",
        descriptionGeneric: "BitBoxapp ne collecte aucune donnée lors de l'achat de {{nom}}, les fonds entrants sont traités comme une transaction normale. Cependant, les exchanges partenaires ont besoin de recueillir certaines informations pour fonctionner. Veuillez vous référer à leurs politiques de confidentialité respectives pour voir plus en détail comment sont traitées ces données.",
        title: "Protection des données"
      },
      security: {
        description: "Lorsque vous achetez du {{name}} via MoonPay, vous utilisez un service externe. Ce service est hors de portée du modèle sécurité contre les menaces de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé.",
        descriptionGeneric: "Lorsque vous achetez du {{nom}} via un exchange partenaire, vous utilisez un service externe. Ce service est hors de portée du modèle sécurité contre les menaces de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé.",
        link: "Modèle de menace à la sécurité",
        title: "Modèle de sécurité"
      },
      title: "Bienvenue sur la boutique de votre site clé en main pour acheter du {{name}}"
    },
    next: "Suivant",
    selectLabel: "Sélectionnez votre compte",
    selectPlaceholder: "Sélectionnez un coin (monnaie)",
    skip: "Ne plus montrer",
    title: "Acheter du {{name}}"
  },
  pocket: {
    data: {
      link: "Politique de confidentialité de Pocket",
      p1: "BitBoxApp ne recueille aucune donnée lors de l'achat de bitcoins, les fonds entrants sont traités comme une transaction ordinaire. Pocket a besoin de collecter certaines données personnelles pour son fonctionnement. La politique de confidentialité de Pocket expose en détail la manière dont elles sont exploitées.",
      title: "Protection des données"
    },
    kyc: {
      link: "Lire la FAQ de Pocket",
      p1: "Pocket s'efforce de réduire au minimum le processus d’identification (KYC). Pour les achats inférieurs à 950 EUR (1000 CHF) par jour, aucun document supplémentaire n'est requis. Pour les achats supérieurs à ce montant, vous devrez fixer un rendez-vous téléphonique avec Pocket au préalable afin de compléter le processus Identification/Lutte Contre le Blanchiment (KYC/AML) nécessaire.",
      title: "Identification/Lutte Contre le Blanchiment (KYC/AML)"
    },
    payment: {
      p1: "Vous avez la possibilité d’acheter des bitcoins instantanément avec Pocket via un transfert bancaire SEPA. Les frais sont de 1,5% et les bitcoins sont déposés dans votre BitBox dès que possible, une fois le virement bancaire  reçu par Pocket (généralement le jour même).",
      p2: "Veuillez noter que les taux de change de Pocket peuvent différer de ceux utilisés par BitBoxApp,et avoir pour effet des montants légèrement différents.",
      title: "Modes de paiement et frais"
    },
    previousTransactions: "L'historique des transactions de ce compte n'est pas vierge. En partageant ce compte, toutes ses transactions passées et futures seront exposées à Pocket. Souhaitez-vous continuer malgré tout ?",
    security: {
      link: "Modèle de menace de sécurité de BitBox02",
      p1: "Lorsque vous achetez des bitcoins via Pocket, vous utilisez un service externe. Ce service est hors de portée du modèle de menace de sécurité de BitBox02 et repose sur la sécurité de l'environnement dans lequel le logiciel BitBoxApp est déployé. Cependant, nous collaborons dans le but de renforcer la sécurité en utilisant un mécanisme d'authentification à deux facteurs pour vérifier l'adresse sur laquelle vous les recevez.",
      title: "Modèle de sécurité"
    },
    usedAddress: "L'adresse {{adresse}} a déjà été utilisée, veuillez recommencer avec une nouvelle adresse.",
    verifyBitBox02: "Veuillez vérifier que l'adresse que vous avez reçue par email correspond à celle affichée sur votre Bitbox. Si vous en avez la possibilité, vous devriez ouvrir l'email sur un deuxième appareil pour plus de sécurité.",
    welcome: {
      p1: "Nous collaborons avec Pocket afin de vous offrir un processus simplifié pour vos achats de bitcoins directement dans l'application BitBox. Quelques clics suffisent.",
      p2: "Pocket est une plateforme suisse qui permet d'acheter rapidement et facilement des bitcoins depuis la plupart des pays européens (partout où les transferts bancaires SEPA sont disponibles).",
      p3: "Avec Pocket, vous pouvez également effectuer des achats réguliers par le biais d'ordres bancaires récurrents, vous donnant ainsi la possibilité d'effectuer facilement un lissage de votre prix d'acquisition (DCA).",
      title: "Bienvenue dans votre espace unique et complet dédié à l'achat de bitcoins."
    }
  },
  title: "Acheter du {{name}}"
};
const changePin$e = {
  newTitle: "Nouveau mot de passe de l'appareil",
  oldLabel: "Mot de passe actuel de l'appareil"
};
const chart$a = {
  dataMissing: "Récupération de l’historique des données… soyez patients.",
  dataOldTimestamp: "Mise à jour de l’historique des taux de change. Le graphique ne tient pas compte des données après {{time}}.",
  dataUpdating: "mise à jour des données...",
  filter: {
    all: "Tout",
    month: "Mois",
    week: "Semaine",
    year: "Année"
  }
};
const checkSDcard$e = "vérification de la carte microSD";
const clickHere$e = "Cliquez ici.";
const confirm$g = {
  abortInfo: "Appuyez pour",
  abortInfoRedText: "abandonner",
  approveInfo: "Appuyez 4+ secondes pour",
  approveInfoGreenText: "confirmer",
  info: "Continuez sur votre BitBox",
  infoWhenPaired: "D'abord sur le mobile appairé, puis sur votre BitBox"
};
const confirmOnDevice$e = "Veuillez confirmer sur l'appareil.";
const connectKeystore$8 = {
  promptNoName: "Veuillez connecter votre BitBox02 pour continuer",
  promptWithName: 'Veuillez connecter votre BitBox02 dénommée "{{name}}" pour continuer'
};
const darkmode$8 = {
  toggle: "Dark mode"
};
const device$e = {
  appUpradeRequired: "Votre BitBox n'est pas compatible avec cette version de l'application de bureau. Veuillez télécharger et installer la dernière version.",
  keystoreConnected: "Wallet connecté"
};
const deviceLock$e = {
  button: "Activer la double authentification (2FA)",
  condition1: "Avez-vous une sauvegarde ?",
  condition2: "Est-ce que la vérification avec l'application mobile fonctionne-t-elle ?",
  condition3: "Le 2FA DÉSACTIVE les sauvegardes et l'appariement à l'application mobile. L'appareil doit être RÉINITIALISÉ pour enlever le 2FA !",
  confirm: "Activer la double authentification (2FA)",
  title: "Activer la double authentification (2FA)"
};
const deviceSettings$e = {
  backups: {
    manageBackups: {
      description: "Créez ou vérifiez la sauvegarde de votre carte microSD."
    },
    showRecoveryWords: {
      description: "Afficher et vérifier les mots de récupération."
    },
    title: "Sauvegardes"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp vérifie l'authenticité de votre appareil."
    },
    deviceName: {
      description: "Modifiez le nom de votre appareil."
    },
    rootFingerprint: {
      description: "L'empreinte digitale racine est un identifiant unique du portefeuille en cours d'utilisation. Elle peut vous aider à distinguer les différents portefeuilles si vous utilisez des passsphrases."
    },
    securechip: {
      description: "Modèle de la puce sécurisée."
    },
    title: "Informations sur l'appareil"
  },
  expert: {
    factoryReset: {
      description: "Réinitialisez votre appareil aux paramètres d'usine. Cela supprimera le wallet de votre BitBox02 !",
      title: "Réinitialisation aux paramètres d'usine"
    },
    goToStartupSettings: {
      description: "Entrez le bootloader de la BitBox02. Vous pouvez activer le hachage du micrologiciel à partir de là."
    },
    passphrase: {
      description: "Activer ou désactiver la fonction de passphrase (phrase secrète)",
      title: "Passphrase (phrase secrète)"
    }
  },
  firmware: {
    firmwareVersion: "Version du Firmware",
    newVersion: {
      label: "Version disponible"
    },
    title: "Micrologiciel",
    upToDate: "Votre appareil est à jour",
    upgradeAvailable: "Nouvelle mise à jour disponible",
    version: {
      label: "Version"
    }
  },
  hardware: {
    attestation: {
      "false": "Échec du contrôle d'authenticité",
      label: "Contrôle d'authenticité",
      "true": "Votre BitBox02 est authentique"
    },
    sdcard: {
      "false": "Non insérée",
      label: "carte microSD",
      "true": "Insérée"
    },
    securechip: "Puce sécurisée",
    title: "Matériel informatique"
  },
  loading: "Récupération des informations sur l'appareil…",
  pairing: {
    lock: {
      "false": "Désactivé",
      label: "Double authentification (2FA)",
      "true": "Activé"
    },
    mobile: {
      "false": "Fermé",
      label: "Application mobile",
      "true": "Ouvrir"
    },
    status: {
      "false": "Non appairé",
      label: "Statut",
      "true": "Appairé"
    },
    title: "Appariement"
  },
  secrets: {
    manageBackups: "Gérer les sauvegardes",
    title: "Secrets"
  }
};
const deviceTampered$e = "Est-ce que votre BitBox a été fourni avec un mot de passe de récupération ? Si c'est le cas, arrêtez la procédure d'installation et contactez immédiatement le support. Shift ne vous donnera jamais un portefeuille prêt à l'emploi ni de recommandation de mot de passe.";
const dialog$f = {
  cancel: "Annuler",
  confirm: "Confirmer",
  confirmTitle: "Confirmation"
};
const error$a = {
  accountAlreadyExists: "Ce compte existe déjà.",
  accountLimitReached: "Impossible d'ajouter un compte. Le nombre maximum de comptes pour ce coin (monaie) a été atteint.",
  aoppCallback: "Une erreur s'est produite lors de la transmission de l'adresse à {{host}}.",
  aoppInvalidRequest: "Requête invalide.",
  aoppNoAccounts: "Aucun comptes disponibles.",
  aoppSigningAborted: "Demande de possession de l'adresse annulée.",
  aoppUnknown: "Une erreur inconnue s'est produite.",
  aoppUnsupportedAsset: "Cet actif n'est pas pris en charge.",
  aoppUnsupportedFormat: "Aucun des comptes disponibles ne supporte le format d'adresse requis.",
  aoppUnsupportedKeystore: "L’appareil connecté ne peut pas signer de messages pour cet asset.",
  aoppVersion: "Version inconnue.",
  wrongKeystore: "Portefeuille connecté incorrect. Veuillez vous assurer d'insérer le bon appareil correspondant à ce compte",
  wrongKeystore2: "Si vous utilisez la passphrase facultative, assurez-vous bien que vous avez saisi la passphrase correspondant à ce compte."
};
const fiat$g = {
  "default": "défaut",
  setDefault: "Définir {{code}} comme paramètre par défaut",
  title: "Devises"
};
const footer$g = {
  appVersion: "Version de l'application :"
};
const generic$a = {
  enabled_false: "Désactivé",
  enabled_true: "Activé"
};
const genericError$e = "Une erreur est survenue. Si vous rencontrez des problèmes, veuillez redémarrez l'application.";
const goal$e = {
  buttons: {
    create: "Créer un nouveau portefeuille",
    restore: "Restaurer un portefeuille à partir d'une sauvegarde"
  },
  paragraph: "Veuillez sélectionner l'une des options suivantes :",
  step: {
    "1": {
      title: "Information de sécurité"
    },
    "2": {
      description: "Définir un mot de passe pour l'appareil",
      title: "Appareil"
    },
    "3-create": {
      description: "Créer un nouveau portefeuille",
      title: "Portefeuille"
    },
    "3-restore": {
      description: "à partir d'une sauvegarde",
      title: "Restaurer"
    },
    "4-create": {
      title: "Résumé"
    },
    "4-restore": {
      title: "Résumé"
    }
  }
};
const guide$f = {
  accountDescription: {
    text: `La vue d'ensemble de votre compte affiche votre solde disponible ainsi que les transactions entrantes et sortantes. Notre guide dans "Paramètres" contient plus d'informations sur chaque type de compte. `,
    title: "Que me montre cette page ?"
  },
  accountFiat: {
    text: "Oui. Cliquez sur n'importe quel symbol pour changer la devise. Vous pouvez modifier la liste des devises dans les paramètres.",
    title: "Puis-je afficher d'autres taux de conversion ?"
  },
  accountIncomingBalance: {
    text: "Entrant est la somme des montants qui vous ont été transférés mais qui n'ont pas encore été confirmés par le réseau.",
    title: "Que veut dire entrant ?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Chaque xpub est liée au "Type" indiqué : soit "Native Segwit (bech32)", "Wrapped Segwit" ou "Taproot" (Bitcoin uniquement). Ce sont les types de script utilisés par {{coinName}}. BitBoxApp les combine, prenant en charge plusieurs types de script dans le même compte. Comme chaque type de script donne une xpub différente, il y a plusieurs xpubs par compte.

Si vous recevez systématiquement sur l'adresse par défaut (Native Segwit), vous n'avez besoin que de la xpub "bech32". Cependant, si vous recevez également des fonds sur "Wrapped Segwit" ou "Taproot", vous devez également utiliser respectivement les clés publiques étendues "Wrapped Segwit" et "Taproot".`,
      title: "Pourquoi y a-t-il plusieurs xpubs ?"
    },
    privacy: {
      text: "Pour ce compte spécifique, la clé publique étendue révèle l'ensemble de l'historique des opérations, le solde de votre compte et toutes les transactions futures. Mais la xpub ne permet à personne de dépenser vos coins (monnaie).\n\nSi vous communiquez une xpub à quelqu'un, vous devez être conscient que cette personne ou entreprise peut visualiser toutes les autres transactions de ce même compte. Par conséquent, c'est une bonne idée d'utiliser ce compte uniquement à cette fin et de garder les autres fonds sur des comptes distincts.",
      title: "Est-ce que je dois garder ma xpub secrète ?"
    },
    verify: {
      text: "Oui, c'est toujours une bonne initiative de revérifier votre xpub. Si un tiers va générer des adresses de réception à partir de cette xpub pour vous envoyer de l'argent, c'est tout particulièrement important. Vous devez la vérifier sur l'appareil afin de vous assurer que cette xpub vous appartient; sinon, l'ensemble des fonds pourraient être envoyés à des adresses non voulues.",
      title: "Est-ce que je dois vérifier la xpub sur l'appareil ?"
    },
    xpub: {
      text: `Une clé publique étendue (xpub) est une clé racine à partir de laquelle toutes les adresses de réception d'un compte sont dérivées.

Elle sont fournies ici à des fins d'utilisation avancée et d'interopérabilité avec les portefeuilles de type "watch-only", comme Electrum ou Sentinel. Si vous recevez des fonds sur différents types d'adresses, veuillez importer tous les différents formats xpub dans le portefeuille "watch-only" afin de pouvoir visualiser tous vos fonds.

Veuillez noter que certains portefeuilles tiers ne supportent pas encore les xpubs Taproot.`,
      title: "Qu'est-ce qu'une clé publique étendue ?"
    }
  },
  accountRates: {
    text: "Les taux de change sont mis à jour toutes les minutes à partir de CoinGecko.",
    title: "Quels taux de change sont utilisés ?"
  },
  accountReload: {
    text: "Il n'y a pas besoin. Vos informations de transaction sont mises à jour automatiquement.",
    title: "Puis-je recharger l'historique des transactions ?"
  },
  accountSendDisabled: {
    text: 'Le bouton "Envoyer" est activé lorsque votre solde est supérieur à zéro.',
    title: "Pourquoi ne puis-je pas envoyer de {{unit}} ?"
  },
  accountSummaryAmount: {
    text: "Le montant total est la somme de tous vos comptes crypto. Les taux de change sont obtenus auprès de coingecko.com.\n\nRemarque : si vous utilisez MyEtherWallet pour des tokens (jetons) non pris en charge par BitBoxApp, ils ne seront pas inclus dans le montant affiché.",
    title: "Comment le montant total est-il calculé ?"
  },
  accountSummaryDescription: {
    text: "Vous pouvez voir ici la performance de votre portefeuille au fil du temps. Un résumé de vos comptes cryptos individuels est affiché sous le graphique.",
    title: "Que me montre cette page ?"
  },
  accountTransactionAttributesBTC: {
    text: "Taille virtuelle : détermine les frais de réseau. Vous avez réussi à économiser sur les frais si elle est inférieure à la taille de la transaction.\nTaille : Taille réelle de la transaction en octets dépendamment de la blockchain concernée.\nPoids : Une nouvelle mesure, introduite avec Segwit, permettant d'évaluer la transaction et la taille du bloc. Chaque octet témoin est séparé et compte pour un, le reste en tant que quatre unités de poids. Au lieu d'un mégaoctet de taille réelle, la limite de taille de bloc est maintenant de quatre millions d'unités de poids.",
    title: "Qu'en est-il des détails spécifiques de la transaction Bitcoin ?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmations : Lors de l'émission de votre transaction, elle ne sera pas confirmée. Vous devrez attendre qu'un mineur l'inclue dans un bloc, elle aura alors une confirmation. Chaque bloc émis sur le réseau par la suite ajoutera une nouvelle confirmation à votre transaction. En général, les commerçants et autres acteurs de l'écosystème considèrent comme valides les transactions ayant entre 3 et 6 confirmations.\nTransaction ID : Numéro d'identification unique pouvant être utilisé pour rechercher une transaction dans un explorateur de blocs.\nFrais : Les mineurs reçoivent des frais de transaction afin de les inciter à intégrer les transactions dans les blocs qu'ils minent. Pour en savoir plus, cliquez sur le bouton d'envoi.",
    title: "Quelles sont les informations affichées dans le détail de la transaction?"
  },
  accountTransactionConfirmation: {
    text: "Il s’agit d’une transaction qui a été émise sur le réseau et en attente d’être confirmée.",
    title: "Qu'est-ce qu'une transaction en attente ?"
  },
  accountTransactionLabel: {
    text: "C'est l'adresse vous ayant envoyé les coins ou à laquelle vous les avez envoyés.",
    title: "Quelle adresse est affichée pour chaque transaction?"
  },
  accountTransactionTime: {
    text: "L'heure et la date à laquelle la transaction a été confirmée sur la blockchain.",
    title: "Quel horodatage est affiché ?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin et Litecoin ne peuvent avoir qu’un nombre arbitraire de comptes. Au delà de cinq comptes, vous ne pouvez en ajouter un supplémentaire que si le compte précédent a déjà été utilisé. \nUn maximum de cinq comptes est possible pour les autres coins (jetons).",
      title: "Combien de comptes puis-je créer ?"
    },
    howtoAddTokens: {
      text: `Les jetons utilisant la norme ERC20 sont rattachés à un compte Ethereum spécifique. Pour activer ou désactiver un jeton en particulier, ouvrez l'écran "Gérer les comptes", élargissez votre compte Ethereum et activez ou désactivez le jeton souhaité.`,
      title: "Comment ajouter des jetons supplémentaires ?"
    },
    moveFunds: {
      text: "Oui. Mais comme les comptes sont indépendants, vous devez envoyer vos fonds en utilisant une transaction classique.",
      title: "Est-ce que je peux déplacer des fonds entre les différents comptes ?"
    },
    recoverAccounts: {
      text: "Oui. BitBoxApp crée des comptes en utilisant des normes bien établies et compatibles avec la plupart des autres portefeuilles de crypto-monnaies.",
      title: "Est-ce que je peux récupérer mes comptes avec d'autres portefeuilles ?"
    },
    whatAreAccounts: {
      text: "Votre portefeuille peut gérer plusieurs comptes pour un même coin (monnaie). Les différents comptes sont utiles lorsque vous souhaitez conserver des fonds séparément.",
      title: "Qu'est-ce qu'un compte ?"
    },
    whyIsThisUseful: {
      text: `Les comptes sont parfaits pour gérer des fonds destinés à des personnes ou des objectifs différents, car ils sont distincts. Vous pouvez également partager la "clé publique étendue" (xpub) d'un compte sans rien dévoiler de vos autres comptes. Cela vous permet de recevoir des fonds de manière répétée sans réutiliser les adresses, par exemple pour recevoir votre salaire ou acheter régulièrement des crypto-monnaies.`,
      title: "Pourquoi est-ce utile ?"
    }
  },
  appendix: {
    link: "Contactez-nous !",
    text: "Vous avez une autre question ?"
  },
  backups: {
    check: {
      text: `"Vérifier la sauvegarde" vous permet de vérifier que vous disposez d'une sauvegarde fonctionnelle correspondant à votre portefeuille actuel. Elle peut également être utilisée pour vérifier que vous disposez toujours du mot de passe de récupération correct. Vous pouvez vérifier votre mot de passe de récupération principal ou votre mot de passe de récupération caché.`,
      title: 'Que signifie "Vérifier la sauvegarde" ?'
    },
    encrypt: {
      text: "Non, mais votre mot de passe de récupération est nécessaire pour dériver le portefeuille à partir de la graine stockée.",
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    howOften: {
      text: "La sauvegarde est automatiquement générée lorsqu'un nouveau portefeuille est créé. Vous devez effectuer une nouvelle sauvegarde que si votre carte microSD est perdue ou endommagée ou si vous souhaitez utiliser plusieurs cartes microSD pour vos sauvegardes.\nVous n'avez pas besoin de créer une nouvelle sauvegarde après avoir effectué des transactions. Toutes les données associées à vos transactions peuvent être recréées par votre sauvegarde unique qui a été générée automatiquement.",
      title: "À quelle fréquence dois-je faire une sauvegarde ?"
    },
    whatIsABackup: {
      text: "C'est une copie de la graine sur une carte microSD. La graine combinée à votre mot de passe de récupération génère votre portefeuille.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Vérifier la sauvegarde" vous permet de vérifier que la sauvegarde correspond bien à votre portefeuille.',
      title: 'Que signifie "Vérifier la sauvegarde" ?'
    },
    encrypt: {
      text: `Non. Veillez à conserver la carte microSD en sécurité compte tenu du fait qu'elle contient votre liste de mots permettant la restauration de votre portefeuille. Si vous souhaitez protéger votre graine par mot de passe, vous pouvez activer une phrase secrète dans les paramètres avancés du menu "Gérer l'appareil".`,
      title: "Puis-je chiffrer la sauvegarde ?"
    },
    whatIsABackup: {
      text: "Il s'agit d'une copie de votre liste de mots BIP39 sur une carte microSD.",
      title: "Qu'est-ce qu'une sauvegarde ?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Lorsque le 2FA est activé, toutes les transactions doivent être approuvées sur votre téléphone portable appairé afin de pouvoir envoyer des jetons. En réalité, un numéro chiffré, à usage unique, est envoyé à l'application mobile, déchiffré  et renvoyé au BitBox lorsque vous appuyez sur le bouton "Accepter". Cette communication avec l'appareil se fait via le canal entre le téléphone mobile et l'application de bureau établie lors de l'appareillage.

Assurez-vous de sauvegarder votre portefeuille et d'appairer l'application mobile avant d'activer le 2FA. Une fois activé, l'appairage entre l'emplacement de la carte micro SD et l'application mobile est désactivé. Il peut être réactivé en réinitialisant le BitBox.`,
      title: "Comment fonctionne la double authentification (2FA) ?"
    },
    disable2FA: {
      text: `Pour désactiver le 2FA, vous devez réinitialiser votre BitBox, puis restaurer le portefeuille à partir de sa sauvegarde. Assurez-vous que vous êtes toujours en possession de la carte micro SD avec la sauvegarde et que vous vous souvenez du mot de passe de récupération. Puis appuyez sur "Réinitialiser l'appareil". Définissez un nouveau mot de passe et choisissez "Ou restaurer une sauvegarde". Sélectionnez la sauvegarde que vous avez effectuée à partir du portefeuille, cliquez sur "Restaurer" et entrez le mot de passe de récupération que vous avez utilisé lors de la création du portefeuille.`,
      title: "Comment puis-je désactiver la double authentification (2FA) ?"
    },
    ejectBitbox: {
      text: "Vous pouvez débrancher le BitBox à tout moment sans avoir à l'éjecter.",
      title: "Comment puis-je éjecter le BitBox ?"
    },
    ejectSD: {
      text: "Vous pouvez retirer la carte microSD du BitBox à tout moment, tant que vous n'êtes pas en train de créer ou de restaurer une sauvegarde.",
      title: "Comment puis-je éjecter la carte microSD ?"
    },
    hiddenWallet: {
      text: "Il s’agit d’un deuxième portefeuille sur le même appareil, protégé par un mot de passe d'appareil et de récupération différents, qui peut être utile pour un plausible déni. La même graine de sauvegarde est utilisée pour votre portefeuille normal et votre portefeuille caché. Aucune sauvegarde supplémentaire n'est donc nécessaire.",
      title: "Qu'est-ce qu'un portefeuille caché ?"
    },
    legacyHiddenWallet: {
      text: "Cliquez d'abord sur le bouton ci-dessous (disponible si le BitBox est déverrouillé avec le mot de passe principal de l'appareil et si la double authentification est désactivée), puis rebranchez votre BitBox et déverrouillez-le avec le mot de passe du portefeuille caché.",
      title: "Comment accéder au portefeuille Legacy caché ?"
    },
    pairing: {
      text: "Après avoir téléchargé notre application mobile pour iOS ou Android, vous devez scanner le QR code affiché, ce qui établit un canal sécurisé entre l'application mobile et l'application de bureau. Une fois scanné, suivez les instructions sur l'application mobile.",
      title: "Comment appairer votre téléphone en toute sécurité ?"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Veuillez consulter le site web de Bitsurance et sa FAQ pour plus de détails.",
      title: "Questions supplémentaires ?"
    },
    privacy: {
      link: {
        text: "Politique de confidentialité de Bitsurance"
      },
      title: "Quelles informations personnelles sont nécessaires pour l'assurance ?"
    },
    renew: {
      title: "Comment puis-je renouveler ou résilier l'assurance ?"
    },
    status: {
      text: `Les comptes assurés avec succès sont signalés par un badge vert "assuré" dans le coin supérieur droit de chaque page de vos compte Bitcoin. Dans la section "Assurance", vous pouvez avoir l'aperçu de tous les comptes Bitcoin assurés et leur statut d'assurance en temps réel.`,
      title: "Puis-je consulter l'état d'un compte assuré ?"
    },
    what: {
      title: "Est-ce que l'ensemble du portefeuille BitBox est assuré ?"
    },
    who: {
      text: "L'assurance est proposée par Bitsurance, un courtier en assurance fondé par des bitcoiners. Ils travaillent conjointement avec ELEMENT insurance afin de fournir une assurance Bitcoin. Ces deux sociétés sont basées en Allemagne.",
      title: "Qui assure mes bitcoins ?"
    },
    why: {
      text: "Bitsurance couvre certains risques liés à la self-custody (détention par soi-même) qui ne sont pas couverts même par les wallets les plus sûrs, comme par exemple le cambriolage, l'extorsion ou la destruction du-dit wallet. Il vous appartient de décider par vous même si vous avez la nécessité d'une police d'assurance pour ces risques.",
      title: "Ai-je besoin d'une assurance Bitcoin ?"
    }
  },
  cointracking: {
    text: `Cliquez sur le bouton "Exporter" et ouvrez le dossier de téléchargement où vous trouverez l'exportation CSV. Cliquez ensuite sur le lien ci-dessous, téléchargez votre fichier CSV BitBox et importez les données afin de les utiliser avec votre gestionnaire de portefeuille CoinTracking et pour créer vos déclaration fiscales.`,
    title: "Comment importer mes transactions dans CoinTracking ?"
  },
  device: {
    attestation: {
      link: {
        text: "En savoir plus sur le contrôle d'authenticité"
      },
      text: "BitBoxApp effectue un contrôle d'attestation sur la BitBox02 afin de confirmer que le dispositif est bien authentique. La vérification est effectuée localement et ne nécessite aucune connexion à un serveur.",
      title: "Comment fonctionne le contrôle d'authenticité?"
    },
    name: {
      text: "Ceci est le nom de votre portefeuille et de votre sauvegarde. Ce nom est utilisé pour les sauvegardes futures et permet de faire la distinction entre différents portefeuilles. Il peut être modifié à tout moment mais veuillez noter que les sauvegardes effectuées avant ce changement continueront d' utiliser le nom précédent.",
      title: "A quoi sert le nom BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "En savoir plus sur la puce sécurisée"
      },
      text: "Cette information indique le modèle de la puce sécurisée. La puce la plus récente est l'ATECC608B, qui bénéficie de caractéristiques de sécurité renforcées comparativement aux précédents modèles.",
      title: "Pourquoi indiquer le modèle de puce sécurisée?"
    }
  },
  receive: {
    address: {
      text: "Vous pouvez donner l'adresse à d'autres personnes pour qu'elles vous envoient des coins. Assurez-vous simplement qu'elles envoient à la bonne adresse.",
      title: "Que puis-je faire d'une adresse ?"
    },
    addressChange: {
      text: "Dès que vous effectuez une transaction, une nouvelle adresse est automatiquement ajoutée à la liste de sorte qu'il y ait toujours 20 adresses vierges disponibles.",
      title: "Quand les adresses changent-elles ?"
    },
    addressFormats: {
      text: "Par défaut, le type d'adresse est Native Segwit. Ce type d'adresse est largement adopté par d'autres portefeuilles/exchanges et vous offre les meilleurs niveau de frais pour les transactions quotidiennes. Cependant, vous pouvez également choisir d'envoyer vers Taproot (Bitcoin uniquement), qui est le type d'adresse le plus récent, mais qui n'est peut-être pas encore largement supporté. Par ailleurs, si vous rencontrez des difficultés pour vos envois vers Native Segwit (le type par défaut), vous pouvez essayer de passer à l'ancien type d'adresse Wrapped Segwit, qui peut se révéler compatible avec davantage de portefeuilles/exchanges.",
      title: `Quand dois-je utiliser la fonction "Modifier le type d'adresse" ?`
    },
    howVerify: {
      text: "Pour le BitBox01, cliquez sur l'icône BitBox dans la barre latérale de gauche et consultez la section appairage. Le guide sera mis à jour et vous pourrez continuer à suivre les instructions à partir de là.\nPour le BitBox02, vous pouvez vérifier les adresses directement sur l'appareil pendant le processus d'envoi/réception.",
      title: "Comment puis-je vérifier une adresse en toute sécurité ?"
    },
    plugout: {
      text: "Non, une fois que vous avez envoyé des fonds sur votre adresse BitBox, vous n'avez pas besoin de laisser votre BitBox branchée. Vous êtes libre de pouvoir déconnecter votre BitBox.",
      title: "Est-ce que je dois laisser mon BitBox branché quand je reçois des fond ?"
    },
    why20: {
      text: `Au démarrage, l'application génère des adresses dérivées de votre graine pour vérifier si elles ont reçu des fonds. Comme l'application peut générer un nombre presque infini d'adresses, elle pourrait prendre des années à effectuer cette vérification de solde. Pour limiter cette recherche, elle s'arrête après avoir généré 20 adresses vierges. Il s'agit de la "limite d'écart" et 20 est une norme commune bien que arbitraire. Voici les 20 adresses parmi lesquelles vous pouvez choisir.`,
      title: "Pourquoi seulement 20 adresses ?"
    },
    whyMany: {
      text: "Pour préserver la confidentialité et la sécurité, ne donnez jamais deux fois la même adresse. Si vous avez utilisé une adresse, cliquez sur la flèche à droite pour obtenir une nouvelle adresse. Vous pouvez générer jusqu'à 20 adresses à la fois. Voyez les adresses comme des numéros de facture. Toutes les adresses sont dérivées de votre graine, elle même unique.",
      title: "Pourquoi y a-t-il autant d'adresses ?"
    },
    whyVerify: {
      text: "Vous ne devriez pas faire confiance à votre ordinateur pour générer et afficher des adresses authentiques. Sa grande surface d'attaque le rend beaucoup plus vulnérable qu'un portefeuille physique. Pour le BitBox01, le bouton permettant de vérifier l'adresse envoie l'adresse de manière sécurisée à un téléphone mobile jumelé, à partir duquel vous pouvez également scanner et vérifier le code QR. Pour le BitBox02, l'adresse peut être vérifiée directement sur l'écran du BitBox02.",
      title: "Pourquoi devrais-je vérifier l'adresse en toute sécurité ?"
    }
  },
  send: {
    change: {
      text: "Le change sera restituée sur une adresse Taproot si vous disposez d'au moins un UTXO Taproot. Si vous utilisez le coin control, le change sera transféré vers une adresse Taproot s'il y a au moins un UTXO Taproot parmi les UTXOs sélectionnés. Dans tous les autres cas, le change est envoyé vers une adresse Native Segwit.",
      title: "Comment le change output (de sortie) est-il déterminé ?"
    },
    fee: {
      text: "Les frais sont basés sur la taille des données de la transaction et non sur son montant. L'estimation des frais à payer sont calculés par l'algorithme du logiciel Bitcoin Core en fonction de la priorité de traitement par le réseau choisie. Ils sont affichés s'ils ont une valeur différente des cibles ci-dessous.\n\nÉconomique : 24 blocs (environ 4 heures pour Bitcoin, 1 heure pour Litecoin)\nBas : 12 blocs (environ 2 heures pour Bitcoin, 30 minutes pour Litecoin)\nNormal : 6 blocs (environ 1 heure pour Bitcoin, 15 minutes pour Litecoin)\nÉlevé : 2 blocs (environ 20 minutes pour Bitcoin, 5 minutes pour Litecoin)\n(Un bloc prend en moyenne dix minutes pour Bitcoin (2,5 minutes pour Litecoin) à miner et la charge du réseau peut varier considérablement au cours des périodes ci-dessus.)",
      title: "Comment les frais sont-ils déterminés ?"
    },
    plugout: {
      text: "Non, une fois que vous avez effectué une transaction, il n'est pas nécessaire de laisser votre BitBox branché. Vous pouvez déconnecter votre BitBox.",
      title: "Dois-je laisser ma BitBox branchée pendant l'envoi ?"
    },
    priority: {
      text: "Votre transaction sera généralement confirmée plus rapidement par le réseau si les frais que vous êtes prêt à payer sont élevés.",
      title: "Quelle est la priorité du réseau ?"
    },
    revert: {
      text: "Une fois qu'une transaction est signée et envoyée (c'est-à-dire diffusée sur le réseau), elle ne peut plus être annulée. Vérifiez les transactions (y compris les frais) correctement avant de signer !\nSi vous connaissez le destinataire et qu'il est prêt à vous renvoyer le même montant (moins les frais de transaction), vous pouvez lui communiquer une adresse de réception à vous.",
      title: "Puis-je annuler une transaction ?"
    },
    whyFee: {
      text: "Les transactions sont en compétitions les unes avec les autres pour être confirmées par un mineur. Les mineurs choisissent quelles transactions sont à inclure dans la blockchain en fonction des frais de réseau.\nLes mineurs votent sur l'historique des transactions. Puisqu'il n'y a pas de tiers de confiance qui impose un vote par personne (ce qui est l'intérêt des blockchains), les mineurs votent sur les transactions en sacrifiant une ressource coûteuse telle que la puissance de calcul. En récompense de leur travail, ils peuvent prétendre aux jetons fraichement créés ainsi qu'aux frais de toutes les transactions qu'ils ont incluses dans leur bloc.",
      title: "Pourquoi y a-t-il des frais de réseau ?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Si vous avez l'intention de connecter à votre nœud exclusivement à un seul réseau (par exemple, le réseau wifi de votre domicile), l'utilisation d'une communication réseau normale est suffisante.\nDans ce cas, il est conseillé que votre serveur Electrum fournisse un certificat TLS pour crypter la communication.\nSi vous avez l'intention de connecter votre nœud depuis n'importe où, l'utilisation de Tor est la meilleure option. Aucun certificat TLS n'est nécessaire dans ce cas.",
      title: "Dois-je utiliser clearnet TCP, TLS ou Tor ?"
    },
    instructions: {
      link: {
        text: "Guide pour connecter votre nœud"
      },
      text: "Pour un tutoriel complet, veuillez consulter notre guide :",
      title: "Comment je fais pour connecter ma BitBoxApp à mon nœud personnel?"
    },
    options: {
      text: "Il existe différentes solutions pour faire tourner votre propre nœud, comme par exemple acheter un appareil prêt à l'emploi, ou bien fabriquer le vôtre, ou bien encore utiliser Bitcoin Core.\nSi vous souhaitez connecter votre BitBoxApp à votre nœud, assurez-vous qu'il tourne sur un serveur Electrum. Il s'agit d'un programme dédié qui permet à une application de portefeuille de communiquer avec votre nœud.\nLes options supportées sont Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).",
      title: "Quelles sont les options disponibles pour faire tourner un nœud?"
    },
    tor: {
      text: `Tor est l'acronyme de "The Onion Router", un logiciel libre et gratuit qui offre de nombreux avantages en matière de confidentialité et qui est particulièrement intéressant lorsque vous utilisez Bitcoin.
Si vous avez l'intention de vous connecter à votre nœud via Tor, assurez-vous que Tor est installé sur votre ordinateur, puis activez le proxy Tor dans les paramètres de BitBoxApp.
Sur la plupart des systèmes d'exploitation, il existe deux façons d'exécuter Tor :
1. Navigateur Tor : téléchargez et ouvrez le navigateur Tor. Cela permettra à BitBoxApp de se connecter au réseau Tor en activant le port 9150 dans les paramètres du proxy Tor.
2. Background service Tor : installez le daemon Tor, qui fonctionne toujours en fond. BitBoxApp peut alors se connecter en configurant le port 9050 dans les paramètres du proxy Tor.`,
      title: "Qu'est-ce que Tor, le proxy Tor et quel port dois-je utiliser ?"
    },
    what: {
      text: "Il est possible de synchroniser votre portefeuille depuis vos propres nœuds complets au lieu d'utiliser les serveurs de Shift.",
      title: "Qu'est-ce que cela ?"
    },
    why: {
      text: "Faire tourner votre propre nœud n'est pas nécessaire mais améliore la confidentialité et réduit le besoin de faire confiance aux autres.\nPremièrement, cela signifie que vous utilisez Bitcoin de manière plus privée car le BitBoxApp ne se connectera pas à nos serveurs pour récupérer l'historique de vos transactions, mais récupérera ces informations à partir de votre propre nœud.\nDeuxièmement, faire tourner votre propre nœud signifie que celui-ci vérifie lui-même toutes les transactions, en s'assurant que les règles de consensus sont bien respectées.",
      title: "Pourquoi est-ce que je devrais faire tourner mon propre nœud ?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" en abrégé) est la plus petite unité de Bitcoin. Un Satoshi correspond à un cent millionième de bitcoin (0,00000001 BTC). Il tire son nom du créateur de Bitcoin, Satoshi Nakamoto.',
      title: "Qu'est-ce qu'un Satoshi?"
    },
    servers: {
      text: "Cette application communique avec les serveurs de Shift Crypto pour rechercher des mises à jour, charger des transactions et envoyer des informations aux applications mobiles appairées.\nDe plus, elle récupère les derniers taux de change de CoinGecko.\nLes conversions sont calculées localement, aucun de vos montants n'est transmis.\nNote : Pour Ethereum et les jetons ERC20, nous utilisons Etherscan.io APIs.",
      title: "Avec quels serveurs cette application communique-t-elle ?"
    }
  },
  title: "Guide",
  toggle: {
    close: "Fermer le guide",
    open: "Guide"
  },
  trackingModePortfolioChart: {
    text: "Sur ordinateur, déplacez le curseur sur le graphique. Sur mobile, maintenez le doigt sur le graphique et faites-le glisser horizontalement.",
    title: "Comment voir les valeurs historiques sur le graphique?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Vous devez réinitialiser l'appareil et restaurer le portefeuille à partir d'une sauvegarde et du mot de passe de récupération.",
      title: "Que dois-je faire si j'ai oublié le mot de passe de l'appareil ?"
    },
    reset: {
      text: "Entrez un mauvais mot de passe 15 fois. Les dernières tentatives nécessitent une longue pression du bouton tactile sur l'appareil.",
      title: "Comment réinitialiser l'appareil ?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Le dispositif doit clignoter une fois qu'il est inséré. Assurez-vous qu'il soit inséré dans le bon sens. Si vous rencontrez des difficultés, veuillez nous contacter via le lien ci-dessous.\n\nLa BitBox01 n'est pas utilisable sur mobile. Veuillez utiliser la BitBoxApp sur votre ordinateur pour connecter votre BitBox01.",
      title: "Mon BitBox01 n'est pas reconnu"
    },
    getDevice: {
      link: {
        text: "Commander un BitBox"
      },
      text: "Vous pouvez acheter un BitBox dans notre boutique en ligne :",
      title: "Comment puis-je obtenir un appareil BitBox ?"
    },
    internet: {
      text: "Oui, une connexion à Internet est nécessaire pour synchroniser le portefeuille, envoyer des transactions et récupérer les derniers taux de change.",
      title: "Cette application nécessite-t-elle une connexion à Internet ?"
    },
    lostDevice: {
      link: {
        text: "Centre de sauvegarde"
      },
      text: "Vous pouvez accéder à vos comptes via un nouveau BitBox ou depuis notre centre de sauvegarde.",
      title: "J'ai perdu mon appareil. Que faire ?"
    },
    useWithoutDevice: {
      text: "Ce n'est malheureusement pas possible pour le moment.",
      title: "Puis-je utiliser l'application sans appareil Bitbox ?"
    },
    welcome: {
      text: "Merci d'utiliser cette application développée par Shift Crypto en Suisse. Nous apprécions tous les commentaires dont vous pourriez nous faire part. Vous pouvez nous les soumettre en cliquant sur le lien en bas de page.",
      title: "Bienvenue dans l'application BitBox !"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si vous utilisez un nouveau téléphone/ordinateur avec la BitBoxApp, vous devrez vous connecter à nouveau aux DApps. Vous verrez alors vos coins sur la DApps comme précédemment.",
      title: "Je ne vois pas mes précédentes connexions."
    },
    supportedNetworks: {
      text: "Actuellement, seul le mainnet d’Ethereum est supporté lorsque vous utilisez WalletConnect dans la BitBoxApp. Pour utiliser d'autres chaînes compatibles EVM, veuillez utiliser l'extension de navigateur Rabby wallet.",
      title: "Quels sont les réseaux supportés ?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect est un protocole de communication pour les applications web3. Il vous permet de vous connecter facilement aux DApps et aux portefeuilles web reposant sur Ethereum sans utiliser d'application tierce; ceci constitue une solution particulièrement pratique pour les utilisateurs Android de la BitBoxApp.",
      title: "Qu'est-ce que WalletConnect ?"
    }
  }
};
const headerssync$e = {
  blocksSynced: "{{blocks}} blocs synchronisés"
};
const hiddenWallet$e = {
  info1HTML: "Pour un besoin de déni plausible, un portefeuille caché peut être créé à partir d'une combinaison de <strong> différents </strong> mot de passe de récupération et d'appareil.",
  info2HTML: "Définissez le mot de passe de l'appareil et de récupération que vous souhaitez associer à votre portefeuille caché ci-dessous. Le mot de passe de l'appareil et le mot de passe de récupération doivent être <strong> différents </strong> de ceux que vous avez définis pour votre portefeuille principal.",
  passwordLabel: "Mot de passe de récupération caché",
  passwordPlaceholder: "Veuillez confirmer le mot de passe de récupération caché",
  pinLabel: "Mot de passe de l'appareil caché",
  pinRepeatLabel: "Répéter le mot de passe de l'appareil caché",
  pinRepeatPlaceholder: "Veuillez confirmer le mot de passe de l'appareil caché",
  success: "Un portefeuille caché a été créé avec succès. Rebranchez votre BitBox pour le déverrouiller."
};
const initialize$e = {
  create: "Définir le mot de passe de l'appareil",
  creating: "Définition du mot de passe de l'appareil en cours…",
  error: {
    e102: "Le mot de passe de l'appareil doit comporter au moins 4 caractères."
  },
  info: {
    description1: "Choisissez le mot de passe de votre appareil. Celui-ci sera utilisé pour déverrouiller votre BitBox.",
    description2: "Vous pouvez utiliser des chiffres, des lettres et des symboles. Les mots de passe longs offrent une meilleure sécurité.",
    description3: "Si vous perdez le mot de passe de votre appareil, vous devrez le réinitialiser et restaurer la sauvegarde de votre portefeuille.",
    subtitle: "Vous allez maintenant définir le mot de passe de votre appareil",
    title: "Initialisation de votre appareil"
  },
  input: {
    label: "Mot de passe de l'appareil",
    labelRepeat: "Répéter le mot de passe de l'appareil",
    placeholderRepeat: "Veuillez confirmer le mot de passe de l'appareil"
  }
};
const invalidFormat$e = "Format invalide";
const language$f = {
  title: "Choisir la langue"
};
const legacyhiddenwallet$e = {
  disable: "Désactiver le portefeuille Legacy caché",
  enable: "Activer le portefeuille Legacy caché",
  successDisable: "Portefeuille Legacy caché désactivé avec succès.",
  successEnable: "Portefeuille Legacy caché activé avec succès. Reconnectez votre BitBox et entrez le mot de passe de l'appareil caché pour accéder au portefeuille Legacy caché."
};
const loading$e = "chargement en cours…";
const manageAccounts$8 = {
  accountHidden: "Ce compte a été retiré de vos comptes watch-only. Pour le voir à nouveau, veuillez brancher votre BitBox02.",
  editAccount: "Modifier",
  editAccountNameTitle: "Modifier le nom du compte",
  noAccounts: "aucun compte trouvé",
  settings: {
    hideTokens: "Cacher les jetons",
    showTokens: "Afficher les jetons ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Ajouter et afficher/masquer les comptes",
  title: "Gestion des comptes",
  watchAccount: "Compte de suivi",
  watchAccountDescription: "Ce compte fait partie de vos comptes watch-only. Vous pouvez le faire disparaître de vos comptes watch-only à l'aide du bouton."
};
const mobile$9 = {
  usingMobileDataWarning: "Utilisation des données mobiles : cette application peut télécharger jusqu'à quelques centaines de mégaoctets de données d'en-tête de blockchain après avoir déverrouillé un compte. Veuillez vous connecter au Wi-Fi afin d'éviter d'utiliser les données mobiles. Après l'avoir quitté, ce message ne s'affichera plus."
};
const newSettings$7 = {
  about: {
    appVersion: {
      title: "Version de l'application"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Verrouiller l'accès à l'application via le verrouillage de l'écran/empreinte digitale.",
      title: "Verrouillage de l'écran"
    },
    coinControl: {
      description: "Sélectionnez quelles UTXO font partie d'une transaction afin d'améliorer la confidentialité"
    },
    customFees: {
      description: "Vous permet de saisir vos propres frais lors de l'envoi."
    },
    torProxy: {
      description: "Se connecter via Tor pour une meilleure confidentialité."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Ces devises supplémentaires peuvent être sélectionnées sur la page de votre compte.",
      title: "Devises activées"
    },
    darkmode: {
      description: "Voir la BitBoxApp en dark mode (mode sombre)."
    },
    defaultCurrency: {
      description: "Sélectionnez votre devise par défaut",
      title: "Devise par défaut"
    },
    enableAccount: {
      description: "La désactivation de votre compte signifie qu'il n'apparaîtra plus dans la barre latérale ou dans le portfolio. Vous avez toujours la possibilité de le réactiver à partir d'ici. Les coins de ce compte ne seront pas affectées et resteront en sécurité.",
      title: "Activer/désactiver le compte"
    },
    hideAmounts: {
      description: "Affiche un bouton permettant de masquer votre solde et vos montants afin d'améliorer votre confidentialité lorsque vous utilisez l'application en public.",
      hideAmounts: "Cacher les montants",
      showAmounts: "Afficher les montants",
      title: "Autoriser la dissimulation des montants"
    },
    language: {
      description: "Quelle langue souhaitez vous que BitBoxApp utilise?",
      title: "Langue"
    },
    remebmerWallet: {
      name: "Se souvenir du wallet"
    },
    toggleSats: {
      description: "Activer ou désactiver l'unité des Satoshis"
    }
  }
};
const note$a = {
  input: {
    description: "(facultatif)",
    placeholder: "Ajouter une note..."
  },
  title: "Note"
};
const notification$e = {
  newTxs_one: "Nouvelle transaction dans : {{accountName}}",
  newTxs_other: "{{count}} nouvelles transactions dans : {{accountName}}"
};
const pairing$e = {
  aborted: {
    text: "L'appairage a été annulé depuis l'application mobile.",
    title: "Abandonné"
  },
  button: "Appairer l'application mobile",
  confirm: "Êtes-vous sûr de vouloir appairer votre BitBox ? Notez qu'ensuite le téléphone mobile est nécessaire pour effectuer une transaction.",
  connectOnly: {
    button: "Connecter l'application mobile",
    title: 'Scannez depuis notre application mobile en cliquant sur "Connecter à une nouvelle application de bureau"'
  },
  error: {
    text: "Quelque chose s'est mal passé. Veuillez recommencer.",
    title: "Erreur"
  },
  pullFailed: {
    text: "Impossible de faire passer un message de votre mobile par le serveur relais. Le serveur relais est peut-être hors ligne, veuillez contacter l'assistance.",
    title: "Échec de transfert"
  },
  reconnectOnly: {
    button: "Reconnecter l'application mobile"
  },
  scanningFailed: {
    text: "Le mobile n'a pas pu scanner le message correctement. Veuillez réessayer.",
    title: "Échec de la numérisation"
  },
  start: {
    hideAppQRCode: "Masquer le QR Code",
    revealAppQRCode: "Afficher le QR Code",
    step1: "Si vous ne possédez pas encore l'application mobile, vous pouvez scanner le QR code correspondant à l'App Store ou au Play Store en fonction de votre téléphone.",
    step2: `Scannez depuis notre application mobile, que vous pouvez trouver sous le nom "Digital Bitbox 2FA" dans les magasins d'applications pour iOS et Android :`
  },
  started: {
    text: "Veuillez maintenant suivre les instructions sur l'application mobile.",
    title: "Génial"
  },
  success: {
    text: "Félicitations, vous avez appairé votre BitBox à l’application mobile !",
    title: "Succès"
  },
  timeout: {
    text: "Le temps d'appairage expire après deux minutes. Recommencez si vous souhaitez toujours appairer l'application mobile.",
    title: "Expiration de session"
  },
  title: "Appairage mobile"
};
const passphrase$8 = {
  considerations: {
    button: "Considérations relatives à la sauvegarde",
    message: "La passphrase ajoute une couche de protection supplémentaire  à la sauvegarde de votre portefeuille (carte microSD ou mots de récupération). Si quelqu'un a accès à votre sauvegarde, il aura également besoin de la passphrase pour accéder à votre portefeuille.\n\nCependant, cela signifie que vous aurez besoin <strong>à la fois de la passphrase ET de la sauvegarde du portefeuille</strong>  pour restaurer votre portefeuille pour lequel la passphrase est activée, au cas où votre BitBox02 serait perdu ou cassé. Si vous oubliez ou perdez votre passphrase, vous perdrez l'accès à toutes les fonds se trouvant dans ce portefeuille.\n\nLorsque vous stockez votre passphrase, pensez bien à la conserver dans un endroit différent de celui de votre sauvegarde. De cette façon, si venait à trouver votre sauvegarde, il n'aurait pas accès à votre passphrase également.",
    title: "Considérations relatives à la sauvegarde"
  },
  disable: "Désactiver la passphrase",
  disableInfo: {
    button: "Désactiver",
    message: "Une fois la passphrase désactivée, il ne vous sera plus demandé de saisir une passphrase après avoir déverrouillé votre BitBox02. Par conséquent, vous entrerez dans votre portefeuille par défaut.\n\nTous les coins (monnaies) se trouvant sur votre portefeuille avec passphrase seront toujours sur ce portefeuille, mais vous ne pourrez plus y accéder car après avoir déverrouillé votre BitBox02, vous ouvrirez votre portefeuille par défaut.\n\nPour accéder de nouveau à vos portefeuilles avec passphrase, il suffit de réactiver la fonction passphrase et de saisir la passphrase correspondante après déverrouillage de la BitBox02.\n\n<strong>Astuce:</strong> Vous pouvez toujours accéder à votre portefeuille d'origine en laissant la phrase de passe vide."
  },
  enable: "Activer la passphrase",
  error: {
    e104: "La modification des paramètres de la passphrase a été interrompue."
  },
  how: {
    button: "A quoi ça ressemble",
    message: "Une passphrase ne fonctionne pas comme les mots de passe auxquels vous êtes habitué. Si vous vous trompez dans la saisie de votre passphrase, vous ne serez pas averti. En effet, <strong>chaque passphrase crée un portefeuille distinct, mais valide</strong>. Cela signifie que vous pouvez utiliser autant de passphrases que vous le souhaitez afin de créer autant de portefeuilles correspondants. Mais on ne peut accéder à chaque portefeuille qu'en saisissant la passphrase associée.\n\nAu moment où vous branchez votre BitBox02, le mot de passe de l'appareil vous sera demandé de manière habituelle. Ensuite, il vous sera demandé d'entrer une passphrase sur l'appareil.\n\nAprès avoir saisi la passphrase, vous verrez s'afficher cette même passphrase que vous avez entrée. Cela vous permet de confirmer que vous l'avez saisie correctement.",
    title: "Comment ça marche"
  },
  intro: {
    message: "Une passphrase fournit une couche supplémentaire de sécurité en plus pour votre portefeuille.\nVoyons comment cela fonctionne.",
    title: "Configurer la passphrase"
  },
  progressDisable: {
    message: "Confirmez sur votre BitBox que vous souhaitez <strong>désactiver</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  progressEnable: {
    message: "Confirmez sur votre BitBox que vous voulez <strong>activer</strong> la passphrase optionnelle.",
    title: "Confirmer sur l'appareil"
  },
  successDisabled: {
    message: "Passphrase optionnelle <strong>activée avec succès</strong> !\nIl vous sera demandé de fournir une passphrase à partir de maintenant.",
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02",
    title: "Passphrase activée"
  },
  successEnabled: {
    message: "Passphrase optionnelle <strong>désactivée avec succès</strong> !\nIl ne vous sera plus demandé de fournir une passphrase à partir de maintenant.",
    messageEnd: "Veuillez maintenant rebrancher votre BitBox02.",
    tips: "Astuces",
    tipsList: [
      "Nous vous suggérons d'envoyer d'abord un petit montant dans le portefeuille avec passphrase. Ensuite, débranchez puis rebranchez la BitBox02 avant de saisir votre mot de passe et votre passphrase. Si vous avez entré votre passphrase correctement, vous devriez voir les fonds dans votre portefeuille.",
      "Si vous souhaitez accéder à votre portefeuille d'origine sans passphrase, vous pouvez toujours le faire en ne saisissant tout simplement rien lorsque vous êtes invité à fournir la passphrase. Vous pouvez également choisir de désactiver la fonction passphrase."
    ],
    title: "Passphrase désactivée"
  },
  summary: {
    button: "Activer la passphrase",
    title: "Résumé",
    understand: "Je comprends le fonctionnement de la passphrase et les risques qui lui sont associés.",
    understandList: [
      "La passphrase est une couche de sécurité supplémentaire en plus de votre sauvegarde.",
      "La saisie d'une passphrase différente générera à chaque fois un porte-monnaie différent.",
      "Pour restaurer votre portefeuille, vous avez besoin <strong>à la fois de la passphrase et de la sauvegarde</strong>.",
      "Si vous oubliez votre passphrase, vous ne pourrez plus accéder à vos fonds."
    ]
  },
  what: {
    button: "Découvrez comment cela fonctionne",
    message: `Un portefeuille est créé (dérivé) à partir d'un  nombre aléatoire très grand, également appelé "seed" (graine). Cette seed est créée lors de la première configuration de votre BitBox02 et est sauvegardée via la carte microSD ou les mots de récupération. Toute personne ayant accès à la seed dispose d'un contrôle total sur les fonds de ce portefeuille.

Une passphrase est un <strong>secret optionnel</strong>, ajouté à la seed. Lorsque vous utilisez une passphrase, chaque passphrase crée un nouveau portefeuille basé sur la seed + la passphrase (secret optionnel). Une passphrase peut être n'importe quoi : des lettres, des mots, des caractères spéciaux ou même être vide. Le portefeuille par défaut est en fait dérivé de la seed + passphrase vide.

La passphrase fait partie de la norme BIP39, ce qui signifie qu'elle est compatible avec tous les portefeuilles qui supportent cette dernière.`,
    title: "Qu'est-ce qu'une passphrase?"
  },
  why: {
    button: "Pourquoi utiliser une passphrase",
    message: `La BitBox02 protège la seed contre l'extraction depuis l'appareil lui-même, mais la sauvegarde (carte microSD ou mots de récupération) donne un accès complet au portefeuille. C'est pourquoi elle doit être stockée dans un endroit sûr !

Puisqu'une passphrase crée un nouveau portefeuille en utilisant votre seed existante, le portefeuille avec passphrase nécessite à la fois <strong> votre sauvegarde ET votre passphrase pour être restauré</strong>. L'avantage de ceci est que si quelqu'un trouve votre sauvegarde, il a toujours besoin de la passphrase pour accéder au poretefeuille avec passphrase.

En outre, la fonction passphrase vous permet de créer plusieurs portefeuilles sur le même appareil, ou "portefeuilles cachés", en plus du portefeuille par défaut.`,
    title: "Pourquoi utiliser une passphrase"
  }
};
const password$e = {
  show: "Montrer {{label}}",
  warning: {
    caps: "ATTENTION : le verrouillage des majuscules (⇪) est activé",
    paste: 'Pour coller du texte, activez "Montrer {{label}}"'
  }
};
const random$f = {
  button: "Générer un numéro aléatoire",
  description: "Votre BitBox a généré le numéro aléatoire à {{bits}}-bit suivant :"
};
const receive$g = {
  bitsuranceWarning: "Ceci est un compte assuré, ce qui signifie qu'il ne peut recevoir des fonds que sur des adresses Native Segwit. Ceci afin d'éviter que vous ne receviez accidentellement des fonds vers des adresses Wrapped Segwit ou Taproot, qui ne sont elles pas assurées.",
  changeScriptType: "Changer de type d'adresse",
  label: "Votre adresse",
  onlyThisCoin: {
    description: "Pour recevoir d'autres coins, activez-les dans les paramètres. Si vous déposez d'autres coins, il se peut qu'ils ne soient pas accessibles.",
    warning: "Assurez-vous de ne recevoir que {{coinName}} sur cette adresse."
  },
  scriptType: {
    p2tr: "Taproot (nouveau format d'adresse)",
    p2wpkh: "Native Segwit (par défaut)",
    "p2wpkh-p2sh": "Wrapped Segwit (format compatible)"
  },
  selectAccount: "Sélectionner un compte",
  showFull: "Afficher et vérifier l'adresse complète sur l'appareil",
  taprootWarning: `Remarque : Taproot est une nouvelle fonctionnalité sur Bitcoin et n'est pas encore largement adoptée. Les fonds reçus sur les adresses Taproot peuvent potentiellement ne pas être visibles depuis les portefeuilles "watch-only" tiers. De nombreux portefeuilles et exchanges ne sont pas encore en mesure d'envoyer des fonds aux adresses Taproot.`,
  title: "Recevoir {{accountName}}",
  verify: "Vérifier l'adresse de façon sécurisée",
  verifyBitBox01: "Vérifier l'adresse sur l'application mobile",
  verifyBitBox02: "Vérifier l'adresse sur le BitBox02",
  verifyInstruction: "Veuillez vérifier que l'adresse suivante correspond à celle affichée sur votre appareil.",
  warning: {
    secureOutput: "Veuillez appairer votre BitBox avec votre téléphone mobile pour activer la vérification sécurisée des adresses. Cliquez sur «Gérer l'appareil» dans la barre latérale."
  }
};
const reset$e = {
  description: "Toutes les données vont être supprimées de l'appareil. Ceci inclut votre Clé Privée !",
  notReset: "Appareil NON réinitialisé.",
  title: "Réinitialiser l'appareil aux paramètres usine",
  understand: "J'ai une sauvegarde et je connais mon mot de passe de récupération",
  understandBB02: "J'ai une sauvegarde valide"
};
const securityInformation$e = {
  create: {
    description1: "Il est recommandé de configurer votre appareil dans un environnement sécurisé; c'est-à-dire loin d'autres personnes qui seraient susceptibles de voir le mot de passe que vous choisissez.",
    description2: "Il vous sera demandé de créer deux mots de passe.",
    description3: "Le premier est le <strong>mot de passe de l'appareil</strong> qui déverrouille votre BitBox et peut être modifié ultérieurement.",
    description4: "Le second est le <strong>mot de passe de récupération</strong> qui déverrouille votre portefeuille. Ce mot de passe ne peut PAS être changé ultérieurement.",
    description5: "Le portefeuille que vous créez sera sauvegardé dans un fichier sur la carte microSD fournie. Elle peut être utilisé en cas d'urgence pour récupérer vos fonds avec l'aide de votre <strong>mot de passe de récupération</strong>.",
    title: "Information de sécurité"
  },
  restore: {
    description1: "Il vous sera demandé d'insérer la carte microSD utilisée pour votre sauvegarde.",
    description2: "Pour restaurer votre appareil, vous aurez besoin de votre mot de passe de récupération.",
    description3: "Veuillez faire attention lorsque vous entrez le mot de passe de récupération. Tout mot de passe que vous entrez créera un portefeuille valide. Si vous entrez un mot de passe différent, le solde du portefeuille ne sera pas celui attendu.",
    title: "Information de sécurité"
  }
};
const seed$e = {
  agreements: {
    "funds-access": "Je ne pourrai PAS accéder à mes fonds si j'oublie mon mot de passe de récupération",
    "password-change": "Je ne peux PAS changer le mot de passe de récupération ultérieurement",
    "password-required": "Le mot de passe de récupération est nécessaire pour restaurer un portefeuille à partir d'une sauvegarde."
  },
  create: "Créer un portefeuille",
  creating: "Créer un portefeuille",
  description: "Je comprends que :",
  error: {
    e102: "Le mot de passe doit contenir au minimum 4 caractères.",
    e200: "Vous devez insérer une carte microSD dans votre BitBox afin de créer un portefeuille, une sauvegarde se créée ainsi automatiquement."
  },
  info: {
    button: "Définir le mot de passe maintenant",
    description1: "Insérez la carte microSD dans le BitBox",
    description2: 'Choisissez un mot de passe de récupération pour le portefeuille et sélectionnez "Définir le mot de passe de récupération maintenant".',
    description3: "La sauvegarde sur une carte microSD et votre mot de passe de récupération constituent le seul moyen de récupérer vos fonds en cas de perte ou de vol de votre BitBox.",
    description4: "Vous ne pouvez pas modifier votre mot de passe de récupération sans avoir transféré vos fonds au préalable.",
    title: "Créer un nouveau portefeuille"
  },
  password: {
    label: "Mot de passe de récupération",
    repeatPlaceholder: "Répéter le mot de passe de récupération"
  },
  walletName: {
    label: "Nom du portefeuille"
  }
};
const seedRestore$e = {
  error: {
    e200: "La restauration d'un portefeuille à partir d'une sauvegarde nécessite la carte microSD."
  },
  info: {
    description1: "Insérez la carte microSD dans le BitBox et cliquez sur «Continuer»",
    description2: 'Choisissez une sauvegarde et cliquez sur "Restaurer"',
    description3: "Entrez le mot de passe de récupération",
    description4: "Vous devez confirmer avoir compris qu'un mot de passe incorrect créera un portefeuille différent.",
    title: "Comment restaurer un portefeuille à partir d'une sauvegarde"
  }
};
const send$g = {
  abort: "La transaction a été annulée.",
  address: {
    label: "Adresse du destinataire",
    placeholder: "Entrer l'adresse"
  },
  amount: {
    label: "Montant",
    placeholder: "Entrer le montant"
  },
  availableBalance: "Solde disponible",
  button: "Revoir",
  coincontrol: {
    address: "Adresse",
    outpoint: "Point de sortie",
    title: "Envoi à partir de"
  },
  confirm: {
    "selected-coins": "Coins sélectionnés",
    title: "Confirmer et envoyer la transaction",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Il semblerait que vous n'ayez pas assez d'Ether pour régler cette transaction ERC20. Veuillez vous assurer que vous avez suffisamment d'Ether dans votre portefeuille.",
    feeTooLow: "Frais pas assez élevés",
    feesNotAvailable: "Estimation des frais impossible",
    insufficientFunds: "fonds insuffisants",
    invalidAddress: "adresse invalide",
    invalidAmount: "montant invalide",
    invalidData: "données invalides"
  },
  fee: {
    customPlaceholder: "Entrer le montant",
    label: "Frais de réseau",
    placeholder: "Indisponible"
  },
  feeTarget: {
    customLabel: "Taux des frais",
    customLabel_eth: "Prix du Gas",
    description: {
      economy: "4 heures (24 blocs)",
      economy_eth: "30 minutes maximum",
      economy_ltc: "1 heure (24 blocs)",
      high: "20 minutes (2 blocs)",
      high_eth: "30 secondes maximum",
      high_ltc: "5 minutes (2 blocs)",
      low: "2 heures (12 blocs)",
      low_eth: "5 minutes maximum",
      low_ltc: "30 minutes (12 blocs)",
      normal: "1 heure (6 blocs)",
      normal_eth: "2 minutes maximum",
      normal_ltc: "15 minutes (6 blocs)"
    },
    estimate: "Temps d'attente estimé avant confirmation:",
    label: {
      custom: "Personnalisé",
      economy: "Économique",
      high: "Élevé",
      low: "Faible",
      normal: "Normal"
    },
    placeholder: "Calcul des frais…"
  },
  maximum: "Envoyer tout",
  maximumSelectedCoins: "",
  noFeeTargets: "L'estimation des frais n'est pas disponible actuellement. Veuillez réessayer plus tard ou saisir des frais personnalisés.",
  priority: "Priorité",
  scanQR: "Scanner un QR Code",
  signprogress: {
    description: "Cette transaction contient beaucoup de données. Pour la signer entièrement, il vous sera demandé de confirmer {{steps}} fois.",
    label: "Avancement"
  },
  success: "La transaction a été signée et envoyée.",
  title: "Envoyer {{accountName}}",
  toggleCoinControl: "Sélecteur de coins",
  transactionDetails: "Détails de la transaction"
};
const settings$f = {
  about: "À propos",
  accounts: "Comptes",
  advancedSettings: "Paramètres avancés",
  appearance: "Apparence",
  electrum: {
    add: "Ajouter un serveur",
    "add-server": "Ajouter",
    check: "Vérifier",
    checkFailed: "Échoué",
    checkSuccess: "Connexion à {{hôte}} réussie",
    checking: "Vérification",
    "download-cert": "Télécharger le certificat distant",
    "remove-server": "Retirer",
    removeConfirm: "Supprimer {{serveur}} ?",
    reset: "Réinitialisation aux valeurs par défaut",
    resetConfirm: 'Voulez-vous retirer tous les serveurs et installer ceux "par défaut" ?',
    servers: "Serveurs",
    step1: "1",
    "step1-text": "Entrez le endpoint.",
    step2: "2",
    "step2-text": "Entrez un certificat de la chaîne de certificats du serveur. Vous pouvez également télécharger le certificat isolé et le comparer visuellement.",
    "step2-text-tcp": "Vous pouvez sauter cette étape si vous ne souhaitez pas utiliser TLS.",
    step3: "3",
    "step3-text": "Vérifiez la connexion et ajoutez le serveur.",
    step4: "4",
    "step4-text": "Redémarrez l'appareil. Si vous ne supprimez pas les serveurs par défaut votre nœud sera ajouté comme une redondance.",
    "title-btc": "Serveurs Bitcoin Electrum",
    "title-ltc": "Serveurs Litecoin Electrum",
    "title-tbtc": "Serveurs Bitcoin Testnet Electrum",
    "title-tltc": "Serveurs Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activer le contrôle des monnaies",
    electrum: {
      description: "Vous pouvez vous connecter à votre propre nœud Electrum.",
      title: "Connectez votre nœud complet"
    },
    fee: "Activer la personnalisation des frais",
    setProxyAddress: "Définir une adresse proxy",
    title: "Paramètres avancés",
    useProxy: "Activer tor proxy",
    useSats: "Afficher les valeurs des BTC en Satoshis"
  },
  header: {
    home: "Accueil"
  },
  info: {
    "out-of-date": "Nouvelle mise à jour disponible",
    title: "Info",
    "up-to-date": "Votre application est à jour",
    version: "Version de l'application"
  },
  restart: "Veuillez redémarrer la BitBoxApp pour que les changements prennent effet.",
  services: {
    title: "Services"
  },
  success: "Veuillez débrancher et reconnecter le BitBox pour que les modifications prennent effet.",
  title: "Paramètres"
};
const setup$e = "Configuration de l'appareil";
const sidebar$f = {
  buy: "Acheter de la crypto",
  device: "Gérer l'appareil",
  insurance: "Assurance",
  leave: "Quitter",
  settings: "Paramètres"
};
const success$l = {
  create: {
    info1: "Votre portefeuille a été correctement sauvegardé sur la carte microSD. Retirez-la et gardez-la en sécurité.",
    info2: "Vous avez créé un mot de passe sécurisé pour l'appareil qui permet de déverrouiller votre BitBox.",
    info3: "Vous avez créé un mot de passe de récupération sécurisé pour votre portefeuille, qui déverrouille vos fonds et permet la restauration de vos sauvegardes.",
    summary: "Voici un résumé de ce que vous avez fait",
    title: "Succès"
  },
  getstarted: "Commencer",
  restore: {
    summary: "Vous avez restauré avec succès un portefeuille à partir de votre sauvegarde.",
    title: "Succès"
  }
};
const transaction$f = {
  confirmation: "Confirmations",
  details: {
    activity: "Activité",
    address: "Adresse",
    amount: "Montant",
    date: "Date",
    fiat: "Devise",
    fiatAmount: "Montant en Fiat",
    fiatAtTime: "Fiat au moment de la transaction",
    status: "Statut",
    title: "Détails de la transaction",
    type: "Type"
  },
  explorer: "Identification de transaction",
  explorerTitle: "Ouvrir dans un Explorateur de blocs externe",
  fee: "Frais",
  fiatHistorical: "Historique",
  gas: "Gaz",
  note: {
    edit: "Modifier la note",
    save: "Sauvegarder la note"
  },
  pending: "Transaction en attente",
  size: "Taille",
  status: {
    complete: "Terminé",
    failed: "Échoué",
    pending: "En attente"
  },
  tx: {
    received: "Reçu de",
    sent: "Envoyé à"
  },
  vsize: "Taille virtuelle",
  weight: "Poids"
};
const transactions$e = {
  errorLoadTransactions: "Une erreur s'est produite lors du chargement des transactions",
  placeholder: "Aucune transaction pour le moment."
};
const unknownError$e = "Une erreur inconnue s'est produite : {{errorMessage}}";
const unlock$e = {
  description: "Entrez le mot de passe de votre appareil pour le déverrouiller.",
  error: {
    e109_normal: "Mauvais mot de passe. {{remainingAttempts}} essais restant avant que l'appareil se réinitialise.",
    e109_touch: "$t(unlock.error.e109_normal) La prochaine connexion nécessite de maintenir le bouton tactile enfoncé.",
    e113: "En raison de nombreuses tentatives de connexion, la connexion suivante nécessite de maintenir le bouton tactile enfoncé pendant 4 secondes."
  },
  input: {
    label: "Mot de passe de l'appareil",
    placeholder: "Entrez le mot de passe de votre appareil pour le déverrouiller"
  },
  unlocking: "Déverrouillage…"
};
const upgradeFirmware$f = {
  button: "Mettre à jour le firmware",
  description: "Voulez-vous mettre à jour le firmware de la version {{currentVersion}} à la {{newVersion}} ?",
  label: "Une mise à jour du firmware de votre BitBox est nécessaire.",
  locked: "Pour effectuer la mise à jour de la {{currentVersion}} à la {{newVersion}}, veuillez presser longuement le bouton tactile.",
  title: "Mettre à jour le firmware",
  unlocked: "Le chargeur d'amorçage est déverrouillé. Pour continuer, veuillez :",
  unlocked1: "Débrancher et rebrancher votre BitBox",
  unlocked2: "La LED s'allumera lorsque votre BitBox sera rebranché",
  unlocked3: "Appuyez sur le bouton tactile lorsque la LED s'allume"
};
const walletConnect$9 = {
  connect: {
    button: "Connecter",
    dappLabel: "Saisir l'adresse URI de la Dapp",
    invalidPairingUri: "Uri d'appariement non valide"
  },
  dashboard: {
    allSessions: "Toutes les sessions",
    disclaimer: "Walletconnect est un protocole permettant de se connecter à des Dapps basées sur Ethereum. Ces Dapps sont gérées par des services tiers, ne vous connectez donc uniquement qu'à des Dapps en lesquelles vous avez entièrement confiance et assurez-vous de toujours savoir ce que vous signez lorsque vous effectuez une transaction.",
    newConnection: "Nouvelle connexion",
    noConnectedSessions: "Aucun compte n'est actuellement connecté à une Dapp."
  },
  invalidPairingChain: "Erreur dans l'approbation de l'appariement. Veillez à utiliser l'une des chaînes prises en charge : {{chains}}",
  pairingRequest: {
    approve: "Approuver la connexion",
    reject: "Rejeter",
    title: "Nouvelle demande de connexion de"
  },
  pairingSuccess: "Dapp connectée avec succès. Vous pouvez continuer sur le site de la Dapp.",
  signingRequest: {
    account: "Compte",
    chain: "Chaîne",
    dapp: "Dapp",
    data: "Données",
    dataParsingError: "Échec de l'analyse des données",
    decodeError: "Échec de déchiffrage du message",
    method: {
      sendTransaction: "Signer et envoyer la transaction",
      signMessage: "Signer un message",
      signTransaction: "Signer une transaction",
      signTypedData: "Signer les données saisies"
    },
    successfullySigned: "Requête signée avec succès",
    walletConnectRequest: "Demande WalletConnect"
  },
  useNewUri: "Cet URI a déjà été utilisé pour une tentative de connexion. Veuillez utiliser un nouvel URI.",
  walletConnect: "WalletConnect"
};
const warning$k = {
  receivePairing: "Veuillez appairer le BitBox pour activer la vérification d'adresse sécurisée. Cliquez sur «Gérer l'appareil» dans la barre latérale.",
  sdcard: "Conservez la carte micro SD séparément du BitBox, à moins que vous ne  souhaitiez gérer les sauvegardes.",
  sendPairing: "Veuillez appairer le BitBox pour vérifier le détails de la transaction en toute sécurité. Cliquez sur «Gérer l'appareil» dans la barre latérale."
};
const welcome$e = {
  connect: "Connexion BitBox02",
  getStarted: "Commençons en installant le firmware sur votre BitBox02",
  insertBitBox02: "Pour le BitBox02, appuyez sur l'appareil pour continuer.",
  insertDevice: "Pour commencer, veuillez connecter votre appareil",
  title: "Bienvenue"
};
const appTranslationsFR = {
  account: account$e,
  accountInfo: accountInfo$e,
  accountSummary: accountSummary$e,
  addAccount: addAccount$f,
  aopp: aopp$8,
  app: app$e,
  auth: auth$8,
  backup: backup$e,
  bb02Bootloader: bb02Bootloader$e,
  bitbox: bitbox$e,
  bitbox02Interact: bitbox02Interact$e,
  bitbox02Settings: bitbox02Settings$e,
  bitbox02Wizard: bitbox02Wizard$e,
  bitsurance: bitsurance$7,
  bitsuranceAccount: bitsuranceAccount$7,
  blink: blink$e,
  bootloader: bootloader$e,
  button: button$j,
  buy: buy$a,
  changePin: changePin$e,
  chart: chart$a,
  checkSDcard: checkSDcard$e,
  clickHere: clickHere$e,
  confirm: confirm$g,
  confirmOnDevice: confirmOnDevice$e,
  connectKeystore: connectKeystore$8,
  darkmode: darkmode$8,
  device: device$e,
  deviceLock: deviceLock$e,
  deviceSettings: deviceSettings$e,
  deviceTampered: deviceTampered$e,
  dialog: dialog$f,
  error: error$a,
  fiat: fiat$g,
  footer: footer$g,
  generic: generic$a,
  genericError: genericError$e,
  goal: goal$e,
  guide: guide$f,
  headerssync: headerssync$e,
  hiddenWallet: hiddenWallet$e,
  initialize: initialize$e,
  invalidFormat: invalidFormat$e,
  language: language$f,
  legacyhiddenwallet: legacyhiddenwallet$e,
  loading: loading$e,
  manageAccounts: manageAccounts$8,
  mobile: mobile$9,
  newSettings: newSettings$7,
  note: note$a,
  notification: notification$e,
  pairing: pairing$e,
  passphrase: passphrase$8,
  password: password$e,
  random: random$f,
  receive: receive$g,
  reset: reset$e,
  securityInformation: securityInformation$e,
  seed: seed$e,
  seedRestore: seedRestore$e,
  send: send$g,
  settings: settings$f,
  setup: setup$e,
  sidebar: sidebar$f,
  success: success$l,
  transaction: transaction$f,
  transactions: transactions$e,
  unknownError: unknownError$e,
  unlock: unlock$e,
  upgradeFirmware: upgradeFirmware$f,
  walletConnect: walletConnect$9,
  warning: warning$k,
  welcome: welcome$e
};
const account$d = {
  disconnect: "接続が切れました。再試行中です…",
  "export": "エクスポート",
  exportTransactions: "取引一覧をCSV形式でダウンロードフォルダにエクスポート",
  fatalError: "予期せぬエラーが起こりました。",
  incoming: "受信中",
  initializing: "ブロックチェーンから情報を取得中…",
  insuranceExpired: "<strong>アカウントに保険が適用されなくなりました</strong>\n\nこのアカウントの保険プランが変更されました。\n詳細については、保険ページをご確認ください。",
  insured: "保険付き口座",
  maybeProxyError: "Torプロキシが有効化されています。Torプロキシが正しく動作していることを確認するか、プロキシ設定を無効にしてください。",
  reconnecting: "接続が切れました。再試行中…",
  syncedAddressesCount: "{{count}}個のアドレスをスキャンしました",
  uncoveredFunds: "",
  uncoveredFundsLink: "コインの移動方法については、こちらのガイドに従ってください。",
  warning: "警告！"
};
const accountInfo$d = {
  address: "アドレス",
  buyCTA: {
    buy: "{{unit}}を購入する",
    buyCrypto: "仮想通貨を購入",
    information: {
      looksEmpty: "このウォレットは空のようです",
      start: "いくつかのコインをウォレットに入金するか、BitBoxAppで直接購入して始めましょう"
    }
  },
  extendedPublicKey: "拡張公開鍵",
  label: "アカウント情報",
  scriptType: "スクリプトタイプ",
  title: "アカウント情報",
  verify: "デバイスで確認",
  xpubTypeChangeBtn: {
    p2pkh: " legacy P2PKH拡張公開鍵を表示",
    p2tr: "Taprootを表示",
    p2wpkh: "ネイティブSegwitを表示",
    "p2wpkh-p2sh": "古いSegwit拡張公開鍵を表示"
  },
  xpubTypeInfo: "現在、{{scriptType}}拡張公開鍵（{{numberOfXPubs}}中の{{current}}）を表示しています"
};
const accountSummary$d = {
  availableBalance: "利用可能な残高",
  balance: "残高",
  exportSummary: "ダウンロードフォルダにアカウント概要をCSV形式でエクスポートする",
  fiatBalance: "フィアット残高",
  name: "アカウント名",
  noAccount: "表示できるアカウントがありません。",
  subtotalWithCoinName: "合計（{{coinName}}）",
  title: "ポートフォリオ",
  total: "合計",
  transactionHistory: "取引履歴"
};
const addAccount$e = {
  chooseName: {
    nextButton: "アカウントを追加",
    step: "アカウント名をつける",
    title: "あなたのアカウントに名前を付けてください"
  },
  selectCoin: {
    nextButton: "次",
    step: "コインを選択",
    title: "仮想通貨を選択"
  },
  success: {
    addAnotherAccount: "別のアカウントを追加",
    message: "<strong>{{accountName}}</strong>があなたのアカウントに追加されました",
    nextButton: "完了",
    step: "終了",
    title: "アカウント追加済み"
  },
  title: "アカウントを追加"
};
const aopp$7 = {
  addressRequest: "{{host}}は受け取りアドレスを要求しています",
  addressRequestWithLogo: "受け取りアドレスを要求しています",
  banner: "アドレスの要求が進行中です。続行するためにデバイスを接続してください。",
  errorTitle: "アドレスのリクエスト中にエラーが起きました",
  labelAddress: "アドレス",
  labelMessage: "メッセージ",
  reverifyInfoText: "アドレスの確認",
  signing: "進めるには、BitBox02でメッセージに署名してください",
  success: {
    message: "{{host}}で進めてください",
    title: "アドレスの送信に成功"
  },
  syncing: "アカウントを同期しています、お待ちください",
  title: "アドレスリクエスト"
};
const app$d = {
  upgrade: "アプリの新しいバージョンが利用可能です！{{current}}から{{version}}にアップグレードしてください。"
};
const auth$7 = {
  authButton: "認証",
  title: "続行するには認証してください"
};
const backup$d = {
  check: {
    checking: "バックアップを確認中…",
    confirmTitle: "バックアップを確認",
    notOK: "このバックアップはウォレットと一致しません。",
    ok: "このバックアップはウォレットと一致します。",
    password: {
      label: "リカバリーパスワード",
      placeholder: "リカバリーパスワード",
      showLabel: "リカバリーパスワード"
    },
    success: "バックアップの検証に成功：",
    title: "バックアップを確認"
  },
  create: {
    alreadyExists: "既に有効なバックアップが存在します。再作成しますか？",
    fail: "バックアップの作成に失敗しました。",
    info: "認証のため、現在のウォレットのリカバリーパスワードを入力してください。",
    name: {
      label: "バックアップの名前",
      placeholder: "バックアップに名前をつけてください"
    },
    password: {
      label: "リカバリーパスワード",
      placeholder: "リカバリーパスワードを入力してください"
    },
    title: "バックアップの作成",
    verificationFailed: "リカバリーパスワードが現在のウォレットと一致しません。バックアップは作成されました。リカバリーパスワードを検証するには「バックアップの確認」をご利用ください。"
  },
  description: "<strong>ウォレットのバックアップファイル</strong>を選択してください",
  insert: "バックアップを管理するにはSDカードを挿入してください。",
  insertButton: "SDカードを挿入しました",
  list: "microSDカード上のバックアップ",
  noBackups: "このmicroSDカードにはバックアップが存在しません。",
  restore: {
    confirmTitle: "バックアップの復元",
    error: {
      e200: "microSDカードが見つかりません",
      general: "バックアップの復元中にエラーが発生しました。"
    },
    password: {
      label: "リカバリーパスワードもしくは秘密リカバリーパスワード",
      placeholder: "リカバリーパスワード",
      repeatPlaceholder: "リカバリーパスワードの確認",
      showLabel: "リカバリーパスワード"
    },
    restoring: "バックアップから復元中…",
    selectedBackup: "<strong>{{backupName}}</strong>は、{{createdDateTime}}に作成され、復元されます。",
    title: "復元",
    understand: "間違ったリカバリーパスワードは別のウォレットを作成することを理解しました"
  },
  showMnemonic: {
    description: "BitBox02上でリカバリーワードが表示され、これらがウォレットのバックアップを形成します。それらを紙に書き留めてください。\n\n<strong>これらをデジタルに保存せず、写真を撮ったりしないでください。</strong>\n\n<strong>これらの言葉を声に出さないでください。</strong>\n\n<strong>このバックアップはパスワードで保護されていません。</strong>\n\nその後、各単語を確認していただくことになります。",
    title: "リカバリーワードを表示する",
    warning: "<strong>リカバリーワードは決して誰にも教えないでください。</strong>それによって、あなたのウォレットへ完全にアクセスできるようになります。もし誰かがあなたのリカバリーワードを尋ねてきたら、それは詐欺師です！"
  },
  title: "バックアップの管理"
};
const bb02Bootloader$d = {
  abort: "アップグレードしない – 前の画面に戻る",
  abort_noUpgrade: "前の画面に戻る",
  advanced: {
    label: "詳細設定",
    toggleShowFirmwareHash: "起動時に毎回ファームウェアのハッシュを表示"
  },
  flipscreen: "画面を反転",
  orientation: "デバイスの向きは合っていますか？　",
  success: "アップグレードに成功しました！{{rebootSeconds}}秒後に次に進みます。",
  success_install: "インストールが成功しました！{{rebootSeconds}} 秒後に次に進みます"
};
const bitbox$d = {
  error: {
    e10000: "現在のデバイスのパスワードが間違っています。",
    e10001: "デバイスのパスワードの変更に失敗しました。",
    e102: "パスワードは4文字以上（半角）必要です。",
    e112: "秘密デバイスのパスワードとメインデバイスのパスワードは同じではいけません。"
  }
};
const bitbox02Interact$d = {
  confirmDate: "本日の日付をBitBox02で確認してください",
  confirmDateText: "この日付はバックアップ作成に使用されます。",
  confirmName: "名前をBitBox02で確認してください",
  confirmWords: "あなたのBitBox02に{{amount}}のリカバリーワードを記入してください",
  confirmWordsText: "その後、BitBox02は、バックアップが正しいかどうかを確認するために、各単語を確認するよう求めます。",
  followInstructions: "BitBox02の手順に従ってください。",
  followInstructionsMnemonic: "バックアップからリカバリーワードを入力し、ウォレットを復元するために、BitBox02の指示に従ってください。",
  followInstructionsMnemonicTitle: "リカバリーワードから復元する"
};
const bitbox02Settings$d = {
  deviceName: {
    current: "現在のデバイス名",
    error: "デバイス名を設定できませんでした。",
    error_104: "デバイス上でデバイス名の確認が中止されました。",
    input: "BitBox02　名前",
    placeholder: "新しいデバイス名",
    title: "BitBox02の名前を設定"
  },
  gotoStartupSettings: {
    description: "これにより、BitBox02が再起動し、起動設定に入ります",
    title: "起動設定に移動"
  }
};
const bitbox02Wizard$d = {
  advanced: {
    button: "詳細オプション",
    outOfDate: "この機能にはファームウェアが古すぎます。",
    seed12WordInfo: "ウォレットを作成した後で単語の数を変更することはできないことに注意してください。",
    seed12WordLabel: "24語のシードの代わりに12語のシードを作成します。",
    seed12WordText: "デフォルトでは、BitBox02は24語のシードを使用します。どちらのシード長も実際のところブルートフォース攻撃に対して安全です。一部のユーザーは12語のシードの便利さを好むかもしれません。",
    skipSDCardLabel: "マイクロSDカードのバックアップをスキップして、代わりにリカバリーワードを書き留めてください",
    skipSDCardText: "セットアップ後にmicroSDカードのバックアップを作成したり、リカバリーワードを書き込んだりするオプションは常に用意されています。これは、設定から行うことができます。",
    title: "高度なバックアップオプション"
  },
  attestationFailed: "正規性チェックに失敗しました。これは、デバイスがユーザー入力を待っている間にアプリを再起動したためである可能性があります。再接続して再試行してください。この問題が続く場合は、support@bitbox.swissにお問合せください。",
  backup: {
    point1: "microSDカードのバックアップを選択してください",
    point2: "デバイスのパスワードを設定",
    restoreText: "さあ、バックアップを復元しましょう！",
    text1: "これでBitBox02のパスワードは設定され、ウォレットも作成されました。次はバックアップを作成しましょう、microSDカードがデバイスに挿入されていることを確認してから次に進んでください。",
    text2: "デバイス上の画面の指示に従って、バックアップを作成してください。",
    text3: "バックアップ作成後にデバイスからmicroSDカードを取り外し、<strong>安全な場所</strong>に保管してください。microSDカードの内容はパスワード保護されていません。BitBox02以外のデバイスに挿入しないよう気をつけてください。",
    userConfirmation1: "バックアップは安全な場所に保管するべきです。",
    userConfirmation2: "バックアップはパスワードによって保護されていません。バックアップにアクセスできる人はあなたのウォレットにもアクセスできます。",
    userConfirmation3: "BitBox02が損傷または紛失した際には、バックアップからしか、資金を復元できません。",
    userConfirmation4: "バックアップとBitBox02の両方を紛失または損傷させた場合、資金は失われます。",
    userConfirmation5: "マイクロSDカードのバックアップをコンピューター、携帯電話、プリンター、またはBitBox02以外の任意のデバイスに挿入すべきではありません。",
    userConfirmation5mnemonic: "リカバリーワードをBitBox02以外のコンピュータ、電話、プリンタ、または他のデバイスに入れるべきではありません。"
  },
  create: {
    button: "デバイス名を設定して続行",
    info: "BitBoxの初期設定には下記のステップを行います：",
    inputTitle: "ウォレット名前",
    point1: "デバイス名の設定",
    point2: "デバイスのパスワードを設定",
    point3: "バックアップ作成",
    text: "さあ、新しいウォレットを作りましょう！"
  },
  createBackupAborted: "バックアップの作成が中断されました。",
  createBackupFailed: "バックアップの作成に失敗しました、再度試してください。",
  initialize: {
    passwordText: "次にデバイスのパスワードを設定しましょう。BitBoxを操作してパスワードの入力を行ってください。",
    passwordTitle: "BitBoxのパスワードを設定",
    text: "BitBox02のペアリングに成功しました！次にデバイスの初期化を行いましょう。まず最初に新しくウォレットを作成するか、既存のバックアップを復元するかを選んでください。<strong>次のステップに進む前に、デバイスにmicroSDカードが挿入されていることを確認してください。</strong>",
    tip: "安全な場所で進めることをお勧めします。",
    title: "BitBoxの初期化"
  },
  insertSDCard: "<strong>BitBox02にmicroSDカードが挿入されていることを確認してください。</strong?",
  noPasswordMatch: "パスワードが一致しませんでした、再度試してください。",
  pairing: {
    failed: "ペアリングが確認できません。BitBox02を挿し直してください。",
    paired: "あなたのデバイスで以下のコードを確認しました。続行してください。",
    title: "ペアリングコードを確認する",
    unpaired: "ペアリングされていないBitBox02が検出されました。ペアリングコードがBitBox02に表示されているものと一致することを確認してください。"
  },
  restoreFromMnemonic: {
    e104: "カバリーワードからの復元がキャンセルされました。",
    failed: "リカバリーワードからの復元に失敗しました、もう一度試してください。"
  },
  stepBackup: {
    beforeProceed: "次へ進む前に、重要なセキュリティ事項を読んでください。",
    createBackup: "これからmicroSDカード上にバックアップを作成します。",
    createBackupMnemonic: "あなたは今、リカバリーワードを書き留めることになります。"
  },
  stepBackupSuccess: {
    fundsSafe: "資金の安全を保つため、次のことを覚えていてください：",
    title: "バックアップを復元しました！"
  },
  stepConnected: {
    unlock: "BitBox02のパスワードを入力してロックを解除してください"
  },
  stepCreate: {
    description: "この名前はデバイス名とバックアップのために使用されます。",
    nameLabel: "BitBox02の名前",
    namePlaceholder: "私のBitBox02",
    title: "BitBox02の名前を決めてください",
    toastMicroSD: "ウォレットのバックアップを保存するために、BitBox02にmicroSDカードを挿入してください。"
  },
  stepCreateSuccess: {
    removeMicroSD: "BitBox02からmicroSDカードを抜いて安全な場所にしまってください。",
    storeMnemonic: "リカバリーワードを安全な場所に保管してください",
    success: "バックアップの作成に成功しました。"
  },
  stepInsertSD: {
    insertSDCard: "次へ進むにはBitBox02にmicroSDカードを挿入してください。",
    insertSDcardTitle: "microSDカードを挿入してください。"
  },
  stepPassword: {
    e104: "パスワードの設定がキャンセルされました。",
    title: "BitBox02のパスワードを設定する",
    useControls: "BitBox02を操作してパスワードを設定してください。"
  },
  stepUninitialized: {
    create: "新しいBitBox02をセットアップする。",
    restore: "バックアップからウォレットを復元する。",
    restoreMicroSD: "microSDカードから復元する",
    restoreMnemonic: "リカバリーワードから復元",
    title: "BitBox02をセットアップする"
  },
  success: {
    text: "おめでとうございます！BitBox02を使い始める準備が整いました。\n\nBitBox Appの使用方法についての詳細は、画面右上のクエスチョンマークからアプリ内のガイドを参照してください。",
    title: "準備が整いました"
  }
};
const bitsurance$6 = {
  dashboard: {
    active: "有効な保険契約",
    button: "新しいアカウントに保険をかける",
    canceled: "キャンセル",
    coverage: "最大適用範囲",
    inactive: "非アクティブ",
    processing: "処理",
    refused: "拒否",
    supportLink: "契約の管理",
    title: "保険付き口座\n",
    waitpayment: "支払いを待っています"
  },
  detect: {
    button: "既存の保険を確認してください。",
    insured: "保険がかけられたアカウントが検出されました：",
    notInsured: "保険付き口座が検出されませんでした。保険付き口座をお持ちの場合は、正しいウォレットが接続されていることをご確認ください。",
    text: "Bitsuranceに既に登録済みの場合、BitBoxAppは自動的に既存の保険内容を同期することができます。",
    title: "すでに保険に加入されていますか？"
  },
  insure: {
    button: "可用性と価格を確認してください",
    faq: "BitsuranceのFAQをもっと読む",
    listItem1: "盗難",
    listItem2: "恐喝（例：5ドルの鉄パイプ攻撃など）",
    listItem3: "火災、水害、自然災害による損害",
    month: "月",
    text: "BitBox02と最大100,000ユーロ相当のビットコインに保険をかけることができます。",
    text2: "保険プランは年間30ユーロ（月額2.50ユーロ）から。Bitsuranceの詳細と正確な保険内容については、以下をご覧ください。",
    text3: "現在ドイツで入手可能で、今後さらに多くの地域で入手可能になる予定。",
    title: "始める"
  },
  intro: {
    link: "Bitsurance のウェブサイト",
    text1: "BitBoxはBitsuranceと連携して、ビットコインの追加の保護層を提供します。BitBox02は資金を安全に保管し、Bitsuranceは自宅での盗難、恐喝、またはハードウェアウォレット自体の破壊など、テクノロジーだけでは緩和できない脅威に対処します。"
  },
  terms: {
    link: "Bitsuranceプライバシーポリシー",
    text1: "Bitsuranceは独立した第三者サービスです。サービス内容や保険請求に関するご質問は、Bitsuranceに直接お問い合わせください。",
    text2: "保険は現在ドイツで利用可能で、今後さらに多くの地域で利用できるようになる。",
    text3: "現在利用可能なビットコインの最高補償額は1人当たり10万ユーロです。将来的にはもっと高額になる予定です。",
    text4: "個人情報と保険契約の拡張公開鍵は、保険契約と関連する情報としてBitsuranceと保険プロバイダーと共有されます。",
    text5: "プライバシーに関する詳細は"
  },
  title: "保険"
};
const bitsuranceAccount$6 = {
  errorNoXpub: "エラー： アカウントからxpubを取得できませんでした。",
  noAccount: "保険に加入できるアカウントはない。　\n",
  select: "アカウント選択",
  title: "保険"
};
const blink$d = {
  button: "点滅"
};
const bootloader$d = {
  button: "ファームウェアをアップグレードする",
  button_install: "ファームウェアをインストールする",
  progress: "アップグレード中：{{progress}}\r%",
  progress_install: "インストール中：{{progress}}\n%",
  success: "アップグレートが完了しました。今回は、ボタンを触らずにデバイスを挿入し直してください。"
};
const button$i = {
  abort: "中止",
  back: "戻る",
  buy: "購入",
  changepin: "デバイスのパスワード変更",
  check: "バックアップの確認",
  "continue": "続行",
  copy: "コピー",
  create: "作成",
  dismiss: "閉じる",
  done: "完了",
  download: "ダウンロード",
  hiddenwallet: "隠しウォレットの作成",
  next: "次へ",
  ok: "OK",
  previous: "前へ",
  receive: "受信",
  restore: "復元",
  select: "選択",
  send: "送信",
  unlock: "アンロック",
  update: "アップデート",
  upgrade: "アップグレード"
};
const buy$9 = {
  exchange: {
    bankTransfer: "銀行振込",
    bestDeal: "最高の取引",
    creditCard: "クレジットカード",
    fast: "高速",
    fee: "手数料",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "銀行振込: {{fee}}%",
          creditDebitCard: "クレジット/デビットカード: {{fee}}%",
          learnMore: "Moonpayについて詳しく知る",
          title: "手数料"
        },
        fullCurrenciesList: "ここで全ての通貨のリストを見る",
        payment: {
          asteriskText: "米国在住の方はご利用いただけません。",
          bankTransfer: "銀行振込",
          bankTransferDetails: {
            pix: "PIX（ブラジル内の取引のみ）",
            sepa: "SEPAおよびSEPAインスタント（SEPA加盟国内のユーロ取引のみ）",
            uk: "UKファスターペイメント（イギリス内のGBP取引のみ）"
          },
          creditDebitCard: "クレジット/デビットカード",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa and Maestro"
          },
          learnMore: "お支払い方法について詳しく見る",
          title: "お支払い方法"
        },
        supportedCurrencies: "すべての主要なフィアット通貨をサポート：USD、EUR、CHFなど。"
      },
      pocket: {
        fees: {
          info: "銀行振込: {{fee}}%",
          title: "手数料"
        },
        learnMore: "Pocketについて詳しく知る",
        payment: {
          bankTransfer: "銀行振込",
          bankTransferDetails: {
            sepa: "「SEPAおよびSEPAインスタント（SEPA国のユーロ取引のみ）」",
            sic: "スイス・インターバンク・クリアリング（CH/LI内のCHF取引のみ）",
            uk: "UKファスターペイメント（イギリス内のGBP取引のみ）"
          },
          bankTransferReccuring: "スタンディングオーダーでの定期購入をどのように設定しますか？",
          title: "お支払い方法"
        },
        supportedCurrencies: "欧州通貨に対応：EUR, GBP, and CHF.",
        verification: {
          info: "日次と年次のしきい値を超える場合にのみ、身元確認が必要です。",
          link: "現在のしきい値はこちら",
          title: "本人確認"
        }
      },
      region: {
        title: "お客様の銀行口座が登録されている地域を選択すると、どのようなオプションが利用できるかを確認することができます。"
      }
    },
    noExchanges: "申し訳ございませんが、この地域では利用可能な取引所はございません。",
    region: "地域",
    selectRegion: "指定なし",
    title: "{{name}}購入"
  },
  info: {
    "continue": "同意して続ける",
    crypto: "仮想通貨",
    disclaimer: {
      intro: [
        "私たちはMoonPayと提携し、BitBoxApp内で直接{{name}}を購入するためのシームレスな方法を提供しています。数回クリックするだけです。",
        "MoonPayは、160以上の国で{{name}}を簡単かつ迅速に購入することができるプラットフォームです。"
      ],
      payment: {
        details: "MoonPay経由で、以下の支払い方法で{{name}}を即座に購入することができます。クレジットカードまたはデビットカードの注文は即座にできて便利ですが、チャージバックのリスクが高まるため、割高になります。大量の購入には銀行振込のご利用をお勧めします。最低手数料は4 USD/EURまたはそれに相当する金額です。",
        footnote: "MoonPayの為替レートはBitBoxAppで使用されているものと異なる場合があり、その結果、金額が若干異なることをご了承ください。",
        table: {
          "1_description": "最安値の料金で、最大3営業日かかります。",
          "1_method": "銀行振込(SEPA)",
          "2_description": "手数料は高いが、迅速な対応で即座に",
          "2_method": "クレジットとデビットカード",
          description: "概要",
          fee: "手数料",
          method: "方法"
        },
        title: "支払い方法と手数料"
      },
      privacyPolicy: "MoonPayのプライバシーポリシー",
      protection: {
        description: "BitBoxAppは{{name}}を購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。MoonPayは運用のために一部の個人情報を収集する必要があります。そのプライバシーポリシーでは、そのデータがどのように取り扱われるかが詳細に説明されています。",
        descriptionGeneric: "BitBoxAppは{{name}}を購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。しかし、パートナーの取引所は運営のためにいくつかの情報を収集する必要があります。データがどのように取り扱われるのか、詳細は各々のプライバシーポリシーをご覧ください。",
        title: "データ保護"
      },
      security: {
        description: "MoonPay経由で{{name}}を購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。",
        descriptionGeneric: "パートナーの取引所経由で{{name}}を購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。",
        link: "キュリティ脅威モデル",
        title: "セキュリティモデル"
      },
      title: "ようこそ、{{name}}を買うためのワンストップショップへ。"
    },
    next: "次へ",
    selectLabel: "アカウントを選択する",
    selectPlaceholder: "コインを選択する",
    skip: "再表示しない",
    title: " {{name}}購入 "
  },
  pocket: {
    data: {
      link: "Pocket のプライバシーポリシー",
      p1: "BitBoxAppはビットコインを購入する際には一切のデータを収集しません。入金される資金は通常の取引として取り扱われます。Pocketは運用のために一部の個人情報を収集する必要があります。そのプライバシーポリシーでは、そのデータがどのように取り扱われるかが詳細に説明されています。",
      title: "データ保護"
    },
    kyc: {
      link: "Pocket よくあるご質問を読む",
      p1: "PocketはKYC（顧客の本人確認）を最小限に抑えるよう努力しています。1日に950ユーロ（1000スイスフラン）以下の購入には、追加の書類は必要ありません。この金額を超える購入には、必要なKYC/AML（アンチマネーロンダリング）プロセスを完了するために、Pocketとの電話予約をする必要があります。",
      title: "KYC/AML"
    },
    payment: {
      p1: "SEPA銀行振込を利用して、Pocketを通じてビットコインを即時に購入することができます。手数料は1.5%で、Pocketが銀行振込を受け取った後できるだけ早くビットコインがあなたのBitBoxに預けられます（通常は同日中）。",
      p2: "Pocketの為替レートはBitBoxAppで使用されるものと異なる場合があり、その結果、少し異なる金額になることに注意してください。",
      title: "支払い方法と手数料"
    },
    previousTransactions: "このアカウントの取引履歴は空ではありません。このアカウントを共有すると、過去及び未来の全ての取引がPocketに表示されます。それでも進みますか？",
    security: {
      link: "BitBox02のセキュリティ脅威のモデル",
      p1: "Pocket経由でビットコインを購入するとき、あなたは外部のサービスを利用しています。このサービスはBitBox02のセキュリティ脅威モデルの範囲外であり、BitBoxAppソフトウェアが動作している環境の安全性とセキュリティに依存しています。しかし、あなたが受け取るアドレスを確認するために二要素認証メカニズムを使用して、我々は共同でセキュリティを向上させる努力をしています。",
      title: "セキュリティモデル"
    },
    usedAddress: "アドレス{{address}}はすでに使用されているため、新しいアドレスでやり直してください。",
    verifyBitBox02: "あなたがメールで受け取ったアドレスがBitboxに表示されているアドレスと一致することを確認してください。可能であれば、より高いセキュリティを確保するために、別のデバイスでメールを開くべきです。",
    welcome: {
      p1: "私たちはPocketと提携し、BitBoxApp内で直接ビットコインを購入するシームレスな方法を提供しています。数回クリックするだけです。",
      p2: "Pocketはスイスのプラットフォームで、ヨーロッパのほとんどの地域（SEPA銀行送金がサポートされている場所）でビットコインを迅速かつ簡単に購入することができます。",
      p3: "Pocketを利用すると、定期的な銀行注文を通じて定期的な購入も行うことができますので、簡単にDCA（ドルコスト平均法）を実践することができます。",
      title: "ビットコインを購入するためのワンストップショップへようこそ"
    }
  },
  title: "{{name}}を購入"
};
const changePin$d = {
  newTitle: "新しいデバイスパスワード",
  oldLabel: "現在のデバイスパスワード"
};
const chart$9 = {
  dataMissing: "過去のデータを収集中です...お待ちください",
  dataOldTimestamp: "過去の為替レートが更新されています。{{time}}以降のデータがチャートに表示されません。",
  dataUpdating: "データを更新中です...",
  filter: {
    all: "全て",
    month: "月",
    week: "週",
    year: "年"
  }
};
const checkSDcard$d = "microSDカードを確認しています";
const clickHere$d = "こちらをクリック";
const confirm$f = {
  abortInfo: "タップしてください",
  abortInfoRedText: "中止する",
  approveInfo: "4秒以上長押ししてください",
  approveInfoGreenText: "確認",
  info: "BitBoxで続けてください",
  infoWhenPaired: "まずペアリングされたモバイルアプリで操作し、次にBitBox上で続けてください"
};
const confirmOnDevice$d = "デバイス上で確認してください。";
const connectKeystore$7 = {
  promptNoName: "続行するには、BitBox02を接続してください",
  promptWithName: '"{{name}}" という名前のBitBox02を接続してください'
};
const darkmode$7 = {
  toggle: "ダークモード"
};
const device$d = {
  appUpradeRequired: "あなたのBitBoxはこのソフトウェアとの互換性がありません。最新のバージョンをダウンロードしてからインストールしてください。",
  keystoreConnected: "接続されたウォレット"
};
const deviceLock$d = {
  button: "2段階認証(2FA)を有効にしてください",
  condition1: "バックアップはありますか？",
  condition2: "モバイルアプリでの検証はできていますか？",
  condition3: "2段階認証(2FA)はバックアップ及びモバイルアプリのペアリングを無効にします。2段階認証を終了するにはデバイスのリセットが必要です。",
  confirm: "2段階認証(2FA)を有効にする",
  title: "2段階認証(2FA)を有効にする"
};
const deviceSettings$d = {
  backups: {
    manageBackups: {
      description: "マイクロSDカードのバックアップを作成するか確認してください。"
    },
    showRecoveryWords: {
      description: "リカバリーワードを表示し、確認する。"
    },
    title: "バックアップ"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxAppはあなたのデバイスが本物であるかどうかを確認します"
    },
    deviceName: {
      description: "あなたのデバイスの名前を変更してください。"
    },
    rootFingerprint: {
      description: "ルートフィンガープリントは、現在使用中のウォレットに対して固有の識別子です。パスフレーズを使用する場合、異なるウォレットを区別するのに役立ちます。"
    },
    securechip: {
      description: "セキュアチップのモデルです。"
    },
    title: "デバイス情報"
  },
  expert: {
    factoryReset: {
      description: "デバイスを工場出荷時の設定にリセットしてください。これによって、BitBox02からウォレットが削除されます！",
      title: "工場出荷時の設定にリセットします。"
    },
    goToStartupSettings: {
      description: "BitBox02のブートローダーに入ります。ここからファームウェアハッシュを有効にすることができます。"
    },
    passphrase: {
      description: "パスフレーズ機能を有効または無効にします。",
      title: "パスフレーズ"
    }
  },
  firmware: {
    firmwareVersion: "ファームウェアのバージョン",
    newVersion: {
      label: "使用可能なバージョン"
    },
    title: "ファームウェア",
    upToDate: "デバイスは最新の状態です",
    upgradeAvailable: "新しいアップグレードが可能です",
    version: {
      label: "バージョン"
    }
  },
  hardware: {
    attestation: {
      "false": "認証チェックに失敗しました",
      label: "真贋チェック",
      "true": "あなたのBitBox02は本物です"
    },
    sdcard: {
      "false": "挿入されていません",
      label: "microSDカード",
      "true": "挿入されています"
    },
    securechip: "セキュアチップ",
    title: "ハードウェア"
  },
  loading: "デバイス情報を読込中…",
  pairing: {
    lock: {
      "false": "無効",
      label: "2段階認証(2FA)",
      "true": "有効"
    },
    mobile: {
      "false": "停止中",
      label: "モバイルアプリ",
      "true": "起動中"
    },
    status: {
      "false": "ペアされていません",
      label: "ステータス",
      "true": "ペアされています"
    },
    title: "ペアリング"
  },
  secrets: {
    manageBackups: "バックアップを管理",
    title: "秘密"
  }
};
const deviceTampered$d = "あたなのBitBoxにリカバリーパスワードが同梱されていた場合、直ちにセットアップをやめてサポートに連絡をしてください。Shiftは設定済みのウォレットの販売及びパスワードの推奨を行うことはありません。";
const dialog$e = {
  cancel: "キャンセル",
  confirm: "確認",
  confirmTitle: "確認"
};
const error$9 = {
  accountAlreadyExists: "アカウントはすでに存在しています。",
  accountLimitReached: "アカウントを追加できません。このコインのアカウント最大数に達しました。",
  aoppCallback: "アドレスを{{host}}に配信する際にエラーが発生しました。",
  aoppInvalidRequest: "無効なリクエストです",
  aoppNoAccounts: "利用可能なアカウントはありません。",
  aoppSigningAborted: "アドレス所有権の要求がキャンセルされました。",
  aoppUnknown: "不明なエラーが発生しました",
  aoppUnsupportedAsset: "アセットがサポートされていません。",
  aoppUnsupportedFormat: "要求されたアドレス形式をサポートする利用可能なアカウントはありません。",
  aoppUnsupportedKeystore: "接続されたデバイスは、このアセットのメッセージに署名できません",
  aoppVersion: "不明なバージョンです。",
  wrongKeystore: "接続されたウォレットが間違っています。このアカウントに合致する正しいデバイスを挿入しているかを確認してください。",
  wrongKeystore2: "オプションのパスフレーズを使用している場合、アカウントの正しいパスフレーズを入力していることを確認してください。"
};
const fiat$f = {
  "default": "デフォルト",
  setDefault: "{{code}}をデフォルトに設定する",
  title: "通貨"
};
const footer$f = {
  appVersion: "アプリのバージョン："
};
const generic$9 = {
  enabled_false: "無効化",
  enabled_true: "有効化"
};
const genericError$d = "エラーが発生しました。問題が起きた場合はソフトウェアを再起動してください。";
const goal$d = {
  buttons: {
    create: "新しいウォレットの作成",
    restore: "バックアップからウォレットを復元"
  },
  paragraph: "次の中から一つ選択してください",
  step: {
    "1": {
      title: "セキュリティ情報"
    },
    "2": {
      description: "デバイスパスワード",
      title: "デバイス"
    },
    "3-create": {
      description: "新しいウォレットの作成",
      title: "ウォレット"
    },
    "3-restore": {
      description: "バックアップから",
      title: "復元"
    },
    "4-create": {
      title: "概括"
    },
    "4-restore": {
      title: "概括"
    }
  }
};
const guide$e = {
  accountDescription: {
    text: "あなたのアカウント概要は、利用可能な残高と受け取りおよび送り出しのトランザクションを表示します。「設定」のガイドには、各アカウントタイプに関する詳しい情報があります。",
    title: "ここには何を示していますか？"
  },
  accountFiat: {
    text: "はい。どのティッカーでもクリックするとフィアット通貨が順に切り替わります。設定で通貨のリストを変更することができます。",
    title: "他の換算レートも表示できますか？"
  },
  accountIncomingBalance: {
    text: "受信中は、あなたに送金されたがまだネットワークによって確認されていない金額を合計します。",
    title: "受信中とはどういう意味ですか？"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'それぞれのxpubは、表示された"Type"（タイプ）に結びついています："Native Segwit (bech32)"、"Wrapped Segwit"または“Taproot”（ビットコインのみ）。これらは{{coinName}}で使用されるスクリプトタイプです。BitBoxAppはこれらを組み合わせ、同じアカウントで複数のスクリプトタイプをサポートします。各スクリプトタイプは異なるxpubを提供するため、アカウントごとに複数のxpubが存在します。\n\nデフォルトのアドレス（Native Segwit）に一貫して受け取る場合、"bech32" xpubだけが必要です。しかし、"Wrapped Segwit"または“Taproot”にも資金を受け取る場合は、それぞれ"Wrapped Segwit"と“Taproot”の拡張公開鍵も使用する必要があります。',
      title: "なぜ複数のxpubが存在するのですか？"
    },
    privacy: {
      text: "この特定のアカウントでは、拡張公開キー（xpub）が全ての金融履歴、アカウントの残高、そして全ての将来の取引を明らかにします。しかし、xpubでは誰もあなたのコインを使うことはできません。\n\nもしxpubを誰かに渡す場合、その人や会社が同一のアカウントの他の全ての取引を見ることができることを理解しておくべきです。それゆえ、その目的のためだけにそのアカウントを使用し、他の資金は別のアカウントに保管するのが良い考えです。",
      title: "私のxpub（拡張公開キー）を秘密に保つ必要がありますか？"
    },
    verify: {
      text: "はい、xpubを再確認することは常に良い考えです。もし他の人があなたにお金を送るためにこのxpubから受け取りアドレスを生成する場合、これは特に重要です。このxpubがあなたのものであることを確認するために、デバイス上で確認する必要があります。そうしないと、全ての資金が誤ったアドレスに送られる可能性があります。",
      title: "デバイス上でxpub（拡張公開キー）を確認する必要がありますか？"
    },
    xpub: {
      text: "拡張公開キー（xpub）は、アカウントの全ての受け取りアドレスが派生するルートキーです。\n\nこれは、ElectrumやSentinelなどのウォッチオンリー（閲覧専用）ウォレットとの高度な使用と相互運用性のために提供されています。異なるアドレスタイプに対して資金を受け取った場合は、全てのコインを確認するために、異なるxpubフォーマット全てをウォッチオンリーウォレットにインポートしてください。\n\nただし、第三者のウォレットはまだTaproot xpubをサポートしていないかもしれませんので、ご注意ください。",
      title: "拡張公開鍵とはなんですか？"
    }
  },
  accountRates: {
    text: "換算レートは毎分CoinGeckoの情報を取得して更新されます。",
    title: "どの為替レートが適用されますか？"
  },
  accountReload: {
    text: "それは必要ありません。あなたの取引情報は自動的に更新されます。",
    title: "取引履歴を再読み込みすることは可能ですか？"
  },
  accountSendDisabled: {
    text: "「送信」ボタンは残高が0以上の時に有効になります。",
    title: "{{unit}}を送ることが出来ないのですが？"
  },
  accountSummaryAmount: {
    text: "合計金額は、すべての仮想通貨アカウントの合計です。為替レートはcoingecko.comから取得されます。\n\n注意: BitBoxAppでサポートされていないトークンをMyEtherWalletで使用している場合、表示される金額には含まれません。\n\n\n\n",
    title: "総額はどのように算出されるのですか？"
  },
  accountSummaryDescription: {
    text: "ここでは、ポートフォリオの時間経過に伴うパフォーマンスを確認できます。チャートの下には、個々の仮想通貨アカウントのサマリーが表示されます。",
    title: "このページは何を示しているのでしょうか？"
  },
  accountTransactionAttributesBTC: {
    text: "バーチャルサイズ（Virtual size）：ネットワーク手数料を決定する要素です。もしトランザクションサイズよりも小さい場合、手数料を節約できています。\nサイズ（Size）：ブロックチェーンに基づいてシリアライズされた場合の実際のトランザクションサイズ（バイト単位）です。\nウェイト（Weight）：Segwitで導入された新しい指標で、トランザクションやブロックのサイズを評価するために使用されます。Segregated Witnessのバイトは1として数えられ、それ以外は4のウェイト単位として数えられます。従来の1メガバイトのサイズではなく、ブロックサイズの制限は現在400万のウェイト単位となります。",
    title: "ビットコイン特有の取引内容についてはどうでしょうか。　"
  },
  accountTransactionAttributesGeneric: {
    text: "\n承認数：最初のトランザクションのブロードキャストは、マイナーがそれをブロックに含めるまで承認されていません。ブロードキャストされた各ブロックは、取引に別の承認を追加します。一般的に、商人や他のネットワーク参加者は、取引が3〜6回の承認を受けた後にのみ決済を行います。\nトランザクションID：block explorerでトランザクションを検索するための一意の識別番号です。\n手数料：マイナーはトランザクションをブロックに含めるためのインセンティブとして手数料を受け取ります。詳細については、送信ボタンをクリックしてください。",
    title: "取引明細に記載されている情報は何ですか？"
  },
  accountTransactionConfirmation: {
    text: "ネットワークにブロードキャストされたが、まだ承認されていないトランザクションです。",
    title: "ペンディングトランザクションとは何ですか？"
  },
  accountTransactionLabel: {
    text: "それは、コインを受け取ったアドレスまたはコインを送ったアドレスです。\n",
    title: "各トランザクションには、どのアドレスが表示されますか？"
  },
  accountTransactionTime: {
    text: "ブロックチェーントランザクションの確認時間です。\n",
    title: "表示される時間は何時ですか？"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoinと Litecoinは任意の数のアカウントを持つことができます。5つのアカウントがある場合、前のアカウントが使用された場合のみ別のアカウントを追加できます。\n他のコインは最大で5つのアカウントを持つことができます。",
      title: "何個のアカウントを作成することができますか？"
    },
    howtoAddTokens: {
      text: "ERC20標準を使用するトークンは特定のイーサリアムアカウントに関連付けられています。特定のトークンを有効にしたり無効にしたりするには、「アカウントの管理」画面を開き、あなたのイーサリアムアカウントを展開し、目的のトークンをオンまたはオフに切り替えます。",
      title: "トークンを追加したいのですが、どうすればよいですか？"
    },
    moveFunds: {
      text: "はい。しかし、アカウントが独立しているため、通常の取引を使用して資金を送金する必要があります。",
      title: "アカウント間で資金を移動することは可能ですか？"
    },
    recoverAccounts: {
      text: "はい。BitBoxAppは、他のほとんどの暗号ウォレットと互換性のある、確立された標準を使用してアカウントを作成します。",
      title: "他のウォレットのアカウントを復元することはできますか？"
    },
    whatAreAccounts: {
      text: "ウォレットは、同じコインの複数のアカウントを管理することができます。資金を別々に管理したいときに便利です。",
      title: "アカウントとは何ですか？"
    },
    whatIsRememberWallet: {
      text: "「ウォレットを記憶する」を有効にすると、BitBox02が接続されていない状態でもBitBoxAppでこのウォレットのアカウントを表示できます。これにより、いつでも残高とポートフォリオを確認できます。ただし、コインを送受信するには、BitBox02を接続し、ロックを解除する必要があります。\n\n「ウォレットを記憶する」を無効にすると、該当するBitBox02（またはパスフレーズウォレット）をBitBoxAppでアカウントを表示するために接続する必要があります。\n",
      title: "「ウォレットを記憶する」を有効／無効にするとどうなりますか？"
    },
    whyIsThisUseful: {
      text: "アカウントは分離されているため、異なる人や目的のための資金を管理するのに適しています。また、アカウントの「拡張公開鍵」を共有することで、他のアカウントについて何も明かすことなく利用することができます。これにより、給料の受け取りや暗号の定期購入など、アドレスを再利用することなく繰り返し資金を受け取ることができます。",
      title: "なぜこれが便利なのでしょうか？"
    }
  },
  appendix: {
    link: "ご連絡ください！",
    text: "他にも質問がありますか？"
  },
  backups: {
    check: {
      text: "「バックアップのチェック」機能により、現在のウォレットに対応する動作するバックアップを確認することができます。また、正しいリカバリーパスワードを持っているかどうかを確認するためにも使用することができます。メインのリカバリーパスワードまたは隠しリカバリーパスワードのどちらかをチェックすることができます。",
      title: "「バックアップのチェック」とは何ですか？"
    },
    encrypt: {
      text: "できませんが、保管されたシードから正しいウォレットを復元するには関連付けたリカバリーパスワードが必要です。",
      title: "バックアップを暗号化することはできますか？"
    },
    howOften: {
      text: "新しいウォレットが作成されると、バックアップは自動的に生成されます。microSDカードが紛失または破損した場合、または複数のmicroSDカードをバックアップとして使用したい場合を除き、新しいバックアップを作成する必要はありません。\n取引後に新しいバックアップを作成する必要はありません。すべての取引データは、自動的に生成された単一のバックアップによって再作成できます。",
      title: "どれだけ頻繁にバックアップを作成するべきですか？"
    },
    whatIsABackup: {
      text: "microSDカードにシードをコピーしたものです。シードとリカバリーパスワードを合わせてウォレットを生成します。",
      title: "バックアップとは？"
    }
  },
  backupsBB02: {
    check: {
      text: "「バックアップの確認」では現在のウォレットに対応するバックアップが動作しているかどうかを確認することができます。",
      title: "「バックアップの確認」とは？"
    },
    encrypt: {
      text: "いいえ。microSDカードにはウォレット復元のために必要な暗号化されていないシード情報を含んでいるため、安全な場所に保管してください。シードをパスワードで保護したい場合は、エキスパート設定の「デバイスの管理」でオプションのパスフレーズを有効にすることができます。",
      title: "バックアップを暗号化することはできますか？"
    },
    whatIsABackup: {
      text: "microSDカードにシードをコピーしたものです。",
      title: "バックアップとは？"
    }
  },
  bitbox: {
    "2FA": {
      text: "2段階認証(2FA)が有効な場合、コインを消費するには全ての取引をペアされた携帯電話で承認する必要があります。裏側では暗号化された一回限り使用可能な番号をモバイルアプリに送信し、承認ボタンが押されたタイミングで解読された番号をBitBoxに送り返します。この送受信は、最初にモバイルアプリとのペアリングを行った際に開設されたチャンネルを使用します。\n2段階認証(2FA)を有効にする前に、必ずウォレットのバックアップを作成し、モバイルアプリとのペアリングを行ってください。2段階認証(2FA)が有効になると、バックアップ時に使用されるmicroSDカードスロットとモバイルアプリのペアリングは無効となります。これらを再度使用したい場合は再設定、つまりはBitBoxをリセットしなければなりません。",
      title: "2段階認証(2FA)はどのように機能するのですか？"
    },
    disable2FA: {
      text: "2段階認証(2FA)を無効にするためには、BitBoxをリセットし、バックアップからウォレットを復元する必要があります。バックアップが記録されているmicroSDカードをまだ持っていること、そしてリカバリーパスワードをまだ覚えていることを確認してください。それから、「デバイスをリセット」を押します。新しいデバイスパスワードを設定し、「バックアップを復元する」を選択します。ウォレットから作成したバックアップを選択し、「復元」をクリックし、ウォレットを作成する際に使用したリカバリーパスワードを入力します。",
      title: "どのように2段階認証(2FA)を無効にするにはどうしたらいいですか？"
    },
    ejectBitbox: {
      text: "BitBoxはいつでも取り外すことができます。",
      title: "どのようにBitBoxを取り出すのですか？"
    },
    ejectSD: {
      text: "バックアップの作成・復元作業中でなければ、いつでもmicroSDカードをBitBoxから取り外すことができます。",
      title: "microSDカードを取り出すにはどうしたらよいですか？"
    },
    hiddenWallet: {
      text: "隠しウォレットとは同じデバイス上にあり、別のパスワード・リカバリーパスワードで守られた２つ目のウォレットであり、妥当な否認権(plausible deniability)として使用できます。普通のウォレットと隠しウォレット両方で一つのバックアップを使用するので、新しくバックアップを作成する必要はありません。",
      title: "隠しウォレットとは何ですか？"
    },
    legacyHiddenWallet: {
      text: "最初に下のボタンをクリックし（BitBoxがメインデバイスパスワードによりアンロックされていて、2段階認証が無効な場合押すことができます）、BitBoxを挿し直してから秘密デバイスパスワードでアンロックしてください。",
      title: "どのように legacyの秘密ウォレットにアクセスできますか？"
    },
    pairing: {
      text: "iOSもしくはAndroid用のモバイルアプリのダウンロード後、表示されているQRコードをスキャンすることでこのソフトウェアとモバイルアプリの間に安全なチャンネルが開設されます。スキャン後はモバイルアプリに表示される手順に従ってペアリングを行なってください。",
      title: "安全に携帯電話とペアリングを行うには"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "詳しくはBitsuranceのウェブサイトとFAQをご覧ください。",
      title: "他に質問はありますか？"
    },
    privacy: {
      link: {
        text: "Bitsuranceプライバシーポリシー"
      },
      text: "通常の保険契約と同様に、この契約にはあなたのフルネームと住所が含まれ、保険対象物（保険されたビットコインアカウントの拡張公開鍵によって定義されます）が明示されています。このデータはBitsuranceに直接提出され、Shift Cryptoとは共有されません。詳細についてはBitsuranceのプライバシーポリシーをご参照ください。\n\n\n\n\n\n",
      title: "保険にはどのような個人情報が必要ですか？"
    },
    renew: {
      text: "保険は次年度に自動更新されます。BitBoxAppの「契約管理」をクリックし、Bitsuranceカスタマーポータルに移動すると、いつでも更新をキャンセルできます。",
      title: "保険の更新や解約はどうすればよいですか？"
    },
    status: {
      text: "保険が適用されたアカウントは、各ビットコインアカウントページの左上隅に緑色の「保険」バッジで表示されます。また、「保険」セクションでは、すべての保険がかけられたビットコインアカウントとその現在の保険状況の概要を確認できます。",
      title: "保険付き口座の状況を確認できますか？"
    },
    what: {
      text: "各ビットコイン保険契約は特定のウォレットアカウントをカバーします。複数のアカウントを保険できるように、複数の保険ポリシーを取り扱うことができます。保険の対象となるアカウントは、「Native Segwit」ビットコインアドレスの使用に制限されています。",
      title: "BitBoxウォレット全体に保険はかけられてますか？"
    },
    who: {
      text: "保険はビットコイン関係者によって設立された保険ブローカーであるBitsuranceによって提供されています。彼らはELEMENT Insuranceと提携してビットコイン保険を提供しています。両社はドイツに拠点を置いています。\n",
      title: "私のビットコインに保険をかけるのは誰ですか？"
    },
    why: {
      text: "Bitsuranceは、最も安全なウォレットにも含まれない、自己保管のいくつかのリスクをカバーしています。たとえば、強盗、恐喝、またはウォレットの破壊などです。これらのリスクに対する保険が必要かどうかは、あなた個人の判断によります。",
      title: "ビットコインの保険は必要ですか？"
    }
  },
  cointracking: {
    text: '"エクスポート"ボタンをクリックし、CSVエクスポートが見つかるダウンロードフォルダを開きます。その後、以下のリンクをクリックし、BitBoxのCSVファイルをアップロードしてデータをインポートします。これにより、CoinTrackingのポートフォリオマネージャーで使用したり、税金報告書を作成したりすることができます。',
    title: "CoinTrackingに自分の取引をどのようにインポートするか？"
  },
  device: {
    attestation: {
      link: {
        text: "真贋チェックの詳細はこちら"
      },
      text: "BitBoxAppは、デバイスが本物であることを確認するために、BitBox02に対して認証チェックを実行します。このチェックはローカルで行われ、サーバーには接続しません。",
      title: "真贋チェックはどのように行われるのですか？"
    },
    name: {
      text: "これはあなたのウォレットとバックアップの名前です。この名前は将来のバックアップに使われ、異なるウォレットを区別するのに役立つことがあります。いつでも変更することができますが、変更前に作成したバックアップは以前の名前を使用し続けることに注意してください。",
      title: "BitBox02の名前は何に使われているのですか？"
    },
    "secure-chip": {
      link: {
        text: "セキュアチップについて詳しく見る"
      },
      text: "この情報はセキュアチップのモデル番号を表示しています。最新のチップはATECC608Bで、旧モデルに比べてセキュリティ機能が向上しています。",
      title: "セキュアチップモデルを見せる理由は？"
    }
  },
  receive: {
    address: {
      text: "あなたは他の人にこのアドレスを教えて、コインを送ってもらうことができます。ただし、正しいアドレスに送金していることを確認してください。",
      title: "アドレスは何に使用することができますか？"
    },
    addressChange: {
      text: "取引を行うとすぐに、新しいアドレスが自動的にリストに追加され、常に受け取り履歴のないアドレスが20個利用可能となります。",
      title: "アドレスが変わるのはいつですか？"
    },
    addressFormats: {
      text: "デフォルトでは、アドレスタイプはNative Segwitです。このアドレスタイプは他のウォレット/取引所に広く採用されており、日常のトランザクションに最適な手数料率を提供します。しかし、Taproot（ビットコインのみ）に送ることも選択できます。これは最新のアドレスタイプですが、まだ広くサポートされていないかもしれません。また、Native Segwit（デフォルトタイプ）への送金に問題がある場合は、より多くのウォレット/取引所と互換性がある可能性のある古いWrapped Segwitアドレスタイプに切り替えることを試みることができます。",
      title: '"アドレスタイプを変更"はいつ使用しますか？」という質問に対する回答は次のとおりです：'
    },
    howVerify: {
      text: "BitBox01については、左側のサイドバーにあるBitBoxアイコンをクリックし、「ペアリング」セクションを参照してください。ガイドが更新され、そこから指示に従って続行することができます。\nBitBox02では、送受信プロセス中にデバイス上で直接アドレスを確認することができます。",
      title: "安全にアドレスを検証するにはどうすればいいですか？"
    },
    plugout: {
      text: "BitBoxのアドレスにコインを送った後は、BitBoxを接続したままにしておく必要はありません。BitBoxの接続を解除することは自由です。",
      title: "受信中、BitBoxを接続したままにしておく必要はありますか？"
    },
    why20: {
      text: "スタートアップ時に、アプリはあなたのシードから派生したアドレスを生成し、彼らが資金を受け取ったかどうかを確認します。アプリはほぼ無限にアドレスを生成できるため、残高の確認に何年も費やす可能性があります。この検索を制限するために、資金を受け取ったことがないアドレスを20個見つけたら停止するようにしています。これが「ギャップリミット」で、20個がデファクトスタンダードになっていますが、その数は任意です。これが、あなたが選ぶことのできる20のアドレスです。",
      title: "なぜ20個のアドレスだけなのですか？"
    },
    whyMany: {
      text: "プライバシーとセキュリティを保つため、同じアドレスを2度渡さないようにしてください。アドレスを使用してしまった場合は、右矢印をクリックして新しいアドレスを作成してください。一度に最大20個のアドレスを生成することができます。住所は、請求書番号のようなものだと考えてください。すべてのアドレスは、あなたの1つのバックアップシードから派生します。",
      title: "なぜこんなにたくさんのアドレスが存在するのですか？"
    },
    whyVerify: {
      text: "コンピュータが本物のアドレスを生成して表示することを信用してはいけません。攻撃対象が大きいので、ハードウェアウォレットよりもかなり脆弱です。BitBox01の場合、アドレスを確認するボタンは、ペアリングされた携帯電話にアドレスを安全に送信し、そこからQRコードをスキャンして確認することもできます。BitBox02の場合は、BitBox02のディスプレイ上で直接アドレスを確認することができます。",
      title: "なぜ安全にアドレスを検証したほうがいいのですか？"
    }
  },
  send: {
    change: {
      text: "Taproot UTXOが1つ以上あれば、お釣りはTaprootアドレスに返却されます。コインコントロールを使用する場合、選択したUTXOの中に少なくとも1つのTaproot UTXOがある場合、釣りはTaprootアドレスに返されます。それ以外の場合は、Native Segwitアドレスにお釣りが返されます。",
      title: "変化出力はどのように決定されるのですか？"
    },
    fee: {
      text: "手数料は取引の総額ではなくデータサイズによって決まります。手数料は選択したネットワーク優先度毎にBitcoin Coreの手数料見積もりアルゴリズムを使用して算出されます。結果が下記情報と違った場合に表示されます。\nエコノミー：24ブロック(Bitcoinで約4時間、Litecoinで約1時間)\n低：12ブロック(Bitcoinで約2時間、Litecoinで約30分)\n普通：6ブロック(Bitcoinで約1時間、Litecoinで約15分)\n高：2ブロック(Bitcoinで約20分、Litecoinで約5分)\n(1つのブロックを採掘するのにBitcoinで約10分、Litecoinで約2.5分かかり、上記時間内にネットーワーク負荷が変化する可能性もあります。)",
      title: "手数料はどのように計算されているのですか？"
    },
    plugout: {
      text: "いいえ、一度取引した後は、BitBoxを接続したままにしておく必要はありません。BitBoxの接続を解除することは自由です。",
      title: "送信中にBitBoxを接続したままにしておく必要はありますか？"
    },
    priority: {
      text: "高い手数料を払うほど、より早くあなたの取引がネットワークに認証されます。",
      title: "ネットワーク優先度とは何ですか？"
    },
    revert: {
      text: "一度署名し、送信された(ネットワークに向けて発信された)取引は取り消すことができません。署名を行う前に取引内容の確認(手数料を含む)を行なってください！\n送信先の人を知っていて、その人が同額(手数料含まず)を送り返してくれるのであれは、新しい受信用アドレスをその人に教えてください。",
      title: "取引を取り消すことは可能ですか？"
    },
    whyFee: {
      text: "取引は採掘者によって承認されるよう競争しています。採掘者はブロックに含む取引を手数料によって決めています。採掘者は取引履歴を元に投票しており、1人につき1票を取り締まる第三者がいないため(そもそもブロックチェーンが存在する理由)、高価なパソコン演算力などのリソースを犠牲に投票しています。これに対する報酬として、新しく作られたコインとブロックに含めた取引の手数料を獲得できます。",
      title: "なぜネットワーク手数料は存在するのですか？"
    }
  },
  "settings-electrum": {
    connection: {
      text: "同じネットワーク（例：自宅のwifi）にいるときだけノードに接続するつもりであれば、通常のネットワーク通信を使用すれば十分です。\nこの場合、Electrumサーバーは、通信を暗号化するためにTLS証明書を提供することをお勧めします。\nもし、どこからでもノードに接続するつもりであれば、Torを使うのがよいでしょう。この場合、TLS証明書は必要ありません。",
      title: "clearnet TCP、TLS、Torのどれを使うべきですか？"
    },
    instructions: {
      link: {
        text: "ノード接続の手引き"
      },
      text: "詳しいチュートリアルは、こちらのガイドをご覧ください：",
      title: "BitBoxAppを自分のフルノードに接続するにはどうすればよいですか？"
    },
    options: {
      text: "自分のノードを動かすには、完成品を買う、自作する、Bitcoin Coreを動かすなど、複数の選択肢があります。\nBitBoxAppをノードに接続したい場合は、Electrumサーバーが動作していることを確認します。これは、ウォレットアプリがあなたのフルノードと通信するための専用プログラムです。\nサポートされているオプションには、Electrs、Electrum Personal Server (EPS)、Bitcoin Wallet Tracker (BTW)があります。",
      title: "ノードを動かすには、どのようなオプションがあるのでしょうか？"
    },
    tor: {
      text: "Torは「The Onion Router」の略で、フリーでオープンソースのソフトウェアで、多くのプライバシー上の利点を提供し、特にビットコインを使用する際に便利です。\nTor経由でノードに接続する場合は、Torがコンピュータにインストールされていることを確認し、BitBoxAppの設定でTor Proxyを有効にします。\nほとんどのOSで、Torを実行する方法は2つあります：\n1. Tor Browser: Tor Browser をダウンロードし、開いてください。これにより、Torプロキシ設定でポート9150を設定することで、BitBoxAppがTorネットワークに接続することができます。\n2. Tor background service：Torデーモンをインストールし、常にバックグラウンドで実行します。これにより、BitBoxAppはTorプロキシ設定にポート9050を設定することで接続できるようになります。",
      title: "Tor、Torプロキシとはどのようなもので、どのポートを使用すればいいのでしょうか？\n"
    },
    what: {
      text: "Shiftのサーバーを使う代わりに、自分のノードを使用してウォレットを運用することができます。",
      title: "ここで何ができますか？"
    },
    why: {
      text: "自分のノードを実行することは必須ではありませんが、プライバシーを向上させ、他人を信頼する必要性を減らすことができます。\nまず、BitBoxAppが私たちのサーバーに接続して取引履歴を取得するのではなく、自分のノードから情報を取得するため、より個人的にビットコインを使用することを意味します。\n第二に、自分のノードを動かすということは、自分のノードがすべてのトランザクションを自分で検証し、コンセンサスルールが実施されていることを確認することを意味します。",
      title: "なぜ自分でノードを動かす必要があるのか？"
    }
  },
  settings: {
    sats: {
      text: "Satoshi（略して「sat」）とは、ビットコインの最小単位である。1 Satoshiはbitcoinの1億分の1（0.00000001BTC）です。bitcoinの生みの親であるサトシ・ナカモトにちなんで名づけられました。",
      title: "Satoshiとはなんですか？"
    },
    servers: {
      text: "このアプリは情報更新、取引履歴の読み込み、ペアされたモバイルアプリへの情報送信のためShift Cryptoのサーバーと繋がっています。また、CoinGeckoより最新の換算レートを取得しています(換算はローカル環境で行われます、あなたの金額等の情報は一切発信されません)。",
      title: "このアプリはどのサーバーと接続していますか？"
    }
  },
  title: "ガイド",
  toggle: {
    close: "ガイドを終了します",
    open: "ガイド"
  },
  trackingModePortfolioChart: {
    text: "デスクトップでは、カーソルをチャート上に重ねてください。モバイルでは、指をチャート上に長押しし、横方向にドラッグしてください。",
    title: "チャートで過去の値を見るには？"
  },
  unlock: {
    forgotDevicePassword: {
      text: "デバイスのリセットを行い、リカバリーパスワードを使用してバックアップからウォレットを復元する必要があります。",
      title: "デバイスパスワードを忘れてしまった場合どうすればいいですか？"
    },
    reset: {
      text: "15回続けて間違ったパスワードを入力してください。最後の何度かはデバイスを長押しするよう求められます。",
      title: "どのようにデバイスをリセットできますか？"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "デバイスは挿入時に一度点滅するはずです。正しい向きで挿入されていることを確認してください。問題がある場合は、以下のリンクからお問い合わせください。\n\nBitBox01はモバイルではサポートされていません。BitBox01を接続するには、デスクトップのBitBoxAppを使用してください",
      title: "私のBitBox01は認識されません"
    },
    getDevice: {
      link: {
        text: "BitBoxを注文"
      },
      text: "BitBoxは弊社オンラインショップよりご購入いただけます：",
      title: "どのようにデバイスを入手できますか？"
    },
    internet: {
      text: "はい、ウォレットの同期、取引の送信、最新の換算レートの取得等を行うためにインターネット接続が必要になります。",
      title: "アプリを使用するのにインターネット接続は必要ですか？"
    },
    lostDevice: {
      link: {
        text: "バックアップセンター"
      },
      text: "バックアップセンターを使用することで、新しいBitBoxにあなたのアカウントを復元することができます。",
      title: "デバイスを紛失してしまったのですが？"
    },
    useWithoutDevice: {
      text: "残念ながら現段階では使用できません。",
      title: "アプリをデバイスなしでも使用することができますか？"
    },
    welcome: {
      text: "スイスのShift Cryptoにより開発されたこのアプリをご使用いただきありがとうございます。現在はまだベータ版となっているため、使い勝手においての不明点・お気付きの点などのご連絡をいただけると幸いです。",
      title: "BitBoxAppにようこそ！"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "BitBoxAppを新しい電話/コンピューターで使用している場合、DAppsに再接続する必要があります。その後、通常通りにDApp上でコインが表示されるでしょう。",
      title: "以前の接続が見えません。"
    },
    supportedNetworks: {
      text: "現在、BitBoxAppでWalletConnectを使用してサポートされているのはEthereumメインネットのみです。他のEVM互換チェーンを使用するには、Rabbyブラウザ拡張ウォレットをご利用ください。",
      title: "どのネットワークがサポートされていますか？"
    },
    whatIsWalletConnect: {
      text: "WalletConnectは、web3アプリケーションのための通信プロトコルです。これにより、第三者のアプリを使用せずに、EthereumベースのDAppsやウェブウォレットに便利に接続することができます。これは、BitBoxAppのAndroidユーザーに特に便利です。",
      title: "WalletConnectとは何ですか？"
    }
  }
};
const headerssync$d = {
  blocksSynced: "{{blocks}}のブロックを同期済み"
};
const hiddenWallet$d = {
  info1HTML: "妥当性のある否認権(plausible deniability)目的のため、普段お使いのウォレットとは<strong>違った</strong>デバイスパスワード・リカバリーパスワードで隠しウォレットを作ることができます。",
  info2HTML: "隠しウォレットに紐づけるデバイスパスワードとリカバリーパスワードを決めてください。これら2つのパスワードは、通常のウォレットとは<strong>違う</strong>パスワードでなければいけません。",
  passwordLabel: "隠しリカバリーパスワード",
  passwordPlaceholder: "隠しリカバリーパスワードの確認",
  pinLabel: "隠しデバイスパスワード",
  pinRepeatLabel: "隠しデバイスパスワードの確認",
  pinRepeatPlaceholder: "隠しデバイスパスワードの確認",
  success: "隠しウォレットの作成に成功しました。アンロックするにはデバイスを一度抜いて、再度挿入してください。"
};
const initialize$d = {
  create: "デバイスパスワードを設定",
  creating: "デバイスパスワードを設定中…",
  error: {
    e102: "デバイスパスワードは4文字以上(半角)でなければいけません。"
  },
  info: {
    description1: "デバイスパスワードを決めてください。これはあなたのBitBoxのアンロックに使用されます。",
    description2: "半角の数字、文字、及び記号を使用できます。",
    description3: "デバイスパスワードを紛失した場合は、デバイスをリセットしてからウォレットをバックアップから復元する必要があります。",
    subtitle: "これからあなたのデバイスパスワードを設定します",
    title: "デバイスの初期化"
  },
  input: {
    label: "デバイスパスワード",
    labelRepeat: "デバイスパスワードの確認",
    placeholderRepeat: "デバイスパスワードの確認"
  }
};
const invalidFormat$d = "無効な形式です";
const language$e = {
  title: "言語を選択してください"
};
const legacyhiddenwallet$d = {
  disable: " legacy秘密ウォレットの無効化",
  enable: " legacy秘密ウォレットの有効化",
  successDisable: " legacy秘密ウォレットの無効化に成功しました。",
  successEnable: " legacy秘密ウォレットの有効化に成功しました。BitBoxを挿し直し、秘密デバイスパスワードを入力してレガシー秘密ウォレットにアクセスしてください。"
};
const loading$d = "ロード中…";
const manageAccounts$7 = {
  accountHidden: "このアカウントは、閲覧専用アカウントから非表示にされています。再度表示するには、BitBox02を接続してください。",
  editAccount: "編集",
  editAccountNameTitle: "アカウント名を編集する",
  noAccounts: "アカウントが見つかりません",
  settings: {
    hideTokens: "トークンを隠す",
    showTokens: "トークンを表示する ({{activeTokenCount}})"
  },
  settingsButtonDescription: "アカウントの追加と表示/非表示",
  title: "アカウント管理",
  watchAccount: "閲覧アカウント",
  watchAccountDescription: "このアカウントは閲覧専用アカウントの一部です。トグルを使用して、閲覧専用から非表示にすることができます。"
};
const mobile$8 = {
  usingMobileDataWarning: "モバイルデータ使用：このアプリは、アカウントロック解除後に最大数百メガバイトのブロックチェーンヘッダーデータをダウンロードする場合があります。モバイルデータの使用を避けるため、Wi-Fiに接続してください。このメッセージは、一度閉じると再び表示されません。"
};
const newSettings$6 = {
  about: {
    appVersion: {
      title: "アプリバージョン"
    }
  },
  advancedSettings: {
    authentication: {
      description: "アプリへのアクセスを画面ロックや指紋認証でロックします。",
      title: "スクリーンロック"
    },
    coinControl: {
      description: "プライバシーを向上させるために、トランザクションに含まれるUTXO（未使用取引出力）を選択してください。"
    },
    customFees: {
      description: "送信時に独自の手数料を入力することができます。"
    },
    torProxy: {
      description: "プライバシーを向上させるために、Tor経由で接続してください。"
    }
  },
  appearance: {
    activeCurrencies: {
      description: "これらの追加通貨は、アカウントページで切り替えることができます。",
      title: "活発な通貨"
    },
    darkmode: {
      description: "ダークモードでのBitBoxAppをご覧ください。"
    },
    defaultCurrency: {
      description: "デフォルトの通貨を選択してください。",
      title: "デフォルトの通貨"
    },
    enableAccount: {
      description: "アカウントを無効にすると、サイドバーやポートフォリオに表示されなくなります。ここからいつでも有効に戻すことができます。このアカウントのコインは影響を受けず、安全なままです。",
      title: "アカウントの有効化/無効化"
    },
    hideAmounts: {
      description: "公共の場でアプリを使用する際にプライバシーを向上させるために、残高や金額を非表示にするトグルを表示します。",
      hideAmounts: "金額を隠す",
      showAmounts: "金額を表示する",
      title: "金額の非表示を許可する"
    },
    language: {
      description: "BitBoxAppで使用する言語を選択してください。",
      title: "言語"
    },
    remebmerWallet: {
      name: "ウォレットを記憶する",
      warning: "これで記憶していたウォレットが削除されます。再び表示するには、このウォレットの ためにBitBox02 を接続する必要があります。このウォレット内のコインは影響を受けません。続行しますか？\n",
      warningTitle: "ウォレットを記憶しない"
    },
    toggleSats: {
      description: " Satoshi単位を有効または無効にします。"
    }
  }
};
const note$9 = {
  input: {
    description: "(任意)",
    placeholder: "メモを追加する..."
  },
  title: "メモ"
};
const notification$d = {
  newTxs_one: "{{accountName}}にて{{count}}個の新しいトランザクション",
  newTxs_other: "{{accountName}}に{{count}}件の新しい取引があります"
};
const pairing$d = {
  aborted: {
    text: "ペアリングはモバイルアプリから取り消されました。",
    title: "中止しました"
  },
  button: "モバイルアプリをペアリングする",
  confirm: "本当にBitBoxのペアリングを行いますか？この場合、トランザクションを行うには携帯電話が必要になります。",
  connectOnly: {
    button: "モバイルアプリに接続する",
    title: "モバイルアプリから「Connect to new desktop app」を選択してスキャンを行なってください。"
  },
  error: {
    text: "問題が起きました。もう一度やり直してください。",
    title: "エラー"
  },
  pullFailed: {
    text: "リレーサーバーを介してモバイルからメッセージを取得できませんでした。リレーサーバーがオフラインの可能性がありますので、サポートにお問い合わせください。",
    title: "取得に失敗しました"
  },
  reconnectOnly: {
    button: "モバイルアプリに再接続"
  },
  scanningFailed: {
    text: "モバイルでは、メッセージを正常にスキャンできませんでした。もう一度お試しください。",
    title: "スキャンに失敗しました"
  },
  start: {
    hideAppQRCode: "QRコードを隠す",
    revealAppQRCode: "QRコードを表示",
    step1: "もしモバイルアプリをお持ちでない場合、お使いの携帯電話に応じてApple App StoreまたはGoogle Play StoreのQRコードをスキャンすることができます。",
    step2: "モバイルアプリ（「Digital Bitbox 2FA」の名前でiOS・Android用アプリを検索できます）からQRコードをスキャンしてください。"
  },
  started: {
    text: "モバイルアプリに表示されている手順に従ってください。",
    title: "いい調子です"
  },
  success: {
    text: "おめでとうございます、あなたのBitBoxは問題なくモバイルアプリとペアリングされました。",
    title: "成功"
  },
  timeout: {
    text: "ペアリング作業は2分経過した時点でタイムアウトしました。ペアリングを行いたい場合はもう一度最初からやり直してください。",
    title: "タイムアウト"
  },
  title: "モバイルペアリング"
};
const passphrase$7 = {
  considerations: {
    button: "バックアップについて",
    message: "パスフレーズは、あなたのウォレットのバックアップ（マイクロSDカードまたはリカバリーワード）に保護の層を追加します。誰かがあなたのバックアップにアクセスできる場合、あなたのウォレットにアクセスするためにもパスフレーズが必要になります。\n\nしかし、これはあなたがBitBox02を失ったり壊したりした場合、パスフレーズを有効にしたウォレットを復元するためには<strong>パスフレーズ + ウォレットのバックアップ</strong>の両方が必要になることを意味します。パスフレーズを忘れたり失ったりすると、そのウォレットの全てのコインにアクセスできなくなります。\n\nパスフレーズを保存する際には、バックアップとは別の場所に置くことを検討してください。そのようにすると、誰かがあなたのバックアップを見つけてもパスフレーズは見つけられないでしょう。",
    title: "バックアップについて"
  },
  disable: "パスフレーズを無効にする",
  disableInfo: {
    button: "無効にする",
    message: "パスフレーズを無効にした後、BitBox02のロックを解除した後でパスフレーズを入力するよう求められることはもうありません。したがって、デフォルトのウォレットを入力することになります。\n\nパスフレーズウォレット上のコインはそのまま残りますが、BitBox02のロックを解除した後はデフォルトのウォレットが開くため、アクセスできなくなります。\n\n再度パスフレーズウォレットにアクセスするには、単にパスフレーズ機能を再有効にし、BitBox02のロックを解除した後に関連するパスフレーズを入力します。\n\n<strong>ヒント:</strong>パスフレーズを空白にすることで、元のウォレットに依然として入ることができます。"
  },
  enable: "パスフレーズを有効にする",
  error: {
    e104: "パスフレーズ設定の変更が中止された。"
  },
  how: {
    button: "どのようなものか",
    message: "パスフレーズは、あなたが普段使っているパスワードとは異なります。パスフレーズを間違って入力しても、通知はされません。これは、<strong>すべてのパスフレーズが異なる、しかしそれでも有効なウォレットを作成する</strong>からです。これは、あなたが望むだけの多くのウォレットに対して複数のパスフレーズを使用できることを意味します。しかし、各ウォレットは対応するパスフレーズを入力したときにのみアクセスできます。\n\nBitBox02を接続すると、通常どおりデバイスのパスワードが求められます。その後、デバイス上でパスフレーズを入力するよう求められます。\n\nパスフレーズを入力した後、入力したパスフレーズが表示されます。これは、あなたが正しく入力したことを確認するためです。",
    title: "どのような仕組みになっているのか"
  },
  intro: {
    message: "パスフレーズは、ウォレットのセキュリティを一層強化するためのものです。\nそれがどのように機能するかを学んでみましょう。\n\n",
    title: "パスフレーズの設定"
  },
  progressDisable: {
    message: "オプションのパスフレーズを<strong>disable</strong>にすることをBitBoxで確認します。",
    title: "デバイスで確認する"
  },
  progressEnable: {
    message: "オプションのパスフレーズを<strong>enable</strong>にすることをBitBoxで確認します。",
    title: "デバイスで確認する"
  },
  successDisabled: {
    message: "オプションのパスフレーズ <strong>successfully enabled</strong>！\n今後、パスフレーズの入力が求められます。",
    messageEnd: "今すぐBitBox02を再接続してください。",
    title: "パスフレーズを有効にする"
  },
  successEnabled: {
    message: "オプションのパスフレーズは<strong>正常に無効化されました</strong>！\n\nパスフレーズの入力を求められることはなくなりました。",
    messageEnd: "今すぐあなたのBitBox02を再接続してください。",
    tips: "ヒント",
    tipsList: [
      "まず少額をパスフレーズウォレットに送金することをおすすめします。その後、BitBox02を抜き差しし、パスワードとパスフレーズを入力します。パスフレーズを正しく入力した場合、ウォレットにコインが表示されます。",
      "パスフレーズなしで元のウォレットに入りたい場合、パスフレーズの入力を求められたときに何も入力しないことでパスフレーズを入力することができます。また、パスフレーズ機能を無効にすることもできます。"
    ],
    title: "パスフレーズ無効"
  },
  summary: {
    button: "パスフレーズ有効",
    title: "要約",
    understand: "パスフレーズの仕組みやリスクについて理解している。",
    understandList: [
      "パスフレーズは、バックアップの上に追加されるセキュリティの層です。",
      "異なるパスフレーズを入力すると、必ず異なるウォレットが生成されます。",
      "ウォレットを復元するには、<strong>パスフレーズとバックアップの両方が必要です</strong>。",
      "パスフレーズを忘れた場合、<strong>コインにアクセスできなくなります</strong>。"
    ]
  },
  what: {
    button: "この仕組みについてはこちら",
    message: "ウォレットは非常に大きなランダムな数値（シードとも呼ばれる）から作成（派生）されます。このシードはBitBox02を初めて設定したときに作成され、マイクロSDカードまたはリカバリーワードでバックアップされます。シードにアクセスできる人は、そのウォレットの資金を完全にコントロールすることができます。\n\nパスフレーズは、シードに追加される<strong>オプションの秘密</strong>です。パスフレーズを使用すると、各パスフレーズはシード + パスフレーズ（オプションの秘密）に基づいた新しいウォレットを作成します。パスフレーズは何でもよいです：文字、単語、特殊文字、または空でも可能です。デフォルトのウォレットは実際にはシード + 空のパスフレーズから派生します。\n\nパスフレーズはBIP39標準の一部であり、これは同じ標準をサポートするすべてのウォレットと互換性があることを意味します。",
    title: "パスフレーズとは何ですか？"
  },
  why: {
    button: "パスフレーズを使用する理由",
    message: "BitBox02は、デバイス自体からのシードの抽出を防ぎますが、バックアップ（マイクロSDカードまたはリカバリーワード）はウォレットへの完全なアクセスを提供します。そのため、それは安全な場所に保存するべきです！\n\nパスフレーズが既存のシードを使用して新しいウォレットを作成するため、パスフレーズウォレットの復元には<strong>バックアップとパスフレーズの両方が必要</strong>です。これの利点は、誰かがあなたのバックアップを見つけても、パスフレーズウォレットにアクセスするためにはパスフレーズが必要であるということです。\n\nさらに、パスフレーズ機能を使用すると、同じデバイス上に複数のウォレットを作成したり、デフォルトのものに加えて「隠されたウォレット」を作成したりすることができます。",
    title: "なぜパスフレーズを使うのですか？"
  }
};
const password$d = {
  show: "{{label}}を表示",
  warning: {
    caps: "注意：caps lock(⇪)が有効になっています",
    paste: "貼り付けを行うには「{{label}}を表示」を有効にしてください"
  }
};
const random$e = {
  button: "乱数を生成する",
  description: "あなたのBitBoxは次の{{bits}}bit乱数を生成しました："
};
const receive$f = {
  bitsuranceWarning: "これは保険のかかったアカウントであり、Native Segwitへの入金のみが許可されています。これはWrapped SegwitやTaprootへ誤って入金しないようにするための措置です。これらは保険の対象外です。",
  changeScriptType: "アドレスの種類を変更する",
  label: "あなたのアドレス",
  onlyThisCoin: {
    description: "他のトークンを受け取るには、設定で有効にしてください。他のトークンを預けると、アクセスできなくなる場合があります。",
    warning: "このアドレスで{{coinName}}だけを受信するようにしてください。"
  },
  scriptType: {
    p2tr: "Taproot (最新版)",
    p2wpkh: "Native Segwit (デフォルト)",
    "p2wpkh-p2sh": "Wrapped Segwit（互換フォーマット）"
  },
  selectAccount: "アカウント選択",
  showFull: "フルアドレスをデバイス上で表示・確認",
  taprootWarning: "注意：Taprootは新しいビットコインの機能であり、まだ広く採用されていません。Taprootアドレスで受け取った資金は、サードパーティのwatch-only ウォレットでは表示されない場合があります。多くのウォレットと取引所はまだTaprootアドレスに送金することができません。",
  title: "受け取る{{accountName}}",
  verify: "安全にアドレスを検証する",
  verifyBitBox01: "モバイルアプリでアドレスを確認する",
  verifyBitBox02: "BitBox02のアドレスを確認する",
  verifyInstruction: "下記アドレスがデバイス画面に表示されているものと一致することを確認してください。",
  warning: {
    secureOutput: "あなたのBitBoxをあなたのモバイルデバイスとペアリングして、安全なアドレス検証を有効にしてください。サイドバーの「デバイスの管理」に移動してください。\n\n\n\n"
  }
};
const reset$d = {
  description: "このデバイスからすべてのデータが削除されます。それには、あなたのプライベートキーも含まれます！",
  notReset: "デバイスはリセットされませんでした。",
  title: "デバイスを工場出荷状態にリセット",
  understand: "私はバックアップがあり、リカバリーパスワードも覚えています",
  understandBB02: "有効なバックアップがあります"
};
const securityInformation$d = {
  create: {
    description1: "私たちは、他の人があなたが選んだパスワードを見ることができる環境から離れた、安全な環境でデバイスを設定することをお勧めします。",
    description2: "これから2つのパスワードを設定します。",
    description3: "1つ目は<strong>デバイスパスワード</strong>です。あなたのBitBoxをアンロックをするのに必要で、後から変更することができます。",
    description4: "2つ目は<strong>リカバリーパスワード</strong>です。これはウォレットのアンロックに使用され、後から変更できません。",
    description5: "作成したウォレットは、提供されたマイクロSDカード上のファイルにバックアップされます。これは緊急時にあなたの<strong>リカバリーパスワード</strong>を使用して資金を回復するために使用することができます。",
    title: "セキュリティ情報"
  },
  restore: {
    description1: "バックアップを保存するために使用したmicroSDカードを挿入するよう求められます。",
    description2: "復元を行うにはリカバリーパスワードが必要です。",
    description3: "リカバリーパスワードを入力する際はご注意ください。間違ったパスワードを入力した場合でも妥当なウォレットは作成されます。パスワードが間違っていた場合は予期せぬウォレット残高が表示される場合があります。",
    title: "セキュリティ情報"
  }
};
const seed$d = {
  agreements: {
    "funds-access": "リカバリーパスワードを忘れてしまった場合は資金へアクセスできません",
    "password-change": "リカバリーパスワードを後から変更することができません",
    "password-required": "ウォレットをバックアップから復元したい場合はリカバリーパスワードが必要になります"
  },
  create: "ウォレットを作成する",
  creating: "ウォレットの作成中",
  description: "次の項目を確認しました：",
  error: {
    e102: "パスワードは最低4文字(半角)必要です。",
    e200: "ウォレットを作成するためには、BitBoxにmicroSDカードを挿入する必要があるため、自動的にバックアップを作成することが可能です。"
  },
  info: {
    button: "今すぐリカバリーパスワードを設定する",
    description1: "BitBoxにmicroSDカードを挿入してください",
    description2: "ウォレットのリカバリーパスワードを決めて「リカバリーパスワードを設定する」を選択してください",
    description3: "マイクロSDカードへのバックアップとあなたのリカバリーパスワードは、BitBoxデバイスが紛失または盗難の場合に資金を回復する唯一の方法です。",
    description4: "資金を移す以外の方法で、後からリカバリーパスワードの変更を行うことはできません。",
    title: "新しいウォレットの作成"
  },
  password: {
    label: "リカバリーパスワード",
    repeatPlaceholder: "リカバリーパスワードの確認"
  },
  walletName: {
    label: "ウォレット名"
  }
};
const seedRestore$d = {
  error: {
    e200: "バックアップからウォレットを復元するには、マイクロSDカードが必要です。"
  },
  info: {
    description1: "BitBoxにmicroSDカードを挿入し「続ける」をクリックしてください。",
    description2: "バックアップを選択し、「復元」をクリックしてください",
    description3: "リカバリーパスワード",
    description4: "間違ったパスワードは別のウォレットを作成することを理解するため、あなたの確認が必要です。",
    title: "バックアップからウォレットを復元する方法"
  }
};
const send$f = {
  abort: "取引は中止されました。",
  address: {
    label: "受信者アドレス",
    placeholder: "アドレスを入力してください"
  },
  amount: {
    label: "金額",
    placeholder: "金額を入力してください"
  },
  availableBalance: "利用可能な残高",
  button: "レビュー",
  coincontrol: {
    address: "アドレス",
    outpoint: "アウトポイント",
    title: "アウトプットから送信します。"
  },
  confirm: {
    "selected-coins": "選択されたコイン",
    title: "トランザクションの確認と送信",
    total: "総額"
  },
  error: {
    erc20InsufficientGasFunds: "このERC20トランザクションの手数料を支払うために十分なイーサがないようです。ウォレットに十分なイーサが保有されているか確認してください。",
    feeTooLow: "手数料が低すぎます。",
    feesNotAvailable: "手数料を見積もることができませんでした。",
    insufficientFunds: "資金が不十分です",
    invalidAddress: "無効なアドレス",
    invalidAmount: "無効な金額",
    invalidData: "無効なデータ"
  },
  fee: {
    customPlaceholder: "金額を入力してください",
    label: "ネットワーク手数料",
    placeholder: "情報がありません"
  },
  feeTarget: {
    customLabel: "手数料率",
    customLabel_eth: "ガス料金",
    description: {
      economy: "4時間（24ブロック）",
      economy_eth: "30分以内",
      economy_ltc: "1時間（24ブロック）",
      high: "20分（2ブロック）",
      high_eth: "30秒以内",
      high_ltc: "5分（2ブロック）",
      low: "2時間（12ブロック）",
      low_eth: "5分以内",
      low_ltc: "30分（12ブロック）",
      normal: "1時間（6ブロック）",
      normal_eth: "2分以内",
      normal_ltc: "15分（6ブロック）"
    },
    estimate: "推定確認時間：",
    label: {
      custom: "カスタム",
      economy: "エコノミー",
      high: "高い",
      low: "低い",
      normal: "ノーマル"
    },
    placeholder: "手数料を計算しています..."
  },
  maximum: "全て送信",
  maximumSelectedCoins: "選択したコインを送信します。",
  noFeeTargets: "現在、手数料率の見積もりは利用できません。後でもう一度試すか、カスタム手数料を入力してください",
  priority: "優先",
  scanQR: "QRコードをスキャン",
  signprogress: {
    description: "この取引はたくさんのデータを含みます。取引を完全にサインするには、{{steps}}回確認することを求められます。",
    label: "進行度"
  },
  success: "取引は署名され送信されました。",
  title: "{{accountName}}送信する。",
  toggleCoinControl: "コインコントロールの切り替え",
  transactionDetails: "トランザクションの詳細"
};
const settings$e = {
  about: "について",
  accounts: "アカウント",
  advancedSettings: "詳細設定",
  appearance: "外観",
  electrum: {
    add: "サーバーを追加",
    "add-server": "追加",
    check: "チェック",
    checkFailed: "失敗しました",
    checkSuccess: "{{host}}への接続に成功しました",
    checking: "チェック中",
    "download-cert": "リモート証明書をダウンロード",
    "remove-server": "削除",
    removeConfirm: "{{server}} を削除しますか？",
    reset: "デフォルト値に戻す",
    resetConfirm: "全てのサーバーを削除して、デフォルトのサーバーをインストールしますか？",
    servers: "サーバー一覧",
    step1: "1",
    "step1-text": "エンドポイントを入力してください。",
    step2: "2",
    "step2-text": "サーバーの証明書チェーンの証明書を入力してください。または、リモート証明書をダウンロードして比較することも可能です。",
    "step2-text-tcp": "もしTLSを使用したくない場合は、このステップをスキップしてください。",
    step3: "3",
    "step3-text": "接続の確認を行なってサーバーを追加しましょう。",
    step4: "4",
    "step4-text": "ウォレットを再起動してください。デフォルトのサーバーを削除したくない場合、あなたのノードは重複物としてついかされます。",
    "title-btc": "Bitcoin Electrumサーバー",
    "title-ltc": "Litecoin Electrumサーバー",
    "title-tbtc": "Bitcoin Testnet Electrumサーバー",
    "title-tltc": "Litecoin Testnet Electrumサーバー"
  },
  expert: {
    coinControl: "コインコントロールを有効にする",
    electrum: {
      description: "独自のElectrumフルノードに接続することができます。",
      title: "自分のノードに接続"
    },
    fee: "カスタム手数料を有効にします。",
    setProxyAddress: "プロキシアドレスを設定します。",
    title: "エキスパート設定",
    useProxy: "Torプロキシを有効にします。",
    useSats: "\nBTCの値をSatoshiで表示します。"
  },
  header: {
    home: "ホーム"
  },
  info: {
    "out-of-date": "新しいアップデートが利用可能です。",
    title: "情報",
    "up-to-date": "お使いのアプリは最新版です。",
    version: "アプリのバージョン"
  },
  restart: "変更が反映されるためには、BitBoxAppを再起動してください。",
  services: {
    title: "サービス"
  },
  success: "変更を適用するにはBitBoxを一度引き抜いてから再度挿入してください。",
  title: "設定"
};
const setup$d = "デバイスを設定";
const sidebar$e = {
  buy: "仮想通貨を購入する",
  device: "デバイス管理",
  insurance: "ほけん",
  leave: "離れる",
  settings: "設定"
};
const success$k = {
  create: {
    info1: "ウォレットは安全にmicroSDカードにバックアップされました。カードを取り外して安全な場所に保管してください。",
    info2: "Bitboxのアンロックに使われる安全なデバイスパスワードを作成しました。",
    info3: "あなたのウォレットの資産とバックアップをアンロックする安全なリカバリーパスワードを作成しました。",
    summary: "これまでのサマリーです",
    title: "成功"
  },
  getstarted: "始めましょう",
  restore: {
    summary: "バックアップからのウォレットの復元に成功しました。",
    title: "成功"
  }
};
const transaction$e = {
  confirmation: "認証済み",
  details: {
    activity: "アクティビティ",
    address: "アドレス",
    amount: "金額",
    date: "日付",
    fiat: "フィアット",
    fiatAmount: "フィアットの金額",
    fiatAtTime: "取引時のフィアットの価格",
    status: "ステータス",
    title: "取引の詳細",
    type: "タイプ"
  },
  explorer: "取引ID",
  explorerTitle: "外部のブロックエクスプローラで開く",
  fee: "手数料",
  fiatHistorical: "Historical",
  gas: "Gas",
  note: {
    edit: "ノートを編集する",
    save: "ノートを保存する"
  },
  pending: "保留中のトランザクション",
  size: "サイズ",
  status: {
    complete: "完了",
    failed: "失敗しました",
    pending: "保留中"
  },
  tx: {
    received: "受信先",
    sent: "送信先\n"
  },
  vsize: "バーチャルサイズ",
  weight: "重量"
};
const transactions$d = {
  errorLoadTransactions: "トランザクションの読み込み中にエラーが発生しました。",
  placeholder: "表示できる取引がありません。"
};
const unknownError$d = "不明なエラーが起きました：{{errorMessage}}";
const unlock$d = {
  description: "デバイスパスワードを入力してアンロックしてください。",
  error: {
    e109_normal: "デバイスパスワードが間違っています。デバイスがリセットされるまで後{{remainingAttempts}}回入力できます。",
    e109_touch: "$t(unlock.error.e109_normal) 次のログインではデバイスの長押しが必要です。",
    e113: "ログインを試みた回数が多いため、次のログインではデバイスを4秒以上長いしする必要があります。"
  },
  input: {
    label: "デバイスパスワード",
    placeholder: "デバイスをアンロックするにはデバイスパスワードを入力してください。"
  },
  unlocking: "アンロック中…"
};
const upgradeFirmware$e = {
  button: "ファームウェアをアップグレード",
  description: "{{currentVersion}}から{{newVersion}}へのファームウェアのアップグレードを行いますか？",
  label: "BitBoxのファームウェアアップグレードが必要です。",
  locked: "{{currentVersion}}から{{newVersion}}にアップグレードするには、デバイスを長押ししてください。",
  title: "ファームウェアをアップグレード",
  unlocked: "ブートローダーはアンロックされています。続けるには：",
  unlocked1: "BitBoxを引き抜き、再度差し込んでください",
  unlocked2: "BitBoxを再度挿入した際にLEDが点灯します",
  unlocked3: "LEDが点灯したらデバイスをタップしてください"
};
const walletConnect$8 = {
  connect: {
    button: "接続する",
    dappLabel: "dappのURIアドレスを入力してください。",
    invalidPairingUri: "無効なペアリングURIです"
  },
  dashboard: {
    allSessions: "全セッション",
    disclaimer: "Walletconnectは、EthereumベースのDappsに接続するためのプロトコルです。これらのdappsはサードパーティのサービスによって運営されているため、信頼できるdappsにのみ接続し、トランザクションを行う際には常に署名している内容を把握しておくことが重要です。",
    newConnection: "新しい接続",
    noConnectedSessions: "現在、どのアカウントもdappsに接続されていません。"
  },
  invalidPairingChain: "ペアリングの承認にエラーが発生しました。サポートされているチェーンの一つを使用していることを確認してください：{{chains}}",
  pairingRequest: {
    approve: "接続を承認する",
    reject: "拒否する",
    title: "からの新規接続リクエスト"
  },
  pairingSuccess: "Dappが正常に接続されました。dappのウェブサイトで続行できます。",
  signingRequest: {
    account: "アカウント",
    chain: "チェーン",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "データの解析に失敗しました",
    decodeError: "メッセージのデコードに失敗しました。",
    method: {
      sendTransaction: "トランザクションに署名して送信する",
      signMessage: "メッセージに署名する",
      signTransaction: "トランザクションに署名する",
      signTypedData: "タイプされたデータに署名する"
    },
    successfullySigned: "リクエストが正常に署名されました。",
    walletConnectRequest: "WalletConnectリクエスト"
  },
  useNewUri: "このURIはすでに接続を試みるために使用されています。新しいURIを使用してください。",
  walletConnect: "WalletConnect"
};
const warning$j = {
  receivePairing: "安全なアドレス検証を有効にするために、BitBoxをペアリングしてください。サイドバーの「デバイスの管理」に移動してください。",
  sdcard: "バックアップを管理したい場合を除き、BitBoxとマイクロSDカードを別々に保管してください。",
  sendPairing: "トランザクションの詳細を安全に確認するために、BitBoxをペアリングしてください。サイドバーの「デバイスの管理」に移動してください。"
};
const welcome$d = {
  connect: "BitBox02を接続する",
  getStarted: "BitBox02にファームウェアをインストールして始めましょう。",
  insertBitBox02: "BitBox02の場合は、続行するためにデバイスをタップしてください。",
  insertDevice: "開始するにはデバイスを差し込んでください",
  title: "ようこそ"
};
const appTranslationsJA = {
  account: account$d,
  accountInfo: accountInfo$d,
  accountSummary: accountSummary$d,
  addAccount: addAccount$e,
  aopp: aopp$7,
  app: app$d,
  auth: auth$7,
  backup: backup$d,
  bb02Bootloader: bb02Bootloader$d,
  bitbox: bitbox$d,
  bitbox02Interact: bitbox02Interact$d,
  bitbox02Settings: bitbox02Settings$d,
  bitbox02Wizard: bitbox02Wizard$d,
  bitsurance: bitsurance$6,
  bitsuranceAccount: bitsuranceAccount$6,
  blink: blink$d,
  bootloader: bootloader$d,
  button: button$i,
  buy: buy$9,
  changePin: changePin$d,
  chart: chart$9,
  checkSDcard: checkSDcard$d,
  clickHere: clickHere$d,
  confirm: confirm$f,
  confirmOnDevice: confirmOnDevice$d,
  connectKeystore: connectKeystore$7,
  darkmode: darkmode$7,
  device: device$d,
  deviceLock: deviceLock$d,
  deviceSettings: deviceSettings$d,
  deviceTampered: deviceTampered$d,
  dialog: dialog$e,
  error: error$9,
  fiat: fiat$f,
  footer: footer$f,
  generic: generic$9,
  genericError: genericError$d,
  goal: goal$d,
  guide: guide$e,
  headerssync: headerssync$d,
  hiddenWallet: hiddenWallet$d,
  initialize: initialize$d,
  invalidFormat: invalidFormat$d,
  language: language$e,
  legacyhiddenwallet: legacyhiddenwallet$d,
  loading: loading$d,
  manageAccounts: manageAccounts$7,
  mobile: mobile$8,
  newSettings: newSettings$6,
  note: note$9,
  notification: notification$d,
  pairing: pairing$d,
  passphrase: passphrase$7,
  password: password$d,
  random: random$e,
  receive: receive$f,
  reset: reset$d,
  securityInformation: securityInformation$d,
  seed: seed$d,
  seedRestore: seedRestore$d,
  send: send$f,
  settings: settings$e,
  setup: setup$d,
  sidebar: sidebar$e,
  success: success$k,
  transaction: transaction$e,
  transactions: transactions$d,
  unknownError: unknownError$d,
  unlock: unlock$d,
  upgradeFirmware: upgradeFirmware$e,
  walletConnect: walletConnect$8,
  warning: warning$j,
  welcome: welcome$d
};
const account$c = {
  disconnect: "Потеряна связь. Восстановление связи ... ",
  "export": "Экспортировать",
  exportTransactions: "Экспортировать транзакций в папку «загрузки» в виде файла CSV",
  fatalError: "Произошла ошибка.",
  incoming: "Ждите",
  initializing: "Получение информации из блокчейна ...",
  maybeProxyError: "Прокси-сервер включен. Убедитесь, что Ваш прокси-сервер рабочий, иначе отключите использование прокси-сервера в настройках.",
  reconnecting: "Потерянна связь, попытка повторного подключения ...",
  syncedAddressesCount: "Отсканировано {{count}} адресов"
};
const accountInfo$c = {
  address: "Адрес",
  buyCTA: {
    buy: "Покупка {{unit}}",
    buyCrypto: "Купить криптовалюту",
    information: {
      looksEmpty: "Возможно, этот кошелёк пустой",
      start: "Внесите интересующую криптовалюту на кошелёк или купите в приложении BitBoxApp."
    }
  },
  extendedPublicKey: "Расширенный Public Key",
  label: "Информация об учетной записи",
  scriptType: "Тип шифрования",
  title: "Информация об учетной записи",
  verify: "Подтвердите на устройстве",
  xpubTypeChangeBtn: {
    p2pkh: "Обзор legacy P2PKH расширенного открытого ключа",
    p2tr: "Просмотр счета Taproot",
    p2wpkh: "Просмотр счета Native Segwit",
    "p2wpkh-p2sh": "Просмотр Segwit расширенного открытого ключа"
  },
  xpubTypeInfo: "Отображение {{scriptType}} расширенного открытого ключа ({{current}} из {{numberOfXPubs}})"
};
const accountSummary$c = {
  availableBalance: "Доступный баланс",
  balance: "Баланс",
  exportSummary: "Экспортировать сводку учетных записей в папку загрузок в виде файла CSV",
  fiatBalance: "Валютный баланс",
  name: "Название учетной записи",
  noAccount: "Нет аккаунтов для показа.",
  subtotalWithCoinName: "Монета ({{coinName}})",
  title: "Моя учетная запись\n",
  total: "Всего",
  transactionHistory: "Журнал транзакций"
};
const addAccount$d = {
  chooseName: {
    nextButton: "Добавить аккаунт",
    step: "Имя аккаунта",
    title: "Назовите свой аккаунт"
  },
  selectCoin: {
    nextButton: "Далее",
    step: "Выберите монету",
    title: "Выберите криптовалюту"
  },
  success: {
    message: "<strong>{{accountName}}</strong> добавлен в аккаунт",
    nextButton: "Выполнено",
    step: "Завершено",
    title: "Добавлен аккаунт"
  },
  title: "Добавить учётную запись"
};
const aopp$6 = {
  addressRequest: "{{host}} запрашивает адрес получателя",
  addressRequestWithLogo: "запрашивается адрес получателя",
  banner: "Выполняется запрос адреса",
  errorTitle: "Ошибка при запросе адреса",
  labelAddress: "Адрес",
  labelMessage: "Сообщение",
  reverifyInfoText: "Проверка адреса",
  signing: "Чтобы продолжить, подпишите сообщение на BitBox02",
  success: {
    message: "Продолжить на {{host}}",
    title: "Адрес успешно отправлен"
  },
  syncing: "Синхронизация аккаунта, пожалуйста, подождите.",
  title: "Запрос адреса"
};
const app$c = {
  upgrade: "Доступна новая версия этого приложения! Обновите с {{current}} на {{version}}."
};
const backup$c = {
  check: {
    checking: "Проверка резервных копий ...",
    confirmTitle: "Проверить резервную копию",
    notOK: "Резервная копия НЕ соответствует текущему кошельку. ",
    ok: "Резервная копия соответствует текущему кошельку.",
    password: {
      label: "Пароль восстановления",
      placeholder: "Пароль восстановления",
      showLabel: "пароль восстановления"
    },
    success: "Резервная копия успешно подтверждена:",
    title: "Проверить резервную копию"
  },
  create: {
    alreadyExists: "У вас уже существует резервная копия. Вы хотите её переписать?",
    fail: "Создание резервной копии НЕ удалось!",
    info: "Введите пароль восстановления текущего кошелька для проверки.",
    name: {
      label: "Имя резервной копии",
      placeholder: "Укажите имя резервной копии"
    },
    password: {
      label: "Пароль восстановления",
      placeholder: "Введите Ваш пароль восстановления"
    },
    title: "Создать резервную копию",
    verificationFailed: "Пароль восстановления НЕ СООТВЕТСВУЕТ текущему кошельку. Создана новая резервная копия. Используйте «Проверить резервную копию», чтобы подтвердить пароль восстановления."
  },
  description: "Выбрать <strong>файл резервной копии</strong>",
  insert: "Вставьте карту памяти microSD для управления резервными копиями.",
  insertButton: "Я вставил карту памяти microSD",
  list: "Список резервных копий на карте памяти microSD",
  noBackups: "На этой карте microSD нет резервных копий.",
  restore: {
    confirmTitle: "Восстановление резервной копии",
    error: {
      e200: "Карта памяти microSD не обнаружена",
      general: "Невозможно восстановить резервную копию"
    },
    password: {
      label: "Пароль восстановления или скрытый пароль восстановления",
      placeholder: "Пароль восстановления",
      repeatPlaceholder: "Повторите пароль восстановления",
      showLabel: "Пароль восстановления"
    },
    restoring: "Происходит восстановление резервной копии ...",
    selectedBackup: "<strong>{{backupName}}</strong> созданный на {{createdDateTime}}будет восстановлен",
    title: "Восстановить",
    understand: "Я понимаю, что неверный пароль восстановления создаст другой кошелек"
  },
  showMnemonic: {
    description: "Вам будут представлены 24 слова восстановления, которые образуют резервную копию Вашего кошелька. Запишите их на бумаге.\n\n<strong>Не храните их в цифровом виде и не фотографируйте.</strong>\n\n<strong>Не произносите слова вслух.</strong>\n\n<strong>Эта резервная копия не защищена паролем.</strong>\n\nПосле этого вам будет предложено подтвердить каждое слово.",
    title: "Показать слова восстановления кошелька"
  },
  title: "Управление резервными копиями"
};
const bb02Bootloader$c = {
  abort: "Не обновлять - вернуться обратно",
  abort_noUpgrade: "Вернуть назад",
  advanced: {
    label: "Дополнительные настройки",
    toggleShowFirmwareHash: "Показывать хэш прошивки каждый раз при запуске"
  },
  flipscreen: "Перевернуть экран",
  orientation: "Экран ориентирован на другую сторону?",
  success: "Обновление прошло успешно! Перезагрузка через {{rebootSeconds}} секунд ...",
  success_install: "Установка прошла успешно! Перезагрузка через {{rebootSeconds}} секунд..."
};
const bitbox$c = {
  error: {
    e10000: "Неверный пароль устройства.",
    e10001: "Не удалось заменить пароль устройства",
    e102: "Пароль должен содержать не менее 4 символов.",
    e112: "Скрытый пароль устройства не может совпадать с основным паролем устройства."
  }
};
const bitbox02Interact$c = {
  confirmDate: "Подтвердите сегодняшнюю дату на Вашем устройстве BitBox02",
  confirmDateText: "Эта дата будет использована для создания Вашей резервной копии.",
  confirmName: "Подтвердите имя на Вашем устройстве BitBox02",
  followInstructions: "Пожалуйста, следуйте инструкциям на Вашем устройстве BitBox02.",
  followInstructionsMnemonic: "Пожалуйста, следуйте инструкциям на вашем устройстве BitBox02, чтобы восстановить кошелек используя резервную копию слов",
  followInstructionsMnemonicTitle: "Восстановление из резервных слов (мнемонической фразы)"
};
const bitbox02Settings$c = {
  deviceName: {
    current: "Текущее имя устройства",
    input: "Имя устройства BitBox02",
    placeholder: "Новое имя устройства",
    title: "Переименовать устройство BitBox02"
  },
  gotoStartupSettings: {
    description: "Данное действие перезагрузит BitBox02 и вернет начальные настройки запуска",
    title: "Перейти к начальным настройкам"
  }
};
const bitbox02Wizard$c = {
  attestationFailed: "Проверка подлинности устройства не удалась. Это могло быть связано с перезапуском приложения, когда устройство ожидало ввода данных. Пожалуйста, снова переподключите устройство и повторите попытку. Пожалуйста, свяжитесь с support@bitbox.swiss если эта проблема не решилась",
  backup: {
    point1: "Выберите резервную копию на карте microSD",
    point2: "Установите пароль для вашего устройства",
    restoreText: "Хорошо, давайте восстановим резервную копию!",
    text1: "Отлично, ваш пароль BitBox02 теперь установлен и кошелек создан. Теперь пришло время создать вашу первую резервную копию. Убедитесь, что ваша карта microSD вставлена ​​в BitBox02, и продолжайте.",
    text2: "Пожалуйста, следуйте инструкциям на экране вашего устройства, чтобы создать резервную копию.",
    text3: "После создания резервной копии извлеките карту microSD и храните её в <strong>безопасном месте</strong>. Содержимое карты microSD не защищено паролем. Никогда не вставляйте её в любое другое устройство, кроме вашего BitBox02.",
    userConfirmation1: "Я должен хранить резервную копию в надежном месте.",
    userConfirmation2: "Моя резервная копия не защищена паролем. Любой, у кого есть доступ, сможет владеть моим кошельком.",
    userConfirmation3: "Если я потеряю или повредю мой BitBox02, единственный способ восстановить все средства - это резервная копия.",
    userConfirmation4: "Если я потеряю или повредю резервную копию и мой BitBox02, все средства будут утеряны.",
    userConfirmation5: "Я не должен вставлять мою карту памяти microSD на которой находится резервная копия в компьютер, телефон, принтер или любое другое устройство, кроме BitBox02."
  },
  create: {
    button: "Именовать устройство и продолжить",
    info: "Вот основные шаги, которые вы будете предпринимать для настройки вашего BitBox: ",
    inputTitle: "Название кошелька",
    point1: "Назовите Ваше устройство",
    point2: "Установите пароль для Вашего устройства",
    point3: "Создать резервную копию",
    text: "Хорошо, давайте создадим новый кошелек!"
  },
  createBackupFailed: "Не удалось создать резервную копию. Попробуйте еще раз.",
  initialize: {
    passwordText: "Теперь давайте установим пароль для вашего устройства. Используйте элементы управления на вашем BitBox для ввода и выбора пароля.",
    passwordTitle: "Установите пароль для вашего BitBox",
    text: "Ваш BitBox02 был успешно присоединен! Теперь давайте инициализировать ваше устройство. Начните с выбора создания нового кошелька или восстановления кошелька из существующей резервной копии. <strong>Убедитесь, что в ваш BitBox02 вставлена ​​карта памяти microSD</strong>",
    tip: "Прежде чем продолжить, настоятельно рекомендуется продолжить работу в безопасной среде.",
    title: "Инициализируйте ваш BitBox"
  },
  insertSDCard: "<strong>Убедитесь, что в BitBox02 вставлена ​​карта microSD.</strong>",
  noPasswordMatch: "Пароли не совпадают, попробуйте еще раз.",
  pairing: {
    failed: "Неподтвержденное присоединение. Пожалуйста, подключите ваш BitBox02 заново.",
    paired: "Вы подтвердили на своем устройстве, что код соответствует. Если это правильно, вы можете продолжить, нажав кнопку ниже.",
    title: "Проверьте код соединения",
    unpaired: "Новый BitBox02 был обнаружен. Убедитесь, что следующий код соответствует тому, что показан на вашем устройстве. Если код соответствует, нажмите под галочкой на вашем BitBox02 и затем нажмите кнопку ниже, чтобы продолжить."
  },
  restoreFromMnemonic: {
    failed: "Не удалось выполнить восстановление. Попробуйте еще раз."
  },
  stepBackup: {
    beforeProceed: "Прежде чем продолжить, прочтите следующие важные примечания по безопасности:",
    createBackup: "Теперь вы создадите резервную копию на карте microSD."
  },
  stepBackupSuccess: {
    fundsSafe: "Для максимальной безопасности ваших средств, помните следующее:",
    title: "Резервная копия восстановлена!"
  },
  stepConnected: {
    unlock: "Введите пароль BitBox02 для разблокировки."
  },
  stepCreate: {
    description: "Это имя используется в качестве имени устройства и для резервного копирования",
    nameLabel: "Имя BitBox02",
    namePlaceholder: "Мой BitBox02",
    title: "Выберите имя BitBox02",
    toastMicroSD: "Убедитесь, что карта microSD вставлена ​​в BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "Извлеките карту microSD из BitBox02 и храните ее в надежном месте.",
    success: "Вы успешно создали резервную копию"
  },
  stepInsertSD: {
    insertSDCard: "Чтобы продолжить, вставьте карту microSD в BitBox02.",
    insertSDcardTitle: "Вставьте карту microSD"
  },
  stepPassword: {
    title: "Установить пароль BitBox02",
    useControls: "Используйте элементы управления на устройстве BitBox02, чтобы установить пароль."
  },
  stepUninitialized: {
    create: "Я хочу инициализировать новый BitBox02.",
    restore: "Я хочу восстановить мой кошелек из резервной копии.",
    restoreMicroSD: "Восстановить с карты microSD",
    restoreMnemonic: "Восстановить с помошью слов восстановления",
    title: "Инициализируйте Ваш BitBox02"
  },
  success: {
    text: "Ура! Ваш BitBox02 теперь готов к использованию.\n\nДля получения дополнительной информации о том, как использовать приложение BitBoxApp, пожалуйста, используйте руководство в приложении, нажав на знак вопроса в верхнем правом углу.",
    title: "Вы готовы к работе!"
  }
};
const blink$c = {
  button: "Мерцать"
};
const bootloader$c = {
  button: "Обновить прошивку",
  button_install: "Установить прошивку",
  progress: "Обновление: {{progress}}%",
  progress_install: "Установка: {{progress}}%",
  success: "Успешное обновление! Отсоедините и присоедените устройство заново. На этот раз не прикасайтесь к кнопке."
};
const button$h = {
  abort: "Прервать",
  back: "Назад",
  buy: "Купить",
  changepin: "Изменить пароль устройства",
  check: "Проверить резервную копию",
  "continue": "Продолжить",
  copy: "Копировать",
  create: "Создать",
  dismiss: "Отклонить",
  done: "Выполнено",
  download: "Скачать",
  hiddenwallet: "Создать скрытый кошелек",
  next: "Следующее",
  ok: "Хорошо",
  previous: "Предыдущее",
  receive: "Получить",
  restore: "Восстановить",
  select: "Выбрать",
  send: "Перевести",
  unlock: "Разблокировать",
  update: "Обновить",
  upgrade: "Обновить"
};
const buy$8 = {
  info: {
    "continue": "Подтвердить и продолжить",
    crypto: "Криптовалюта",
    disclaimer: {
      intro: [
        "Мы сотрудничаем с MoonPay, чтобы предложить удобный способ покупки {{name}} в приложении BitBoxApp. Всего в несколько кликов",
        "MoonPay - это платформа, позволяющая легко и быстро совершать покупки {{name}} в более чем 160+ странах"
      ],
      payment: {
        details: "Вы можете мгновенно купить {{name}} через MoonPay различными способами оплаты. Переводы по кредитной или дебетовой карте выполняются мгновенно и это удобно, но стоят дороже из-за повышенного риска возврата средств. Для более крупных сумм, мы рекомендуем использовать вариант банковского перевода. Минимальная плата составляет 4 USD/EUR или эквивалент",
        footnote: "Обратите внимание, что обменные курсы MoonPay могут отличаться от курсов, используемые в BitBoxApp, в результате суммы могут немного отличаться.",
        table: {
          "1_description": "Самая низкая комиссия, может занять до 3-х рабочих дней",
          "1_method": "Банковские переводы (SEPA)",
          "2_description": "Более высокая комиссия, но быстро и мгновенно",
          "2_method": "Кредитные и дебетовые карты",
          description: "Описание",
          fee: "Оплата",
          method: "способ"
        },
        title: "Способы оплаты и комиссии"
      },
      privacyPolicy: "Политика конфиденциальности MoonPay",
      protection: {
        description: "Приложение BitBoxApp не собирает никаких данных при покупке {{name}}, входящие средства обрабатываются как обычная транзакция. MoonPay необходимо собирать некоторые персональные данные для работы. Их политика конфиденциальности подробно объясняет, как обрабатываются предоставляемые данные",
        title: "Защита данных"
      },
      security: {
        description: "Покупая {{name}} через MoonPay, вы используете внешний сервис. Этот сервис выходит за рамки модели угроз безопасности BitBox02 и зависит от безопасности среды, в которой работает программное обеспечение BitBoxApp",
        link: "Модель угроз безопасности",
        title: "Модель безопасности"
      },
      title: "Добро пожаловать в ваш универсальный магазин для покупки {{name}}"
    },
    next: "Далее",
    selectLabel: "Выберите аккаунт",
    selectPlaceholder: "Выберите монету",
    skip: "Не показывать снова",
    title: "Купить {{name}}"
  },
  title: "Купить {{name}}"
};
const changePin$c = {
  newTitle: "Новый пароль устройства",
  oldLabel: "Текущий пароль устройства"
};
const chart$8 = {
  dataMissing: "Мы все еще собираем информацию. Пожалуйста, подождите.",
  dataUpdating: "обновление данных…",
  filter: {
    all: "Все",
    month: "Месяц",
    week: "Неделя",
    year: "Год"
  }
};
const checkSDcard$c = "Проверка карты памяти microSD";
const clickHere$c = "Нажмите здесь.";
const confirm$e = {
  abortInfo: "Нажмите, чтобы",
  abortInfoRedText: " прервать",
  approveInfo: "Удерживайте 4 секунды, чтобы",
  approveInfoGreenText: " подтвердить",
  info: "Продолжайте на Вашем устройстве BitBox. ",
  infoWhenPaired: "Сначала на присоединённом мобильном устройстве, а затем на BitBox"
};
const confirmOnDevice$c = "Пожалуйста, подтвердите на вашем устройстве.";
const device$c = {
  appUpradeRequired: "Ваш BitBox несовместим с этой версией приложения. Загрузите и установите последнюю версию."
};
const deviceLock$c = {
  button: "Включить двухфакторную авторизацию (2FA)",
  condition1: "У Вас есть резервная копия?",
  condition2: "Работает ли проверка мобильного приложения?",
  condition3: "Двухфакторная авторизация ЗАПРЕЩАЕТ резервное копирование и подключение мобильных приложений. Устройство должно быть СБРОШЕНО для выхода из режима двухфакторной авторизации (2FA)!",
  confirm: "Включить 2FA",
  title: "Включить двухфакторною авторизацию (2FA)"
};
const deviceSettings$c = {
  firmware: {
    newVersion: {
      label: "Доступная версия"
    },
    title: "Прошивка",
    upToDate: "Ваше устройство использует самую актуальную версию",
    version: {
      label: "Версия"
    }
  },
  hardware: {
    sdcard: {
      "false": "Не вставленна",
      label: "Карта Micro SD",
      "true": "Вставленный"
    },
    securechip: "Защищенный чип",
    title: "Техническое обеспечение"
  },
  loading: "Получение информации об устройстве ...",
  pairing: {
    lock: {
      "false": "Отключено",
      label: "Двухфакторная авторизации (2FA)",
      "true": "Включено"
    },
    mobile: {
      "false": "Закрыто",
      label: "Мобильное приложение",
      "true": "Открыто"
    },
    status: {
      "false": "Не соединено",
      label: "Статус",
      "true": "Соединено"
    },
    title: "Соединение"
  },
  secrets: {
    manageBackups: "Управление резервными копиями",
    title: "Полезные функции"
  }
};
const deviceTampered$c = "У Вашего BitBox был создан пароль восстановления? Если это так, немедленно прекратите процесс установки и обратитесь в службу поддержки. Shift никогда не даст Вам готовый кошелек и не будет давать рекомендации по паролю.";
const dialog$d = {
  cancel: "Отменить",
  confirm: "Подтвердить",
  confirmTitle: "Подтверждение"
};
const error$8 = {
  accountAlreadyExists: "Аккаунт уже существует",
  accountLimitReached: "Невозможно добавить счет. Достигнуто максимальное количество счетов для этой монеты",
  aoppCallback: "Произошла ошибка при добавлении адреса на {{host}}",
  aoppInvalidRequest: "Неверный запрос",
  aoppNoAccounts: "Нет доступных аккаунтов",
  aoppSigningAborted: "Запрос адресом на подключение отменен",
  aoppUnknown: "Произошла неизвестная ошибка",
  aoppUnsupportedAsset: "Актив не поддерживается",
  aoppUnsupportedFormat: "Нет доступных счетов, поддерживающих запрошенный формат адреса.",
  aoppUnsupportedKeystore: "Подключенное устройство не может подписывать сообщения для этого актива",
  aoppVersion: "Неизвестная версия"
};
const fiat$e = {
  "default": "Стандарт",
  setDefault: "Настроить {{code}} ",
  title: "Валюты"
};
const footer$e = {
  appVersion: "Версия приложения:"
};
const generic$8 = {
  enabled_false: "Отключено",
  enabled_true: "Включено"
};
const genericError$c = "Произошла ошибка. Если вы заметили какие-либо проблемы, перезапустите приложение.";
const goal$c = {
  buttons: {
    create: "Создать новый кошелек",
    restore: "Восстановить кошелек "
  },
  paragraph: "Выберите одну из следующих опций:",
  step: {
    "1": {
      title: "Информация о безопасности"
    },
    "2": {
      description: "Установка пароля устройства",
      title: "Устройство"
    },
    "3-create": {
      description: "Создать новый кошелек",
      title: "Кошелек"
    },
    "3-restore": {
      description: "из резервной копии",
      title: "Восстановить"
    },
    "4-create": {
      title: "Сводка"
    },
    "4-restore": {
      title: "Сводка"
    }
  }
};
const guide$d = {
  accountDescription: {
    text: "Это обзор вашей учетной записи. Он показывает входящие и исходящие транзакции. Баланс отображается для каждой учетной записи отдельно. Прочитайте инструкцию, чтобы узнать больше о разных типах учетных записей.",
    title: "Что здесь отображается?"
  },
  accountFiat: {
    text: "Да, Вы можете нажать на любую кнопку, чтобы выбрать валюту. Вы также можете изменить список валют в настройках.",
    title: "Можно ли отображать другие курсы обмены валюты?"
  },
  accountIncomingBalance: {
    text: "Входящие, это общая сумма средств, которые были переведены Вам, но еще не подтверждены сетью.",
    title: "Что обозначает входящее?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Каждый xpub ключ привязан к конкретному "Формату": "Native Segwit (bech32)", "Wrapped Segwit" or “Taproot” (Только для Bitcoin). Это форматы адресов, используемые {{coinName}}. Приложение BitBoxApp объединяет их, поддерживая несколько форматов адресов в одном аккаунте. Поскольку каждый формат адреса предоставляет разные xpub ключи, для каждого аккаунта существует несколько xpub ключей.\n\nЕсли вы получаете монеты по умолчанию, на формат адреса (Native Segwit), для этого нужен только xpub ключ "bech32". Однако, если вы получаете средства на "Wrapped Segwit" или “Taproot” адреса, то необходимо использовать расширенные открытые ключи от "Wrapped Segwit" и “Taproot” соответственно',
      title: "Почему существует несколько xpub ключей?"
    },
    privacy: {
      text: "Для текущего аккаунта расширенный открытый ключ (xpub) раскрывает всю финансовую историю, баланс вашего счета и все будущие транзакции. Данный xpub ключ никому не позволяет тратить ваши монеты.\n\nЕсли Вы предоставляете кому-либо xpub ключ, вы соглашаетесь с тем, что лицо или компания могут видеть все другие транзакции текущего аккаунта. Поэтому рекомендуется при передаче данного xpub ключа все иные средства хранить на других счетах или аккаунтах.",
      title: "Нужно ли хранить свой xpub ключ в секрете?"
    },
    verify: {
      text: "Да, будет полезно перепроверить свой xpub ключ. Если кто-то другой будет генерировать новые адреса из xpub ключа, для отправки вам активов, это будет особенно важно. Вам необходимо будет подтвердить это на устройстве, чтобы убедиться, что этот xpub ключ принадлежит вам. В противном случае все средства могут отправиться не по тем адресам!",
      title: "Нужно ли мне проверять xpub ключ на устройстве?"
    },
    xpub: {
      text: "Расширенный открытый ключ (xpub) - это корневой ключ, из которого выводятся все адреса получения в аккаунте.\n\nОн предоставляется здесь для расширенного использования и взаимодействия с кошельками, предназначенными только для просмотра, такими как Electrum или Sentinel. Если вы получили ключи от разных типов адресов, пожалуйста, импортируйте все различные форматы xpub в кошелек, доступный только для просмотра, чтобы увидеть все ваши монеты.\n\nОбратите внимание, что сторонние кошельки могут еще не поддерживать Taproot xpubs ключи",
      title: "Что такое расширенный открытый ключ?"
    }
  },
  accountRates: {
    text: "Курсы валют обновляются каждую минуту с помощью CoinGecko.",
    title: "Какие курсы используются?"
  },
  accountReload: {
    text: "Вся информация о транзакции обновляется автоматически.",
    title: "Как я могу перезагрузить историю транзакций?"
  },
  accountSendDisabled: {
    text: "Кнопка «Отправить» активируется, когда ваш баланс больше нуля.",
    title: "Почему я не могу отправить {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Общая сумма всех ваших криптовалютных счетов. Курсы обмена можно узнать на сайте coingecko.com.\n\nПримечание. Токены используемые с помощью MyEtherWallet которые не поддерживаются в BitBoxApp исключены из общей суммы.",
    title: "Как вычисляется общая сумма?"
  },
  accountSummaryDescription: {
    text: "Здесь вы можете увидеть динамику вашего портфолио. Сводная информация по вашим индивидуальным учетным записям отображается под графиком.",
    title: "Что изображается на этой странице?"
  },
  accountTransactionAttributesBTC: {
    text: "Виртуальный размер: используется для определения стоимости отправки транзакции. Вы успешно сэкономили, если этот размер меньше размера транзакции.\nРазмер: фактический размер транзакции в байтах при сериализации в соответствии с протоколом блокчейна.\nВес: Введенный в Segwit, это новый показатель для оценки размеров транзакций и блоков. Каждый отдельный байт Segwit считается как один, а все остальные - четырьмя единицами веса. Вместо одного мегабайта, размер блока теперь составляет четыре миллиона единиц веса.",
    title: "Сведения о транзакции, связанные с биткойнами"
  },
  accountTransactionAttributesGeneric: {
    text: "Подтверждения: Изначально, при трансляции Вашей транзакции, она будет неподтвержденной. Вам нужно будет дождаться, когда она будет включена в блок каким-либо майнером, после чего у Вас будет одно подтверждение. Затем каждый блок, передаваемый по сети, добавит еще одно подтверждение к Вашей транзакции. Обычно торговцы принимают транзакции только с 3-6 подтверждениями.\nИдентификатор транзакции: уникальный идентификационный номер, который можно использовать для поиска транзакции.\nКомиссионный сбор: майнерам выплачивается комиссия за транзакцию в качестве стимула для включения транзакций в блоки, которые они создают. Чтобы узнать больше, нажмите кнопку «Перевести».",
    title: "Какова информация, указанная в деталях транзакции?"
  },
  accountTransactionConfirmation: {
    text: "Это транзакция была передана в сеть но еще не получила подтверждения.",
    title: "Что такое ожидающая транзакция?"
  },
  accountTransactionLabel: {
    text: "Это адрес, с которого вы получали или отправляли монеты.",
    title: "Какой адрес отображается для каждой транзакции?"
  },
  accountTransactionTime: {
    text: "Время, когда транзакция была подтверждена в блокчейне.",
    title: "Какое время отображается?"
  },
  accounts: {
    howManyAccounts: {
      text: "Каждая монета может иметь максимум пять счетов",
      title: "Сколько счетов я могу создать?"
    },
    howtoAddTokens: {
      text: 'Токены, использующие стандарт ERC20, привязаны к счету Ethereum. Чтобы включить или отключить определенный токен, откройте экран "Управление счетами", разверните свою учетную запись Ethereum и включите или выключите нужный токен.',
      title: "Как мне добавить дополнительные токены?"
    },
    moveFunds: {
      text: "Да. Но так как счета независимы, вам необходимо отправлять свои средства с помощью обычной транзакции.",
      title: "Могу ли я переводить средства между счетами?"
    },
    recoverAccounts: {
      text: "Да. BitBoxApp создает аккаунт, используя устоявшиеся стандарты, совместимые с большинством других крипто-кошельков.",
      title: "Могу ли я восстановить свои аккаунт с помощью других кошельков?"
    },
    whatAreAccounts: {
      text: "Кошелек может управлять несколькими счетами одной монеты. Несколько счетов полезны, когда вы хотите хранить средства раздельно",
      title: "Что такое аккаунт?"
    },
    whyIsThisUseful: {
      text: 'В аккаунте сами счета отлично подходят для управления активами разными людьми или создания целей, так как они разделены. Вы также можете поделиться "расширенным открытым ключом (xpub)" выбранной конкретной монеты, не раскрывая ничего о других ваших монетах. Это позволит вам получать активы без повторного создания адресов. Например, у доверенных людей получать заработную плату или регулярно покупать криптовалюту',
      title: "Почему это полезно?"
    }
  },
  appendix: {
    link: "Свяжитесь с нами!",
    text: "Другой вопрос?"
  },
  backups: {
    check: {
      text: "«Проверить резервную копию» позволяет подтвердить, что у Вас есть рабочая резервная копия, соответствующая Вашему текущему кошельку. Её также можно использовать для проверки пароля восстановления.",
      title: "Что такое «Проверить резервную копию»?"
    },
    encrypt: {
      text: "Нет, но ваш пароль восстановления необходим для получения кошелька.",
      title: "Могу ли я зашифровать резервную копию?"
    },
    howOften: {
      text: "Резервная копия создается автоматически при создании нового кошелька. Вам нужно создать новую резервную копию только если ваша карта micro SD потеряна или повреждена, или если вы хотите использовать несколько микро SD-карт в качестве резервных копий.\nВам не нужно создавать новые резервные копии после транзакций. Все ваши данные транзакций могут быть воссозданы с помощью одной резервной копии, которая была автоматически создана.",
      title: "Как часто мне стоит делать резервную копию?"
    },
    whatIsABackup: {
      text: "Это копия сид на карте micro SD. Сид вместе с вашим паролем восстановления образует ваш кошелек.",
      title: "Что такое резервная копия?"
    }
  },
  backupsBB02: {
    check: {
      text: "«Проверка резервной копии» позволяет проверить, есть ли у вас рабочая резервная копия, соответствующая вашему текущему кошельку.",
      title: "Что такое «Проверка резервной копии»?"
    },
    encrypt: {
      text: "Нет. Храните карту microSD в надежном месте, поскольку она содержит незашифрованные исходные данные для восстановления вашего кошелька. Если вы хотите защитить свой сид паролем, вы можете включить факультативную фразу в экспертных настройках в разделе «Управление устройством».",
      title: "Могу ли я зашифровать резервную копию?"
    },
    whatIsABackup: {
      text: "Это копия сида на карте micro SD.",
      title: "Что такое резервная копия?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Когда функция 2FA включена, все транзакции должны быть одобрены на подключённом мобильном телефоне, для того, чтобы тратить монеты. Одноразовый зашифрованный номер отправляется в мобильное приложение, дешифруется там и возвращается в BitBox при нажатии кнопки «Подтвердить». Эта связь с устройством осуществляется через канал между мобильным телефоном и настольным приложением, установленным во время подключения.\n\nОбязательно создайте резервную копию своего кошелька и соедините мобильное приложение, прежде чем включить функцию 2FA. После включения, слот micro SD и подключение мобильного приложения отключены. Их можно повторно включить, сбросив BitBox, который стирает устройство.",
      title: "Как работает двухфакторная авторизация (2FA)?"
    },
    disable2FA: {
      text: "Чтобы отключить 2FA, вам необходимо сбросить BitBox, а затем восстановить кошелек из его резервной копии. Убедитесь, что у вас все еще есть карта microSD с резервной копией и вы все еще помните пароль восстановления. Затем нажмите «Сбросить устройство». Установите новый пароль устройства и выберите «Или восстановить резервную копию». Выберите резервную копию, которую вы сделали из кошелька, нажмите «Восстановить» и введите пароль восстановления, который вы использовали при создании кошелька.",
      title: "Как отключить двухфакторную авторизацию (2FA)?"
    },
    ejectBitbox: {
      text: "Вы можете отсоединить BitBox в любое время.",
      title: "Как я могу извлечь BitBox?"
    },
    ejectSD: {
      text: "Вы можете удалить карту microSD из BitBox в любое время, если вы не находитесь в процессе создания или восстановления резервной копии.",
      title: "Как я могу извлечь карту microSD?"
    },
    hiddenWallet: {
      text: "Это второй кошелек на том же устройстве, который защищен паролем другого устройства и паролем восстановления, который Вы можете использовать для правдоподобия. Такая же резервное семя используется как для Вашего обычного, так и скрытого кошелька, поэтому дополнительная резервная копия не требуется.",
      title: "Что такое скрытый кошелек?"
    },
    legacyHiddenWallet: {
      text: "Сначала нажмите кнопку ниже (доступно, если BitBox разблокирован с помощью пароля основного устройства, и двухфакторная авторизация 2FA отключена), затем переподключите Ваш Bitbox и разблокируйте его с помощью пароля скрытого устройства.",
      title: "Как получить доступ к унаследованному скрытому кошельку?"
    },
    pairing: {
      text: "После загрузки нашего мобильного приложения для iOS или Android сканируйте отображаемый QR-код, который устанавливает безопасный канал между мобильным приложением и этим приложением. После сканирования следуйте инструкциям в мобильном приложении.",
      title: "Как безопасно соединить с телефоном"
    }
  },
  cointracking: {
    text: 'Нажмите кнопку "Экспорт" и откройте папку загрузок, где вы найдете файл в формате CSV. Затем нажмите на ссылку ниже, загрузите свой CSV-файл BitBox и импортируйте данные, чтобы использовать их для управления портфелем (отслеживанием монет) и для создания налоговых отчетов',
    title: "Как импортировать мои транзакции из раздела с отслеживанием монет?"
  },
  receive: {
    address: {
      text: "Вы можете дать адрес другим, чтобы они отправили вам монеты. Просто убедитесь, что вы отправляете на правильный адрес.",
      title: "Что мне делать с адресом?"
    },
    addressChange: {
      text: "Как только адрес используется в транзакции, новый адрес добавляется в список для его замены. В списке всегда будет 20 неиспользуемых адресов.",
      title: "Когда меняются адреса?"
    },
    addressFormats: {
      text: "По умолчанию формат адреса - Native Segwit. Этот тип адреса широко используется другими кошельками / биржами и предлагает вам лучшие комиссионные за повседневные транзакции. Однако вы также можете выбрать отправку на Taproot (только для Биткойна (Btc)), который является самым новым типом адреса, но, возможно, еще не получил широкой поддержки на разных площадках. Если у вас возникли проблемы с отправкой на Native Segwit (тип по умолчанию), вы можете попробовать переключиться на более старый тип адреса Wrapped Segwit, который может быть совместим с разными кошельками / биржами",
      title: "Когда я должен использовать “Изменить тип адреса”?"
    },
    howVerify: {
      text: "Если у Вас BitBox01, щелкните значок BitBox на боковой панели слева и перейдите в раздел «Соединение». Руководство обновится, и вы сможете продолжить выполнение инструкций.\nЕсли у Вас BitBox02, вы можете проверять адреса непосредственно на устройстве в процессе отправки и получения.",
      title: "Как я могу безопасно проверить адрес?"
    },
    plugout: {
      text: "Нет, после того, как вы отправили монеты на свой адрес BitBox, вам не нужно оставлять свой BitBox подключенным. Вы можете отключить свой BitBox",
      title: "Нужно ли мне оставлять BitBox подключенным во время получения активов?"
    },
    why20: {
      text: "Во время запуска приложение генерирует адреса, полученные из вашего сида, чтобы вычислить, были ли отправленны на них средства. Поскольку приложение может генерировать почти бесконечное количество адресов, на определение баланса можно потратить годы. Чтобы ограничить этот поиск, он останавливается после 20 адресов на которые никогда не были отправленны средства. Это «предел разрыва» с 20 адресами является стандартом де-факто, хотя число было выбрано произвольно.",
      title: "Почему всего 20 адресов?"
    },
    whyMany: {
      text: "Для обеспечения конфиденциальности и безопасности никогда не давайте один и тот же адрес дважды. Если вы использовали адрес, щелкните стрелку вправо для перехода к новому адресу. Вы можете создать до 20 адресов одновременно. Думайте об адресах как о номерах счетов. Все адреса получены из вашего единственного сида.",
      title: "Почему так много адресов?"
    },
    whyVerify: {
      text: "Вы не должны доверять своему компьютеру во время создания и отображение подлинных адресов. Компьютер намного более уязвимый чем аппаратный кошелек. Если у вас BitBox01, кнопка подтверждения адреса безопасно отправляет адрес на соединенный мобильный телефон, с которого вы также можете сканировать и проверять QR-код. Если у вас BitBox02, адрес можно проверить непосредственно на дисплее BitBox02.",
      title: "Зачем мне безопасно проверять адрес?"
    }
  },
  send: {
    change: {
      text: "Сдача будет возвращена на адрес формата Taproot, если у вас есть хотя бы один UTXO (Выход неизрасходованных транзакций) формата Taproot. Другими словами, если вы контролируете монеты, сдача будет возвращена на адрес Taproot, если среди выбранных UTXOs есть хотя бы один Taproot UTXO. Во всех остальных случаях сдача возвращается на адрес формата Native Segwit",
      title: "Как определяется выход сдачи?"
    },
    fee: {
      text: "Плата основана на размере данных транзакции, а не на её сумме. Платы рассчитываются по алгоритму оценки платы Bitcoin Core для каждого сетевого приоритета.\nЭкономический: 24 блока (около 4 часов для биткойнов, 1 час для Litecoin)\nНизкий: 12 блоков (около 2 часов для биткойнов, 30 минут для Litecoin)\nНормальный: 6 блоков (около 1 часа для биткойнов, 15 минут для Litecoin)\nВысокий: 2 блока (около 20 минут для биткойнов, 5 минут для Litecoin)\n(Блок берет в среднем десять минут для биткойнов (2,5 минуты для Litecoin) для обработки но сетевая нагрузка может значительно различаться в вышеуказанные периоды.)",
      title: "Как определяется комиссионная плата?"
    },
    plugout: {
      text: "Нет, после того, как вы совершили транзакцию, вам не нужно оставлять свой BitBox подключенным. Вы можете отключить свой BitBox",
      title: "Нужно ли мне оставлять свой BitBox подключенным во время отправки активов?"
    },
    priority: {
      text: "Чем выше плата, которую вы готовы заплатить, тем быстрее ваша транзакция обычно подтверждается сетью.",
      title: "Что такое сетевой приоритет?"
    },
    revert: {
      text: "Как только транзакция будет подписана и отправлена ​​(это значит транслирована в сеть), она больше не может быть отменена. Перед началом подписания проверьте транзакции (включая плату)!\nЕсли Вы знаете, что получатель желает отправить ту же сумму к вам обратно, Вы можете отправить им новый адрес получателя.",
      title: "Можно ли вернуть транзакцию?"
    },
    whyFee: {
      text: "Сделки конкурируют, чтобы быть подверженными шахтером. Шахтеры выбирают транзакции, которые должны быть включены в blockchain, исходя из их стоимости.\nШахтеры голосуют на опоре историй транзакций. Поскольку нет доверенной третьей стороны для обеспечения одного голоса на одного человека (что является целым звеном цепочки блоков), шахтеры голосуют за транзакции, жертвуя дорогостоящим ресурсом, таким как вычислительная мощность. В качестве награды за свою работу они могут требовать вновь созданные монеты и плату за все транзакции, которые они причастны.",
      title: "Почему существует сетевая плата?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Если вы намереваетесь подключаться к своему узлу только тогда, когда находитесь в той же сети (например, к домашнему Wi-Fi), тогда достаточно обычного сетевого взаимодействия.\nВ этом случае рекомендуется, чтобы ваш сервер Electrum предоставил сертификат TLS для шифрования связи.\nЕсли вы собираетесь подключиться к своему узлу из любого места, лучше использовать Tor. В этом случае сертификат TLS не требуется.",
      title: "Что мне следует использовать, TCP, TLS или Tor?"
    },
    instructions: {
      link: {
        text: "Руководство по подключению собственного узла"
      },
      text: "Посетите наше полное руководство",
      title: "Как подключить BitBoxApp к собственному крипто узлу (серверу)?"
    },
    options: {
      text: "Есть несколько вариантов запуска собственного узла, таких как покупка готового устройства, создание собственного либо Bitcoin Core.\nЕсли вы хотите подключить BitBoxApp к своему узлу, убедитесь, что он запускает сервер Electrum. Это специальная программа, которая позволяет приложению взаимодействовать с вашим узлом.\nПоддерживаемые варианты включают Electrs, персональный сервер Electrum (EPS) или Bitcoin Wallet Tracker (BTW).",
      title: "Какие есть варианты запуска собственного узла?"
    },
    tor: {
      text: "Tor означает «луковый маршрутизатор». Это бесплатное программное обеспечение с открытым исходным кодом, которое предлагает множество преимуществ в отношении конфиденциальности и особенно полезно при использовании биткойнов.\nЕсли вы собираетесь подключиться к своему узлу через Tor, убедитесь, что Tor установлен на вашем компьютере, а затем включите Tor Proxy в настройках BitBoxApp.\nВ большинстве операционных систем есть два способа запустить Tor:\n1. Tor Browser: загрузите и откройте Tor Browser. Это позволит BitBoxApp подключиться к сети Tor, установив порт 9150 в настройках прокси-сервера Tor.\n2. Фоновая служба Tor: установите демон Tor, который всегда работает в фоновом режиме. Затем BitBoxApp сможет подключиться, установив порт 9050 в настройках прокси-сервера Tor.",
      title: "Что такое Tor, прокси-сервер Tor и какой порт мне следует использовать?"
    },
    what: {
      text: "Возможно использовать свой кошелек с вашими собственными полными узлами вместо использования серверов Shift.",
      title: "Что это?"
    },
    why: {
      text: "Запуск собственного узла не является обязательным, но улучшает конфиденциальность и снижает необходимость доверять другим.\nВо-первых, это означает, что вы используете биткойн более конфиденциально, поскольку BitBoxApp не будет подключаться к нашим серверам для получения сводки ваших транзакций; вместо этого приложение получит эту информацию из вашего собственного узла.\nВо-вторых, запуск собственного узла означает, что ваш узел сам проверяет все транзакции, следя за соблюдением правил консенсуса.",
      title: "Зачем мне запускать собственный узел?"
    }
  },
  settings: {
    servers: {
      text: "Это приложение взаимодействует с серверами Shift Crypto для проверки обновлений, загрузки транзакций и отправки информации к соединенным мобильным приложениям.\nКроме того, оно извлекает последнии курсы обмена от CoinGecko. (Конверсии вычисляются локально, никакие суммы не передаются.)",
      title: "На каких серверах работает это приложение?"
    }
  },
  title: "Руководство",
  toggle: {
    close: "Закрыть руководство",
    open: "Руководство"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Вам необходимо сбросить устройство и восстановить кошелек из резервной копии, используя пароль восстановления.",
      title: "Что делать, если я забыл пароль устройства?"
    },
    reset: {
      text: "Введите неверный пароль устройства 15 раз. Последние несколько попыток требуют длительного касания устройства.",
      title: "Как сбросить устройство?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Устройство должно мигнуть один раз при присоединении. Убедитесь, что оно вставлено правильно. Если у вас возникли проблемы, пожалуйста, свяжитесь с нами по ссылке ниже.\n\nBitBox01 не поддерживается на мобильных устройствах. Пожалуйста, используйте приложение BitBoxApp на рабочем столе для подключения вашего BitBox01",
      title: "Мое устройство BitBox01 не распознается"
    },
    getDevice: {
      link: {
        text: "Заказать BitBox"
      },
      text: "Вы можете купить BitBox в нашем интернет-магазине:",
      title: "Как я могу получить устройство?"
    },
    internet: {
      text: "Да, для синхронизации кошелька, транзакций и получения последних обменных курсов, требуется интернет-соединение.",
      title: "Требуется ли для этого приложения подключение к Интернету?"
    },
    lostDevice: {
      link: {
        text: "Центр резервных копий"
      },
      text: "Вы можете восстановить свои учетные записи на новом BitBox или в нашем центре резервных копий.",
      title: "Я потерял свое устройство. Что теперь?"
    },
    useWithoutDevice: {
      text: "К сожалению, пока это невозможно.",
      title: "Могу ли я использовать приложение без устройства?"
    },
    welcome: {
      text: "Спасибо за использование этого приложения, созданного Shift Crypto в Швейцарии. Он по-прежнему находится в стадии бета-тестирования, и мы ценим любой вклад, которым Вы можете поделиться. Пожалуйста, оцените приложение, используя ссылку внизу.",
      title: "Добро пожаловать в приложение BitBoxApp!"
    }
  }
};
const headerssync$c = {
  blocksSynced: "{{blocks}} блоков синхронизированы"
};
const hiddenWallet$c = {
  info1HTML: "Для правдоподобных целей неприкосновенности скрытый кошелек может быть создан на основе комбинации <strong> разных </strong> паролей для восстановления пароля устройства.",
  info2HTML: "Определите пароль устройства и пароль восстановления, которые Вы хотите связать с Вашим скрытым кошельком. Пароль устройства и пароль восстановления должны <strong> отличатся </strong> от тех, которые Вы используете для своего основного кошелька.",
  passwordLabel: "Скрытый пароль восстановления",
  passwordPlaceholder: "Подтвердите скрытый пароль восстановления",
  pinLabel: "Скрытый пароль устройства",
  pinRepeatLabel: "Повторить скрытый пароль устройства",
  pinRepeatPlaceholder: "Подтвердите пароль скрытого устройства",
  success: "Скрытый кошелек создан успешно. Переподключите BitBox, чтобы разблокировать его."
};
const initialize$c = {
  create: "Установить пароля устройства",
  creating: "Установка пароля устройства ...",
  error: {
    e102: "Пароль устройства должен содержать не менее 4 символов."
  },
  info: {
    description1: "Выберите пароль устройства. Он будет использоваться для разблокировки вашего BitBox.",
    description2: "Вы можете использовать числа и буквы. Длинные пароли гарантируют больше безопасности.",
    description3: "Если Вы потеряете пароль устройства, вам придётся сбросить  Ваше устройство и восстановить резервную копию Вашего кошелька.",
    subtitle: "Теперь Вы установите пароль своего устройства",
    title: "Инициализация устройства"
  },
  input: {
    label: "Пароль устройства",
    labelRepeat: "Повторить пароль устройства",
    placeholderRepeat: "Подтвердить пароль устройства"
  }
};
const invalidFormat$c = "Недопустимый формат";
const language$d = {
  title: "Выбрать язык"
};
const legacyhiddenwallet$c = {
  disable: "Отключить скрытый кошелек устаревшего типа",
  enable: "Включить скрытый кошелек устаревшего типа",
  successDisable: "Успешно отключился скрытый кошелек.",
  successEnable: "Успешно включился скрытый кошелек. Переподключите свой BitBox и введите пароль скрытого устройства, чтобы получить доступ к скрытому кошельку."
};
const loading$c = "загрузка ...";
const manageAccounts$6 = {
  editAccount: "Изменить",
  editAccountNameTitle: "Изменить имя аккаунта",
  noAccounts: " Аккаунты не найдены",
  settings: {
    hideTokens: "Скрыть токены",
    showTokens: "Показать токены ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Добавить и отобразить/скрыть аккаунты",
  title: "Управление аккаунтами"
};
const mobile$7 = {
  usingMobileDataWarning: "Использование мобильных данных: это приложение может загружать до нескольких сотен мегабайт данных из блокчейна после разблокировки учетной записи. Пожалуйста, подключитесь к Wi-Fi, чтобы не использовать мобильные данные. После закрытия этого сообщения, оно больше не будет отображаться."
};
const note$8 = {
  input: {
    description: "(факультативно)",
    placeholder: "Добавить примечание ..."
  },
  title: "Примечание"
};
const notification$c = {
  newTxs_one: "Новая транзакция в: {{accountName}}",
  newTxs_other: "{{count}} новых транзакций в: {{accountName}}"
};
const pairing$c = {
  aborted: {
    text: "Присоединение с мобильным приложением было отменено.",
    title: "Ошибка"
  },
  button: "Присоединить мобильное приложение ",
  confirm: "Вы уверены, что хотите присоединить свой BitBox? Обратите внимание, что после этого для выполнения транзакции требуется мобильный телефон.",
  connectOnly: {
    button: "Подключить мобильное приложение",
    title: "Сканируйте с помощью нашего мобильного приложения, выбрав пункт меню «Подключиться к новому настольному приложению»,"
  },
  error: {
    text: "Произошла ошибка. Пожалуйста, начните заново.",
    title: "Ошибка"
  },
  pullFailed: {
    text: "Не удалось получить сообщение с мобильного телефона через ретрансляционный сервер. Возможно, сервер ретрансляции отключен, обратитесь в службу технической поддержки",
    title: "Ошибка извлечения"
  },
  reconnectOnly: {
    button: "Запустите заново мобильное приложение"
  },
  scanningFailed: {
    text: "Мобильный телефон не смог успешно отсканировать сообщение. Пожалуйста, попробуйте еще раз",
    title: "Ошибка сканирования"
  },
  start: {
    hideAppQRCode: "Скрыть QR код",
    revealAppQRCode: "Показать QR код",
    step1: "Если у вас нет мобильного приложения, вы можете отсканировать QR-код для Apple App Store или Google Play Store в зависимости от того, какое у вас устройство.",
    step2: "Сканируйте с помощью нашего мобильного приложения, которое вы можете найти под названием «Digital Bitbox 2FA» в магазинах приложений для iOS и Android:"
  },
  started: {
    text: "Теперь следуйте инструкциям в мобильном приложении.",
    title: "Отлично"
  },
  success: {
    text: "Поздравляем, Вы успешно соединили свой BitBox с мобильным приложением!",
    title: "Успех"
  },
  timeout: {
    text: "Время ожидания истекло спустя две минуты. Начните снова, если Вы все еще хотите соединить мобильное приложение.",
    title: "Тайм-аут"
  },
  title: "Мобильное сопряжение"
};
const passphrase$6 = {
  considerations: {
    button: "Рекомендации по резервному копированию",
    message: "Кодовая фраза добавляет дополнительный уровень защиты к резервной копии вашего кошелька (карта microSD или seed фраза из 24 слов). Если у кого-то есть доступ к вашей резервной копии, ему также понадобится кодовая фраза для доступа к вашему кошельку.\n\nОднако это означает, что вам понадобится <strong>как кодовая фраза, так и резервная копия кошелька</strong> для восстановления кошелька с поддержкой кодовой фразы, в случае, если ваш BitBox02 потерян или сломан. Если вы забудете или потеряете свою кодовую фразу, вы потеряете доступ ко всем монетам на данном кошельке (аккаунте).\n\nПри хранении кодовой фразы подумайте о том, чтобы поместить ее в отдельное место, отличное от резервной копии. Таким образом, если кто-то найдет вашу резервную копию, он не найдет вашу кодовую фразу!",
    title: "Рекомендации по резервному копированию"
  },
  disable: "Отключение кодовой фразы",
  disableInfo: {
    button: "Отключить",
    message: "После отключения кодовой фразы вам больше не будет предложено ввести кодовую фразу после разблокировки BitBox02. Вы увидите свой кошелек по умолчанию.\n\nЛюбые монеты на вашем кошельке с кодовой фразой по-прежнему будут находиться на этом кошельке, но вы не сможете получить к ним доступ, потому что после разблокировки вашего BitBox02 откроется кошелек по умолчанию.\n\nЧтобы снова получить доступ к вашим кошелькам с кодовой фразой, просто повторно включите функцию кодовой фразы и введите соответствующую кодовую фразу после разблокировки BitBox02.\n\n<strong>Совет:</strong> Вы можете попасть в свой кошелек по умолчанию, оставив пароль пустым"
  },
  enable: "Включить кодовую фразу",
  error: {
    e104: "Изменение настройки кодовой фразы было прервано"
  },
  how: {
    button: "Как это выглядит",
    message: "Кодовая фраза работает не так, как пароль, к которому вы привыкли. Если вы неправильно введете свою кодовую фразу, то не получите уведомление. Это происходит потому, что <strong>каждая кодовая фраза создает другой, но действительный кошелек</strong>. Вы можете использовать несколько кодовых фраз для любого количества кошельков, сколько захотите. Доступ к каждому кошельку возможен только при вводе соответствующей кодовой фразы.\n\nПри включении BitBox02 вам, как обычно, будет предложено ввести пароль устройства. После этого будет предложено ввести кодовую фразу на устройстве.\n\nПосле ввода кодовой фразы вам будет показана введенная вами кодовая фраза. Это сделано для того, чтобы вы могли убедиться, что ввели её правильно",
    title: "Как это работает"
  },
  intro: {
    message: "Кодовая фраза обеспечивает дополнительный уровень безопасности вашего кошелька.\nДавайте узнаем, как это работает",
    title: "Установить кодовую фразу"
  },
  progressDisable: {
    message: "Подтвердите в своем BitBox, что вы хотите <strong>отключить</strong> необязательную кодовую фразу",
    title: "Подтвердите на устройстве"
  },
  progressEnable: {
    message: "Подтвердите на своем BitBox, что вы хотите <strong>включить</strong> необязательную кодовую фразу",
    title: "Подтвердите на устройстве"
  },
  successDisabled: {
    message: "Необязательная кодовая фраза <strong>успешно включена</strong>!\nС этого момента вас попросят её ввести",
    messageEnd: "Пожалуйста, подключите BitBox02 сейчас",
    title: "Кодовая фраза включена"
  },
  successEnabled: {
    message: "Необязательная кодовая фраза <strong>успешно отключена</strong>!\nВас больше не будут просить ввести кодовую фразу",
    messageEnd: "Пожалуйста, подключите ваш BitBox02 сейчас",
    tips: "Рекомендации",
    tipsList: [
      "Мы рекомендуем сначала отправить небольшую сумму на кошелек с кодовой фразой. Затем отключите и снова подключите BitBox02 и введите свой пароль и кодовую фразу. Если вы правильно ввели кодовую фразу, вы должны увидеть монеты в своем кошельке",
      "Если вы хотите ввести свой оригинальный кошелек без кодовой фразы, достаточно не вводить ничего, когда будет предложено ввести кодовую фразу, оставить пустую строку. Или вы можете отключить функцию кодовой фразы"
    ],
    title: "Кодовая фраза отключена"
  },
  summary: {
    button: "Включить кодовую фразу",
    title: "Сводка",
    understand: "Я понимаю, как работает кодовая фраза и связанные с ней риски",
    understandList: [
      "Кодовая фраза - это дополнительный уровень безопасности, помимо вашей резервной копии",
      "Ввод другой кодовой фразы всегда приведет к созданию нового кошелька",
      "Чтобы восстановить свой кошелек, вам понадобится <strong>как кодовая фраза, так и резервная копия</strong>",
      "Если вы забудете свою кодовую фразу, вы больше не сможете получить доступ к своим монетам"
    ]
  },
  what: {
    button: "Узнайте, как это работает",
    message: "Кошелек создается (выводится) из очень большого случайного числа, также известного как seed фраза (начальная фраза). Это начальная фраза создается при первой настройке BitBox02 и сохраняется с помощью карты microSD или 24 слов. Любой, у кого есть доступ к seed фразе, имеет полный контроль над средствами на этом кошельке.\n\nКодовое слово - это <strong>необязательный секрет</strong>, добавляемый к seed фразе. При использовании кодового слова создается новый кошелек на основе seed фразы + кодового слова (необязательного секрета). Каждое новое кодовое слово создает новый, другой кошелек. Кодовое слово может состоять из: букв, слов, специальных символов или даже быть пустым. На самом деле при создании начальной фразы по умолчанию стоит пустая кодовая фраза, т.е. seed фраза + пустое кодовое слово.\n\nКодовое слово является частью стандарта BIP39 - это означает, что она совместима со всеми кошельками, поддерживающими один и тот же стандарт",
    title: "Что такое кодовое слово?"
  },
  why: {
    button: "Зачем использовать кодовое слово",
    message: "BitBox02 полностью защищает seed фразу от извлечения с самого устройства, но резервная копия (карта microSD или 24 слова) дают полный доступ к кошельку. Они должны храниться в надежном месте!\n\nТак как кодовое слово создает новый кошелек, используя вашу существующую seed фразу, его также требуется хранить, <strong>как резервную копию для восстановления</strong>. Преимущество этого заключается в том, что если кто-то найдет вашу резервную копию (от seed фразы), ему все равно понадобится пароль для доступа к кошельку с кодовой фразой.\n\nКроме того, функция кодовой фразы позволяет создавать несколько кошельков на одном устройстве, как “скрытые кошельки” в дополнение к кошельку по умолчанию",
    title: "Зачем использовать кодовое слово?"
  }
};
const password$c = {
  show: "Показать {{label}}",
  warning: {
    caps: "ВНИМАНИЕ: «Caps Lock» (⇪) включен",
    paste: "Для того чтобы вставить текст, включите «ПОКАЗАТЬ {{label}}»"
  }
};
const random$d = {
  button: "Сгенерировать случайное число",
  description: "Ваш BitBox сгенерировал следующее {{bits}}-битное случайное число:"
};
const receive$e = {
  changeScriptType: "Изменить тип адреса",
  label: "Ваш адрес",
  onlyThisCoin: {
    description: "Чтобы получать другие токены, включите их в настройках. Если вы внесете другие токены, они могут быть недоступны.",
    warning: "Убедитесь, что получаете только {{coinName}} по этому адресу."
  },
  scriptType: {
    p2tr: "Taproot (новейший формат)",
    p2wpkh: "Native Segwit (по умолчанию)",
    "p2wpkh-p2sh": "Wrapped Segwit (совместимый формат)"
  },
  showFull: "Показать и проверить полный адрес на устройстве",
  taprootWarning: "Примечание: Taproot - это новая функция Биткойна, которая еще не получила широкого распространения. Средства, полученные на формат адреса Taproot, могут быть недоступны для просмотра в сторонних кошельках, предназначенных только для просмотра. Многие кошельки и биржи пока не могут отправлять на адреса Taproot",
  title: "Получить {{accountName}}",
  verify: "Безопасно проверить адрес",
  verifyBitBox01: "Подтвердите адрес в мобильном приложении",
  verifyBitBox02: "Проверить адрес на BitBox02",
  verifyInstruction: "Убедитесь, что этот адрес совпадает с тем который отображается на Вашем устройстве.",
  warning: {
    secureOutput: 'Пожалуйста, соедините ваш BitBox с мобильным устройством, чтобы включить безопасную проверку адреса. Перейдите в раздел "Управление устройством" на боковой панели'
  }
};
const reset$c = {
  description: "Все данные на устройстве будут удалены. Это включает в себя Ваш закрытый ключ!",
  notReset: "Не удалось сбросить устройство.",
  title: "Сбросить устройство на заводскую прошивку",
  understand: "У меня есть резервная копия и я знаю пароль восстановления",
  understandBB02: "У меня есть действующая резервная копия"
};
const securityInformation$c = {
  create: {
    description1: "Мы рекомендуем вам инициализировать устройство в безопасной среде, вдали от других людей которые могут видеть Ваш пароль.",
    description2: "Вам будет предложено создать два пароля.",
    description3: "Первый <strong>device password</strong>, это тот, который разблокирует Ваш BitBox и может быть изменен позже.",
    description4: "Второй  <strong>recovery password</strong> открывает Ваш кошелек. Этот пароль не может быть изменен позже.",
    description5: "Созданный кошелек будет скопирован в файл на прилагаемой карте micro SD. Её можно использовать в чрезвычайной ситуации, чтобы восстановить свои средства, используя <strong>пароль восстановления</strong>.",
    title: "Информация о безопасности"
  },
  restore: {
    description1: "Вам нужно будет вставить карту micro SD, которую вы использовали для хранения резервной копии",
    description2: "Для восстановления вашего устройства вам понадобится пароль восстановления.",
    description3: "Будьте внимательны при вводе пароля восстановления. Любой введенный Вами пароль создаст действительный кошелек. Если Вы введете неправильный пароль, вам может быть показан баланс кошелька, которого вы не ожидаете.",
    title: "Информация о безопасности"
  }
};
const seed$c = {
  agreements: {
    "funds-access": "Я НЕ смогу получить доступ к своим средствам, если я забуду пароль восстановления",
    "password-change": "Я НЕ смогу изменить пароль восстановления позже.",
    "password-required": "Пароль восстановления необходим для восстановления кошелька из резервной копии"
  },
  create: "Создать кошелек",
  creating: "Создание кошелька",
  description: "Я подтверждаю:",
  error: {
    e102: "Пароль должен состоять не менее чем из 4 символов.",
    e200: "Вам необходимо вставить карту micro SD в свой BitBox, чтобы создать кошелек и создать автоматически резервную копию"
  },
  info: {
    button: "Установить пароль восстановления",
    description1: "Вставьте карту micro SD в BitBox",
    description2: "Выберите пароль восстановления для кошелька и нажмите «Установить пароль восстановления»",
    description3: "Резервная копия на карте micro SD и резервная копия из слов (seed фраза) - единственный способ восстановить ваши средства в случае потери или кражи BitBox.",
    description4: "Вы не можете изменить пароль для восстановления позже, не переводя свои средства.",
    title: "Создать новый кошелек"
  },
  password: {
    label: "Пароль восстановления",
    repeatPlaceholder: "Повторить пароль восстановления"
  },
  walletName: {
    label: "Название кошелька"
  }
};
const seedRestore$c = {
  error: {
    e200: "Для восстановления кошелька из резервной копии требуется карта micro SD."
  },
  info: {
    description1: "Вставьте карту micro SD в BitBox и нажмите «Продолжить»,",
    description2: "Выберите резервную копию и нажмите «Восстановить»,",
    description3: "Введите пароль восстановления",
    description4: "Вам нужно подтвердить, что неверный пароль создаст другой кошелек.",
    title: "Как восстановить кошелек из резервной копии"
  }
};
const send$e = {
  abort: "Транзакция была прервана.",
  address: {
    label: "Адрес получателя",
    placeholder: "Введите адрес"
  },
  amount: {
    label: "Сумма",
    placeholder: "Введите сумму"
  },
  availableBalance: "Доступные средства",
  button: "Проверка",
  coincontrol: {
    address: "Адрес",
    outpoint: "Outpoint",
    title: "Отправить с выхода"
  },
  confirm: {
    "selected-coins": "Выбранные монеты",
    title: "Подтвердить и отправить транзакцию",
    total: "Всего"
  },
  error: {
    feeTooLow: "комиссия слишком малая",
    feesNotAvailable: "Не удалось оценить комиссии",
    insufficientFunds: "недостаточно средств",
    invalidAddress: "неверный адрес",
    invalidAmount: "недопустимая сумма",
    invalidData: "неверные данные"
  },
  fee: {
    customPlaceholder: "Внести сумму",
    label: "Сетевая комиссия",
    placeholder: "Недоступно"
  },
  feeTarget: {
    customLabel: "Процент комиссии",
    customLabel_eth: "Цена gas (газа eth)",
    description: {
      economy: "4 часа (24 блока)",
      economy_eth: "30 минут или меньше",
      economy_ltc: "1 час (24 блока)",
      high: "20 минут (2 блока)",
      high_eth: "30 секунд или меньше",
      high_ltc: "5 минут (2 блока)",
      low: "2 часа (12 блоков)",
      low_eth: "5 минут или меньше",
      low_ltc: "30 минут (12 блоков)",
      normal: "1 час (6 блоков)",
      normal_eth: "2 минуты или меньше",
      normal_ltc: "15 минут (6 блоков)"
    },
    estimate: "Расчетное время подтверждения транзакции:",
    label: {
      custom: "Кастом",
      economy: "Эконом",
      high: "Быстро",
      low: "Медленно",
      normal: "Средне"
    },
    placeholder: "Расчет сетевой комиссии  ..."
  },
  maximum: "Отправить все",
  maximumSelectedCoins: "Отправить выбранные монеты",
  priority: "Приоритет",
  scanQR: "Сканировать QR код",
  signprogress: {
    description: "Это транзакция содержит много данных. Чтобы полностью подписать транзакцию, вы должны подтвердить {{steps}} разa.",
    label: "Прогресс"
  },
  success: "Транзакция была подписана и отправлена.",
  title: "Послать {{accountName}}",
  toggleCoinControl: "Переключить управление входами",
  transactionDetails: "Детали транзакции"
};
const settings$d = {
  electrum: {
    add: "Добавить сервер",
    "add-server": "Добавить",
    check: "Проверка",
    checkFailed: "Не удалось",
    checkSuccess: "Успешно установлено соединение с {{host}}",
    checking: "Проверка",
    "download-cert": "Загрузить сертификат",
    "remove-server": "Удалить",
    removeConfirm: "Удалить {{server}}?",
    reset: "Восстановить на изначальные настройки",
    resetConfirm: "Вы хотите удалить все серверы и установить изначальные?",
    servers: "Серверы",
    step1: "1",
    "step1-text": "Введите эндпоинт.",
    step2: "2",
    "step2-text": "Введите сертификат цепочки сертификатов сервера. Либо, скачайте сертификат и сравните его визуально.",
    "step2-text-tcp": "Вы можете пропустить этот шаг, если не хотите использовать TLS.",
    step3: "3",
    "step3-text": "Проверьте подключение и добавьте сервер.",
    step4: "4",
    "step4-text": "Перезагрузите кошелек. Если Вы не удалите дефолтные серверы, Ваш собственный узел будет добавлен как избыточность.",
    "title-btc": "Серверы Bitcoin Electrum",
    "title-ltc": "Серверы Litecoin Electrum",
    "title-tbtc": "Серверы Bitcoin Testnet Electrum ",
    "title-tltc": "Серверы Litecoin Testnet Electrum "
  },
  expert: {
    coinControl: "Включить управление входами",
    electrum: {
      title: "Подключить свой собственный узел"
    },
    fee: "Включить индивидуальную сетевую комиссию",
    setProxyAddress: "Установить адрес прокси",
    title: "Экспертные настройки",
    useProxy: "Включить прокси-сервер тор"
  },
  header: {
    home: "Главная"
  },
  restart: "Перезапустите BitBoxApp, чтобы изменения вступили в силу.",
  services: {
    title: "Сервисы"
  },
  success: "Пожалуйста, отключите и подключите BitBox заново, чтобы изменения вступили в силу.",
  title: "Настройки"
};
const setup$c = "Инициализировать устройство";
const sidebar$d = {
  buy: "Купить криптовалюту",
  device: "Управление устройством",
  leave: "Выйти",
  settings: "Настройки"
};
const success$j = {
  create: {
    info1: "Резервная копия вашего кошелька была надежно сохранена на карту microSD. Выньте ее и сохраните в надежном месте.",
    info2: "Вы создали пароль защищающий устройство, который открывает доступ к BitBox.",
    info3: "Вы создали безопасный пароль для восстановления Вашего кошелька, который разблокировывает Ваши средства и восстанавливает Ваши резервные копии.",
    summary: "Вот краткое изложение того, что Вы сделали",
    title: "Успешно"
  },
  getstarted: "Начать",
  restore: {
    summary: "Вы успешно восстановили кошелек из резервной копии.",
    title: "Успешно"
  }
};
const transaction$d = {
  confirmation: "Подтверждения",
  details: {
    activity: "Деятельность",
    address: "Адрес",
    amount: "Сумма",
    date: "Дата",
    fiat: "Фиат",
    fiatAmount: "Сумма фиата",
    status: "Статус",
    type: "Тип"
  },
  explorer: "Номер транзакции",
  explorerTitle: "Открыть во внешнем проводнике блоков",
  fee: "Плата",
  fiatHistorical: "Исторический",
  gas: "Газ",
  note: {
    edit: "Изменить заметку",
    save: "Сохранить заметку"
  },
  pending: "Неподтвержденная транзакция",
  size: "Размер",
  status: {
    complete: "Завершенная",
    failed: "Неудавшаяся",
    pending: "В ожидании"
  },
  tx: {
    received: "Получено",
    sent: "Отправлено"
  },
  vsize: "Виртуальный размер",
  weight: "Вес"
};
const transactions$c = {
  placeholder: "Нет пока никаких транзакций."
};
const unknownError$c = "Произошла неизвестная ошибка: {{errorMessage}}";
const unlock$c = {
  description: "Введите пароль своего устройства, чтобы разблокировать устройство.",
  error: {
    e109_normal: "Неверный пароль устройства. {{remainingAttempts}} попыток остаются до сброса данных устройства.",
    e109_touch: "$t(unlock.error.e109_normal) Следующий вход в систему требует удерживание сенсорной кнопки.",
    e113: "Из-за многих попыток входа в систему, для очередного входа в систему требуется удерживать сенсорную кнопку в течение 4 секунд."
  },
  input: {
    label: "Пароль устройства",
    placeholder: "Введите пароль своего устройства."
  },
  unlocking: "Разблокировка ..."
};
const upgradeFirmware$d = {
  button: "Обновление прошивки",
  description: "Вы хотите обновить прошивку с {{currentVersion}} на {{newVersion}}?",
  label: "Для использования BitBox требуется обновление прошивки.",
  locked: "Чтобы обновить с {{currentVersion}} на {{newVersion}}, долго нажмите кнопку.",
  title: "Обновление прошивки",
  unlocked: "Загрузчик разблокирован. Чтобы продолжить, пожалуйста:",
  unlocked1: "Отсоедините и присоедините Ваш Bitbox заново",
  unlocked2: "Светодиод загорится, когда Ваш BitBox будет снова присоеденён",
  unlocked3: "Нажмите сенсорную кнопку, когда загорится светодиод"
};
const warning$i = {
  receivePairing: "Пожалуйста, соедините BitBox, для безопасной проверки адреса. Перейдите в «Настройки Устройства» на боковой панели",
  sdcard: "Храните карту micro SD отдельно от BitBox, если только вы не хотите управлять резервными копиями",
  sendPairing: "Присоедините BitBox, для безопасного провeрки данных транзакции. Перейдите в «Настройки устройства» на боковой панели"
};
const welcome$c = {
  getStarted: "Давайте начнем с установки прошивки на ваш BitBox02",
  insertBitBox02: "Для использования BitBox02, пожалуйста, коснитесь устройства.",
  insertDevice: "Присоедините Ваше устройство для начала работы",
  title: "Добро пожаловать"
};
const appTranslationsRU = {
  account: account$c,
  accountInfo: accountInfo$c,
  accountSummary: accountSummary$c,
  addAccount: addAccount$d,
  aopp: aopp$6,
  app: app$c,
  backup: backup$c,
  bb02Bootloader: bb02Bootloader$c,
  bitbox: bitbox$c,
  bitbox02Interact: bitbox02Interact$c,
  bitbox02Settings: bitbox02Settings$c,
  bitbox02Wizard: bitbox02Wizard$c,
  blink: blink$c,
  bootloader: bootloader$c,
  button: button$h,
  buy: buy$8,
  changePin: changePin$c,
  chart: chart$8,
  checkSDcard: checkSDcard$c,
  clickHere: clickHere$c,
  confirm: confirm$e,
  confirmOnDevice: confirmOnDevice$c,
  device: device$c,
  deviceLock: deviceLock$c,
  deviceSettings: deviceSettings$c,
  deviceTampered: deviceTampered$c,
  dialog: dialog$d,
  error: error$8,
  fiat: fiat$e,
  footer: footer$e,
  generic: generic$8,
  genericError: genericError$c,
  goal: goal$c,
  guide: guide$d,
  headerssync: headerssync$c,
  hiddenWallet: hiddenWallet$c,
  initialize: initialize$c,
  invalidFormat: invalidFormat$c,
  language: language$d,
  legacyhiddenwallet: legacyhiddenwallet$c,
  loading: loading$c,
  manageAccounts: manageAccounts$6,
  mobile: mobile$7,
  note: note$8,
  notification: notification$c,
  pairing: pairing$c,
  passphrase: passphrase$6,
  password: password$c,
  random: random$d,
  receive: receive$e,
  reset: reset$c,
  securityInformation: securityInformation$c,
  seed: seed$c,
  seedRestore: seedRestore$c,
  send: send$e,
  settings: settings$d,
  setup: setup$c,
  sidebar: sidebar$d,
  success: success$j,
  transaction: transaction$d,
  transactions: transactions$c,
  unknownError: unknownError$c,
  unlock: unlock$c,
  upgradeFirmware: upgradeFirmware$d,
  warning: warning$i,
  welcome: welcome$c
};
const account$b = {
  disconnect: "Sambungan hilang. Mencuba lagi...",
  "export": "Eksport",
  exportTransactions: "Eksport transaksi ke folder muat turun sebagai fail CSV",
  fatalError: "Terdapat kesilapan yang tidak dijangka.",
  incoming: "Masuk",
  initializing: "Mendapatkan maklumat dari blockchain ...",
  insuranceExpired: "<strong>Akaun tidak lagi diinsuranskan</strong>\n\nPelan insurans untuk akaun ini telah diubah suai.\nSila semak halaman insurans untuk butiran.",
  insured: "Akaun yang diinsuranskan",
  maybeProxyError: "Proksi Tor diaktifkan. Pastikan proksi Tor anda berfungsi dengan baik atau matikan tetapan proksi.",
  reconnecting: "Sambungan hilang, mencuba menyambung kembali...",
  syncedAddressesCount: "{{count}} alamat telah diimbas",
  uncoveredFunds: "Anda mempunyai syiling pada alamat yang tidak diinsuranskan. Nama alamat: <strong>{{name}}</strong>, akaun yang tidak diinsuranskan: {{uncovered}}.\nKarena akaun itu diinsuranskan, hanya syiling diterima melalui <strong>Segwit asli (Native Segwit)</strong> adalah jenis alamat yang diinsuranskan. Syiling pada jenis alamat yang berbeza, walaupun ia berada pada akaun yang sama, tidak diinsuranskan.\nSila alihkan semua syiling anda daripada jenis alamat yang tidak disokong kepada jenis alamat <strong>Segwit asl (Native Segwit)i</strong>, jadi semua syiling anda pada akaun ini diinsuranskan.",
  uncoveredFundsLink: "Ikuti panduan ini tentang cara mengalihkan syiling anda.",
  warning: "Amaran!\n"
};
const accountInfo$b = {
  address: "Alamat",
  buyCTA: {
    buy: "Beli {{unit}}",
    buyCrypto: "Beli Kripto",
    information: {
      looksEmpty: "Nampaknya dompet ini kosong.",
      start: "Memulakan dengan mendepositkan beberapa syiling ke dalam dompet atau membeli terus di dalam aplikasi BitBoxApp."
    }
  },
  extendedPublicKey: "Public key lanjutan",
  label: "Maklumat akaun",
  scriptType: "Jenis skrip",
  title: "Maklumat Akaun",
  verify: "Sahkan pada peranti",
  xpubTypeChangeBtn: {
    p2pkh: "Lihat legacy P2PKH extended public key",
    p2tr: "Lihat Taproot",
    p2wpkh: "Lihat Segwit Asli",
    "p2wpkh-p2sh": "Lihat Segwit public key lanjutan yang lebih lama"
  },
  xpubTypeInfo: "Sedang memaparkan {{scriptType}} public key lanjutan ({{current}} daripada {{numberOfXPubs}})"
};
const accountSummary$b = {
  availableBalance: "Baki yang ada",
  balance: "Baki",
  exportSummary: "Eksport Ringkasan Akaun ke Folder Muat Turun sebagai Fail CSV",
  fiatBalance: "Baki Fiat",
  name: "Nama Akaun",
  noAccount: "Tiada akaun untuk dipaparkan.",
  subtotalWithCoinName: "Jumlah ({{coinName}})",
  title: "Ringkasan Akaun",
  total: "Jumlah",
  transactionHistory: "Sejarah transaksi"
};
const addAccount$c = {
  chooseName: {
    nextButton: "Tambah Akaun",
    step: "Nama akaun",
    title: "Namakan akaun anda"
  },
  selectCoin: {
    nextButton: "Seterusnya",
    step: "Pilih syiling",
    title: "Pilih mata wang kripto"
  },
  success: {
    addAnotherAccount: "Tambah akaun lain",
    message: "<strong>{{accountName}}</strong> telah ditambahkan ke akaun anda",
    nextButton: "Selesai",
    step: "Selesai",
    title: "Akaun ditambahkan"
  },
  title: "Tambah akaun"
};
const aopp$5 = {
  addressRequest: "{{host}} sedang meminta alamat penerimaan.",
  addressRequestWithLogo: "sedang meminta alamat penerima",
  banner: "Permintaan alamat sedang dijalankan. Sila sambungkan peranti anda untuk meneruskan.",
  errorTitle: "Ralat semasa permintaan alamat",
  labelAddress: "Alamat",
  labelMessage: "Mesej",
  reverifyInfoText: "Sahkan alamat",
  signing: "Untuk meneruskan, tandatangani mesej pada BitBox02 anda.",
  success: {
    message: "Teruskan {{host}}",
    title: "Alamat berjaya dihantar"
  },
  syncing: "Menyelaraskan akaun, sila tunggu.",
  title: "Permintaan alamat"
};
const app$b = {
  upgrade: "Versi baru aplikasi ini telah didapati! Sila kemaskini dari {{current}} ke {{version}}."
};
const auth$6 = {
  authButton: "Sahkan",
  title: "Sila sahkan untuk meneruskan"
};
const backup$b = {
  check: {
    checking: "Memeriksa backup...",
    confirmTitle: "Semak Backup",
    notOK: "Backup TIDAK sepadan dengan wallet.",
    ok: "Backup sepadan dengan wallet.",
    password: {
      label: "Kata laluan pemulihan",
      placeholder: "Kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    success: "Backup berjaya disahkan",
    title: "Semak Backup"
  },
  create: {
    alreadyExists: "Anda sudah mempunyai backup yang sah. Adakah anda ingin menciptanya kembali?",
    fail: "TIDAK BERJAYA membuat backup!",
    info: "Sila masukkan kata laluan pemulihan dari wallet terkini untuk pengesahan",
    name: {
      label: "Nama backup",
      placeholder: "Sila memberi nama backup"
    },
    password: {
      label: "Kata Laluan Pemulihan",
      placeholder: "Sila masukkan kata laluan pemulihan anda"
    },
    title: "Buat Backup",
    verificationFailed: "Kata laluan pemulihan TIDAK sesuai dompet terkini. Backup telah dibuat. Sila gunakan 'Semak Backup' untuk mengesahkan kembali password pemulihan anda."
  },
  description: "Pilih <strong>fail backup wallet</strong>",
  insert: "Sila masukkan kad micro SD untuk mengurus backup.",
  insertButton: "Saya telah memasukkan kad micro SD",
  list: "Telah jumpa <strong>backup berikut</strong> pada kad SD ini:",
  noBackups: "Tiada backup pada kad microSD ini.",
  restore: {
    confirmTitle: "Memulihkan Backup",
    error: {
      e200: "SD card tidak dijumpai",
      general: "Ralat memulihkan sandaran"
    },
    password: {
      label: "Kata laluan pemulihan atau kata laluan pemulihan tersembunyi",
      placeholder: "Kata laluan pemulihan",
      repeatPlaceholder: "Ulangi kata laluan pemulihan",
      showLabel: "Kata laluan pemulihan"
    },
    restoring: "Memulihkan backup...",
    selectedBackup: "<strong>{{backupName}}</strong> dicipta pada {{createdDateTime}} akan dipulihkan.",
    title: "Memulihkan",
    understand: "Saya faham bahawa kata laluan pemulihan yang salah akan membuat dompet yang berbeza"
  },
  showMnemonic: {
    description: "Anda akan diberikan 24 perkataan pemulihan, yang membentuk sandaran dompet anda. Tulis mereka di atas kertas.\n\n<strong>Jangan menyimpannya secara digital atau mengambil gambar.</strong>\n\n<strong>Jangan mengucapkannya dengan lantang.</strong>\n\n<strong>Sandaran ini tidak dilindungi kata laluan.</strong>\n\nSelepas itu, anda akan diminta mengesahkan setiap perkataan.",
    title: "Tunjukkan perkataan pemulihan",
    warning: "<strong>Jangan sekali-kali berkongsi kata-kata pemulihan anda dengan sesiapa pun.</strong> Perkataan pemulihan anda memberikan akses penuh kepada dompet anda. Jika seseorang meminta anda untuk kata-kata pemulihan anda, ia adalah penipu, jangan kongsikannya!"
  },
  title: "Urus Backup"
};
const bb02Bootloader$b = {
  abort: "Jangan naik taraf - Kembali",
  abort_noUpgrade: "Bawa saya balik",
  advanced: {
    label: "Tetapan lanjutan",
    toggleShowFirmwareHash: "Tunjukkan hash firmware setiap kali pada permulaan"
  },
  flipscreen: "Putar skrin",
  orientation: "Orientasi peranti salah?",
  success: "Naik taraf berjaya! Meneruskan dalam {{rebootSeconds}} detik...",
  success_install: "Pemasangan berjaya! Meneruskan dalam {{rebootSeconds}} detik..."
};
const bitbox$b = {
  error: {
    e10000: "Kata laluan peranti terkini salah",
    e10001: "Gagal mengganti kata laluan peranti",
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e112: "Kata laluan peranti tersembunyi tidak boleh sama dengan kata laluan peranti utama."
  }
};
const bitbox02Interact$b = {
  confirmDate: "Sahkan tarikh hari ini pada BitBox02 anda.",
  confirmDateText: "Tarikh ini akan digunakan untuk membuat sandaran anda.",
  confirmName: "Sahkan nama pada BitBox02",
  confirmWords: "Tuliskan {{amount}} perkataan pemulihan daripada BitBox02 anda",
  confirmWordsText: "Selepas itu BitBox02 meminta anda mengesahkan setiap perkataan untuk mengesahkan bahawa sandaran adalah betul.",
  followInstructions: "Sila ikuti arahan pada BitBox02 anda.",
  followInstructionsMnemonic: "Ikuti arahan pada BitBox02 anda untuk memasukkan perkataan pemulihan dari sandaran dan pulihkan dompet anda.",
  followInstructionsMnemonicTitle: "Pulihkan dari perkataan pemulihan"
};
const bitbox02Settings$b = {
  deviceName: {
    current: "Nama peranti semasa",
    error: "Nama peranti tidak dapat ditetapkan",
    error_104: "Mengesahkan nama peranti telah digugurkan pada peranti.",
    input: "Nama BitBox02",
    placeholder: "Nama peranti baharu",
    title: "Tetapkan Nama BitBox02"
  },
  gotoStartupSettings: {
    description: "Ini akan but semula BitBox02 anda dan masukkan tetapan permulaan.",
    title: "Ini akan me-reboot BitBox02 anda dan masuk ke dalam tetapan permulaan semula."
  }
};
const bitbox02Wizard$b = {
  advanced: {
    button: "Pilihan lanjutan",
    outOfDate: "Perisian tegar sudah lapuk untuk ciri ini",
    seed12WordInfo: "Sila ambil perhatian bahawa bilangan perkataan tidak boleh diubah selepas mencipta dompet.",
    seed12WordLabel: "Buat 12 perkataan dan bukannya benih 24 perkataan",
    seed12WordText: "Secara lalai, BitBox02 menggunakan benih 24 perkataan. Kedua-dua panjang benih adalah selamat daripada paksaan kasar dalam amalan. Sesetengah pengguna mungkin lebih suka kemudahan benih 12 perkataan sebaliknya.",
    skipSDCardLabel: "Langkau sandaran kad microSD dan tulis perkataan pemulihan sebaliknya",
    skipSDCardText: "Anda sentiasa mempunyai pilihan untuk membuat sandaran kad microSD atau menulis perkataan pemulihan anda selepas persediaan. Ini boleh dilakukan dari tetapan.",
    title: "Pilihan sandaran lanjutan"
  },
  attestationFailed: "Pengesahan peranti gagal. BitBox anda mungkin palsu atau terkompromi. Syiling di BitBox02 mungkin berisiko hilang. Sila hubungi support@bitbox.swiss dengan segera.",
  backup: {
    point1: "Pilih backup pada kad microSD",
    point2: "Tetapkan kata laluan untuk peranti anda",
    restoreText: "Ok, mari kita pulihkan backup!",
    text1: "Hebat, kata laluan BitBox02 anda sudah ditetapkan dan wallet dibuat. Kini tiba masanya untuk membuat backup pertama anda. Sila pastikan kad microSD anda dimasukkan ke dalam BitBox02 anda dan teruskan.",
    text2: "Sila ikuti arahan pada skrin pada peranti anda untuk membuat backup.",
    text3: "Selepas backup anda dicipta, sila tarik keluar kad microSD dan simpan itu di <strong>lokasi selamat</strong>. Kandungan kad microSD tidak dilindungi kata laluan. Jangan sekali-kali memasukkannya ke peranti lain selain BitBox02 anda.",
    userConfirmation1: "Saya harus menyimpan sandaran saya di lokasi yang selamat.",
    userConfirmation2: "Sandaran saya tidak dilindungi dengan kata laluan. Siapa saja yang mempunyai akses kepadanya dapat mengakses dompet saya.",
    userConfirmation3: "Jika saya kehilangan atau merosakkan BitBox02 saya, satu-satunya cara untuk memulihkan dana saya adalah dengan memulihkan daripada sandaran saya.",
    userConfirmation4: "Jika saya kehilangan atau merusakkan kedua-dua sandaran dan BitBox02 saya, maka dana saya akan hilang.",
    userConfirmation5: "Saya sepatutnya tidak memasukkan sandaran kad microSD saya ke dalam komputer, telefon, pencetak atau sebarang peranti selain daripada BitBox02.",
    userConfirmation5mnemonic: "Saya tidak sepatutnya meletakkan perkataan pemulihan saya dalam komputer, telefon, pencetak atau mana-mana peranti selain daripada BitBox02."
  },
  create: {
    button: "Beri Nama dan Teruskan",
    info: "Inilah langkah-langkah asas yang akan anda ambil untuk menyediakan BitBox anda: ",
    inputTitle: "Nama Wallet",
    point1: "Tetapkan nama untuk peranti anda",
    point2: "Tetapkan kata laluan untuk peranti anda",
    point3: "Buat backup",
    text: "Ok, mari buat dompet baru!"
  },
  createBackupAborted: "Membuat sandaran dihentikan.",
  createBackupFailed: "Gagal membuat sandaran, cuba lagi.",
  initialize: {
    passwordText: "Sekarang mari kita tetapkan kata laluan untuk peranti anda. Gunakan kawalan pada BitBox anda untuk memasukkan dan memilih kata laluan.",
    passwordTitle: "Tetapkan kata laluan untuk BitBox anda",
    text: "Berjaya berpasangan dengan BitBox02 anda! Sekarang mari kita inisialisasi peranti anda. Mulailah dengan memilih untuk membuat wallet baru, atau untuk memulihkan wallet dari backup yang sudah ada. <strong>Sila pastikan anda mempunyai kad microSD yang sudah dimasukkan dalam BitBox02 anda</strong>",
    tip: "Sebelum meneruskan, sangat disyorkan supaya anda meneruskan di persekitaran yang selamat.",
    title: "Inisialisasi BitBox anda"
  },
  insertSDCard: "<strong>Sila pastikan anda mempunyai kad microSD yang dimasukkan ke dalam BitBox02 anda.</strong>",
  noPasswordMatch: "Kata laluan tidak sepadan, sila cuba lagi.",
  pairing: {
    failed: "Pasangan tidak berjaya disahkan. Sila tancap ulang BitBox02 anda.",
    paired: "Anda telah mengesahkan pada peranti anda bahawa kod sepadan. Jika ini betul, anda boleh meneruskan dengan mengklik butang di bawah.",
    title: "Sahkan Kod Pasangan",
    unpaired: "BitBox02 baru telah dikesan. Sila sahkan bahawa kod berikut sepadan dengan apa yang ditunjukkan pada peranti anda. Jika kod itu sepadan, sentuh di bawah tanda semak pada BitBox02 anda dan kemudian klik butang di bawah untuk meneruskan."
  },
  restoreFromMnemonic: {
    e104: "Pemulihan daripada perkataan pemulihan telah dibatalkan.",
    failed: "Pemulihan daripada perkataan pemulihan gagal, sila cuba lagi."
  },
  stepBackup: {
    beforeProceed: "Sebelum meneruskan, sila baca pertimbangan keselamatan berikut:",
    createBackup: "Anda kini akan membuat sandaran pada kad microSD anda.",
    createBackupMnemonic: "Kini, anda akan dapat menulis perkataan pemulihan."
  },
  stepBackupSuccess: {
    fundsSafe: "Untuk memastikan dana anda selamat, sila ingat perkara berikut:",
    title: "Sandaran Dipulihkan!"
  },
  stepConnected: {
    unlock: "Masukkan kata laluan BitBox02 untuk membuka kunci."
  },
  stepCreate: {
    description: "Nama ini digunakan sebagai nama peranti dan untuk sandaran.",
    nameLabel: "Nama BitBox02",
    namePlaceholder: "BitBox02 Saya",
    title: "Pilih nama BitBox02",
    toastMicroSD: "Sila masukkan kad microSD anda ke dalam BitBox02 anda yang akan digunakan untuk menyimpan sandaran dompet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Sila keluarkan kad microSD dari BitBox02 anda dan simpan di tempat yang selamat.",
    storeMnemonic: "Sila simpan perkataan pemulihan anda di lokasi yang selamat",
    success: "Anda telah berjaya membuat sandaran anda."
  },
  stepInsertSD: {
    insertSDCard: "Sila masukkan kad mikroSD ke dalam BitBox02 anda untuk meneruskan.",
    insertSDcardTitle: "Masukkan kad mikroSD"
  },
  stepPassword: {
    e104: "Menetapkan kata laluan telah dibatalkan.",
    title: "Tetapkan kata laluan BitBox02",
    useControls: "Gunakan kawalan pada BitBox02 anda untuk menetapkan kata laluan."
  },
  stepUninitialized: {
    create: "Saya mahu menyiapkan BitBox02 baru",
    restore: "Saya mahu memulihkan dompet saya daripada sandaran.",
    restoreMicroSD: "Pulihkan daripada kad microSD",
    restoreMnemonic: "Pulihkan daripada perkataan pemulihan",
    title: "Sediakan BitBox02 anda"
  },
  success: {
    text: "Hooray! BitBox02 anda kini siap untuk digunakan.\n\nUntuk maklumat lanjut mengenai cara menggunakan aplikasi BitBox, sila gunakan panduan dalam aplikasi dengan mengklik tanda tanya di sudut kanan atas.",
    title: "Anda sudah bersedia untuk pergi!"
  }
};
const bitsurance$5 = {
  dashboard: {
    active: "Polisi insurans aktif",
    button: "Insuranskan akaun baharu",
    canceled: "Dibatalkan",
    coverage: "Liputan maksimum",
    inactive: "Tidak aktif",
    processing: "Memproses",
    refused: "enggan",
    supportLink: "Urus kontrak",
    title: "Akaun yang diinsuranskan",
    waitpayment: "Menunggu pembayaran"
  },
  detect: {
    button: "Semak insurans sedia ada",
    insured: "Akaun yang diinsuranskan dikesan:",
    notInsured: "Tiada akaun yang diinsuranskan dikesan. Jika anda pasti anda mempunyai akaun yang diinsuranskan, sila pastikan anda mempunyai dompet yang betul disambungkan.",
    text: "Jika anda sudah mendaftar dengan Bitsurance, BitBoxApp boleh menyegerakkan perlindungan insurans sedia ada anda secara automatik.",
    title: "Sudah diinsuranskan?"
  },
  insure: {
    button: "Semak ketersediaan dan harga",
    faq: "Baca lebih lanjut mengenai Soalan Lazim Bitsurance",
    listItem1: "rompakan",
    listItem2: "Peras ugut (cth., serangan sepana $5)",
    listItem3: "Kemusnahan akibat kebakaran, air atau bencana alam",
    month: "bulan",
    text: "Insuranskan BitBox02 anda dan bitcoin bernilai sehingga €100,000 terhadap",
    text2: "Pelan insurans bermula pada €30/tahun (€2.50/bulan). Anda boleh mengetahui lebih lanjut tentang Bitsurance dan tawaran insurans tepat mereka di",
    text3: "Kini tersedia di Jerman, dengan lebih banyak wilayah untuk diikuti.",
    title: "Bermula"
  },
  intro: {
    link: "Laman web Bitsurance",
    text1: "BitBox berfungsi dengan Bitsurance untuk menambah lapisan perlindungan tambahan untuk bitcoin anda. Walaupun BitBox02 memastikan dana anda selamat, Bitsurance melindungi ancaman di rumah yang tidak boleh dikurangkan dengan teknologi sahaja, seperti pecah rumah, peras ugut atau pemusnahan dompet perkakasan itu sendiri."
  },
  terms: {
    link: "Dasar Privasi Bitsurance",
    text1: "Bitsurance ialah perkhidmatan pihak ketiga yang bebas. Untuk pertanyaan mengenai tawaran dan tuntutan insurans mereka, sila hubungi Bitsurance secara terus.",
    text2: "Insurans kini tersedia di Jerman, dengan lebih banyak wilayah untuk diikuti.",
    text3: "Perlindungan Bitcoin maksimum yang tersedia pada masa ini ialah €100,000 setiap orang. Jumlah yang lebih tinggi dirancang untuk masa hadapan.",
    text4: "Maklumat peribadi dan kunci awam lanjutan (extended public key) akaun anda yang diinsuranskan adalah sebahagian daripada polisi insurans dan akan dikongsi dengan Bitsurance dan pembekal insurans.",
    text5: "Untuk maklumat lanjut tentang privasi, sila rujuk"
  },
  title: "Insurans"
};
const bitsuranceAccount$5 = {
  errorNoXpub: "Ralat: Tidak dapat mendapatkan xpub daripada akaun.",
  noAccount: "Tiada akaun yang boleh diinsuranskan.",
  select: "Pilih akaun",
  title: "Insurans"
};
const blink$b = {
  button: "Berkedip"
};
const bootloader$b = {
  button: "Naik taraf Firmware sekarang",
  button_install: "Pasang firmware sekarang",
  progress: "Menaiktaraf: {{progress}}%",
  progress_install: "Memasang: {{progress}}%",
  success: "Naik taraf berjaya! Sila pasang ulang peranti. Kali ini, jangan sentuh butang."
};
const button$g = {
  abort: "Tinggalkan",
  back: "Kembali",
  buy: "Beli",
  changepin: "Ubah kata laluan peranti",
  check: "Semak Backup",
  "continue": "Teruskan",
  copy: "Menyalin",
  create: "Buat",
  dismiss: "Batalkan",
  done: "Selesai",
  download: "Muat turun",
  hiddenwallet: "Buat wallet tersembunyi",
  next: "Berikut",
  ok: "OK",
  previous: "Sebelumnya",
  receive: "Terima",
  restore: "Memulihkan",
  select: "Pilih",
  send: "Hantar",
  unlock: "Buka",
  update: "Kemas kini",
  upgrade: "Naik taraf"
};
const buy$7 = {
  exchange: {
    bankTransfer: "Transfer bank",
    bestDeal: "Tawaran terbaik",
    creditCard: "Kad kredit",
    fast: "Cepat",
    fee: "bayaran",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Pemindahan bank: {{fee}}%",
          creditDebitCard: "Kad kredit/debit: {{fee}}%",
          learnMore: "Ketahui lebih lanjut tentang Moonpay",
          title: "Bayaran"
        },
        fullCurrenciesList: "Lihat senarai penuh mata wang di sini",
        payment: {
          asteriskText: "* Tidak tersedia untuk penduduk AS",
          bankTransfer: "Transfer bank*",
          bankTransferDetails: {
            pix: "PIX (transaksi BR di Brasil sahaja)",
            sepa: "SEPA dan SEPA Instant (transaksi EUR di negara-negara SEPA sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          creditDebitCard: "Kad kredit/debit",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa dan Maestro"
          },
          learnMore: "Lihat butiran lanjut tentang kaedah pembayaran",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong semua mata wang fiat utama: USD, EUR, CHF dan lain-lain."
      },
      pocket: {
        fees: {
          info: "Transfer bank: {{fee}}%",
          title: "Bayaran"
        },
        learnMore: "Ketahui lebih lanjut tentang Pocket",
        payment: {
          bankTransfer: "Transfer bank",
          bankTransferDetails: {
            sepa: "SEPA dan SEPA Segera (urus niaga EUR di negara SEPA sahaja)",
            sic: "Swiss Interbank Clearing (transaksi CHF di CH/LI sahaja)",
            uk: "UK Faster Payments (transaksi GBP di UK sahaja)"
          },
          bankTransferReccuring: "Bagaimana cara menyiapkan pembelian berkala dengan standing order?",
          title: "Cara bayaran"
        },
        supportedCurrencies: "Menyokong mata wang Eropah: EUR, GBP dan CHF.",
        verification: {
          info: "Hanya memerlukan pengesahan identiti melebihi ambang harian dan tahunan.",
          link: "Cari ambang semasa di sini",
          title: "Pengesahan identiti"
        }
      },
      region: {
        title: "Pilih wilayah akaun bank anda didaftarkan untuk melihat pilihan yang tersedia untuk anda."
      }
    },
    noExchanges: "Maaf, tiada pertukaran tersedia di rantau ini.",
    region: "Wilayah",
    selectRegion: "Tidak dinyatakan",
    title: "Beli {{name}}"
  },
  info: {
    "continue": "Setuju dan teruskan",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "Kami bekerjasama dengan MoonPay untuk menawarkan anda cara yang lancar untuk membeli {{name}} terus dalam BitBoxApp. Ia hanya beberapa klik.",
        "MoonPay ialah platform yang memudahkan dan cepat untuk membeli {{name}} di lebih 160+ negara."
      ],
      payment: {
        details: "Anda boleh beli {{name}} serta-merta melalui MoonPay dengan kaedah pembayaran berikut. Pesanan kad kredit atau debit adalah segera dan mudah, tetapi lebih mahal disebabkan peningkatan risiko caj balik. Kami mengesyorkan menggunakan pilihan pindahan bank untuk jumlah yang lebih besar. Yuran minimum ialah 4 USD/EUR atau setara.",
        footnote: "Sila ambil perhatian bahawa kadar pertukaran MoonPay boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
        table: {
          "1_description": "Yuran terendah, boleh mengambil masa sehingga 3 hari bekerja",
          "1_method": "Pindahan bank (SEPA)",
          "2_description": "Yuran yang lebih tinggi tetapi cepat dan segera",
          "2_method": "Kad kredit & debit",
          description: "Penerangan",
          fee: "Yuran",
          method: "Kaedah"
        },
        title: "Kaedah pembayaran dan yuran"
      },
      privacyPolicy: "Dasar privasi MoonPay",
      protection: {
        description: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana masuk dianggap seperti transaksi biasa. MoonPay perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
        descriptionGeneric: "BitBoxApp tidak mengumpul sebarang data semasa membeli {{name}}, dana yang masuk dianggap seperti transaksi biasa. Bagaimanapun pertukaran rakan kongsi perlu mengumpul beberapa maklumat untuk beroperasi. Sila rujuk dasar privasi masing-masing untuk melihat dengan lebih terperinci cara data dikendalikan.",
        title: "Perlindungan Data"
      },
      security: {
        description: "Apabila anda membeli {{name}} melalui MoonPay, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        descriptionGeneric: "Apabila anda membeli {{name}} melalui pertukaran rakan kongsi, anda menggunakan perkhidmatan luaran. Perkhidmatan ini berada di luar skop model ancaman keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran tempat perisian BitBoxApp dijalankan.",
        link: 'Model "security threat"',
        title: "Model security"
      },
      title: ""
    },
    next: "Seterusnya",
    selectLabel: "Pilih akaun anda",
    selectPlaceholder: "Pilih syiling",
    skip: "Jangan tunjukkan lagi",
    title: "Beli {{name}}"
  },
  pocket: {
    data: {
      link: "Dasar privasi poket",
      p1: "BitBoxApp tidak mengumpul sebarang data semasa membeli bitcoin, dana masuk dianggap seperti transaksi biasa. Pocket perlu mengumpul beberapa data peribadi untuk beroperasi. Dasar Privasi mereka menerangkan secara terperinci cara data tersebut dikendalikan.",
      title: "Perlindungan Data"
    },
    kyc: {
      link: "Baca Soalan Lazim Poket",
      p1: "Pocket cuba mengekalkan KYC pada tahap minimum. Untuk pembelian di bawah 950 EUR (1000 CHF) sehari, tiada dokumen tambahan diperlukan. Untuk pembelian melebihi jumlah ini, anda perlu menjadualkan panggilan dengan Pocket untuk melengkapkan proses KYC/AML yang diperlukan.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Anda boleh membeli bitcoin serta-merta dengan Pocket melalui pindahan bank SEPA. Yuran adalah 1.5% dan bitcoin didepositkan ke BitBox anda secepat mungkin selepas Pocket menerima pindahan bank (biasanya dalam hari yang sama).",
      p2: "Sila ambil perhatian bahawa kadar pertukaran Pocket boleh berbeza daripada yang digunakan dalam BitBoxApp, menghasilkan jumlah yang sedikit berbeza.",
      title: "Kaedah pembayaran dan yuran"
    },
    previousTransactions: "Sejarah transaksi akaun ini tidak kosong. Berkongsi akaun ini akan menjadikan semua urus niaga masa lalu dan masa depannya kelihatan untuk Pocket. Teruskan juga?",
    security: {
      link: "Model ancaman keselamatan BitBox02",
      p1: "Apabila anda membeli bitcoin melalui Pocket, anda menggunakan perkhidmatan luaran. Perkhidmatan ini di luar skop model Ancaman Keselamatan BitBox02 dan bergantung pada keselamatan dan keselamatan persekitaran yang dijalankan oleh perisian BitBoxApp. Walau bagaimanapun, kami bekerjasama untuk meningkatkan keselamatan dengan menggunakan mekanisme pengesahan dua faktor untuk mengesahkan alamat anda menerima ke.",
      title: "Model keselamatan"
    },
    usedAddress: "Alamat {{address}} telah digunakan, sila mulakan semula dengan alamat baharu.",
    verifyBitBox02: "Sila sahkan bahawa alamat yang anda terima melalui e-mel sepadan dengan alamat yang dipaparkan pada Bitbox anda. Jika boleh, anda harus membuka e-mel pada peranti kedua untuk keselamatan yang lebih baik.",
    welcome: {
      p1: "Kami bekerjasama dengan Pocket untuk menawarkan anda cara yang lancar untuk membeli bitcoin terus dalam BitBoxApp. Ia hanya beberapa klik.",
      p2: "Pocket ialah platform Switzerland yang menjadikannya cepat dan mudah untuk membeli bitcoin di kebanyakan Eropah (di mana-mana sahaja di mana pemindahan bank SEPA disokong).",
      p3: "Dengan Pocket, anda juga boleh melakukan pembelian biasa melalui pesanan bank tetap, jadi anda boleh DCA (purata kos dolar) dengan mudah.",
      title: "Selamat datang ke kedai sehenti anda untuk membeli bitcoin"
    }
  },
  title: "Beli {{name}}"
};
const changePin$b = {
  newTitle: "Kata laluan peranti baru",
  oldLabel: "Kata laluan peranti terkini"
};
const chart$7 = {
  dataMissing: "Mengumpul data sejarah... nantikan.",
  dataOldTimestamp: "Pengemaskinian kadar pertukaran sejarah. Carta tidak memaparkan data selepas {{time}}.",
  dataUpdating: "mengemas kini data…",
  filter: {
    all: "Semua",
    month: "Bulan",
    week: "Minggu",
    year: "Tahun"
  }
};
const checkSDcard$b = "memeriksa kad micro SD";
const clickHere$b = "Tekan di sini.";
const confirm$d = {
  abortInfo: "Sentuh untuk ",
  abortInfoRedText: "tinggalkan",
  approveInfo: "Tahan 4 detik untuk ",
  approveInfoGreenText: "sahkan",
  info: "Pada BitBox anda",
  infoWhenPaired: "Mula-mula pada telefon mudah alih yang dipasangkan dan kemudian BitBox anda"
};
const confirmOnDevice$b = "Sila sahkan pada peranti anda.";
const connectKeystore$6 = {
  promptNoName: "Sila sambungkan BitBox02 anda untuk meneruskan",
  promptWithName: 'Sila sambungkan BitBox02 anda bernama "{{name}}" bersambung'
};
const darkmode$6 = {
  toggle: "Mod gelap"
};
const device$b = {
  appUpradeRequired: "BitBox anda tidak sesuai dengan aplikasi desktop ini. Sila muat turun dan pasang versi terkini.",
  keystoreConnected: "Wallet bersambung"
};
const deviceLock$b = {
  button: "Membolehkan Pengesahan Dua Langkah (2FA)",
  condition1: "Adakah anda mempunyai backup?",
  condition2: "Apakah pengesahan aplikasi mudah alih berfungsi?",
  condition3: "2FA MENYAHAKTIFKAN backup dan pemasangan aplikasi. Peranti mesti DITETAPKAN SEMULA untuk keluar dari 2FA!",
  confirm: "Membolehkan Pengesahan Dua Langkah (2FA)",
  title: "Membolehkan Pengesahan Dua Langkah (2FA)"
};
const deviceSettings$b = {
  backups: {
    manageBackups: {
      description: "Cipta atau sahkan sandaran kad microSD anda."
    },
    showRecoveryWords: {
      description: "Tunjukkan dan sahkan perkataan pemulihan."
    },
    title: "Sandaran"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp menyemak sama ada peranti anda adalah tulen."
    },
    deviceName: {
      description: "Tukar nama peranti anda."
    },
    rootFingerprint: {
      description: "Root fingerprint ialah pengecam unik untuk dompet yang sedang digunakan. Root fingerpri boleh membantu anda membezakan antara dompet yang berbeza jika anda menggunakan frasa laluan."
    },
    securechip: {
      description: "Model cip selamat."
    },
    title: "Maklumat peranti"
  },
  expert: {
    factoryReset: {
      description: "Tetapkan semula peranti anda kepada tetapan kilang. Ini memadamkan dompet daripada BitBox02 anda!",
      title: "Tetapan semula kilang"
    },
    goToStartupSettings: {
      description: "Masukkan pemuat but BitBox02. Anda boleh mendayakan cincang perisian tegar dari sini."
    },
    passphrase: {
      description: "Dayakan atau lumpuhkan ciri frasa laluan.",
      title: "Ungkapan laluan"
    }
  },
  firmware: {
    firmwareVersion: "Versi Perisian Tegar",
    newVersion: {
      label: "Versi yang tersedia"
    },
    title: "Firmware",
    upToDate: "Peranti anda adalah yang terkini",
    upgradeAvailable: "Peningkatan baharu tersedia",
    version: {
      label: "Versi"
    }
  },
  hardware: {
    attestation: {
      "false": "Semakan ketulenan gagal",
      label: "Semakan ketulenan",
      "true": "BitBox02 anda adalah sahih"
    },
    sdcard: {
      "false": "Belum dimasukkan",
      label: "Kad micro SD",
      "true": "Telah dimasukkan"
    },
    securechip: "Cip selamat",
    title: "Hardware"
  },
  loading: "Mengambil maklumat peranti ...",
  pairing: {
    lock: {
      "false": "dinyahaktifkan",
      label: "Pengesahan Dua Langkah (2FA)",
      "true": "Diaktifkan"
    },
    mobile: {
      "false": "Ditutup",
      label: "Aplikasi Mudah Alih",
      "true": "Buka"
    },
    status: {
      "false": "Belum dipasangkan",
      label: "Status",
      "true": "Dipasangkan"
    },
    title: "Memasang"
  },
  secrets: {
    manageBackups: "Urus Backup",
    title: "Rahsia"
  }
};
const deviceTampered$b = "Apakah BitBox anda dibekalkan dengan kata laluan pemulihan? Jika ya, hentikan proses persediaan dan hubungi sokongan segera. Shift tidak akan memberikan anda dompet siap pakai atau membuat cadangan kata laluan.";
const dialog$c = {
  cancel: "Batal",
  confirm: "Sahkan",
  confirmTitle: "Pengesahan"
};
const error$7 = {
  accountAlreadyExists: "Akaun sudah wujud.",
  accountLimitReached: "Tidak boleh menambah akaun. Bilangan maksimum akaun untuk syiling ini telah dicapai.",
  aoppCallback: "Terdapat ralat menghantar alamat kepada {{host}}.",
  aoppInvalidRequest: "Invalid request.",
  aoppNoAccounts: "Tiada akaun tersedia.",
  aoppSigningAborted: "Permintaan pemilikan alamat dibatalkan.",
  aoppUnknown: "Ralat tidak diketahui berlaku.",
  aoppUnsupportedAsset: "Aset tidak disokong.",
  aoppUnsupportedFormat: "Tiada akaun tersedia yang menyokong format alamat yang diminta.",
  aoppUnsupportedKeystore: "Peranti yang disambungkan tidak boleh menandatangani mesej untuk aset ini.",
  aoppVersion: "Versi tidak diketahui.",
  wrongKeystore: "Dompet salah disambungkan. Sila pastikan anda memasukkan peranti yang betul yang sepadan dengan akaun ini.",
  wrongKeystore2: " Jika anda menggunakan frasa laluan pilihan, pastikan anda telah memasukkan frasa laluan yang betul untuk akaun tersebut."
};
const fiat$d = {
  "default": "tetapan standard",
  setDefault: "Tetapkan {{code}} sebagai tetapan standard",
  title: "Mata wang"
};
const footer$d = {
  appVersion: "Versi App:"
};
const generic$7 = {
  enabled_false: "Dinyahaktifkan",
  enabled_true: "Diaktifkan"
};
const genericError$b = "Kesalahan muncul. Sekiranya anda melihat sebarang masalah, sila mulakan semula aplikasi.";
const goal$b = {
  buttons: {
    create: "Buat wallet baru",
    restore: "Pulihkan wallet dari backup"
  },
  paragraph: "Sila pilih salah satu pilihan berikut:",
  step: {
    "1": {
      title: "Maklumat Keselamatan"
    },
    "2": {
      description: "Tetapkan kata laluan peranti",
      title: "Peranti"
    },
    "3-create": {
      description: "Buat wallet baru",
      title: "Wallet"
    },
    "3-restore": {
      description: "dari backup",
      title: "Memulihkan"
    },
    "4-create": {
      title: "Ringkasan"
    },
    "4-restore": {
      title: "Ringkasan"
    }
  }
};
const guide$c = {
  accountDescription: {
    text: "Ini adalah gambaran keseluruhan akaun anda. Ia menunjukkan transaksi masuk dan keluar. Baki dipaparkan untuk setiap akaun secara berasingan. Rujuk panduan dalam tetapan untuk mengetahui lebih lanjut mengenai jenis akaun yang berlainan.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountFiat: {
    text: "Ya, anda boleh mengklik ticker mana sahaja untuk berputar melalui beberapa mata wang fiat. Anda juga boleh menukar senarai mata wang dalam tetapan.",
    title: "Bolehkah saya memaparkan kadar penukaran lain?"
  },
  accountIncomingBalance: {
    text: "Jumlah yang akan masuk dan akan dipindahkan kepada anda tetapi belum disahkan oleh rangkaian.",
    title: "Apakah maksud akan masuk?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Setiap xpub terikat dengan "Jenis" yang ditunjukkan: sama ada "Segwit Asli (bech32)", "Segwit Terbungkus" atau "Taproot" (Bitcoin sahaja). Ini adalah jenis skrip yang digunakan oleh {{coinName}}. BitBoxApp menggabungkannya, menyokong berbilang jenis skrip dalam akaun yang sama. Kerana setiap jenis skrip memberikan xpub yang berbeza, terdapat berbilang xpub bagi setiap akaun.\n\nJika anda menerima secara konsisten pada alamat lalai (Native Segwit), anda hanya memerlukan xpub "bech32". Walau bagaimanapun, jika anda turut menerima dana untuk "Wrapped Segwit" atau "Taproot", anda juga perlu menggunakan kunci awam lanjutan "Wrapped Segwit" dan "Taproot".',
      title: "Mengapa terdapat banyak xpub?"
    },
    privacy: {
      text: "Untuk akaun khusus ini, kunci awam lanjutan mendedahkan keseluruhan sejarah kewangan, baki akaun anda dan semua urus niaga masa hadapan. Tetapi xpub tidak membenarkan sesiapa membelanjakan syiling anda.\n\nJika anda memberikan xpub kepada seseorang, anda harus sedar bahawa orang atau syarikat ini boleh melihat semua transaksi lain akaun yang sama. Oleh itu, adalah idea yang baik untuk menggunakan akaun itu hanya untuk tujuan ini dan menyimpan dana lain dalam akaun yang berbeza.",
      title: "Adakah saya perlu merahsiakan xpub saya?"
    },
    verify: {
      text: "Ya, adalah idea yang baik untuk menyemak semula xpub anda. Jika orang lain akan menjana alamat terima daripada xpub ini untuk menghantar wang kepada anda, ini amat penting. Anda perlu mengesahkannya pada peranti untuk memastikan bahawa xpub ini kepunyaan anda; jika tidak, semua dana boleh pergi ke alamat yang salah.",
      title: "Adakah saya perlu mengesahkan xpub pada peranti?"
    },
    xpub: {
      text: "Public Key Lanjutan adalah kunci akar yang mana semua alamat penerima sebuah akaun diperoleh.\nIa disediakan di sini untuk kegunaan lanjutan dan saling kendalian dengan wallet yang hanya boleh dilihat sahaja, seperti Electrum atau Sentinel.",
      title: "Apa itu Public Key Lanjutan?"
    }
  },
  accountRates: {
    text: "Kadar pertukaran dikemas kini setiap minit oleh CoinGecko.",
    title: "Kadar mana yang digunakan?"
  },
  accountReload: {
    text: "Semua maklumat transaksi dikemas kini secara automatik.",
    title: "Bagaimanakah saya dapat memuatkan semula sejarah transaksi?"
  },
  accountSendDisabled: {
    text: "Butang 'Hantar' diaktifkan apabila baki anda tidak kosong.",
    title: "Mengapa saya tidak dapat menghantar sebarang {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Jumlah keseluruhan ialah jumlah semua akaun crypto anda. Kadar pertukaran diperoleh daripada coingecko.com.\n\nNota: Jika anda menggunakan MyEtherWallet untuk token yang tidak disokong dalam BitBoxApp, ia tidak akan dimasukkan dalam jumlah yang dipaparkan.",
    title: "Bagaimanakah jumlah keseluruhan dikira?"
  },
  accountSummaryDescription: {
    text: "Di sini anda boleh melihat prestasi portfolio anda dari semasa ke semasa. Ringkasan akaun crypto individu anda dipaparkan di bawah carta.",
    title: "Apa yang dipaparkan di sini?"
  },
  accountTransactionAttributesBTC: {
    text: "Saiz maya: Digunakan untuk menentukan yuran rangkaian. Anda telah berjaya menyimpan yuran jika ia lebih kecil daripada saiz transaksi.\nSaiz: Saiz transaksi yang sebenarnya dalam bait apabila disirikan mengikuti blockchan yang mendasarinya.\nBerat: Diperkenalkan dengan Segwit, itu adalah metrik baru untuk menilai saiz transaksi dan blok. Setiap bait saksi yang dipisahkan dianggap sebagai satu, semua yang lain sebagai empat unit berat. Dibandingkan satu megabyte dalam saiz sebenarnya, had saiz blok kini adalah empat juta unit berat.",
    title: "Butiran transaksi yang berkaitan dengan Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: "Pengesahan: Apabila transaksi anda disiarkan buat kali pertama, ia tidak akan disahkan terlebih dahulu. Anda perlu menunggu untuk dimasukkan ke dalam blok oleh pelombong, selepas itu ia akan mempunyai 1 pengesahan. Setiap blok yang disiarkan di rangkaian selepas itu akan menambah pengesahan lain ke transaksi anda. Secara umum pedagang dan pelaku rangkaian lain hanya akan menerima transaksi dengan pengesahan 3-6 sebelum mempertimbangkan transaksi sebagai selesai.\nID Transaksi: Nombor pengenalan unik yang boleh digunakan untuk mencari transaksi dalam blok explorer.\nYuran: Pelombong dibayar yuran transaksi sebagai insentif untuk memasukkan transaksi di blok-blok yang mereka laksanakan. Untuk mengetahui lebih lanjut, klik pada butang hantar.",
    title: "Apa makna daripada maklumat yang ditunjukkan dalam butiran transaksi?"
  },
  accountTransactionConfirmation: {
    text: "Ini adalah transaksi yang telah disiarkan ke rangkaian dan sedang menunggu untuk disahkan.",
    title: "Apa itu transaksi yang tertunda?"
  },
  accountTransactionLabel: {
    text: "Ia adalah alamat di mana anda menerima syiling atau menghantar syiling itu. Satu alamat menyandi bagaimana (dan dengan demikian oleh siapa) syiling dapat dibelanjakan.",
    title: "Alamat mana yang dipaparkan untuk setiap transaksi?"
  },
  accountTransactionTime: {
    text: "Masa daripada transaksi yang telah disahkan di blokchain.",
    title: "Masa mana yang dipaparkan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Setiap syiling boleh mempunyai maksimum lima akaun.",
      title: "Berapa banyak akaun yang boleh saya buat?"
    },
    howtoAddTokens: {
      text: 'Token yang menggunakan standard ERC20 terikat pada akaun Ethereum tertentu. Untuk mendayakan atau melumpuhkan token tertentu, buka skrin "Urus akaun", kembangkan akaun Ethereum anda dan hidupkan atau matikan token yang dikehendaki.',
      title: "Bagaimanakah saya boleh menambah token tambahan?"
    },
    moveFunds: {
      text: "ya. Tetapi kerana akaun adalah bebas, anda perlu menghantar dana anda menggunakan transaksi biasa.",
      title: "Bolehkah saya memindahkan dana antara akaun?"
    },
    recoverAccounts: {
      text: "ya. BitBoxApp mencipta akaun menggunakan piawaian yang mantap yang serasi dengan kebanyakan dompet crypto lain.",
      title: "Bolehkah saya memulihkan akaun saya dengan dompet lain?"
    },
    whatAreAccounts: {
      text: "Dompet anda boleh mengurus berbilang akaun syiling yang sama. Akaun berguna apabila anda ingin mengasingkan dana.",
      title: "Apakah akaun?"
    },
    whatIsRememberWallet: {
      text: 'Mendayakan "Ingat dompet" membolehkan anda melihat akaun untuk dompet ini dalam BitBoxApp walaupun apabila BitBox02 tidak dipalamkan. Ini membolehkan anda menyemak baki dan portfolio anda pada bila-bila masa anda mahu. BitBox02 masih perlu dipalamkan dan dibuka kuncinya untuk menghantar atau menerima syiling.\n\nMelumpuhkan "Ingat dompet" memerlukan anda memasukkan BitBox02 (atau dompet frasa laluan) masing-masing untuk melihat akaun tersebut dalam BitBoxApp.',
      title: 'Apa yang berlaku apabila saya mendayakan/lumpuhkan "Ingat dompet"?'
    },
    whyIsThisUseful: {
      text: 'Akaun bagus untuk mengurus dana untuk orang atau tujuan yang berbeza kerana ia dipisahkan. Anda juga boleh berkongsi "kunci awam lanjutan" akaun tanpa mendedahkan apa-apa tentang akaun anda yang lain. Ini membolehkan anda berulang kali menerima dana tanpa menggunakan semula alamat, seperti menerima gaji anda atau kerap membeli kripto.',
      title: "Mengapa ini berguna?"
    }
  },
  appendix: {
    link: "Hubungi kami!",
    text: "Soalan lain?"
  },
  backups: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda. Ia juga boleh digunakan untuk mengesahkan bahawa anda masih mempunyai kata laluan pemulihan yang betul. Anda dapat menyemak kata laluan pemulihan utama atau tersembunyi anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak, tetapi kata laluan pemulihan diperlukan untuk memperoleh wallet dari benih yang disimpan.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    howOften: {
      text: "Cadangan dibuat secara automatik apabila dompet baru dibuat. Anda hanya perlu membuat backup baru jika kad micro SD anda hilang atau rosak, atau jika anda mahu menggunakan lebih daripada satu kad micro SD sebagai backup.\nAnda tidak perlu membuat backup baru selepas aktiviti transaksi. Semua data transaksi anda dapat diciptakan oleh backup tunggal anda yang dijana secara automatik untuk anda.",
      title: "Berapa kerap saya perlu membuat backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad micro SD. Benih bersama-sama dengan kata laluan pemulihan menjana dompet anda.",
      title: "Apa itu backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Semak Backup' membolehkan anda mengesahkan bahawa anda mempunyai backup kerja yang sesuai dengan dompet semasa anda.",
      title: "Apa itu 'Semak Backup'?"
    },
    encrypt: {
      text: "Tidak. Sila simpan kad SD mikro dengan selamat, kerana ia mengandung benih yang tidak disenarai untuk memulihkan dompet anda.",
      title: "Bolehkah saya menyulitkan backup?"
    },
    whatIsABackup: {
      text: "Ia adalah salinan benih pada kad microSD.",
      title: "Apakah backup itu?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Apabila 2FA dihidupkan, semua transaksi perlu diluluskan pada telefon mudah alih yang dipasangkan untuk membelanjakan duit syiling. Di bawah tudung, nombor guna tunggal yang disulitkan dihantar ke aplikasi mudah alih, disahsulitkan di sana, dan kembali ke BitBox dengan menekan butang Terima. Komunikasi dengan peranti ini dilakukan melalui saluran antara telefon mudah alih dan aplikasi desktop ini yang ditubuhkan semasa berpasangan.\n\nPastikan anda telah membackup wallet anda dan pasangkan aplikasi mudah alih sebelum menghidupkan 2FA. Setelah dihidupkan, slot micro SD dan pasangan aplikasi mudah alih akan dimatikan. Mereka boleh diaktifkan semula dengan menetapkan semula BitBox, yang mana akan menghapuskan peranti tersebut.",
      title: "Bagaimanakah Pengesahan Dua Langkah (2FA) berfungsi?"
    },
    disable2FA: {
      text: "Untuk mematikan 2FA, anda perlu menetapkan semula BitBox anda dan kemudian memulihkan wallet dari backupnya. Pastikan anda masih mempunyai kad micro SD dengan backup dan bahawa anda masih ingat kata laluan pemulihan anda. Kemudian tekan 'Tetapkan semula Peranti'. Lalu tetapkan kata laluan peranti baru dan pilih 'Atau Pulihkan Backup'. Pilih backup yang telah anda buat dari wallet, klik 'Pulihkan' dan masukkan kata laluan pemulihan yang anda gunakan semasa membuat dompet.",
      title: "Bagaimanakah saya dapat mematikan Pengesahan Dua Langkah (2FA)?"
    },
    ejectBitbox: {
      text: "Anda boleh mencabut BitBox bila-bila masa tanpa perlu mengklik ikon 'Selamat Lepaskan Perkakasan' terlebih dahulu.",
      title: "Bagaimana saya dapat menarik keluar BitBox?"
    },
    ejectSD: {
      text: "Anda dapat menyingkirkan micro SD kad dari BitBox kapanpun selama anda tidak menciptakan atau memulihkan sebuah backup",
      title: "Bagaimana saya dapat mengeluarkan kad micro SD?"
    },
    hiddenWallet: {
      text: "Ia adalah wallet kedua pada peranti yang sama yang dilindungi oleh kata laluan peranti dan kata laluan pemulihan yang berlainan, yang boleh anda gunakan untuk tujuan penafian yang munasabah. Dikeranakan penggunaan benih backup yang sama untuk wallet biasa dan tersembunyi anda, tiada tambahan backup diperlukan.",
      title: "Apa itu wallet tersembunyi?"
    },
    legacyHiddenWallet: {
      text: "Mula-mula klik butang di bawah (tersedia jika BitBox dikunci dengan kata laluan peranti utama dan 2FA dinyahdayakan), kemudian pasang kembali Bitbox dan buka dengan kata laluan peranti tersembunyi anda.",
      title: "Bagaimanakah saya dapat mengakses legacy wallet tersembunyi?"
    },
    pairing: {
      text: "Selepas memuat turun aplikasi mudah alih kami untuk iOS atau Android, anda dapat menubuhkan saluran selamat antara aplikasi mudah alih dan aplikasi ini dengan mengimbas kod QR yang dipaparkan. Setelah diimbas, ikut arahan dalam aplikasi mudah alih.",
      title: "Bagaimana memasangkan dengan selamat telefon anda"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Sila semak tapak web Bitsurance dan Soalan Lazim mereka untuk butiran lanjut.",
      title: "Soalan tambahan?"
    },
    privacy: {
      link: {
        text: "Dasar privasi Bitsurance"
      },
      text: "Seperti mana-mana polisi insurans biasa, ia mengandungi nama penuh dan alamat anda, dan menyatakan objek yang diinsuranskan (ditakrifkan oleh kunci awam lanjutan akaun Bitcoin yang diinsuranskan). Data ini diserahkan kepada Bitsurance secara langsung dan tidak dikongsi dengan Shift Crypto. Sila rujuk dasar privasi Bitsurance untuk mendapatkan maklumat lanjut",
      title: "Apakah maklumat peribadi yang diperlukan untuk insurans?"
    },
    renew: {
      text: 'Insurans akan diperbaharui secara automatik untuk tahun hadapan. Anda boleh membatalkan pembaharuan pada bila-bila masa dengan mengklik pada "Urus kontrak" dalam BitBoxApp, yang membawa anda ke portal pelanggan Bitsurance.',
      title: "Bagaimanakah saya boleh memperbaharui atau membatalkan insurans?"
    },
    status: {
      text: 'Akaun yang berjaya diinsuranskan ditandakan dengan lencana hijau "diinsuranskan" di penjuru kiri sebelah atas pada setiap halaman akaun Bitcoin. Dalam bahagian "Insurans", anda boleh melihat gambaran keseluruhan semua akaun Bitcoin yang diinsuranskan dan status insurans semasa mereka.',
      title: "Bolehkah saya menyemak status akaun yang diinsuranskan?"
    },
    what: {
      text: 'Setiap kontrak insurans Bitcoin meliputi akaun dompet tertentu. Anda boleh menginsuranskan berbilang akaun dengan mengambil beberapa polisi insurans. Akaun yang diinsuranskan terhad kepada menggunakan alamat Bitcoin "Segwit Asli".',
      title: "Adakah keseluruhan dompet BitBox diinsuranskan?"
    },
    who: {
      text: "Insurans ditawarkan oleh Bitsurance, broker insurans yang dibina oleh bitcoiners. Mereka bekerja dengan insurans ELEMENT untuk menyediakan insurans Bitcoin. Kedua-dua syarikat berpangkalan di Jerman.",
      title: "Siapa yang menginsuranskan bitcoin saya?"
    },
    why: {
      text: "Bitsurance melindungi beberapa risiko penjagaan diri yang tidak dalam skop walaupun dompet paling selamat, mis. pecah rumah, peras ugut atau pemusnahan dompet. Ia adalah keputusan peribadi anda jika anda memerlukan perlindungan insurans untuk risiko ini.",
      title: "Adakah saya memerlukan insurans Bitcoin?"
    }
  },
  cointracking: {
    text: 'Klik butang "Eksport" dan buka folder muat turun di mana anda akan menemui eksport CSV. Kemudian klik pautan di bawah, muat naik fail CSV BitBox anda dan import data untuk menggunakannya untuk pengurus portfolio CoinTracking anda dan untuk membuat laporan cukai anda.',
    title: "Bagaimana untuk mengimport urus niaga saya ke dalam CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Baca lebih lanjut mengenai semakan ketulenan"
      },
      text: "BitBoxApp menjalankan semakan pengesahan pada BitBox02 untuk mengesahkan sama ada peranti itu tulen. Semakan dilakukan secara tempatan dan tidak bersambung ke mana-mana pelayan.",
      title: "Bagaimanakah semakan ketulenan berfungsi?"
    },
    name: {
      text: "Ini adalah nama dompet dan sandaran anda. Nama itu digunakan untuk sandaran masa hadapan dan boleh digunakan untuk membantu membezakan antara dompet yang berbeza. Ia boleh ditukar pada bila-bila masa tetapi ambil perhatian bahawa sandaran yang dibuat sebelum perubahan masih akan menggunakan nama sebelumnya.",
      title: "Apakah nama BitBox02 digunakan?"
    },
    "secure-chip": {
      link: {
        text: "Baca lebih lanjut mengenai cip selamat"
      },
      text: "Maklumat ini menunjukkan nombor model cip selamat, cip paling terkini ialah ATECC608B dengan ciri keselamatan yang dipertingkatkan berbanding model lama.",
      title: "Mengapa tunjukkan model cip selamat?"
    }
  },
  receive: {
    address: {
      text: "Berikan kepada orang lain untuk menghantarkan anda beberapa syiling.\n(Sentiasa sahkan alamat secara mandiri, contohnya dengan panggilan telefon.)",
      title: "Apa yang boleh saya lakukan dengan alamat?"
    },
    addressChange: {
      text: "Selepas alamat digunakan dalam sebuah transaksi, alamat baru akan ditambah ke senarai untuk menggantikannya. Setiap masa terdapat 20 alamat yang belum digunakan dalam senarai.",
      title: "Bila alamat berubah?"
    },
    addressFormats: {
      text: "Secara lalai, jenis alamat ialah Segwit Asli. Jenis alamat ini digunakan secara meluas oleh dompet/pertukaran lain dan memberikan anda kadar yuran terbaik untuk transaksi harian. Walau bagaimanapun, anda juga boleh memilih untuk menghantar kepada Taproot (Bitcoin sahaja), yang merupakan jenis alamat terbaharu, tetapi mungkin belum disokong secara meluas lagi. Sebagai alternatif, jika anda menghadapi masalah menghantar kepada Native Segwit (jenis lalai), anda boleh cuba bertukar kepada jenis alamat Wrapped Segwit yang lebih lama yang mungkin serasi dengan lebih banyak dompet/pertukaran.",
      title: 'Bilakah saya menggunakan "Tukar jenis alamat"?'
    },
    howVerify: {
      text: "Klik ikon BitBox pada bar sisi di sebelah kiri dan lihat bahagian Pemasangan. Panduan akan dikemas kini dan anda boleh terus mengikuti arahan dari sana.",
      title: "Bagaimana saya dapat mengesahkan alamat dengan selamat?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda menghantar syiling ke alamat BitBox anda, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menerima?"
    },
    why20: {
      text: 'Semasa permulaan apl menjana alamat yang diperoleh daripada benih anda untuk melihat sama ada mereka telah menerima dana. Memandangkan apl boleh menjana bilangan alamat yang hampir tidak terhingga, ia boleh menghabiskan masa bertahun-tahun untuk menentukan baki. Untuk mengehadkan carian ini ia berhenti selepas ia melihat 20 alamat yang tidak pernah menerima dana. Ini ialah "had jurang" dan 20 ialah piawaian de-facto walaupun bilangannya adalah sewenang-wenangnya. Ini ialah 20 alamat yang boleh anda pilih.',
      title: "Mengapa hanya 20 alamat?"
    },
    whyMany: {
      text: "Untuk sebab-sebab privasi dan keselamatan, anda tidak perlu menyerahkan alamat yang sama dua kali. Klik 'Berikut' untuk mendapatkan alamat baru untuk tujuan yang berbeza. Anda boleh menjana hingga 20 alamat dalam satu masa. Semua alamat diperoleh dari biji backup tunggal anda. (Bayangkan alamat seperti nombor invois.)",
      title: "Mengapa terdapat banyak alamat?"
    },
    whyVerify: {
      text: "Salah satu sebab untuk membeli wallet hardware seperti BitBox ialah anda tidak boleh mempercayai komputer anda kerana permukaan serangan yang besar. Oleh itu, anda tidak boleh mempercayai komputer anda untuk menjana dan memaparkan alamat yang sahih. Butang untuk mengesahkan alamat dengan selamat membuat BitBox menghantar alamat ke telefon mudah alih yang dipasangkan, dari mana anda juga boleh mengimbas dan mengesahkan kod QR.",
      title: "Mengapa saya perlu mengesahkan alamat dengan selamat?"
    }
  },
  send: {
    change: {
      text: "Perubahan akan dikembalikan ke alamat Taproot jika anda mempunyai sekurang-kurangnya satu Taproot UTXO. Jika anda menggunakan kawalan syiling, perubahan akan dikembalikan ke alamat Taproot jika terdapat sekurang-kurangnya satu Taproot UTXO antara UTXO yang dipilih. Dalam semua kes lain, perubahan dikembalikan ke alamat Segwit Asli.",
      title: "Bagaimanakah output perubahan ditentukan?"
    },
    fee: {
      text: "Yuran ini didasarkan pada saiz data transaksi dan bukan jumlahnya. Sasaran yuran dikira oleh algoritma pengiraan yuran Bitcoin Core untuk setiap keutamaan rangkaian yang anda pilih. Mereka ditunjukkan jika mereka mempunyai nilai yang berbeza dari sasaran di bawah.\nEkonomi: 24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)\nRendah: 12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)\nNormal: 6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)\nTinggi: 2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)\n(Blok mengambil purata sepuluh minit untuk Bitcoin (2.5 minit di Litecoin) untuk melombong dan beban rangkaian mungkin berbeza-beza untuk tempoh di atas.)",
      title: "Bagaimanakah bayaran ditentukan?"
    },
    plugout: {
      text: "Tidak, sebaik sahaja anda membuat transaksi, anda tidak perlu membiarkan BitBox anda dipalamkan. Anda bebas untuk memutuskan sambungan BitBox anda.",
      title: "Adakah saya perlu membiarkan BitBox saya dipalamkan semasa menghantar?"
    },
    priority: {
      text: "Semakin tinggi yuran yang anda bayar, semakin cepat transaksi anda disahkan oleh rangkaian.",
      title: "Apa itu keutamaan rangkaian?"
    },
    revert: {
      text: "Selepas sebuah transaksi ditandatangani dan dihantar (disiarkan ke rangkaian), ia tidak dapat lagi dipulangkan. Periksa ulang transaksi (termasuk yurannya) dengan teliti sebelum menandatangani!\nSekiranya anda tahu sang penerima dan dia akan menghantar jumlah yang sama (dikurang yuran transaksi) kepada anda, anda boleh menghantar kepadanya alamat penerima yang baru.",
      title: "Dapatkah saya memulangkan transaksi?"
    },
    whyFee: {
      text: "Transaksi bersaing untuk disahkan oleh penambang. Pelombong memilih transaksi untuk dimasukkan ke dalam blok yang berdasarkan yuran mereka.\nMiners mengundi untuk sejarah transaksi. Dikeranakan tidak ada pihak ketiga yang dipercayai untuk menguatkuasakan satu undi bagi setiap orang (yang merupakan titik keseluruhan blok), penambang mengundi transaksi dengan mengorbankan sumber yang mahal seperti daya pengkomputeran. Sebagai hadiah untuk kerja mereka, mereka boleh menuntut duit syiling yang baru dibuat dan yuran dari semua transaksi yang mereka sertakan.",
      title: "Mengapa ada yuran rangkaian?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Jika anda berhasrat untuk menyambung ke nod anda sahaja apabila anda berada di rangkaian yang sama (cth. wifi rumah anda), maka menggunakan komunikasi rangkaian biasa sudah memadai.\nDalam kes ini, adalah dinasihatkan bahawa pelayan Electrum anda menyediakan sijil TLS untuk menyulitkan komunikasi.\nJika anda berhasrat untuk menyambung ke nod anda dari mana-mana sahaja, menggunakan Tor ialah pilihan yang lebih baik. Tiada sijil TLS diperlukan dalam kes itu.",
      title: "Sekiranya saya menggunakan clearnet TCP, TLS atau Tor?"
    },
    instructions: {
      link: {
        text: "Panduan untuk menyambungkan nod anda"
      },
      text: "Untuk tutorial penuh, sila lawati panduan kami:",
      title: "Bagaimanakah cara saya menyambungkan BitBoxApp saya ke nod penuh saya sendiri?"
    },
    options: {
      text: "Terdapat pelbagai pilihan untuk menjalankan nod anda sendiri seperti membeli peranti siap, membina sendiri atau menjalankan Bitcoin Core.\nJika anda ingin menyambungkan BitBoxApp anda ke nod anda, pastikan ia menjalankan pelayan Electrum. Ini ialah program khusus yang membolehkan apl dompet berkomunikasi dengan nod penuh anda.\nPilihan yang disokong termasuk Electrs, Electrum Personal Server (EPS) atau Bitcoin Wallet Tracker (BTW).",
      title: "Apakah pilihan yang ada untuk menjalankan nod?"
    },
    tor: {
      text: "Tor adalah singkatan kepada 'The Onion Router', iaitu perisian percuma dan sumber terbuka yang menawarkan banyak faedah privasi dan amat berguna apabila menggunakan Bitcoin.\nJika anda berhasrat untuk menyambung ke nod anda melalui Tor, pastikan Tor dipasang pada komputer anda dan kemudian dayakan Proksi Tor dalam tetapan BitBoxApp.\nPada kebanyakan sistem pengendalian terdapat dua cara untuk menjalankan Tor:\n1. Pelayar Tor: muat turun dan buka Pelayar Tor. Ini akan membolehkan BitBoxApp menyambung ke rangkaian Tor dengan menetapkan port 9150 dalam tetapan proksi Tor.\n2. Perkhidmatan latar belakang Tor: pasang daemon Tor, yang sentiasa berjalan di latar belakang. BitBoxApp kemudiannya boleh menyambung dengan menetapkan port 9050 dalam tetapan proksi Tor.",
      title: "Apakah Tor, proksi Tor dan port mana yang harus saya gunakan?"
    },
    what: {
      text: "Adalah mungkin untuk menggerakkan dompet anda dengan nod penuh anda sendiri sebagai ganti menggunakan server Shift.",
      title: "Apakah ini?"
    },
    why: {
      text: "Menjalankan nod anda sendiri tidak perlu tetapi meningkatkan privasi dan mengurangkan keperluan untuk mempercayai orang lain.\nPertama, ini bermakna anda menggunakan Bitcoin secara lebih peribadi kerana BitBoxApp tidak akan menyambung ke pelayan kami untuk mengambil sejarah transaksi anda; sebaliknya ia akan mengambil maklumat tersebut daripada nod anda sendiri.\nKedua, menjalankan nod anda sendiri bermakna nod anda mengesahkan semua transaksi itu sendiri, memastikan peraturan konsensus dikuatkuasakan.",
      title: "Mengapa saya perlu menjalankan nod saya sendiri?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (pendek kata 'sat') ialah unit terkecil Bitcoin. Satu Satoshi ialah seratus juta bitcoin (0.00000001 BTC). Ia dinamakan sempena pencipta Bitcoin, Satoshi Nakamoto.",
      title: "Apa itu Satoshi?"
    },
    servers: {
      text: "Aplikasi ini berkomunikasi dengan server Shift Crypto untuk memeriksa kemas kini, memuat transaksi, dan menghantar maklumat ke aplikasi mudah alih yang telah dipasangkan.\nDi samping itu, ia mengambil kadar pertukaran terkini dari CoinGecko. (Penukaran dikira secara tempatan, tiada wang anda yang dihantar)",
      title: "Server mana yang digunakan aplikasi ini?"
    }
  },
  title: "Panduan",
  toggle: {
    close: "Tutup panduan",
    open: "Panduan"
  },
  trackingModePortfolioChart: {
    text: "Pada desktop, tuding kursor pada carta. Pada mudah alih, pegang jari anda pada carta dan seret secara mendatar.",
    title: "Bagaimana untuk melihat nilai sejarah pada carta?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Anda perlu menetapkan semula peranti dan memulihkan wallet dari backup dengan menggunakan kata laluan pemulihan.",
      title: "Apa yang perlu saya lakukan jika saya lupa kata laluan peranti?"
    },
    reset: {
      text: "Anda telah memasukkan kata laluan peranti yang salah sebanyak 15 kali. Beberapa percubaan terakhir memerlukan sentuhan panjang pada peranti.",
      title: "Bagaimana menetapkan semula peranti?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Peranti mesti berkelip sekali apabila dimasukkan. Pastikan ia dimasukkan ke arah yang betul. Jika anda menghadapi masalah, sila hubungi kami melalui pautan di bawah.",
      title: "Peranti saya tidak diketahui"
    },
    getDevice: {
      link: {
        text: "Pesan sebuah BitBox"
      },
      text: "Anda boleh membeli BitBox di kedai online kami:",
      title: "Bagaimana saya boleh mendapatkan peranti?"
    },
    internet: {
      text: "Ya, sambungan internet diperlukan untuk menyegerakkan wallet, menghantar transaksi dan mendapatkan kadar pertukaran terkini.",
      title: "Apakah aplikasi ini memerlukan sambungan internet?"
    },
    lostDevice: {
      link: {
        text: "Pusat Backup"
      },
      text: "Anda boleh memulihkan akaun anda pada BitBox baru atau dengan pusat backup kami.",
      title: "Saya kehilangan peranti saya. Bagaimana sekarang?"
    },
    useWithoutDevice: {
      text: "Maaf, ini belum mungkin pada masa ini.",
      title: "Bolehkah saya menggunakan aplikasi tanpa peranti?"
    },
    welcome: {
      text: "Terima kasih kerana menggunakan aplikasi ini yang dibina oleh Shift Crypto dari Switzerland. Ia masih dalam versi beta dan kami menghargai apa-apa input yang anda perlu bagikan. Sila berikan maklum balas menggunakan pautan di bahagian bawah.",
      title: "Selamat datang ke aplikasi BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Jika anda menggunakan telefon/komputer baharu dengan BitBoxApp, maka anda perlu menyambung semula ke DApps. Anda kemudian akan melihat syiling anda pada dapp semula seperti biasa.",
      title: "Saya tidak melihat sambungan saya sebelum ini."
    },
    supportedNetworks: {
      text: "Pada masa ini, hanya mainnet Ethereum disokong menggunakan WalletConnect dalam BitBoxApp. Untuk menggunakan rantaian serasi EVM lain, sila gunakan dompet sambungan penyemak imbas Rabby.",
      title: "Apakah rangkaian yang disokong?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect ialah protokol komunikasi untuk aplikasi web3. Ia membolehkan anda menyambung dengan mudah ke DApps berasaskan Ethereum dan dompet web tanpa menggunakan aplikasi pihak ketiga, yang amat berguna untuk pengguna Android BitBoxApp.",
      title: "Apakah itu WalletConnect?"
    }
  }
};
const headerssync$b = {
  blocksSynced: "{{blocks}} blok telah disegerakkan"
};
const hiddenWallet$b = {
  info1HTML: "Untuk tujuan penafian yang munasabah, wallet tersembunyi boleh dibuat dengan kombinasi kata laluan pemulihan dan kata laluan peranti yang <strong> berbeza </strong>.",
  info2HTML: "Tentukan kata laluan peranti dan kata laluan pemulihan yang anda mahu kaitkan dengan wallet tersembunyi anda di bawah ini. Kata laluan peranti dan kata laluan pemulihan mestilah <strong> berbeza </strong> daripada yang anda tentukan untuk wallet utama anda.",
  passwordLabel: "Kata laluan pemulihan tersembunyi",
  passwordPlaceholder: "Sila ulangi kata laluan pemulihan tersembunyi",
  pinLabel: "Kata laluan peranti tersembunyi",
  pinRepeatLabel: "Ulangi kata laluan peranti tersembunyi",
  pinRepeatPlaceholder: "Sila ulangi kata laluan peranti tersembunyi",
  success: "Dompet tersembunyi berjaya dibuat. Pasang ulang BitBox anda untuk membuka kuncinya."
};
const initialize$b = {
  create: "Tetapkan kata laluan peranti",
  creating: "Menetapkan kata laluan peranti...",
  error: {
    e102: "Kata laluan peranti mestilah mengandung sekurang-kurangnya 4 aksara."
  },
  info: {
    description1: "Pilih kata laluan peranti anda. Ini akan digunakan untuk membuka kunci BitBox anda.",
    description2: "Anda boleh menggunakan nombor, huruf dan simbol. Kata laluan yang lebih panjang memberikan keselamatan yang lebih tinggi",
    description3: "Jika anda kehilangan kata laluan peranti, anda perlu menetapkan semula peranti anda dan memulihkan backup wallet anda.",
    subtitle: "Sekarang anda boleh menetapkan kata laluan peranti anda",
    title: "Memulakan peranti anda"
  },
  input: {
    label: "Kata laluan peranti",
    labelRepeat: "Ulangi kata laluan peranti",
    placeholderRepeat: "Sila ulangi kata laluan peranti"
  }
};
const invalidFormat$b = "Format tidak sah";
const language$c = {
  title: "Pilih Bahasa"
};
const legacyhiddenwallet$b = {
  disable: "Matikan Legacy Hidden Wallet",
  enable: "Aktifkan Legacy Hidden Wallet",
  successDisable: "Berjaya melumpuhkan legacy hidden wallet",
  successEnable: "Berjaya menyahaktifkan wallet legacy tersembunyi. Pasang semula BitBox anda dan masukkan kata laluan peranti tersembunyi untuk mengakses wallet legacy tersembunyi warisan."
};
const loading$b = "memuatkan ...";
const manageAccounts$5 = {
  accountHidden: "Akaun ini telah disembunyikan daripada akaun watch-only anda sahaja. Untuk melihatnya semula, sila pasangkan BitBox02 anda.",
  editAccount: "Sunting",
  editAccountNameTitle: "Sunting nama akaun",
  noAccounts: "tiada akaun ditemui",
  settings: {
    hideTokens: "Sembunyikan token",
    showTokens: "Tunjukkan token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Tambah dan tunjukkan/sembunyikan akaun",
  title: "Urus akaun",
  watchAccount: "Tonton akaun",
  watchAccountDescription: "Akaun ini adalah sebahagian daripada akaun watch-only anda sahaja. Anda boleh menyembunyikannya daripada akaun jam tangan anda menggunakan togol."
};
const mobile$6 = {
  usingMobileDataWarning: "Penggunaan data mudah alih: apl ini boleh memuat turun sehingga beberapa ratus megabait data pengepala blockchain selepas membuka kunci akaun. Sila sambung ke Wi-Fi untuk mengelak daripada menggunakan data mudah alih. Selepas menolaknya, mesej ini tidak akan ditunjukkan lagi."
};
const newSettings$5 = {
  about: {
    appVersion: {
      title: "Versi aplikasi"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Kunci akses kepada aplikasi dengan kunci skrin/cap jari.",
      title: "Kunci skrin"
    },
    coinControl: {
      description: "Pilih UTXO yang merupakan sebahagian daripada transaksi untuk membantu meningkatkan privasi."
    },
    customFees: {
      description: "Membolehkan anda memasukkan yuran anda sendiri semasa menghantar."
    },
    torProxy: {
      description: "Sambungkan melalui Tor untuk privasi yang lebih baik."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Mata wang tambahan ini boleh ditogol pada halaman akaun anda.",
      title: "Mata wang aktif"
    },
    darkmode: {
      description: "Lihat BitBoxApp dalam mod gelap."
    },
    defaultCurrency: {
      description: "Pilih mata wang lalai anda",
      title: "Mata wang lalai"
    },
    enableAccount: {
      description: "Melumpuhkan akaun anda bermakna ia tidak akan muncul dalam bar sisi atau portfolio. Anda sentiasa boleh mendayakannya semula dari sini. Syiling pada akaun ini tidak akan terjejas dan akan kekal selamat.",
      title: "Dayakan/lumpuhkan akaun"
    },
    hideAmounts: {
      description: "Memaparkan togol untuk menyembunyikan baki anda dan amaun untuk meningkatkan privasi anda apabila menggunakan apl di khalayak ramai.",
      hideAmounts: "Sembunyikan jumlah",
      showAmounts: "Tunjukkan jumlah",
      title: "Benarkan menyembunyikan jumlah"
    },
    language: {
      description: "Bahasa yang anda mahu BitBoxApp gunakan.",
      title: "Bahasa"
    },
    remebmerWallet: {
      name: "Ingat dompet",
      warning: "Ini akan mengeluarkan dompet anda yang diingati. Untuk melihatnya semula, anda perlu memasukkan BitBox02 untuk dompet ini. Sebarang syiling pada dompet ini tidak terjejas. Adakah anda mahu meneruskan?",
      warningTitle: "Lumpuhkan ingat dompet"
    },
    toggleSats: {
      description: "Dayakan atau lumpuhkan Satoshis."
    }
  }
};
const note$7 = {
  input: {
    description: "(pilihan)",
    placeholder: "Tambah Nota…"
  },
  title: "Catatan"
};
const notification$b = {
  newTxs_one: "{{count}} transaksi baru di: {{accountName}}",
  newTxs_other: "{{count}} transaksi baharu dalam: {{accountName}}"
};
const pairing$b = {
  aborted: {
    text: "Pemasangan telah ditinggalkan oleh aplikasi mudah alih.",
    title: "Ditinggalkan"
  },
  button: "Pasangkan Aplikasi Mudah Alih",
  confirm: "Adakah anda pasti mahu memasangkan BitBox anda? Ambil perhatian bahawa selepas itu, telefon bimbit diperlukan untuk melakukan transaksi.",
  connectOnly: {
    button: "Sambungkan aplikasi mudah alih",
    title: "Imbas dengan aplikasi mudah alih kami dengan memilih item menu 'Sambung ke aplikasi desktop baharu'"
  },
  error: {
    text: "Ada yang salah. Sila mulakan lagi.",
    title: "Ada yang salah"
  },
  pullFailed: {
    text: "Gagal menarik mesej daripada telefon bimbit anda melalui pelayan geganti. Pelayan geganti mungkin berada di luar talian, sila hubungi sokongan.",
    title: "Pull gagal"
  },
  reconnectOnly: {
    button: "Sambung semula aplikasi mudah alih"
  },
  scanningFailed: {
    text: "Mudah alih tidak berjaya mengimbas mesej. Sila cuba lagi.",
    title: "Pengimbasan Gagal"
  },
  start: {
    hideAppQRCode: "Sembunyikan QR Code",
    revealAppQRCode: "Tunjukkan QR Code",
    step1: "Jika anda tidak mempunyai aplikasi mudah alih, anda boleh mengimbas kod QR untuk Apple App Store atau Google Play Store.",
    step2: "Imbas dengan aplikasi mudah alih kami, yang anda dapati di bawah nama 'Digital Bitbox 2FA' di kedai aplikasi untuk iOS dan Android:"
  },
  started: {
    text: "Kini sila ikuti arahan dalam aplikasi mudah alih.",
    title: "Hebat"
  },
  success: {
    text: "Selamat, anda berjaya memasangkan BitBox anda dengan aplikasi mudah alih!",
    title: "Berjaya"
  },
  timeout: {
    text: "Pemasanganan ini berakhir selepas dua minit. Mula semula jika anda masih mahu memasangkan aplikasi mudah alih.",
    title: "Berakhir"
  },
  title: "Memasang telefon bimbit"
};
const passphrase$5 = {
  considerations: {
    button: "Pertimbangan sandaran",
    message: "Frasa laluan menambah lapisan perlindungan pada sandaran dompet anda (kad mikroSD atau perkataan pemulihan). Jika seseorang mempunyai akses kepada sandaran anda, mereka juga memerlukan frasa laluan untuk mengakses dompet anda.\n\nWalau bagaimanapun, ini bermakna anda perlu <strong>kedua-dua frasa laluan + sandaran dompet</strong> untuk memulihkan dompet didayakan frasa laluan anda, sekiranya BitBox02 anda hilang atau rosak. Jika anda terlupa atau kehilangan frasa laluan anda, anda akan kehilangan akses kepada semua syiling pada dompet itu.\n\nApabila menyimpan frasa laluan anda, pertimbangkan untuk meletakkannya di lokasi yang berasingan daripada sandaran anda. Dengan cara itu jika seseorang menjumpai sandaran anda, mereka juga tidak menemui frasa laluan anda.",
    title: "Pertimbangan sandaran"
  },
  disable: "Lumpuhkan frasa laluan",
  disableInfo: {
    button: "Lumpuhkan",
    message: "Selepas melumpuhkan frasa laluan, anda tidak lagi akan diminta untuk memasukkan frasa laluan selepas membuka kunci BitBox02 anda. Oleh itu, anda akan memasukkan dompet lalai anda.\n\nMana-mana syiling pada dompet frasa laluan anda masih ada pada dompet itu, namun anda tidak akan dapat mengaksesnya kerana selepas membuka kunci BitBox02 anda, anda akan membuka dompet lalai anda.\n\nUntuk mengakses dompet frasa laluan anda sekali lagi, cukup dayakan semula ciri frasa laluan dan masukkan frasa laluan yang berkaitan selepas membuka kunci BitBox02.\n\n<strong>Petua:</strong> Anda masih boleh memasukkan dompet asal anda dengan membiarkan frasa laluan kosong."
  },
  enable: "Dayakan frasa laluan",
  error: {
    e104: "Menukar tetapan frasa laluan telah digugurkan."
  },
  how: {
    button: "Macam mana rupanya",
    message: "Frasa laluan tidak berfungsi seperti kata laluan yang anda gunakan. Jika anda tersalah taip frasa laluan anda, anda tidak akan dimaklumkan. Ini adalah kerana <strong>setiap frasa laluan mencipta dompet yang berbeza, namun sah</strong>. Ini bermakna anda boleh menggunakan berbilang frasa laluan untuk seberapa banyak dompet yang anda mahukan. Tetapi setiap dompet hanya boleh diakses apabila menaip frasa laluan yang sepadan.\n\nApabila memasang BitBox02 anda, anda akan digesa untuk kata laluan peranti seperti biasa. Selepas itu, anda akan diminta untuk memasukkan frasa laluan pada peranti.\n\nSelepas memasukkan frasa laluan, anda akan ditunjukkan frasa laluan yang anda masukkan. Ini supaya anda boleh mengesahkan anda memasukkannya dengan betul.",
    title: "Bagaimanakah ia berfungsi"
  },
  intro: {
    message: "Frasa laluan menyediakan lapisan keselamatan tambahan di atas dompet anda.\nMari belajar bagaimana ia berfungsi.",
    title: "Sediakan frasa laluan"
  },
  progressDisable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>melumpuhkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  progressEnable: {
    message: "Sahkan pada BitBox anda yang anda mahu <strong>membolehkan</strong> frasa laluan pilihan.",
    title: "Sahkan pada peranti"
  },
  successDisabled: {
    message: "Ungkapan laluan pilihan <strong>berjaya didayakan</strong>!\nAnda akan diminta untuk memberikan frasa laluan mulai sekarang.",
    messageEnd: "Sila pasang semula BitBox02 sekarang.",
    title: "Ungkapan laluan didayakan"
  },
  successEnabled: {
    message: "Ungkapan laluan pilihan <strong>berjaya dilumpuhkan</strong>!\n\nAnda tidak akan diminta untuk memberikan frasa laluan lagi.",
    messageEnd: "Sila pasang semula BitBox02 anda sekarang.",
    tips: "Petua",
    tipsList: [
      "Kami cadangkan menghantar sejumlah kecil ke dompet frasa laluan terlebih dahulu. Kemudian cabut dan pasang semula BitBox02 dan masukkan kata laluan dan frasa laluan anda. Jika anda memasukkan frasa laluan dengan betul, anda sepatutnya melihat syiling dalam dompet anda.",
      "Jika anda ingin memasukkan dompet asal anda tanpa frasa laluan, anda masih boleh melakukan ini dengan memasukkan apa-apa apabila digesa untuk memasukkan frasa laluan. Atau anda boleh melumpuhkan ciri frasa laluan."
    ],
    title: "Ungkapan laluan dilumpuhkan"
  },
  summary: {
    button: "Dayakan frasa laluan",
    title: "Ringkasan",
    understand: "Saya faham cara frasa laluan berfungsi dan risiko yang berkaitan dengannya.",
    understandList: [
      "Frasa laluan ialah lapisan keselamatan tambahan di atas sandaran anda.",
      "Memasukkan frasa laluan yang berbeza akan sentiasa menghasilkan dompet yang berbeza.",
      "Untuk memulihkan dompet anda yang anda perlukan <strong>kedua-dua frasa laluan dan sandaran</strong>.",
      "Jika anda terlupa frasa laluan anda, anda tidak lagi boleh mengakses syiling anda."
    ]
  },
  what: {
    button: "Ketahui cara ini berfungsi",
    message: "Dompet dicipta (berasal) daripada nombor rawak yang sangat besar, juga dikenali sebagai benih. Benih ini dicipta apabila anda mula-mula menyediakan BitBox02 anda dan disandarkan dengan kad microSD atau perkataan pemulihan. Sesiapa sahaja yang mempunyai akses kepada benih mempunyai kawalan penuh ke atas dana pada dompet itu.\n\nFrasa laluan ialah <strong>rahsia pilihan</strong>, ditambah kepada benih. Apabila menggunakan frasa laluan, setiap frasa laluan mencipta dompet baharu berdasarkan benih + frasa laluan (rahsia pilihan). Frasa laluan boleh jadi apa-apa sahaja: huruf, perkataan, aksara khas atau malah boleh kosong. Dompet lalai sebenarnya berasal daripada benih + frasa laluan kosong.\n\nFrasa laluan adalah sebahagian daripada standard BIP39, yang bermaksud ia serasi dengan semua dompet yang menyokong standard yang sama.",
    title: "Apakah frasa laluan?"
  },
  why: {
    button: "Mengapa menggunakan frasa laluan",
    message: 'BitBox02 melindungi benih daripada pengekstrakan daripada peranti itu sendiri, tetapi sandaran (kad mikroSD atau perkataan pemulihan) memberikan akses penuh kepada dompet. Itulah sebabnya ia harus disimpan di lokasi yang selamat!\n\nMemandangkan frasa laluan mencipta dompet baharu menggunakan benih sedia ada anda, frasa laluan-dompet memerlukan kedua-dua anda <strong>sandaran DAN frasa laluan untuk memulihkan</strong>. Faedah ini ialah jika seseorang menemui sandaran anda, mereka masih memerlukan frasa laluan untuk mengakses dompet frasa laluan.\n\nSelain itu, ciri frasa laluan membolehkan anda membuat berbilang dompet pada peranti yang sama, atau "dompet tersembunyi" sebagai tambahan kepada dompet lalai.',
    title: "Mengapa menggunakan frasa laluan?"
  }
};
const password$b = {
  show: "Tunjukkan {{label}}",
  warning: {
    caps: "AMARAN: kunci caps (⇪) diaktifkan",
    paste: 'untuk menampal teks, aktifkan "SHOW {{label}}"'
  }
};
const random$c = {
  button: "Menjana Nombor Rawak",
  description: "BitBox anda telah menjana nombor rawak {{bits}}-bit berikut:"
};
const receive$d = {
  bitsuranceWarning: "Ini ialah akaun yang diinsuranskan, bermakna ia hanya boleh menerima kepada Native Segwit. Ini supaya anda tidak menerima secara tidak sengaja kepada Wrapped Segwit atau Taproot, yang tidak diinsuranskan.",
  changeScriptType: "Tukar jenis alamat",
  label: "Alamat anda",
  onlyThisCoin: {
    description: "Untuk menerima token lain, dayakannya dalam tetapan. Jika anda mendepositkan token lain, ia mungkin tidak boleh diakses.",
    warning: "Pastikan hanya menerima {{coinName}} pada alamat ini."
  },
  scriptType: {
    p2tr: "Akar Tunjang (format terbaharu)",
    p2wpkh: "Segwit asli (lalai)",
    "p2wpkh-p2sh": "Wrapped Segwit (format yang serasi)"
  },
  selectAccount: "Pilih akaun",
  showFull: "Tunjukkan dan sahkan alamat lengkap",
  taprootWarning: "Nota: Taproot ialah ciri Bitcoin baharu dan belum diterima pakai secara meluas. Dana yang diterima pada alamat Taproot mungkin tidak kelihatan dalam dompet jam tangan pihak ketiga sahaja. Banyak dompet dan pertukaran belum dapat dihantar ke alamat Taproot.",
  title: "Dapatkan syiling",
  verify: "Sahkan alamat dengan selamat",
  verifyBitBox01: "Sahkan alamat pada apl mudah alih",
  verifyBitBox02: "Sahkan alamat pada BitBox02",
  verifyInstruction: "Sila sahkan bahawa alamat berikut sepadan dengan yang dipaparkan pada peranti anda.",
  warning: {
    secureOutput: "Sila pasangkan BitBox anda dengan peranti mobile anda untuk menghidupkan pengesahan alamat selamat. Pergi ke 'Urus Peranti' pada bar sisi."
  }
};
const reset$b = {
  description: "Semua data pada peranti akan dihapus. Itu termasuk Private Key anda!",
  notReset: "Peranti BELUM ditetapkan semula.",
  title: "Tetapkan semula peranti",
  understand: "Saya mempunyai backup dan mengetahui kata laluan pemulihan saya",
  understandBB02: "Saya mempunyai sandaran yang sah"
};
const securityInformation$b = {
  create: {
    description1: "Sebelum menetapkan peranti anda, disarankan agar anda dalam persekitaran yang selamat.",
    description2: "Anda akan diminta untuk membuat dua kata laluan.",
    description3: "Yang pertama adalah <strong> kata laluan peranti </strong> yang digunakan untuk membuka peranti BitBox anda dan boleh diubah kemudian.",
    description4: "Yang kedua ialah <strong>kata laluan pemulihan</strong> yang digunakan untuk membuka wallet anda. Kata laluan ini tidak boleh diubah kemudian.",
    description5: "Wallet yang anda buat akan dibackupkan kepada fail pada kad micro SD yang disediakan. Ini boleh digunakan dalam kecemasan untuk memulihkan wang anda menggunakan <strong> kata laluan pemulihan </strong> anda.",
    title: "Maklumat Keselamatan"
  },
  restore: {
    description1: "Anda akan diminta untuk memasukkan kad micro SD yang digunakan untuk menyimpan backup.",
    description2: "Untuk memulihkan peranti, anda memerlukan kata laluan pemulihan anda.",
    description3: "Sila berhati-hati semasa memasukkan kata laluan pemulihan. Sebarang kata laluan yang anda masukkan akan membuat wallet yang sah. Jika anda memasukkan kata laluan yang salah, anda mungkin akan mendapatkan baki wallet yang tidak anda harapkan.",
    title: "Maklumat Keselamatan"
  }
};
const seed$b = {
  agreements: {
    "funds-access": "Saya TIDAK akan dapat mengakses dana saya jika saya lupa kata laluan pemulihan saya",
    "password-change": "Saya TIDAK dapat menukar kata laluan pemulihan di kemudian hari",
    "password-required": "Kata laluan pemulihan diperlukan untuk memulihkan dompet dari backup"
  },
  create: "Buat Wallet",
  creating: "Membuat dompet",
  description: "Saya faham bahawa:",
  error: {
    e102: "Kata laluan mestilah terdiri daripada sekurang-kurangnya 4 aksara.",
    e200: "Anda perlu memasukkan kad micro SD ke dalam BitBox anda untuk membuat wallet, agar backup boleh dibuat secara automatik."
  },
  info: {
    button: "Tetapkan kata laluan pemulihan sekarang",
    description1: "Masukkan kad micro SD ke dalam BitBox",
    description2: 'Pilih kata laluan pemulihan untuk wallet dan pilih "Tetapkan kata laluan pemulihan sekarang"',
    description3: "Backup ke kad micro SD dan kata laluan pemulihan anda adalah satu-satunya cara untuk mendapatkan semula wang anda, sekiranya peranti BitBox hilang atau dicuri.",
    description4: "Anda tidak dapat mengganti kata laluan pemulihan anda di kemudian hari tanpa memindahkan wang anda.",
    title: "Buat wallet baru"
  },
  password: {
    label: "Kata laluan pemulihan",
    repeatPlaceholder: "Ulangi kata laluan pemulihan"
  },
  walletName: {
    label: "Nama Wallet"
  }
};
const seedRestore$b = {
  error: {
    e200: "Untuk memulihkan wallet dari backup memerlukan kad micro SD."
  },
  info: {
    description1: 'Masukkan kad micro SD ke BitBox dan klik "Teruskan"',
    description2: 'Pilih backup pada dan klik "Simpan semula"',
    description3: "Masukkan kata laluan pemulihan",
    description4: "Anda perlu mengesahkan untuk memahami bahawa kata laluan salah akan membuat dompet yang berbeza.",
    title: "Bagaimana cara memulihkan wallet dari backup"
  }
};
const send$d = {
  abort: "Transaksi telah ditinggalkan.",
  address: {
    label: "Alamat Penerima",
    placeholder: "Masukkan alamat"
  },
  amount: {
    label: "Jumlah",
    placeholder: "Masukkan jumlah"
  },
  availableBalance: "Baki yang ada",
  button: "Tandatangan dan Hantar",
  coincontrol: {
    address: "Alamat",
    outpoint: "Outpoint",
    title: "Hantar dari Output"
  },
  confirm: {
    "selected-coins": "Syiling yang dipilih",
    title: "Sahkan Transaksi",
    total: "Jumlah"
  },
  error: {
    erc20InsufficientGasFunds: "Nampaknya anda tidak mempunyai Eter yang mencukupi untuk membayar transaksi ERC20 ini. Sila pastikan anda memegang cukup Eter dalam dompet anda",
    feeTooLow: "bayaran terlalu rendah",
    feesNotAvailable: "Tidak dapat menganggarkan bayaran",
    insufficientFunds: "Dana tidak mencukupi",
    invalidAddress: "alamat tidak sah",
    invalidAmount: "jumlah tidak sah",
    invalidData: "data tidak sah"
  },
  fee: {
    customPlaceholder: "Masukkan jumlah",
    label: "Yuran Rangkaian",
    placeholder: "Tidak tersedia"
  },
  feeTarget: {
    customLabel: "Kadar bayaran",
    customLabel_eth: "Harga gas",
    description: {
      economy: "24 blok (sekitar 4 jam untuk Bitcoin, 1 jam untuk Litecoin)",
      economy_eth: "30 minit atau kurang",
      economy_ltc: "1 jam (24 blok)",
      high: "2 blok (sekitar 20 minit untuk Bitcoin, 5 minit untuk Litecoin)",
      high_eth: "30 saat atau kurang",
      high_ltc: "5 minit (2 blok)",
      low: "12 blok (sekitar 2 jam untuk Bitcoin, 30 minit untuk Litecoin)",
      low_eth: "5 minit atau kurang",
      low_ltc: "30 minit (12 blok)",
      normal: "6 blok (sekitar 1 jam untuk Bitcoin, 15 minit untuk Litecoin)",
      normal_eth: "2 minit atau kurang",
      normal_ltc: "15 minit (6 blok)"
    },
    estimate: "Anggaran masa pengesahan:",
    label: {
      custom: "Adat",
      economy: "ekonomi",
      high: "tinggi",
      low: "rendah",
      normal: "normal"
    },
    placeholder: "Mengira bayaran anggaran ..."
  },
  maximum: "Hantar semua",
  maximumSelectedCoins: "Hantar syiling terpilih",
  noFeeTargets: "Anggaran kadar yuran tidak tersedia pada masa ini. Sila cuba sebentar lagi atau masukkan yuran tersuai.",
  priority: "Keutamaan",
  scanQR: "Imbas Kod QR",
  signprogress: {
    description: "Ini adalah transaksi yang mengandung banyak data. Untuk menandatangani transaksi dengan sepenuhnya, anda akan diminta untuk mengesahkan sebanyak {{steps}} kali.",
    label: "Kemajuan"
  },
  success: "Transaksi telah ditandatangani dan dihantar.",
  title: "Hantar syiling",
  toggleCoinControl: "Toggle Kawalan Syiling",
  transactionDetails: "Butiran transaksi"
};
const settings$c = {
  about: "Tentang aplikasi",
  accounts: "Akaun",
  advancedSettings: "Tetapan lanjutan",
  appearance: "Penampilan",
  electrum: {
    add: "Tambah server",
    "add-server": "Tambah",
    check: "Periksa",
    checkFailed: "Gagal",
    checkSuccess: "Berhasil menubuhkan sambungan ke {{host}}",
    checking: "Memeriksa",
    "download-cert": "Muat turun sijil jauh",
    "remove-server": "Hapus",
    removeConfirm: "Hapus {{server}}?",
    reset: "Tetapkan semula kepada tetapan standard",
    resetConfirm: "Apakah anda mahu menyingkirkan semua server dan memasang server standard?",
    servers: "Server",
    step1: "1",
    "step1-text": "Masukkan titik akhir.",
    step2: "2",
    "step2-text": "Masukkan sijil dari rantai sijil server. Secara alternatif, muat turun sijil jauh dan bandingkan secara visual.",
    "step2-text-tcp": "Anda boleh melangkau langkah ini jika anda tidak mahu menggunakan TLS.",
    step3: "3",
    "step3-text": "Semak sambungan dan tambahkan server.",
    step4: "4",
    "step4-text": "Mulakan semula wallet anda. Jika anda tidak menyingkirkan server standard, nod anda akan ditambah sebagai redundansi.",
    "title-btc": "Bitcoin Electrum Server",
    "title-ltc": "Litecoin Electrum Server",
    "title-tbtc": "Bitcoin Testnet Electrum Server",
    "title-tltc": "Litecoin Testnet Electrum Server"
  },
  expert: {
    coinControl: "Hidupkan kawalan syiling",
    electrum: {
      description: "Anda boleh menyambung ke nod penuh Electrum anda sendiri.",
      title: "Sambung nod penuh anda sendiri"
    },
    fee: "Dayakan yuran tersuai",
    setProxyAddress: "Tetapkan alamat proksi",
    title: "Tetapan Pakar",
    useProxy: "Dayakan proksi tor",
    useSats: "Paparkan nilai BTC dalam Satoshis"
  },
  header: {
    home: "Rumah"
  },
  info: {
    "out-of-date": "Kemas kini baharu tersedia",
    title: "info",
    "up-to-date": "Apl anda adalah terkini",
    version: "Versi Apl"
  },
  restart: "Sila mulakan semula BitBoxApp untuk perubahan berkuat kuasa.",
  services: {
    title: "Perkhidmatan"
  },
  success: "Sila cabut dan pasang kembali BitBox agar perubahan dapat berlaku.",
  title: "Tetapan"
};
const setup$b = "Menetapkan peranti";
const sidebar$c = {
  buy: "Beli kripto",
  device: "Urus Peranti",
  insurance: "Insurans",
  leave: "Tinggalkan",
  settings: "Tetapan"
};
const success$i = {
  create: {
    info1: "Dompet anda telah dibackupkan dengan selamat ke kad micro SD. Tarik keluar kad micro SD dan simpan dengan selamat.",
    info2: "Anda telah membuat kata laluan peranti yang selamat yang dapat membuka BitBox.",
    info3: "Anda telah membuat kata laluan pemulihan yang selamat untuk wallet anda yang dapat membuka wang anda dan mengembalikan backup anda.",
    summary: "Berikut adalah ringkasan dari apa yang telah anda lakukan",
    title: "Berjaya"
  },
  getstarted: "Bermula",
  restore: {
    summary: "Anda telah berjaya memulihkan wallet dari backup anda.",
    title: "Berjaya"
  }
};
const transaction$c = {
  confirmation: "Pengesahan",
  details: {
    activity: "Aktiviti",
    address: "Alamat",
    amount: "Jumlah",
    date: "Tarikh",
    fiat: "Fiat",
    fiatAmount: "Jumlah Fiat",
    fiatAtTime: "Fiat pada masa transaksi",
    status: "Status",
    title: "butiran transaksi",
    type: "taip"
  },
  explorer: "ID Transaksi",
  explorerTitle: "Buka dalam blok Explorer luaran",
  fee: "Yuran",
  fiatHistorical: "Sejarah",
  gas: "Gas",
  note: {
    edit: "Edit nota",
    save: "Simpan nota"
  },
  pending: "Transaksi Menunggu",
  size: "Saiz",
  status: {
    complete: "lengkap",
    failed: "Gagal",
    pending: "Yang belum selesai"
  },
  tx: {
    received: "Diterima kepada",
    sent: "Dihantar kepada"
  },
  vsize: "Saiz maya",
  weight: "Berat"
};
const transactions$b = {
  errorLoadTransactions: "Terdapat ralat semasa memuatkan urus niaga",
  placeholder: "Belum ada transaksi."
};
const unknownError$b = "Kesalahan yang tidak diketahui muncul: {{errorMessage}}";
const unlock$b = {
  description: "Masukkan kata laluan peranti anda untuk membuka peranti.",
  error: {
    e109_normal: "Kata laluan peranti salah. Masih ada {{remainingAttempts}} percubaan sebelum peranti diset semula.",
    e109_touch: "$t(unlock.error.e109_normal) Menahan butang sentuhan diperlukan pada log masuk berikutnya",
    e113: "Oleh kerana banyaknya percubaan masuk, menahan butang sentuhan selama 4 saat diperlukan pada log masuk berikutnya ."
  },
  input: {
    label: "Kata laluan peranti",
    placeholder: "Masukkan kata laluan peranti anda"
  },
  unlocking: "Membuka ..."
};
const upgradeFirmware$c = {
  button: "Tingkatkan firmware",
  description: "Apakah anda mahu menaik taraf Firmware dari versi {{currentVersion}} ke {{newVersion}}?",
  label: "Peningkatan firmware diperlukan untuk BitBox anda.",
  locked: "Untuk menaik taraf dari {{currentVersion}} ke {{newVersion}}, sila buat sentuhan panjang.",
  title: "Tingkatkan Firmware",
  unlocked: "Bootloader terbuka. Untuk meneruskan, sila:",
  unlocked1: "Tarik keluar dan pasang ulang BitBox anda",
  unlocked2: "LED akan menyala apabila BitBox anda terpasang kembali",
  unlocked3: "Tekan butang sentuh apabila LED menyala"
};
const walletConnect$7 = {
  connect: {
    button: "Sambung",
    dappLabel: "Masukkan alamat URI dapp",
    invalidPairingUri: "Uri gandingan tidak sah"
  },
  dashboard: {
    allSessions: "Semua sesi",
    disclaimer: "Walletconnect ialah protokol untuk menyambung ke Dapps berasaskan Ethereum. Dapps ini dijalankan oleh perkhidmatan pihak ketiga, jadi hanya sambungkan kepada dapps yang anda percayai dan pastikan anda sentiasa mengetahui perkara yang anda tandatangani semasa membuat transaksi.",
    newConnection: "Sambungan baharu",
    noConnectedSessions: "Tiada akaun disambungkan ke mana-mana dapp pada masa ini."
  },
  invalidPairingChain: "Ralat dalam meluluskan gandingan. Sila pastikan anda menggunakan salah satu rangkaian yang disokong: {{chains}}",
  pairingRequest: {
    approve: "Luluskan Sambungan",
    reject: "Tolak",
    title: "Permintaan sambungan baharu daripada"
  },
  pairingSuccess: "Dapp berjaya disambungkan. Anda boleh teruskan di laman web dapp.",
  signingRequest: {
    account: "Akaun",
    chain: "Rantai",
    dapp: "Dapp",
    data: "Data",
    dataParsingError: "Gagal menghuraikan data",
    decodeError: "Gagal menyahkod mesej",
    method: {
      sendTransaction: "Tandatangan dan hantar transaksi",
      signMessage: "Tandatangan mesej",
      signTransaction: "Tandatangani transaksi",
      signTypedData: "Tandatangani data yang ditaip"
    },
    successfullySigned: "Permintaan berjaya ditandatangani",
    walletConnectRequest: "Permintaan WalletConnect"
  },
  useNewUri: "URI ini telah digunakan untuk mencuba sambungan. Sila gunakan URI baharu.",
  walletConnect: "WalletConnect"
};
const warning$h = {
  receivePairing: "Sila pasangkan BitBox untuk membolehkan pengesahan alamat dengan selamat. Pergi ke 'Uruskan Peranti' pada bar sisi.",
  sdcard: "Pastikan kad micro SD disimpan berasingan dari BitBox, kecuali jika anda mahu mengurus backup.",
  sendPairing: "Sila pasang BitBox untuk mengesahkan butiran transaksi dengan selamat. Pergi ke 'Urus Peranti' di bar sisi."
};
const welcome$b = {
  connect: "Sambungkan BitBox02",
  getStarted: "Mari mulakan dengan memasang perisian tegar pada BitBox02 anda.",
  insertBitBox02: "Untuk BitBox02, sila ketik peranti untuk meneruskan.",
  insertDevice: "Sila sambungkan peranti anda untuk memulakan",
  title: "Selamat datang"
};
const appTranslationsMS = {
  account: account$b,
  accountInfo: accountInfo$b,
  accountSummary: accountSummary$b,
  addAccount: addAccount$c,
  aopp: aopp$5,
  app: app$b,
  auth: auth$6,
  backup: backup$b,
  bb02Bootloader: bb02Bootloader$b,
  bitbox: bitbox$b,
  bitbox02Interact: bitbox02Interact$b,
  bitbox02Settings: bitbox02Settings$b,
  bitbox02Wizard: bitbox02Wizard$b,
  bitsurance: bitsurance$5,
  bitsuranceAccount: bitsuranceAccount$5,
  blink: blink$b,
  bootloader: bootloader$b,
  button: button$g,
  buy: buy$7,
  changePin: changePin$b,
  chart: chart$7,
  checkSDcard: checkSDcard$b,
  clickHere: clickHere$b,
  confirm: confirm$d,
  confirmOnDevice: confirmOnDevice$b,
  connectKeystore: connectKeystore$6,
  darkmode: darkmode$6,
  device: device$b,
  deviceLock: deviceLock$b,
  deviceSettings: deviceSettings$b,
  deviceTampered: deviceTampered$b,
  dialog: dialog$c,
  error: error$7,
  fiat: fiat$d,
  footer: footer$d,
  generic: generic$7,
  genericError: genericError$b,
  goal: goal$b,
  guide: guide$c,
  headerssync: headerssync$b,
  hiddenWallet: hiddenWallet$b,
  initialize: initialize$b,
  invalidFormat: invalidFormat$b,
  language: language$c,
  legacyhiddenwallet: legacyhiddenwallet$b,
  loading: loading$b,
  manageAccounts: manageAccounts$5,
  mobile: mobile$6,
  newSettings: newSettings$5,
  note: note$7,
  notification: notification$b,
  pairing: pairing$b,
  passphrase: passphrase$5,
  password: password$b,
  random: random$c,
  receive: receive$d,
  reset: reset$b,
  securityInformation: securityInformation$b,
  seed: seed$b,
  seedRestore: seedRestore$b,
  send: send$d,
  settings: settings$c,
  setup: setup$b,
  sidebar: sidebar$c,
  success: success$i,
  transaction: transaction$c,
  transactions: transactions$b,
  unknownError: unknownError$b,
  unlock: unlock$b,
  upgradeFirmware: upgradeFirmware$c,
  walletConnect: walletConnect$7,
  warning: warning$h,
  welcome: welcome$b
};
const account$a = {
  disconnect: "Verbinding verbroken. Opnieuw aan het verbinden...",
  "export": "Exporteren",
  exportTransactions: "Transacties als CSV bestand naar de downloads map exporteren",
  fatalError: "Er is een onverwachte fout opgetreden",
  incoming: "Inkomende",
  initializing: "Blockchain wordt gesynchroniseerd",
  insuranceExpired: "<strong>Account niet meer verzekerd</strong>\nDe verzekering voor dit account is gewijzigd. Kijk op de verzekeringspagina voor meer informatie.",
  insured: "Verzekerde account",
  maybeProxyError: "De Tor Proxy staat ingeschakeld. Zorg ervoor dat deze correct werkt, of schakel de proxy-instelling uit.",
  reconnecting: "Verbinding verbroken, opnieuw aan het verbinden...",
  syncedAddressesCount: "{{count}} adressen gescand",
  uncoveredFunds: "Je heb coins op de volgende niet-verzekerde addressen van je <strong>{{name}}</strong> account: {{uncovered}}.\nJe account is verzekerd, maar alleen coins die via het <strong>Native Segwit</strong> adrestype ontvangen worden, zijn gedekt. Coins op een ander adrestype zijn niet gedekt, ook al zijn de adressen onderdeel van hetzelfde account.\nStuur alsjeblieft al je coins van de niet-ondersteunde adrestypes naar het <strong>Native Segwit</strong> adrestype, zodat alle coins op dit account verzekerd zijn.",
  uncoveredFundsLink: "Volg deze handleiding over hoe je je coins kunt verplaatsen.",
  warning: "Waarschuwing!"
};
const accountInfo$a = {
  address: "Adres",
  buyCTA: {
    buy: "Koop {{unit}}",
    buyCrypto: "Koop Crypto",
    information: {
      looksEmpty: "Het lijkt erop dat deze wallet leeg is.",
      start: "Begin door coins naar deze wallet te sturen, of direct vanuit de BitBoxApp te kopen."
    }
  },
  extendedPublicKey: "Uitgebreide publieke sleutel",
  label: "Accountinformatie",
  scriptType: "Script-type",
  title: "Accountinformatie",
  verify: "Verifieer op je adres",
  xpubTypeChangeBtn: {
    p2pkh: "Legacy P2PKH uitgebreide publieke sleutel weergeven",
    p2tr: "Taproot weergeven",
    p2wpkh: "Native SegWit weergeven",
    "p2wpkh-p2sh": "Oude SegWit uitgebreide publieke sleutel weergeven"
  },
  xpubTypeInfo: "Op dit moment wordt nummer {{current}} van de {{numberOfXPubs}} {{scriptType}} uitgebreide publieke sleutels weergegeven"
};
const accountSummary$a = {
  availableBalance: "Beschikbare balans",
  balance: "Balans",
  exportSummary: "Accounts als CSV bestand naar de downloads map exporteren",
  fiatBalance: "Fiat balans",
  name: "Accountnaam",
  noAccount: "Er zijn geen accounts om weer te geven",
  subtotalWithCoinName: "Totaal ({{coinName}})",
  title: "Mijn portfolio",
  total: "Totaal",
  transactionHistory: "Transactiegeschiedenis"
};
const addAccount$b = {
  chooseName: {
    nextButton: "Account toevoegen",
    step: "Account benoemen",
    title: "Geef je account een naam"
  },
  selectCoin: {
    nextButton: "Volgende",
    step: "Coin selecteren",
    title: "Cryptovaluta selecteren"
  },
  success: {
    addAnotherAccount: "Voeg een account toe",
    message: "<strong>{{accountName}}</strong> is aan je accounts toegevoegd",
    nextButton: "Klaar",
    step: "Afgerond",
    title: "Account toegevoegd"
  },
  title: "Account toevoegen"
};
const aopp$4 = {
  addressRequest: "Er wordt een ontvangstadres aangevraagd door {{host}}",
  addressRequestWithLogo: "vraagt een ontvangstadres aan",
  banner: "Adresaanvraag in behandeling",
  errorTitle: "Foutmelding tijdens adresaanvraag",
  labelAddress: "Adres",
  labelMessage: "Bericht",
  reverifyInfoText: "Adres verifiëren",
  signing: "Onderteken het bericht op je BitBox02 om door te gaan",
  success: {
    message: "Ga door op {{host}}",
    title: "Adres verzonden"
  },
  syncing: "Account aan het synchroniseren, even geduld",
  title: "Adresaanvraag"
};
const app$a = {
  upgrade: "Er is een nieuwe versie van de app beschikbaar! Upgrade nu van versie {{current}} naar {{version}}>"
};
const auth$5 = {
  authButton: "Inloggen\n",
  title: "Log in om door te gaan"
};
const backup$a = {
  check: {
    checking: "Backup aan het controleren...",
    confirmTitle: "Controleer backup",
    notOK: "De backup komt NIET overeen met de wallet",
    ok: "Backup komt overeen met de wallet",
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      showLabel: "herstelwachtwoord"
    },
    success: "Backup geverifieerd:",
    title: "Controleer backup"
  },
  create: {
    alreadyExists: "Je hebt al een valide backup. Wil je deze opnieuw maken?",
    fail: "Backup is NIET gemaakt!",
    info: "Voer het herstelwachtwoord van de huidige wallet in.",
    name: {
      label: "Backup naam",
      placeholder: "Geef de backup een naam"
    },
    password: {
      label: "Herstelwachtwoord",
      placeholder: "Voer alsjeblieft je herstelwachtwoord in"
    },
    title: "Creeër backup",
    verificationFailed: "Het herstelwachtworod komt NIET overeen met de huidige wallet. De backup is aangemaakt. Gebruik 'Check backup' om je herstelwachtwoord nogmaals te verifiëren."
  },
  description: "Selecteer <strong>wallet backup bestand</strong>",
  insert: "Voer de microSD kaart in om je backups te beheren",
  insertButton: "Ik heb de microSD kaart ingevoerd",
  list: "Jouw microSD kaart backups",
  noBackups: "Er zijn geen backups op deze microSD kaart aanwezig.",
  restore: {
    confirmTitle: "Backup herstellen",
    error: {
      e200: "microSD kaart niet gevonden",
      general: "Fout tijdens het herstellen van de backup"
    },
    password: {
      label: "Herstelwachtwoord of verborgen herstelwachtwoord",
      placeholder: "Herstelwachtwoord",
      repeatPlaceholder: "Herstelwachtwoord herhalen",
      showLabel: "Herstelwachtwoord"
    },
    restoring: "Backup aan het herstellen",
    selectedBackup: "De backup <strong>{{backupName}}</strong>, aangemaakt op {{createdDateTime}}, wordt hersteld",
    title: "Herstellen",
    understand: ""
  },
  showMnemonic: {
    description: "Je ziet zometeen de 24 herstelwoorden die de backup van je wallet vormen. Schrijf ze op papier op.\n<strong>Sla ze niet digitaal op en neem er geen foto's van</strong>\n<strong>Zeg de woorden niet hardop</strong>\n<strong>Deze backup is niet beschermd met een wachtwoord</strong>\nAchteraf word je gevraagd ieder woord te bevestigen",
    title: "Herstelwoorden tonen",
    warning: "<strong>Deel je herstelwoorden nooit, met wie dan ook!</strong> Met je herstelwoorden kan iemand volledige toegang tot je wallet krijgen. Als iemand je om je herstelwoorden vraagt, is dit vrijwel altijd een oplichter."
  },
  title: "Backups beheren"
};
const bb02Bootloader$a = {
  abort: "Terug - doe de update niet",
  abort_noUpgrade: "Breng me terug",
  advanced: {
    label: "Geavanceerde instellingen",
    toggleShowFirmwareHash: "Toon de firmware hash iedere keer tijdens het opstarten"
  },
  flipscreen: "Scherm omkeren",
  orientation: "Tekst op je BitBox ondersteboven?",
  success: "Upgrade voltooid! Verder in {{rebootSeconds}} seconden...",
  success_install: "Installatie voltooid! Verder in {{rebootSeconds}} seconden..."
};
const bitbox$a = {
  error: {
    e10000: "Huidig apparaatwachtwoord incorrect",
    e10001: "Het veranderen van het wachtwoord is niet gelukt",
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e112: "Het verborgen apparaatwachtwoord kan niet hetzelfde zijn als het hoofdwachtwoord."
  }
};
const bitbox02Interact$a = {
  confirmDate: "Bevestig de huidige datum op je BitBox02",
  confirmDateText: "Deze datum wordt gebruikt om je backup te maken.",
  confirmName: "Bevestig naam op je BitBox02",
  confirmWords: "Schrijf de {{amount}}",
  confirmWordsText: "Hierna vraagt de BitBox je om ieder woord te bevestigen zodat je zeker weet dat de backup correct is.",
  followInstructions: "Volg de instructies op je BitBox02",
  followInstructionsMnemonic: "Volg de instructies op je BitBox02 om te herstellen met je herstelwoorden.",
  followInstructionsMnemonicTitle: "Met herstelwoorden herstellen"
};
const bitbox02Settings$a = {
  deviceName: {
    current: "Huidige naam",
    error: "Het is niet gelukt de naam in te stellen.",
    error_104: "Het instellen van de naam is afgebroken door de BitBox.",
    input: "BitBox02 naam",
    placeholder: "Nieuwe naam",
    title: "BitBox02 naam instellen"
  },
  gotoStartupSettings: {
    description: "",
    title: "Ga naar opstartinstellingen"
  }
};
const bitbox02Wizard$a = {
  advanced: {
    button: "Geavanceerde opties",
    outOfDate: "Deze optie is niet beschikbaar voor deze firmware-versie",
    seed12WordInfo: "De hoeveelheid woorden kan niet veranderd worden nadat je de wallet hebt aangemaakt.",
    seed12WordLabel: "Seed met 12 ipv 24 herstelwoorden aanmaken",
    seed12WordText: 'De BitBox maakt standaard een backup met 24 herstelwoorden aan. Backups met zowel 12 als 24 woorden zijn in de praktijk veilig tegen "brute force" aanvallen. ',
    skipSDCardLabel: "MicroSD backup overslaan en herstelwoorden opschrijven",
    skipSDCardText: "Je hebt altijd de mogelijkheid om via de instellingen alsnog een microSD- of herstelwoord-backup te maken.",
    title: "Geavanceerde backup-opties"
  },
  attestationFailed: "Validiteitscheck niet gehaald. Dit kan gebeuren als de app opnieuw wordt opgestart terwijl de BitBox wachtte op input. Probeer de BitBox opnieuw te verbinden. Neem contact op met support@bitbox.swiss als dit probleem blijft voortbestaan.",
  backup: {
    point1: "Selecteer een backup op de microSD kaart",
    point2: "Stel een wachtwoord in voor je apparaat",
    restoreText: "Ok, laten we een backup herstellen!",
    text1: "Je BitBox02 wachtwoord is ingesteld en je wallet is aangemaakt. Nu gaan we je eerste backup instellen. Zorg dat je microSD kaart is ingevoerd in de BitBox02 en ga verder.",
    text2: "Volg de instructies op je BitBox om een backup te maken.",
    text3: "Verwijder de microSD kaart en sla hem op in een <strong>veilige locatie</strong> nadat je backup is aangemaakt. De inhoud van de microSD kaart is niet beveiligd met een wachtwoord. Voer je microSD kaart nooit in een ander apparaat dan je BitBox02 in.",
    userConfirmation1: "Ik zal mijn backup in een veilige locatie opslaan.",
    userConfirmation2: "Mijn backup is niet beveiligd met een wachtwoord. Iedereen die er toegang tot heeft, heeft toegang tot mijn wallet.",
    userConfirmation3: "Als ik mijn BitBox02 verlies of beschadig, is de backup mijn enige manier om weer toegang tot mijn wallet te krijgen.",
    userConfirmation4: "Als ik mijn BitBox02 én mijn backup verlies of beschadig, is mijn wallet permanent verloren.",
    userConfirmation5: "Ik moet mijn microSD kaart niet in een computer, telefoon, printer of ieder ander apparaat dan een BitBox02 invoeren.",
    userConfirmation5mnemonic: "Ik snap dat ik mijn herstelwoorden NOOIT in een computer, telefoon, printer of ieder ander apparaat dat geen BitBox is moet invoeren"
  },
  create: {
    button: "",
    info: "Dit zijn de stappen die je gaat nemen om je BitBox in te stellen:",
    inputTitle: "Walletnaam",
    point1: "Geef je BitBox een naam",
    point2: "Stel een wachtwoord voor je BitBox in",
    point3: "Maak een backup",
    text: "Ok, we gaan nu een nieuwe wallet aanmaken!"
  },
  createBackupAborted: "Backup afgebroken",
  createBackupFailed: "Het maken van een backup is niet gelukt, probeer het opnieuw.",
  initialize: {
    passwordText: "Gebruik de touch-sensors op je BitBox om een wachtwoord in te stellen.",
    passwordTitle: "Stel een wachtwoord in voor je BitBox.",
    text: "Je BitBox02 is gekoppeld. Stel hem in door te kiezen voor het maken van een nieuwe wallet, of het herstellen van een backup. <strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
    tip: "We raden je aan in een veilige omgeving door te gaan.",
    title: "Initializeer je BitBox"
  },
  insertSDCard: "<strong>Zorg ervoor dat je een microSD kaart in je BitBox02 hebt zitten</strong>",
  noPasswordMatch: "De wachtwoorden kwamen niet overeen, probeer het op nieuw.",
  pairing: {
    failed: "Koppeling niet bevestigd. Plug je BitBox opnieuw in.",
    paired: "Je hebt de volgende code op je BitBox bevestigd. Klik om door te gaan.",
    title: "Verifieer koppelcode",
    unpaired: "Er is een nieuwe BitBox02 gedetecteerd. Controleer dat onderstaande code overeenkomt met wat er op je BitBox staat"
  },
  restoreFromMnemonic: {
    e104: "Het herstellen is afgebroken",
    failed: "Herstel is niet gelukt, probeer het nog eens."
  },
  stepBackup: {
    beforeProceed: "Lees deze belangrijke veiligheidsoverwegingen voordat je verder gaat:",
    createBackup: "Je gaat nu een backup op je microSD kaart maken.",
    createBackupMnemonic: "Je gaat nu de herstelwoorden opschrijven"
  },
  stepBackupSuccess: {
    fundsSafe: "Houd rekening met het volgende om je crypto veilig te houden:",
    title: "Backup hersteld!"
  },
  stepConnected: {
    unlock: "Voer je BitBox02 wachtwoord in om te ontgrendelen."
  },
  stepCreate: {
    description: "Deze naam wordt gebruikt als apparaatnaam en voor de backup",
    error: {
      genericMessage: "Gebruik letters, cijfers, symbolen en spaties. Maximaal 30 karakters.",
      invalidChars: "De naam bevat ongeldige karakters: {{invalidChars}}.",
      tooLong: "Naam is te lang"
    },
    nameLabel: "BitBox02 naam",
    namePlaceholder: "Mijn BitBox02",
    title: "Kies een naam voor je BitBox02",
    toastMicroSD: "Zorg dat je microSD kaart is ingevoerd in je BitBox02; deze wordt gebruikt om een backup van je wallet op te slaan."
  },
  stepCreateSuccess: {
    removeMicroSD: "Haal de microSD kaart uit je BitBox02 en bewaar deze in een veilige locatie.",
    storeMnemonic: "Bewaar je herstelwoorden op een veilige locatie",
    success: "Je backup is aangemaakt."
  },
  stepInsertSD: {
    insertSDCard: "Stop een microSD kaart in je BitBox02 om door te gaan.",
    insertSDcardTitle: "Voer microSD kaart in"
  },
  stepPassword: {
    e104: "Het instellen van een wachtwoord is afgebroken",
    title: "BitBox02 wachtwoord instellen",
    useControls: "Gebruik de touch-sensors op je BitBox02 om een wachtwoord in te voeren."
  },
  stepUninitialized: {
    create: "Ik wil een nieuwe BitBox02 instellen.",
    restore: "Ik wil de backup van een bestaande wallet herstellen.",
    restoreMicroSD: "Herstel met microSD kaart",
    restoreMnemonic: "Herstel met herstelwoorden",
    title: "Stel je BitBox02 in"
  },
  success: {
    text: "Gefeliciteerd! Je BitBox02 is nu klaar om te gebruiken.\nVoor meer informatie over het gebruik van de BitBoxApp check je de applicatiehulp door op het icoon rechtsbovenin te klikken.",
    title: "Je bent helemaal klaar!"
  }
};
const bitsurance$4 = {
  dashboard: {
    active: "Verzekering actief",
    button: "Verzeker een nieuw account",
    canceled: "Geannuleerd",
    coverage: "Maximale dekking",
    inactive: "Inactief",
    processing: "In behandeling",
    refused: "Geweigerd",
    supportLink: "Contract beheren",
    title: "Verzekerde accounts",
    waitpayment: "In afwachting van betaling"
  },
  detect: {
    button: "Bestaande verzekering checken",
    insured: "Verzekerde account gevonden:",
    notInsured: "Geen verzekerde accounts gevonden. Als je zeker weet dat je een verzekerde account hebt, kijk dan of je de juiste wallet hebt verbonden.",
    text: "Als je al lid bent van Bitsurance, kan de BitBoxApp automatisch met je bestaande verzekering synchroniseren.",
    title: "Al verzekerd?"
  },
  insure: {
    button: "Bekijk beschikbaarheid en prijzen",
    faq: "Lees meer in de Bitsurance FAQs",
    listItem1: "Diefstal",
    listItem2: "Afpersing of bedreiging",
    listItem3: "Vernietiging door brand, waterschade of natuurrampen",
    month: "maand",
    text: "Verzeker je BitBox02 en tot €100 000 aan bitcoin tegen",
    text2: "Verzekeringen zijn verkrijgbaar vanaf €30 per jaar (€2,50 per maand). Je kunt meer te weten komen over Bitsurance en hun verzekeringsaanbod op de",
    text3: "Op dit moment alleen beschikbaar in Duitsland, andere landen volgen later",
    title: "Aan de slag"
  },
  intro: {
    link: "Bitsurance website",
    text1: "BitBox werkt met Bitsurance om een extra laag van bescherming voor je bitcoin te bieden. Waar de BitBox02 je coins beveiligt, dekt Bitsurance ook de dingen die niet op te lossen zijn met technologie, zoals diefstal, afpersing en bedreiging of vernietiging van de hardware wallet zelf."
  },
  terms: {
    link: "Bitsurance privacy policy",
    text1: "Bitsurance is een onafhankelijke dienst van een derde partij. Voor vragen over hun aanbod en voor het doen van verzekeringsclaims kun je direct met Bitsurance contact opnemen.",
    text2: "Verzekeringen zijn op dit moment alleen in Duitsland beschikbaar, andere landen volgen later.",
    text3: "De maximale bitcoin-dekking is op dit moment €100 000 per persoon. Het plan is om in de toekomst ook hogere dekkingen aan te bieden.",
    text4: "Je persoonlijke informatie en de publieke sleutel van je verzekerde account is onderdeel van de verzekering en zal gedeeld worden met Bitsurance en de verzekeringsprovider.",
    text5: "Voor meer over je privacy, raadpleeg je de"
  },
  title: "Verzekering"
};
const bitsuranceAccount$4 = {
  errorNoXpub: "Foutmelding: De xpub voor dit account kon niet gevonden worden.",
  noAccount: "Er zijn geen accounts die verzekerd kunnen worden.",
  select: "Selecteer account",
  title: "Verzekering"
};
const blink$a = {
  button: "Knipperen"
};
const bootloader$a = {
  button: "Firmwareupgrade uitvoeren",
  button_install: "Firmware installeren",
  progress: "Firmwareupgrade wordt uitgevoerd: {{progress}}%",
  progress_install: "Firmware wordt geïnstalleerd: {{progress}}%",
  success: "Upgrade voltooid! Plug je BitBox opnieuw in. Druk deze keer niet op de knop."
};
const button$f = {
  abort: "Annuleren",
  back: "Terug",
  buy: "Koop",
  changepin: "BitBox-wachtwoord veranderen",
  check: "Backup controleren",
  "continue": "Verder",
  copy: "Kopiëren",
  create: "Aanmaken",
  dismiss: "Sluiten",
  done: "Klaar",
  download: "Download",
  hiddenwallet: "Verborgen wallet aanmaken",
  next: "Volgende",
  ok: "OK",
  previous: "Vorige",
  receive: "Ontvangen",
  restore: "Herstellen",
  select: "Selecteren",
  send: "Verzenden",
  unlock: "Ontgrendelen",
  update: "Updaten",
  upgrade: "Upgraden"
};
const buy$6 = {
  exchange: {
    bankTransfer: "Bankoverschrijving",
    bestDeal: "Beste deal",
    creditCard: "Creditcard",
    fast: "Snel",
    fee: "transactiekosten",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bankoverschrijving: {{fee}}%",
          creditDebitCard: "Creditcard:  {{fee}}%",
          learnMore: "Lees meer over Moonpay",
          title: "Transactiekosten"
        },
        fullCurrenciesList: "Bekijk hier de hele Valutalijst",
        payment: {
          asteriskText: "* Niet beschikbaar voor inwoners van de VS",
          bankTransfer: "Bankoverschrijving*",
          bankTransferDetails: {
            pix: "PIX (Alleen in Brazilië)",
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          creditDebitCard: "Credit/debitkaart",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa en Maestro"
          },
          learnMore: "Zie meer details over betaalmethodes",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "Ondersteunt alle grote fiat-valuta: USD, EUR, CHF en meer"
      },
      pocket: {
        fees: {
          info: "Bankoverschrijving: {{fee}}%",
          title: "Transactiekosten"
        },
        learnMore: "Lees meer over Pocket",
        payment: {
          bankTransfer: "Bankoverschrijving",
          bankTransferDetails: {
            sepa: "SEPA en SEPA Instant (Alleen EUR-transacties in SEPA landen)",
            sic: "Swiss Interbank Clearing (CHF-transacties alleen in CH/LI)",
            uk: "UK Faster Payments (Alleen GBP transacties in het VK)"
          },
          bankTransferReccuring: "Hoe stel ik regelmatige aankopen in?",
          title: "Betaalmethodes"
        },
        supportedCurrencies: "EUR, GBP en CHF worden ondersteund",
        verification: {
          info: "Vereist alleen identiteitsverificatie boven een dagelijks/jaarlijks limiet",
          link: "Vind de huidige limieten hier",
          title: "Identiteitsverificatie"
        }
      },
      region: {
        title: "Selecteer het land waarin je bankrekening is geregistreerd om de beschikbare opties te zien"
      }
    },
    noExchanges: "Sorry, er zijn geen exchanges beschikbaar in jouw regio",
    region: "Regio",
    selectRegion: "Niet aangegeven",
    title: "Koop {{name}}"
  },
  info: {
    "continue": "Akkoord, verder",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Samen met MoonPay bieden we je een naadloze manier om {{name}} direct in de BitBoxApp te kopen. Het is met een paar kliks gedaan.",
        "MoonPay is een platform dat het snel en makkelijk maakt om {{name}} in meer dan 160 landen te kopen."
      ],
      payment: {
        details: "Je kunt via MoonPay direct {{name}} kopen met de volgende betaalmethodes. Credit- of debitcard aankopen zijn makkelijk en snel, maar zijn duurder omdat de transactie teruggedraaid kan worden. We raden aan om een bankoverschrijving te doen voor grotere hoeveelheden. De minimale kosten zijn 4 euro.",
        footnote: "Houd er rekening mee dat de wisselkoers die MoonPay aanhoudt anders kan zijn dan die in de BitBoxApp, waardoor de hoeveelheden kunnen verschillen.",
        table: {
          "1_description": "Laagste kosten, kan tot 3 werkdagen duren.",
          "1_method": "Bankoverschrijving (SEPA)",
          "2_description": "Hogere kosten, onmiddelijke aankoop",
          "2_method": "Credit- en debitcards",
          description: "Omschrijving",
          fee: "Kosten",
          method: "Methode"
        },
        title: "Betaalmethode en kosten"
      },
      privacyPolicy: "MoonPay privacy policy",
      protection: {
        description: "De BitBoxApp verzamelt geen data als je {{name}} koopt, de inkomende transactie wordt als gewone transactie behandeld. MoonPay moet wat persoonlijke data verzamelen om je hun diensten aan te bieden. Hun privacy policy legt in detail uit hoe die data behandeld wordt.",
        descriptionGeneric: "De BitBoxApp verzamelt geen informatie van je als je {{name}} koopt. De inkomende transactie wordt als een normale transactie behandeld. Onze partner-exchanges moeten echter wat informatie verzamelen om hun diensten te kunnen verlenen. Zie hun respectievelijke privacybeleid voor meer informatie over hoe ze met je data omgaan.",
        title: "Databescherming."
      },
      security: {
        description: "Als je {{name}} koopt via MoonPay, gebruik je een externe dienst. Deze dienst valt buiten het BitBox02 Beveiligings- en bedreigingsmodel en vertrouwt op de beveiliging van de omgeving waarin je de BitBoxApp draait.",
        descriptionGeneric: "Als je {{name}} koopt via een van onze partner-exchanges, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait.",
        link: "Beveiliging- en bedreigingsmodel",
        title: "Bedreigingsmodel"
      },
      title: "Welkom bij jouw one-stop-shop om {{name}} te kopen"
    },
    next: "Volgende",
    selectLabel: "Kies je account",
    selectPlaceholder: "Selecteer een coin",
    skip: "Niet nog eens weergeven",
    title: "Koop {{name}}"
  },
  pocket: {
    data: {
      link: "Pocket's privacybeleid",
      p1: "De BitBoxApp verzamelt geen informatie van je als je bitcoin koopt. De inkomende transactie wordt als een normale transactie behandeld. Moet echter wat informatie verzamelen om hun diensten te kunnen verlenen. Pocket's privacybeleid legt in detail uit hoe ze met je data omgaan.",
      title: "Databescherming"
    },
    kyc: {
      link: "Lees de Pocket-FAQs",
      p1: "Pocket probeert KYC tot een minimum te beperken. Voor aankopen van minder dan 950EUR (1000 CHF) per dag, is het uploaden van identificatie-documenten niet nodig. Als je meer dan dit wilt kopen, zul je een gesprek met Pocket in moeten plannen om de benodigde KYC/AML-procedure te doorlopen.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Je kunt bij Pocket direct bitcoin kopen met een simpele SEPA bankoverschrijving. De transactiekosten hiervoor zijn 1.5%, en de bitcoin wordt direct naar je BitBox gestuurd (zodra Pocket de bankoverschrijving heeft ontvangen - meestal dezelfde dag nog).",
      p2: "Let er op dat de wisselkoers die Pocket hanteert verschillend kan zijn dan die in de BitBoxApp wordt aangegeven, wat een klein verschil in de hoeveelheden kan opleveren.",
      title: "Betaalmethodes en transactiekosten"
    },
    previousTransactions: "Je deelt een bestaande en gebruikte account met Pocket. Als je dit doet kunnen ze je volledige transactiegeschiedenis en alle toekomstige transacties inzien. Wil je toch doorgaan?",
    security: {
      link: "BitBox02 beveiligings- en bedreigingsmodel",
      p1: "Als je bitcoin koopt via Pocket, gebruik je een externe dienst. Deze diensten vallen buiten het beveiligings- en bedreigingsmodel van de BitBox02 en zijn afhankelijk van de veiligheid van de omgeving waarin de BitBoxApp software draait. We werken echter samen met Pocket om de beveiliging te verbeteren door het adres waar je op ontvangt te controleren met een tweefactor-authenticatiemechanisme.",
      title: "Beveiligingsmodel"
    },
    usedAddress: "Het adres {{address}} is al gebruikt, probeer het opnieuw met een nieuw adres.",
    verifyBitBox02: "Verifieer alsjeblieft of het adres wat je via de mail is toegestuurd hetzelfde is als het adres dat op je BitBox wordt weergegeven. Als het kan, is het het beste om de email op een tweede apparaat te openen.",
    welcome: {
      p1: "Met Pocket kun je binnen een paar kliks direct in de BitBoxApp bitcoin kopen.",
      p2: "Pocket is een Zwitsers platform wat het makkelijk en snel maakt om bitcoin te kopen in bijna heel Europa (overal waar SEPA bankoverschrijvingen beschikbaar zijn).",
      p3: "Met Pocket kun je ook regelmatige aankopen doen door een herhaalopdracht in te stellen bij je bank, zodat je makkelijk een DCA (dollar-cost-averaging) spaarplan in kunt stellen.",
      title: "Welkom bij je one-stop-shop voor bitcoin-aankopen"
    }
  },
  title: "Koop {{name}}"
};
const changePin$a = {
  newTitle: "Nieuw BitBox02 wachtwoord",
  oldLabel: "Huidig BitBox02 wachtwoord"
};
const chart$6 = {
  dataMissing: "Datahistorie aan het verzamelen... even geduld.",
  dataOldTimestamp: "Historische wisselkoersen aan het updaten. De grafiek toont geen data van na {{time}}.",
  dataUpdating: "Data aan het updaten...",
  filter: {
    all: "Alle",
    month: "Maand",
    week: "Week",
    year: "Jaar"
  }
};
const checkSDcard$a = "microSD kaart aan het controleren";
const clickHere$a = "Klik hier";
const confirm$c = {
  abortInfo: "Klik om",
  abortInfoRedText: "annuleren",
  approveInfo: "Houd 4 seconden ingedrukt om te",
  approveInfoGreenText: "bevestigen",
  info: "Ga verder op je BitBox",
  infoWhenPaired: "Eerst op de gekoppelde telefoon en dan op je BitBox"
};
const confirmOnDevice$a = "Bevestig op je BitBox";
const connectKeystore$5 = {
  promptNoName: "Verbind je BitBox02 om verder te gaan",
  promptWithName: 'Verbind de BitBox02 die je "{{name}}" hebt genoemd om verder te gaan'
};
const darkmode$5 = {
  toggle: "Donkere kleurstelling"
};
const device$a = {
  appUpradeRequired: "Je BitBox wordt niet ondersteund door deze desktop applicatie. Download en installeer de laatste versie.",
  keystoreConnected: "Verbonden wallet"
};
const deviceLock$a = {
  button: "Stel tweefactor authenticatie (2FA) in",
  condition1: "Heb je een backup?",
  condition2: "Werkt de mobiele app verificatie?",
  condition3: "2FA stelt backups en app-koppelingen buiten werking. De BitBox moet worden gereset om 2FA uit te zetten!",
  confirm: "Stel tweefactor authenticatie (2FA) in",
  title: "Stel tweefactor authenticatie (2FA) in"
};
const deviceSettings$a = {
  backups: {
    manageBackups: {
      description: "MicroSD kaart backup aanmaken of controleren."
    },
    showRecoveryWords: {
      description: "Herstelwoorden tonen en verifiëren."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "De BitBoxApp controleert of je apparaat echt is."
    },
    deviceName: {
      description: "Verander de naam van je apparaat."
    },
    rootFingerprint: {
      description: "Deze vingerafdruk is een unieke identificatie voor de wallet die je op dit moment gebruikt. Het kan je helpen om verschillende wallets uit elkaar te houden, bijvoorbeeld als je een passphrase gebruikt."
    },
    securechip: {
      description: "Secure-chip modelnummer"
    },
    title: "Apparaatinformatie"
  },
  expert: {
    factoryReset: {
      description: "Zet je BitBox terug naar de fabrieksinstellingen - dit verwijdert de wallet uit je BitBox02!",
      title: "Terugzetten naar fabrieksinstellingen"
    },
    goToStartupSettings: {
      description: 'Ga naar de bootloader van de BitBox02. Je kunt hier het laten zien van de "firmware hash" inschakelen.'
    },
    passphrase: {
      description: "Zet de optionele passphrase aan of uit",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Firmware-versie",
    newVersion: {
      label: "Beschikbare versie"
    },
    title: "Firmware",
    upToDate: "Je BitBox is up-to-date",
    upgradeAvailable: "Een nieuwe upgrade is beschikbaar",
    version: {
      label: "Versie"
    }
  },
  hardware: {
    attestation: {
      "false": "Autentiteitscontrole mislukt",
      label: "Autentiteitscontrole",
      "true": "Je hebt een autentieke BitBox02"
    },
    sdcard: {
      "false": "Niet ingevoerd",
      label: "microSD kaart",
      "true": "Ingevoerd"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Apparaatinformatie aan het verzamelen...",
  pairing: {
    lock: {
      "false": "Uitgeschakeld",
      label: "Tweefactor authenticatie (2FA)",
      "true": "Ingeschakeld"
    },
    mobile: {
      "false": "Gesloten",
      label: "Mobiele app",
      "true": "Open"
    },
    status: {
      "false": "Niet gekoppeld",
      label: "Status",
      "true": "Gekoppeld"
    },
    title: "Aan het koppelen"
  },
  secrets: {
    manageBackups: "Backups beheren",
    title: "Geheimen"
  }
};
const deviceTampered$a = "Heb je een herstelwachtwoord gekregen bij de aankoop van je BitBox? Zo ja, moet je onmiddelijk stoppen en ons onmiddelijk contacteren. Shift zal je nooit een kant-en-klare wallet aanbieden of aanbevelingen doen voor je wachtwoorden.";
const dialog$b = {
  cancel: "Annuleren",
  confirm: "Bevestigen",
  confirmTitle: "Bevestiging"
};
const error$6 = {
  accountAlreadyExists: "Deze account bestaat al",
  accountLimitReached: "Kan account niet toevoegen. Je hebt de maximale hoeveelheid accounts voor deze coin.",
  aoppCallback: "Er is een fout opgetreden tijdens het versturen van het adres naar {{host}}",
  aoppInvalidRequest: "Ongeldig verzoek.",
  aoppNoAccounts: "Er zijn geen accounts beschikbaar.",
  aoppSigningAborted: "Verzoek om adreseigenaarschap geannuleerd.",
  aoppUnknown: "Er is een onbekende fout opgetreden.",
  aoppUnsupportedAsset: "Dit token wordt niet ondersteund.",
  aoppUnsupportedFormat: "Er zijn geen accounts beschikbaar die de het verzochte adresformaat ondersteunen.",
  aoppUnsupportedKeystore: "Het verbonden apparaat kan voor deze crypto geen berichten ondertekenen.",
  aoppVersion: "Onbekende versie.",
  keystoreTimeout: "Walletaanvraag verlopen. Probeer het opnieuw.",
  wrongKeystore: "Verkeerde wallet verbonden. Zorg ervoor dat je de juiste BitBox02 voor dit account verbindt.",
  wrongKeystore2: "Als je de optionele passphrase hebt ingeschakeld, zorg er dan voor dat je de juiste passphrase voor dit account hebt ingevoerd."
};
const fiat$c = {
  "default": "Standaard",
  setDefault: "Stel {{code}} in als standaard",
  title: "Valuta's"
};
const footer$c = {
  appVersion: "App versie:"
};
const generic$6 = {
  enabled_false: "Uitgeschakeld",
  enabled_true: "Ingeschakeld"
};
const genericError$a = "Er is een fout opgetreden. Start de applicatie opnieuw op als je problemen tegenkomt.";
const goal$a = {
  buttons: {
    create: "Maak een nieuwe wallet aan.",
    restore: "Herstel een wallet met een backup"
  },
  paragraph: "Selecteer één van de volgende opties:",
  step: {
    "1": {
      title: "Beveiligingsinformatie"
    },
    "2": {
      description: "Stel een apparaatwachtwoord in",
      title: "Apparaat"
    },
    "3-create": {
      description: "Maak een nieuwe wallet aan",
      title: "Wallet"
    },
    "3-restore": {
      description: "met een backup",
      title: "Herstel"
    },
    "4-create": {
      title: "Samenvatting"
    },
    "4-restore": {
      title: "Samenvatting"
    }
  }
};
const guide$b = {
  accountDescription: {
    text: "Je accountpagina laat je beschikbare balansen, en binnenkomende en uitgaande transacties zien. In de instellingen kun je meer informatie vinden over iedere accountsoort.",
    title: "Wat staat er op deze pagina?"
  },
  accountFiat: {
    text: "Ja. Je kunt op iedere 'ticker' klikken om door fiatvaluta te roteren. Je kunt de lijst van valuta's in de instellingen veranderen.",
    title: "Kan ik ook andere wisselkoersen weergeven?"
  },
  accountIncomingBalance: {
    text: "Binnenkomende transacties zijn een som van de hoeveelheden die naar je toe gestuurd zijn, maar nog geen bevestiging hebben van het netwerk.",
    title: "Wat zijn binnenkomende transacties?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Iedere xpub is gekoppeld aan het getoonde 'type': dit is "Native segwit (bech32)", "Wrapped segwit" of "Taproot" (alleen bij Bitcoin). Dit zijn scrypttypes die gebruikt worden door {{coinName}}. De BitBoxApp combineert ze door meerdere scripttypes in dezelfde account te ondersteunen. Omdat ieder scripttype een andere xpub heeft, heb je meerdere xpubs per account.

Als je altijd op het standaardadres ontvangt, heb je alleen de 'bech32' xpub nodig. Als je echter ook (handmatig) ontvangt op je compatibiliteitsadres, staan deze onder de "oudere Segwit" of "Taproot" uitgebreide publieke sleutel (xpub).`,
      title: "Waarom heb ik meerdere xpubs?"
    },
    privacy: {
      text: "Met de uitgebreide publieke sleutel vallen de volledige financiële geschiedenis, de balans van je account en alle eventuele toekomstige transacties te achterhalen. Met alleen de xpub heb je echter geen verzendcontrole over de coins.\n\nAls je een xpub aan iemand geeft, moet je je ervan bewust zijn dat deze persoon of dit bedrijf alle transacties van dit account kan zien. Daarom is het handig om accounts waarvan je de xpub weggeeft maar voor één doel te gebruiken, en je andere financiën op een ander account te beheren. ",
      title: "Moet ik mijn xpub geheim houden?"
    },
    verify: {
      text: "Ja, het is altijd een goed idee om je xpub te dubbel-checken. Zeker als iemand anders met deze xpub adressen gaat genereren om je geld te sturen is het extra belangrijk. Je verifieert de xpub op je BitBox om er zeker van te zijn dat de xpub van jou is. Anders zullen alle transacties naar een verkeerd adres gaan. ",
      title: "Moet ik de xpub verifiëren op mijn BitBox?"
    },
    xpub: {
      text: "Een uitgebreide publieke sleutel (xpub) is de bron waaruit alle ontvangstadressen van een account gemaakt worden. \n\nHet wordt hier weergegeven voor geavanceerde gebruikers en voor ondersteuning van watch-only wallets zoals Electrum of Sentinel. Als je verschillende adrestypes gebruikt, noteer dan alle verschillende xpub-formaten in de watch-only wallet om al je coins te kunnen zien.\n\nLet op dat nog niet alle externe wallets Taproot ondersteunen. ",
      title: "Wat is een uitgebreide publieke sleutel?"
    }
  },
  accountRates: {
    text: "We vernieuwen de wisselkoers iedere minuut gebaseerd op de wisselkoersen van CoinGecko.",
    title: "Welke wisselkoersen gelden er?"
  },
  accountReload: {
    text: "Dat is niet nodig. Je transactiegeschiedenis wordt automatisch geüpdatet.",
    title: "Kan ik de transactiegeschiedenis herladen?"
  },
  accountSendDisabled: {
    text: "De verzendknop wordt geactiveerd als de balans van dat account meer dan nul is.",
    title: "Waarom kan ik geen {{unit}} verzenden?"
  },
  accountSummaryAmount: {
    text: "De totale balans is de som van al je crypto-accounts, berekend met de wisselkoers van coingecko.com.\nLet op: Gebruik je MyEtherWallet voor toekens die niet ondersteund worden door de BitBoxApp? Dan worden deze niet meegerekend in dit totaal.",
    title: "Hoe wordt de totale balans berekend?"
  },
  accountSummaryDescription: {
    text: "Hier kun je de prestaties van je gehele portfolio gedurende verschillende tijdsbestekken bekijken. Een overzicht van je individuele crypto-accounts wordt onder de grafiek weergegeven.",
    title: "Wat zie ik op deze pagina?"
  },
  accountTransactionAttributesBTC: {
    text: "Grootte: De daadwerkelijke grootte van de transactie in bytes zoals berekend volgens de onderliggende blockchain.\nVirtuele grootte: Dit bepaalt de netwerkkosten. Je bespaart op kosten als de virtuele grootte kleiner is dan de transactiegrootte.\nGewicht: Een nieuwe meeteenheid die geïntroduceerd is met Segwit om de grootte van transacties en blokken te evalueren. Iedere 'segregated witness' byte telt als één gewichtseenheid (weight unit), alle andere data telt als vier. In plaats van één megabyte is de grootte van een block nu vier miljoen weight units.",
    title: "Hoe zit het met de Bitcoin-specifieke transactiedetails?"
  },
  accountTransactionAttributesGeneric: {
    text: "Bevestigingen: Je transactie is onbevestigd totdat een miner het toevoegt aan een block. Op dat moment heeft het één bevestiging. Ieder block wat daarna komt geeft jouw transactie een extra bevestiging. Over het algemeen vereisen winkels en andere mensen op het netwerk drie tot zes bevestigingen.\nTransactie-ID: Een uniek identificatienummer waarmee je je transactie in een block explorer kunt opzoeken.\nTransactiekosten: Miners worden betaald met transactiekosten, die ervoor moet zorgen dat ze jouw transactie in een block opnemen. Klik op 'verzenden' om hier meer over te leren.",
    title: "Welke informatie vind ik in de transactiedetails?"
  },
  accountTransactionConfirmation: {
    text: "Een transactie die is uitgezondern naar het netwerk, maar nog geen bevestigingen heeft. ",
    title: "Wat is een transactie in afwachting?"
  },
  accountTransactionLabel: {
    text: "Dit is het adres waarop je coins hebt ontvangen of naartoe hebt verzonden. ",
    title: "Wat is het adres wat bij iedere transactie wordt weergegeven?"
  },
  accountTransactionTime: {
    text: "De transactiebevestigingstijd op de blockchain",
    title: "Wat is de tijd die wordt weergegeven?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin en Litecoin kunnen zoveel accounts hebben als je wilt. Na vijf accounts kun je pas een nieuwe toevoegen als de vorige account daadwerkelijk gebruikt is voor een transactie. Andere coins hebben een maximum van vijf accounts.",
      title: "Hoeveel accounts kan ik aanmaken?"
    },
    howtoAddTokens: {
      text: 'Tokens die gebruik maken van de ERC20 standaard worden aan een specifieke Ethereum-account gekoppeld. Om een token aan- of uit te zetten, open je het "Accounts beheren" scherm, klik je op je Ethereum account en schakel je de gewenste token in of uit.',
      title: "Hoe kan ik meer tokens toevoegen?"
    },
    moveFunds: {
      text: "Ja, maar omdat accounts onafhankelijk van elkaar zijn, moet je een reguliere transactie maken.",
      title: "Kan ik mijn coins tussen accounts verplaatsen?"
    },
    recoverAccounts: {
      text: "Ja, de BitBoxApp maakt accounts die voldoen aan breed gebruikte standaarden, zodat je accounts compatibel zijn met de meeste andere crypto-wallets.",
      title: "Kan ik mijn accounts in een andere wallet herstellen?"
    },
    whatAreAccounts: {
      text: "Je wallet kan meerdere accounts van dezelfde coin aanmaken. Accounts zijn handig als je verschillende 'rekeningen' wilt hebben om je financiën gescheiden te houden..",
      title: "Wat zijn accounts?"
    },
    whatIsRememberWallet: {
      text: 'Als je "wallet onthouden" hebt ingeschakeld, kun je de accounts voor deze wallet bekijken, zelfs zonder dat je BitBox02 is verbonden. Zo kun je je portfolio inzien wanneer je wilt. Om te verzenden en te ontvangen, moet je nog steeds je BitBox02 verbinden.\n\nAls je deze optie uitzet, moet je je BitBox02 ingeplugd hebben om de bijbehorende accounts in te zien.',
      title: 'Wat gebeurt er als ik "wallet onthouden" in- of uitschakel?'
    },
    whyIsThisUseful: {
      text: "Accounts zijn een goede manier om bijvoorbeeld de financiën van verschillende mensen of voor verschillende doeleinden te beheren omdat deze gescheiden gehouden worden in verschillende accounts. Je kunt ook de uitgebreide publieke sleutel (xpub) van één account met iemand anders delen zonder ook maar iets over je andere accounts aan diegene bloot te stellen. Dit zorgt ervoor dat je herhaaldelijk kunt ontvangen zonder een adres te hergebruiken, bijvoorbeeld om een salaris te ontvangen of regelmatig crypto te kopen.",
      title: "Waar is dit goed voor?"
    }
  },
  appendix: {
    link: "Neem contact met ons op!",
    text: "Nog een vraag?"
  },
  backups: {
    check: {
      text: "Het checken van je backup zorgt ervoor dat je kunt controleren of je een geldige backup hebt voor je huidige wallet. Het kan ook gebruikt worden om te controleren of je herstelwachtwoord nog klopt. Je kunt je hoofdherstelwachtwoord checken, of je verborgen herstelwachtwoord.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, maar je herstelwachtwoord is nodig om de wallet vanuit de seed phrase te herstellen.",
      title: "Kan ik de backup versleutelen?"
    },
    howOften: {
      text: "De backup wordt automatisch gegenereerd wanneer je een nieuwe wallet aanmaakt. Je hoeft alleen een nieuwe backup te maken als je microSD kaart kapot of kwijt is, of als je meerdere microSD kaarten als backup wilt gebruiken. Je hoeft geen nieuwe backup te maken nadat je een transactie hebt gedaan; alle transactiedata kan worden hersteld met de backup die aan het begin gemaakt is.",
      title: "Hoe vaak moet ik een nieuwe backup maken?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwoorden ('seed phrase') op een microSD kaart. De herstelwoorden samen met je herstelwachtwoord genereren je wallet.",
      title: "Wat is een backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "Met 'check backup' kun je verifiëren dat je een werkende backup hebt die overeenkomt met je huidige wallet.",
      title: "Wat is 'check backup'?"
    },
    encrypt: {
      text: "Nee, dit is niet mogelijk. Bewaar de microSD kaart op een veilige plek, omdat de onversleutelde herstelwoorden die je wallet kunnen herstellen hierop staan. Als je een wachtwoordbeveiliging wilt gebruiken, kun je de optionele wachtwoordfunctie inschakelen onder de geavanceerde instellingen. ",
      title: "Kan ik de backup versleutelen?"
    },
    whatIsABackup: {
      text: "Het is een kopie van de herstelwachtwoorden op een microSD kaart.",
      title: "Wat is een backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Wanneer 2FA is ingeschakeld moeten alle (verzend-) transacties goedgekeurd worden met de gekoppelde mobiele telefoon. Dit is wat er onder de motorkap gebeurt: Een versleuteld bericht wordt naar de mobiele app gestuurd en ontgrendeld, waarna het teruggestuurd wordt naar de BitBoxApp als je op 'accepteren' klikt. Deze communicatie wordt gedaan via het kanaal dat opgezet wordt tussen de mobiele telefoon en de BitBoxApp tijdens het koppelen. \n\nZorg dat je wallet gebackupt is en gekoppeld met de mobiele app voordat je 2FA inschakeld. Zodra dit gebeurd is worden de microSD poort en het koppelen met de mobiele app uitgeschakeld. Ze kunnen opnieuw ingeschakeld worden door de BitBox te resetten, wat ook je wallets verwijdert. ",
      title: "Hoe werkt tweefactor authenticatie (2FA)?"
    },
    disable2FA: {
      text: "Om 2FA uit te zetten moet je de BitBox resetten en herstellen middels je backup. Zorg ervoor dat je de microSD kaart met de backup nog hebt en dat je het herstelwachtwoord nog weet. Kies dan voor 'Reset BitBox' in de instellingen. Kies een nieuw apparaatwachtwoord en kies 'herstel een backup'. Selecteer de backup die je voor je wallet hebt gemaakt, klik op herstellen en voer het herstelwachtwoord in wat je hebt gekozen toen je de wallet aanmaakte.",
      title: "Hoe kan ik tweefactor authenticatie (2FA) uitschakelen?"
    },
    ejectBitbox: {
      text: "Je kunt de BitBox op ieder moment uit je apparaat halen, zonder dat je het eerst hoeft uit te werpen.",
      title: "Hoe kan ik de BitBox uitwerpen?"
    },
    ejectSD: {
      text: "Je kunt de microSD kaart op ieder moment handmatig uit je BitBox halen, zo lang je niet op dat moment een backup aan het maken of herstellen bent.",
      title: "Hoe kan ik de microSD kaart uitwerpen?"
    },
    hiddenWallet: {
      text: "Het is een tweede wallet op dezelfde BitBox, die beschermd wordt door aparte apparaat- en herstelwachtwoorden, die je kunt gebruiken om een gedeelte van je balans te verbergen. Dezelfde herstelwoorden / SD kaart backup wordt gebruikt voor je normale en verborgen wallet, dus je hebt geen extra backup nodig.",
      title: "Wat is een verborgen wallet?"
    },
    legacyHiddenWallet: {
      text: "Klik eerst op onderstaande button (die beschikbaar is als de BitBox ontgrendeld is en 2FA niet ingeschakeld staat), plug daarna je BitBox opnieuw in en ontgrendel hem met je verborgen apparaatwachtwoord.",
      title: "Hoe krijg ik toegang tot mijn verborgen legacy wallet?"
    },
    pairing: {
      text: "Nadat je de mobiele BitBoxApp hebt gedownload voor iOS of Android, kun je de weergegeven QR-code scannen. Dit zet een beveiligd kanaal op tussen de mobiele telefoon en deze applicatie. Zodra je de QR-code gescand hebt, kun je de instructies op je telefoon volgen.",
      title: "Hoe koppel ik mijn mobiele telefoon?"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Raadpleeg alsjeblieft Bitsurance's website en hun FAQ voor meer informatie.",
      title: "Verder nog vragen?"
    },
    privacy: {
      link: {
        text: "Bitsurance privacy policy"
      },
      text: "De verzekering bevat, zoals alle verzekeringen, je naam en adres, en specificeert het het te verzekeren object (in dit geval wordt dit door je publieke sleuten gedefinieerd). Deze gegevens worden direct naar Bitsurance gestuurd en worden niet met Shift Crypto gedeeld. Voor meer informatie kun je de Bitsurance privacy policy raadplegen.",
      title: "Welke persoonlijke informatie is nodig voor de verzekering?"
    },
    renew: {
      text: 'De verzekering verlengt na een jaar automatisch. Je kunt dit op ieder moment stopzetten via "Contract beheren" in de BitBoxApp, wat je naar het klantenportaal van Bitsurance brengt.',
      title: "Hoe kan ik de verzekering verlengen of annuleren?"
    },
    status: {
      text: 'Verzekerde accounts worden met een groene "verzekerd" badge gemarkeerd in de linkerbovenhoek van de Bitcoin account-pagina. In de "verzekering" sectie kun je een overzicht vinden van alle verzekerde Bitcoin accounts en hun huidige verzekeringsstatus.',
      title: "Kan ik de status van een verzekerd account inzien?"
    },
    what: {
      text: 'Iedere Bitcoin-verzekeringscontract dekt een specifieke account in je wallet. Je kunt verschillende accounts verzekeren door meerdere polissen af te sluiten. De verzekering dekt alleen adressen van het "Native Segwit" type.',
      title: "Is de hele BitBox wallet verzekerd?"
    },
    who: {
      text: "De verzekering wordt aangeboden door Bitsurance, een verzekeraar opgericht door bitcoiners. Ze werken samen met ELEMENT verzekeringen om de Bitcoin-verzekering aan te bieden. Beide bedrijven zijn in Duitsland gevestigd.",
      title: "Wie verzekert mijn bitcoin?"
    },
    why: {
      text: "Bitsurance dekt een aantal risico's van het in eigen beheer houden van je coins die niet door een wallet afgevangen kunnen worden, zoals diefstal, afpersing of vernietiging van de wallet. Het is een persoonlijke beslissing of je voor deze risico's een verzekering nodig hebt.",
      title: "Heb ik een Bitcoin-verzekering nodig?"
    }
  },
  cointracking: {
    text: "Klik op de 'exporteren' knop en open de downloads map. Hier vind je een .csv export bestand. Klik op onderstaande link, upload je BitBox .csv bestand en importeer de data om het in je CoinTracking porfoliomanager te gebruiken en je belastingaangifte te genereren.",
    title: "Hoe importeer ik mijn transacties in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Lees meer over de authenticiteits-check"
      },
      text: "De BitBoxApp doet een authenticiteitscheck om er zeker van te zijn dat je BitBox echt is. Deze check wordt lokaal uitgevoerd en benodigt geen verbinding naar externe servers.",
      title: "Hoe werkt de authenticiteitscheck?"
    },
    name: {
      text: "Dit is de naam van je wallet en van je backup. De naam wordt gebruikt voor toekomstige backups en kan ook gebruikt worden om verschillende wallets te onderscheiden. Deze kun je op ieder moment veranderen, maar backups die je hiervoor gemaakt hebt zullen nog steeds de oude naam gebruiken.",
      title: "Waar wordt de BitBox02-naam voor gebruikt?"
    },
    "secure-chip": {
      link: {
        text: "Lees meer over de secure chip"
      },
      text: "Deze informatie toont het modelnummer van de secure chip. De het nieuwste model is de ATECC608B, die verbeterde beveiligings-eigenschappen heeft vergleken met oudere modellen.",
      title: "Waarom wordt het secure chip modelnummer getoond?"
    }
  },
  receive: {
    address: {
      text: "Je kunt dit adres aan anderen geven, zodat ze transacties naar je kunnen doen. Controleer altijd met de verzender of zij wel het juiste adres hebben ingevuld!",
      title: "Wat moet ik met een adres?"
    },
    addressChange: {
      text: "Zodra je een transactie doet, wordt er automatisch een nieuw adres gegenereerd en toegevoegd aan de lijst. Zo heb je altijd 20 adressen beschikbaar die nog nooit coins hebben ontvangen.",
      title: "Wanneer veranderen mijn adressen?"
    },
    addressFormats: {
      text: "Het standaardadrestype is Native Segwit. Dit adrestype is het meest gebruikt door andere wallets en exchanges en zorgt ervoor dat je de laagste transactiekosten betaalt. Je kunt er echter voor kiezen om bitcointransacties naar Taproot-adressen te doen, wat het nieuwste adresformaat is, maar nog niet overal ondersteund wordt. Als je problemen ondervind met het versturen naar een Native Segwit adres, kun je ervoor kiezen om een Wrapped Segwit adres te gebruiken, wat met vrijwel alle andere wallets en exchanges compatibel is. ",
      title: 'Wanneer moet ik "Adrestype wijzigen" gebruiken?'
    },
    howVerify: {
      text: "Voor de BitBox01 klik je op het BitBox icoon in het zijmenu aan de linkerkant en ga je naar de 'koppelen'-sectie. Als je daar bent, updatet de hulp en kun je de instructies daar verder volgen.\nOp de BitBox02 kun je adressen direct op het apparaat verifiëren tijdens het proces van verzenden of ontvangen.",
      title: "Hoe kan ik veilig mijn adressen verifiëren?"
    },
    plugout: {
      text: "Nee, zodra je je coins naar het adres hebt verstuurd, kun je je BitBox gewoon weer opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het ontvangen?"
    },
    why20: {
      text: "Tijdens het opstarten genereert de app verschillende adressen op basis van je seed om te kijken of ze iets hebben ontvangen. Omdat de app een praktisch oneindige hoeveelheid adressen kan genereren, kan de app ook oneindig doorgaan met adressen controleren tijdens het opstarten. Om dit te voorkomen, stopt de app met controleren als het 20 adressen achter elkaar heeft gezien die niets ontvangen hebben. Dit is het tussenruimte-limiet en 20 is hiervoor de arbitraire standaard. Dit zijn de 20 adressen waar je uit kunt kiezen.",
      title: "Waarom slechts 20 adressen?"
    },
    whyMany: {
      text: "Om je privacy en veiligheid te bewaken, moet je nooit twee keer hetzelfde adres gebruiken; bekijk een adres als een factuurnummer. Als je een adres hebt gebruikt, kun je op de rechterpijl klikken voor een nieuw adres. Je kunt tot 20 adressen tegelijkertijd aanmaken. Alle adressen zijn gegenereerd op basis van je backup herstelwoorden.",
      title: "Waarom zo veel adressen?"
    },
    whyVerify: {
      text: "Je zou je computer niet moeten vertrouwen om adressen te genereren en weer te geven. Je computer heeft een veel hoger aanvalsrisico dan een hardware wallet, waardoor de kans op virussen en malware vele malen hoger is. \nVoor de BitBox01 klik je op de knop om een veilig adres naar de gekoppelde telefoon te sturen, die je ook kun gebruiken om de QR-code te scannen en verifiëren. Voor de BitBox02 kun je het adres direct op het display verifiëren. ",
      title: "Waarom moet ik mijn adressen verifiëren. "
    }
  },
  send: {
    change: {
      text: "Het wisselgeld wordt naar een Taproot-adres gestort als je ten minste één andere Taproot-UTXO hebt. Als je coin control gebruikt, wordt het wisselgeld naar een Taproot adres gestort als er zich ten minste één Taproot-UTXO tussen de geselecteerde UTXOs bevindt. In alle andere gevallen wordt het wisselgeld naar een Native Segwit adres gestort. ",
      title: "Hoe wordt het wisselgeldadres bepaald?"
    },
    fee: {
      text: "De netwerkkosten worden geschat op basis van de grootte van de transactie en niet de hoeveelheid. De netwerkkosten worden berekend door het algoritme van Bitcoin Core op basis van de prioriteit die je zelf kiest. Deze worden weergegeven als ze een andere waarde hebben dan de waardes hieronder:\nBudget: 24 blokken (ongeveer 4 uur voor Bitcoin, 1 uur voor Litecoin)\nLaag: 12 blokken (ongeveer 2 uur voor Bitcoin, 30 minuten voor Litecoin)\nNormaal: 6 blokken (ongeveer 1 uur voor Bitcoin, 15 minuten voor Litecoin)\nHoog: 2 blokken (ongeveer 20 uur voor Bitcoin, 5 minuten voor Litecoin)\n(Een Bitcoin-blok kost gemiddeld 10 minuten en een Litecoin-blok 2,5 minuut om te minen. De belasting op het netwerk en dus je bevestigingstijd kan drastisch variëren.)",
      title: "Hoe worden de netwerkkosten bepaald?"
    },
    plugout: {
      text: "Nee, zodra je een transactie hebt gemaakt, hoef je je BitBox niet ingeplugd te laten. Je kunt je BitBox direct na verzenden veilig opbergen.",
      title: "Moet ik mijn BitBox ingeplugd laten tijdens het verzenden?"
    },
    priority: {
      text: "Hoe hoger de netwerkkosten die je bereid bent te betalen, hoe sneller je transactie bevestigd zal worden door het netwerk.",
      title: "Wat is de netwerkprioriteit?"
    },
    revert: {
      text: "Zodra een transactie is ondertekend en verzonden (uitgezonden naar het netwerk), kan het niet teruggedraaid worden. Verifieer daarom altijd alle onderdelen van de transactie (inclusief de netwerkkosten) voordat je hem ondertekent! Als je de ontvanger kent, kun je ze middels een ontvangstadres vragen om de transactie handmatig terug te sturen.",
      title: "Kan ik een transactie terugdraaien?"
    },
    whyFee: {
      text: "Transacties concurreren met elkaar om bevestigd te worden door een miner. Miners kiezen de transacties die ze in hun blokken stoppen op basis van welke transacties het meeste betalen. Miners bepalen welke transacties er opgenomen worden in de blockchain. Omdat er geen vertrouwde derde partijen zijn om te bepalen welke transacties valide zijn, doen miners dit door middel van computerkracht op te offeren. Als beloning voor hun werk, kunnen ze nieuwe Bitcoin en de netwerkkosten van alle transacties die ze hebben uitgekozen opeisen.",
      title: "Waarom zijn er netwerkkosten?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Als je je eigen node wilt verbinden die zich op hetzelfde netwerk bevindt (bv. je wifinetwerk thuis), kun je zonder problemen normale netwerkcommunicatie gebruiken. Het is aan te raden dat je Electrum-server een TLS-certificaat heeft om de communicatie te versleutelen.\nAls je op andere locaties dan alleen thuis met je node wilt verbinden, is Tor de betere optie. In dit geval is een TLS-certificaat niet nodig.",
      title: "Moet ik clearnet TCP, TLS of Tor gebruiken?"
    },
    instructions: {
      link: {
        text: "Instructies om je eigen node te koppelen."
      },
      text: "Voor een volledige tutorial kun je onze instructies op deze webpagina volgen:",
      title: "Hoe verbind ik mijn BitBoxApp met mijn eigen full node?"
    },
    options: {
      text: "Er zijn meerdere opties om je eigen node te draaien, zoals een kant-en-klaar apparaat te kopen, er zelf een te bouwen of Bitcoin Core te draaien op je PC. Als je de BitBoxApp wilt verbinden met je eigen node, moet je ervoor zorgen dat het beschikt over een Electrum server. Dit is een programma dat toegeweid is aan het verbinden van wallets met je full node.\nOndersteunde opties zijn Electrs, Electrum Personal Server of Bitcoin Wallet Tracker.",
      title: "Welke opties heb ik om zelf een full node te draaien?"
    },
    tor: {
      text: "Tor staat voor 'The Onion Router'. Het is een gratis, open source programma dat je extra privacy biedt en heel nuttig is in combinatie met Bitcoin. \nAls je met je node wilt verbinden via Tor, moet je ervoor zorgen dat Tor is geïnstalleerd op je computer en dat de Tor Proxy is ingeschakeld in de instellingen van de BitBoxApp.\nOp de meeste besturingssystemen zijn er twee manieren om Tor te gebruiken:\n1. Tor Browser: download en open de Tor Browser. Dit zorgt ervoor dat de BitBoxApp kan verbinden met het Tor netwerk als je poort 9150 hebt ingesteld in de Tor Proxy instellingen.\n2. Tor achtergronddienst: installeer de Tor daemon, die altijd in de achtergrond draait. De BitBoxApp kan dan verbinden door poort 9050 in te stellen in de Tor Proxy instellingen.",
      title: "Wat zijn Tor en de Tor Proxy, en welke poort moet ik gebruiken?"
    },
    what: {
      text: "Het is mogelijk om je wallet te verbinden met je eigen full node, in plaats van het gebruiken van de Shift servers.",
      title: "Wat is dit?"
    },
    why: {
      text: "Het draaien van je eigen node is niet noodzakelijk, maar het verhoogt wel je privacy en verlaagt de noodzaak om anderen te vertrouwen.\nHet betekent dat je Bitcointransacties meer privé zijn, omdat de BitBoxApp niet meer verbindt met onze servers om je transactiegeschiedenis op te halen. In plaats daarvan wordt die informatie van je eigen node gehaald.\nTen tweede zorgt het draaien van je eigen node ervoor dat je alle transacties zelf verifieerd en controleert of de consensusregels gevolgd worden ",
      title: "Waarom zou ik mijn eigen node moeten draaien?"
    }
  },
  settings: {
    sats: {
      text: 'Een Satoshi (of "sat" in het kort) is de kleinst mogelijke eenheid op het bitcoinnetwerk. Een satoshi is één honderdmiljoenste bitcoin (0.00 000 001 BTC). Het is vernoemd naar de maker van Bitcoin, Satoshi Nakamoto.',
      title: "Wat is een Satoshi?"
    },
    servers: {
      text: "De app communiceert met de Shift Crypto servers om op updates te controleren, je transacties te laden en informatie te versturen naar je gekoppelde mobiele apps. \nDe app haalt ook de huidige wisselkoersen van CoinGecko. Alle conversies worden lokaal gedaan, zodat je balansen nooit naar derde partijen verstuurd worden.\nVoor Ethereum en ERC20 tokens worden de Etherscan.io APIs gebruikt.",
      title: "Met welke servers verbindt deze app?"
    }
  },
  title: "Gids",
  toggle: {
    close: "Gids sluiten",
    open: "Gids"
  },
  trackingModePortfolioChart: {
    text: "Op de desktop kun je je muiscursor over de grafiek heen bewegen. Op je telefoon gebruik je je vinger om horizontaal over de grafiek te slepen.",
    title: "Hoe kan ik de historische waardes op de grafiek inzien?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Je moet het apparaat resetten en de wallet herstellen middels een backup en het herstelwachtwoord.",
      title: "Wat moet ik doen als ik het wachtwoord van mijn BitBox vergeten ben?"
    },
    reset: {
      text: "Door 15 keer een verkeerd apparaatwachtwoord in te voeren. Tijdens de laatste paar keer moet je de knoppen langer ingedrukt houden.",
      title: "Hoe reset ik mijn BitBox?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Het apparaat zou één keer moeten knipperen als het ingevoerd wordt. Zorg dat het met de juiste kant boven ingevoerd is. Als je het probleem niet opgelost krijgt, kun je contact met ons opnemen via onderstaande link.\nDe BitBox01 is niet te koppelen met mobiele telefoons. Gebruik alsjeblieft de BitBoxApp op een PC om je BitBox01 te verbinden.",
      title: "Mijn BitBox01 wordt niet herkend."
    },
    getDevice: {
      link: {
        text: "Bestel een BitBox"
      },
      text: "Je kunt een BitBox op onze webwinkel bestellen:",
      title: "Hoe kan ik aan een BitBox komen?"
    },
    internet: {
      text: "Ja, een internetverbinding is nodig om de wallet te synchroniseren, transacties te versturen en de laatste wisselkoersen op te halen.",
      title: "Heeft deze app een internetverbinding nodig?"
    },
    lostDevice: {
      link: {
        text: "Backup-center"
      },
      text: "Je kunt je accounts herstellen met een nieuwe BitBox of via ons backup-center",
      title: "Ik ben mijn BitBox kwijt, wat nu?"
    },
    useWithoutDevice: {
      text: "Dat is op dit moment niet mogelijk.",
      title: "Kan ik de app ook zonder BitBox gebruiken?"
    },
    welcome: {
      text: "Bedankt voor het gebruiken van deze app, gemaakt door Shift Crypto in Zwitserland. We waarderen alle feedback die je voor ons hebt! Die kun je delen door op de link onderaan het scherm te klikken.",
      title: "Welkom in de BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Als je een nieuwe telefoon of computer met de BitBoxApp verbindt, moet je opnieuw met je DApps verbinden. Als je dit gedaan hebt, zie je de coins weer in de DApp zoals je gewend bent.",
      title: "Ik zie mijn eerdere verbindingen niet."
    },
    supportedNetworks: {
      text: "Op dit moment wordt alleen Ethereum via WalletConnect in de BitBoxApp ondersteund. Gebruik de Rabby-browserextensie om van andere EVM-compatibele chains gebruik te maken.",
      title: "Welke netwerken worden ondersteund?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect is een communicatie-protocol voor web3 applicaties. Hiermee kun je op een gemakkelijke manier met op Ethereum gebaseerde DApps en web-wallets verbinden zonder een applicatie van een derde partij te hoeven gebruiken. Dit is extra handig voor gebruikers van de Android-BitBoxApp.",
      title: "Wat is WalletConnect?"
    }
  }
};
const headerssync$a = {
  blocksSynced: "{{blocks}} blokken gesynchroniseerd"
};
const hiddenWallet$a = {
  info1HTML: "Je kunt een verborgen wallet aanmaken met een <strong>andere</strong> combinatie van apparaatwachtwoord & herstelwachwoord, om plausibele ontkenning mogelijk te maken.",
  info2HTML: "Voer het apparaatwachwoord en het herstelwachtwoord dat je met je verborgen wallet wilt associëren hieronder in. Het apparaatwachtworod en het herstelwachtwoord <strong>moeten</strong> van je hoofdwallet verschillen.",
  passwordLabel: "Verborgen herstelwachtwoord",
  passwordPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  pinLabel: "Verborgen apparaatwachtwoord",
  pinRepeatLabel: "Herhaal je verborgen herstelwachtwoord",
  pinRepeatPlaceholder: "Bevestig je verborgen herstelwachtwoord",
  success: "Verborgen wallet aangemaakt. Voer je BitBox opnieuw in om het te ontgrendelen."
};
const initialize$a = {
  create: "Stel apparaatwachtwoord in",
  creating: "Apparaatwachtwoord instellen...",
  error: {
    e102: "Het apparaatwachtwoord moet ten minste vier karakters bevatten."
  },
  info: {
    description1: "Kies je apparaatwachtwoord. Dit wordt gebruikt om je BitBox te ontgrendelen.",
    description2: "Je kunt nummers, letters en symbolen gebruiken. Langere wachtwoorden bieden je meer veiligheid.",
    description3: "Als je je apparaatwachtwoord kwijtraakt moet je je BitBox resetten met je backup.",
    subtitle: "Nu ga je je apparaatwachtwoord instellen.",
    title: "Apparaat initialiseren..."
  },
  input: {
    label: "Apparaatwachtwoord",
    labelRepeat: "Herhaal apparaatwachtwoord",
    placeholderRepeat: "Bevestig apparaatwachtwoord"
  }
};
const invalidFormat$a = "Ongeldig format";
const language$b = {
  title: "Selecteer je taal"
};
const legacyhiddenwallet$a = {
  disable: "Verborgen legacy wallet uitschakelen",
  enable: "Verborgen legacy wallet inschakelen",
  successDisable: "Verborgen legacy wallet uitgeschakeld",
  successEnable: "Verborgen legacy wallet ingeschakeld. Plug je BitBox opnieuw in en voer het verborgen apparaatwachtwoord in om toegang te krijgen tot je verborgen legacy wallet."
};
const loading$a = "laden...";
const manageAccounts$4 = {
  accountHidden: "Deze account is verborgen in je alleen-kijken accounts. Om hem weer te zien moet je je BitBox02 verbinden.",
  editAccount: "Bewerken",
  editAccountNameTitle: "Accountnaam bewerken",
  noAccounts: "Geen accounts gevonden",
  settings: {
    hideTokens: "Tokens verbergen",
    showTokens: "Tokens tonen ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Accounts toevoegen en tonen/verbergen",
  title: "Accounts beheren",
  watchAccount: "Alleen-kijken account",
  watchAccountDescription: "Deze account is onderdeel van je alleen-kijken accounts. Je kunt het in deze lijst verbergen met de toggle."
};
const mobile$5 = {
  usingMobileDataWarning: "Mobiel datagebruik: deze app kan een paar honderd megabyte aan blockchaindata downloaden als je een account opent. Verbind met een wifinetwerk om je mobiele datagebruik te beperken.\n\nDit bericht wordt niet nogmaals getoond."
};
const newSettings$4 = {
  about: {
    appVersion: {
      title: "App versie"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Vergrendel toegang tot de app met je schermvergrendeling of vingerafdruk.",
      title: "Schermvergrendeling"
    },
    coinControl: {
      description: "Selecteer welke UTXOs onderdeel van een transactie zijn om privacy te verbeteren."
    },
    customFees: {
      description: "Dit laat je de transactiekosten van een overboeking precies bepalen."
    },
    torProxy: {
      description: "Verbind via Tor voor betere privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Je kunt door alle valuta heen wisselen op de acccountpagina.",
      title: "Actieve valuta"
    },
    darkmode: {
      description: "Verander het uiterlijk van de BitBoxApp naar een donkere kleurstelling."
    },
    defaultCurrency: {
      description: "Selecteer je standaardvaluta",
      title: "Standaardvaluta"
    },
    enableAccount: {
      description: "Als je je account de-activeert betekent dit alleen dat deze niet direct zichtbaar is in de BitBoxApp. Je kunt hem via dit menu altijd weer heractiveren. Coins op gedeactiveerde accounts blijven daar gewoon staan en blijven veilig.",
      title: "Account activeren/uitzetten"
    },
    hideAmounts: {
      description: "Laat een toggle zien om je balansen en hoeveelheden te verbergen om je privacy te beschermen als je de app in het openbaar gebruikt.",
      hideAmounts: "Hoeveelheden verbergen",
      showAmounts: "Hoeveelheden laten zien",
      title: '"Hoeveelheden verbergen" inschakelen'
    },
    language: {
      description: "De taal waarin je de BitBoxApp wilt gebruiken.",
      title: "Taal"
    },
    remebmerWallet: {
      name: "Wallet onthouden",
      warning: "Je onthouden wallet wordt hiermee vergeten. Om hem weer te zien, moet je je BitBox02 opnieuw verbinden. Dit heeft geen enkele invloed op de coins die op je wallet staan. \n\nWil je doorgaan?",
      warningTitle: "Wallet niet meer onthouden"
    },
    toggleSats: {
      description: "Satoshis in- of uitschakelen."
    }
  }
};
const note$6 = {
  input: {
    description: "(optioneel)",
    placeholder: "Notitie toevoegen"
  },
  title: "Notitie"
};
const notification$a = {
  newTxs_one: "Nieuwe transactie in: {{accountName}}",
  newTxs_other: "{{count}} nieuwe transacties in: {{accountName}}"
};
const pairing$a = {
  aborted: {
    text: "Het koppelen van de mobiele app is afgebroken.",
    title: "Afgebroken"
  },
  button: "Mobiele app koppelen",
  confirm: "Weet je zeker dat je je BitBox wilt koppelen? Hierna heb je je mobiele telefoon nodig om een transactie uit te voeren.",
  connectOnly: {
    button: "Mobiele app verbinden",
    title: "Scan met de mobiele app door in het menu 'Nieuwe desktop-app verbinden' te kiezen."
  },
  error: {
    text: "Er is iets misgegaan. Probeer het opnieuw.",
    title: "Fout"
  },
  pullFailed: {
    text: "We konden het bericht niet van je telefoon ophalen door de relay server. De server kan offline zijn, neem contact op met de klantenservice.",
    title: "Pull niet gelukt"
  },
  reconnectOnly: {
    button: "Mobiele app opnieuw verbinden"
  },
  scanningFailed: {
    text: "Telefoon kon het bericht niet scannen. Probeer het opnieuw.",
    title: "Scan niet gelukt"
  },
  start: {
    hideAppQRCode: "QR-code verbergen",
    revealAppQRCode: "QR-code tonen",
    step1: "Als je de mobiele app niet hebt, kun je de QR-code voor de App Store of Play store scannen, afhankelijk van welke telefoon je hebt. ",
    step2: "Scan met onze mobiele app, die je kunt vinden als 'Digital BitBox 2FA' in de iOS en Android app stores."
  },
  started: {
    text: "Volg de instructies op de mobiele app",
    title: "Fantastisch"
  },
  success: {
    text: "Gefeliciteerd, je hebt je BitBox met de mobiele app gekoppeld!",
    title: "Gelukt"
  },
  timeout: {
    text: "Het koppelen is na twee minuten automatisch gestopt. Begin opnieuw als je de mobiele app nog steeds wilt koppelen. ",
    title: "Time-out"
  },
  title: "Mobiele koppeling"
};
const passphrase$4 = {
  considerations: {
    button: "Backup overwegingen",
    message: "De passphrase biedt je extra bescherming voor je (microSD of herstelwoord-) backup. Als iemand toegang heeft gekregen tot je backup, hebben ze nu ook de passphrase nodig om toegang te krijgen tot je wallet.\n\nDit betekent echter dat je <strong>zowel de passphrase als de backup</strong> nodig hebt om je wallet te herstellen wanneer je BitBox02 kapot gaat of verloren raakt. Als je je passphrase verliest of vergeet, raak je de toegang tot alle coins op die wallet kwijt.\n\nAls je je passphrase ergens opslaat, zou je dit op een andere plek dan je backup moeten doen. Op die manier heeft iemand die je backup vindt niet ook toegang tot je passphrase.",
    title: "Backup overwegingen"
  },
  disable: "Passphrase uitzetten",
  disableInfo: {
    button: "Uitzetten",
    message: "Nadat je de passphrase hebt uitgezet, word je niet langer gevraagd om een passphrase in te voeren nadat je je BitBox02 hebt ontgrendeld. Je voert dus je standaard wallet in.\n\nEventuele coins die nog op je passphrase wallet staan, zullen daarop blijven staan, en je kunt hier niet meer bij; je BitBox vraagt immers niet meer om de passphrase en opent direct je standaard wallet. Om weer toegang te krijgen, kun je simpelweg de passphrase opnieuw inschakelen en de passphrase weer invoeren bij het opstarten.\n\n<strong>Tip:</strong> Je kunt ook met een passphrase toegang tot je standaardwallet krijgen door niks in te voeren als er om je passphrase gevraagd wordt."
  },
  enable: "Passphrase inschakelen",
  error: {
    e104: "Het veranderen van de passphrase-instelling is geannuleerd."
  },
  how: {
    button: "Hoe het er uit ziet",
    message: "Een passphrase werkt niet zoals andere wachtwoorden waar je aan gewend bent. Als je je passphrase verkeerd invoerd, krijg je hier geen melding van. Dit komt omdat <strong>iedere passphrase een nieuwe, valide wallet maakt</strong>. Dit betekent dat je zo veel verschillende wallets kunt aanmaken als je wilt door een andere passphrase in te voeren. Je kunt weer toegang krijgen tot iedere wallet door de bijbehorende passphrase in te voeren.\n\nAls je je BitBox02 invoert, zul je zoals je gewend bent om het gewone wachtwoord gevraagd worden. Daarna kun je een passphrase invoeren.\n\nNadat je de passphrase hebt ingevoerd, kun je nog een keer checken wat je precies hebt ingevoerd, zodat je zeker weet dat het was wat je verwachtte.",
    title: "Hoe werkt het"
  },
  intro: {
    message: "Een passphrase zorgt voor extra beveiliging voor je wallet.\nDit is hoe het werkt.",
    title: "Passphrase instellen"
  },
  progressDisable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>uitschakelen</strong>",
    title: "Bevestig op je BitBox"
  },
  progressEnable: {
    message: "Bevestig op je BitBox dat je de passphrase wilt <strong>aanzetten</strong>.",
    title: "Bevestig op je BitBox"
  },
  successDisabled: {
    message: "De passphrase <strong>staat nu aan</strong>!\nVanaf nu zul je tijdens het opstarten om een passphrase worden gevraagd.",
    messageEnd: "Plug alsjeblieft de BitBox opnieuw in.",
    title: "Passphrase aangezet"
  },
  successEnabled: {
    message: "De passphrase <strong>staat nu uit</strong>!\nVanaf nu zul je niet langer tijdens het opstarten om een passphrase worden gevraagd.",
    messageEnd: "Plug je BitBox02 opnieuw in.",
    tips: "Tips",
    tipsList: [
      "We raden je aan om een kleine hoeveelheid coins naar de passphrase wallet te sturen. Plug daarna je BitBox opnieuw in en voer je wachtwoord en passphrase in. Als je passphrase correct is, zou je de coins in je wallet moeten zien.",
      "Als je toegang wilt krijgen tot de originele wallet, kun je dit nog steeds doen door niets in te voeren als je om een passphrase wordt gevraagd. Of je kunt de passphrase helemaal uitzetten."
    ],
    title: "Passphrase uitgeschakeld"
  },
  summary: {
    button: "Passphrase aanzetten",
    title: "Samenvatting",
    understand: "Ik snap hoe de passphrase werkt, en begrijp de risico's die het met zich meebrengt.",
    understandList: [
      "De passphrase is een extra beveiliging bovenop je backup",
      "Het invoeren van een andere passphrase genereert een andere wallet.",
      "Om je wallet te herstellen heb je <strong>zowel de passphrase als de backup</strong> nodig.",
      "Als je je passphrase vergeet, kun je geen toegang meer krijgen tot je coins."
    ]
  },
  what: {
    button: "Leer hoe dit werkt",
    message: "Een wallet komt voort uit een heel groot willekeurig getal, ook wel bekend als je 'seed'. Deze seed is gemaakt toen je je BitBox02 voor het eerst instelde en is gebackupt met de microSD kaart of je lijst van herstelwoorden. Iedereen die toegang heeft tot de seed, heeft volledige controle over de coins in die wallet. \n\nEen passphrase is een <strong>optioneel geheim</strong> dat toegevoegd wordt aan de seed. Wanneer je de passphrase aanzet, maakt iedere verschillende passphrase een nieuwe wallet op basis van de seed <strong>en</strong> de passphrase. Een passphrase kan alles zijn; letters, woorden, speciale karakters, of helemaal niets. In feite is je standaardwallet een seed met een lege passphrase.\n\nDeze passphrase is onderdeel van de BIP39 standaard, wat betekent dat hij compatibel is met alle wallets die diezelfde standaard ondersteunen. ",
    title: "Wat is een passphrase?"
  },
  why: {
    button: "Waarom zou ik een passphrase gebruiken?",
    message: "De BitBox02 beschermt je seed op het apparaat zelf, maar de backup (op de microSD kaart of je herstelwoorden) geeft nog steeds volledige controle over de wallet. Dat is waarom deze backup veilig opgeslagen moet worden!\n\nOmdat een passphrase een nieuwe wallet genereert met de bestaande seed, heeft een passphrase wallet <strong>zowel de backup als de passphrase</strong> nodig om hem te herstellen. Het voordeel hiervan is dat als iemand je backup vindt, ze nog steeds je passphrase nodig hebben om toegang te krijgen tot je wallet.\n\nDaarnaast kun je met de passphrase meerdere wallets op hetzelfde device aanmaken, ook bekend als 'verborgen wallets', naast de bestaande wallet.",
    title: "Waarom zou je een passphrase gebruiken?"
  }
};
const password$a = {
  show: "Toon {{label}}",
  warning: {
    caps: "WAARSCHUWING: Caps lock (⇪) is ingeschakeld",
    paste: 'om tekst te plakken, schakel je "SHOW {{label}}" in'
  }
};
const random$b = {
  button: "Genereer willekeurig getal",
  description: "Je BitBox heeft het volgende willekeurige getal van {{bits}} bits gegenereerd:"
};
const receive$c = {
  bitsuranceWarning: "Dit is een verzekerde account, wat betekent dat het alleen kan ontvangen naar Native Segwit adressen. Dit is om te voorkomen dat je geen bitcoin naar adressen stuurt die niet gedekt zijn.",
  changeScriptType: "Adrestype wijzigen",
  label: "Jouw adres",
  onlyThisCoin: {
    description: "Om andere tokens te ontvangen, moet je deze inschakelen in de instellingen. Als je hier andere tokens stort, zijn ze mogelijk niet toegankelijk.",
    warning: "Zorg dat je alleen {{coinName}} op dit adres ontvangt."
  },
  scriptType: {
    p2tr: "Taproot (nieuwste adresformaat)",
    p2wpkh: "Native Segwit (standaard)",
    "p2wpkh-p2sh": "Wrapped Segwit (compatibiliteitsformaat)"
  },
  selectAccount: "Selecteer een account",
  showFull: "Toon het volledige adres op je BitBox om te verifiëren",
  taprootWarning: "Let op: Taproot is een nieuwe adressoort in Bitcoin en wordt nog niet op grote schaal gebruikt. Het kan bijvoorbeeld zijn dat bitcoin die op een Taproot-adres ontvangen wordt, niet weergegeven wordt in andere watch-only wallets. Veel andere wallets en exchanges kunnen ook nog niet naar Taproot-adressen zenden.",
  title: "{{accountName}} ontvangen",
  verify: "Verifieer veilig je adres ",
  verifyBitBox01: "Verifieer het adres op de mobiele app",
  verifyBitBox02: "Verifieer het adres op je BitBox02",
  verifyInstruction: "Verifieer of het volgende adres hetzelfde is als het adres wat op je BitBox wordt getoond.",
  warning: {
    secureOutput: "Koppel je BitBox met je mobiele telefoon om beveiligde adresverificatie in te schakelen. Ga hiervoor naar 'Apparaten beheren' in de zijbalk."
  }
};
const reset$a = {
  description: "Alle data zal van dit apparaat worden verwijderd, inclusief je privésleutel!",
  notReset: "Apparaat NIET gereset",
  title: "Fabrieksinstellingen terugzetten",
  understand: "Ik heb een backup en weet mijn herstelwachtwoord",
  understandBB02: "Ik heb een geldige backup"
};
const securityInformation$a = {
  create: {
    description1: "We raden je aan om je apparaat in te stellen in een veilige omgeving. Het belangrijkste is dat andere mensen niet kunnen zien welk wachtwoord je keist.",
    description2: "Je wordt gevraagd om twee wachtwoorden aan te maken.",
    description3: "Het eerste is het <strong>apparaatwachtwoord</strong>, wat je BitBox ontgrendeld. Dit kan later veranderd worden.",
    description4: "Het tweede is je <strong>herstelwachtwoord</strong>, wat je wallet ontgrendeld. Dit wachtwoord kan niet gewijzigd worden.",
    description5: "De wallet die je aanmaakt wordt gebackupt als bestand op de meegeleverde microSD kaart. Dit kan <strong>samen met je herstelwachtwoord</strong> gebruikt worden om je wallets te herstellen.",
    title: "Beveiligingsinformatie"
  },
  restore: {
    description1: "Je wordt gevraagd om de microSD kaart die je gebruikt hebt om je backup te maken in te voeren.",
    description2: "Om je apparaat te herstellen, heb je je herstelwachtwoord nodig.",
    description3: "Zorg ervoor dat je het juiste herstelwachtwoord invoert. Ongeacht wat je hier invoert, maak je een valide wallet aan. Als je een verkeerd wachtwoord invoert, krijg je waarschijnlijk een nieuwe, lege wallet te zien.",
    title: "Beveiligingsinformatie"
  }
};
const seed$a = {
  agreements: {
    "funds-access": "Ik kan NIET bij mijn wallets als ik mijn herstelwachtwoord vergeet",
    "password-change": "Ik kan het herstelwachtwoord NIET meer veranderen",
    "password-required": "Het hetstelwachtwoord is nodig om een wallet van een backup te herstellen"
  },
  create: "Wallet aanmaken",
  creating: "Wallet aanmaken...",
  description: "Ik heb het volgende gelezen en begrepen:",
  error: {
    e102: "Het wachtwoord moet uit ten minste vier karakters bestaan.",
    e200: "Je moet een microSD kaart in je BitBox invoeren om een wallet aan te maken, zodat er automatisch een backup gegenereerd kan worden."
  },
  info: {
    button: "Stel nu je herstelwachtwoord in",
    description1: "Voer de microSD kaart in de BitBox in",
    description2: 'Kies een herstelwachtwoord voor de wallet en selecteer "Herstelwachtwoord nu instellen"',
    description3: "De backup op je microSD kaart en je herstelwachtwoord zijn de enige manier om weer toegang te krijgen tot je wallet als je BitBox verloren raakt, gestolen wordt, of kapot gaat.",
    description4: "Je kunt je herstelwachtwoord niet veranderen zonder je balans over te zetten op een nieuwe wallet.",
    title: "Nieuwe wallet aanmaken"
  },
  password: {
    label: "Herstelwachtwoord",
    repeatPlaceholder: "Herstelwachtwoord herhalen"
  },
  walletName: {
    label: "Walletnaam"
  }
};
const seedRestore$a = {
  error: {
    e200: "Voor het herstellen van een backup is de microSD kaart nodig"
  },
  info: {
    description1: 'Voer de microSD kaart in de BitBox in en klik op "verder"',
    description2: 'Kies een backup en klik op "herstellen"',
    description3: "Voer het herstelwachtwoord in",
    description4: "Je moet bevestigen dat je begrijpt dat een verkeerd wachtwoord een nieuwe, andere wallet aanmaakt.",
    title: "Hoe herstel je een wallet vanuit een backup"
  }
};
const send$c = {
  abort: "De transactie is afgebroken",
  address: {
    label: "Adres van de ontvanger",
    placeholder: "Adres invoeren"
  },
  amount: {
    label: "Hoeveelheid",
    placeholder: "Hoeveelheid invoeren"
  },
  availableBalance: "Beschikbare balans",
  button: "Controle",
  coincontrol: {
    address: "Adres",
    outpoint: "Output",
    title: "Verstuur uit output"
  },
  confirm: {
    "selected-coins": "Geselecteerde coins",
    title: "Bevestigen & transactie versturen",
    total: "Totaal"
  },
  error: {
    erc20InsufficientGasFunds: "Je hebt niet genoeg Ether in je wallet voor deze transactie. Stort meer Ether in je wallet om de transactie uit te voeren.",
    feeTooLow: "netwerkkosten te laag",
    feesNotAvailable: "Schatting van netwerkkosten niet beschikbaar",
    insufficientFunds: "ontoereikende balans",
    invalidAddress: "ongeldig adres",
    invalidAmount: "ongeldige hoeveelheid",
    invalidData: "ongeldige data"
  },
  fee: {
    customPlaceholder: "Hoeveelheid invoeren",
    label: "Netwerkkosten",
    placeholder: "Niet beschikbaar"
  },
  feeTarget: {
    customLabel: "Netwerktarief",
    customLabel_eth: "Gas-prijs",
    description: {
      economy: "4 uur (24 blokken)",
      economy_eth: "30 minuten of minder",
      economy_ltc: "1 uur (24 blokken)",
      high: "20 minuten (2 blokken)",
      high_eth: "30 seconden of minder",
      high_ltc: "5 minuten (2 blokken)",
      low: "2 uur (12 blokken)",
      low_eth: "5 minuten of minder",
      low_ltc: "30 minuten (12 blokken)",
      normal: "1 uur (6 blokken)",
      normal_eth: "2 minuten of minder",
      normal_ltc: "15 minuten (6 blokken)"
    },
    estimate: "Geschatte bevestigingstijd:",
    label: {
      custom: "Eigen selectie",
      economy: "Budget",
      high: "Hoog",
      low: "Laag",
      normal: "Normaal"
    },
    placeholder: "Netwerkkosten berekenen..."
  },
  maximum: "Alles verzenden",
  maximumSelectedCoins: "Geselecteerde coins verzenden",
  noFeeTargets: "Schattingen van de transactiekosten zijn op dit moment niet beschikbaar. Probeer het later opnieuw of stel zelf de hoogte in.",
  priority: "Prioriteit",
  scanQR: "QR-code scannen",
  signprogress: {
    description: "Dit is een transactie die veel data in zich heeft. Om de transactie te verzenden, word je gevraagd om {{steps}} keer te ondertekenen.",
    label: "Voortgang"
  },
  success: "De transactie is ondertekend en verzonden.",
  title: "Verstuur {{accountName}}",
  toggleCoinControl: "Coin control aan/uitzetten",
  transactionDetails: "Transactiedetails"
};
const settings$b = {
  about: "Over",
  accounts: "Accounts",
  advancedSettings: "Geavanceerde instellingen",
  appearance: "Uiterlijk",
  electrum: {
    add: "Server toevoegen",
    "add-server": "Toevoegen",
    check: "Controleer",
    checkFailed: "Niet geslaagd",
    checkSuccess: "Verbinding met {{host}} tot stand gebracht",
    checking: "Aan het controleren",
    "download-cert": "Remote certificate downloaden",
    "remove-server": "Verwijderen",
    removeConfirm: "Wil je {{server}} verwijderen?",
    reset: "Terugzetten naar standaardinstelling",
    resetConfirm: "Wil je alle servers verwijderen en de standaard-servers instellen?",
    servers: "Servers",
    step1: "1",
    "step1-text": "Voer het eindpunt in.",
    step2: "2",
    "step2-text": "Voer een certificaat van de server in. Je kunt ook het remote certificate downloaden en het op het oog inspecteren.",
    "step2-text-tcp": "Je kunt deze stap overslaan als je geen TLS wilt gebruiken.",
    step3: "3",
    "step3-text": "Controleer de verbinding en voeg de server toe.",
    step4: "4",
    "step4-text": "Start de wallet opnieuw op. Als je de standaard servers niet verwijderd, wordt je eigen node als backup-server toegevoegd.",
    "title-btc": "",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: "Coin control aanzetten",
    electrum: {
      description: "Je kunt hier met je eigen Electrum-fullnode verbinden.",
      title: "Verbind met je eigen full node"
    },
    fee: "Custom fees aanzetten",
    setProxyAddress: "Proxy adres instellen",
    title: "Geavanceerde instellingen",
    useProxy: "Tor proxy aanzetten",
    useSats: "BTC-waarde in Satoshis weergeven"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nieuwe update beschikbaar ",
    title: "Info",
    "up-to-date": "Je app is bijgewerkt",
    version: "App versie"
  },
  restart: "Start de BitBoxApp opnieuw op om de veranderde instellingen in te schakelen.",
  services: {
    title: "Diensten"
  },
  success: "Voer de BitBox opnieuw in om de veranderde instellingen in te schakelen.",
  title: "Instellingen"
};
const setup$a = "Apparaat instellen";
const sidebar$b = {
  buy: "Crypto kopen",
  device: "Apparaat beheren",
  insurance: "Verzekering",
  leave: "Verlaten",
  settings: "Instellingen"
};
const success$h = {
  create: {
    info1: "Je wallet is veilig gebackupt op de microSD kaart. Verwijder deze en bewaar hem op een veilige plek.",
    info2: "Je hebt een veilig apparaatwachtwoord aangemaakt dat de BitBox ontgrendelt.",
    info3: "Je hebt een veilig herstelwachtwoord voor je wallet aangemaakt die je wallet ontgrendeld en nodig is om je backups te herstellen.",
    summary: "Hier is een samenvatting van wat je gedaan hebt",
    title: "Gelukt"
  },
  getstarted: "Get started",
  restore: {
    summary: "Je hebt je wallet vanuit je backup hersteld",
    title: "Gelukt"
  }
};
const transaction$b = {
  confirmation: "Bevestigingen",
  details: {
    activity: "Activiteit",
    address: "Adres",
    amount: "Hoeveelheid",
    date: "Datum",
    fiat: "Fiat",
    fiatAmount: "Hoeveelheid in fiat",
    fiatAtTime: "Fiat-waarde ten tijde van de transactie",
    status: "Status",
    title: "Transactiedetails",
    type: "Type"
  },
  explorer: "Transactie-ID",
  explorerTitle: "In externe block explorer openen",
  fee: "Netwerkkosten",
  fiatHistorical: "Historie",
  gas: "Gas",
  note: {
    edit: "Notitie aanpassen",
    save: "Notitie opslaan"
  },
  pending: "Transactie in afwachting",
  size: "Grootte",
  status: {
    complete: "Afgerond",
    failed: "Niet gelukt",
    pending: "In afwachting"
  },
  tx: {
    received: "Ontvangen naar",
    sent: "Verzonden naar"
  },
  vsize: "Virtuele grootte",
  weight: "Gewicht"
};
const transactions$a = {
  errorLoadTransactions: "Er is een fout opgetreden bij het laden van de transacties",
  placeholder: "Nog geen transacties"
};
const unknownError$a = "Er is een onbekende fout opgetreden: {{errorMessage}}";
const unlock$a = {
  description: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen",
  error: {
    e109_normal: "Apparaatwachtwoord onjuist. Je hebt nog {{remainingAttempts}} over voordat je BitBox wordt gereset.",
    e109_touch: "$t(unlock.error.e109_normal) Met de volgende login moet je de touchknop ingedrukt houden.",
    e113: "Omdat je tevaak geprobeerd hebt in te loggen, moet je de touchknop 4 seconden ingedrukt houden bij de volgende login."
  },
  input: {
    label: "Apparaatwachtwoord",
    placeholder: "Voer je apparaatwachtwoord in om je BitBox te ontgrendelen"
  },
  unlocking: "Ontgrendelen..."
};
const upgradeFirmware$b = {
  button: "Firmware updaten",
  description: "Wil je de firmware updaten van versie {{currentVersion}} naar versie {{newVersion}}?",
  label: "Je BitBox heeft een firmwareupdate nodig.",
  locked: "Hou de touchknop lang ingedrukt om van {{currentVersion}} naar {{newVersion}} te updaten.",
  title: "Firmware updaten",
  unlocked: "De bootloader is ontgrendeld. Om door te gaan:",
  unlocked1: "Voer je BitBox opnieuw in",
  unlocked2: "Het LED lichtje gaat branden als je BitBox opnieuw is ingevoerd",
  unlocked3: "Klik op de touchknop wanneer het LED lichtje gaat branden"
};
const walletConnect$6 = {
  connect: {
    button: "Verbinden",
    dappLabel: "Voer het URI-address van de DApp in",
    invalidPairingUri: "Ongeldige koppel-URI"
  },
  dashboard: {
    allSessions: "Alle sessies",
    disclaimer: "WalletConnect is een protocol om met op Ethereum gebaseerde DApps te verbinden. Deze DApps worden aangeboden door derder partijen, dus zorg ervoor dat je alleen met DApps verbindt die je vertrouwt. Zorg er ook altijd voor dat je weet wat je ondertekent als je een transactie aanmaakt.",
    newConnection: "Nieuwe verbinding",
    noConnectedSessions: "Geen van je accounts zijn op dit moment met een DApp verbonden."
  },
  invalidPairingChain: "Error met het toestaan van de koppeling. Zorg ervoor dat je een van deze ondersteunde chains gebruikt: {{chains}}",
  pairingRequest: {
    approve: "Koppeling goedkeuren",
    reject: "Afwijzen",
    title: "Nieuw koppelverzoek van"
  },
  pairingSuccess: "DApp met success verbonden. Je kunt verdergaan op de website van de DApp",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Data",
    dataParsingError: "Data kon niet verwerkt worden",
    decodeError: "Bericht kon niet gedecodeerd worden",
    method: {
      sendTransaction: "Transactie ondertekenen en verzenden",
      signMessage: "Bericht ondertekenen",
      signTransaction: "Transactie ondertekenen",
      signTypedData: "Ingevoerde data ondertekenen"
    },
    successfullySigned: "Verzoek ondertekend",
    walletConnectRequest: "WalletConnect verzoek"
  },
  useNewUri: "Deze URI is al gebruikt om een verbinding te maken. Gebruik alsjeblieft een nieuwe URI.",
  walletConnect: "WalletConnect"
};
const warning$g = {
  receivePairing: "Koppel de BitBox om beveiligde adresverificatie in te schakelen. Ga naar 'Apparaat beheren' in de sidebar.",
  sdcard: "Bewaar de microSD kaart apart van de BitBox, tenzij je je backups aan het beheren bent.",
  sendPairing: "Koppel de BitBox om je transactiedetails beveiligd te kunnen verifiëren. Ga naar 'Manage device' in de sidebar."
};
const welcome$a = {
  connect: "Verbind je BitBox02",
  getStarted: "Laten we beginnen door de firmware op je BitBox02 te installeren.",
  insertBitBox02: "Tap de touch-sensoren op je BitBox02 om door te gaan.",
  insertDevice: "Verbind je BitBox om te starten",
  title: "Welkom"
};
const appTranslationsNL = {
  account: account$a,
  accountInfo: accountInfo$a,
  accountSummary: accountSummary$a,
  addAccount: addAccount$b,
  aopp: aopp$4,
  app: app$a,
  auth: auth$5,
  backup: backup$a,
  bb02Bootloader: bb02Bootloader$a,
  bitbox: bitbox$a,
  bitbox02Interact: bitbox02Interact$a,
  bitbox02Settings: bitbox02Settings$a,
  bitbox02Wizard: bitbox02Wizard$a,
  bitsurance: bitsurance$4,
  bitsuranceAccount: bitsuranceAccount$4,
  blink: blink$a,
  bootloader: bootloader$a,
  button: button$f,
  buy: buy$6,
  changePin: changePin$a,
  chart: chart$6,
  checkSDcard: checkSDcard$a,
  clickHere: clickHere$a,
  confirm: confirm$c,
  confirmOnDevice: confirmOnDevice$a,
  connectKeystore: connectKeystore$5,
  darkmode: darkmode$5,
  device: device$a,
  deviceLock: deviceLock$a,
  deviceSettings: deviceSettings$a,
  deviceTampered: deviceTampered$a,
  dialog: dialog$b,
  error: error$6,
  fiat: fiat$c,
  footer: footer$c,
  generic: generic$6,
  genericError: genericError$a,
  goal: goal$a,
  guide: guide$b,
  headerssync: headerssync$a,
  hiddenWallet: hiddenWallet$a,
  initialize: initialize$a,
  invalidFormat: invalidFormat$a,
  language: language$b,
  legacyhiddenwallet: legacyhiddenwallet$a,
  loading: loading$a,
  manageAccounts: manageAccounts$4,
  mobile: mobile$5,
  newSettings: newSettings$4,
  note: note$6,
  notification: notification$a,
  pairing: pairing$a,
  passphrase: passphrase$4,
  password: password$a,
  random: random$b,
  receive: receive$c,
  reset: reset$a,
  securityInformation: securityInformation$a,
  seed: seed$a,
  seedRestore: seedRestore$a,
  send: send$c,
  settings: settings$b,
  setup: setup$a,
  sidebar: sidebar$b,
  success: success$h,
  transaction: transaction$b,
  transactions: transactions$a,
  unknownError: unknownError$a,
  unlock: unlock$a,
  upgradeFirmware: upgradeFirmware$b,
  walletConnect: walletConnect$6,
  warning: warning$g,
  welcome: welcome$a
};
const account$9 = {
  disconnect: "Conexão perdida. Tentando novamente...",
  "export": "Exportar",
  exportTransactions: "Exportar transações para a pasta Downloads como um arquivo CSV.",
  fatalError: "Ocorreu um erro inesperado.",
  incoming: "Lançamentos",
  initializing: "Obtendo informações da blockchain...",
  insuranceExpired: "<strong>A conta não está mais segurada</strong>\n\nO plano de seguro para esta conta foi modificado.\nPor favor, verifique a página do seguro para obter detalhes.",
  insured: "Conta segurada",
  maybeProxyError: "Tor proxy ativado. Certifique-se que seu Tor esteja rodando corretamente ou desative as opções de proxy.",
  reconnecting: "Conexão perdida, tentando reconectar...",
  syncedAddressesCount: "Encontrado {{count}} endereços",
  uncoveredFunds: "Você tem moedas nos seguintes tipos de endereços descobertos da sua conta <strong>{{name}}</strong>: {{uncovered}}.\nUma vez que a conta está segurada, apenas as moedas recebidas através do tipo de endereço <strong>Segwit nativo</strong> são cobertas. Moedas em outros tipos de endereços, mesmo que estejam na mesma conta, não estão seguradas.\nMova todas as suas moedas dos tipos de endereço não suportados para o tipo de endereço <strong>Segwit nativo</strong> para que todas as suas moedas nesta conta fiquem seguradas.",
  uncoveredFundsLink: "Siga este guia sobre como mover suas moedas.",
  warning: "Aviso!"
};
const accountInfo$9 = {
  address: "Endereço",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Cripto",
    information: {
      looksEmpty: "Parece que esta carteira está vazia.",
      start: "Comece depositando algumas moedas na carteira ou comprando diretamente no BitBoxApp."
    }
  },
  extendedPublicKey: "Chave pública estendida",
  label: "Informações da conta",
  scriptType: "Tipo de script",
  title: "Informações da conta",
  verify: "Verificar no dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizar chave P2PKH pública estendida já existente.",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Segwit Nativo",
    "p2wpkh-p2sh": "Veja a chave pública estendida do Segwit mais antiga"
  },
  xpubTypeInfo: "Atualmente mostrando {{scriptType}} chave pública estendida ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$9 = {
  availableBalance: "Saldo disponível",
  balance: "Saldo",
  exportSummary: "Exportar resumo de contas para a pasta de Downloads como um arquivo CSV",
  fiatBalance: "Saldo em moeda corrente",
  name: "Nome da conta",
  noAccount: "Não há contas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Meu portfólio",
  total: "Total",
  transactionHistory: "Histórico de transações"
};
const addAccount$a = {
  chooseName: {
    nextButton: "Adicionar conta",
    step: "Nome conta",
    title: "Um nome para sua conta"
  },
  selectCoin: {
    nextButton: "Próximo",
    step: "Selecione a moeda",
    title: "Selecione a crypto."
  },
  success: {
    addAnotherAccount: "Adicionar outra conta",
    message: "<strong>{{accountName}}</strong> foi addicionado agora as suas contas.",
    nextButton: "Pronto",
    step: "Terminado",
    title: "Conta adicionada"
  },
  title: "Adicionar conta"
};
const aopp$3 = {
  addressRequest: "{{host}} está solicitando um endereço de recebimento.",
  addressRequestWithLogo: "está solicitando um endereço de recebimento",
  banner: "Solicitação de endereço em andamento. Conecte seu dispositivo para continuar.",
  errorTitle: "Erro durante a solicitação de endereço",
  labelAddress: "Endereço",
  labelMessage: "Mensagem",
  reverifyInfoText: "Verificar endereço",
  signing: "Para prosseguir, assine a mensagem na sua BitBox02",
  success: {
    message: "Prossiga em {{host}}",
    title: "Endereço enviado com sucesso"
  },
  syncing: "Sincronizando a conta, aguarde.",
  title: "Solicitação de endereço"
};
const app$9 = {
  upgrade: "Uma nova versão desse app está disponível! Por favor, atualize de {{current}} para {{version}}."
};
const auth$4 = {
  authButton: "Autenticar",
  title: "Autentique-se para continuar"
};
const backup$9 = {
  check: {
    checking: "Checando backup...",
    confirmTitle: "Checar backup",
    notOK: "O Backup NÃO corresponde à carteira.",
    ok: "Backup corresponde à carteira.",
    password: {
      label: "Senha de recuperação",
      placeholder: "Senha de recuperação",
      showLabel: "senha de recuperação"
    },
    success: "Backup verificado com sucesso:",
    title: "Checar backup"
  },
  create: {
    alreadyExists: "Você já tem um backup válido. Você deseja recriá-lo?",
    fail: "A criação do backup FALHOU!",
    info: "Por favor, digite a senha de recuperação da carteira atual para verificação.",
    name: {
      label: "Nome do backup",
      placeholder: "Por favor, nomeie o backup"
    },
    password: {
      label: "Senha de recuperação",
      placeholder: "Por favor, digite sua senha de recuperação"
    },
    title: "Criar backup",
    verificationFailed: "A senha de recuperação NÃO CORRESPONDE à carteira atual. O backup foi criado. Por favor, use 'Checar backup' para verificar sua senha de recuperação novamente."
  },
  description: "Selecione um <strong>arquivo de backup da carteira</strong>",
  insert: "Por favor, insira o cartão microSD para gerenciar backups.",
  insertButton: "Eu inseri o cartão microSD",
  list: "Os backups do seu cartão microSD",
  noBackups: "Não há backups neste cartão microSD.",
  restore: {
    confirmTitle: "Restaurar backup",
    error: {
      e200: "Cartão microSD não encontrado",
      general: "Erro ao restaurar o backup"
    },
    password: {
      label: "Senha de recuperação ou senha de recuperação oculta",
      placeholder: "Senha de recuperação",
      repeatPlaceholder: "Repita a senha de recuperação",
      showLabel: "Senha de recuperação"
    },
    restoring: "Restaurando o backup...",
    selectedBackup: "<strong>{{backupName}}</strong> criado em {{createdDateTime}} será restaurado.",
    title: "Restaurar",
    understand: "Eu entendo que uma senha de recuperação incorreta criará uma carteira diferente"
  },
  showMnemonic: {
    description: "Serão mostradas suas palavras de recuperação na sua BitBox02, que formam um backup de sua carteira. Anote-as em um papel.\n\n<strong>Não as armazene digitalmente nem tire fotos delas.</strong>\n\n<strong>Não diga as palavras em voz alta.</strong>\n\n<strong>Este backup não é protegido por senha.</strong>\n\nDepois disso, você será solicitado a confirmar cada palavra.",
    title: "Mostrar frase de recuperação",
    warning: "<strong>Nunca compartilhe suas palavras de recuperação com ninguém.</strong> Suas palavras de recuperação dão acesso total à sua carteira. Se alguém está pedindo suas palavras de recuperação, é um golpista, não as compartilhe!"
  },
  title: "Gerenciar backups"
};
const bb02Bootloader$9 = {
  abort: "Não atualizar - Leve-me de volta",
  abort_noUpgrade: "Me leve de volta",
  advanced: {
    label: "Configurações avançadas",
    toggleShowFirmwareHash: "Mostrar o hash de firmware toda vez na inicialização"
  },
  flipscreen: "Girar tela",
  orientation: "Dispositivo orientado de maneira errada?",
  success: "Atualização bem sucedida! Continuando em {{rebootSeconds}} segundos...",
  success_install: "Instalação com sucesso! Continuando em {{rebootSeconds}} segundos..."
};
const bitbox$9 = {
  error: {
    e10000: "Senha atual do dispositivo incorreta.",
    e10001: "Falha ao substituir a senha do dispositivo",
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e112: "A senha do dispositivo oculto não pode ser igual à senha do dispositivo principal."
  }
};
const bitbox02Interact$9 = {
  confirmDate: "Confirme a data de hoje em sua BitBox02",
  confirmDateText: "Esta data será usada para criar seu backup.",
  confirmName: "Confirme o nome na BitBox02",
  confirmWords: "Escreva as {{amount}} palavras de recuperação da sua BitBox02",
  confirmWordsText: "Depois disso a BitBox02 pede para você confirmar cada palavra para verificar se o backup está correto.",
  followInstructions: "Por favor, siga as instruções na sua BitBox02.",
  followInstructionsMnemonic: "Siga as instruções em sua BitBox02 para inserir as palavras de recuperação de seu backup e restaurar sua carteira.",
  followInstructionsMnemonicTitle: "Restaurar a partir da frase de recuperação"
};
const bitbox02Settings$9 = {
  deviceName: {
    current: "Nome atual do dispositivo",
    error: "Não foi possível definir o nome do dispositivo",
    error_104: "A confirmação do nome do dispositivo foi interrompida no dispositivo.",
    input: "Nome da BitBox02",
    placeholder: "Novo nome de dispositivo",
    title: "Definir nome da BitBox02"
  },
  gotoStartupSettings: {
    description: "Isso reiniciará sua BitBox02 e entrará nas configurações de inicialização.",
    title: "Vá para as configurações de inicialização"
  }
};
const bitbox02Wizard$9 = {
  advanced: {
    button: "Opções avançadas",
    outOfDate: "Firmware desatualizado para este recurso",
    seed12WordInfo: "Observe que o número de palavras não pode ser alterado após a criação da carteira.",
    seed12WordLabel: "Criar uma semente de 12 palavras em vez de 24 palavras",
    seed12WordText: "Por padrão, a BitBox02 usa uma semente de 24 palavras. Ambos os tamanhos de sementes são seguros contra força bruta na prática. Alguns usuários podem preferir a conveniência da semente de 12 palavras.",
    skipSDCardLabel: "Pule o backup do cartão microSD e anote as palavras de recuperação",
    skipSDCardText: "Você sempre tem a opção de criar um backup em um cartão microSD ou escrever suas palavras de recuperação após a configuração. Isso pode ser feito nas configurações.",
    title: "Opções avançadas de backup"
  },
  attestationFailed: "Falha na verificação do dispositivo, o que pode ter ocorrido ao reniciar o app enquanto o dispositivo estava esperando uma entrada do usuário. Por favor, reconecte e tente novamente. Entre em contato com support@bitbox.swiss se a falha persistir.",
  backup: {
    point1: "Selecione um backup no cartão microSD",
    point2: "Defina uma senha para o seu dispositivo",
    restoreText: "Ok, vamos restaurar um backup!",
    text1: "Ótimo, sua senha da BitBox02 foi definida e a carteira foi criada. Agora é hora de criar seu primeiro backup. Por favor, verifique se o seu cartão microSD está inserido na sua BitBox02 e continue.",
    text2: "Por favor, siga as instruções na tela do seu dispositivo para criar um backup.",
    text3: "Após o backup ser criado, remova o cartão microSD e armazene-o em um <strong>local seguro</strong>. O conteúdo do cartão microSD não é protegido por senha. Nunca insira em qualquer outro dispositivo além de sua BitBox02.",
    userConfirmation1: "Eu devo armazenar meu backup em um local seguro.",
    userConfirmation2: "Meu backup não é protegido por senha. Qualquer pessoa com acesso a ele pode acessar minha carteira.",
    userConfirmation3: "Se eu perder ou danificar minha BitBox02, a única maneira de recuperar meus fundos é restaurando do meu backup.",
    userConfirmation4: "Se eu perder ou danificar meu backup e minha BitBox02, meus fundos serão perdidos.",
    userConfirmation5: "Eu não devo colocar meu cartão de backup microSD em um computador, telefone, impressora ou qualquer dispositivo a não ser o BitBox02. ",
    userConfirmation5mnemonic: "Não devo colocar minhas palavras de recuperação em um computador, telefone, impressora ou qualquer outro dispositivo que não seja uma BitBox02."
  },
  create: {
    button: "Nomear dispositivo e continuar",
    info: "Aqui estão os passos básicos que você vai seguir para configurar a sua BitBox: ",
    inputTitle: "Nome da carteira",
    point1: "Nomear seu dispositivo",
    point2: "Definir uma senha para o seu dispositivo",
    point3: "Criar um backup",
    text: "Ok, vamos criar uma nova carteira!"
  },
  createBackupAborted: "Criação de backup abortada.",
  createBackupFailed: "Falha na criação do backup, tente novamente.",
  initialize: {
    passwordText: "Agora vamos definir uma senha para o seu dispositivo. Use os controles da sua BitBox para entrar e escolher uma senha.",
    passwordTitle: "Definir uma senha para a sua BitBox",
    text: "Sucesso ao emparelhar sua BitBox02! Agora vamos inicializar seu dispositivo. Comece escolhendo criar uma nova carteira ou restaurar uma carteira a partir de um backup existente. <strong>Por favor, verifique se você tem um cartão microSD inserido na sua BitBox02</strong>",
    tip: "Recomendamos que você proceda em um ambiente seguro.",
    title: "Inicialize sua BitBox"
  },
  insertSDCard: "<strong>Por favor, verifique se você tem um cartão microSD inserido em sua BitBox02.</strong>",
  noPasswordMatch: "Senhas não conferem, tente novamente.",
  pairing: {
    failed: "Pareamento não confirmado. Por favor, reconecte sua BitBox02.",
    paired: "Você confirmou o seguinte código em seu dispositivo. Por favor continue.",
    title: "Verificar o código de pareamento",
    unpaired: "Uma BitBox02 não pareada foi detectada. Verifique se o código de pareamento corresponde ao que é mostrado em sua BitBox02."
  },
  restoreFromMnemonic: {
    e104: "A restauração a partir das palavras de recuperação foi cancelada.",
    failed: "A restauração a partir da frase de recuperação falhou, por favor, tente novamente."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, leia estas importantes considerações de segurança:",
    createBackup: "Agora você criará um backup no seu cartão microSD.",
    createBackupMnemonic: "Agora você anotará as palavras de recuperação."
  },
  stepBackupSuccess: {
    fundsSafe: "Para manter seus fundos seguros, lembre-se do seguinte:",
    title: "Backup restaurado!"
  },
  stepConnected: {
    unlock: "Digite a senha da BitBox02 para desbloquear."
  },
  stepCreate: {
    description: "Este nome é usado como o nome do dispositivo e para o backup.",
    nameLabel: "Nome da BitBox02",
    namePlaceholder: "Minha BitBox02",
    title: "Escolha o nome da BitBox02",
    toastMicroSD: "Por favor, insira seu cartão microSD em sua BitBox02, que será usado para armazenar um backup da carteira."
  },
  stepCreateSuccess: {
    removeMicroSD: "Remova o cartão microSD de sua BitBox02 e guarde-o em um local seguro.",
    storeMnemonic: "Guarde suas palavras de recuperação em um local seguro",
    success: ""
  },
  stepInsertSD: {
    insertSDCard: "Por favor insira um cartão microSD na sua BitBox02 para continuar.",
    insertSDcardTitle: "Insira cartão microSD."
  },
  stepPassword: {
    e104: "A definição da senha foi cancelada.",
    title: "Definir senha da BitBox02",
    useControls: "Use os controles em sua BitBox02 para definir uma senha."
  },
  stepUninitialized: {
    create: "Quero configurar uma nova BitBox02.",
    restore: "Quero restaurar minha carteira a partir de um backup.",
    restoreMicroSD: "Restaurar a partir do cartão microSD",
    restoreMnemonic: "Restaurar a partir da frase de recuperação",
    title: "Configure sua BitBox02"
  },
  success: {
    text: "Oba! Sua BitBox02 agora está pronta para uso.\n\nPara obter mais informações sobre como usar o BitBoxApp, use o guia no aplicativo clicando no ponto de interrogação no canto superior direito.",
    title: "Você está pronto para começar!"
  }
};
const bitsurance$3 = {
  dashboard: {
    active: "Apólice de seguro ativa",
    button: "Faça seguro de uma nova conta",
    canceled: "Cancelado",
    coverage: "Cobertura máxima",
    inactive: "Inativo",
    processing: "Em processamento",
    refused: "Recusado",
    supportLink: "Gerenciar contrato",
    title: "Contas seguradas",
    waitpayment: "Aguardando pagamento"
  },
  detect: {
    button: "Verificar se há seguro existente",
    insured: "Conta segurada detectada:",
    notInsured: "Nenhuma conta segurada detectada. Se você tiver certeza de que possui uma conta segurada, certifique-se de ter a carteira correta conectada.",
    text: "Se você já se cadastrou no Bitsurance, o BitBoxApp pode sincronizar automaticamente sua cobertura de seguro existente.",
    title: "Já está segurado?"
  },
  insure: {
    button: "Verificar disponibilidade e preços",
    faq: "Leia mais sobre perguntas frequentes sobre Bitsurance",
    listItem1: "Roubo",
    listItem2: "Extorsão (por exemplo, $5 wrench attack)",
    listItem3: "Destruição devido a incêndio, água ou desastres naturais",
    month: "mês",
    text: "Faça seguro do sua BitBox02 e de até €100.000 em bitcoin contra",
    text2: "Os planos de seguro começam em 30€/ano (2,50€/mês). Você pode aprender mais sobre o Bitsurance e suas ofertas exatas de seguros no",
    text3: "Atualmente disponível na Alemanha, com mais regiões a seguir.",
    title: "Começar"
  },
  intro: {
    link: "Site do Bitsurance",
    text1: "A BitBox trabalha com Bitsurance para adicionar uma camada adicional de proteção ao seu bitcoin. Enquanto a BitBox02 mantém seus fundos seguros, o Bitsurance cobre ameaças domésticas que não podem ser mitigadas apenas com tecnologia, como roubo, extorsão ou destruição da própria carteira de hardware."
  },
  terms: {
    link: "Política de Privacidade do Bitsurance",
    text1: "Bitsurance é um serviço terceirizado independente. Para perguntas sobre suas ofertas e reivindicações de seguro, entre em contato diretamente com o Bitsurance.",
    text2: "O seguro está atualmente disponível na Alemanha, com mais regiões a seguir.",
    text3: "A cobertura máxima de Bitcoin atualmente disponível é de 100.000 euros por pessoa. Montantes mais elevados estão previstos para o futuro.",
    text4: "As informações pessoais e a chave pública estendida da sua conta segurada fazem parte da apólice de seguro e serão compartilhadas com o Bitsurance e a seguradora.",
    text5: "Para mais informações sobre privacidade, consulte a"
  },
  title: "Seguro"
};
const bitsuranceAccount$3 = {
  errorNoXpub: "Erro: não foi possível obter o xpub da conta.",
  noAccount: "Não há contas que possam ser seguradas.",
  select: "Selecione a conta",
  title: "Seguro"
};
const blink$9 = {
  button: "Piscar"
};
const bootloader$9 = {
  button: "Atualizar firmware agora",
  button_install: "Instale o firmware agora",
  progress: "Atualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Atualização bem sucedida! Por favor, insira novamente o dispositivo. Desta vez, não toque no botão."
};
const button$e = {
  abort: "Abortar",
  back: "Voltar",
  buy: "Comprar",
  changepin: "Mudar senha do dispositivo",
  check: "Checar backup",
  "continue": "Continuar",
  copy: "Copiar",
  create: "Criar",
  dismiss: "Dispensar",
  done: "Pronto",
  download: "Baixar",
  hiddenwallet: "Criar carteira oculta",
  next: "Próximo",
  ok: "OK",
  previous: "Anterior",
  receive: "Receber",
  restore: "Restaurar",
  select: "Selecionar",
  send: "Enviar",
  unlock: "Desbloquear",
  update: "Atualizar",
  upgrade: "Atualizar"
};
const buy$5 = {
  exchange: {
    bankTransfer: "Transferência bancária",
    bestDeal: "Melhor oferta",
    creditCard: "Cartão de crédito",
    fast: "Rápido",
    fee: "taxa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferência bancária: {{fee}}%",
          creditDebitCard: "Cartão de crédito/débito: {{fee}}%",
          learnMore: "Saiba mais sobre a Moonpay",
          title: "Taxas"
        },
        fullCurrenciesList: "Veja a lista completa de moedas aqui",
        payment: {
          asteriskText: "* Não disponível para residentes nos EUA",
          bankTransfer: "Transferência bancária*",
          bankTransferDetails: {
            pix: "PIX (transações BR somente no Brasil)",
            sepa: "SEPA e SEPA Instant (transações em EUR somente em países SEPA)",
            uk: "UK Faster Payments (transações em GBP somente no Reino Unido)"
          },
          creditDebitCard: "Cartão de crédito/débito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Veja mais detalhes sobre os métodos de pagamento",
          title: "Métodos de Pagamento"
        },
        supportedCurrencies: "Suporta todas as principais moedas fiduciárias: USD, EUR, CHF e outras."
      },
      pocket: {
        fees: {
          info: "Transferência bancária: {{fee}}%",
          title: "Taxas"
        },
        learnMore: "Saiba mais sobre a Pocket",
        payment: {
          bankTransfer: "Transferência bancária",
          bankTransferDetails: {
            sepa: "SEPA e SEPA Instant (transações em EUR somente em países SEPA)",
            sic: "Swiss Interbank Clearing (transações em CHF apenas em CH/LI)",
            uk: "UK Faster Payments (transações em GBP somente no Reino Unido)"
          },
          bankTransferReccuring: "Como configurar compras recorrentes com uma ordem permanente?",
          title: "Métodos de Pagamento"
        },
        supportedCurrencies: "Suporta moedas europeias: EUR, GBP e CHF.",
        verification: {
          info: "Requer apenas verificação de identidade acima dos limites diários e anuais.",
          link: "Encontre os limites atuais aqui",
          title: "Verificação de Identidade"
        }
      },
      region: {
        title: "Selecione a região em que sua conta bancária está registrada para ver quais opções estão disponíveis para você."
      }
    },
    noExchanges: "Desculpe, não há exchanges disponíveis nesta região.",
    region: "Região",
    selectRegion: "Não especificada",
    title: "Comprar {{name}}"
  },
  info: {
    "continue": "Concordo e continue",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Somos parceiros da MoonPay para oferecer a você um modo perfeito de comprar {{name}} diretamente para o BitBoxApp. Em apenas alguns cliques.",
        "MoonPay é uma plataforma simples e rápida para comprar {{name}} em mais de 160 países."
      ],
      payment: {
        details: "Você pode comprar {{name}} instantâneamente através da MoonPay com os seguintes métodos de pagamento. Compras com cartão de crédito ou débito são convenientes e instantâneas, mas são mais caras devido ao risco de estorno. Nós recomendamos que use a opção de transferência bancária para quantidades maiores. A taxa mínima é de 4 USD/EUR ou equivalente.",
        footnote: "Por favor perceba que as taxas da corretora MoonPay pode ser diferente das utilizadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
        table: {
          "1_description": "Taxas baixas podem levar até 3 dias úteis.",
          "1_method": "Transferência bancária (SEPA)",
          "2_description": "Taxas altas mas rápidas e instantâneas",
          "2_method": "Cartões de crédito & débito",
          description: "Descrição",
          fee: "Taxa",
          method: "Método"
        },
        title: "Métodos de pagamento e taxas"
      },
      privacyPolicy: "Política de privacidade da MoonPay",
      protection: {
        description: "O BitBoxApp não coleta nenhum dado quando você compra {{name}}, o saldo recebido é tratado como uma transação regular. A MoonPay precisa coletar alguns dados pessoais para a operação. A Política de Privacidade da MoonPay explica detalhadamente como esses dados são tratados.",
        descriptionGeneric: "O BitBoxApp não coleta nenhum dado quando você compra {{name}}, os fundos recebidos são tratados como uma transação normal. No entanto, as exchanges parceiras precisam coletar algumas informações para operar. Consulte suas respectivas políticas de privacidade para ver com mais detalhes como os dados são tratados.",
        title: "Proteção dos dados"
      },
      security: {
        description: "Quando você compra {{name}} através da MoonPay, você está usando um serviço externo. Esse serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e fora do ambiente de segurança onde o aplicativo BitBoxApp está rodando.",
        descriptionGeneric: "Quando você compra {{name}} através de uma exchange parceira, você está usando um serviço externo. Este serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e depende da proteção e segurança do ambiente em que o software BitBoxApp está sendo executado.",
        link: "Modelo de ameaças de segurança",
        title: "Modelo de segurança"
      },
      title: "Bem-vindo a sua loja virtual pessoal para comprar {{name}}"
    },
    next: "Próximo",
    selectLabel: "Seleciona sua conta",
    selectPlaceholder: "Selecione uma moeda",
    skip: "Não mostre novamente",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Política de privacidade da Pocket",
      p1: "O BitBoxApp não coleta nenhum dado ao comprar bitcoin, os fundos recebidos são tratados como uma transação regular. A Pocket precisa coletar alguns dados pessoais para operar. Sua Política de Privacidade explica em detalhes como esses dados são tratados.",
      title: "Proteção de dados"
    },
    kyc: {
      link: "Leia as perguntas frequentes da Pocket",
      p1: "A Pocket tenta manter o KYC no mínimo. Para compras abaixo de 950 EUR (1000 CHF) por dia, não são necessários documentos adicionais. Para compras acima desse valor, será necessário agendar uma ligação com a Pocket para concluir o processo KYC/AML necessário.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Você pode comprar bitcoin instantaneamente com a Pocket via transferência bancária SEPA. A taxa é de 1,5% e o bitcoin é depositado em sua BitBox o mais rápido possível após a Pocket receber a transferência bancária (geralmente no mesmo dia).",
      p2: "Observe que as taxas de câmbio da Pocket podem diferir daquelas usadas no BitBoxApp, resultando em valores ligeiramente diferentes.",
      title: "Métodos de pagamento e taxas"
    },
    previousTransactions: "O histórico de transações desta conta não está vazio. Compartilhar esta conta tornará todas as transações passadas e futuras visíveis para a Pocket. Continuar mesmo assim?",
    security: {
      link: "Modelo de ameaças de segurança da BitBox02",
      p1: "Ao comprar bitcoin via Pocket, você está usando um serviço externo. Este serviço está fora do escopo do modelo de ameaças de segurança da BitBox02 e depende da proteção e segurança do ambiente em que o software BitBoxApp está sendo executado. No entanto, trabalhamos juntos para melhorar a segurança usando um mecanismo de autenticação de dois fatores para verificar o endereço em que você está recebendo.",
      title: "Modelo de segurança"
    },
    usedAddress: "O endereço {{address}} já foi usado, comece novamente com um novo endereço.",
    verifyBitBox02: "Verifique se o endereço que você recebeu por e-mail corresponde ao exibido em sua Bitbox. Se possível, você deve abrir o e-mail em um segundo dispositivo para maior segurança.",
    welcome: {
      p1: "Fizemos parceria com a Pocket para oferecer a você uma maneira perfeita de comprar bitcoin diretamente no BitBoxApp. São apenas alguns cliques.",
      p2: "Pocket é uma plataforma suíça que facilita e agiliza a compra de bitcoin na maior parte da Europa (em qualquer lugar onde as transferências bancárias SEPA sejam suportadas).",
      p3: "Com a Pocket, você também pode fazer compras regulares por meio de ordens bancárias recorrentes, para poder fazer DCA (dollar-cost averaging) com facilidade.",
      title: "Bem-vindo ao seu balcão único para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
};
const changePin$9 = {
  newTitle: "Nova senha do dispositivo",
  oldLabel: "Senha atual do dispositivo"
};
const chart$5 = {
  dataMissing: "Buscando dados históricos... fique ligado.",
  dataOldTimestamp: "Atualização das taxas de câmbio históricas. O gráfico não está exibindo dados após {{time}}.",
  dataUpdating: "atualizando dados...",
  filter: {
    all: "Todos",
    month: "Mês",
    week: "Semana",
    year: "Ano"
  }
};
const checkSDcard$9 = "checando cartão microSD";
const clickHere$9 = "Clique aqui.";
const confirm$b = {
  abortInfo: "Toque para ",
  abortInfoRedText: "abortar",
  approveInfo: "Segure 4 segundos ou mais para ",
  approveInfoGreenText: "confirmar",
  info: "Prossiga na sua BitBox.",
  infoWhenPaired: "Primeiro no celular emparelhado e depois na sua BitBox"
};
const confirmOnDevice$9 = "Por favor, confirme no seu dispositivo.";
const connectKeystore$4 = {
  promptNoName: "Por favor conecte sua BitBox02 para continuar",
  promptWithName: 'Por favor conecte sua BitBox02 chamada "{{name}}" para continuar'
};
const darkmode$4 = {
  toggle: "Modo escuro"
};
const device$9 = {
  appUpradeRequired: "Sua BitBox não é compatível com este aplicativo. Por favor, baixe e instale a versão mais recente.",
  keystoreConnected: "Carteira conectada"
};
const deviceLock$9 = {
  button: "Ativar autorização de dois fatores (2FA)",
  condition1: "Você tem um backup?",
  condition2: "A verificação pelo aplicativo de celular está funcionando?",
  condition3: "2FA DESATIVA backups e emparelhamento de aplicativos móveis. O dispositivo precisa ser RESETADO para sair do 2FA!",
  confirm: "Ativar autorização de dois fatores (2FA)",
  title: "Ativar autorização de dois fatores (2FA)"
};
const deviceSettings$9 = {
  backups: {
    manageBackups: {
      description: "Criar ou verificar o backup do cartão microSD."
    },
    showRecoveryWords: {
      description: "Mostrar e verificar palavras de recuperação."
    },
    title: "Backups"
  },
  deviceInformation: {
    attestation: {
      description: "O BitBoxApp verifica se o seu dispositivo é autêntico."
    },
    deviceName: {
      description: "Altere o nome do seu dispositivo."
    },
    rootFingerprint: {
      description: "A impressão digital raiz é um identificador exclusivo da carteira atualmente em uso. Pode ajudá-lo a distinguir entre diferentes carteiras se você usar frases secretas."
    },
    securechip: {
      description: "O modelo do chip seguro."
    },
    title: "Informações do dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Redefina seu dispositivo para as configurações de fábrica. Isso exclui a carteira de sua BitBox02!",
      title: "Restauração de fábrica"
    },
    goToStartupSettings: {
      description: "Acesse o bootloader da BitBox02. Você pode habilitar o hash do firmware aqui."
    },
    passphrase: {
      description: "Ative ou desative o recurso de frase secreta.",
      title: "Frase secreta"
    }
  },
  firmware: {
    firmwareVersion: "Versão do firmware",
    newVersion: {
      label: "Versão disponível"
    },
    title: "Firmware",
    upToDate: "Seu dispositivo está atualizado",
    upgradeAvailable: "Nova atualização disponível",
    version: {
      label: "Versão"
    }
  },
  hardware: {
    attestation: {
      "false": "Falha na verificação de autenticidade",
      label: "Verificação de autenticidade",
      "true": "Sua BitBox02 é autêntica"
    },
    sdcard: {
      "false": "Não inserido",
      label: "Cartão microSD",
      "true": "Inserido"
    },
    securechip: "Chip seguro",
    title: "Hardware"
  },
  loading: "Recuperando informações do dispositivo...",
  pairing: {
    lock: {
      "false": "Desativado",
      label: "Autorização de dois fatores (2FA)",
      "true": "Ativado"
    },
    mobile: {
      "false": "Fechado",
      label: "Aplicativo móvel",
      "true": "Abrir"
    },
    status: {
      "false": "Não emparelhado",
      label: "Status",
      "true": "Emparelhado"
    },
    title: "Emparelhamento"
  },
  secrets: {
    manageBackups: "Gerenciar backups",
    title: "Privacidade"
  }
};
const deviceTampered$9 = "Sua BitBox foi fornecida com uma senha de recuperação? Se sim, pare o processo de configuração e contate o suporte imediatamente. A Shift nunca lhe dará uma carteira pronta ou fará recomendações de senha.";
const dialog$a = {
  cancel: "Cancelar",
  confirm: "Confirmar",
  confirmTitle: "Confirmação"
};
const error$5 = {
  accountAlreadyExists: "A conta já existe.",
  accountLimitReached: "Não foi possível adicionar a conta. O número máximo de contas para essa moeda foi atingido.",
  aoppCallback: "Ocorreu um erro ao entregar o endereço para {{host}}.",
  aoppInvalidRequest: "Pedido inválido.",
  aoppNoAccounts: "Não há contas disponíveis.",
  aoppSigningAborted: "Solicitação de propriedade de endereço cancelada.",
  aoppUnknown: "Ocorreu um erro desconhecido.",
  aoppUnsupportedAsset: "O ativo não é compatível.",
  aoppUnsupportedFormat: "Não há contas disponíveis que suportem o formato de endereço solicitado.",
  aoppUnsupportedKeystore: "O dispositivo conectado não pode assinar mensagens para este ativo.",
  aoppVersion: "Versão desconhecida.",
  wrongKeystore: "Carteira errada conectada. Certifique-se de inserir o dispositivo correto que corresponde a esta conta.",
  wrongKeystore2: " Se você estiver usando a frase secreta opcional, certifique-se de ter digitado a frase secreta correta para a conta."
};
const fiat$b = {
  "default": "padrão",
  setDefault: "Definir {{code}} como padrão",
  title: "Moedas"
};
const footer$b = {
  appVersion: "Versão do aplicativo:"
};
const generic$5 = {
  enabled_false: "Desabilitado",
  enabled_true: "Habilitado"
};
const genericError$9 = "Um erro ocorreu. Se você notar algum problema, por favor, reinicie o aplicativo.";
const goal$9 = {
  buttons: {
    create: "Criar uma nova carteira",
    restore: "Restaurar uma carteira de um backup"
  },
  paragraph: "Por favor, selecione uma das seguintes opções:",
  step: {
    "1": {
      title: "Informação de segurança"
    },
    "2": {
      description: "Definir uma senha do dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Criar uma nova carteira",
      title: "Carteira"
    },
    "3-restore": {
      description: "de um backup",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumo"
    },
    "4-restore": {
      title: "Resumo"
    }
  }
};
const guide$a = {
  accountDescription: {
    text: 'A visão geral da sua conta mostra seu saldo disponível, além de transações de entrada e saída. Nosso guia em "Configurações" contém mais informações sobre cada tipo de conta. ',
    title: "O que esta página me mostra?"
  },
  accountFiat: {
    text: "Sim. Clique em qualquer código para alternar entre moedas fiduciárias. Você pode alterar a lista de moedas nas configurações.",
    title: "Posso exibir outras taxas de conversão?"
  },
  accountIncomingBalance: {
    text: "Lançamentos soma os valores transferidos para você ainda não confirmados pela rede.",
    title: "O que significa lançamentos?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Cada xpub é atrelado ao "Tipo" mostrado: tanto o "Segwit Nativo (bech32)" como ao "Wrapped Segwit" ou "Taproot" (somente Bitcoin). Esses são tipos de scripts usados pela {{coinName}}. O BitBoxApp combina eles, suportando múltiplos tipos de scripts na mesma conta. Por isso cada tipo de script te fornece um xpub diferente, existem vários xpubs por conta.\n\nSe você recebe constantemente em um tipo de endereço padrão (Segwit Nativo), você só precisa do xpub "bech32". Entretando, se você também recebe valores nos tipos "Wrapped Segwit" ou "Taproot", você precisa usar as chaves públicas estendidas do "Wrapped Segwit" e "Taproot" respectivamente.',
      title: "Por que tem vários xpubs?"
    },
    privacy: {
      text: "Para esse tipo específio de conta, a chave pública estendida revela seu histórico financeiro completo, seu saldo em conta e todas suas transações futuras. Mas a xpub não permite que ninguém gaste suas moedas.\n\nSe você fornecer sua xpub à alguém, você deverá ter em mente que essa pessoa ou empresa poderá ver todas as transações antigas da sua conta. Assim achamos uma boa idéia que você use essa conta somente para esse propósito e mantenha seus fundos salvos em contas diferentes dessa.",
      title: "Por que preciso manter minha xpub secreta?"
    },
    verify: {
      text: "Sim, é sempre uma boa idéia revisar sua xpub. Se alguma outra pessoa gerar um endereço de recebimento através da sua xpub para mandar seu dinheiro, isso é muito importante. Você precisa verificar no dispositivo para garantir que essa xpub pertence a você para que seus fundos não acabem indo para endereços errados e sejam perdidos.",
      title: "Preciso verificar minha xpub nesse dispositivo?"
    },
    xpub: {
      text: "Uma chave pública estendida (xpub) é uma chave-raiz da qual todos os endereços de recebimento de uma conta são derivados.\n\nEla é fornecida aqui para uso avançado e interoperabilidade com carteiras watch-only, como Electrum ou Sentinel. Se você recebeu de diferentes tipos de endereço, importe todos os formatos diferentes de xpub em sua carteira watch-only para ver todas as suas moedas.\n\nPor favor, note que que carteiras de terceiros podem não suportar xpubs do tipo Taproot ainda.",
      title: "O que é uma chave pública estendida?"
    }
  },
  accountRates: {
    text: "Nós atualizamos as taxas de câmbio a cada minuto no CoinGecko.",
    title: "Quais taxas de câmbio são aplicadas?"
  },
  accountReload: {
    text: "Não há necessidade. Suas informações de transação são atualizadas automaticamente.",
    title: "Posso recarregar o histórico de transações?"
  },
  accountSendDisabled: {
    text: 'O botão "Enviar" é ativado quando seu saldo for maior que zero.',
    title: "Por que não consigo enviar {{unit}}?"
  },
  accountSummaryAmount: {
    text: "O montante total é a soma de de saldo de todas sua contas crypto. Taxas de troca são obtidas através da coingecko.com.\n\nObs: Se você usa a MyEtherWallet para tokens ela não é suportada no BitBoxApp, por isso não será incluso no montante total mostrado.",
    title: "Como o valor total é calculado?"
  },
  accountSummaryDescription: {
    text: "Aqui você pode ver o desempenho do seu portfólio ao longo do tempo. Um resumo de suas contas crypto individuais é exibido abaixo do gráfico.",
    title: "O que essa página me mostra?"
  },
  accountTransactionAttributesBTC: {
    text: "Tamanho virtual: determina a taxa de rede. Você economizou com sucesso em taxas se for menor que o tamanho da transação.\nTamanho: tamanho real da transação em bytes quando serializado de acordo com a blockchain subjacente.\nPeso: uma nova métrica introduzida no Segwit para avaliar os tamanhos de transação e bloco. Cada segregated witness (segwit) byte conta como um, todo o resto como quatro unidades de peso. Em vez de um megabyte em tamanho real, o limite de tamanho do bloco agora é de quatro milhões de unidades de peso.",
    title: "E os detalhes da transação específica do Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmações: sua primeira transmissão de transação não é confirmada até que um minerador a inclua em um bloco, isso só acontece após uma confirmação. Cada bloco transmitido na rede adiciona outra confirmação à sua transação. Geralmente, os comerciantes e outros agentes da rede somente liquidam transações com três a seis confirmações.\nID da transação: um número de identificação exclusivo que permite procurar uma transação em um explorador de blocos.\nTaxa: Os mineradores recebem uma taxa de mineração como incentivo para incluir transações nos blocos que mineram. Para saber mais, clique no botão enviar.",
    title: "Quais são as informações nos detalhes da transação?"
  },
  accountTransactionConfirmation: {
    text: "Uma transação transmitida para a rede, mas ainda não confirmada.",
    title: "O que é uma transação pendente?"
  },
  accountTransactionLabel: {
    text: "É o endereço para o qual você recebeu ou enviou moedas.",
    title: "Qual endereço é exibido para cada transação?"
  },
  accountTransactionTime: {
    text: "O horário de confirmação da transação blockchain.",
    title: "Qual horário é exibido?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin e Litecoin podem ter uma quantidade arbitrária de contas. Após cinco contas, você só pode adicionar outra conta se a conta anterior tiver sido usada. Outras moedas podem ter um máximo de cinco contas.",
      title: "Quantas contas posso criar?"
    },
    howtoAddTokens: {
      text: 'Tokens usando o padrão ERC20 são atrelados a uma conta Ethereum específica. Para habilitar ou desabilitar um token em particular, abra a tela "Gerenciar contas", e expanda até a sua conta Ethereum e mude o token desejado para ligado ou desligado.',
      title: "Como posso adicionar mais tokens?"
    },
    moveFunds: {
      text: "Sim. Porque as contas são independentes, você deve mandar saldo usando uma transação regular.",
      title: "Posso mover saldo entre contas?"
    },
    recoverAccounts: {
      text: "Sim, O BitBoxApp cria suas contas usando o melhor padrão estabelecido compatível com a maioria das outras carteiras de crypto.",
      title: "Posso recuperar minhas contas com outras carteiras?"
    },
    whatAreAccounts: {
      text: "Sua carteira pode gerenciar contas múltiplas da mesma moeda. Várias contas são de extrema ajuda para manter seus fundos separadamente.",
      title: "O que são contas?"
    },
    whatIsRememberWallet: {
      text: "Ativar “Lembrar carteira” permite que você veja as contas desta carteira no BitBoxApp mesmo quando a BitBox02 não está conectada. Isso permite checar seu saldo e portfólio quando quiser. A BitBox02 ainda precisa ser conectada e desbloqueada para enviar ou receber moedas.\n\nDesativar “Lembrar carteira” exige que você conecte a respectiva BitBox02 (ou a carteira com frase secreta) para ver essas contas no BitBoxApp.",
      title: "O que acontece quando eu habilito/desabilito “Lembrar carteira”?"
    },
    whyIsThisUseful: {
      text: 'Contas são ótimas para gerenciar seus fundos para pessoas ou propósitos diferentes porque são separadas. Você pode também compartilhar sua "chave pública estendida" de uma conta sem revelar nada sobre suas outras contas.Isso permite você repetidamente receber saldo sem reutilizar os seus endereços, bem como receber seu salário ou seu saldo de crypto que for comprado.',
      title: "Por que isso é útil?"
    }
  },
  appendix: {
    link: "Contate-nos!",
    text: "Outra pergunta?"
  },
  backups: {
    check: {
      text: "'Checar backup' permite verificar se você tem um backup funcionando correspondente à sua carteira atual. Também pode ser usado para verificar se você ainda tem a senha de recuperação correta. Você pode verificar sua senha de recuperação principal ou sua senha de recuperação oculta.",
      title: "O que é 'Checar backup'?"
    },
    encrypt: {
      text: "Não, mas sua senha de recuperação é necessária para derivar a carteira a partir da semente armazenada.",
      title: "Posso criptografar o backup?"
    },
    howOften: {
      text: "O backup é gerado automaticamente quando uma nova carteira é criada. Você só precisa fazer um novo backup se o seu cartão microSD for perdido ou danificado ou se desejar usar vários cartões microSD como backups.\nVocê não precisa criar novos backups depois das atividades de transação. Todos os seus dados de transação podem ser recriados pelo backup único que foi gerado automaticamente para você.",
      title: "Com que frequência tenho que fazer um backup?"
    },
    whatIsABackup: {
      text: "É uma cópia da semente em um cartão microSD. A semente junto com sua senha de recuperação gera sua carteira.",
      title: "O que é um backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Checar backup' permite verificar se você tem um backup funcionando correspondente à sua carteira atual.",
      title: "O que é 'Checar backup'?"
    },
    encrypt: {
      text: 'Não. Por favor, mantenha o cartão microSD seguro, pois ele contém a semente não criptografada para recuperar sua carteira. Se você deseja proteger sua semente com senha, é possível ativar uma frase secreta opcional nas configurações de especialistas em "Gerenciar dispositivo".',
      title: "Posso criptografar o backup?"
    },
    whatIsABackup: {
      text: "É uma cópia da semente em um cartão microSD.",
      title: "O que é um backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Quando o 2FA é ativado, todas as transações de moedas precisam ser aprovadas no celular emparelhado. Internamente, um número de uso único criptografado é enviado para o aplicativo móvel, é descriptografado e retornado à BitBox ao pressionar o botão Aceitar. Esta comunicação com o dispositivo é feita através do canal entre o telefone celular e este aplicativo de desktop estabelecido durante o emparelhamento.\n\nCertifique-se de fazer um backup de sua carteira e emparelhar o aplicativo móvel antes de ativar o 2FA. Uma vez ativado, o slot de cartão microSD e o emparelhamento via aplicativo móvel são desativados. Eles podem ser reativados resetando a BitBox, o que formata o dispositivo.",
      title: "Como funciona a autenticação de dois fatores (2FA)?"
    },
    disable2FA: {
      text: `Para desabilitar o 2FA, você precisa resetar a sua BitBox e restaurar a carteira através do seu backup. Certifique-se de que você ainda tem o cartão microSD com o backup e que você ainda se lembra da senha de recuperação. Em seguida, pressione 'Resetar dispositivo'. Defina uma nova senha para o dispositivo e escolha "Ou restaurar a partir de um backup". Selecione o backup que você fez da carteira, clique em 'Restaurar' e insira a senha de recuperação que você usou ao criar a carteira.`,
      title: "Como posso desativar a autorização de dois fatores (2FA)?"
    },
    ejectBitbox: {
      text: "Você pode desconectar a BitBox a qualquer momento sem precisar ejetá-la primeiro.",
      title: "Como posso ejetar a BitBox?"
    },
    ejectSD: {
      text: "Você pode remover o cartão microSD da BitBox a qualquer momento, desde que não esteja criando ou restaurando um backup.",
      title: "Como posso ejetar o cartão microSD?"
    },
    hiddenWallet: {
      text: "É uma segunda carteira no mesmo dispositivo protegida por uma senha de dispositivo e senha de recuperação diferentes, que você pode usar para negação plausível (plausible deniability). A mesma semente do backup é usada para sua carteira normal e oculta, portanto, nenhum backup adicional é necessário.",
      title: "O que é uma carteira oculta?"
    },
    legacyHiddenWallet: {
      text: "Primeiro, clique no botão abaixo (disponível se a BitBox estiver desbloqueada com a senha principal do dispositivo e o 2FA estiver desabilitado), em seguida, reconecte sua BitBox e desbloqueie-a com a senha oculta do dispositivo.",
      title: "Como faço para acessar a carteira legacy oculta?"
    },
    pairing: {
      text: "Depois de fazer o download do nosso aplicativo para dispositivos móveis para iOS ou Android, escaneie o QR code exibido, que cria um canal seguro entre o aplicativo móvel e este aplicativo. Depois de escanear, siga as instruções no aplicativo para dispositivos móveis.",
      title: "Como emparelhar de forma segura com o seu telefone"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Verifique o site do Bitsurance e suas perguntas frequentes para obter mais detalhes.",
      title: "Mais perguntas?"
    },
    privacy: {
      link: {
        text: "Política de privacidade do Bitsurance"
      },
      text: "Como qualquer apólice de seguro regular, ela contém seu nome e endereço completos e especifica o objeto segurado (definido pela chave pública estendida da conta Bitcoin segurada). Esses dados são enviados diretamente ao Bitsurance e não são compartilhados com a Shift Crypto. Por favor consulte a política de privacidade do Bitsurance para mais informações",
      title: "Quais informações pessoais são necessárias para o seguro?"
    },
    renew: {
      text: "O seguro será renovado automaticamente para o próximo ano. Você pode cancelar a renovação a qualquer momento clicando em “Gerenciar contrato” no BitBoxApp, que o leva ao portal do cliente Bitsurance.",
      title: "Como posso renovar ou cancelar o seguro?"
    },
    status: {
      text: "As contas seguradas com sucesso são marcadas com um emblema verde “segurado” no canto superior esquerdo de cada página da conta Bitcoin. Na seção “Seguro”, você pode ver a visão geral de todas as contas Bitcoin seguradas e seu status atual de seguro.",
      title: "Posso verificar o status de uma conta segurada?"
    },
    what: {
      text: "Cada contrato de seguro Bitcoin cobre uma conta de carteira específica. Você pode segurar várias contas contratando várias apólices de seguro. As contas seguradas estão limitadas ao uso de endereços Bitcoin “Segwit Nativo”.",
      title: "Toda a carteira BitBox está segurada?"
    },
    who: {
      text: "O seguro é oferecido pelo Bitsurance, uma corretora de seguros criada por bitcoiners. Eles trabalham com o seguro ELEMENT para fornecer seguro de Bitcoin. Ambas as empresas estão sediadas na Alemanha.",
      title: "Quem está assegurando meu bitcoin?"
    },
    why: {
      text: "O Bitsurance cobre alguns riscos de autocustódia que não estão no escopo nem mesmo da carteira mais segura, por exemplo. roubo, extorsão ou destruição da carteira. A decisão é sua se você precisa de cobertura de seguro para esses riscos.",
      title: "Preciso de seguro de Bitcoin?"
    }
  },
  cointracking: {
    text: 'Clique no botão "Exportar" e abra a pasta de downloads onde você ira encontrar seu arquivo CSV exportado. Depois clique no link abaixo, faça upload do arquivo CSV BitBox e importe ele a fim de usar os dados no seu Gerenciador de rastreamento de moeda e poderá criar seus relatórios de taxa.',
    title: "Como importar minhas transações para a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leia mais sobre a verificação de autenticidade"
      },
      text: "O BitBoxApp executa uma verificação de atestado na BitBox02 para verificar se o dispositivo é genuíno. A verificação é feita localmente e não se conecta a nenhum servidor.",
      title: "Como funciona a verificação de autenticidade?"
    },
    name: {
      text: "Este é o nome da sua carteira e backup. O nome é usado para backups futuros e pode ser usado para ajudar a distinguir entre diferentes carteiras. Ele pode ser alterado a qualquer momento, mas observe que os backups feitos antes da alteração ainda usarão o nome anterior.",
      title: "Para que serve o nome da BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leia mais sobre o chip seguro"
      },
      text: "Esta informação mostra o número do modelo do chip seguro, o chip mais atualizado é o ATECC608B com recursos de segurança aprimorados em comparação com modelos mais antigos.",
      title: "Por que mostrar o modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Você pode dar o endereço para que outras pessoas lhe enviem algumas moedas. Apenas certifique-se de que estão enviando para o endereço correto.",
      title: "O que eu faço com um endereço?"
    },
    addressChange: {
      text: "Assim que você realiza a transação, um novo endereço é automaticamente adicionado à lista, para que haja sempre 20 endereços disponíveis que nunca receberam moedas.",
      title: "Quando os endereços mudam?"
    },
    addressFormats: {
      text: "Por padrão, o tipo de endereço é Segwit Nativo. Esse tipo de endereço é amplamente adotado por outras carteiras/corretoras e oferece as melhores taxas para transações habituais. No entanto, você também pode optar por enviar para Taproot (somente Bitcoin), que é o tipo de endereço mais recente, mas pode não ser amplamente suportado ainda. Alternativamente, se você estiver tendo problemas para enviar para o Segwit Nativo (o tipo padrão), tente alternar para o tipo de endereço mais antigo Wrapped Segwit que pode ser compatível com mais carteiras/corretoras.",
      title: 'Quando usar "Alterar tipo de endereço"?'
    },
    howVerify: {
      text: "Para a BitBox01, clique no ícone BitBox na barra lateral à esquerda e veja a seção Emparelhamento. O guia será atualizado e você poderá continuar seguindo as instruções.\nPara a BitBox02, você pode verificar os endereços diretamente no dispositivo durante o processo de envio/recebimento.",
      title: "Como posso verificar um endereço com segurança?"
    },
    plugout: {
      text: "Não, uma vez que você enviou moedas para o seu endereço BitBox, você não precisa deixar sua BitBox conectada. Você pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o recebimento?"
    },
    why20: {
      text: 'Durante a inicialização, o aplicativo gera endereços derivados de sua semente para ver se eles receberam fundos. Como o aplicativo pode gerar um número quase infinito de endereços, poderia levar anos determinando o saldo. Para limitar essa pesquisa, ele para depois de ver 20 endereços que nunca receberam fundos. Esse é o "gap limit" e 20 é um padrão de fato, embora o número seja arbitrário. Estes são os 20 endereços que você pode escolher.',
      title: "Por que apenas 20 endereços?"
    },
    whyMany: {
      text: "Para manter a privacidade e a segurança, nunca distribua o mesmo endereço duas vezes. Se você usou um endereço, clique na seta para a direita para obter um novo endereço. Você pode gerar até 20 endereços por vez. Pense em endereços como números de fatura. Todos os endereços são derivados de sua única semente de backup.",
      title: "Por que tantos endereços?"
    },
    whyVerify: {
      text: "Você não deve confiar no seu computador para gerar e exibir endereços autênticos. As diferentes formas que um computador convencional pode ser atacado o torna significativamente mais vulnerável do que uma carteira de hardware. Para a BitBox01, o botão para verificar o endereço envia o endereço com segurança para um telefone celular emparelhado, a partir do qual você também pode digitalizar e verificar o QR code. Para a BitBox02, o endereço pode ser verificado diretamente no visor da BitBox02.",
      title: "Por que devo verificar o endereço com segurança?"
    }
  },
  send: {
    change: {
      text: "O troco será devolvido a um endereço Taproot se você tiver pelo menos um Taproot UTXO. Se você usar o controle de moedas, o troco será devolvido a um endereço Taproot se houver pelo menos um Taproot UTXO entre os UTXOs selecionados. Em todos os outros casos, o troco é devolvido a um endereço Segwit Nativo.",
      title: "Como o output do troco é determinado?"
    },
    fee: {
      text: "A taxa é baseada no tamanho dos dados da transação e não no valor. As metas de taxas são calculadas pelo algoritmo de estimativa de taxas do Bitcoin Core para cada prioridade de rede que você escolher. Elas são mostradas se tiverem um valor diferente do objetivo abaixo.\nEconômica: 24 blocos (cerca de 4 horas para Bitcoin, 1 hora para Litecoin)\nBaixa: 12 blocos (cerca de 2 horas para o Bitcoin, 30 minutos para o Litecoin)\nNormal: 6 blocos (cerca de 1 hora para o Bitcoin, 15 minutos para o Litecoin)\nAlta: 2 blocos (cerca de 20 minutos para Bitcoin, 5 minutos para Litecoin)\n(Um bloco demora, em média, dez minutos para Bitcoin (2,5 minutos para Litecoin) para ser minerado e o carregamento da rede pode variar consideravelmente nos períodos acima.)",
      title: "Como a taxa é determinada?"
    },
    plugout: {
      text: "Não, uma vez que você tenha feito uma transação, você não precisa deixar sua BitBox conectada. Você pode desconectar sua BitBox.",
      title: "Preciso deixar minha BitBox conectada durante o envio?"
    },
    priority: {
      text: "Tipicamente, quanto maior a taxa que você está disposto a pagar, mais rapidamente sua transação é confirmada pela rede.",
      title: "Qual é a prioridade da rede?"
    },
    revert: {
      text: "Depois que uma transação é assinada e enviada (ou seja, transmitida para a rede), ela não pode mais ser revertida. Verifique as transações (incluindo a taxa) corretamente antes de assinar!\nSe você conhece o destinatário e ele ou ela está disposto a enviar o mesmo valor (menos as taxas de transação) de volta para você, você pode enviar um novo endereço de recebimento.",
      title: "Posso reverter uma transação?"
    },
    whyFee: {
      text: "As transações estão competindo para serem confirmadas por um minerador. Mineradores escolhem transações para serem incluídas na blockchain com base em sua taxa.\nOs mineradores votam no histórico das transações. Como não há nenhum terceiro confiável para fazer valer um voto por pessoa (que é a ideia das blockchains), os mineradores votam em transações sacrificando um recurso caro como o poder de computação. Como recompensa por seu trabalho, eles podem reivindicar moedas recém-criadas e a taxa de todas as transações incluídas.",
      title: "Por que há uma taxa de rede?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Se você pretente apenas conectar seu nó quando você tiver em uma rede específica (ex: seu wifi de casa), então uma comunicação padrão apenas é suficiente.\nNesse caso é aconselhado que seu servidor Electrum forneça um certificado TLS para encriptar a comunicação.\nSe você prente conectar seu nó de qualquer lugar usando o protocolo Tor a melhor opção e necessária é não usar um certificado TLS para esse caso.",
      title: "Devo usar clearnet TCP, TLS ou Tor?"
    },
    instructions: {
      link: {
        text: "Guia para conectar seu nó"
      },
      text: "Para um tutorial completo, por favor visite nosso guia:",
      title: "Como conecto meu BitBoxApp no meu prórprio nó?"
    },
    options: {
      text: "Existem várias opções para você rodar seu próprio nó, como comprar um dispositivo próprio, construir um ou usar a rede Bitcoin Core.\nSe você deseja conectar seu BitBoxApp no seu nó, certifique-se de quele roda um servidor Electrum compatível. Trata-se de um programa dedicado que permite que seu aplicativo de carteira se comunique com seu próprio nó.\nOperações suportadas incluem Electrs, Electrum Personal Server (EPS) ou Bitcoin Wallet Tracker (BTW).",
      title: "Quais opções tenho para rodar um nó?"
    },
    tor: {
      text: "Tor significa 'The Onion Router', que é um software de código aberto e gratuito que oferece muitos benefícios de privacidade e é especialmente útil ao usar Bitcoin.\nSe você pretende se conectar ao seu node através do Tor, certifique-se de que o Tor está instalado no seu computador e ative o Proxy Tor nas configurações do BitBoxApp.\nNa maioria dos sistemas operacionais, existem duas maneiras de executar o Tor:\n1. Navegador Tor: baixe e abra o navegador Tor. Isso permitirá que o BitBoxApp se conecte à rede Tor configurando a porta 9150 nas configurações de proxy do Tor.\n2. Serviço Tor em segundo plano: instale o daemon Tor, que sempre é executado em segundo plano. O BitBoxApp pode então se conectar definindo a porta 9050 nas configurações de proxy do Tor.",
      title: "O que é Tor, proxy Tor e qual porta devo usar?"
    },
    what: {
      text: "É possível alimentar sua carteira com seus próprios full nodes em vez de usar os servidores Shift.",
      title: "O que é isso?"
    },
    why: {
      text: "Executar seu próprio node não é necessário, mas melhora a privacidade e reduz a necessidade de confiar nos outros.\nEm primeiro lugar, significa que você está usando o Bitcoin de forma mais privada, pois o BitBoxApp não se conecta aos nossos servidores para buscar seu histórico de transações; em vez disso, ele buscará essas informações em seu próprio node.\nEm segundo lugar, executar seu próprio node significa que ele verifica todas as transações por si mesmo, garantindo que as regras de consenso sejam aplicadas.",
      title: "Por que devo executar meu próprio node?"
    }
  },
  settings: {
    sats: {
      text: "Um Satoshi ('sat' para abreviar) é a menor unidade de Bitcoin. Um Satoshi é um centésimo milionésimo de um bitcoin (0,00000001 BTC). É o nome do criador do Bitcoin, Satoshi Nakamoto.",
      title: "O que é um Satoshi?"
    },
    servers: {
      text: "Este aplicativo se comunica com os servidores Shift Crypto para verificar atualizações, carregar transações e enviar informações para aplicativos móveis emparelhados.\nO aplicativo também busca as taxas de câmbio mais recentes do CoinGecko. Todas as conversões são calculadas localmente, o que significa que nenhum dado sobre o valor da sua transação é transmitido.\nNota: Para Ethereum e ERC20 Tokens, nós usamos APIs do Etherscan.io.",
      title: "Com quais servidores este aplicativo se comunica?"
    }
  },
  title: "Guia",
  toggle: {
    close: "Fechar guia",
    open: "Guia"
  },
  trackingModePortfolioChart: {
    text: "No desktop passe o cursor sobre o gráfico. No celular, segure o dedo no gráfico e arraste horizontalmente.",
    title: "Como ver os valores históricos no gráfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Você precisa resetar o dispositivo e restaurar a carteira a partir de um backup, usando a senha de recuperação.",
      title: "O que faço se eu esquecer a senha do dispositivo?"
    },
    reset: {
      text: "Digite uma senha do dispositivo errada 15 vezes. As últimas tentativas exigem um toque longo no dispositivo.",
      title: "Como faço para resetar o dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "O dispositivo deve piscar uma vez quando inserido. Certifique-se de que está inserido de maneira correta. Se você está tendo problemas, por favor, entre em contato conosco através do link abaixo.\n\nA BitBox01 não é suportada em dispositivos móveis. Por favor, use o BitBoxApp no Desktop para conectar sua BitBox01.",
      title: "Minha BitBox01 não é reconhecida"
    },
    getDevice: {
      link: {
        text: "Encomendar uma BitBox"
      },
      text: "Você pode comprar uma BitBox em nossa loja online:",
      title: "Como posso obter um dispositivo?"
    },
    internet: {
      text: "Sim, uma conexão com a internet é necessária para sincronizar a carteira, enviar transações e buscar as taxas de câmbio mais recentes.",
      title: "Este aplicativo requer uma conexão com a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de backup"
      },
      text: "Você pode recuperar suas contas em uma nova BitBox ou com o nosso centro de backup.",
      title: "Eu perdi meu dispositivo. E agora?"
    },
    useWithoutDevice: {
      text: "Infelizmente, isso ainda não é possível no momento.",
      title: "Posso usar o aplicativo sem um dispositivo?"
    },
    welcome: {
      text: "Obrigado por usar este aplicativo criado pela Shift Crypto na Suíça. Agradecemos qualquer contribuição que você tenha para compartilhar. Por favor, dê feedback usando o link na parte inferior.",
      title: "Bem-vindo ao BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se você estiver usando um novo telefone/computador com o BitBoxApp, precisará se conectar aos DApps novamente. Você verá suas moedas no dapp novamente, como de costume.",
      title: "Não vejo minhas conexões anteriores."
    },
    supportedNetworks: {
      text: "Atualmente, apenas a rede principal Ethereum é suportada usando WalletConnect no BitBoxApp. Para usar outras cadeias compatíveis com a EVM, use a carteira de extensão do navegador Rabby.",
      title: "Quais redes são suportadas?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect é um protocolo de comunicação para aplicativos web3. Ele permite que você se conecte convenientemente a DApps baseados em Ethereum e carteiras web sem usar um aplicativo de terceiros, o que é particularmente útil para usuários Android do BitBoxApp.",
      title: "O que é WalletConnect?"
    }
  }
};
const headerssync$9 = {
  blocksSynced: "{{blocks}} blocos sincronizados"
};
const hiddenWallet$9 = {
  info1HTML: "Para fins de negação plausível (plausible deniability), uma carteira oculta pode ser criada com base em uma combinação de senha de recuperação e uma senha de dispositivo <strong>diferente</strong>.",
  info2HTML: "Defina a senha do dispositivo e a senha de recuperação que você deseja associar à sua carteira oculta abaixo. A senha do dispositivo e a senha de recuperação devem ser <strong>diferentes</strong> das que você definiu para sua carteira principal.",
  passwordLabel: "Senha de recuperação oculta",
  passwordPlaceholder: "Por favor, confirme a senha de recuperação oculta",
  pinLabel: "Senha oculta do dispositivo",
  pinRepeatLabel: "Repita a senha oculta do dispositivo",
  pinRepeatPlaceholder: "Por favor, confirme a senha oculta do dispositivo",
  success: "Carteira oculta criada com sucesso. Reconecte a sua BitBox para desbloqueá-la."
};
const initialize$9 = {
  create: "Definir senha do dispositivo",
  creating: "Configurando senha do dispositivo...",
  error: {
    e102: "A senha do dispositivo precisa conter pelo menos 4 caracteres."
  },
  info: {
    description1: "Escolha a senha do seu dispositivo. Ela será usada para desbloquear a sua BitBox.",
    description2: "Você pode usar números, letras & símbolos. Senhas maiores oferecem mais segurança.",
    description3: "Se você perder a senha do dispositivo, precisará resetá-lo e restaurar o backup da carteira.",
    subtitle: "Agora você vai definir a senha do seu dispositivo",
    title: "Inicializando seu dispositivo"
  },
  input: {
    label: "Senha do dispositivo",
    labelRepeat: "Repita a senha do dispositivo",
    placeholderRepeat: "Por favor, confirme a senha do dispositivo"
  }
};
const invalidFormat$9 = "Formato Inválido";
const language$a = {
  title: "Selecione o idioma"
};
const legacyhiddenwallet$9 = {
  disable: "Desativar carteira legacy oculta",
  enable: "Ativar carteira legacy oculta",
  successDisable: "Carteira legacy oculta desativada com sucesso.",
  successEnable: "Carteira legacy oculta ativada com sucesso. Reconecte sua BitBox e digite a senha oculta do dispositivo para acessar a carteira legacy oculta."
};
const loading$9 = "carregando…";
const manageAccounts$3 = {
  accountHidden: "Esta conta foi ocultada das suas contas watch-only. Para vê-la novamente, conecte sua BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nome da conta",
  noAccounts: "nenhuma conta encontrada",
  settings: {
    hideTokens: "Esconder tokens",
    showTokens: "Exibir tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Adicionar e exibir/mostrar contas",
  title: "Gerenciar contas",
  watchAccount: "Observar conta",
  watchAccountDescription: "Esta conta faz parte das suas contas watch-only. Você pode ocultá-la de suas contas watch-only usando o botão de alternância."
};
const mobile$4 = {
  usingMobileDataWarning: "Uso de dados móveis: esse aplicativo baixa centenas de megabytes de dados de cabeçalho de blockhain depois de desbloquear sua conta. Por favor conecte no Wi-Fi para evitar de usar dados móveis desnecessários. Depois de descartar isso, essa mensagem não aparecerá novamente."
};
const newSettings$3 = {
  about: {
    appVersion: {
      title: "Versão do aplicativo"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloqueie o acesso ao aplicativo com bloqueio de tela/impressão digital.",
      title: "Bloqueio de tela"
    },
    coinControl: {
      description: "Selecione quais UTXOs fazem parte de uma transação para ajudar a melhorar a privacidade."
    },
    customFees: {
      description: "Permite inserir sua própria taxa ao enviar."
    },
    torProxy: {
      description: "Conecte-se via Tor para melhor privacidade."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Essas moedas adicionais podem ser alternadas na página da sua conta.",
      title: "Moedas ativas"
    },
    darkmode: {
      description: "Veja o BitBoxApp no modo escuro."
    },
    defaultCurrency: {
      description: "Selecione sua moeda padrão",
      title: "Moeda padrão"
    },
    enableAccount: {
      description: "Desativar sua conta significa que ela não aparecerá na barra lateral ou no portfólio. Você sempre pode ativá-la novamente aqui. As moedas nesta conta não serão afetadas e permanecerão seguras.",
      title: "Ativar/desativar conta"
    },
    hideAmounts: {
      description: "Exibe um botão para ocultar seu saldo e valores para melhorar sua privacidade ao usar o aplicativo em público.",
      hideAmounts: "Ocultar valores",
      showAmounts: "Mostrar valores",
      title: "Permitir ocultar valores"
    },
    language: {
      description: "Qual idioma você deseja que o BitBoxApp use.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Lembrar carteira",
      warning: "Isso removerá sua carteira lembrada. Para vê-la novamente, você precisará conectar a BitBox02 para esta carteira. Quaisquer moedas nesta carteira não serão afetadas. Você quer continuar?",
      warningTitle: "Desativar lembrar carteira"
    },
    toggleSats: {
      description: "Ativar ou desativar Satoshis."
    }
  }
};
const note$5 = {
  input: {
    description: "(opcional)",
    placeholder: "Adicionar nota..."
  },
  title: "Nota"
};
const notification$9 = {
  newTxs_one: "Nova transação em: {{accountName}}",
  newTxs_other: "{{count}} novas transações em: {{accountName}}"
};
const pairing$9 = {
  aborted: {
    text: "O emparelhamento foi cancelado no aplicativo para dispositivos móveis.",
    title: "Abortado"
  },
  button: "Emparelhar aplicativo móvel",
  confirm: "Tem certeza de que deseja emparelhar sua BitBox? Observe que, depois disso, o celular será necessário para realizar uma transação.",
  connectOnly: {
    button: "Conectar aplicativo móvel",
    title: "Escaneie com nosso aplicativo móvel selecionando o item 'Conectar ao novo aplicativo de desktop' do menu"
  },
  error: {
    text: "Algo deu errado. Por favor comece de novo.",
    title: "Erro"
  },
  pullFailed: {
    text: "Falha ao obter mensagem de seu dispositivo móvel através do servidor. O servidor pode estar offline, por favor entre em contato com o suporte.",
    title: "Falha ao obter"
  },
  reconnectOnly: {
    button: "Reconectar aplicativo móvel"
  },
  scanningFailed: {
    text: "Telefone não foi capaz de scanear a mensagem com sucesso. Por favor tente novamente.",
    title: "Falha ao scanear."
  },
  start: {
    hideAppQRCode: "Ocultar QR code",
    revealAppQRCode: "Mostrar QR code",
    step1: "Se você não tiver o aplicativo para dispositivos móveis, você pode escanear o QR code da Apple App Store ou da Google Play Store, dependendo de qual celular você possui.",
    step2: 'Escaneie com nosso aplicativo para celular, que você pode encontrar sob o nome "Digital Bitbox 2FA" nas lojas de aplicativos para iOS e Android:'
  },
  started: {
    text: "Agora, por favor, siga as instruções no aplicativo móvel.",
    title: "Ótimo"
  },
  success: {
    text: "Parabéns, você pareou com sucesso sua BitBox com o aplicativo móvel!",
    title: "Sucesso"
  },
  timeout: {
    text: "O emparelhamento expirou após dois minutos. Comece novamente se você ainda deseja emparelhar o aplicativo para dispositivos móveis.",
    title: "Tempo esgotado"
  },
  title: "Emparelhamento por celular"
};
const passphrase$3 = {
  considerations: {
    button: "Considerações sobre backup",
    message: "A frase secreta adiciona uma camada de proteção ao backup da sua carteira (cartão microSD ou palavras de recuperação). Se alguém tiver acesso ao seu backup, também precisará da frase secreta para acessar sua carteira.\n\nNo entanto, isso significa que você precisará <strong>tanto da frase secreta + backup da carteira</strong> para restaurar sua carteira habilitada para frase secreta, caso sua BitBox02 seja perdida ou danificada. Se você esquecer ou perder sua frase secreta, perderá o acesso a todas as moedas dessa carteira.\n\nAo armazenar sua frase secreta, considere colocá-la em um local separado do backup. Dessa forma, se alguém encontrar seu backup, eles também não encontrarão sua frase secreta.",
    title: "Considerações sobre backup"
  },
  disable: "Desabilitar frase secreta",
  disableInfo: {
    button: "Desabilitar",
    message: "Depois de desabilitar a frase secreta, você não será mais solicitado a inserir uma frase secreta após desbloquear sua BitBox02. Portanto, você entrará em sua carteira padrão.\n\nQuaisquer moedas em sua carteira gerada com a frase secreta ainda estarão nessa carteira, mas você não poderá acessá-las porque depois de desbloquear sua BitBox02, você abrirá sua carteira padrão.\n\nPara acessar suas carteiras geradas com frases secretas novamente, basta reativar o recurso de frase secreta e inserir a frase secreta relevante após desbloquear a BitBox02.\n\n<strong>Dica:</strong> você ainda pode acessar sua carteira original deixando a frase secreta vazia."
  },
  enable: "Habilitar frase secreta",
  error: {
    e104: "A alteração da configuração da frase secreta foi abortada."
  },
  how: {
    button: "Como funciona",
    message: "Uma frase secreta não funciona como uma senha com a qual você está acostumado. Se você digitar incorretamente sua frase secreta, você não será notificado. Isso ocorre porque <strong>cada frase secreta cria uma carteira diferente, porém válida</strong>. Isso significa que você pode usar várias frases secretas para quantas carteiras quiser. Mas cada carteira só pode ser acessada ao digitar a frase secreta correspondente.\n\nAo conectar sua BitBox02, você será solicitado a inserir a senha do dispositivo como de costume. Depois disso, você será solicitado a inserir uma frase secreta no dispositivo.\n\nDepois de inserir a frase secreta, você verá a frase secreta digitada. Isso é para que você possa confirmar que digitou corretamente.",
    title: "Como funciona"
  },
  intro: {
    message: "Uma frase secreta fornece uma camada adicional de segurança em sua carteira.\nVamos aprender como funciona.",
    title: "Configurar frase secreta"
  },
  progressDisable: {
    message: "Confirme em sua BitBox que você deseja <strong>desabilitar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  progressEnable: {
    message: "Confirme em sua BitBox que você deseja <strong>ativar</strong> a frase secreta opcional.",
    title: "Confirmar no dispositivo"
  },
  successDisabled: {
    message: "Frase secreta opcional <strong>ativada com sucesso</strong>!\nVocê será solicitado a fornecer uma frase secreta a partir de agora.",
    messageEnd: "Por favor, reconecte a BitBox02 agora.",
    title: "Frase secreta ativada"
  },
  successEnabled: {
    message: "Frase secreta opcional <strong>desativada com sucesso</strong>!\n\nVocê não será mais solicitado a fornecer uma frase secreta.",
    messageEnd: "Por favor, reconecte sua BitBox02 agora.",
    tips: "Dicas",
    tipsList: [
      "Sugerimos enviar primeiro uma pequena quantia para a carteira gerada pela frase secreta. Em seguida, desconecte e reconecte a BitBox02 e digite sua senha e frase secreta. Se você digitou a frase secreta corretamente, deverá ver as moedas em sua carteira.",
      "Se você deseja acessar sua carteira original sem uma frase secreta, você ainda pode fazer isso não digitando nada quando solicitado a inserir a frase secreta. Ou você pode desativar o recurso de frase secreta."
    ],
    title: "Frase secreta desativada"
  },
  summary: {
    button: "Ativar frase secreta",
    title: "Resumo",
    understand: "Eu entendo como a frase secreta funciona e os riscos associados a ela.",
    understandList: [
      "A frase secreta é uma camada adicional de segurança em seu backup.",
      "A inserção de uma frase secreta diferente sempre gerará uma carteira diferente.",
      "Para restaurar sua carteira, você precisa <strong>da frase secreta e do backup</strong>.",
      "Se você esquecer sua frase secreta, você <strong>não poderá mais acessar suas moedas</strong>."
    ]
  },
  what: {
    button: "Saiba como isso funciona",
    message: "Uma carteira é criada (derivada) a partir de um número aleatório muito grande, também conhecido como semente. Essa semente é criada quando você configura sua BitBox02 pela primeira vez e é feito backup com o cartão microSD ou palavras de recuperação. Qualquer pessoa que tenha acesso à semente tem controle total sobre os fundos dessa carteira.\n\nUma frase secreta é um <strong>segredo opcional</strong>, adicionado à semente. Ao usar uma frase secreta, cada frase secreta cria uma nova carteira com base na semente + frase secreta (segredo opcional). Uma frase secreta pode ser qualquer coisa: letras, palavras, caracteres especiais ou pode até ser vazia. A carteira padrão é de fato derivada da semente + frase secreta vazia.\n\nA frase secreta é parte do padrão BIP39, o que significa que é compatível com todas as carteiras que suportam o mesmo padrão.",
    title: "O que é uma frase secreta?"
  },
  why: {
    button: "Por que usar uma frase secreta",
    message: "A BitBox02 protege a semente contra extração do próprio dispositivo, mas o backup (cartão microSD ou palavras de recuperação) dá acesso total à carteira. É por isso que deve ser armazenado em um local seguro!\n\nComo uma frase secreta cria uma nova carteira usando sua semente existente, a carteira da frase secreta requer tanto seu <strong>backup quanto sua frase secreta para restaurar</strong>. O benefício disso é que, se alguém encontrar seu backup, ainda precisará da frase secreta para acessar a carteira.\n\nAlém disso, o recurso de frase secreta permite que você crie várias carteiras no mesmo dispositivo ou “carteiras ocultas” além da padrão.",
    title: "Por que usar uma frase secreta?"
  }
};
const password$9 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "ATENÇÃO: o caps lock (⇪) está ativado",
    paste: 'para colar o texto, ative "MOSTRAR {{label}}"'
  }
};
const random$a = {
  button: "Gerar número aleatório",
  description: "Sua BitBox gerou o seguinte número aleatório de {{bits}} bits:"
};
const receive$b = {
  bitsuranceWarning: "Esta é uma conta segurada, o que significa que só pode receber em Segwit Nativo. Isso é para que você não receba acidentalmente Wrapped Segwit ou Taproot, que não são segurados.",
  changeScriptType: "Alterar tipo de endereço",
  label: "Seu endereço",
  onlyThisCoin: {
    description: "Para receber outros tokens, ative-os nas configurações. Se você depositar outros tokens, eles podem não ser acessíveis.",
    warning: "Certifique-se de receber apenas {{coinName}} neste endereço."
  },
  scriptType: {
    p2tr: "Taproot (formato mais recente)",
    p2wpkh: "Segwit Nativo (padrão)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatível)"
  },
  selectAccount: "Selecione a conta",
  showFull: "Mostrar e verificar endereço completo no dispositivo",
  taprootWarning: "Nota: Taproot é um novo recurso do Bitcoin e ainda não é amplamente adotado. Os valores recebidos em endereços Taproot podem não ser visíveis em carteiras watch-only de terceiros. Muitas carteiras e corretoras ainda não podem enviar para endereços Taproot.",
  title: "Receber {{accountName}}",
  verify: "Verificar endereço com segurança",
  verifyBitBox01: "Verifique o endereço no aplicativo móvel",
  verifyBitBox02: "Verifique o endereço na BitBox02",
  verifyInstruction: "Por favor, verifique se o endereço a seguir corresponde ao exibido no seu dispositivo.",
  warning: {
    secureOutput: "Por favor, emparelhe sua BitBox com seu dispositivo móvel para ativar a verificação segura de endereço. Vá para 'Gerenciar dispositivo' na barra lateral."
  }
};
const reset$9 = {
  description: "Todos os dados serão excluídos deste dispositivo. Isso inclui sua chave privada!",
  notReset: "Dispositivo NÃO redefinido.",
  title: "Restaurar configurações de fábrica",
  understand: "Eu tenho um backup e sei minha senha de recuperação",
  understandBB02: "Eu tenho um backup válido"
};
const securityInformation$9 = {
  create: {
    description1: "Recomendamos que você configure seu dispositivo em um ambiente seguro, ou seja, você estará longe de outras pessoas que possam ver a senha que você escolher.",
    description2: "Você será solicitado a criar duas senhas.",
    description3: "A primeira é a <strong>senha do dispositivo</strong> que desbloqueia o seu dispositivo BitBox e pode ser alterada mais tarde.",
    description4: "A segunda é a <strong>senha de recuperação</strong> que desbloqueia sua carteira. Esta senha não pode ser alterada mais tarde.",
    description5: "A carteira que você criar será copiada para um arquivo no cartão microSD fornecido. Ele pode ser usado em caso de emergência para recuperar seus fundos usando a sua <strong>senha de recuperação</strong>.",
    title: "Informação de segurança"
  },
  restore: {
    description1: "Você será solicitado a inserir o cartão microSD usado para armazenar seu backup.",
    description2: "Para restaurar o seu dispositivo, você precisará da sua senha de recuperação.",
    description3: "Por favor, tenha cuidado ao digitar a senha de recuperação. Qualquer senha que você inserir criará uma carteira válida. Se você digitar a senha errada, poderá ser mostrado um saldo da carteira que você não espera.",
    title: "Informação de segurança"
  }
};
const seed$9 = {
  agreements: {
    "funds-access": "Eu NÃO poderei acessar meus fundos se esquecer minha senha de recuperação",
    "password-change": "Eu NÃO posso mudar a senha de recuperação mais tarde",
    "password-required": "A senha de recuperação é necessária para restaurar uma carteira de um backup"
  },
  create: "Criar carteira",
  creating: "Criando carteira",
  description: "Eu entendo que:",
  error: {
    e102: "A senha deve conter pelo menos 4 caracteres.",
    e200: "Você precisa inserir um cartão microSD na sua BitBox para criar uma carteira, para que um backup possa ser criado automaticamente."
  },
  info: {
    button: "Definir senha de recuperação agora",
    description1: "Insira o cartão microSD na BitBox",
    description2: 'Escolha uma senha de recuperação para a carteira e selecione "Definir senha de recuperação agora"',
    description3: "O backup para o cartão microSD e sua senha de recuperação é o único método para recuperar seus fundos em caso de perda ou roubo de um dispositivo BitBox.",
    description4: "Você não pode alterar sua senha de recuperação posteriormente sem transferir seus fundos.",
    title: "Criar uma nova carteira"
  },
  password: {
    label: "Senha de recuperação",
    repeatPlaceholder: "Repita a senha de recuperação"
  },
  walletName: {
    label: "Nome da carteira"
  }
};
const seedRestore$9 = {
  error: {
    e200: "Restaurar uma carteira a partir de um backup requer o cartão microSD."
  },
  info: {
    description1: 'Insira o cartão microSD na BitBox e clique em "Continuar"',
    description2: 'Escolha um backup e clique em "Restaurar"',
    description3: "Digite a senha de recuperação",
    description4: "Você precisa confirmar que entende que uma senha incorreta criará uma carteira diferente.",
    title: "Como restaurar uma carteira a partir de um backup"
  }
};
const send$b = {
  abort: "A transação foi abortada.",
  address: {
    label: "Endereço do destinatário",
    placeholder: "Insira o endereço"
  },
  amount: {
    label: "Montante",
    placeholder: "Insira o valor"
  },
  availableBalance: "Saldo disponível",
  button: "Revisar",
  coincontrol: {
    address: "Endereço",
    outpoint: "Outpoint",
    title: "Enviar da saída"
  },
  confirm: {
    "selected-coins": "Moedas selecionadas",
    title: "Confirmar e enviar transação",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que você não tem Ether suficiente para pagar por esta transação ERC20. Certifique-se de ter Ether suficiente em sua carteira",
    feeTooLow: "taxa muito baixa",
    feesNotAvailable: "Não foi possível estimar as taxas",
    insufficientFunds: "saldo insuficiente",
    invalidAddress: "endereço inválido",
    invalidAmount: "montante inválido",
    invalidData: "dados inválidos"
  },
  fee: {
    customPlaceholder: "Insira o valor",
    label: "Taxa de rede",
    placeholder: "Não disponível"
  },
  feeTarget: {
    customLabel: "Taxa",
    customLabel_eth: "Preço do gás",
    description: {
      economy: "4 horas (24 blocos)",
      economy_eth: "30 minutos ou menos",
      economy_ltc: "1 hora (24 blocos)",
      high: "20 minutos (2 blocos)",
      high_eth: "30 segundos ou menos",
      high_ltc: "5 minutos (2 blocos)",
      low: "2 horas (12 blocos)",
      low_eth: "5 minutos ou menos",
      low_ltc: "30 minutos (12 blocos)",
      normal: "1 hora (6 blocos)",
      normal_eth: "2 minutos ou menos",
      normal_ltc: "15 minutos (6 blocos)"
    },
    estimate: "Tempo estimado de confirmação:",
    label: {
      custom: "Customizar",
      economy: "Econômica",
      high: "Alta",
      low: "Baixa",
      normal: "Normal"
    },
    placeholder: "Calculando a taxa ..."
  },
  maximum: "Enviar tudo",
  maximumSelectedCoins: "Enviar moedas selecionadas",
  noFeeTargets: "As estimativas de taxa de transação estão indisponíveis no momento. Por favor, tente novamente mais tarde ou insira uma taxa personalizada.",
  priority: "Prioridade",
  scanQR: "Escanear QR code",
  signprogress: {
    description: "Esta é uma transação que contém muitos dados. Para assinar completamente a transação, você será solicitado a confirmar {{steps}} vezes.",
    label: "Progresso"
  },
  success: "A transação foi assinada e enviada.",
  title: "Enviar {{accountName}}",
  toggleCoinControl: "Alternar controle de moedas",
  transactionDetails: "Detalhes da transação"
};
const settings$a = {
  about: "Sobre",
  accounts: "Contas",
  advancedSettings: "Configurações avançadas",
  appearance: "Aparência",
  electrum: {
    add: "Adicionar um servidor",
    "add-server": "Adicionar",
    check: "Checar",
    checkFailed: "Falhou",
    checkSuccess: "Conexão com {{host}} estabelecida com sucesso.",
    checking: "Checando",
    "download-cert": "Baixar certificado remoto",
    "remove-server": "Remover",
    removeConfirm: "Remover {{server}}?",
    reset: "Redefinir para o padrão",
    resetConfirm: "Você deseja remover todos os servidores e instalar os servidores padrão?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Digite o endpoint.",
    step2: "2",
    "step2-text": "Digite um certificado da cadeia de certificados do servidor. Alternativamente, baixe o certificado remoto e compare-o visualmente.",
    "step2-text-tcp": "Você pode pular essa estapa se não quiser usar TLS.",
    step3: "3",
    "step3-text": "Checar a conexão e adicionar o servidor.",
    step4: "4",
    "step4-text": "Reinicie a carteira. Se você não remover os servidores padrão, seu próprio node será adicionado como uma redundância.",
    "title-btc": "Servidores Bitcoin Electrum",
    "title-ltc": "Servidores Litecoin Electrum",
    "title-tbtc": "Servidores Bitcoin Testnet Electrum",
    "title-tltc": "Servidores Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Ativar controle de moedas",
    electrum: {
      description: "Você pode se conectar ao seu próprio nó completo Electrum.",
      title: "Conectar seu próprio full node"
    },
    fee: "Habilitar taxas personalizadas",
    setProxyAddress: "Configurar endereço de proxy",
    title: "Configurações para especialistas",
    useProxy: "Ativar proxy Tor",
    useSats: "Exibir valores BTC em Satoshis"
  },
  header: {
    home: "Início"
  },
  info: {
    "out-of-date": "Nova atualização disponível",
    title: "Informações",
    "up-to-date": "Seu aplicativo está atualizado",
    version: "Versão do aplicativo"
  },
  restart: "Por favor, reinicie o BitBoxApp para que as alterações façam efeito.",
  services: {
    title: "Serviços"
  },
  success: "Por favor, retire e reconecte a BitBox para que as mudanças façam efeito.",
  title: "Configurações"
};
const setup$9 = "Configurar dispositivo";
const sidebar$a = {
  buy: "Comprar crypto",
  device: "Gerenciar dispositivo",
  insurance: "Seguro",
  leave: "Sair",
  settings: "Configurações"
};
const success$g = {
  create: {
    info1: "Sua carteira foi armazenada com segurança no cartão microSD. Remova-o e mantenha-o seguro.",
    info2: "Você criou uma senha de dispositivo segura que desbloqueia a BitBox.",
    info3: "Você criou uma senha de recuperação segura para sua carteira que desbloqueia seu saldo e restaura seus backups.",
    summary: "Aqui está um resumo do que você fez",
    title: "Sucesso"
  },
  getstarted: "Começar",
  restore: {
    summary: "Você restaurou uma carteira a partir do seu backup com sucesso.",
    title: "Sucesso"
  }
};
const transaction$a = {
  confirmation: "Confirmações",
  details: {
    activity: "Movimentação",
    address: "Endereço",
    amount: "Valor",
    date: "Data",
    fiat: "Fiduciária",
    fiatAmount: "Valor fiduciário",
    fiatAtTime: "Fiat no momento da transação",
    status: "Status",
    title: "Detalhes da transação",
    type: "Tipo"
  },
  explorer: "ID da transação",
  explorerTitle: "Abrir no explorador de blocos externo",
  fee: "Taxa",
  fiatHistorical: "Histórico",
  gas: "Gas",
  note: {
    edit: "Editar nó",
    save: "Salvar nó"
  },
  pending: "Transação pendente",
  size: "Tamanho",
  status: {
    complete: "Completa",
    failed: "Falhou",
    pending: "Pendente"
  },
  tx: {
    received: "Recebido para",
    sent: "Enviado para"
  },
  vsize: "Tamanho virtual",
  weight: "Peso"
};
const transactions$9 = {
  errorLoadTransactions: "Ocorreu um erro ao carregar as transações",
  placeholder: "Nenhuma transação ainda."
};
const unknownError$9 = "Ocorreu um erro desconhecido: {{errorMessage}}";
const unlock$9 = {
  description: "Digite a senha do dispositivo para desbloqueá-lo.",
  error: {
    e109_normal: "Senha do dispositivo errada. {{remainingAttempts}} tentativas restantes antes que o dispositivo seja resetado.",
    e109_touch: "$t(unlock.error.e109_normal) O próximo login requer que segure o botão touch.",
    e113: "Devido a muitas tentativas de login, o próximo login requer que o botão touch seja pressionado por 4 segundos."
  },
  input: {
    label: "Senha do dispositivo",
    placeholder: "Digite a senha do dispositivo para desbloqueá-lo"
  },
  unlocking: "Desbloqueando..."
};
const upgradeFirmware$a = {
  button: "Atualizar firmware",
  description: "Deseja atualizar o firmware da versão {{currentVersion}} para {{newVersion}}?",
  label: "Sua BitBox requer uma atualização de firmware.",
  locked: "Para atualizar da versão {{currentVersion}} para a {{newVersion}}, por favor, realize um longo toque.",
  title: "Atualizar firmware",
  unlocked: "O bootloader está desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecte e reconecte sua Bitbox",
  unlocked2: "O LED acenderá quando a sua BitBox for conectada novamente",
  unlocked3: "Toque no botão touch quando o LED acender"
};
const walletConnect$5 = {
  connect: {
    button: "Conectar",
    dappLabel: "Insira o endereço URI do dapp",
    invalidPairingUri: "Uri de emparelhamento inválido"
  },
  dashboard: {
    allSessions: "Todas as sessões",
    disclaimer: "Walletconnect é um protocolo para conectar-se a Dapps baseados em Ethereum. Esses dapps são executados por serviços de terceiros, portanto, conecte-se apenas a dapps em que você confia e sempre saiba o que está assinando ao fazer uma transação.",
    newConnection: "Nova conexão",
    noConnectedSessions: "Nenhuma conta está atualmente conectada a nenhum dapps."
  },
  invalidPairingChain: "Erro ao aprovar o emparelhamento. Certifique-se de usar uma das cadeias suportadas: {{chains}}",
  pairingRequest: {
    approve: "Aprovar conexão",
    reject: "Rejeitar",
    title: "Nova solicitação de conexão de"
  },
  pairingSuccess: "Dapp conectado com sucesso. Você pode continuar no site dapp.",
  signingRequest: {
    account: "Conta",
    chain: "Cadeia",
    dapp: "Dapp",
    data: "Dados",
    dataParsingError: "Falha ao analisar os dados",
    decodeError: "Falha ao decodificar a mensagem",
    method: {
      sendTransaction: "Assinar e enviar transação",
      signMessage: "Assinar mensagem",
      signTransaction: "Assinar transação",
      signTypedData: "Assinar dados digitados"
    },
    successfullySigned: "Solicitação assinada com sucesso",
    walletConnectRequest: "Solicitação WalletConnect"
  },
  useNewUri: "Este URI já foi usado para tentar uma conexão. Use um novo URI.",
  walletConnect: "WalletConnect"
};
const warning$f = {
  receivePairing: "Por favor, emparelhe a BitBox para ativar a verificação segura de endereço. Vá para 'Gerenciar dispositivo' na barra lateral.",
  sdcard: "Mantenha o cartão microSD guardado separado da BitBox, a menos que você queira gerenciar os backups.",
  sendPairing: 'Por favor, emparelhe a BitBox para verificar com segurança os detalhes da transação. Vá para "Gerenciar dispositivo" na barra lateral.'
};
const welcome$9 = {
  connect: "Conecte a BitBox02",
  getStarted: "Vamos começar instalando o firmware na sua BitBox02.",
  insertBitBox02: "Para a BitBox02, por favor, toque no dispositivo para continuar.",
  insertDevice: "Por favor, conecte seu dispositivo para iniciar",
  title: "Bem-vindo"
};
const appTranslationsPT = {
  account: account$9,
  accountInfo: accountInfo$9,
  accountSummary: accountSummary$9,
  addAccount: addAccount$a,
  aopp: aopp$3,
  app: app$9,
  auth: auth$4,
  backup: backup$9,
  bb02Bootloader: bb02Bootloader$9,
  bitbox: bitbox$9,
  bitbox02Interact: bitbox02Interact$9,
  bitbox02Settings: bitbox02Settings$9,
  bitbox02Wizard: bitbox02Wizard$9,
  bitsurance: bitsurance$3,
  bitsuranceAccount: bitsuranceAccount$3,
  blink: blink$9,
  bootloader: bootloader$9,
  button: button$e,
  buy: buy$5,
  changePin: changePin$9,
  chart: chart$5,
  checkSDcard: checkSDcard$9,
  clickHere: clickHere$9,
  confirm: confirm$b,
  confirmOnDevice: confirmOnDevice$9,
  connectKeystore: connectKeystore$4,
  darkmode: darkmode$4,
  device: device$9,
  deviceLock: deviceLock$9,
  deviceSettings: deviceSettings$9,
  deviceTampered: deviceTampered$9,
  dialog: dialog$a,
  error: error$5,
  fiat: fiat$b,
  footer: footer$b,
  generic: generic$5,
  genericError: genericError$9,
  goal: goal$9,
  guide: guide$a,
  headerssync: headerssync$9,
  hiddenWallet: hiddenWallet$9,
  initialize: initialize$9,
  invalidFormat: invalidFormat$9,
  language: language$a,
  legacyhiddenwallet: legacyhiddenwallet$9,
  loading: loading$9,
  manageAccounts: manageAccounts$3,
  mobile: mobile$4,
  newSettings: newSettings$3,
  note: note$5,
  notification: notification$9,
  pairing: pairing$9,
  passphrase: passphrase$3,
  password: password$9,
  random: random$a,
  receive: receive$b,
  reset: reset$9,
  securityInformation: securityInformation$9,
  seed: seed$9,
  seedRestore: seedRestore$9,
  send: send$b,
  settings: settings$a,
  setup: setup$9,
  sidebar: sidebar$a,
  success: success$g,
  transaction: transaction$a,
  transactions: transactions$9,
  unknownError: unknownError$9,
  unlock: unlock$9,
  upgradeFirmware: upgradeFirmware$a,
  walletConnect: walletConnect$5,
  warning: warning$f,
  welcome: welcome$9
};
const account$8 = {
  disconnect: "संपर्क टूट गया। फिरसे प्रयास कर रहे हे...",
  exportTransactions: "ट्रांसेक्शन्स को डाउनलोड फ़ोल्डर में CSV फाइल के रूप में निर्यात करें।",
  fatalError: "एक अनपेक्षित भूल थी।",
  incoming: "आ रहे है",
  initializing: "ब्लॉकचेन से जानकारी प्राप्त कर रहे हैं ...",
  reconnecting: "कनेक्शन खो दिया, फिर से कनेक्ट करने का प्रयास कर रहा है ..."
};
const accountInfo$8 = {
  address: "एड्रेस",
  extendedPublicKey: "विस्तारित पब्लिक की",
  label: "खाता जानकारी",
  title: "अकाउंट की जानकारी",
  verify: "डिवाइस पर सत्यापित करें"
};
const accountSummary$8 = {
  balance: "बेलेंस",
  exportSummary: "अकाउंट सारांश को डाउनलोड फ़ोल्डर में CSV फाइल के स्वरूप में एक्सपोर्ट करे",
  fiatBalance: "फिएट बैलेंस",
  name: "अकाउंट का नाम",
  noAccount: "दिखाने के लिए कोई अकाउंट नहीं हैं।",
  title: "एकाउंट्स सारांश",
  total: "टोटल"
};
const addAccount$9 = {
  title: "अकाउंट जोड़ो"
};
const app$8 = {
  upgrade: "इस एप्लिकेशन का एक नया संस्करण उपलब्ध है! कृपया {{current}} से {{version}} अपग्रेड करें ।"
};
const backup$8 = {
  check: {
    checking: "बैकअप जाँच रहा है ...",
    confirmTitle: "बैकअप की जाँच करें",
    notOK: "बैकअप वॉलेट से मेल नहीं खाता है।",
    ok: "बैकअप वॉलेट से मेल खाता है।",
    password: {
      label: "रिकवरी पासवर्ड",
      placeholder: "रिकवरी पासवर्ड",
      showLabel: "रिकवरी पासवर्ड"
    },
    success: "सफलतापूर्वक सत्यापित बैकअप:",
    title: "बैकअप की जाँच करें"
  },
  create: {
    alreadyExists: "आपके पास पहले से ही एक वैध बैकअप है। क्या आप इसे फिर से बनाना चाहते हैं?",
    fail: "बैकअप बनाना असफल हुआ",
    info: "कृपया सत्यापन के लिए वर्तमान वॉलेट का रिकवरी पासवर्ड दर्ज करें।",
    name: {
      label: "बैकअप का नाम",
      placeholder: "कृपया बैकअप को नाम दे"
    },
    password: {
      label: "रिकवरी पासवर्ड",
      placeholder: "कृपया अपना रिकवरी पासवर्ड दर्ज करें"
    },
    title: "बैकअप बनाए",
    verificationFailed: "रिकवरी पासवर्ड वर्तमान वॉलेट से नहीं मिलता है। बैकअप बनाया गया है। कृपया अपने रिकवरी पासवर्ड को फिर से सत्यापित करने के लिए 'चेक बैकअप' का उपयोग करें।"
  },
  description: "<strong>वॉलेट बैकअप फ़ाइल</strong> को चुने",
  insert: "कृपया बैकअप को मैनेज करने लिए माइक्रो एसडी कार्ड डालें।",
  insertButton: "मैंने माइक्रो एसडी कार्ड डाला है",
  list: "आपके माइक्रोएसडी कार्ड बैकअप",
  noBackups: "इस माइक्रो एसडी कार्ड पर कोई बैकअप नहीं है।",
  restore: {
    confirmTitle: "बैकअप पुनर्स्थापित करे",
    error: {
      e200: "एसडी कार्ड नहीं मिला"
    },
    password: {
      label: "रिकवरी पासवर्ड या हिडन रिकवरी पासवर्ड",
      placeholder: "रिकवरी पासवर्ड",
      repeatPlaceholder: "रिकवरी पासवर्ड दोहराएँ",
      showLabel: "रिकवरी पासवर्ड"
    },
    restoring: "बैकअप पुनर्स्थापित कर रहा है ...",
    title: "पुनर्स्थापित करें",
    understand: "मैं समझता हूं कि एक गलत रिकवरी पासवर्ड एक अलग वॉलेट बनाएगा"
  },
  showMnemonic: {
    description: "आपको 24 शब्द दिखाए जाएँगे, जो आपके वॉलेट का बैकअप बनाते हैं। उन्हें कागज पर लिख लें।\n\n<strong>उन्हें डिजिटल रूप से संग्रहीत न करें या इसकी तस्वीरें न लें।</strong>\n\n<strong>शब्दों को ज़ोर से मत बोलो।</strong>\n\n<strong>यह बैकअप पासवर्ड से सुरक्षित नहीं है।</strong>\n\nबाद में, आपको प्रत्येक शब्द की पुष्टि करने के लिए कहा जाएगा।",
    title: "नेमोनिक सीड दिखाओ"
  },
  title: "बैकअप मैनेज करें"
};
const bb02Bootloader$8 = {
  abort: "अपग्रेड न करें - मुझे वापस ले जाएं",
  advanced: {
    label: "एडवांस सेटिंग",
    toggleShowFirmwareHash: "स्टार्टअप पर हर बार फ़र्मवेयर hash दिखाएं"
  },
  flipscreen: "फ्लिप स्क्रीन",
  orientation: "डिवाइस गलत तरीके से उन्मुख है?",
  success: "अपग्रेड सफल हुआ!  {{rebootSeconds}} सेकंड में में जारी है..."
};
const bitbox$8 = {
  error: {
    e10000: "वर्तमान डिवाइस पासवर्ड गलत है।",
    e10001: "डिवाइस पासवर्ड बदलने में विफल",
    e102: "पासवर्ड में कम से कम 4 अक्षर होने चाहिए।",
    e112: "हिडन डिवाइस पासवर्ड मुख्य डिवाइस पासवर्ड के समान नहीं हो सकता है।"
  }
};
const bitbox02Interact$8 = {
  followInstructions: "कृपया अपने BitBox02 पर दिए गए निर्देशों का पालन करें।"
};
const bitbox02Settings$8 = {
  deviceName: {
    current: "वर्तमान डिवाइस का नाम",
    input: "BitBox02 का नाम",
    title: "BitBox02 का नाम सेट करें"
  }
};
const bitbox02Wizard$8 = {
  attestationFailed: "उपकरण सत्यापन विफल हो गया, जो ऐप को पुनरारंभ करने के कारण हो सकता है जबकि डिवाइस उपयोगकर्ता इनपुट की प्रतीक्षा कर रहा था। कृपया पुन: कनेक्ट करें और पुनः प्रयास करें।",
  backup: {
    point1: "माइक्रोएसडी कार्ड पर बैकअप का चयन करें",
    point2: "अपने डिवाइस के लिए एक पासवर्ड सेट करें",
    restoreText: "ठीक है, चलो बैकअप पुनर्स्थापित करें!",
    text1: "बढ़िया, अब आपका BitBox02 पासवर्ड सेट और वॉलेट बनाया गया है। अब आपका पहला बैकअप बनाने का समय आ गया है। कृपया सुनिश्चित करें कि आपका माइक्रोएसडी कार्ड आपके BitBox02 में डाला गया है और जारी है।",
    text2: "बैकअप बनाने के लिए कृपया अपने डिवाइस पर ऑन-स्क्रीन निर्देश का पालन करें।",
    text3: "आपका बैकअप बन जाने के बाद, कृपया माइक्रोएसडी कार्ड निकालें और इसे <strong>सुरक्षित स्थान</strong> में स्टोर करें । माइक्रोएसडी कार्ड की सामग्री पासवर्ड से सुरक्षित नहीं है। इसे कभी BitBox02 के अलावा किसी अन्य डिवाइस में न डालें।",
    userConfirmation1: "मुझे अपना बैकअप सुरक्षित स्थान पर संग्रहीत करना चाहिए।",
    userConfirmation2: "मेरा बैकअप पासवर्ड प्रोटेक्टेड नहीं है। इससे कोई भी व्यक्ति मेरे वॉलेट तक पहुंच सकता है।",
    userConfirmation3: "यदि मैं अपना BitBox02 खो देता हूं या नुकसान पहुंचाता हूं, तो अपने फंड को पुनर्प्राप्त करने का एकमात्र तरीका मेरे बैकअप से पुनर्स्थापित करना है।",
    userConfirmation4: "अगर मैं अपना बैकअप और मेरा BitBox02 दोनों खो देता हूं या नुकसान होता है तो मेरे फंड हमेशा के लिए खो जाएंगे।"
  },
  create: {
    button: "डिवाइस को नाम दे और जरी रखे",
    info: "अपना BitBox सेटअप करने के लिए यहाँ पे बेसिक स्टेप्स हे जिसका आप पालन करेंगे",
    inputTitle: "वॉलेट का नाम",
    point1: "अपने डिवाइस को नाम दे",
    point2: "अपने डिवाइस के लिए एक पासवर्ड सेट करें",
    point3: "एक बैकअप बनाएं",
    text: "ठीक है, चलो एक नया वॉलेट बनाएँ!"
  },
  initialize: {
    passwordText: "अब आप अपने डिवाइस के लिए एक पासवर्ड सेट करें। पासवर्ड दर्ज करने और चुनने के लिए अपने BitBox पर नियंत्रण का उपयोग करें।",
    passwordTitle: "अपने BitBox के लिए एक पासवर्ड सेट करें",
    text: "सफलतापूर्वक अपने BitBox02 को जोड़ा! अब अपने डिवाइस को इनिशियलाइज़ करते हैं। एक नया वॉलेट बनाने से, या एक मौजूदा बैकअप से एक वॉलेट को पुनर्स्थापित करने से शुरुआत करते है। <strong>कृपया सुनिश्चित करें कि आपने BitBox02 में एक माइक्रोएसडी कार्ड डाला  है</strong>",
    tip: "यह सुनिश्चित करें कि आप सुरक्षित वातावरण में आगे बढ़ें।",
    title: "अपने BitBox को इनिशियलाइज़ करें"
  },
  insertSDCard: "<strong>कृपया सुनिश्चित करें कि आपके पास अपने BitBox02 में एक माइक्रोएसडी कार्ड डाला गया है।</strong>",
  pairing: {
    failed: "अपुष्ट युग्मन। कृपया अपना BitBox02 फिरसे प्लग करें।",
    paired: "आपने अपने डिवाइस पर पुष्टि की है कि कोड मेल खाता है। यदि यह सही है, तो आप नीचे दिए गए बटन पर क्लिक करके जारी रख सकते हैं।",
    title: "pairing कोड सत्यापित करें",
    unpaired: "एक नया BitBox02 पता चला है। कृपया सत्यापित करें कि निम्न कोड आपके डिवाइस पर दिखाया गया है। यदि कोड मेल खाता है, तो अपने BitBox02 पर चेक मार्क के नीचे टच करें और फिर जारी रखने के लिए नीचे दिए गए बटन पर क्लिक करें।"
  },
  restoreFromMnemonic: {
    failed: "नेमोनिक सीड से बहाल करना विफल रहा, कृपया पुनः प्रयास करें।"
  },
  stepBackup: {
    beforeProceed: "आगे बढ़ने से पहले, कृपया इन महत्वपूर्ण सुरक्षा विचारों को पढ़ें:",
    createBackup: "अब आप अपने माइक्रोएसडी कार्ड पर एक बैकअप बनाएंगे।"
  },
  stepBackupSuccess: {
    fundsSafe: "अपने धन को सुरक्षित रखने के लिए, कृपया निम्नलिखित को याद रखें:",
    title: "बैकअप पुनः स्थापित किया!"
  },
  stepConnected: {
    unlock: "अनलॉक करने के लिए BitBox02 पासवर्ड डाले।"
  },
  stepCreate: {
    nameLabel: "BitBox02 नाम",
    namePlaceholder: "मेरा BitBox02",
    title: "BitBox02 का नाम चुनें",
    toastMicroSD: "कृपया सुनिश्चित करें कि आपका माइक्रोएसडी कार्ड आपके BitBox02 में डाला गया है।"
  },
  stepCreateSuccess: {
    removeMicroSD: "कृपया अपने BitBox02 से माइक्रोएसडी कार्ड निकालें और इसे सुरक्षित स्थान पर संग्रहीत करें।",
    success: "आपने सफलतापूर्वक अपना बैकअप बना लिया है।"
  },
  stepPassword: {
    title: "BitBox02 का पासवर्ड सेट करें",
    useControls: "पासवर्ड सेट करने के लिए अपने BitBox02 के नियंत्रण का उपयोग करें।"
  },
  stepUninitialized: {
    create: "मैं एक नया BitBox02 सेटअप करना चाहता हूं।",
    restore: "मैं अपने वॉलेट को एक बैकअप से पुनर्स्थापित करना चाहता हूं।",
    restoreMicroSD: "माइक्रोएसडी कार्ड से पुनर्स्थापित करें",
    restoreMnemonic: "mnemonic से पुनर्स्थापित करें",
    title: "अपना BitBox02 सेटअप करें"
  },
  success: {
    text: "हुर्रे! आपका BitBox02 अब उपयोग करने के लिए तैयार है।\n\nBitBoxApp का उपयोग कैसे करें के बारे में अधिक जानकारी के लिए, शीर्ष दाएं कोने पर प्रश्न चिह्न पर क्लिक करके इन-ऐप गाइड का उपयोग करें।",
    title: "आप आगे जाने के लिए तैयार हैं!"
  }
};
const blink$8 = {
  button: "झपकी"
};
const bootloader$8 = {
  button: "अब फर्मवेयर अपग्रेड करें",
  progress: "अपग्रेड हो रहा है: {{progress}}%",
  success: "अपग्रेड सफल हुआ! कृपया डिवाइस को फिर से डाले। इस बार, बटन को स्पर्श न करें।"
};
const button$d = {
  abort: "बीच में ही नष्ट करने के लिए",
  back: "वापस जाएँ",
  changepin: "डिवाइस पासवर्ड बदलें",
  check: "बैकअप की जाँच करें",
  "continue": "Continue",
  copy: "कॉपी करें",
  create: "सर्जन करे",
  download: "डाउनलोड",
  hiddenwallet: "हिडन वॉलेट बनाएं",
  next: "आगे",
  ok: "ठीक",
  previous: "पिछला",
  receive: "प्राप्त करें",
  restore: "पुनर्स्थापित करें",
  select: "Select",
  send: "भेजें",
  unlock: "अनलॉक",
  update: "Update",
  upgrade: "अपग्रेड"
};
const changePin$8 = {
  newTitle: "नया डिवाइस पासवर्ड",
  oldLabel: "वर्तमान डिवाइस पासवर्ड"
};
const checkSDcard$8 = "माइक्रो एसडी कार्ड की जाँच हो रही है";
const clickHere$8 = "यहां क्लिक करे।";
const confirm$a = {
  abortInfo: "टेप करे ",
  abortInfoRedText: "बीच में ही नष्ट करे",
  approveInfo: "4+ सेकंड के लिए होल्ड करें",
  approveInfoGreenText: " पुष्टि करने के लिए",
  info: "अपने BitBox पर",
  infoWhenPaired: "पहले आपका पेर किया हुआ मोबाइल और फिर आपका BitBox"
};
const confirmOnDevice$8 = "कृपया अपने डिवाइस पर पुष्टि करें।";
const device$8 = {
  appUpradeRequired: "आपका BitBox इस डेस्कटॉप एप्लिकेशन के अनुकूल नहीं है। कृपया नवीनतम वर्जन डाउनलोड और इंस्टॉल करें।"
};
const deviceLock$8 = {
  button: "Two Factor Authorization (2FA) सक्षम करे",
  condition1: "क्या आपके पास बैकअप है?",
  condition2: "क्या मोबाइल ऐप वेरिफिकेशन कार्य कर रहा है?",
  condition3: "2FA बैकअप और मोबाइल ऐप पेयरिंग को बेकार बनाता है। डिवाइस को 2FA से बाहर निकलने के लिए RESET होना चाहिए!",
  confirm: "Two Factor Authorization (2FA) सक्षम करे",
  title: "Two Factor Authorization (2FA) सक्षम करे"
};
const deviceSettings$8 = {
  firmware: {
    newVersion: {
      label: "उपलब्ध वर्जन"
    },
    title: "फर्मवेयर",
    upToDate: "आपका डिवाइस अप टू डेट है",
    version: {
      label: "वर्जन"
    }
  },
  hardware: {
    sdcard: {
      "false": "डाला नहीं गया",
      label: "माइक्रो एसडी कार्ड",
      "true": "डाला गया"
    },
    title: "हार्डवेयर"
  },
  loading: "उपकरण जानकारी पुनर्प्राप्त कर रहा है…",
  pairing: {
    lock: {
      "false": "डिसेबल है",
      label: "Two Factor Authorization (2FA)",
      "true": "सक्रिय है"
    },
    mobile: {
      "false": "बन्द है",
      label: "मोबाइल एप्लिकेशन",
      "true": "खोलो"
    },
    status: {
      "false": "जोड़ा नहीं",
      label: "स्थिति",
      "true": "जुड़ गया"
    },
    title: "पेअर करो"
  },
  secrets: {
    manageBackups: "बैकअप मैनेज करें",
    title: "सीक्रेट"
  }
};
const deviceTampered$8 = "क्या आपका BitBox एक रिकवरी पासवर्ड के साथ आया गई है? यदि हां, तो सेटअप प्रक्रिया बंद करें और तुरंत support से संपर्क करें। Shift आपको कभी भी तैयार किए गए वॉलेट या पासवर्ड की सिफारिशें नहीं देगा।";
const dialog$9 = {
  cancel: "रद्द करे",
  confirm: "पुष्टि करें"
};
const fiat$a = {
  "default": "डिफ़ॉल्ट",
  setDefault: "set {{code}} as default",
  title: "मुद्राओं"
};
const footer$a = {
  appVersion: "एप्लिकेशन वर्जन:"
};
const genericError$8 = "एक एरर पाई गई। यदि आपको कोई समस्या दिखाई देती है, तो कृपया एप्लिकेशन को पुनः आरंभ करें।";
const goal$8 = {
  buttons: {
    create: "एक नया वॉलेट बनाएँ",
    restore: "बैकअप से वॉलेट को पुनर्स्थापित करें"
  },
  paragraph: "कृपया निम्न में से किसी एक विकल्प को चुनें:",
  step: {
    "1": {
      title: "सुरक्षा जानकारी"
    },
    "2": {
      description: "डिवाइस पासवर्ड सेट करें",
      title: "डिवाइस"
    },
    "3-create": {
      description: "एक नया वॉलेट बनाएँ",
      title: "वॉलेट"
    },
    "3-restore": {
      description: "बैकअप से",
      title: "पुनर्स्थापित करें"
    },
    "4-create": {
      title: "सारांश"
    },
    "4-restore": {
      title: "सारांश"
    }
  }
};
const guide$9 = {
  accountDescription: {
    text: "आपका खाता अवलोकन आपके उपलब्ध संतुलन के साथ-साथ आने वाले और बाहर जाने वाले लेनदेन को दर्शाता है। 'सेटिंग्स’ में हमारे गाइड में प्रत्येक खाता प्रकार के बारे में अधिक जानकारी है। ",
    title: "यह पेज मुझे क्या दिखाता है?"
  },
  accountFiat: {
    text: "हाँ। फिएट मुद्राओं के माध्यम से घूमने के लिए किसी भी टिकर पर क्लिक करें। आप सेटिंग्स में मुद्राओं की सूची को बदल सकते हैं।",
    title: "क्या मैं अन्य रूपांतरण दरें प्रदर्शित कर सकता हूं?"
  },
  accountIncomingBalance: {
    text: "आने वाली रकम आपके द्वारा हस्तांतरित की गई राशि के बराबर है लेकिन अभी तक नेटवर्क द्वारा पुष्टि नहीं की गई है।",
    title: "incoming का क्या मतलब है?"
  },
  accountInfo: {
    xpub: {
      text: "एक विस्तारित पुब्लिक की एक रूट की है जिसमें से कोई अकाउंट के सारे रिसीव एड्रेस बनाये जाते हे।\nयह यहां केवल-वॉलेट्स जैसे कि इलेक्ट्रम या सेंटिनल के साथ उन्नत उपयोग और इंटरऑपरेबिलिटी के लिए प्रदान किया जाता है।",
      title: "एक विस्तारित पुब्लिक की क्या है?"
    }
  },
  accountRates: {
    text: "हम CoinGecko से हर मिनट विनिमय दर अपडेट करते हैं। \n",
    title: "कौन सी विनिमय दरें लागू होती हैं?"
  },
  accountReload: {
    text: "कोई जरूरत नहीं है। आपकी लेन-देन की जानकारी अपने आप अपडेट हो जाती है।",
    title: "क्या मैं लेनदेन इतिहास पुनः लोड कर सकता हूं?"
  },
  accountSendDisabled: {
    text: "आपका शेष शून्य से अधिक होने पर  'Send' बटन सक्रिय हो जाता है।",
    title: "मैं कोई {{unit}} क्यों नहीं भेज सकता ?"
  },
  accountTransactionAttributesBTC: {
    text: "वर्चुअल साइज: नेटवर्क शुल्क निर्धारित करने के लिए उपयोग किया जाता है। यदि ट्रांजेक्शन के साइज से छोटा है तो आपने फीस पर सफलतापूर्वक बचत की है।\nसाइज: ब्लॉकचैन के अनुसार क्रमबद्ध होने पर बाइट्स में वास्तविक लेनदेन का साइज।\nवेइट: Segwit के साथ पेश किया गया, यह ट्रांजेक्शन और ब्लॉक आकारों का मूल्यांकन करने के लिए एक नया मीट्रिक है। प्रत्येक segregated witness बाइट की गिनती एक के रूप में होती है, बाकी सब चार वेट यूनिट के रूप में। वास्तविक आकार में एक मेगाबाइट के बजाय, ब्लॉक आकार की सीमा अब चार मिलियन वेट यूनिट है।",
    title: "बिटकॉइन-विशिष्ट लेनदेन के विवरण के बारे में क्या?"
  },
  accountTransactionAttributesGeneric: {
    text: "पुष्टि(Confirmations): आपका पहला लेन-देन प्रसारण अपुष्ट है जब तक कि एक miner इसे एक ब्लॉक में शामिल नहीं करता है, जिसके बाद इसकी एक पुष्टि होती है। नेटवर्क पर प्रसारित प्रत्येक ब्लॉक आपके लेनदेन में एक और पुष्टि जोड़ता है। आम तौर पर व्यापारी केवल तीन से छह पुष्टियों के बीच लेनदेन का निपटान करेंगे।\nलेनदेन आईडी(Transaction ID): एक विशिष्ट पहचान संख्या जो आपको ब्लॉक एक्सप्लोरर में लेनदेन देखने की अनुमति देती है।\nशुल्क(Fee): ब्लॉक में लेनदेन को शामिल करने के लिए एक प्रोत्साहन के रूप में खनिकों को लेनदेन शुल्क का भुगतान किया जाता है। अधिक जानने के लिए, भेजें बटन पर क्लिक करें।",
    title: "ट्रांजेक्शन के विवरण में दर्शाई गई जानकारी क्या है?"
  },
  accountTransactionConfirmation: {
    text: "यह एक ट्रांजेक्शन है जिसे नेटवर्क पर प्रसारित किया गया है और पुष्टि होने की प्रतीक्षा कर रहा है।",
    title: "पेंडिंग ट्रांजेक्शन क्या है?"
  },
  accountTransactionLabel: {
    text: "यह वह एड्रेस है जहां आपने कोइन्स प्राप्त किए थे या कोइन्स को भेजा था।",
    title: "प्रत्येक लेनदेन के लिए कौन सा पता प्रदर्शित होता है?"
  },
  accountTransactionTime: {
    text: "ब्लॉकचेन लेनदेन पुष्टि समय।",
    title: "क्या समय प्रदर्शित किया जाता है?"
  },
  appendix: {
    link: "हमसे संपर्क करें!",
    text: "एक और सवाल?"
  },
  backups: {
    check: {
      text: "'चेक बैकअप' आपको यह सत्यापित करने की अनुमति देता है कि आपके पास अपने वर्तमान बटुए के अनुरूप काम करने वाला बैकअप है। यह सत्यापित करने के लिए भी उपयोग किया जा सकता है कि आपके पास अभी भी सही पुनर्प्राप्ति पासवर्ड है। आप अपने मुख्य रिकवरी पासवर्ड या अपने छिपे हुए रिकवरी पासवर्ड की जांच कर सकते हैं।",
      title: "'चेक बैकअप’ क्या है?"
    },
    encrypt: {
      text: "नहीं, लेकिन आपके संग्रहीत सीड से वॉलेट को पाने के लिए रिकवरी पासवर्ड जरुरी है लेकिन आपके रिकवरी पासवर्ड को संग्रहीत बीज से वॉलेट प्राप्त करना आवश्यक है।",
      title: "क्या मैं बैकअप एन्क्रिप्ट कर सकता हूं?"
    },
    howOften: {
      text: "नया वॉलेट बनाए जाने पर बैकअप अपने आप जेनरेट हो जाता है। यदि आपका माइक्रोएसडी कार्ड खो जाता है या क्षतिग्रस्त हो जाता है, या यदि आप कई माइक्रोएसडी कार्ड बैकअप के रूप में उपयोग करना चाहते हैं, तो आपको केवल एक नया बैकअप बनाना होगा।\nलेन-देन गतिविधि के बाद आपको नए बैकअप बनाने की आवश्यकता नहीं है। आपके सभी लेनदेन डेटा को आपके एकल बैकअप द्वारा पुनः बनाया जा सकता है जो आपके लिए स्वचालित रूप से उत्पन्न हुआ था।",
      title: "मुझे कितनी बार बैकअप लेना है?"
    },
    whatIsABackup: {
      text: "यह माइक्रोएसडी कार्ड पर सीड की एक प्रति है। आपके पुनर्प्राप्ति पासवर्ड के साथ सीड आपके बटुए को उत्पन्न करता है।",
      title: "बैकअप क्या है?"
    }
  },
  backupsBB02: {
    check: {
      text: "'चेक बैकअप' आपको यह सत्यापित करने की अनुमति देता है कि आपके पास अपने वर्तमान बटुए के अनुरूप काम करने वाला बैकअप है।",
      title: "'चेक बैकअप ’क्या है?"
    },
    encrypt: {
      text: 'नहीं, कृपया माइक्रोएसडी कार्ड को सुरक्षित रखें, क्योंकि इसमें आपके बटुए को पुनर्प्राप्त करने के लिए अनएन्क्रिप्टेड बीज होता है। यदि आप अपने बीज को पासवर्ड से सुरक्षित करना चाहते हैं, तो आप "मैनेज डिवाइस" के तहत विशेषज्ञ सेटिंग्स में एक वैकल्पिक पासफ़्रेज़ सक्षम कर सकते हैं।',
      title: "क्या मैं बैकअप एन्क्रिप्ट कर सकता हूं?"
    },
    whatIsABackup: {
      text: "यह माइक्रो एसडी कार्ड पर सीड की एक नकल है।",
      title: "बैकअप क्या है?"
    }
  },
  bitbox: {
    "2FA": {
      text: "जब 2FA सक्षम होता है, तो कोइन्स को खर्च करने के लिए जोड़े गए मोबाइल फोन पर सभी ट्रांजेक्शन को मंजूरी देनी होती है। थोड़े शब्दों में, एक एन्क्रिप्टेड एकल-उपयोग नंबर मोबाइल ऐप पर भेजा जाता है, वहां डिक्रिप्ट किया जाता है, और स्वीकार बटन दबाते ही BitBox में वापस आ जाता है। डिवाइस के साथ यह संचार मोबाइल फोन और डेस्कटॉप ऐप के बीच पेयरिंग के दौरान स्थापित चैनल के माध्यम से किया जाता है।\n2FA सक्षम करने से पहले अपने वॉलेट का बैकअप लें और मोबाइल ऐप को पेयर करें। एक बार सक्षम होने के बाद, माइक्रो एसडी स्लॉट और मोबाइल ऐप पेयरिंग अक्षम हो जाती है। वे BitBox को रीसेट करके फिर से सक्षम हो सकते हैं, जो डिवाइस को मिटा देता है।",
      title: "Two Factor Authorization (2FA) कैसे काम करता है?"
    },
    disable2FA: {
      text: "2FA को निष्क्रिय करने के लिए, आपको अपना BitBox रीसेट करना होगा और फिर इसके बैकअप से वॉलेट को पुनर्स्थापित करना होगा। सुनिश्चित करें कि आपके पास अभी भी बैकअप के साथ माइक्रो एसडी कार्ड है और आपको अभी भी रिकवरी पासवर्ड याद है। फिर 'रीसेट डिवाइस' दबाएं। एक नया डिवाइस पासवर्ड सेट करें और 'बैकअप पुनर्स्थापित करें' चुनें। वॉलेट से आपके द्वारा बनाया गया बैकअप चुनें, 'रिस्टोर' पर क्लिक करें और वॉलेट बनाते समय आपके द्वारा उपयोग किए गए रिकवरी पासवर्ड को दर्ज करें।",
      title: "मैं Two Factor Authorization (2FA) को कैसे निष्क्रिय कर सकता हूं?"
    },
    ejectBitbox: {
      text: "बिना BitBox को हटाए आप किसी भी समय BitBox को अनप्लग कर सकते हैं।",
      title: "मैं BitBox कैसे निकाल सकता हूं?"
    },
    ejectSD: {
      text: "जब तक आप बैकअप बनाने या पुनर्स्थापित करने की प्रक्रिया में नहीं हैं, तब तक आप किसी भी समय बिटबॉक्स से माइक्रोएसडी कार्ड निकाल सकते हैं।",
      title: "मैं माइक्रो एसडी कार्ड कैसे निकाल सकता हूं?"
    },
    hiddenWallet: {
      text: "यह एक अलग डिवाइस पासवर्ड और रिकवरी पासवर्ड द्वारा संरक्षित एक ही डिवाइस पर एक दूसरा वॉलेट है, जिसका उपयोग आप संभावित इनकार (plausible deniability) के लिए कर सकते हैं। एक ही बैकअप बीज का उपयोग आपके सामान्य और हिडन वॉलेट दोनों के लिए किया जाता है, इसलिए अतिरिक्त बैकअप की आवश्यकता नहीं है।",
      title: "हिडन वॉलेट क्या है?"
    },
    legacyHiddenWallet: {
      text: "पहले नीचे दिए गए बटन पर क्लिक करें (उपलब्ध यदि BitBox मुख्य डिवाइस पासवर्ड के साथ अनलॉक किया गया है और 2FA अक्षम है), तो अपने BitBox को फिर से प्लेग क्रे और इसे अपने छिपे हुए डिवाइस पासवर्ड से अनलॉक करें।",
      title: "मैं लिगेसी हिडन वॉलेट का उपयोग कैसे करूं?"
    },
    pairing: {
      text: "iOS या Android के लिए हमारे मोबाइल ऐप को डाउनलोड करने के बाद, आप प्रदर्शित QR कोड को स्कैन करते हैं, जो मोबाइल ऐप और इस एप्लिकेशन के बीच एक सुरक्षित चैनल सेट करता है। एक बार स्कैन करने के बाद, मोबाइल ऐप में दिए गए निर्देशों का पालन करें।",
      title: "कैसे सुरक्षित रूप से अपने फोन के साथ जोड़े"
    }
  },
  receive: {
    address: {
      text: "आप सिक्के भेजने के लिए दूसरों को पता दे सकते हैं। बस सुनिश्चित करें कि आप सही पते पर भेज रहे हैं।",
      title: "मैं एड्रेस के साथ क्या करूँ?"
    },
    addressChange: {
      text: "जैसे ही आप लेन-देन करते हैं, सूची में एक नया पता अपने आप जुड़ जाता है इसलिए हमेशा 20 पते उपलब्ध होते हैं जिन्हें कभी कोई सिक्का नहीं मिला।",
      title: "एड्रेसिस कब बदलते हैं?"
    },
    howVerify: {
      text: "BitBox01 के लिए, बाईं ओर साइडबार में BitBox आइकन पर क्लिक करें और युग्मन अनुभाग देखें। गाइड अपडेट होगा और आप वहां से निर्देशों का पालन करना जारी रख सकते हैं।\nBitBox02 के लिए, आप भेजने / प्राप्त करने की प्रक्रिया के दौरान सीधे डिवाइस पर पते सत्यापित कर सकते हैं।",
      title: "मैं किसी एड्रेस को सुरक्षित रूप से कैसे सत्यापित कर सकता हूं?"
    },
    why20: {
      text: 'स्टार्ट-अप के दौरान ऐप आपके सीड से प्राप्त पते को यह देखने के लिए उत्पन्न करता है कि क्या उन्हें धन प्राप्त हुआ है।चूंकि एप्लिकेशन लगभग अनंत संख्या में पते उत्पन्न कर सकता है, इसलिए यह शेष राशि निर्धारित करने में वर्षों का समय लगा सकता है। इस खोज को सीमित करने के लिए यह 20 पते देखने के बाद बंद हो जाता है जिन्हें कभी धन नहीं मिला है। यह "गैप सीमा" है और 20 एक वास्तविक मानक है, हालांकि संख्या मनमानी है। ये वे 20 पते हैं जिनसे आप चुन सकते हैं।',
      title: "केवल 20 पते ही क्यों?"
    },
    whyMany: {
      text: "गोपनीयता और सुरक्षा बनाए रखने के लिए, एक ही पते पर दो बार प्रयोग न करें। यदि आपने एक पते का उपयोग किया है, तो एक नए पते के लिए दाहिने तीर पर क्लिक करें। आप एक बार में 20 पते तक उत्पन्न कर सकते हैं।सभी पते आपके एकल बैकअप बीज से प्राप्त होते हैं।",
      title: "कई एड्रेसिस क्यों हैं?"
    },
    whyVerify: {
      text: "\nप्रामाणिक पते बनाने और प्रदर्शित करने के लिए आपको अपने कंप्यूटर पर भरोसा नहीं करना चाहिए। यह एक बड़ी हमले की सतह हार्डवेयर वॉलेट की तुलना में इसे काफी कमजोर बनाता है। BitBox01 के लिए, पते को सत्यापित करने का बटन सुरक्षित रूप से एक युग्मित मोबाइल फोन पर पते को भेजता है, जिससे आप QR कोड को स्कैन और सत्यापित भी कर सकते हैं। BitBox02 के लिए, पते को सीधे BitBox02 डिस्प्ले पर सत्यापित किया जा सकता है।",
      title: "मुझे एड्रेस सुरक्षित रूप से क्यों सत्यापित करना चाहिए?"
    }
  },
  send: {
    fee: {
      text: "शुल्क ट्रांजेक्शन डेटा के साइज पर आधारित है, न कि इसकी राशि पर। शुल्क लक्ष्य की गणना आपके द्वारा चुनी गई प्रत्येक नेटवर्क प्राथमिकता के लिए Bitcoin Core के शुल्क आकलन एल्गोरिथ्म द्वारा की जाती है। यदि वे नीचे दिए गए लक्ष्य से भिन्न हैं, तो उन्हें दिखाया जाता है।\nइकोनॉमी: 24 ब्लॉक (Bitcoin के लिए लगभग 4 घंटे, Litecoin के लिए 1 घंटे)\nकम: 12 ब्लॉक (Bitcoin के लिए लगभग 2 घंटे, Litecoin के लिए 30 मिनट)\nसामान्य: 6 ब्लॉक (Bitcoin के लिए लगभग 1 घंटे, Litecoin के लिए 15 मिनट)\nउच्च: 2 ब्लॉक (Bitcoin के लिए लगभग 20 मिनट, Litecoin के लिए 5 मिनट)\n(Bitcoin के लिए औसत दस मिनट (लिटकोइन में 2.5 मिनट) में एक ब्लॉक में होता है  और उपरोक्त अवधि में नेटवर्क लोड काफी भिन्न हो सकता है।)",
      title: "शुल्क कैसे निर्धारित किया जाता है?"
    },
    priority: {
      text: "जितना ज्यादा शुल्क आप भुगतान करने के लिए तैयार हैं, उतनी जल्दी आपके ट्रांजेक्शन की नेटवर्क द्वारा आम तौर पर पुष्टि की जाती है।",
      title: "नेटवर्क प्राथमिकता क्या है?"
    },
    revert: {
      text: "ट्रांजेक्शन पर हस्ताक्षर करने और भेजने (यानी नेटवर्क पर प्रसारित) के बाद, इसे वापस नहीं किया जा सकता है। हस्ताक्षर करने से पहले लेनदेन (शुल्क सहित) को ठीक से सत्यापित करें!\nयदि आप प्राप्तकर्ता को जानते हैं और वह या वह आपको वही राशि (लेनदेन शुल्क घटाकर) भेजने को तैयार है, तो आप उन्हें एक नया प्राप्त करने वाला एड्रेस भेज सकते हैं।",
      title: "क्या मैं ट्रांजेक्शन वापस कर सकता हूं?"
    },
    whyFee: {
      text: "ट्रांजेक्शन माइनर द्वारा पुष्टि किए जाने की होड़ में होते है। माइनर्स अपनी फीस के आधार पर ब्लॉकचैन में शामिल किए जाने वाले ट्रांजेक्शन का चयन करते हैं।\nट्रांजेक्शन के इतिहास पर माइनर्स वोट करते हैं। चूंकि प्रति व्यक्ति एक वोट (जो कि ब्लॉकचेन का पूरा बिंदु है) को लागू करने के लिए कोई विश्वसनीय तीसरा पक्ष नहीं है, माइनर कंप्यूटिंग शक्ति जैसे महंगे संसाधन का त्याग करके लेनदेन पर वोट देते हैं। अपने काम के लिए एक इनाम के रूप में, वे नए बनाए गए कोइन्स और उनके द्वारा शामिल सभी ट्रांजेक्शन के शुल्क का दावा कर सकते हैं।",
      title: "नेटवर्क शुल्क क्यों है?"
    }
  },
  "settings-electrum": {
    what: {
      text: "शिफ्ट सर्वर का उपयोग करने के बजाय अपने स्वयं के पूर्ण नोड के साथ अपने वॉलेट को चलाना संभव है।",
      title: "यह क्या है?"
    }
  },
  settings: {
    servers: {
      text: "यह ऐप अपडेट, चेक लेन-देन के लिए शिफ़्ट क्रिप्टोकरेंसी सर्वर के साथ संचार करता है, और युग्मित मोबाइल ऐप पर जानकारी भेजता है।\nऐप क्रिप्टोकरंसीप के नवीनतम विनिमय दरों को भी पुनः प्राप्त करता है। सभी रूपांतरणों की गणना स्थानीय रूप से की जाती है जिसका अर्थ है कि आपके लेन-देन की मात्रा के बारे में कोई डेटा कभी प्रसारित नहीं होता है।\nनोट: एथेरियम और ईआरसी 20 टोकन के लिए, हम एथरस्कैनियो एपीआई का उपयोग करते हैं।",
      title: "यह ऐप किन सर्वरों से बात करता है?"
    }
  },
  title: "मार्गदर्शक",
  toggle: {
    close: "गाइड बंद करें",
    open: "गाइड"
  },
  unlock: {
    forgotDevicePassword: {
      text: "आपको रिकवरी पासवर्ड का उपयोग करके डिवाइस को रीसेट करना होगा और वॉलेट को बैकअप से पुनर्स्थापित करना होगा।",
      title: "यदि मैं डिवाइस पासवर्ड भूल गया हूं तो मैं क्या करूं?"
    },
    reset: {
      text: "15 बार एक गलत डिवाइस पासवर्ड डालें। अंतिम कुछ प्रयासों के लिए डिवाइस पर एक लंबे स्पर्श की आवश्यकता होती है।",
      title: "मैं डिवाइस को कैसे रीसेट करूं?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "एक बार डालने पर डिवाइस को ब्लिंक करना चाहिए। सुनिश्चित करें कि यह सही तरीके से डाला गया है। यदि आपको परेशानी हो रही है, तो कृपया नीचे दिए गए लिंक के माध्यम से हमसे संपर्क करें।",
      title: "मेरा BitBox01 पहचान नहीं रहा है"
    },
    getDevice: {
      link: {
        text: "BitBox ऑर्डर करें"
      },
      text: "आप हमारी ऑनलाइन दुकान में BitBox खरीद सकते हैं:",
      title: "मैं BitBox डिवाइस कैसे प्राप्त कर सकता हूं?"
    },
    internet: {
      text: "हां, वॉलेट को सिंक्रनाइज़ करने, ट्रांजेक्शन भेजने और नवीनतम विनिमय दरों को पुनः प्राप्त करने के लिए इंटरनेट कनेक्शन की आवश्यकता होती है।",
      title: "क्या इस ऐप के लिए इंटरनेट कनेक्शन की आवश्यकता है?"
    },
    lostDevice: {
      link: {
        text: "बैकअप सेंटर"
      },
      text: "आप एक नए BitBox पर या हमारे बैकअप सेंटर के साथ अपने अकाउंट को पुनर्प्राप्त कर सकते हैं।",
      title: "मैंने अपना डिवाइस खो दिया। अब क्या?"
    },
    useWithoutDevice: {
      text: "दुर्भाग्य से, यह फिलहाल संभव नहीं है।",
      title: "क्या मैं डिवाइस के बिना ऐप का उपयोग कर सकता हूं?"
    },
    welcome: {
      text: "स्विट्जरलैंड में Shift Crypto द्वारा निर्मित इस ऐप का उपयोग करने के लिए धन्यवाद। हम आपके द्वारा साझा किए गए किसी भी इनपुट की सराहना करते हैं। कृपया नीचे दिए गए लिंक का उपयोग करके प्रतिक्रिया दें।",
      title: "BitBox ऐप में आपका स्वागत है!"
    }
  }
};
const headerssync$8 = {
  blocksSynced: "{{blocks}} ब्लॉक सिंक किए गए"
};
const hiddenWallet$8 = {
  info1HTML: "संभावित अस्वीकार (plausible deniability) के लिए, <strong>विभिन्न</strong> डिवाइस पासवर्ड + रिकवरी पासवर्ड संयोजन के आधार पर एक हिडन वॉलेट बनाया जा सकता है ।",
  info2HTML: "डिवाइस पासवर्ड और रिकवरी पासवर्ड को परिभाषित करें जिसे आप अपने छिपे हुए वॉलेट के साथ जोड़ना चाहते हैं। जिन्हें आपने अपने प्राथमिक वॉलेट के लिए परिभाषित किया है उनसे डिवाइस पासवर्ड और रिकवरी पासवर्ड <strong>विभिन्न</strong> होना चाहिए   ",
  passwordLabel: "हिडन रिकवरी पासवर्ड",
  passwordPlaceholder: "कृपया हिडन रिकवरी पासवर्ड की पुष्टि करें",
  pinLabel: "हिडन डिवाइस पासवर्ड",
  pinRepeatLabel: "हिडन डिवाइस पासवर्ड को दोहराएं",
  pinRepeatPlaceholder: "कृपया हिडन डिवाइस पासवर्ड की पुष्टि करें",
  success: "हिडन वॉलेट सफलतापूर्वक बनाया गया। इसे अनलॉक करने के लिए अपने BitBox को फिर से भरें।"
};
const initialize$8 = {
  create: "डिवाइस पासवर्ड सेट करें",
  creating: "डिवाइस पासवर्ड सेट कर रहे है ...",
  error: {
    e102: "डिवाइस पासवर्ड में कम से कम 4 अक्षर होने चाहिए।"
  },
  info: {
    description1: "अपना डिवाइस पासवर्ड चुनें। इसका उपयोग आपके BitBox को अनलॉक करने के लिए किया जाएगा।",
    description2: "आप संख्याओं, अक्षरों का उपयोग कर सकते हैं। लंबे पासवर्ड उच्च सुरक्षा प्रदान करते हैं।",
    description3: "यदि आप डिवाइस पासवर्ड खो देते हैं, तो आपको अपना डिवाइस रीसेट करना होगा और अपने वॉलेट बैकअप को पुनर्स्थापित करना होगा।",
    subtitle: "अब आप अपना डिवाइस पासवर्ड सेट करेंगे",
    title: "अपने डिवाइस को इनिशियलाइज़ करे"
  },
  input: {
    label: "डिवाइस पासवर्ड",
    labelRepeat: "डिवाइस पासवर्ड दोहराएँ",
    placeholderRepeat: "कृपया डिवाइस पासवर्ड की पुष्टि करें"
  }
};
const invalidFormat$8 = "अवैध फॉर्मेट";
const language$9 = {
  title: "भाषा चुनिए"
};
const legacyhiddenwallet$8 = {
  disable: "लिगेसी हिडन वॉलेट को अक्षम करें",
  enable: "लिगेसी हिडन वॉलेट सक्षम करें",
  successDisable: "सफलतापूर्वक लिगेसी हिडन वॉलेट अक्षम कर दिया गया।",
  successEnable: "सफलतापूर्वक लिगेसी हिडन वॉलेट सक्षम किया गया। अपने BitBox को फिर से शुरू करें और लिगेसी हिडन वॉलेट तक पहुंचने के लिए हिडन डिवाइस पासवर्ड दर्ज करें।"
};
const loading$8 = "लोड हो रहा है…";
const notification$8 = {
  newTxs_one: "{{accountName}} में इसमें नया ट्रांजेक्शन",
  newTxs_other: "{{accountName}} में {{count}} नए ट्रांजेक्शंस"
};
const pairing$8 = {
  aborted: {
    text: "मोबाइल ऐप से जोड़ी को समाप्त कर दिया गया है।",
    title: "अंत कर दिया"
  },
  button: "मोबाइल ऐप जोड़े",
  confirm: "क्या आप वाकई अपने BitBox को जोड़ना चाहते हैं? ध्यान दें कि उसके बाद ट्रांजेक्शन करने के लिए मोबाइल फोन आवश्यक है।",
  connectOnly: {
    button: "मोबाइल ऐप कनेक्ट करें",
    title: "मेनू आइटम 'नए डेस्कटॉप ऐप से कनेक्ट करें' का चयन करके हमारे मोबाइल ऐप से स्कैन करें"
  },
  error: {
    text: "कुछ गलत हो गया। कृपया फिर से शुरू करें।",
    title: "एरर"
  },
  reconnectOnly: {
    button: "मोबाइल ऐप को फिर से कनेक्ट करें"
  },
  start: {
    hideAppQRCode: "QR कोड छिपाएं",
    revealAppQRCode: "QR कोड दिखाएं",
    step1: "यदि आपके पास मोबाइल ऐप नहीं है, तो आपके पास कौन सा फोन है उसके मुताबिक आप Apple App Store या Google Play Store के लिए QR कोड को स्कैन कर सकते हैं।",
    step2: "हमारे मोबाइल ऐप से स्कैन करें, जिसे आप iOS और Android के लिए ऐप स्टोर में 'Digital BitBox 2FA' नाम से पा सकते हैं:"
  },
  started: {
    text: "अब कृपया मोबाइल ऐप में दिए गए निर्देशों का पालन करें।",
    title: "Great"
  },
  success: {
    text: "बधाई हो, आपने अपने BitBox को सफलतापूर्वक मोबाइल ऐप के साथ जोड़ा है!",
    title: "सफलता"
  },
  timeout: {
    text: "यह जोड़ी दो मिनट के बाद समाप्त हो गई। यदि आप अभी भी मोबाइल ऐप को पेयर करना चाहते हैं तो फिर से शुरू करें।",
    title: "समय समाप्त"
  },
  title: "Mobile Pairing"
};
const password$8 = {
  show: "{{label}} दिखाए",
  warning: {
    caps: "चेतावनी: कैप्स लॉक (⇪) सक्षम है",
    paste: 'text चिपकाने के लिए, "{{label}} दिखाए" को सक्षम करें '
  }
};
const random$9 = {
  button: "रेण्डम संख्या उत्पन्न करें",
  description: "आपके BitBox ने निम्न {{bits}}-bit यादृच्छिक संख्या उत्पन्न किया :"
};
const receive$a = {
  label: "आपका एड्रेस",
  onlyThisCoin: {
    description: "अन्य टोकन प्राप्त करने के लिए, उन्हें सेटिंग में सक्षम करें। यदि आप अन्य टोकन जमा करते हैं, तो हो सकता है की वे सुलभ ना हो सके।",
    warning: "केवल इस पते पर {{coinName}} प्राप्त करना सुनिश्चित करें।"
  },
  showFull: "पूरा एड्रेस दिखाएं और सत्यापित करें",
  title: "{{accountName}} पाए",
  verify: "एड्रेस को सुरक्षित रूप से सत्यापित करें",
  verifyBitBox01: "मोबाइल ऐप पर एड्रेस सत्यापित करें",
  verifyBitBox02: "BitBox02 पर एड्रेस सत्यापित करें",
  verifyInstruction: "कृपया सत्यापित करें कि निम्न एड्रेस आपके डिवाइस पर प्रदर्शित एड्रेस से मेल खाता है।",
  warning: {
    secureOutput: "सुरक्षित पता सत्यापन को सक्षम करने के लिए कृपया अपने मोबाइल डिवाइस के साथ अपने BitBox को जोड़े। साइडबार में 'मैनेज डिवाइस' पर जाएं।"
  }
};
const reset$8 = {
  description: "डिवाइस का सभी डेटा हटा दिया जाएगा। जिसमें आपकी निजी कुंजी शामिल है!",
  notReset: "डिवाइस रीसेट नहीं है।",
  title: "फैक्टरी रीसेट डिवाइस",
  understand: "मेरे पास बैकअप है और मेरा रिकवरी पासवर्ड मुझे पता है",
  understandBB02: "मेरे पास एक वैध बैकअप है"
};
const securityInformation$8 = {
  create: {
    description1: "अपने डिवाइस को सेट करने से पहले यह सलाह दी जाती है कि आप ऐसा सुरक्षित वातावरण में करें।",
    description2: "आपको दो पासवर्ड बनाने के लिए कहा जाएगा।",
    description3: "पहला है <strong>डिवाइस पासवर्ड</strong> जो आपके BitBox डिवाइस को अनलॉक करता है और ये पासवर्ड बादमे में बदला जा सकता है।",
    description4: "दूसरा है <strong>रिकवरी पासवर्ड</strong> जो आपके वॉलेट को अनलॉक करता है। इस पासवर्ड को बाद में नहीं बदला जा सकता है।",
    description5: "आपके द्वारा बनाया गया वॉलेट, माइक्रो SD कार्ड पर एक फाइल में बैकअप होगा। इसका उपयोग आपातकाल में <strong>रिकवरी पासवर्ड</strong> का उपयोग करके आपके धन को प्राप्त करने के लिए किया जा सकता है ।",
    title: "सुरक्षा जानकारी"
  },
  restore: {
    description1: "आपको उस माइक्रोएसडी कार्ड को डालने के लिए कहा जाएगा जिसका उपयोग आपने बैकअप स्टोर करने के लिए किया था।",
    description2: "अपने डिवाइस को पुनर्स्थापित करने के लिए आपको अपने रिकवरी पासवर्ड की आवश्यकता होगी। ",
    description3: "कृपया रिकवरी पासवर्ड दर्ज करते समय ध्यान रखें। आपके द्वारा दर्ज किया गया कोई भी पासवर्ड एक वैध वॉलेट बनाएगा। यदि आप गलत पासवर्ड दर्ज करते हैं तो आपको एक वॉलेट बैलेंस दिखाया जा सकता है जिसकी आपको उम्मीद नहीं है।",
    title: "सुरक्षा जानकारी"
  }
};
const seed$8 = {
  agreements: {
    "funds-access": "यदि मैं अपना रिकवरी पासवर्ड भूल जाता हूं तो मैं अपने फंड तक नहीं पहुंच पाऊंगा",
    "password-change": "मैं बाद में रिकवरी पासवर्ड नहीं बदल सकता",
    "password-required": "एक बैकअप से वॉलेट को पुनर्स्थापित करने के लिए रिकवरी पासवर्ड आवश्यक है"
  },
  create: "वॉलेट बनाएं",
  creating: "वॉलेट बन रहा है",
  description: "मैं समझता हूँ कि:",
  error: {
    e102: "पासवर्ड में कम से कम 4 अक्षर होने चाहिए।",
    e200: "वॉलेट बनाने के लिए आपको अपने BitBox में एक माइक्रो एसडी कार्ड डालने की आवश्यकता होती है, इसलिए एक बैकअप स्वचालित रूप से बनाया जा सकता है।"
  },
  info: {
    button: "अब रिकवरी पासवर्ड सेट करें",
    description1: "BitBox में माइक्रो एसडी कार्ड डालें",
    description2: 'वॉलेट के लिए एक रिकवरी पासवर्ड चुनें और "अब रिकवरी पासवर्ड सेट करें" चुनें।',
    description3: "BitBox डिवाइस के गुम या चोरी हुए मामले में माइक्रो एसडी कार्ड का बैक अप और आपका रिकवरी पासवर्ड ही आपके फंड को रिकवर करने का एकमात्र तरीका है।",
    description4: "आप बाद में अपने धन को स्थानांतरित किए बिना अपना रिकवरी पासवर्ड नहीं बदल सकते।",
    title: "एक नया वॉलेट बनाएँ"
  },
  password: {
    label: "रिकवरी पासवर्ड",
    repeatPlaceholder: "रिकवरी पासवर्ड दोहराएँ"
  },
  walletName: {
    label: "वॉलेट का नाम"
  }
};
const seedRestore$8 = {
  error: {
    e200: "बैकअप से वॉलेट को पुनर्स्थापित करने के लिए माइक्रो एसडी कार्ड की आवश्यकता होती है।"
  },
  info: {
    description1: 'BitBox में माइक्रो एसडी कार्ड डालें और "जारी रखें" पर क्लिक करें',
    description2: 'एक बैकअप चुनें और "पुनर्स्थापित करें" पर क्लिक करें',
    description3: "रिकवरी पासवर्ड डालें",
    description4: "आपको यह पुष्टि करने की आवश्यकता है कि आप ये समझते है की एक गलत पासवर्ड एक अलग वॉलेट बनाएगा।",
    title: "बैकअप से वॉलेट को कैसे पुनर्स्थापित करें"
  }
};
const send$a = {
  abort: "ट्रांजेक्शन निरस्त कर दिया गया है।",
  address: {
    label: "रिसीवर का एड्रेस",
    placeholder: "एड्रेस डालें"
  },
  amount: {
    label: "रकम",
    placeholder: "राशी डालें"
  },
  button: "हस्ताक्षर करें और भेजें",
  coincontrol: {
    address: "एड्रेस",
    outpoint: "outpoint",
    title: "आउटपुट से भेजें"
  },
  confirm: {
    "selected-coins": "चयनित कोइन्स",
    title: "ट्रांजेक्शन की पुष्टि करें",
    total: "टोटल"
  },
  error: {
    insufficientFunds: "अपर्याप्त कोष",
    invalidAddress: "गलत एड्रेस",
    invalidAmount: "अवैध राशि",
    invalidData: "अमान्य डेटा"
  },
  fee: {
    customPlaceholder: "राशी डालें",
    label: "नेटवर्क शुल्क",
    placeholder: "उपलब्ध नहीं है"
  },
  feeTarget: {
    description: {
      economy: "24 ब्लॉक (Bitcoin के लिए लगभग 4 घंटे, Litecoin के लिए 1 घंटा)",
      high: "2 ब्लॉक (Bitcoin के लिए लगभग 20 मिनट, Litecoin के लिए 5 मिनट)",
      low: "12 ब्लॉक (Bitcoin के लिए लगभग 2 घंटे, Litecoin के लिए 30 मिनट)",
      normal: "6 ब्लॉक (Bitcoin के लिए लगभग 1 घंटे, Litecoin के लिए 15 मिनट)"
    },
    estimate: "अनुमानित प्रतीक्षा समय:",
    label: {
      economy: "किफायती",
      high: "उच्च",
      low: "कम",
      normal: "साधारण"
    },
    placeholder: "शुल्क आकलन की गणना कर रहे हैं ..."
  },
  maximum: "सब भेजें",
  scanQR: "QR कोड स्कैन करें",
  signprogress: {
    description: "यह एक ऐसा ट्रांजेक्शन है जिसमें बहुत अधिक डेटा है। ट्रांजेक्शन पर पूरी तरह से हस्ताक्षर करने के लिए आपको {{steps}} बार पुष्टि करने के लिए कहा जाएगा।",
    label: "प्रगति"
  },
  success: "ट्रांजेक्शन पर हस्ताक्षर किए गए हैं और भेजे गए हैं।",
  title: "{{accountName}} भेजें",
  toggleCoinControl: "Coin Control टॉगल करें"
};
const settings$9 = {
  electrum: {
    add: "एक सर्वर जोड़ें",
    "add-server": "जोड़े",
    check: "जांचें",
    checkFailed: "असफल हुआ",
    checkSuccess: "सफलतापूर्वक {{host}} से एक कनेक्शन स्थापित किया ",
    checking: "जांच हो रही है",
    "download-cert": "रिमोट सर्टिफिकेट डाउनलोड करें",
    "remove-server": "हटाएं",
    removeConfirm: "{{server}} हटाएं?",
    reset: "डिफ़ॉल्ट पर रीसेट करे",
    resetConfirm: "क्या आप सभी सर्वरों को हटाना चाहते हैं और डिफ़ॉल्ट सर्वरों को स्थापित करना चाहते हैं?",
    servers: "सर्वर्स",
    step1: "1",
    "step1-text": "endpoint दर्ज करें।",
    step2: "2",
    "step2-text": "सर्वर की सर्टिफिकेट चेन का एक सर्टिफिकेट डालें। वैकल्पिक रूप से, दूरस्थ प्रमाणपत्र डाउनलोड करें और इसे देख के तुलना करें।",
    step3: "3",
    "step3-text": "कनेक्शन की जाँच करें और सर्वर जोड़ें।",
    step4: "4",
    "step4-text": "वॉलेट को पुनरारंभ करें। यदि आप डिफ़ॉल्ट सर्वर को नहीं हटाते हैं, तो आपका अपना नोड अतिरेक के रूप में जोड़ा जाएगा।",
    "title-btc": "Bitcoin Electrum सर्वर्स",
    "title-ltc": "Litecoin Electrum सर्वर्स",
    "title-tbtc": "Bitcoin Testnet Electrum सर्वर्स",
    "title-tltc": "Litecoin Testnet Electrum सर्वर्स"
  },
  expert: {
    coinControl: "कॉइन नियंत्रण सक्षम करें",
    electrum: {
      title: "अपना फूल नोड कनेक्ट करें"
    },
    setProxyAddress: "प्रॉक्सी पता सेट करें",
    title: "विशेषज्ञ सेटिंग्स",
    useProxy: "टोर प्रॉक्सी सक्षम करें"
  },
  header: {
    home: "Home"
  },
  restart: "परिवर्तनों को प्रभावी करने के लिए कृपया BitBoxApp को फिर से शुरू करें।",
  success: "कृपया अनप्लग करें और परिवर्तनों को प्रभावी करने के लिए BitBox को फिर से भरें।",
  title: "सेटिंग्स"
};
const setup$8 = "सेटअप डिवाइस";
const sidebar$9 = {
  device: "डिवाइस मैनेज करे",
  leave: "छोड़े",
  settings: "सेटिंग्स"
};
const success$f = {
  create: {
    info1: "आपके वॉलेट को माइक्रो एसडी कार्ड में सुरक्षित रूप से बैकअप दिया गया है। इसे हटा दें और सुरक्षित रखें।",
    info2: "आपने एक सुरक्षित डिवाइस पासवर्ड बनाया है जो BitBox को अनलॉक करता है।",
    info3: "आपने अपने वॉलेट के लिए एक सुरक्षित रिकवरी पासवर्ड बनाया है जो आपके धन को अनलॉक करता है और आपके बैकअप को पुनर्स्थापित करता है।",
    summary: "आपने जो किया है उसका सारांश यहां दिया गया है",
    title: "सफलता"
  },
  getstarted: "शुरू करें",
  restore: {
    summary: "आपने अपने बैकअप से वॉलेट को सफलतापूर्वक पुनर्स्थापित कर दिया है।",
    title: "सफलता"
  }
};
const transaction$9 = {
  confirmation: "Confirmations",
  explorer: "ट्रांजेक्शन आईडी",
  explorerTitle: "बाहरी ब्लॉक एक्सप्लोरर में खोलें",
  fee: "शुल्क",
  fiatHistorical: "ऐतिहासिक",
  gas: "Gas",
  pending: "लंबित ट्रांजेक्शन",
  size: "आकार",
  vsize: "आभासी आकार",
  weight: "वजन"
};
const transactions$8 = {
  placeholder: "अभी तक कोई ट्रांजेक्शन नहीं हुआ।"
};
const unknownError$8 = "एक अज्ञात एरर हुई: {{errorMessage}}";
const unlock$8 = {
  description: "अपने डिवाइस को अनलॉक करने के लिए अपना डिवाइस पासवर्ड डालें।",
  error: {
    e109_normal: "गलत डिवाइस पासवर्ड। डिवाइस के रीसेट होने से पहले  {{remainingAttempts}} प्रयास बाकी रहे।",
    e109_touch: "$t(unlock.error.e109_normal) अगले लॉगिन के लिए टच बटन को पकड़ना आवश्यक है।",
    e113: "कई लॉगिन प्रयासों के कारण, अगले लॉगिन के लिए 4 सेकंड के लिए टच बटन को दबाए रखना पड़ेगा।"
  },
  input: {
    label: "डिवाइस पासवर्ड",
    placeholder: "डिवाइस को अनलॉक करने के लिए अपना डिवाइस पासवर्ड डालें"
  },
  unlocking: "अनलॉक कर रहे हैं ..."
};
const upgradeFirmware$9 = {
  button: "फर्मवेयर अपग्रेड करें",
  description: "क्या आप फर्मवेयर को {{currentVersion}} से {{newVersion}} वर्ज़न में अपग्रेड करना चाहते हैं ?",
  label: "आपके BitBox के लिए फर्मवेयर अपग्रेड आवश्यक है।",
  locked: "{{currentVersion}} से {{newVersion}} अपग्रेड करने के लिए, कृपया एक लंबा स्पर्श करें।",
  title: "फर्मवेयर अपग्रेड करें",
  unlocked: "बूटलोडर अनलॉक किया गया है। जारी रखने के लिए, कृपया:",
  unlocked1: "अपने Bitbox को अनप्लग करें और फिर से प्लग करें ",
  unlocked2: "जब आपका BitBox वापस प्लग इन हो जाएगा तब एलईडी लाइट प्रकाशित होगी",
  unlocked3: "एलईडी लाइट्स प्रकाशित होने पर पर टच बटन पर टैप करें"
};
const warning$e = {
  receivePairing: "कृपया सुरक्षित एड्रेस सत्यापन सक्षम करने के लिए BitBox को जोड़ीएं। साइडबार में 'मैनेज डिवाइस' पर जाएं।",
  sdcard: "जब तक आप बैकअप प्रबंधित नहीं करना चाहते, तब तक माइक्रो एसडी कार्ड को बिटबॉक्स से अलग रखें।",
  sendPairing: "ट्रांजेक्शन के विवरण को सुरक्षित रूप से सत्यापित करने के लिए कृपया BitBox को जोड़े। साइडबार में 'मैनेज डिवाइस' पर जाएं।"
};
const welcome$8 = {
  insertBitBox02: "BitBox02 के लिए, जारी रखने के लिए कृपया डिवाइस पर टैप करें।",
  insertDevice: "आरंभ करने के लिए कृपया अपना डिवाइस कनेक्ट करें",
  title: "आपका स्वागत हे"
};
const appTranslationsHI = {
  account: account$8,
  accountInfo: accountInfo$8,
  accountSummary: accountSummary$8,
  addAccount: addAccount$9,
  app: app$8,
  backup: backup$8,
  bb02Bootloader: bb02Bootloader$8,
  bitbox: bitbox$8,
  bitbox02Interact: bitbox02Interact$8,
  bitbox02Settings: bitbox02Settings$8,
  bitbox02Wizard: bitbox02Wizard$8,
  blink: blink$8,
  bootloader: bootloader$8,
  button: button$d,
  changePin: changePin$8,
  checkSDcard: checkSDcard$8,
  clickHere: clickHere$8,
  confirm: confirm$a,
  confirmOnDevice: confirmOnDevice$8,
  device: device$8,
  deviceLock: deviceLock$8,
  deviceSettings: deviceSettings$8,
  deviceTampered: deviceTampered$8,
  dialog: dialog$9,
  fiat: fiat$a,
  footer: footer$a,
  genericError: genericError$8,
  goal: goal$8,
  guide: guide$9,
  headerssync: headerssync$8,
  hiddenWallet: hiddenWallet$8,
  initialize: initialize$8,
  invalidFormat: invalidFormat$8,
  language: language$9,
  legacyhiddenwallet: legacyhiddenwallet$8,
  loading: loading$8,
  notification: notification$8,
  pairing: pairing$8,
  password: password$8,
  random: random$9,
  receive: receive$a,
  reset: reset$8,
  securityInformation: securityInformation$8,
  seed: seed$8,
  seedRestore: seedRestore$8,
  send: send$a,
  settings: settings$9,
  setup: setup$8,
  sidebar: sidebar$9,
  success: success$f,
  transaction: transaction$9,
  transactions: transactions$8,
  unknownError: unknownError$8,
  unlock: unlock$8,
  upgradeFirmware: upgradeFirmware$9,
  warning: warning$e,
  welcome: welcome$8
};
const account$7 = {
  disconnect: "Връзката е прекъсната. Опитваме отново ...",
  exportTransactions: "Експорт на транзакциите в папката Downloads като CSV файл",
  fatalError: "Възникна неочаквана грешка.",
  incoming: "Входящи",
  initializing: "Извличане на информация от блокчейна...",
  reconnecting: "Връзката е прекъсната, опитваме се да я възстановим..."
};
const accountInfo$7 = {
  address: "Адрес",
  extendedPublicKey: "Разширен публичен ключ",
  label: "Информация за профила",
  title: "Информация за портфейла",
  verify: "Потвърждение чрез устройството"
};
const accountSummary$7 = {
  balance: "Баланс",
  exportSummary: "Експорт на обобщената информация за портфейлите като CSV файл в папката Downloads",
  fiatBalance: "Баланс във фиатна валута",
  name: "Име на портфейла",
  noAccount: "Не съществуват портфейли",
  title: "Обобщена информация за портфейлите",
  total: "Общо"
};
const addAccount$8 = {
  title: "Добавяне на портфейл"
};
const app$7 = {
  upgrade: "Намерена е по-нова версия на това приложение! Моля актуализирайте от {{current}} до {{version}}."
};
const backup$7 = {
  check: {
    checking: "Проверяваме архива...",
    confirmTitle: "Проверка на архив",
    notOK: "Архивът НЕ ОТГОВАРЯ на настоящия портфейл.",
    ok: "Архивът съвпада с настоящия портфейл.",
    password: {
      label: "Парола за възстановяване",
      placeholder: "Парола за възстановяване",
      showLabel: "Парола за възстановяване"
    },
    success: "Успешно проверен архив:",
    title: "Проверка на архив"
  },
  create: {
    alreadyExists: "Вече разполагате с валиден архив. Желаете ли да го създадете повторно?",
    fail: "Създаването на архив беше НЕУСПЕШНО!",
    info: "Моля въведете паролата за възстановяване на текущия портфейл за потвърждение.",
    name: {
      label: "Име на архива",
      placeholder: "Моля задайте име на архива"
    },
    password: {
      label: "Парола за възстановяване",
      placeholder: "Моля въведете паролата за възстановяване"
    },
    title: "Създаване на архив",
    verificationFailed: 'Паролата за възстановяване НЕ СЪВПАДА с тази на настоящия портфейл. Архивът е създаден. Моля използвайте функцията "Проверка на архив", за да потвърдите вашата парола отново.'
  },
  description: "Избор на <strong>архивен файл за портфейла</strong>",
  insert: "Моля поставете microSD картата, за да управлявате архивите.",
  insertButton: "microSD картата е поставена",
  list: "Вашите архиви на micro SD картата:",
  noBackups: "На тази microSD карта няма архиви.",
  restore: {
    confirmTitle: "Възстановяване от архив",
    error: {
      e200: "Не е намерена microSD карта"
    },
    password: {
      label: "Парола за възстановяване или скрита парола за възстановяване",
      placeholder: "Парола за възстановяване",
      repeatPlaceholder: "Въведете паролата за възстановяване още веднъж",
      showLabel: "Парола за възстановяване"
    },
    restoring: "Възстановяване от архив...",
    title: "Възстановяване",
    understand: "Разбирам, че въвеждането на грешна парола за възстановяване ще генерира различен портфейл"
  },
  showMnemonic: {
    description: "Ще ви покажем поредица с дължина до 24 думи, която представлява резервно копие на вашия портфейл. Запишете ги на хартия.\n\n<strong>Не ги съхранявайте в цифров вид и не ги снимайте.</strong>\n\n<strong>Не казвайте думите на глас.</strong>\n\n<strong>Архивът не е защитен с парола.</strong>\n\nСлед това ще ви помолим да потвърдите всяка дума.",
    title: "Показване на мнемоничната фраза"
  },
  title: "Управление на архивите"
};
const bb02Bootloader$7 = {
  abort: "Прекратяване на актуализацията – Връщане обратно",
  advanced: {
    label: "Разширени настройки",
    toggleShowFirmwareHash: "Показване на контролна сума на фърмуера при всяко стартиране на устройството"
  },
  flipscreen: "Завъртане на екрана",
  orientation: "Устройството е ориентирано по непоходящ начин?",
  success: "Актуализацията е успешна! Рестарт след {{rebootSeconds}} секунди..."
};
const bitbox$7 = {
  error: {
    e10000: "Въведената защитна парола на устройството е грешна.",
    e10001: "Неуспешна промяна на защитната парола на устройството",
    e102: "Паролата трябва да съдържа минимум 4 символа",
    e112: "Паролата за скритото устройство не може да бъде същата като паролата на основното устройство."
  }
};
const bitbox02Interact$7 = {
  followInstructions: "Моля спазвайте инструкциите, които подава Вашият BitBox02."
};
const bitbox02Settings$7 = {
  deviceName: {
    current: "Настоящо име на устройството",
    input: "Име на BitBox02",
    title: "Задайте име на BitBox02"
  }
};
const bitbox02Wizard$7 = {
  attestationFailed: "Атестацията на устройството беше неуспешна. Възможно е това да стане, ако рестартирате приложението, докато устройството очаква въвеждане на данни от потребителя. Свържете устройството повторно и опитайте отново.",
  backup: {
    point1: "Изберете архив на microSD картата",
    point2: "Задайте парола за своето устройство",
    restoreText: "ОК, нека възстановим от архив!",
    text1: "Отлично, паролата на Вашия BitBox02 е зададена и портфейлът е генериран. Сега е моментът да създадете първия си архив. Уверете се, че microSD картата е поставена в BitBox02 и продължете.",
    text2: "Следвайте инструкциите на екрана на устройството, за да създадете архив.",
    text3: "След като архивът е създаден, извадете micro SD картата и я съхранете <strong>на сигурно място</strong>. Съдържанието на micro SD картата не е защитено с парола. Никога не я поставяйте в каквото и да е устройство, освен Вашия BitBox02.",
    userConfirmation1: "Трябва да съхранявам архива на сигурно място.",
    userConfirmation2: "Архивът не е защитен с парола. Всеки, който има достъп до него, може да разполага с моя портфейл.",
    userConfirmation3: "Ако изгубя или повредя моя BitBox02, единственият начин да възстановя достъпа до средствата в него е да възстановя от направения архив.",
    userConfirmation4: "Ако изгубя или повредя и архива, и BitBox02 устройството, моите средства ще бъдат изгубени."
  },
  create: {
    button: "Задайте име на устройството и продължете нататък",
    info: "Ето поредицата от стъпки, които трябва да изпълните, за да настроите Вашия BitBox:",
    inputTitle: "Име на портфейла",
    point1: "Задайте име на своето устройство",
    point2: "Задайте парола за своето устройство",
    point3: "Създайте архив",
    text: "ОК, нека създадем нов портфейл!"
  },
  initialize: {
    passwordText: "Нека сега зададем парола за устройството. Използвайте сензорните бутони на Вашия BitBox, за да въведете избраната от Вас парола.",
    passwordTitle: "Задайте парола на Вашия BitBox",
    text: "Връзката с Вашия BitBox02 е успешна! Сега нека инициализираме устройството. Най-напред трябва да изберете дали искате да създадете нов портфейл, или да възстановите съществуващ портфейл от архив. <strong>Уверете се, че във Вашия BitBox02 има поставена microSD карта</strong>",
    tip: "Преди да продължите, ви препоръчваме да установите защитена среда.",
    title: "Инициализиране на Вашия BitBox"
  },
  insertSDCard: "<strong>Уверете се, че във Вашия BitBox02 има поставена microSD карта</strong>",
  pairing: {
    failed: "Връзката не е потвърдена. Моля свържете отново Вашия BitBox02.",
    paired: "Вие потвърдихте чрез устройството, че кодът съвпада. Ако това е вярно, можете да продължите, като натиснете бутона отдолу.",
    title: "Потвърждение на кода за обвързване.",
    unpaired: "Открит е нов BitBox02. Уверете се, че следният код съвпада с показаното на екрана на Вашето устройство. Ако кодът съвпада, натиснете сензорния участък под символа с отметка на екрана на Вашия BitBox02 и натиснете бутона отдолу, за да продължите."
  },
  restoreFromMnemonic: {
    failed: "Неуспешно възстановяване от мнемонична фраза, опитайте отново."
  },
  stepBackup: {
    beforeProceed: "Преди да продължите, моля прочетете тази важна информация за сигурността:",
    createBackup: "Предстои Ви да създадете архив върху Вашата microSD карта."
  },
  stepBackupSuccess: {
    fundsSafe: "За да имате винаги достъп до Вашите средства, моля запомнете следното:",
    title: "Архивът е възстановен!"
  },
  stepConnected: {
    unlock: "Въведете паролата на BitBox02, за да отключите устройството."
  },
  stepCreate: {
    nameLabel: "Име на BitBox02",
    namePlaceholder: "Моето BitBox02 устройство",
    title: "Изберете име за Вашия BitBox02",
    toastMicroSD: "Уверете се, че microSD картата е поставена във Вашия BitBox02."
  },
  stepCreateSuccess: {
    removeMicroSD: "Извадете microSD картата от Вашия BitBox02 и я приберете на сигурно място.",
    success: "Архивът е създаден успешно."
  },
  stepPassword: {
    title: "Задаване на парола на BitBox02",
    useControls: "Използвайте бутоните на Вашия BitBox02, за да зададете парола."
  },
  stepUninitialized: {
    create: "Искам да настроя ново BitBox02 устройство.",
    restore: "Искам да възстановя съществуващ портфейл от архив.",
    restoreMicroSD: "Възстановяване от microSD карта",
    restoreMnemonic: "Възстановяване от мнемонична фраза",
    title: "Настройване на Вашето BitBox02 устройство"
  },
  success: {
    text: "Ура! Вашият BitBox02 е готов за употреба.\n\nЗа повече информация как да използвате приложението BitBox, използвайте вграденото ръководство за употреба, като кликнете върху въпросителната в горния десен ъгъл на екрана.",
    title: "Можете да работите!"
  }
};
const blink$7 = {
  button: "Мигане"
};
const bootloader$7 = {
  button: "Актуализиране на firmware",
  progress: "Актуализиране: {{progress}}%",
  success: "Актуализацията е успешна! Моля извадете устройството и го свържете отново, без да докосвате бутона."
};
const button$c = {
  abort: "Прекратяване",
  back: "Назад",
  changepin: "Смяна на паролата на устройството",
  check: "Проверка на архив",
  "continue": "Напред",
  copy: "Копиране",
  create: "Създаване",
  download: "Сваляне",
  hiddenwallet: "Създаване на скрит портфейл",
  next: "Напред",
  ok: "ОК",
  previous: "Назад",
  receive: "Получаване",
  restore: "Възстановяване",
  select: "Изберете",
  send: "Изпращане",
  unlock: "Отключване",
  update: "Обновяване",
  upgrade: "Актуализиране"
};
const changePin$7 = {
  newTitle: "Нова парола на устройството",
  oldLabel: "Настояща парола на устройството"
};
const checkSDcard$7 = "проверка на microSD картата";
const clickHere$7 = "Кликнете тук";
const confirm$9 = {
  abortInfo: "Докоснете, за да",
  abortInfoRedText: "прекратите",
  approveInfo: "Задръжте над 4 секунди, за да",
  approveInfoGreenText: "потвърдите",
  info: "на Вашия BitBox",
  infoWhenPaired: "Първо на свързаното мобилно устройство и след това на Вашия BitBox"
};
const confirmOnDevice$7 = "Моля потвърдете върху Вашето устройство.";
const device$7 = {
  appUpradeRequired: "Вашият BitBox не е съвместим с това настолно приложение. Трябва да изтеглите и инсталирате най-новата версия."
};
const deviceLock$7 = {
  button: "Активиране на двустепенна автентикация (2FA)",
  condition1: "Разполагате ли с архив?",
  condition2: "Дали верификацията чрез мобилно приложение работи?",
  condition3: "2FA ДЕАКТИВИРА възможностите за създаване на архив и свързване с мобилни приложения. Устройството трябва да се РЕСЕТИРА, за да се изключи 2FA!",
  confirm: "Активиране на двустепенна автентикация (2FA)",
  title: "Активиране на двустепенна автентикация (2FA)"
};
const deviceSettings$7 = {
  firmware: {
    newVersion: {
      label: "Налична версия"
    },
    title: "Firmware",
    upToDate: "Вашето устройство използва най-новия софтуер",
    version: {
      label: "Версия"
    }
  },
  hardware: {
    sdcard: {
      "false": "Не е поставена",
      label: "microSD карта",
      "true": "Поставена"
    },
    title: "Хардуер"
  },
  loading: "Извличане на информация за устройството...",
  pairing: {
    lock: {
      "false": "Деактивирано",
      label: "Двустепенна автентикация (2FA)",
      "true": "Активирана"
    },
    mobile: {
      "false": "Затворено",
      label: "Мобилно приложение",
      "true": "Отворено"
    },
    status: {
      "false": "Няма връзка",
      label: "Статус",
      "true": "Има връзка"
    },
    title: "Обвързване"
  },
  secrets: {
    manageBackups: "Управление на архивите",
    title: "Тайни"
  }
};
const deviceTampered$7 = "Ако сте получили парола за възстановяване заедно с Вашия BitBox, прекратете незабавно процеса по настройка и се свържете с екипа по поддръжката. Shift никога не предоставя предварително подготвен портфейл и не дава препоръки за паролата!";
const dialog$8 = {
  cancel: "Отказ",
  confirm: "Потвърждение"
};
const fiat$9 = {
  "default": "по подразбиране",
  setDefault: "Задайте {{code}} по подразбиране",
  title: "Валути"
};
const footer$9 = {
  appVersion: "Версия на приложението:"
};
const genericError$7 = "Възникна грешка. Ако забележите проблеми, рестартирайте приложението.";
const goal$7 = {
  buttons: {
    create: "Създаване на нов портфейл",
    restore: "Възстановяване на портфейл от архив"
  },
  paragraph: "Изберете една от следните възможности:",
  step: {
    "1": {
      title: "Информация за сигурността"
    },
    "2": {
      description: "Задаване на парола на устройството",
      title: "Устройство"
    },
    "3-create": {
      description: "Създаване на нов портфейл",
      title: "Портфейл"
    },
    "3-restore": {
      description: "от архив",
      title: "Възстановяване"
    },
    "4-create": {
      title: "Обща информация"
    },
    "4-restore": {
      title: "Обща информация"
    }
  }
};
const guide$8 = {
  accountDescription: {
    text: 'Страницата с обща информация за Вашия портфейл показва наличния баланс, входящите и изходящи транзакции. Помощното ръководство в панела "Настройки" предоставя повече информация за различните видове портфейли.',
    title: "Какво се показва на тази страница?"
  },
  accountFiat: {
    text: "Да. Кликнете върху тикера, за да превключвате фиатните валути. Можете да изберете кои валути се показват от панела за настройки.",
    title: "Мога ли да виждам други обменни курсове?"
  },
  accountIncomingBalance: {
    text: 'Колоната "Входящи" сумира всички плащания към Вас, които все още не са потвърдени от мрежата.',
    title: 'Какво означава "Входящи"?'
  },
  accountInfo: {
    xpub: {
      text: "Разширеният публичен ключ (Extended Public Key) представлява базов ключ, от който се генерират всички получаващи адреси в портфейла. Предоставяме го тук за нуждите на опитните потребители и за съвместимост с пасивни портфейли като Electrum и Sentinel.",
      title: "Какво представлява разширеният публичен ключ?"
    }
  },
  accountRates: {
    text: "Обменните курсове се актуализират веднъж на минута от CoinGecko.",
    title: "Какви обменни курсове използваме?"
  },
  accountReload: {
    text: "Не е необходимо. Информация за Вашите транзакции се актуализира автоматично.",
    title: "Мога ли да презаредя информацията за транзакциите?"
  },
  accountSendDisabled: {
    text: 'Бутонът "Изпращане" се активира, когато балансът е по-голям от нула.',
    title: "Защо не мога да изпращам {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    text: "Виртуален размер: определя мрежовата такса. Ако е по-малък от същинския размер на транзакцията, спестявате от такси.\nСъщински размер: реалният размер на транзакцията в байтове, както се подава към съответния блокчейн.\nТегло: нов параметър, въведен заедно със SegWit с цел определяне на размера на транзакцията и блоковете. Всеки SegWit байт се брои за една тегловна единица, а всички останали байтове се смятат по четири тегловни единици. Вместо един мегабайт същински размер, лимитът за големина на блока вече е четири милиона тегловни единици.",
    title: "Ами специфичните за Bitcoin подробности за транзакцията?"
  },
  accountTransactionAttributesGeneric: {
    text: 'Потвърждения: Вашата транзакция има състояние "непотвърдена", докато някой миньор я включи в блок, при което нейното състояние ще стане "1 потвърждение". Всеки блок, излъчен след това в мрежата, добавя още едно потвърждение на Вашата транзакция. Търговците и други мрежови потребители обичайно приемат транзакцията за валидна едва след като тя получи между 3 и 6 потвърждения.\nID на транзакция: уникален идентификатор, чрез който можете да намерите дадена транзакция чрез block explorer.\nТакса: Миньорите получават определена такса като стимул да включат транзакциите в блоковете, които откриват. За да научите повече, натиснете бутона "Изпращане".',
    title: "Каква информация съдържат подробностите за транзакцията? "
  },
  accountTransactionConfirmation: {
    text: "Транзакция, която е излъчена в мрежата, но още не е потвърдена.",
    title: "Какво означава чакаща (pending) транзакция?"
  },
  accountTransactionLabel: {
    text: "Това е адресът, от който сте получили или към който изпращате пари.",
    title: "Кой адрес се показва за всяка транзакция?"
  },
  accountTransactionTime: {
    text: "Времето за потвърждението на транзакцията в блокчейна.",
    title: "Какво време се показва?"
  },
  appendix: {
    link: "Свържете се с нас!",
    text: "Имате друг въпрос?"
  },
  backups: {
    check: {
      text: '"Проверка на архива" Ви позволява да потвърдите, че разполагате с работещ архив, който съответства на избрания в момента портфейл. Можете да използвате тази функция и за да се уверите, че разполагате с правилната парола за възстановяване. Можете да сверите и главната, и скритата парола за възстановяване.',
      title: 'Какво представлява "Проверка на архива"?'
    },
    encrypt: {
      text: "Не, но Вашата парола е необходима, за да се извлече портфейлът от съхраненото отправно число (seed).",
      title: "Мога ли да криптирам архива?"
    },
    howOften: {
      text: "Архивът се създава автоматично при генерирането на нов портфейл. Необходимо е да направите нов архив само ако повредите или изгубите Вашата microSD карта или ако искате да направите архиви на различни microSD карти.\nНе е необходимо да създавате нови архиви след създаването или получаването на нови транзакции. Всичката информация за транзакциите може да се пресъздаде от първоначалния архив, който е създаден автоматично.",
      title: "Колко често трябва да правя архив?"
    },
    whatIsABackup: {
      text: "Това е копие на отправното число (seed), записано върху microSD карта. Отправното число и паролата за възстановяване генерират Вашия портфейл.",
      title: "Какво представлява архивът?"
    }
  },
  backupsBB02: {
    check: {
      text: '"Проверка на архива" Ви позволява да се уверите, че разполагате с работещ архив, съответстващ на портфейла, който използвате в момента.',
      title: 'Какво представлява "Проверка на архива"?'
    },
    encrypt: {
      text: 'Не. Съхранявайте microSD картата на сигурно място, тъй като тя съдържа в нешифриран вид отправното число (seed), от което се възстановява портфейлът. Ако искате да защитите отправното число с парола, можете да активирате функцията за използване на допълнителна фраза в панела за експертни настройки под "Управление на устройството".',
      title: "Мога ли да шифрирам архива?"
    },
    whatIsABackup: {
      text: "Това е копие на отправното число (seed), записано върху microSD карта.",
      title: "Какво представлява архивът?"
    }
  },
  bitbox: {
    "2FA": {
      text: 'Когато е активирана двустепенна автентикация (2FA), всички изходящи транзакции трябва да се потвърдят на обвързания мобилен телефон. По-точно описано, към мобилното устройство се изпраща шифриран номер за еднократна употреба; този номер се дешифрира от устройството и с натискането на бутона "Приемам" (Accept) се връща обратно към BitBox. Комуникацията между двете устройства използва канала за връзка, установен по време на обвързването.\n\nУверете се, че Вашият портфейл е архивиран и направете обвръзка мобилното устройство, преди да активирате двустепенната автентикация. След като тя се активира, microSD слотът и възможността за обвързване с мобилно устройство се изключват. Можете да ги активирате отново, ако нулирате своя BitBox — операция, която изтрива неговото съдържание.',
      title: "Как работи двустепенната автентикация (2FA)?"
    },
    disable2FA: {
      text: 'За да премахнете двустепенната автентикация, трябва да нулирате своя BitBox и след това да възстановите портфейла си от архива. Най-напред се уверете, че разполагате с microSD картата с архива и че все още помните паролата за възстановяване. След това натиснете бутона "Нулиране на устройството". Задайте нова парола за устройството и изберете "или възстановяване от архив". Изберете архивното копие на портфейла, кликнете на "Възстановяване" и въведете паролата за възстановяване, която сте използвали при създаването на портфейла.',
      title: "Как мога да премахна двустепенната автентикация (2FA)?"
    },
    ejectBitbox: {
      text: 'Можете да издърпате BitBox по всяко време; няма нужда да изпълнявате "безопасно премахване" (Eject Media).',
      title: "Как да разкача BitBox от компютъра?"
    },
    ejectSD: {
      text: "Можете да извадите microSD картата от BitBox по всяко време, освен ако устройството не се намира в процес на създаване или възстановяване на архив.",
      title: "Как мога да извадя microSD картата?"
    },
    hiddenWallet: {
      text: "Това е втори портфейл в същото устройство, който е защитен с различна защитна парола и парола за възстановяване. Употребата на тази функция прави притежанието на различни портфейли недоказуемо (т.н. 'plausible deniability'). И нормалният, и скритият портфейл използват едно и също отправно число, така че не е необходим отделен архив за скрития портфейл.",
      title: 'Какво представлява "скрит портфейл"?'
    },
    legacyHiddenWallet: {
      text: "Най-напред кликнете на бутона отдолу (той ще се появи ако BitBox е отключен с главната парола на устройството и двустепенната автентикация е изключена), след което извадете и включете BitBox отново и го отключете с паролата за Вашия скрит портфейл.",
      title: "Как да получа достъп до стария (legacy) формат скрит портфейл?"
    },
    pairing: {
      text: "След като свалите мобилното приложение за iOS или Android, трябва да сканирате показания QR код. По този начин между мобилното устройство и това приложение се изгражда защитена връзка. След като сканирате кода, следвайте инструкциите в мобилното приложение.",
      title: "Как да изградите защитена връзка с Вашия телефон"
    }
  },
  receive: {
    address: {
      text: "Можете да предоставите адреса на други потребители, които да Ви изпратят средства по него. Добрата практика е да генерирате нов адрес за всяко плащане.",
      title: "Какво мога да правя с адрес?"
    },
    addressChange: {
      text: "Веднага щом извършите транзакция, към списъка се добавя нов адрес, така че винаги разполагате с 20 адреса, които не са получавали криптовалута.",
      title: "Кога се променят адресите?"
    },
    howVerify: {
      text: 'За BitBox01: кликнете на иконата на BitBox в лявата лента и вижте панела "Обвързване". Ръководството ще се презареди и ще покаже на екрана по-нататъшни инструкции.\nЗа BitBox02: потвърждението на адресите става автоматично на устройството в процеса на изпращане/получаване на средства.',
      title: "Как мога да потвърдя адрес по надежден начин?"
    },
    why20: {
      text: "По време на стартиране, приложението генерира адреси, извлечени от Вашето отправно число (seed) и проверява дали по тях са получени средства. Тъй като приложението може да генерира почти неограничен брой адреси, определянето на баланса може да отнеме години. За да се ограничи времето на търсене, проверката спира след като регистрира 20 последователни адреса, които не са получавали плащания. Това е т.н. праг (gap limit), който е възприет като стандартен в индустрията, макар самото число да е избрано произволно. Това са 20-те адреса, от които можете да избирате.",
      title: "Защо само 20 адреса?"
    },
    whyMany: {
      text: "За да поддържате максимална анонимност и сигурност, никога не използвайте един и същ адрес два пъти. Ако сте използвали вече даден адрес, натиснете дясната стрелка, за да получите нов адрес. Можете да генерирате до 20 адреса наведнъж. Мислете за адресите като за фактури от кочан — всички адреси се генерират от Вашето архивирано отправно число (seed).",
      title: "Защо толкова много адреси?"
    },
    whyVerify: {
      text: "Не трябва да се доверявате на компютъра за генерирането и показването на автентични адреси. Компютърът е значително по-уязвим на атаки от хардуерния портфейл. За BitBox01 бутонът за сигурно потвърждение изпраща адреса към сдвоен мобилен телефон, от който Вие можете също да сканирате и да валидирате QR кода. За BitBox02 адресите могат да се потвърдят директно върху дисплея на самото устройство.",
      title: "Защо трябва да валидирам адресите?"
    }
  },
  send: {
    fee: {
      text: "Таксата зависи от размера на транзакция в байтове, а не от сумата. Таксите се изчисляват чрез алгоритъма на Bitcoin Core за всеки вид приоритет и се показват, ако имат различна стойност от посочените по-долу стандартни стойности.\nИкономична: 24 блока (ок. 4 часа за Bitcoin, 1 час за Litecoin)\nНиска: 12 блока (ок. 2 часа за Bitcoin, 30 минути за Litecoin)\nНормална: 6 блока (ок. 1 час за Bitcoin, 15 минути за Litecoin)\nВисока: 2 блока (ок. 20 минути за Bitcoin, 5 минути за Litecoin)\n\nЗабележка: генерирането на нов блок отнема средно 10 минути за Bitcoin (2.5 минути за Litecoin) и капацитетът на мрежата може да варира значително.",
      title: "Как се определя мрежовата такса?"
    },
    priority: {
      text: "Колкото по-висока такса предложите, толкова по-бързо Вашата транзакция ще бъде потвърдена от мрежата.",
      title: "Какво представлява мрежовият приоритет?"
    },
    revert: {
      text: "След като веднъж една транзакция бъде подписана и изпратена (т.е. излъчена към мрежата), тя не може да бъде анулирана. Проверете всички детайли на плащането (включително размера на таксата) внимателно, преди да подпишете!\nАко познавате получателя и той или тя приеме да Ви възстанови плащането (след приспадане на разходите по транзакцията), можете да предоставите нов адрес за получаване.",
      title: "Мога ли да отменя вече направена транзакция?"
    },
    whyFee: {
      text: 'Транзакциите се конкурират помежду си за потвърждение от миньорите. Миньорът подбира кои транзакции да включи във веригата според големината на таксата. Миньорите "гласуват" за историята на транзакциите. Тъй като не съществува доверена трета страна, която да преброява гласовете, миньорите дават своя глас, жертвайки скъп ресурс — изчислителна мощност. Като възнаграждение за своята работа те получават новосъздадени средства и таксите от всички транзакции, които включат в блока.',
      title: "Защо е необходима мрежова такса?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Възможно е да свържете Вашия портфейл към собствен сървър, вместо да използвате сървърите на Shift.",
      title: "Какво е това?"
    }
  },
  settings: {
    servers: {
      text: "Приложението комуникира със сървърите на Shift Crypto, за да проверява за нови версии, да зарежда транзакции и да изпраща информация към сдвоеното мобилно приложение. Също така, приложението тегли актуални обменни курсове от CoinGecko. Всички конверсии се прилагат локално — не се предава никаква информация за размера на Вашите транзакции.\nЗабележка: за Ethereum и ERC20 токени използваме API-то на Etherscan.io",
      title: "С кои сървъри комуникира приложението?"
    }
  },
  title: "Ръководство",
  toggle: {
    close: "Затваряне на ръководството",
    open: "Ръководство"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Трябва да нулирате устройството и да възстановите портфейла от архив с помощта на паролата за възстановяване.",
      title: "Какво трябва да направя, ако изгубя защитната парола на устройството?"
    },
    reset: {
      text: "Въведете грешна парола за блокиране на устройството 15 пъти подред. Последните няколко опита изискват дълго докосване на сензора на устройството.",
      title: "Как се нулира устройството?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Устройството трябва да премигне веднъж след поставянето. Уверете се, че е поставено успешно. Ако имате затруднения, свържете се с нас чрез връзката отдолу.",
      title: "Моето BitBox 01 устройство не се разпознава"
    },
    getDevice: {
      link: {
        text: "Поръчайте BitBox устройство"
      },
      text: "Можете да закупите BitBox от нашия онлайн магазин:",
      title: "Как да получа устройство?"
    },
    internet: {
      text: "Да — за синхронизиране на портфейла, изпращане на транзакции и извличане на актуалните обменни курсове е необходима интернет връзка.",
      title: "Приложението изисква ли връзка с интернет?"
    },
    lostDevice: {
      link: {
        text: "Архивен център"
      },
      text: "Можете да възстановите Вашите портфейли върху ново BitBox устройство или с помощта на нашия архивен център",
      title: "Изгубих устройството. Какво следва?"
    },
    useWithoutDevice: {
      text: "За съжаление към момента това все още не е възможно.",
      title: "Мога ли да използвам приложението без устройство?"
    },
    welcome: {
      text: "Благодарим Ви, че използвате настоящото приложение, създадено от Shift Crypto в Швейцария. Ние ценим всеки коментар, който нашите клиенти споделят. За да подадете обратна връзка, моля използвайте линка отдолу.",
      title: "Добре дошли в BitBoxApp!"
    }
  }
};
const headerssync$7 = {
  blocksSynced: "Синхронизирани {{blocks}} блока"
};
const hiddenWallet$7 = {
  info1HTML: "За допълнителна защита можете да създадете скрит портфейл, базиран на <strong>различна</strong> комбинация от защитна парола и парола за възстановяване. Съществуването на такъв портфейл е недоказуемо.",
  info2HTML: "Отдолу задайте парола за блокиране на устройството и парола за възстановяване на портфейла, които ще се асоциират със скрития портфейл. И паролата за блокиране, и паролата за възстановяване трябва да бъдат <strong>различни</strong> спрямо използваните в основния портфейл.",
  passwordLabel: "Скрита парола за възстановяване",
  passwordPlaceholder: "Моля потвърдете скритата парола за възстановяване",
  pinLabel: "Скрита защитна парола на устройството",
  pinRepeatLabel: "Скрита защитна парола на устройството (повторно)",
  pinRepeatPlaceholder: "Моля потвърдете скритата защитна парола на устройството",
  success: "Скритият портфейл е създаден успешно. Свържете повторно Вашия BitBox, за да го отключите."
};
const initialize$7 = {
  create: "Задаване на защитна парола на устройството",
  creating: "Задаване на защитната парола...",
  error: {
    e102: "Защитната парола трябва да съдържа поне 4 символа."
  },
  info: {
    description1: "Изберете защитна парола на устройството. Тя се използва за отключване на Вашия BitBox.",
    description2: "Можете да използвате числа, букви и символи. По-дългите пароли дават по-голяма сигурност.",
    description3: "Ако изгубите защитната парола на устройството, ще се наложи да го нулирате и да възстановите портфейла от архив.",
    subtitle: "Сега трябва да зададете защитна парола за устройството",
    title: "Инициализиране на устройството"
  },
  input: {
    label: "Защитна парола за устройството",
    labelRepeat: "Защитна парола за устройството (повторно)",
    placeholderRepeat: "Моля потвърдете защитната парола за устройството"
  }
};
const invalidFormat$7 = "Невалиден формат";
const language$8 = {
  title: "Избор на език"
};
const legacyhiddenwallet$7 = {
  disable: "Деактивиране на скрит портфейл тип Legacy",
  enable: "Активиране на скрит портфейл тип Legacy",
  successDisable: "Скритият Legacy портфейл беше успешно деактивиран.",
  successEnable: "Успешно активиране на скрит портфейл тип Legacy. Свържете отново Вашето BitBox устройство и въведете скритата защитна парола, за да получите достъп до този скрит портфейл."
};
const loading$7 = "зареждане...";
const notification$7 = {
  newTxs_one: "Нова транзакция в {{accountName}}",
  newTxs_other: "{{count}} нови транзакции в {{accountName}}"
};
const pairing$7 = {
  aborted: {
    text: "Обвързването беше прекъснато от мобилното приложение.",
    title: "Прекратено"
  },
  button: "Обвързване с мобилното приложение",
  confirm: "Сигурни ли сте, че искате да свържете Вашия BitBox с мобилното приложение? Ако направите това, ще се нуждаете от мобилния си телефон, за да извършвате транзакции.",
  connectOnly: {
    button: "Свързване с мобилното приложение",
    title: 'Сканирайте с мобилното приложение, като изберете опцията "Връзка с ново настолно приложение" от менюто.'
  },
  error: {
    text: "Нещо не е наред. Моля започнете процедурата отначало.",
    title: "Грешка"
  },
  reconnectOnly: {
    button: "Повторно свързване с мобилното приложение"
  },
  start: {
    hideAppQRCode: "Скриване на QR кода",
    revealAppQRCode: "Показване на QR кода",
    step1: "Ако не разполагате с мобилното приложение, можете да сканирате QR кода за Apple App Store или Google Play Store в зависимост от вида на Вашия телефон.",
    step2: "Сканирайте с мобилното приложение, което можете да намерите в софтуерните магазини за iOS и Android под името 'Digital Bitbox 2FA':"
  },
  started: {
    text: "Следвайте инструкциите на екрана на мобилното приложение.",
    title: "Отлично"
  },
  success: {
    text: "Поздравления, сдвояването на Вашия BitBox с мобилното приложение беше успешно!",
    title: "Успех"
  },
  timeout: {
    text: "Опитът за връзка беше прекратен след 2 минути. Пробвайте отново, ако все още искате да свържете мобилното приложение.",
    title: "Таймаут"
  },
  title: "Мобилно обвързване"
};
const password$7 = {
  show: "Показване на {{label}}",
  warning: {
    caps: "ВНИМАНИЕ: Caps lock (⇪) е включен",
    paste: 'за да копирате текста, активирайте "ПОКАЗВАНЕ НА {{label}}"'
  }
};
const random$8 = {
  button: "Генериране на случайно число",
  description: "Вашият BitBox генерира следното {{bits}}-битово случайно число:"
};
const receive$9 = {
  label: "Вашият адрес",
  onlyThisCoin: {
    description: "За да получавате други криптовалути, ги активирайте в настройките. Ако депозирате различна криптовалута тук, е много вероятно да не можете да получите достъп до нея.",
    warning: "Уверете се, че ще получавате само {{coinName}} на този адрес."
  },
  showFull: "Показване и потвърждаване на пълния адрес върху устройство",
  title: "Извличане на {{accountName}}",
  verify: "Сигурно потвърждение на адреса",
  verifyBitBox01: "Потвърждение на адреса чрез мобилно приложение",
  verifyBitBox02: "Потвърждение на адреса чрез BitBox02",
  verifyInstruction: "Уверете се, че адресът съвпада с показания на екрана на Вашето устройство.",
  warning: {
    secureOutput: 'Обвържете Вашия BitBox с мобилно устройство, за да можете да изпълнявате сигурна верификация на адресите. Отворете менюто "Управление на устройството" от страничната лента.'
  }
};
const reset$7 = {
  description: "Всички данни върху устройството ще бъдат изтрити. Това включва частния ключ!",
  notReset: "Устройството НЕ Е нулирано.",
  title: "Нулиране на устройството",
  understand: "Разполагам с архив и знам паролата за възстановяване",
  understandBB02: "Разполагам с валиден архив"
};
const securityInformation$7 = {
  create: {
    description1: "Преди да настроите своето устройство, уверете се че, че се намирате в сигурна среда.",
    description2: "Ще поискаме от Вас да създадете две пароли.",
    description3: "Първото е <strong>защитната парола</strong>, която отключва Вашето BitBox устройство и може да бъде променяна.",
    description4: "Втората е <strong>паролата за възстановяване от архив</strong>, която отключва Вашия портфейл. Тази парола не може да бъде променяна на по-късен етап.",
    description5: "Създаденият портфейл ще бъде архивиран върху предоставената microSD карта. Този архив може да се използва в аварийна ситуация за възстановяване на достъпа до Вашите средства чрез въвеждане на <strong>паролата за възстановяване</strong>.",
    title: "Информация за сигурността"
  },
  restore: {
    description1: "Ще поискаме от Вас да поставите microSD картата, която съдържа Вашия архив.",
    description2: "За да възстановите съдържанието на устройството, се нуждаете от паролата за възстановяване.",
    description3: "Бъдете изключително внимателни, когато въвеждате паролата за възстановяване. Всяка парола ще създаде валиден портфейл. Ако въведете грешна парола, няма да видите очаквания баланс.",
    title: "Информация за сигурността"
  }
};
const seed$7 = {
  agreements: {
    "funds-access": "НЯМА ДА МОГА да получа достъп до моите средства, ако загубя паролата за възстановяване.",
    "password-change": "НЯМА ДА МОГА да променя паролата за възстановяване в по-късен момент.",
    "password-required": "Паролата за възстановяване е необходима за реконструирането на портфейл от архивно копие"
  },
  create: "Създаване на портфейл",
  creating: "Създаване на портфейл...",
  description: "Разбирам, че:",
  error: {
    e102: "Паролата трябва да съдържа минимум 4 символа.",
    e200: "При създаването на портфейл трябва да поставите microSD карта във Вашето BitBox устройство, за да може да бъде генериран автоматичен архив."
  },
  info: {
    button: "Задаване на парола за възстановяване",
    description1: "Поставете microSD картата в BitBox",
    description2: 'Въведете парола за възстановяване на портфейла и изберете "Задаване на парола за възстановяване"',
    description3: "Архивът върху microSD картата и избраната от Вас парола за възстановяване заедно представляват единственото възможно средство за възобновяване на достъпа до Вашите средства в случай, че BitBox устройството бъде изгубено или откраднато.",
    description4: "Не можете да промените паролата за възстановяване на по-късен етап, без да прехвърлите всичките средства от портфейла.",
    title: "Създаване на нов портфейл"
  },
  password: {
    label: "Парола за възстановяване",
    repeatPlaceholder: "Парола за възстановяване (повторете)"
  },
  walletName: {
    label: "Име на портфейла"
  }
};
const seedRestore$7 = {
  error: {
    e200: "За възстановяване на портфейл от архива е необходима използваната microSD карта."
  },
  info: {
    description1: 'Поставете microSD картата в BitBox устройството и натиснете "Напред"',
    description2: 'Изберете архив и натиснете "Възстановяване"',
    description3: "Въведете паролата за възстановяване",
    description4: "Трябва да потвърдите, че разбирате, че неправилно въведената парола ще създаде различен портфейл.",
    title: "Как се възстановява портфейл от архив"
  }
};
const send$9 = {
  abort: "Транзакцията беше прекъсната.",
  address: {
    label: "Адрес на получателя",
    placeholder: "Въвеждане на адрес"
  },
  amount: {
    label: "Сума",
    placeholder: "Въведете сума"
  },
  button: "Подписване и изпращане",
  coincontrol: {
    address: "Адрес",
    outpoint: "Избор на output",
    title: "Избор на output за харчене"
  },
  confirm: {
    "selected-coins": "Избрана криптовалута",
    title: "Потвърждение на транзакцията",
    total: "Общо"
  },
  error: {
    insufficientFunds: "недостатъчно средства",
    invalidAddress: "невалиден адрес",
    invalidAmount: "невалидна сума",
    invalidData: "невалидни данни"
  },
  fee: {
    customPlaceholder: "Въведете сума",
    label: "Мрежова такса",
    placeholder: "Не е налична"
  },
  feeTarget: {
    description: {
      economy: "24 блока (около 4 часа за Bitcoin, 1 час за Litecoin)",
      high: "2 блока (около 20 минути за Bitcoin, 5 минути за Litecoin)",
      low: "12 блока (около 2 часа за Bitcoin, 30 минути за Litecoin)",
      normal: "6 блока (около 1 час за Bitcoin, 15 минути за Litecoin)"
    },
    estimate: "Прогнозно време за включване:",
    label: {
      economy: "икономична",
      high: "висока",
      low: "ниска",
      normal: "нормална"
    },
    placeholder: "Изчисляване на таксата..."
  },
  maximum: "Изпращане на всичко",
  scanQR: "Сканиране на QR код",
  signprogress: {
    description: "Тази транзакция съдържа много данни. За да я подпишете изцяло са необходими {{steps}} потвърждения.",
    label: "Напредък"
  },
  success: "Транзакцията е подписана и изпратена.",
  title: "Изпращане от {{accountName}}",
  toggleCoinControl: "Контрол върху харченето (Coin Control)"
};
const settings$8 = {
  electrum: {
    add: "Добавяне на сървър",
    "add-server": "Добавяне",
    check: "Проверка",
    checkFailed: "Неуспешно",
    checkSuccess: "Успешно установена връзка с {{host}}",
    checking: "Проверка...",
    "download-cert": "Сваляне на сертификата на сървъра",
    "remove-server": "Премахване",
    removeConfirm: "Да премахнем ли {{server}}?",
    reset: "Възстановяване на настройките по подразбиране",
    resetConfirm: "Желаете ли да премахнете всички добавени сървъри и да инсталирате сървърите по подразбиране?",
    servers: "Сървъри",
    step1: "1",
    "step1-text": "Въведете крайната точка.",
    step2: "2",
    "step2-text": "Въведете сертификат за удостоверителната верига на сървъра, или свалете сертификата на сървъра и го сравнете визуално.",
    step3: "3",
    "step3-text": "Проверете връзката и добавете сървъра",
    step4: "4",
    "step4-text": "Рестартирайте портфейла. Ако не премахнете сървърите по подразбиране, вашият собствен сървър ще се използва като резервен.",
    "title-btc": "Bitcoin Electrum сървъри",
    "title-ltc": "Litecoin Electrum сървъри",
    "title-tbtc": "Bitcoin Testnet Electrum сървъри",
    "title-tltc": "Litecoin Testnet Electrum сървъри"
  },
  expert: {
    coinControl: "Активиране на контрола върху монетите (Coin Control)",
    electrum: {
      title: "Свързване на Вашия собствен сървър"
    },
    setProxyAddress: "Задаване на прокси адрес",
    title: "Експертни настройки",
    useProxy: "Активиране на Tor прокси"
  },
  header: {
    home: "Начало"
  },
  restart: "Рестартирайте BitBoxApp, за да могат промените да влязат в сила.",
  success: "Извадете BitBox устройството и го поставете отново, за да могат промените да влязат в сила.",
  title: "Настройки"
};
const setup$7 = "Настройка на устройството";
const sidebar$8 = {
  device: "Управление на устройството",
  leave: "Напускане",
  settings: "Настройки"
};
const success$e = {
  create: {
    info1: "Вашият портфейл е успешно архивиран върху microSD картата. Извадете я от устройството и я съхранявайте на сигурно място.",
    info2: "Създадохте силна защитна парола, която служи да отключва Вашия BitBox.",
    info3: "Създадохте сигурна парола за възстановяване на портфейла, която отключва достъпа до Вашата криптовалута и възстановява портфейла от архив.",
    summary: "Резюме на извършените действия",
    title: "Успех"
  },
  getstarted: "Начало",
  restore: {
    summary: "Успешно възстановихте Вашия портфейл от архив.",
    title: "Успех"
  }
};
const transaction$8 = {
  confirmation: "Потвърждения",
  explorer: "ID на транзакция",
  explorerTitle: "Отваряне във външен блок експлорер",
  fee: "Такса",
  fiatHistorical: "Исторически стойности",
  gas: "Gas",
  pending: "Транзакция, чакаща потвърждение",
  size: "Размер",
  vsize: "Виртуален размер",
  weight: "Тегло"
};
const transactions$7 = {
  placeholder: "Още няма транзакции."
};
const unknownError$7 = "Възникна неизвестна грешка: {{errorMessage}}";
const unlock$7 = {
  description: "Въведете защитната парола, за да отключите Вашето устройство.",
  error: {
    e109_normal: "Грешна защитна парола. Остават {{remainingAttempts}}, преди устройството да се самоизтрие.",
    e109_touch: "$t(unlock.error.e109_normal) Следващия опит за влизане изисква натискане и задържане на сензорния бутон.",
    e113: "Заради много последователни неуспешни опити за вход, следващият опит за въвеждане изисква да задържите сензорния бутон натиснат за 4 секунди."
  },
  input: {
    label: "Защитна парола",
    placeholder: "Въведете защитната парола, за да отключите устройството"
  },
  unlocking: "Отключване..."
};
const upgradeFirmware$8 = {
  button: "Актуализиране на firmware",
  description: "Съгласни ли сте да обновите firmware от версия {{currentVersion}} до {{newVersion}}?",
  label: "Вашият BitBox изисква актуализация на firmware.",
  locked: "За да надградите от {{currentVersion}} до {{newVersion}}, моля натиснете сензорния бутон продължително.",
  title: "Актуализиране на firmware",
  unlocked: "Bootloader-ът е отключен. За да продължите, моля:",
  unlocked1: "Откачете и включето отново Вашия BitBox",
  unlocked2: "Когато BitBox устройството е включено отново, ще светне светодиодният индикатор",
  unlocked3: "Когато светодиодният индикатор светне, натиснете сензорния бутон"
};
const warning$d = {
  receivePairing: 'Обвържете Вашия BitBox, за да можете да изпълнявате сигурна верификация на адресите. Отворете менюто "Управление на устройството" от страничната лента.',
  sdcard: "Съхранявайте microSD картата отделно от BitBox устройството, освен ако не управлявате архивите.",
  sendPairing: 'Обвържете BitBox устройството, за да можете да потвърждавате параметрите на транзакциите в сигурна среда. Отворете менюто "Управление на устройството" от страничната лента.'
};
const welcome$7 = {
  insertBitBox02: "За BitBox02, докоснете сензорния бутон на устройството, за да продължите.",
  insertDevice: "Свържете устройството, за да започнем работа",
  title: "Добре дошли!"
};
const appTranslationsBG = {
  account: account$7,
  accountInfo: accountInfo$7,
  accountSummary: accountSummary$7,
  addAccount: addAccount$8,
  app: app$7,
  backup: backup$7,
  bb02Bootloader: bb02Bootloader$7,
  bitbox: bitbox$7,
  bitbox02Interact: bitbox02Interact$7,
  bitbox02Settings: bitbox02Settings$7,
  bitbox02Wizard: bitbox02Wizard$7,
  blink: blink$7,
  bootloader: bootloader$7,
  button: button$c,
  changePin: changePin$7,
  checkSDcard: checkSDcard$7,
  clickHere: clickHere$7,
  confirm: confirm$9,
  confirmOnDevice: confirmOnDevice$7,
  device: device$7,
  deviceLock: deviceLock$7,
  deviceSettings: deviceSettings$7,
  deviceTampered: deviceTampered$7,
  dialog: dialog$8,
  fiat: fiat$9,
  footer: footer$9,
  genericError: genericError$7,
  goal: goal$7,
  guide: guide$8,
  headerssync: headerssync$7,
  hiddenWallet: hiddenWallet$7,
  initialize: initialize$7,
  invalidFormat: invalidFormat$7,
  language: language$8,
  legacyhiddenwallet: legacyhiddenwallet$7,
  loading: loading$7,
  notification: notification$7,
  pairing: pairing$7,
  password: password$7,
  random: random$8,
  receive: receive$9,
  reset: reset$7,
  securityInformation: securityInformation$7,
  seed: seed$7,
  seedRestore: seedRestore$7,
  send: send$9,
  settings: settings$8,
  setup: setup$7,
  sidebar: sidebar$8,
  success: success$e,
  transaction: transaction$8,
  transactions: transactions$7,
  unknownError: unknownError$7,
  unlock: unlock$7,
  upgradeFirmware: upgradeFirmware$8,
  warning: warning$d,
  welcome: welcome$7
};
const account$6 = {
  disconnect: "Bağlantı koptu. Tekrar deneniyor...",
  exportTransactions: "İşlemleri İndirilenler Klasörüne CSV Dosyası Olarak Dışa Aktar",
  fatalError: "Beklenmeyen bir hata oluştu.",
  incoming: "Gelen",
  initializing: "Blockchain'den bilgi alınıyor…",
  reconnecting: "Bağlantı koptu, yeniden bağlantı kuruluyor..."
};
const accountInfo$6 = {
  address: "Adres",
  extendedPublicKey: "Genişletilmiş Genel Anahtar",
  label: "Hesap bilgileri",
  title: "Hesap Bilgileri",
  verify: "Bu cihazda doğrula"
};
const accountSummary$6 = {
  balance: "Bakiye",
  exportSummary: "Hesap Özetini İndirilenler Klasörüne CSV Dosyası Olarak Dışa Aktar",
  fiatBalance: "Fiat Bakiyesi",
  name: "Hesap adı",
  noAccount: "Gösterilecek hesap yok.",
  title: "Hesap Özeti",
  total: "Toplam"
};
const addAccount$7 = {
  title: "Hesap Ekle"
};
const app$6 = {
  upgrade: "Bu uygulamanın yeni bir sürümü mevcut! Lütfen  {{current}} 'dan  {{version}}'a yükseltin."
};
const backup$6 = {
  check: {
    checking: "Yedekleme kontrol ediliyor...",
    confirmTitle: "Yedeklemeyi Kontrol Et",
    notOK: "Yedekleme cüzdanla eşleşmiyor.",
    ok: "Yedekleme cüzdanla eşleşti.",
    password: {
      label: "Şifre yenileme",
      placeholder: "Kurtarma şifresi",
      showLabel: "kurtarma şifresi"
    },
    success: "Başarıyla doğrulanmış yedeklemeler:",
    title: "Yedeklemeyi Kontrol Et"
  },
  create: {
    alreadyExists: "Zaten geçerli bir yedeğiniz var. Yeniden yedeklemek ister misiniz?",
    fail: "Yedekleme oluşturma BAŞARISIZ!",
    info: "Lütfen doğrulama için mevcut cüzdanınızın kurtarma şifresini girin.",
    name: {
      label: "Yedek Adı",
      placeholder: "Lütfen yedeği adlandırın"
    },
    password: {
      label: "Kurtarma Şifresi",
      placeholder: "Lütfen kurtarma şifrenizi girin"
    },
    title: "Yedek Oluştur",
    verificationFailed: "Kurtarma şifresi mevcut cüzdanla eşleşmiyor. Yedekleme oluşturuldu. Lütfen kurtarma şifrenizi tekrar doğrulamak için 'Yedeklemeyi Kontrol Et'i kullanın."
  },
  description: "<strong>cüzdan yedekleme dosyasını</strong> seçin",
  insert: "Yedeklemeleri yönetmek için lütfen micro SD kartı takın.",
  insertButton: "Mikro SD kartımı taktım",
  list: "MicroSD kart yedekleriniz",
  noBackups: "Bu microSD kartta yedekleme yok.",
  restore: {
    confirmTitle: "Yedeklemeyi Geri Yükle",
    error: {
      e200: "SD kart bulunamadı"
    },
    password: {
      label: "Kurtarma şifresi veya gizli kurtarma şifresi",
      placeholder: "Kurtarma şifresi",
      repeatPlaceholder: "Kurtarma şifresini tekrar girin",
      showLabel: "Kurtarma şifresi"
    },
    restoring: "Yedekleme geri yükleniyor...",
    title: "Geri Yükle",
    understand: "Yanlış kurtarma şifresinin farklı bir cüzdan yaratacağını onaylıyorum"
  },
  showMnemonic: {
    description: "Cüzdanınızın yedeğini oluşturan 24 kelimeyi size sunacağız. Onları kağıda yazın.\n\n<strong>Bunları dijital olarak saklamayın veya fotoğraflarını çekmeyin.</strong>\n\n<strong>Kelimeleri yüksek sesle söyleme.</strong>\n\n<strong>Bu yedekleme şifre korumalı değildir.</strong>\n\nSonrasında, her bir kelimeyi tek tek onaylamanız istenecektir.",
    title: "BIP39 Anımsatıcısını Göster"
  },
  title: "Yedeklemeleri Yönet"
};
const bb02Bootloader$6 = {
  abort: "Yükseltmeyi durdur – Beni geri götür",
  advanced: {
    label: "Gelişmiş Ayarlar",
    toggleShowFirmwareHash: "Her açılışta bellenim hash'ini göster"
  },
  flipscreen: "Ekran çevir",
  orientation: "Cihaz yanlış yöne mi yöneldi?",
  success: "Yükseltme başarılı!  {{rebootSeconds}} saniye içerisinde devam edecek..."
};
const bitbox$6 = {
  error: {
    e10000: "Geçerli cihaz şifresi yanlış.",
    e10001: "Cihazın şifresini değiştirme başarısız",
    e102: "Şifre en az 4 karakterden oluşmalıdır.",
    e112: "Gizli cihaz şifresi, ana cihaz şifresi ile aynı olamaz."
  }
};
const bitbox02Interact$6 = {
  followInstructions: "Lütfen BitBox02 üzerindeki talimatları takip edin."
};
const bitbox02Settings$6 = {
  deviceName: {
    current: "Geçerli cihaz adı",
    input: "BitBox02 Adı",
    title: "BitBox02 cihazınızı isimlendirin"
  }
};
const bitbox02Wizard$6 = {
  attestationFailed: "Cihaz onayı başarısız oldu. BitBox'ınız sahte veya tehlikede olabilir. BitBox02 üzerindeki paralar kaybolma riski altında olabilir. Lütfen acilen support@bitbox.swiss ile iletişime geçin.",
  backup: {
    point1: "MicroSD karttan bir yedek seçin",
    point2: "Cihazınız için bir şifre belirleyin",
    restoreText: "Tamam, hadi bir yedeği geri yükleyelim!",
    text1: "Harika, BitBox02 şifreniz ayarlandı ve cüzdan oluşturuldu. Şimdi ilk yedeğinizi oluşturma zamanı. Lütfen microSD kartınızın BitBox02 cihazınıza takılı olduğundan emin olun ve devam edin.",
    text2: "Bir yedekleme oluşturmak için lütfen cihazınızdaki ekrandaki talimatları izleyin.",
    text3: "Yedeklemeniz oluşturulduktan sonra, lütfen microSD kartı çıkarın ve <strong>güvenli bir yerde</strong> saklayın. MicroSD kartın içeriği şifre korumalı değildir. Bu nedenle asla başka bir cihaza yerleştirmeyin.",
    userConfirmation1: "Yedeklememi güvenli bir yerde saklamalıyım.",
    userConfirmation2: "Yedeklerim şifre korumalı değil. Buna erişimi olan herkes cüzdanıma erişebilir.",
    userConfirmation3: "BitBox02 yazılımımı kaybedersem veya zarar verirsem, paramı kurtarmanın tek yolu yedeklememden geri yüklemektir.",
    userConfirmation4: "Hem yedeğimi hem de BitBox02’mi kaybedersem veya zarar verirsem fonlarım kaybolacak."
  },
  create: {
    button: "Cihazı adlandır ve devam et",
    info: "İşte BitBox'ınızı ayarlamak için atmanız gereken temel adımlar: ",
    inputTitle: "Cüzdan adı",
    point1: "Cihazınızı adlandırın",
    point2: "Cihazınız için bir şifre belirleyin",
    point3: "Yedekleme oluştur",
    text: "Tamam, hadi yeni bir cüzdan yaratalım!"
  },
  initialize: {
    passwordText: "Şimdi cihazınız için bir şifre ayarlayalım. Bir şifre girmek ve bir şifre seçmek için BitBox'ınızdaki kontrolleri kullanın.",
    passwordTitle: "BitBox'ınız için bir şifre belirleyin",
    text: "BitBox02 cihazınız başarıyla eşleştirildi! Şimdi cihazınızı başlatalım. Yeni bir cüzdan oluşturmayı veya cüzdanı mevcut bir yedekten geri yüklemeyi seçerek başlayın. <strong>Lütfen BitBox02 cihazınıza takılı bir microSD kartın olduğundan emin olun.</strong>",
    tip: "Başlamadan önce, işlemlere güvenli bir ortamda devam etmeniz şiddetle tavsiye edilir.",
    title: "BitBox'ınızı başlatın"
  },
  insertSDCard: "<strong>Lütfen BitBox02 cihazınıza takılı bir microSD kartın olduğundan emin olun.</strong>",
  pairing: {
    failed: "Onaylanmamış eşleştirme. Lütfen BitBox02'nizi değiştirin.",
    paired: "Cihazınızda kodun eşleştiğini onayladınız. Bu doğruysa, aşağıdaki düğmeye tıklayarak devam edebilirsiniz.",
    title: "Eşleştirme Kodunu Doğrulayın",
    unpaired: "Yeni bir BitBox02 tespit edildi. Lütfen aşağıdaki kodun cihazınızda gösterilenlerle eşleştiğini doğrulayın. Kod eşleşirse, BitBox02 üzerindeki onay işaretinin altındaki simgeye dokunun ve devam etmek için aşağıdaki düğmeye tıklayın."
  },
  restoreFromMnemonic: {
    failed: "BIP39 anımsatıcısından geri yükleme başarısız oldu, lütfen tekrar deneyin."
  },
  stepBackup: {
    beforeProceed: "Devam etmeden önce, lütfen şu önemli güvenlik hususlarını okuyun:",
    createBackup: "Şimdi microSD kartınızda bir yedekleme oluşturacaksınız."
  },
  stepBackupSuccess: {
    fundsSafe: "Fonlarınızı güvende tutmak için lütfen aşağıdakileri unutmayın:",
    title: "Yedekleme Geri Yüklendi!"
  },
  stepConnected: {
    unlock: "Kilidi açmak için BitBox02 şifresini girin."
  },
  stepCreate: {
    nameLabel: "BitBox02 adı",
    namePlaceholder: "Benim BitBox02 cüzdanım",
    title: "BitBox02 adını seçin",
    toastMicroSD: "Lütfen microSD kartınızın BitBox02 cihazınıza takılı olduğundan emin olun."
  },
  stepCreateSuccess: {
    removeMicroSD: "Lütfen microSD kartı BitBox02 cihazınızdan çıkarın ve güvenli bir yerde saklayın.",
    success: "Yedeklemenizi başarıyla oluşturdunuz."
  },
  stepPassword: {
    title: "BitBox02 şifresini ayarla",
    useControls: "Bir şifre belirlemek için BitBox02 üzerindeki kontrolleri kullanın."
  },
  stepUninitialized: {
    create: "BitBox02 cihazımı yeniden kurmak istiyorum.",
    restore: "Cüzdanımı bir yedekten geri yüklemek istiyorum.",
    restoreMicroSD: "MicroSD karttan geri yükle",
    restoreMnemonic: "Anımsatıcıdan geri yükle",
    title: "BitBox02 cihazınızı kurun"
  },
  success: {
    text: "Yaşasın! BitBox02'niz artık kullanıma hazır.\n\nBitBox Uygulaması'nın nasıl kullanılacağı hakkında daha fazla bilgi için, lütfen sağ üst köşedeki soru işaretini tıklayarak uygulama içi kılavuzunu kullanın.",
    title: "Başlamaya hazırsın!"
  }
};
const blink$6 = {
  button: "Göz ardı et"
};
const bootloader$6 = {
  button: "Donanım yazılımını şimdi yükselt",
  progress: "Yükseltme: {{progress}}%",
  success: "Yükseltme başarılı! Lütfen cihazı tekrar takın. Bu kez, düğmeye dokunmayın."
};
const button$b = {
  abort: "İptal Et",
  back: "Geri",
  changepin: "Cihaz Şifresini Değiştir",
  check: "Yedeklemeyi Kontrol Et",
  "continue": "Devam et",
  copy: "Kopyala",
  create: "Oluştur",
  download: "İndir",
  hiddenwallet: "Gizli Cüzdan Oluştur",
  next: "Sonraki",
  ok: "Tamam",
  previous: "Önceki",
  receive: "Alınan",
  restore: "Geri Yükle",
  select: "Seç",
  send: "Gönder",
  unlock: "Kilidini aç",
  update: "Güncelleştirme",
  upgrade: "Yükselt"
};
const changePin$6 = {
  newTitle: "Yeni cihazın şifresi",
  oldLabel: "Mevcut cihazın şifresi"
};
const checkSDcard$6 = "Mikro SD kart kontrol ediliyor";
const clickHere$6 = "Buraya tıklayın.";
const confirm$8 = {
  abortInfo: "Dokunun",
  abortInfoRedText: "İptal et",
  approveInfo: "Şu tuşa 4 saniye basılı tut ",
  approveInfoGreenText: "doğrula",
  info: "BitBox'ınızda",
  infoWhenPaired: "Önce telefonla sonrasında Bitbox'la eşleştirin"
};
const confirmOnDevice$6 = "Lütfen cihazınızda onaylayın.";
const device$6 = {
  appUpradeRequired: "BitBox'ınız bu masaüstü uygulaması ile uyumlu değil. Lütfen en son sürümü indirin ve yükleyin."
};
const deviceLock$6 = {
  button: "Two Factor Authorization (2FA) Etkinleştirme",
  condition1: "Bir yedeğin var mı?",
  condition2: "Mobil uygulama doğrulama çalışıyor mu?",
  condition3: "2FA yedekleri ve mobil uygulama eşleştirmesini DEVRE DIŞI bırakır. 2FA'dan çıkmak için cihazın SIFIRLANMASI olması gerekir!",
  confirm: "Two Factor Authorization (2FA) Etkinleştirme",
  title: "Two Factor Authorization (2FA) Etkinleştirme"
};
const deviceSettings$6 = {
  firmware: {
    newVersion: {
      label: "Mevcut sürüm"
    },
    title: "Donanım yazılımı",
    upToDate: "Cihazınız güncel",
    version: {
      label: "Versiyon"
    }
  },
  hardware: {
    sdcard: {
      "false": "Takılı değil",
      label: "Mikro SD kart",
      "true": "Takılı"
    },
    title: "Donanım"
  },
  loading: "Cihaz bilgisi alınıyor…",
  pairing: {
    lock: {
      "false": "Devre dışı",
      label: "Two Factor Authorization (2FA)",
      "true": "Etkinleştir"
    },
    mobile: {
      "false": "Kapalı",
      label: "Mobil Uygulama",
      "true": "Aç"
    },
    status: {
      "false": "Eşleştirilmemiş",
      label: "Durum",
      "true": "Eşleştirilmiş"
    },
    title: "Eşleştirme"
  },
  secrets: {
    manageBackups: "Yedekleri Yönet",
    title: "Secrets"
  }
};
const deviceTampered$6 = "BitBox'ınıza kurtarma şifresi mi sağlandı? Öyleyse, kurulum işlemini durdurun ve hemen desteğe başvurun. Ekibimiz asla size hazır bir cüzdan vermez veya şifre önerileri yapmaz.";
const dialog$7 = {
  cancel: "İptal Et",
  confirm: "Doğrula"
};
const fiat$8 = {
  "default": "Varsayılan",
  setDefault: "{{code}} varsayılan olarak ayarla",
  title: "Para birimleri"
};
const footer$8 = {
  appVersion: "Uygulama Sürümü:"
};
const genericError$6 = "Bir hata oluştu. Herhangi bir sorunla karşılaşırsanız, lütfen uygulamayı yeniden başlatın.";
const goal$6 = {
  buttons: {
    create: "Yeni bir cüzdan oluştur",
    restore: "Cüzdanı yedekten geri yükle"
  },
  paragraph: "Lütfen aşağıdaki seçeneklerden birini seçin:",
  step: {
    "1": {
      title: "Güvenlik bilgileri"
    },
    "2": {
      description: "Bir cihaz şifresi belirleyin",
      title: "cihaz"
    },
    "3-create": {
      description: "Yeni bir cüzdan oluştur",
      title: "Cüzdan"
    },
    "3-restore": {
      description: "bir yedekten",
      title: "Geri Yükle"
    },
    "4-create": {
      title: "Özet"
    },
    "4-restore": {
      title: "Özet"
    }
  }
};
const guide$7 = {
  accountDescription: {
    text: 'Hesabınıza genel bakış, mevcut bakiyenizi, gelen ve giden işlemlerinizi gösterir. " Ayarlar" sekmesindeki kılavuzumuz her hesap türü hakkında daha fazla bilgi içerir. ',
    title: "Bu sayfa bana ne gösteriyor?"
  },
  accountFiat: {
    text: "Evet. Fiat para birimlerine dönüştürmek için herhangi bir ticker'a tıklayın. Ayarlardan Fiat para birimlerini değiştirebilirsiniz.",
    title: "Diğer dönüşüm oranlarını görüntüleyebilir miyim?"
  },
  accountIncomingBalance: {
    text: "Yatırılanlar; size aktarılan ancak henüz ağ tarafından onaylanmayan tutarları gösterir.",
    title: "Yatırılanlar ne demek?"
  },
  accountInfo: {
    xpub: {
      text: "Genişletilmiş bir genel anahtar, bir hesabın tüm alıcı adreslerinin türetildiği bir kök anahtardır.\nBurada Electrum veya Sentinel gibi yalnızca izlemek için olan cüzdanlarla ileri düzeyde kullanım ve birlikte çalışabilirlik için sağlanmıştır.",
      title: "Genişletilmiş genel anahtar nedir?"
    }
  },
  accountRates: {
    text: "Kripto para kurlarını her dakika CoinGecko'dan güncelliyoruz.",
    title: "Hangi döviz kurları uygulanıyor?"
  },
  accountReload: {
    text: "Buna ihtiyacınız yok. İşlem bilgileriniz otomatik olarak güncellenir.",
    title: "İşlem geçmişini yeniden yükleyebilir miyim?"
  },
  accountSendDisabled: {
    text: 'Bakiyeniz sıfırdan fazla olduğunda "Gönder" butonu etkinleşir.',
    title: "Neden hiçbir şey gönderemiyorum {{unit}}?"
  },
  accountTransactionAttributesBTC: {
    title: ""
  },
  accountTransactionAttributesGeneric: {
    text: "Onaylar: İlk işlem yayınınız, bir madenci bir bloğa dahil edinceye kadar onaylanmaz, ardından bir onay verilir. Ağda yayınlanan her blok, işleminize başka bir onay ekler. Genel olarak, tüccarlar ve diğer ağ aktörler üç ila altı onay aldığında işlemleri gerçekleştirir.\nİşlem Kimliği: Bir blok gezgininde bir işlem aramanıza izin veren benzersiz bir kimlik numarası.\nÜcret: Madencilere, işlemleri onaylamalarını teşvik etmek için işlem ücreti ödenir. Daha fazla bilgi için, gönder düğmesine tıklayın.",
    title: "İşlem detaylarındaki bilgiler neler?"
  },
  accountTransactionConfirmation: {
    text: "Ağda yayınlanan ancak henüz onaylanmayan bir işlem.",
    title: "Beklemedeki işlem nedir?"
  },
  accountTransactionLabel: {
    text: "Kripto paralarınızı aldığınız veya gönderdiğiniz adres.",
    title: "Her işlemde görüntülenen adres hangisi?"
  },
  accountTransactionTime: {
    text: "Blockchain işlem onay süresi.",
    title: "Ne zaman görüntülenir?"
  },
  appendix: {
    link: "Bizimle iletişime geçin!",
    text: "Başka bir soru?"
  },
  backups: {
    check: {
      text: "'Yedeklemeyi kontrol et', geçerli cüzdanınıza karşılık gelen çalışan bir yedeklemeniz olduğunu doğrulamanıza olanak tanır. Ayrıca hala doğru kurtarma şifresine sahip olduğunuzu doğrulamak için kullanılabilir. Ana kurtarma şifrenizi veya gizli kurtarma şifrenizi kontrol edebilirsiniz.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: "Hayır, ancak kurtarma şifrenizin cüzdanda depolanan sedden üretilmesi gerekir.",
      title: "Yedeklemeyi şifreleyebilir miyim?"
    },
    howOften: {
      text: "Yeni bir cüzdan oluşturulduğunda, yedekleme otomatik olarak oluşturulur. Yalnızca microSD kartınız kaybolursa veya hasar görürse veya yedek olarak birden fazla microSD kart kullanmak istiyorsanız, yeni bir yedekleme yapmanız gerekir.\nİşlem faaliyetinden sonra yeni yedeklemeler oluşturmanıza gerek yoktur. Tüm işlem verileriniz, sizin için otomatik olarak oluşturulan tek bir yedeklemeyle yeniden oluşturulabilir.",
      title: "Ne sıklıkla yedekleme yapmam gerekir?"
    },
    whatIsABackup: {
      text: "Mikro SD kartınızdaki seedin bir kopyası. Seed, kurtarma şifrenizle birlikte cüzdanınızı oluşturur.",
      title: "Yedek nedir?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Yedeklemeyi kontrol et' geçerli cüzdanınıza karşılık gelen çalışan bir yedeklemeniz olduğunu doğrulamanızı sağlar.",
      title: "'Yedeklemeyi kontrol et' nedir?"
    },
    encrypt: {
      text: `Hayır. Seedler şifrelenmemiş bir şekilde tutulduğundan MicroSD kartınızı güvende tutun. Seed'i şifreyle korumak istiyorsanız, "Cihazı yönet" altındaki gelişmiş ayarlardan isteğe bağlı bir şifre etkinleştirebilirsiniz.`,
      title: "Yedeklemeyi şifreleyebilir miyim?"
    },
    whatIsABackup: {
      text: "Bir microSD karttaki seed'in bir kopyası.",
      title: "Yedek nedir?"
    }
  },
  bitbox: {
    "2FA": {
      text: "2FA etkinleştirildiğinde, para harcamak için tüm işlemlerin eşleştirilmiş cep telefonunda onaylanması gerekir. Böylece şiifreli bir tek kullanımlık numara mobil uygulamaya gönderilir, orada şifresi çözülür ve Kabul Et düğmesine basıldığında BitBox'a geri döndürülür. Cihazla bu iletişim, cep telefonu ile eşleştirme sırasında kurulan bu masaüstü uygulaması arasındaki kanal üzerinden yapılır.\n\n2FA'yı etkinleştirmeden önce cüzdanınızı yedeklediğinizden ve mobil uygulamayı eşleştirdiğinizden emin olun. Once enabled, the micro SD slot and mobile app pairing are disabled. They can be re-enabled by resetting the BitBox, which erases the device.",
      title: "İki faktörlü doğrulama (2FA) nasıl çalışır?"
    },
    disable2FA: {
      text: "2FA'yı devre dışı bırakmak için, BitBox'ınızı sıfırlamanız ve ardından cüzdanı yedekten geri yüklemeniz gerekir. Yedeklemeye sahip microSD kartın hala olduğundan ve kurtarma şifresini hala hatırladığınızdan emin olun. Ardından 'Cihazı sıfırla' tuşuna basın. Yeni bir cihaz şifresi belirleyin ve 'Veya yedeği geri yükle'yi seçin. Cüzdanda oluşturduğunuz yedeklemeyi seçin, 'Geri Yükle'yi tıklayın ve cüzdanı oluştururken kullandığınız kurtarma şifresini girin.",
      title: "İki faktörlü doğrulamayı (2FA) nasıl devre dışı bırakabilirim?"
    },
    ejectBitbox: {
      text: "",
      title: "BitBox'ı nasıl çıkarabilirim?"
    },
    ejectSD: {
      text: "MicroSD kartı BitBox'tan istediğiniz zaman yedekleme oluşturma veya geri yükleme işlemi yapmadığınız sürece kaldırabilirsiniz.",
      title: "MicroSD kartı nasıl çıkarabilirim?"
    },
    hiddenWallet: {
      text: "Aynı cihazda, makul bir reddedilebilirlik için kullanabileceğiniz farklı bir cihaz şifresi ve kurtarma şifresiyle korunan ikinci bir cüzdandır. Aynı yedek send hem normal, hem de gizli cüzdanınız için kullanılır, bu nedenle ek bir yedekleme gerekmez.",
      title: "Gizli cüzdan nedir?"
    },
    legacyHiddenWallet: {
      text: "Önce aşağıdaki düğmeyi tıklayın (BitBox ana cihaz şifresiyle açılmışsa ve 2FA devre dışı bırakılmışsa kullanılabilir), ardından Bitbox'ınızı yeniden takıp kilidini gizli cihaz şifrenizle açın.",
      title: "Eski gizli cüzdanıma nasıl erişirim?"
    },
    pairing: {
      text: "Mobil uygulamamızı iOS veya Android için indirdikten sonra, mobil uygulama ile bu uygulama arasında güvenli bir kanal kuran görüntülenen QR kodunu tararsınız. Tarandıktan sonra mobil uygulamadaki talimatları izleyin.",
      title: "Telefonumla güvenli bir şekilde nasıl eşleştirilir"
    }
  },
  receive: {
    address: {
      text: "Size başkalarının kripto para göndermeleri için adresinizi verebilirsiniz. Sadece doğru adresi gönderdiğinizden emin olun.",
      title: "Bir adres ile ne yapabilirim?"
    },
    addressChange: {
      text: "İşlem yaptığınız anda, otomatik olarak listeye yeni bir adres eklenir, böylece her zaman kripto para almayan 20 adres bulunur.",
      title: "Adresler ne zaman değişir?"
    },
    howVerify: {
      text: "BitBox01 için soldaki kenar çubuğundaki BitBox simgesine tıklayın ve Eşleştirme bölümüne bakın. Kılavuz güncellenir ve oradaki talimatları izlemeye devam edebilirsiniz.\nBitBox02 için, gönderme/alma işlemi sırasında adresleri doğrudan cihaz üzerinde doğrulayabilirsiniz.",
      title: "Bir adresi güvenli bir şekilde nasıl doğrulayabilirim?"
    },
    why20: {
      text: "",
      title: "Neden sadece 20 adres?"
    },
    whyMany: {
      text: "Gizliliği ve güvenliği sağlamak için, aynı adresi asla iki kez vermeyin. Bir adres kullandıysanız, yeni bir adres için sağ oka tıklayın. Bir seferde 20 adede kadar adres oluşturabilirsiniz. Fatura numaraları gibi adresleri düşünün. Tüm adresler, tek yedekleme senedinden türetilir.",
      title: "Neden bu kadar çok adres var?"
    },
    whyVerify: {
      text: "Orijinal adresleri oluşturmak ve görüntülemek için bilgisayarınıza güvenmemelisiniz. Büyük bir saldırı, donanım cüzdanınızın daha savunmasız kalmasını sağlar. BitBox01'in güvenli bir şekilde doğrulama düğmesi, adresi QR kodunu da tarayabileceğiniz ve doğrulayabileceğiniz eşleştirilmiş bir cep telefonuna gönderir. BitBox02 için, adres doğrudan BitBox02 ekranında doğrulanabilir.",
      title: "Neden adresi güvenli bir şekilde doğrulamalıyım?"
    }
  },
  send: {
    fee: {
      text: "Ücret, işlem miktarına değil işlem miktarına göre belirlenir. Ücret hedefleri, seçtiğiniz her ağ önceliği için Bitcoin Core'un ücret tahmin algoritması ile hesaplanır. Aşağıdaki hedeften farklı bir değere sahiplerse gösterilirler.\nEkonomi: 24 blok (Bitcoin için yaklaşık 4 saat, Litecoin için 1 saat)\nDüşük: 12 blok (Bitcoin için yaklaşık 2 saat, Litecoin için 30 dakika)\nNormal: 6 blok (Bitcoin için yaklaşık 1 saat, Litecoin için 15 dakika)\nYüksek: 2 blok (Bitcoin için yaklaşık 20 dakika, Litecoin için 5 dakika)\n(Bir blok Bitcoin için ortalama on dakika sürer (Litecoin'de 2.5 dakika) ve ağ yükü yukarıdaki periyotlarda önemli ölçüde değişebilir.)",
      title: "Ücret nasıl belirlenir?"
    },
    priority: {
      text: "Ödemek istediğiniz ücret ne kadar yüksekse, işleminiz genellikle ağ tarafından daha erken onaylanır.",
      title: "Ağ önceliği nedir?"
    },
    revert: {
      text: "Bir işlem imzalanıp gönderildikten sonra (yani ağa yayınlanır), artık geri alınamaz. İmzalamadan önce işlemleri (ücret dahil) doğru bir şekilde doğrulayın!\nAlıcıyı tanıyorsanız ve aynı tutarı (eksi işlem ücretlerini) size geri göndermeye istekliyse, onlara yeni bir alıcı adresi gönderebilirsiniz.",
      title: "Bir işlemi geri alabilir miyim?"
    },
    whyFee: {
      text: "İşlemler madenci tarafından onaylanmak için yarışıyor. Madenciler ücretlerine göre Blockchain'e dahil edilecek işlemleri seçiyorlar.\nMadenciler işlem tarihine oy veriyor. İşlemleri onaylayacak güvenli bir üçüncü taraf olmadığı için (Blockchain'lerin hepsinde), madenciler bilgisayar gücü gibi pahalı bir kaynaktan fedakarlık yaparak işlemleri oyluyorlar. İşlerinin bir ödülü olarak, yeni oluşturulan paraları ve içerdikleri tüm işlemlerin ücretini talep edebilirler.",
      title: "Neden ağ ücreti var?"
    }
  },
  "settings-electrum": {
    what: {
      text: "Shift sunucularını kullanmak yerine cüzdanınıza kendi tam node'larınızla güç vermek mümkündür.",
      title: "Bu nedir?"
    }
  },
  settings: {
    servers: {
      text: "Bu uygulama, güncellemeleri kontrol etmek, işlemleri yüklemek ve eşleştirilmiş mobil uygulamalara bilgi göndermek için Shift Crypto sunucuları ile iletişim kurar.\nBu uygulama aynı zamanda CoinGecko'den en son döviz kurlarını alıyor. Tüm dönüşümler yerel olarak hesaplanır, bu işleminizin miktarı ile ilgili hiçbir veri iletilmediği anlamına gelir.\nNot: Ethereum ve ERC20 Tokens için Etherscan.io API'lerini kullanıyoruz.",
      title: "Bu uygulama hangi sunucularla konuşuyor?"
    }
  },
  title: "Kılavuz",
  toggle: {
    close: "Kılavuzu kapat",
    open: "Kılavuz"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Kurtarma parolasını kullanarak cihazı sıfırlamanız ve cüzdanı bir yedekten geri yüklemeniz gerekir.",
      title: "Cihaz şifresini unuttuğumda ne yapmalıyım?"
    },
    reset: {
      text: "15 kez yanlış cihaz şifresi girin. Son birkaç deneme, cihaza uzun süre dokunmayı gerektirir.",
      title: "Cihazı nasıl sıfırlarım?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Cihaz yerleştirildiğinde bir kez yanıp sönmelidir. Etrafına doğru yerleştirildiğinden emin olun. Eğer sorun yaşıyorsanız, lütfen aşağıdaki bağlantıdan bize ulaşın.",
      title: "BitBox01 tanınmıyor"
    },
    getDevice: {
      link: {
        text: "Bir BitBox siparişi verin"
      },
      text: "Online mağazamızda bir BitBox satın alabilirsiniz:",
      title: "Nasıl bir cihazı nasıl alabilirim?"
    },
    internet: {
      text: "Evet, cüzdanı senkronize etmek, işlemleri göndermek ve en son kurları almak için bir internet bağlantısı gerekir.",
      title: "Bu uygulama internet bağlantısı gerektiriyor mu?"
    },
    lostDevice: {
      link: {
        text: "Yedekleme merkezi"
      },
      text: "Hesaplarınızı yeni bir BitBox'la veya yedekleme merkezimizde kurtarabilirsiniz.",
      title: "Cihazımı kaybettim. Şimdi ne olacak?"
    },
    useWithoutDevice: {
      text: "Ne yazık ki, şu anda bu henüz mümkün değil.",
      title: "Bir cihaz olmadan uygulamayı kullanabilir miyim?"
    },
    welcome: {
      text: "Shift Crypto tarafından İsviçre'de üretilen bu uygulamayı kullandığınız için teşekkür ederiz. Paylaşmanız gereken herhangi bir geri bildirimi takdir ediyoruz. Lütfen alttaki bağlantıyı kullanarak geri bildirimde bulunun.",
      title: "BitBoxApp'a Hoşgeldiniz!"
    }
  }
};
const headerssync$6 = {
  blocksSynced: "{{blocks}} blok senkronize edildi"
};
const hiddenWallet$6 = {
  info1HTML: "",
  info2HTML: "Aşağıdaki gizli cüzdanınızla ilişkilendirmek istediğiniz cihaz şifresini ve kurtarma şifresini tanımlayın. Cihaz şifresi ve kurtarma şifresi <strong>farklı</strong> birincil cüzdanınız için tanımladığınızdan emin olun",
  passwordLabel: "Gizli kurtarma şifresi",
  passwordPlaceholder: "Lütfen gizli kurtarma şifresini onaylayın",
  pinLabel: "Gizli cihaz şifresi",
  pinRepeatLabel: "Gizli cihaz şifresini tekrarla",
  pinRepeatPlaceholder: "Lütfen gizli cihaz şifresini onayla",
  success: "Gizli cüzdan başarıyla oluşturuldu. Kilidini açmak için BitBox'ınızı değiştirin."
};
const initialize$6 = {
  create: "Cihaz şifresini ayarla",
  creating: "Cihaz şifresini ayarla",
  error: {
    e102: "Cihaz şifresi en az 4 karakterden oluşmalıdır."
  },
  info: {
    description1: "Cihaz şifrenizi seçin. Bu, BitBox'ınızın kilidini açmak için kullanılacaktır.",
    description2: "Sayıları, harfleri ve sembolleri kullanabilirsiniz. Daha uzun şifreler daha yüksek güvenlik sunar.",
    description3: "Cihaz şifresini kaybederseniz, cihazınızı sıfırlamanız ve cüzdan yedeklemenizi geri yüklemeniz gerekir.",
    subtitle: "Şimdi cihaz şifrenizi ayarlayacaksınız",
    title: "Cihazınız başlatılıyor"
  },
  input: {
    label: "Cihaz parolası",
    labelRepeat: "Cihaz şifresini tekrarla",
    placeholderRepeat: "Lütfen cihaz şifresini doğrulayın"
  }
};
const invalidFormat$6 = "Geçersiz format";
const language$7 = {
  title: "Dil Seçin"
};
const legacyhiddenwallet$6 = {
  disable: "Eski gizli cüzdanı devre dışı bırak",
  enable: "Eski gizli cüzdanı etkinleştir",
  successDisable: "Eski gizli cüzdanı başarıyla devre dışı bıraktınız.",
  successEnable: "Eski gizli cüzdanı başarıyla etkinleştirdi. Eski gizli cüzdanınıza erişmek için BitBox'ınızı değiştirin ve gizli cihaz şifresini girin."
};
const loading$6 = "Yükleniyor…";
const notification$6 = {
  newTxs_one: "{{accountName}}'da yeni işlem",
  newTxs_other: "{{count}} Yeni işlem: {{accountName}}"
};
const pairing$6 = {
  aborted: {
    text: "Eşleştirme işlemi mobil uygulamadan kaldırıldı.",
    title: "Kaldırıldı"
  },
  button: "Mobil Uygulamayla Eşleştir",
  confirm: "BitBox'ınızı eşleştirmek istediğinizden emin misiniz? Sonradan, cep telefonunun bir işlem gerçekleştirmesi gerektiğini unutmayın.",
  connectOnly: {
    button: "Mobil Uygulamayı Bağla",
    title: "'Yeni masaüstü uygulamasına bağlan' öğesini seçerek mobil uygulamamız ile tarayın"
  },
  error: {
    text: "Bir şeyler yanlış gitti. Lütfen tekrar başla.",
    title: "Hata"
  },
  reconnectOnly: {
    button: "Mobil Uygulamayı Yeniden Bağla"
  },
  start: {
    hideAppQRCode: "QR Kodunu Gizle",
    revealAppQRCode: "QR Kodunu Göster",
    step1: "Mobil uygulamanız yoksa, sahip olduğunuz telefona bağlı olarak Apple App Store veya Google Play Store için QR kodunu tarayabilirsiniz.",
    step2: "İOS ve Android uygulama mağazalarında 'Digital Bitbox 2FA' adı altında bulabileceğiniz mobil uygulamamız ile tarayın:"
  },
  started: {
    text: "Şimdi mobil uygulamadaki talimatları izleyin.",
    title: "Harika"
  },
  success: {
    text: "Tebrikler, BitBox'ınızı mobil uygulamayla başarıyla eşleştirdiniz!",
    title: "Başarılı"
  },
  timeout: {
    text: "Eşleştirme iki dakikanın ardından zaman aşımına uğradı. Mobil uygulamayı hala eşleştirmek istiyorsanız tekrar başlayın.",
    title: "Zaman aşımı"
  },
  title: "Mobil Eşleştirme"
};
const password$6 = {
  show: "Göster {{label}}",
  warning: {
    caps: "UYARI: Büyük harf kilidi (⇪) aktif",
    paste: 'Metni yapıştırmak için "GÖSTER" butonunu etkinleştirin {{label}}"'
  }
};
const random$7 = {
  button: "Rastgele Sayı Üret",
  description: "BitBox'ınız aşağıdaki {{bits}}-bit random sayıları üretti:"
};
const receive$8 = {
  label: "Sizin adresiniz",
  onlyThisCoin: {
    description: "Başka token'ları almak için, onları ayarlardan etkinleştirin. Diğer token'ları yatırırsanız, erişilebilir olmayabilir.",
    warning: "Sadece bu adresle  {{coinName}} almak istediğinize emin olun"
  },
  showFull: "Cihazdaki tam adresi göster ve doğrula",
  title: "{{accountName}} Al",
  verify: "Adresi güvenli bir şekilde doğrulayın",
  verifyBitBox01: "Mobil uygulamadaki adresi doğrula",
  verifyBitBox02: "BitBox02'deki adresi doğrulayın",
  verifyInstruction: "Lütfen aşağıdaki adresin cihazınızda görüntülenen adresiyle eşleştiğini doğrulayın.",
  warning: {
    secureOutput: "Güvenli adres doğrulamasını etkinleştirmek için lütfen BitBox'ınızı mobil cihazınızla eşleştirin ve kenar çubuğundaki 'Cihazı Yönet' seçeneğine tıklayın."
  }
};
const reset$6 = {
  description: "Cihazdaki tüm veriler silinecek. Buna Özel Anahtarınız da dahil!",
  notReset: "Cihazı SIFIRLAMA.",
  title: "Cihazı sıfırla",
  understand: "Bir yedeğim var ve kurtarma şifremi biliyorum",
  understandBB02: "Geçerli bir yedeğim var"
};
const securityInformation$6 = {
  create: {
    description1: "Cihazınızı kurmadan önce bunu güvenli bir ortamda yapmanız önerilir.",
    description2: "Sizden iki şifre oluşturmanız istenecektir.",
    description3: "İlki <strong>cihaz parolası</strong>. Bu şifre BitBox cihazınızın kilidini açar ve daha sonra değiştirilebilir.",
    description4: "İkincisi cüzdanınızın kilidini açan <strong>kurtarma şifresi</strong>. Bu şifre daha sonra değiştirilemez.",
    description5: "Oluşturduğunuz cüzdan, sağlanan mikro SD karttaki bir dosyaya yedeklenir. Bu, acil durumda <strong>kurtarma şifrenizi</strong> kullanarak fonlarınıza ulaşmanızı sağlar.",
    title: "Güvenlik Uyarısı"
  },
  restore: {
    description1: "Yedeklemenizi saklamak için kullandığınız mikro SD kartı takmanız istenecektir.",
    description2: "Cihazınızı geri yüklemek için kurtarma şifrenizin olması gerekir. ",
    description3: "Lütfen kurtarma şifresini girerken dikkatli olun. Girdiğiniz herhangi bir şifre geçerli bir cüzdan yaratacaktır. Yanlış şifre girerseniz, beklemediğiniz bir cüzdan bakiyesi gösterilebilir.",
    title: "Güvenlik Uyarısı"
  }
};
const seed$6 = {
  agreements: {
    "funds-access": "Kurtarma şifremi unutursam parama ulaşamayacağım",
    "password-change": "Kurtarma şifresini daha sonra değiştiremem",
    "password-required": "Bir cüzdanı bir yedekten geri yüklemek kurtarma şifresi gerektirir."
  },
  create: "Cüzdan Oluştur",
  creating: "Cüzdan oluşturma",
  description: "Bunu kabul ediyorum:",
  error: {
    e102: "Şifre en az 4 karakterden oluşmalıdır.",
    e200: "Cüzdan oluşturmak için BitBox'ınıza bir mikro SD kart takmanız gerekir, böylece yedekleme otomatik olarak oluşturulabilir."
  },
  info: {
    button: "Kurtarma şifresini şimdi ayarla",
    description1: "Mikro SD kartı BitBox'a takın",
    description2: "Cüzdan için bir kurtarma şifresi ayarlayın ve “Şimdi kurtarma şifresini ayarla” seçeneğini tıklayın.",
    description3: "Micro SD karta yedekleme ve kurtarma şifreniz, BitBox cihazın kaybolması veya çalınması durumunda paranızı kurtarmak için tek yöntemdir.",
    description4: "Paranızı aktarmadan kurtarma şifrenizi  değiştiremezsiniz.",
    title: "Yeni bir cüzdan oluştur"
  },
  password: {
    label: "Kurtarma şifresi",
    repeatPlaceholder: "Kurtarma şifresini tekrarla"
  },
  walletName: {
    label: "Cüzdan adı"
  }
};
const seedRestore$6 = {
  error: {
    e200: "Bir cüzdanı yedekten geri yüklemek için mikro SD kart gerekir."
  },
  info: {
    description1: `Mikro SD kartı BitBox'a takın ve "Devam Et" öğesine tıklayın`,
    description2: 'Bir yedekleme seçin ve "Geri Yükle" öğesini seçin',
    description3: "Kurtarma şifresini girin",
    description4: "Yanlış bir şifrenin farklı bir cüzdan yaratacağını kabul ettiğinizi onaylamanız gerekir.",
    title: "Bir cüzdanı bir yedekten geri yükleme"
  }
};
const send$8 = {
  abort: "İşlem iptal edildi.",
  address: {
    label: "Alıcı adresi",
    placeholder: "Adresi girin"
  },
  amount: {
    label: "Miktar",
    placeholder: "Miktarı girin"
  },
  button: "İmzala ve Gönder",
  coincontrol: {
    address: "Adres",
    outpoint: "Çıktı",
    title: "Çıktıdan Gönder"
  },
  confirm: {
    "selected-coins": "Seçilmiş Kripto Paralar",
    title: "İşlemi Onayla",
    total: "Toplam"
  },
  error: {
    insufficientFunds: "yetersiz bakiye",
    invalidAddress: "geçersiz adres",
    invalidAmount: "geçersiz miktar",
    invalidData: "geçersiz veri"
  },
  fee: {
    customPlaceholder: "Miktarı girin",
    label: "Ağ Ücreti",
    placeholder: "Kullanılabilir değil"
  },
  feeTarget: {
    description: {
      economy: "24 blok (Bitcoin için yaklaşık 4 saat, Litecoin için 1 saat)",
      high: "2 blok (Bitcoin için yaklaşık 20 dakika, Litecoin için 5 dakika)",
      low: "12 blok (Bitcoin için yaklaşık 2 saat, Litecoin için 30 dakika)",
      normal: "6 blok (Bitcoin için yaklaşık 1 saat, Litecoin için 15 dakika)"
    },
    estimate: "Tahmini bekleme süresi:",
    label: {
      economy: "ekonomi",
      high: "yüksek",
      low: "düşük",
      normal: "normal"
    },
    placeholder: "Hesaplanan tahmini ücret"
  },
  maximum: "Hepsini gönder",
  scanQR: "QR Kodunu Tara",
  signprogress: {
    description: "Bu, çok fazla veri içeren bir işlemdir. İşlemi tamamen imzalamak için  {{steps}} defa onaylamanız istenir.",
    label: "İlerleme"
  },
  success: "İşlem imzalandı ve gönderildi.",
  title: "Gönder {{accountName}}",
  toggleCoinControl: "Kripto para kontrolünü aç"
};
const settings$7 = {
  electrum: {
    add: "Bir sunucu ekle",
    "add-server": "Ekle",
    check: "Kontrol et",
    checkFailed: "Başarısız oldu",
    checkSuccess: "Başarıyla bağlantı kuruldu {{host}}",
    checking: "Kontrol ediliyor",
    "download-cert": "Uzak sertifikayı indir",
    "remove-server": "Kaldır",
    removeConfirm: "Kaldır {{server}}?",
    reset: "Varsayılana sıfırla",
    resetConfirm: "Tüm sunucuları kaldırmak ve varsayılan sunucuları kurmak istiyor musunuz?",
    servers: "Sunucular",
    step1: "1",
    "step1-text": "Bitiş noktasını girin.",
    step2: "2",
    "step2-text": "Sunucunun sertifika zincirinden bir sertifikasını girin. Alternatif olarak, uzak sertifikayı indirin ve görsel olarak karşılaştırın.",
    step3: "3",
    "step3-text": "Bağlantınızı kontrol edin ve sunucuyu ekleyin.",
    step4: "4",
    "step4-text": "Cüzdanınızı yeniden başlatın. Varsayılan sunucuları kaldırmazsanız, kendi düğümünüz fazlalık olarak eklenir.",
    "title-btc": "Bitcoin Electrum Sunucuları",
    "title-ltc": "Litecoin Electrum Sunucuları",
    "title-tbtc": "Bitcoin Testnet Electrum Sunucuları",
    "title-tltc": "Litecoin Testnet Electrum Sunucuları"
  },
  expert: {
    coinControl: "Coin kontrolünü etkinleştir",
    electrum: {
      title: "Kendi tam node'unuza bağlayın"
    },
    setProxyAddress: "Proxy adresini ayarla",
    title: "Uzman Ayarları",
    useProxy: "Tor proxy'yi etkinleştir"
  },
  header: {
    home: "Ev"
  },
  restart: "Lütfen değişikliklerin geçerli olması için BitBoxApp’i yeniden başlatın.",
  success: "Değişikliklerin etkili olması için lütfen BitBox’un fişini çekin ve yeniden takın.",
  title: "Ayarlar"
};
const setup$6 = "Cihaza Kurulum Yap";
const sidebar$7 = {
  device: "Cihazı Yönet",
  leave: "Ayrıl",
  settings: "Ayarlar"
};
const success$d = {
  create: {
    info1: "Cüzdanınız micro SD Karta güvenli bir şekilde yedeklendi. Çıkarın ve güvenli bir yerde saklayın.",
    info2: "BitBox'un kilidini açan güvenli bir cihaz şifresi oluşturdunuz.",
    info3: "Cüzdanınız için paranızın kilidini açan ve yedeklerinizi geri yükleyen güvenli bir kurtarma şifresi oluşturdunuz.",
    summary: "İşte işlem özetiniz",
    title: "Başarılı"
  },
  getstarted: "Başlarken",
  restore: {
    summary: "Yedeklemenizden bir cüzdanı başarıyla geri yüklediniz.",
    title: "Başarılı"
  }
};
const transaction$7 = {
  confirmation: "Onaylar",
  explorer: "İşlem Kimliği",
  explorerTitle: "Harici explorer'da aç",
  fee: "Ücret",
  fiatHistorical: "Tarih",
  gas: "Gas",
  pending: "Bekleyen işlem",
  size: "Boyut",
  vsize: "Sanal boyut",
  weight: "Ağırlık"
};
const transactions$6 = {
  placeholder: "Henüz işlem yok."
};
const unknownError$6 = "Bilinmeyen bir hata oluştu: {{errorMessage}}";
const unlock$6 = {
  description: "Cihazınızın kilidini açmak için cihaz şifrenizi girin.",
  error: {
    e109_normal: "Cihaz şifresi yanlış. Cihaz sıfırlanmadan önce {{remainingAttempts}} yapabilirsiniz.",
    e109_touch: "$t(unlock.error.e109_normal) Bir sonraki giriş için dokunmatik düğmeye basılı tutmanız gerektirir.",
    e113: "Birçok giriş denemesi nedeniyle, bir sonraki giriş için dokunmatik düğmeye 4 saniye basılı tutmanız gerekiyor."
  },
  input: {
    label: "Cihaz şifresi",
    placeholder: "Cihazın kilidini açmak için cihaz şifrenizi girin."
  },
  unlocking: "Kilit açılıyor"
};
const upgradeFirmware$7 = {
  button: "Donanım yazılımını yükselt",
  description: "Donanım yazılımını  {{currentVersion}}'dan {{newVersion}}'a yükseltmek istiyor musunuz??",
  label: "BitBox'ınızın ürün yazılımının yükseltilmesi gerekiyor.",
  locked: " {{currentVersion}} den yükseltmek için için {{newVersion}}, lütfen uzun süre basılı tutun.",
  title: "Donanım yazılımını yükselt",
  unlocked: "Bootloader kilidi açıldı. Devam etmek için lütfen:",
  unlocked1: "Bitbox'ınızı çıkarın ve yeniden takın",
  unlocked2: "BitBox'unuz tekrar takıldığında LED yanacaktır",
  unlocked3: "LED yandığında düğmeye dokunun"
};
const warning$c = {
  receivePairing: "Güvenli adres doğrulamasını etkinleştirmek için lütfen BitBox'ı eşleştirin. Kenar çubuğunda 'Cihazı Yönet' seçeneğine gidin.",
  sdcard: "Yedeklemeleri yönetmek istemediğiniz sürece, mikro SD kartı BitBox'tan ayrı saklayın.",
  sendPairing: "İşlem ayrıntılarını güvenli bir şekilde doğrulamak için lütfen BitBox'ı eşleştirin. Kenar çubuğundan 'Cihazı Yönet' seçeneğine gidin."
};
const welcome$6 = {
  insertBitBox02: "Devam etmek için lütfen cihaza dokunun.",
  insertDevice: "Başlamak için lütfen cihazınızı bağlayın",
  title: "Hoşgeldiniz"
};
const appTranslationsTR = {
  account: account$6,
  accountInfo: accountInfo$6,
  accountSummary: accountSummary$6,
  addAccount: addAccount$7,
  app: app$6,
  backup: backup$6,
  bb02Bootloader: bb02Bootloader$6,
  bitbox: bitbox$6,
  bitbox02Interact: bitbox02Interact$6,
  bitbox02Settings: bitbox02Settings$6,
  bitbox02Wizard: bitbox02Wizard$6,
  blink: blink$6,
  bootloader: bootloader$6,
  button: button$b,
  changePin: changePin$6,
  checkSDcard: checkSDcard$6,
  clickHere: clickHere$6,
  confirm: confirm$8,
  confirmOnDevice: confirmOnDevice$6,
  device: device$6,
  deviceLock: deviceLock$6,
  deviceSettings: deviceSettings$6,
  deviceTampered: deviceTampered$6,
  dialog: dialog$7,
  fiat: fiat$8,
  footer: footer$8,
  genericError: genericError$6,
  goal: goal$6,
  guide: guide$7,
  headerssync: headerssync$6,
  hiddenWallet: hiddenWallet$6,
  initialize: initialize$6,
  invalidFormat: invalidFormat$6,
  language: language$7,
  legacyhiddenwallet: legacyhiddenwallet$6,
  loading: loading$6,
  notification: notification$6,
  pairing: pairing$6,
  password: password$6,
  random: random$7,
  receive: receive$8,
  reset: reset$6,
  securityInformation: securityInformation$6,
  seed: seed$6,
  seedRestore: seedRestore$6,
  send: send$8,
  settings: settings$7,
  setup: setup$6,
  sidebar: sidebar$7,
  success: success$d,
  transaction: transaction$7,
  transactions: transactions$6,
  unknownError: unknownError$6,
  unlock: unlock$6,
  upgradeFirmware: upgradeFirmware$7,
  warning: warning$c,
  welcome: welcome$6
};
const account$5 = {
  disconnect: "连接断开.重试中...",
  exportTransactions: "将交易导出为CSV文件并下载文件夹",
  fatalError: "出现意外错误",
  incoming: "传入",
  initializing: "正在从区块链网络中获取信息",
  reconnecting: "链接断开，尝试重新链接"
};
const accountInfo$5 = {
  address: "地址",
  extendedPublicKey: "扩展公钥",
  label: "帐户信息",
  title: "帐户信息",
  verify: "请在设备上进行验证"
};
const accountSummary$5 = {
  balance: "余额",
  exportSummary: "将帐户摘要导出为CSV文件并保存到下载文件夹中",
  fiatBalance: "法币余额",
  name: "账户名",
  noAccount: "还未添加账户",
  title: "帐户汇总",
  total: "总计"
};
const addAccount$6 = {
  title: "添加账户"
};
const app$5 = {
  upgrade: "该应用程序有新版本可用！请从 {{current}} 升级至 {{version}}。"
};
const backup$5 = {
  check: {
    checking: "正在检查备份…",
    confirmTitle: "检查备份",
    notOK: "备份与钱包不匹配。",
    ok: "备份与钱包匹配。",
    password: {
      label: "恢复密码",
      placeholder: "恢复密码",
      showLabel: "恢复密码"
    },
    success: "成功验证备份：",
    title: "检查备份"
  },
  create: {
    alreadyExists: "您已经拥有一个有效备份。您想重新创建它吗？",
    fail: "创建备份失败！",
    info: "请输入当前钱包的恢复密码以进行验证。",
    name: {
      label: "备份名称",
      placeholder: "请为该备份命名"
    },
    password: {
      label: "恢复密码",
      placeholder: "请输入您的恢复密码"
    },
    title: "创建备份",
    verificationFailed: "恢复密码与当前的钱包不匹配。备份已创建。请使用“检查备份”再次验证您的恢复密码。"
  },
  description: "选择 <strong>钱包备份文件</strong>",
  insert: "请插入Micro SD卡以管理备份。",
  insertButton: "我已插入Micro SD卡",
  list: "您的microSD卡备份",
  noBackups: "此microSD卡上没有备份。",
  restore: {
    confirmTitle: "恢复已有备份",
    error: {
      e200: "找不到(无法识别到)microSD卡"
    },
    password: {
      label: "恢复密码或隐藏恢复密码",
      placeholder: "恢复密码",
      repeatPlaceholder: "重复恢复密码",
      showLabel: "恢复密码"
    },
    restoring: "正在还原备份…",
    title: "恢复",
    understand: "我知道输入错误的恢复密码会创建出另一个不同的钱包"
  },
  showMnemonic: {
    description: "系统将为您提供最多24个单词，构成您的钱包(助记词)备份。请把它们用抄写到纸上。\n\n<strong>请勿将其数字化存储或对其进行拍照。</strong>\n\n<strong>不要大声说出这些单词。</strong>\n\n<strong>此备份不受密码加密保护。</strong>\n\n抄写完成后，您将需要再次核对每个单词。",
    title: "显示助记词"
  },
  title: "管理备份"
};
const bb02Bootloader$5 = {
  abort: "不要升级-退回",
  advanced: {
    label: "高级设置",
    toggleShowFirmwareHash: "每次启动时显示固件哈希"
  },
  flipscreen: "翻转屏幕",
  orientation: "设备方向错误？",
  success: "升级成功！继续(等待) {{rebootSeconds}} 秒..."
};
const bitbox$5 = {
  error: {
    e10000: "当前输入的设备密码不正确",
    e10001: "更改设备密码失败",
    e102: "密码必须包含至少4个字符",
    e112: "隐藏的设备密码不能与主设备密码相同。"
  }
};
const bitbox02Interact$5 = {
  followInstructions: "请按照BitBox02上的说明进行操作。"
};
const bitbox02Settings$5 = {
  deviceName: {
    current: "当前设备名称",
    input: "BitBox02 名称",
    title: "设置BitBox02的设备名称"
  }
};
const bitbox02Wizard$5 = {
  attestationFailed: "设备认证失败，可能是由于在设备等待用户输入时应用程序重新启动所致。请重新连接，然后重试。",
  backup: {
    point1: "在microSD卡上选择一个备份",
    point2: "为您的设备设置密码",
    restoreText: "好的，现在让我们还原备份！",
    text1: "太棒了，您的BitBox02设备密码已设置完成，并成功创建了新钱包。现在是时候创建您的第一个备份了。请确保您的microSD卡已插入BitBox02设备中并继续。",
    text2: "请按照设备屏幕上的提示创建备份。",
    text3: "创建备份后，请取出microSD卡并将其存储在<strong>安全的地方</strong>。 microSD卡的内容不受密码保护。请勿将其插入BitBox02以外的任何其他设备中。",
    userConfirmation1: "我应该将备份存储在安全的地方。",
    userConfirmation2: "我的备份不受密码保护。任何有权访问它的人都可以访问我的钱包。",
    userConfirmation3: "如果我丢失或损坏了BitBox02设备，恢复资金的唯一方法是通过我的(私钥)备份进行恢复。",
    userConfirmation4: "如果我同时丢失或损坏了我的备份以及BitBox02设备，那么我的资金将会永远丢失。"
  },
  create: {
    button: "命名设备 & 继续",
    info: "以下是设置BitBox所要执行的基本步骤： ",
    inputTitle: "钱包名称",
    point1: "为您的设备命名",
    point2: "为您的BitBox设备设置密码",
    point3: "建立备份",
    text: "好的，让我们开始创建一个新的钱包！"
  },
  initialize: {
    passwordText: "现在，让我们为您的设备设置密码。参考以下视频指导，通过BitBox设备的边框触控功能进行密码设置。",
    passwordTitle: "为您的BitBox设置密码",
    text: "已成功配对您的BitBox02！现在，让我们进行设备的初始化。请选择您是要创建一个新的钱包，或是需要从已有(私钥)备份中恢复原来的钱包。 <strong>请确保您的BitBox02中插入了microSD卡</strong>",
    tip: "我们建议您在安全的环境中进行操作。",
    title: "初始化您的BitBox"
  },
  insertSDCard: "<strong>请确保您的BitBox02设备上已插入了microSD卡。</strong>",
  pairing: {
    failed: "未确认的配对。请重新插入您的BitBox02。",
    paired: "您已在设备上确认代码匹配。如果确认无误，则可以单击下面的按钮以继续。",
    title: "配对码验证中",
    unpaired: "已检测到新的BitBox02。请验证以下代码是否与您设备上显示的代码匹配。如果代码匹配(相同)，请轻触BitBox02显示屏上打勾选项下方的设备边框以继续。"
  },
  restoreFromMnemonic: {
    failed: "通过助记词进行的恢复失败，请重试。"
  },
  stepBackup: {
    beforeProceed: "在继续之前，请阅读以下重要的安全注意事项：",
    createBackup: "现在，您将在microSD卡上创建备份。"
  },
  stepBackupSuccess: {
    fundsSafe: "为了确保您的资金安全，请记住以下几点：",
    title: "备份已还原！"
  },
  stepConnected: {
    unlock: "输入BitBox02密码进行解锁。"
  },
  stepCreate: {
    nameLabel: "BitBox02名称",
    namePlaceholder: "我的BitBox02",
    title: "选择BitBox02名称",
    toastMicroSD: "请确保您的microSD卡已插入BitBox02中。"
  },
  stepCreateSuccess: {
    removeMicroSD: "请从BitBox02中取出microSD卡，并将其存储在安全的位置。",
    success: "您已成功创建备份。"
  },
  stepPassword: {
    title: "设置BitBox02密码",
    useControls: "使用BitBox02上的触控控件设置密码。"
  },
  stepUninitialized: {
    create: "我想设置一个新的BitBox02。",
    restore: "我想从备份中还原我的钱包。",
    restoreMicroSD: "从microSD卡还原",
    restoreMnemonic: "通过助记词还原",
    title: "设置您的BitBox02"
  },
  success: {
    text: "太棒了！您可以开始使用BitBox02了。\n\n如需获取如何使用BitBoxApp的信息，请单击右上角的问号访问应用程序指南。",
    title: "您已准备就绪！"
  }
};
const blink$5 = {
  button: ""
};
const bootloader$5 = {
  button: "立即升级固件",
  progress: "升级： {{progress}}％",
  success: "升级成功！请重新插入设备。这次，请一定不要触摸按钮。"
};
const button$a = {
  abort: "中止",
  back: "返回上一步",
  changepin: "更改设备密码",
  check: "检查备份",
  "continue": "继续",
  copy: "复制",
  create: "创建",
  download: "下载",
  hiddenwallet: "创建隐藏钱包",
  next: "下一个",
  ok: "好的",
  previous: "上一个",
  receive: "接收",
  restore: "恢复",
  select: "选择",
  send: "发送",
  unlock: "解锁(设备)",
  update: "更新",
  upgrade: "升级"
};
const changePin$5 = {
  newTitle: "新设备密码",
  oldLabel: "当前设备密码"
};
const checkSDcard$5 = "检查microSD卡";
const clickHere$5 = "点击这里。";
const confirm$7 = {
  abortInfo: "点按 ",
  abortInfoRedText: "中止",
  approveInfo: "保持4秒 ",
  approveInfoGreenText: "确认",
  info: "在您的BitBox设备上",
  infoWhenPaired: "首先在配对的手机上，然后在您的BitBox上"
};
const confirmOnDevice$5 = "请在设备上进行确认";
const device$5 = {
  appUpradeRequired: "您的BitBox与该桌面应用程序不兼容。请下载并安装最新版本。"
};
const deviceLock$5 = {
  button: "启用双因素认证（2FA）",
  condition1: "你有备份吗？",
  condition2: "移动端app的验证功能是否正常工作？",
  condition3: "2FA禁用了备份和移动应用程序配对功能。必须进行设备复位才能退出2FA！",
  confirm: "启用双因素验证(2FA)",
  title: "启用双因素验证（2FA）"
};
const deviceSettings$5 = {
  firmware: {
    newVersion: {
      label: "可用版本"
    },
    title: "固件",
    upToDate: "您的设备固件是最新的",
    version: {
      label: "版本"
    }
  },
  hardware: {
    sdcard: {
      "false": "未插入",
      label: "microSD卡",
      "true": "已插入"
    },
    title: "硬件信息"
  },
  loading: "检索设备信息…",
  pairing: {
    lock: {
      "false": "禁用",
      label: "双因素授权（2FA）",
      "true": "启用"
    },
    mobile: {
      "false": "关闭",
      label: "移动端app",
      "true": "打开"
    },
    status: {
      "false": "无法配对",
      label: "状态",
      "true": "已配对"
    },
    title: "配对中"
  },
  secrets: {
    manageBackups: "管理备份",
    title: "机密信息"
  }
};
const deviceTampered$5 = "您的BitBox是否已提供恢复密码？如果是这样，请停止设置过程并立即与支持人员联系。 Shift公司绝不会为您提供现成的钱包密码或提供密码建议。";
const dialog$6 = {
  cancel: "取消",
  confirm: "确认"
};
const fiat$7 = {
  "default": "默认设置",
  setDefault: "将 {{code}} 设为默认",
  title: "货币(单位)"
};
const footer$7 = {
  appVersion: "App版本"
};
const genericError$5 = "发生错误。如果发现任何问题，请重新启动应用程序。";
const goal$5 = {
  buttons: {
    create: "创建一个新钱包",
    restore: "通过备份还原钱包"
  },
  paragraph: "请选择以下选项之一：",
  step: {
    "1": {
      title: "安全信息"
    },
    "2": {
      description: "设置设备密码",
      title: "设备"
    },
    "3-create": {
      description: "创建一个新钱包",
      title: "钱包"
    },
    "3-restore": {
      description: "从备份中",
      title: "恢复"
    },
    "4-create": {
      title: "摘要"
    },
    "4-restore": {
      title: "摘要"
    }
  }
};
const guide$6 = {
  accountDescription: {
    text: "您的帐户概览显示您的可用余额以及收款和付款记录。我们在“设置”中的指南中提供了有关每种帐户类型的更多说明。 ",
    title: "该页面向我显示了什么？"
  },
  accountFiat: {
    text: "是。单击任何行情自动切换法定货币。您可以在设置中更改货币列表。",
    title: "可以显示其他的兑换率吗？"
  },
  accountIncomingBalance: {
    text: "正在传入(的交易)汇总了转账给您的交易金额，但这些交易尚未得到网络的确认。",
    title: "正在传入(的交易)意味着什么？"
  },
  accountInfo: {
    xpub: {
      text: "扩展公钥是帐户中所有接收地址的根密钥。\n此处提供扩展公钥供高级用户使用，以及与watch-only(仅限查阅)类型的钱包进行互操作,例如Electrum或Sentinel。",
      title: "什么是扩展公钥？"
    }
  },
  accountRates: {
    text: "我们每分钟都会通过CoinGecko更新汇率。",
    title: "使用的哪种汇率？"
  },
  accountReload: {
    text: "不需要。您的交易信息会自动更新。",
    title: "我可以重新加载交易记录吗？"
  },
  accountSendDisabled: {
    text: "当余额超过零时，将激活“发送”按钮。",
    title: "我为什么不能进行发送 {{unit}}？"
  },
  accountTransactionAttributesBTC: {
    text: "虚拟大小：决定网络费用。如果虚拟大小小于实际大小，则可以成功节省费用。\n实际大小：底层区块链序列化时，实际交易的大小（以字节为单位），。\n重量：隔离见证（Segwit）引入的一种新指标，用于评估交易和区块大小。每个隔离见证字节计为1(个重量单位)，其他所有字节计为4(个重量单位)。因此区块实际大小的限制(上限)不再是一兆字节(1MB)，区块大小的限制(上限)是四百万个重量单位。",
    title: "关于Bitcoin比特币的具体交易细节？"
  },
  accountTransactionAttributesGeneric: {
    text: "确认：您的第一个交易广播尚未确认，直到矿工将其打包入一个区块中，然后再进行一个确认。网络上广播的每个区块都会为您的交易添加另一个确认。通常，商家和其他网络参与者只会用三到六个确认来结算交易。\n交易ID：可让您在区块浏览器中查找交易的唯一标识号。\n费用：网络向矿工支付交易费，以作为其将交易打包确认在他们开采的区块中的奖励。要了解更多信息，请单击发送按钮。",
    title: "交易明细中的信息有哪些？"
  },
  accountTransactionConfirmation: {
    text: "交易已广播到网络中，但尚未确认。",
    title: "什么是待处理交易？"
  },
  accountTransactionLabel: {
    text: "这是您接收到的数字货币的地址或向其发送数字货币的地址。",
    title: "每笔交易显示哪个地址？"
  },
  accountTransactionTime: {
    text: "区块链交易确认时间。",
    title: "显示的是什么时间？"
  },
  appendix: {
    link: "联系我们！",
    text: "另一个问题？"
  },
  backups: {
    check: {
      text: "“检查备份”可让您验证您是否有与当前钱包相对应的有效备份。它还可以用来验证您是否拥有(记得)正确的恢复密码。您可以检查您的主要恢复密码或隐藏恢复密码。",
      title: "什么是“检查备份”？"
    },
    encrypt: {
      text: "否，但是需要您的恢复密码才能从存储的种子中获取钱包。",
      title: "我可以加密备份吗？"
    },
    howOften: {
      text: "创建新钱包后会自动生成备份。仅当microSD卡丢失或损坏，或者要使用多个microSD卡作为备份时，才需要进行新备份。\n交易完成后，您无需创建新的备份。可以通过自动为您生成的单个备份重新创建所有交易数据。",
      title: "我必须多久备份一次？"
    },
    whatIsABackup: {
      text: "它是micro SD卡上种子副本。种子和您的恢复密码一起生成了您的钱包。",
      title: "什么是备份？"
    }
  },
  backupsBB02: {
    check: {
      text: "“检查备份”可验证您是否有与当前钱包相对应的有效备份。",
      title: "什么是“检查备份”？"
    },
    encrypt: {
      text: "否。请确保Micro SD卡安全，因为卡中包含未加密的种子，该种子用于恢复您的钱包。如果希望对种子进行密码保护，可以在“管理设备”下的高级设置中启用密语功能。",
      title: "我可以加密我的备份吗？"
    },
    whatIsABackup: {
      text: "它是microSD卡上种子的副本。",
      title: "什么是备份？"
    }
  },
  bitbox: {
    "2FA": {
      text: "启用2FA后，所有交易都必须在配对手机上获得批准才能发送资产。在内部，一个经过加密的一次性号码被发送到手机app中，并进行解密，在按下接受按钮时返回到BitBox中。此与设备的通信是通过配对期间建立于移动电话和此桌面应用程序之间的频道完成的。\n\n确保在启用2FA之前备份您的钱包并配对移动端app。一旦启用，micro SD插槽和移动端app配对将被禁用。可以通过重置BitBox来重新启用它们，该操作将位擦除设备。",
      title: "双因素授权（2FA）是如何工作的？"
    },
    disable2FA: {
      text: "为了禁用2FA功能，您需要重置BitBox，然后从其备份中重置钱包。请确保您仍然拥有带有备份的microSD卡，并且仍记得恢复密码。然后按“重置设备”。设置新的设备密码，然后选择“或还原备份”。从钱包中选择您已创建的备份，单击“还原”，然后输入创建钱包时使用的恢复密码。",
      title: "如何禁用两因素授权（2FA）？"
    },
    ejectBitbox: {
      text: "您可以随时拔出BitBox，而不必先退出它。",
      title: "如何弹出BitBox？"
    },
    ejectSD: {
      text: "只要您不在创建或还原备份的过程中，就可以随时从BitBox中取出microSD卡。",
      title: "如何弹出microSD卡？"
    },
    hiddenWallet: {
      text: '它是同一台设备上的第二个钱包，受不同的设备密码和恢复密码保护，您可以使用这些钱包进行"合理的可否认性plausible deniability"。普通和隐藏钱包都使用相同的备份种子，因此不需要其他备份。',
      title: "什么是隐藏钱包？"
    },
    legacyHiddenWallet: {
      text: "首先单击下面的按钮（如果使用主设备密码将BitBox解锁并禁用了2FA，则可使用该按钮），然后重新插入您的Bitbox并使用隐藏的设备密码将其解锁。",
      title: "如何访问legacy隐藏钱包？"
    },
    pairing: {
      text: "下载适用于iOS或Android的移动端app后，您可以扫描显示的二维码，从而在移动app和此应用程序之间建立安全通道。扫描后，请按照移动端app中的说明进行操作。",
      title: "如何与手机安全配对"
    }
  },
  receive: {
    address: {
      text: "您可以将该地址提供给其他人，以便他们向您发送数字货币。但请务必确认您发送了正确的地址。",
      title: "地址的用途是？"
    },
    addressChange: {
      text: "一旦(上一笔)交易完成后，一个新地址会自动添加到列表中，因此始终有20个地址从未收到过任何数字货币。",
      title: "地址何时更改？"
    },
    howVerify: {
      text: "对于BitBox01，单击左侧边栏中的BitBox图标，查看“配对”部分。该指南将进行更新，您可以进一步按照说明进行操作。\n对于BitBox02，您可以在发送/接收过程中直接在设备上验证地址。",
      title: "如何安全地验证地址？"
    },
    why20: {
      text: "在启动过程中，该app会通过您的种子生成的地址，以查看这些地址下是否已接收到过资金。由于该app可以生成几乎无限数量的地址，因此可能要花费数年才能确定(该种子下所有地址的)余​​额。为了限制此(无穷)搜索，它会在看到20个从未收到资金的地址后停止。这称为是“间隙限制gap limit”，而20是事实标准，尽管地址数量是任意多个的。而这20个地址是你可以进行选择使用的。",
      title: "为什么只有20个地址？"
    },
    whyMany: {
      text: "为了维护隐私和安全，切勿两次(重复)使用相同的地址。如果您已使用过某个地址，请单击向右箭头以获取新地址。您一次最多可以生成20个地址。将地址视为发票编号。所有地址都衍生自您唯一的备份种子。",
      title: "为什么有那么多地址？"
    },
    whyVerify: {
      text: "您不应该信任您的计算机来生成和显示真实地址。它的被攻击面很大，因此计算机相比硬件钱包更容易受到攻击。对于BitBox01，用于验证地址的按钮会将地址安全地发送到配对的手机，您还可以从该手机扫描并验证QR码。对于BitBox02，可以直接在BitBox02显示屏上验证地址。",
      title: "为什么我需要对地址进行安全验证？"
    }
  },
  send: {
    fee: {
      text: "收取费用(的计算)基于交易数据大小而不是交易金额。费用标准是由Bitcoin Core的费用估算算法针对您选择的每个网络优先级计算的。如果它们的值与下面的标准值不同，则会显示它们。\n经济：24个区块（比特币大约需4小时，莱特币大约需1小时）\n低：12个区块（比特币大约需2小时，莱特币大约需30分钟）\n一般/普通：6个区块（比特币大约需1小时，莱特币大约需15分钟）\n高：2个区块（比特币大约需20分钟，莱特币大约需5分钟）\n（一个区块平均需要十分钟才能被挖出（在莱特币中为2.5分钟），在上述期间网络负载可能会有很大差异。）",
      title: "费用如何确定？"
    },
    priority: {
      text: "您愿意支付的费用越高，网络通常会更快地确认您的交易。",
      title: "网络优先级是什么？"
    },
    revert: {
      text: "一旦交易被签名并发送（即广播到网络中）后，就无法再恢复(回撤)。进行签名前请务必确认交易的正确性（包括费用）！\n如果您认识收币人，并且他或她愿意将相同的金额（减去交易费用）退还给您，则可以向他们发送新的收币地址。",
      title: "我可以逆转一个交易吗？"
    },
    whyFee: {
      text: "交易正在争夺矿工的确认。矿工根据其费用(高低)选择要打包进区块链中的交易。\n矿工对交易历史进行投票。由于没有可信赖的第三方强制每人投票（这是区块链的重点），矿工通过牺牲诸如计算能力之类的昂贵资源来对交易进行投票。作为对他们工作的奖励，他们可以获得新区块产生时的奖励币以及区块中打包确认的所有交易的交易费。",
      title: "为什么要收取网络费？"
    }
  },
  "settings-electrum": {
    what: {
      text: "可以使用您自己的全节点为你的钱包提供支持，而无需使用Shift公司的服务器。",
      title: "这是什么？"
    }
  },
  settings: {
    servers: {
      text: "该app与Shift Crypto服务器进行通信，以检查更新，加载交易并将信息发送到配对的移动端apps。\n该app还从CoinGecko检索最新汇率。所有转换都是在本地计算的，这意味着不会传输有关交易金额的任何数据。\n注意：对于以太坊和ERC20代币，我们使用Etherscan.io API。",
      title: "该app与哪些服务器通信？"
    }
  },
  title: "指南",
  toggle: {
    close: "关闭指南",
    open: "指南"
  },
  unlock: {
    forgotDevicePassword: {
      text: "您必须使用恢复密码来重置设备并通过备份还原钱包。",
      title: "如果忘记了设备密码，我该怎么办？"
    },
    reset: {
      text: "输入错误的设备密码15次。最后几次尝试需要长时间触摸设备。",
      title: "如何重置设备？"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "设备插入后应闪烁一次。确保将其正确插入。如果您遇到问题，请通过以下链接与我们联系。",
      title: "我的BitBox01无法识别"
    },
    getDevice: {
      link: {
        text: "订购一个BitBox"
      },
      text: "您可以在我们的网上商店购买BitBox：",
      title: "我如何获得设备？"
    },
    internet: {
      text: "是的，需要连接网络以同步钱包，发送交易并获取最新汇率。",
      title: "这个app需要连接网络吗？"
    },
    lostDevice: {
      link: {
        text: "备份中心"
      },
      text: "您可以在新的BitBox或通过我们的备份中心进行帐户恢复。",
      title: "我丢失了设备。怎么办？"
    },
    useWithoutDevice: {
      text: "不幸的是，目前尚无法实现。",
      title: "我可以在没有设备的情况下使用该app吗？"
    },
    welcome: {
      text: "感谢您使用由瑞士Shift Crypto公司开发的此应用程序。感谢您分享的任何意见。请使用底部的链接提供反馈。",
      title: "欢迎使用BitBoxApp！"
    }
  }
};
const headerssync$5 = {
  blocksSynced: "{{blocks}} 同步区块"
};
const hiddenWallet$5 = {
  info1HTML: '出于"合理的可否认性plausible deniability"的目的，一个隐藏钱包可以根据 <strong>不同</strong> 设备密码+恢复密码的组合进行创建。',
  info2HTML: "设定与您的隐藏钱包相关联的设备密码和恢复密码。设备密码和恢复密码必须与您的主钱包密码 <strong>不同</strong> 。",
  passwordLabel: "隐藏恢复密码",
  passwordPlaceholder: "请确认隐藏的恢复密码",
  pinLabel: "隐藏设备密码",
  pinRepeatLabel: "重复隐藏设备的密码",
  pinRepeatPlaceholder: "请确认隐藏设备的密码",
  success: "隐藏钱包创建成功。重新插入您的BitBox以解锁。"
};
const initialize$5 = {
  create: "设置设备密码",
  creating: "设置设备密码中...",
  error: {
    e102: "设备密码必须至少包含4个字符。"
  },
  info: {
    description1: "选择您的设备密码。这将用于解锁您的BitBox。",
    description2: "您可以使用数字，字母 & 符号。更长密码可以提供更高的安全性",
    description3: "如果您丢失了设备密码，则必须重置设备并还原钱包备份。",
    subtitle: "现在，您将设置设备密码",
    title: "初始化你的设备"
  },
  input: {
    label: "设备密码",
    labelRepeat: "重复设备密码",
    placeholderRepeat: "请确认设备密码"
  }
};
const invalidFormat$5 = "无效的格式";
const language$6 = {
  title: "选择语言"
};
const legacyhiddenwallet$5 = {
  disable: "禁用legacy隐藏钱包",
  enable: "启用Legacy隐藏钱包",
  successDisable: "已成功禁用legacy隐藏钱包。",
  successEnable: "成功启用legacy隐藏钱包。重新插入您的BitBox并输入隐藏的设备密码以访问legacy隐藏钱包。"
};
const loading$5 = "载入中...";
const notification$5 = {
  newTxs_one: "{{count}} 新交易： {{accountName}}",
  newTxs_other: "{{count}} 新交易： {{accountName}}"
};
const pairing$5 = {
  aborted: {
    text: "配对已在移动端app端中止。",
    title: "中止"
  },
  button: "配对移动端app",
  confirm: "您确定要配对BitBox吗？请注意配对完成后，需要通过手机进行交易操作。",
  connectOnly: {
    button: "连接移动端app",
    title: "选择菜单中“连接到新的桌面应用程序”，使用我们的移动端app移动应用程序进行扫描"
  },
  error: {
    text: "出现一些问题。请重新开始。",
    title: "错误"
  },
  reconnectOnly: {
    button: "重新连接移动端app"
  },
  start: {
    hideAppQRCode: "隐藏二维码",
    revealAppQRCode: "显示二维码",
    step1: "如果您没有移动端app，则可以根据你的手机型号扫描对应的Apple App Store或Google Play商店的二维码。",
    step2: "请使用我们的移动端app进行扫描，您可以在iOS和Android的应用程序商店中通过搜索“ Digital Bitbox 2FA”的名称找到该app："
  },
  started: {
    text: "现在，请按照移动端app上的说明进行操作。",
    title: "太棒了"
  },
  success: {
    text: "恭喜，您已成功将BitBox与移动端app配对！",
    title: "成功"
  },
  timeout: {
    text: "配对在两分钟后超时。如果您仍想配对移动端app，请重新开始。",
    title: "超时"
  },
  title: "手机配对"
};
const password$5 = {
  show: "显示 {{label}}",
  warning: {
    caps: "警告：大写锁定（⇪）已启用",
    paste: "粘贴文本，启用“显示 {{label}}”"
  }
};
const random$6 = {
  button: "生成随机序号",
  description: "您的BitBox产生了以下 {{bits}}位随机数："
};
const receive$7 = {
  label: "你的地址",
  onlyThisCoin: {
    description: "要接收其他代币，请先在设置中启用它们。否则如果您存入其他代币，则可能无法访问它们。",
    warning: "确保只在这个地址上接收 {{coinName}} 。"
  },
  showFull: "在设备上显示并验证完整的地址",
  title: "获取 {{accountName}}",
  verify: "安全验证地址",
  verifyBitBox01: "在移动端app上验证地址",
  verifyBitBox02: "请在BitBox02设备上的验证地址",
  verifyInstruction: "请确认以下地址与设备上显示的地址匹配。",
  warning: {
    secureOutput: "请将您的BitBox与您的移动设备配对以启用安全地址验证功能。再访问侧栏中的“管理设备”选项。"
  }
};
const reset$5 = {
  description: "设备上的所有数据将被删除。其中包括您的私钥！",
  notReset: "设备未重置。",
  title: "恢复出厂设置",
  understand: "我已有备份，并知道我的恢复密码",
  understandBB02: "我有一个有效的备份"
};
const securityInformation$5 = {
  create: {
    description1: "设置设备之前，建议您在安全的环境中进行设置。",
    description2: "系统将要求您创建两个密码。",
    description3: "首先是 <strong>设备密码</strong> 即可解锁您的BitBox设备，该密码以后可以进行更改。",
    description4: "第二个是 <strong>恢复密码</strong> 可以解锁您的钱包。此密码以后不能更改。",
    description5: "您创建的钱包将备份到所提供的microSD卡上的文件中。可以在紧急情况下使用您的 <strong>恢复密码</strong>。",
    title: "安全信息"
  },
  restore: {
    description1: "系统将要求您插入用于存储备份的microSD卡。",
    description2: "要恢复设备，您将需要使用恢复密码。 ",
    description3: "输入恢复密码时请小心。您输入的任何密码都会创建一个有效的钱包。如果输入错误的密码，可能会看到您不期望的钱包余额。",
    title: "安全信息"
  }
};
const seed$5 = {
  agreements: {
    "funds-access": "如果忘记了恢复密码，我将无法使用/取出我的资金",
    "password-change": "我以后无法更改恢复密码",
    "password-required": "需要恢复密码才能从备份中还原钱包"
  },
  create: "创建钱包",
  creating: "创建钱包中",
  description: "我理解：",
  error: {
    e102: "密码必须至少包含4个字符。",
    e200: "您需要在BitBox中插入microSD卡才能创建钱包，以此才能够进行备份的自动创建。"
  },
  info: {
    button: "立即设置恢复密码",
    description1: "将microSD卡插入BitBox",
    description2: "选择钱包的恢复密码，然后选择“立即设置恢复密码”",
    description3: "如果BitBox设备丢失或被盗，已进行备份的microSD卡和您的恢复密码是恢复资金的唯一方法。",
    description4: "在不转移资金的情况下您以后将无法更改恢复密码。",
    title: "创建一个新钱包"
  },
  password: {
    label: "找回密码",
    repeatPlaceholder: "重复恢复密码"
  },
  walletName: {
    label: "钱包名称"
  }
};
const seedRestore$5 = {
  error: {
    e200: "通过备份还原钱包需要用到microSD卡。"
  },
  info: {
    description1: "将microSD卡插入BitBox，然后单击“继续”",
    description2: "选择一个备份，然后单击“还原”",
    description3: "输入恢复密码",
    description4: "您需要确认你已了解到如果输入一个错误的密码，将创建另一个不同的钱包。",
    title: "如何通过备份还原钱包"
  }
};
const send$7 = {
  abort: "交易已被中止。",
  address: {
    label: "收款人地址",
    placeholder: "输入地址"
  },
  amount: {
    label: "金额",
    placeholder: "输入金额"
  },
  button: "签名并发送",
  coincontrol: {
    address: "地址",
    outpoint: "",
    title: "从输出发送"
  },
  confirm: {
    "selected-coins": "已选择的币种",
    title: "确认交易",
    total: "总计"
  },
  error: {
    insufficientFunds: "余额不足",
    invalidAddress: "无效地址",
    invalidAmount: "无效金额",
    invalidData: "无效数据"
  },
  fee: {
    customPlaceholder: "输入金额",
    label: "网络费",
    placeholder: "无法使用"
  },
  feeTarget: {
    description: {
      economy: "24个区块（Bitcoin比特币大约需4小时，Litecoin莱特币大约需1小时）",
      high: "2个区块（Bitcoin比特币大约需20分钟，Litecoin莱特币大约需5分钟）",
      low: "12个区块（Bitcoin比特币大约需2小时，Litecoin莱特币大约需30分钟）",
      normal: "6个区块（Bitcoin比特币大约需1小时，Litecoin莱特币大约需15分钟）"
    },
    estimate: "预计等待时间：",
    label: {
      economy: "经济",
      high: "高",
      low: "低",
      normal: "正常/普通"
    },
    placeholder: "正在进行费用估算…"
  },
  maximum: "发送全部",
  scanQR: "扫描二维码",
  signprogress: {
    description: "这是一个包含大量数据的交易。如要完成交易的完整签名过程，系统会要求您确认 {{steps}} 次。",
    label: "进展"
  },
  success: "交易已签名并完成发送。",
  title: "发送 {{accountName}}",
  toggleCoinControl: "切换coin控制"
};
const settings$6 = {
  electrum: {
    add: "添加服务器",
    "add-server": "添加",
    check: "校验",
    checkFailed: "失败",
    checkSuccess: "成功与 {{host}}建立连接",
    checking: "检查中",
    "download-cert": "下载远程证书",
    "remove-server": "删除",
    removeConfirm: "删除 {{server}}？",
    reset: "重置为默认值",
    resetConfirm: "是否要删除所有服务器并安装默认服务器？",
    servers: "服务器",
    step1: "1",
    "step1-text": "输入endpoint",
    step2: "2",
    "step2-text": "输入服务器证书链的证书。或者下载远程证书并进行视觉对比。",
    step3: "3",
    "step3-text": "检查连接并添加服务器。",
    step4: "4",
    "step4-text": "重启钱包。如果您不删除默认服务器，您自己的节点将被添加并被作为冗余处理",
    "title-btc": "Bitcoin Electrum服务器",
    "title-ltc": "Litecoin莱特币Electrum服务器",
    "title-tbtc": "Bitcoin测试网络Electrum服务器",
    "title-tltc": "Litecoin莱特币测试网Electrum服务器"
  },
  expert: {
    coinControl: "启用coin控制",
    electrum: {
      title: "连接您自己的全节点"
    },
    setProxyAddress: "设定代理地址",
    title: "高级/专业用户设置",
    useProxy: "启用tor代理"
  },
  header: {
    home: "主页"
  },
  restart: "请重新启动BitBoxApp，以使更改生效。",
  success: "请拔出并重新插入BitBox，以使更改生效。",
  title: "设置"
};
const setup$5 = "设置设备";
const sidebar$6 = {
  device: "管理设备",
  leave: "离开",
  settings: "设置"
};
const success$c = {
  create: {
    info1: "您的钱包已安全备份到microSD卡。取出microSD卡并安全保存。",
    info2: "您已经创建了一个安全的设备密码来解锁BitBox。",
    info3: "您已为钱包创建了安全的恢复密码，该密码可解锁资金并还原备份。",
    summary: "这是您已完成事项的摘要",
    title: "成功"
  },
  getstarted: "开始吧",
  restore: {
    summary: "您已成功从备份中还原了钱包。",
    title: "成功"
  }
};
const transaction$6 = {
  confirmation: "确认",
  explorer: "交易ID",
  explorerTitle: "在外部区块浏览器中打开",
  fee: "(交易)费用",
  fiatHistorical: "历史的",
  gas: "Gas",
  pending: "待处理的交易",
  size: "(区块)大小",
  vsize: "(区块)虚拟大小",
  weight: "(区块)重量"
};
const transactions$5 = {
  placeholder: "尚无交易记录"
};
const unknownError$5 = "出现未知错误： {{errorMessage}}";
const unlock$5 = {
  description: "输入您的设备密码以解锁设备",
  error: {
    e109_normal: "设备密码错误。 {{remainingAttempts}} 重设设备之前尝试会保留。",
    e109_touch: "$t(unlock.error.e109_normal）下次登录需要按住触摸按钮。",
    e113: "由于多次登录尝试，下次登录需要按住触摸按钮4秒钟。"
  },
  input: {
    label: "设备密码",
    placeholder: "输入设备密码以解锁设备"
  },
  unlocking: "解锁中..."
};
const upgradeFirmware$6 = {
  button: "升级固件",
  description: "您是否要将固件版本从 {{currentVersion}}升级至 {{newVersion}}？",
  label: "您的BitBox需要固件升级。",
  locked: "从 {{currentVersion}} 升级至 {{newVersion}}，请长按(触控边框)。",
  title: "升级固件",
  unlocked: "引导加载程序已解锁。要继续，请：",
  unlocked1: "拔下并重新插入您的Bitbox",
  unlocked2: "重新插入BitBox时，LED会亮起",
  unlocked3: "LED屏幕亮起时请轻触设备的触控边框"
};
const warning$b = {
  receivePairing: "请配对BitBox以启用安全地址验证。点击侧单栏中的“管理设备”。",
  sdcard: "除非要进行备份管理，否则请将microSD卡与BitBox设备分开存放。",
  sendPairing: "请配对BitBox以安全地验证交易详细信息。转到侧栏中的“管理设备”。"
};
const welcome$5 = {
  insertBitBox02: "如果是BitBox02设备，请点击设备以继续。",
  insertDevice: "请链接您的设备以开始进一步操作",
  title: "欢迎"
};
const appTranslationsZH = {
  account: account$5,
  accountInfo: accountInfo$5,
  accountSummary: accountSummary$5,
  addAccount: addAccount$6,
  app: app$5,
  backup: backup$5,
  bb02Bootloader: bb02Bootloader$5,
  bitbox: bitbox$5,
  bitbox02Interact: bitbox02Interact$5,
  bitbox02Settings: bitbox02Settings$5,
  bitbox02Wizard: bitbox02Wizard$5,
  blink: blink$5,
  bootloader: bootloader$5,
  button: button$a,
  changePin: changePin$5,
  checkSDcard: checkSDcard$5,
  clickHere: clickHere$5,
  confirm: confirm$7,
  confirmOnDevice: confirmOnDevice$5,
  device: device$5,
  deviceLock: deviceLock$5,
  deviceSettings: deviceSettings$5,
  deviceTampered: deviceTampered$5,
  dialog: dialog$6,
  fiat: fiat$7,
  footer: footer$7,
  genericError: genericError$5,
  goal: goal$5,
  guide: guide$6,
  headerssync: headerssync$5,
  hiddenWallet: hiddenWallet$5,
  initialize: initialize$5,
  invalidFormat: invalidFormat$5,
  language: language$6,
  legacyhiddenwallet: legacyhiddenwallet$5,
  loading: loading$5,
  notification: notification$5,
  pairing: pairing$5,
  password: password$5,
  random: random$6,
  receive: receive$7,
  reset: reset$5,
  securityInformation: securityInformation$5,
  seed: seed$5,
  seedRestore: seedRestore$5,
  send: send$7,
  settings: settings$6,
  setup: setup$5,
  sidebar: sidebar$6,
  success: success$c,
  transaction: transaction$6,
  transactions: transactions$5,
  unknownError: unknownError$5,
  unlock: unlock$5,
  upgradeFirmware: upgradeFirmware$6,
  warning: warning$b,
  welcome: welcome$5
};
const account$4 = {
  disconnect: "ارتباط از دست رفته تلاش مجدد ...",
  "export": "خروچی",
  exportTransactions: "خروجی گرفتن از تراکنش ها به صورت CSV و ذخیره در پوشه دانلود ها",
  fatalError: "خطای غیر منتظره.",
  incoming: "ورودی",
  initializing: "دریافت اطلاعات از بلاکچین ...",
  reconnecting: "ارتباط از دست رفته، تلاش برای اتصال مجدد ..."
};
const accountInfo$4 = {
  address: "آدرس",
  extendedPublicKey: "کلید عمومی گسترش یافته",
  label: "اطلاعات حساب",
  title: "اطلاعات حساب",
  verify: "تأیید در دستگاه"
};
const accountSummary$4 = {
  balance: "موجودی",
  exportSummary: "خروجی گرفتن از اطلاعات حساب در فولدر دانلودها به صورت CSV",
  fiatBalance: "موجودی به ارزهای رایج",
  name: "نام حساب",
  noAccount: "هیچ حسابی برای نمایش نیست.",
  title: "اطلاعات حساب ها",
  total: "مجموع"
};
const addAccount$5 = {
  title: "افزودن حساب"
};
const app$4 = {
  upgrade: "نسخه جدید برنامه موجود است. لطفا برنامه را از نسخه {{current}} به نسخه {{version}} ارتقا دهید."
};
const backup$4 = {
  check: {
    checking: "درحال بررسی پشتیبان...",
    confirmTitle: "بررسی پشتیبان",
    notOK: "پشتیبان با کیف پول فعلی منطبق نیست.",
    ok: "پشتیبان با کیف پول فعلی منطبق است",
    password: {
      label: "رمزعبور بازیابی",
      placeholder: "رمزعبور بازیابی",
      showLabel: "رمزعبور بازیابی"
    },
    success: "فایل پشتیبان با موفقیت تایید شد:",
    title: "بررسی پشتیبان"
  },
  create: {
    alreadyExists: "شما یک فایل پشتیبان دارید. آیا می خواهید دوباره ساخته شود؟",
    fail: "تهیه نسخه پشتیبان با مشکل روبرو شد!",
    info: "لطفا رمزعبور بازیابی کیف پول را برای تایید وارد نمایید",
    name: {
      label: "نام پشتیبان",
      placeholder: "لطفا نامی برای پشتیبان وارد کنید"
    },
    password: {
      label: "رمزعبور بازیابی",
      placeholder: "لطفا رمزعبور بازیابی را وارد نمایدد"
    },
    title: "ایجاد پشتیبان",
    verificationFailed: "رمزعبور پشتیبان با کیف پول فعلی متفاوت است. پشتیبان گیری انجام شد. لطفا از دکمه 'بررسی پشتیبان' برای تایید رمزعبور بازیابی استفاده نمایید."
  },
  description: "<strong>فایل پشتیبان کیف پول</strong>را انتخاب نمایید.",
  insert: "لطفا برای پشتیبان گیری، حافظه microSD را وارد نمایید",
  insertButton: "حافظه microSD را وارد کردم",
  list: "نسخه های پشتیبان شما در حافظه microSD",
  noBackups: "هیچ فایل پشتیبانی در حافظه میکرو SD وجود ندارد.",
  restore: {
    confirmTitle: "بازگرداندن پشتیبان",
    error: {
      e200: "حافظه microSD پیدا نشد."
    },
    password: {
      label: "رمزعبور بازیابی یا رمزعبور بازیابی مخفی",
      placeholder: "رمزعبور بازیابی",
      repeatPlaceholder: "تکرار رمزعبور بازیابی",
      showLabel: "رمزعبور بازیابی"
    },
    restoring: "بازگرداندن پشتیبان ...",
    title: "بازیابی",
    understand: "من قبول می کنم رمزعبور بازیابی نادرست کیف پول متفاوتی ایجاد می کند"
  },
  showMnemonic: {
    description: "شما با حداکثر 24 کلمه مواجه می شوید که از پشتیبان شما دریافت شده است. آنها را روی کاغذ یادداشت نمایید.\n<strong>کلمات را به صورت دیجیتالی نگهداری نکنید. ویا از آنها عکس نگیرید</strong>\n<strong>کلمات را بلند نخوانید.</strong>\n<strong>این پشتیبان با رمز قفل نیست.</strong>\nبعد از آن از شما خواسته می شود هر کلمه را تایید نمایید.\n",
    title: "نمایش کلمات بازیابی"
  },
  title: "مدیریت پشتیبان ها"
};
const bb02Bootloader$4 = {
  abort: "بروزرسانی نکن – من را برگردان",
  advanced: {
    label: "تنظیمات پیشرفته",
    toggleShowFirmwareHash: "نمایش هش سیستم عامل هر بار هنگام روشن شدن"
  },
  flipscreen: "چرخش تصویر",
  orientation: "جهت تصویر اشتباه است؟",
  success: "بروزرسانی با موفقیت انجام شد! ادامه در {{rebootSeconds}} ثانیه..."
};
const bitbox$4 = {
  error: {
    e10000: "رمزعبور نادرست است.",
    e10001: "رمزعبور جایگزین نشد",
    e102: "رمزعبور حداقل باید ٨ کارکتر باشد",
    e112: "رمزعبور مخفی دستگاه نمی تواند با رمزعبور اصلی یکی باشد"
  }
};
const bitbox02Interact$4 = {
  followInstructions: "لطفا طبق دستورالعمل های نمایش داده شده در BitBox02 عمل کنید."
};
const bitbox02Settings$4 = {
  deviceName: {
    current: "نام دستگاه فعلی",
    input: "نام BitBox02",
    title: "تنظیم نام BitBo02"
  }
};
const bitbox02Wizard$4 = {
  attestationFailed: "تأیید دستگاه انجام نشد ، که می تواند به دلیل راه اندازی مجدد برنامه در حالی که دستگاه منتظر ورود کاربر بود ، انجام شود. لطفا دوباره وصل شوید و دوباره امتحان کنید.",
  backup: {
    point1: "یک فایل پشتیبان را از حافظه microSD انتخاب نمایید",
    point2: "یک رمزعبور برای دستگاه خود تعیین نمایید",
    restoreText: "خب ، بگذارید پشتیبان را برگردانیم!",
    text1: "عالی، رمزعبور BitBox02 شما تنظیم شد و کیف پول شما ساخته شد. حالا زمان این است که یک پشتیبان تهیه نمایید. لطفا بررسی کنید حافظه microSD شما در BitBo02 شما قرار دارد و ادامه دهید.",
    text2: "لطفا دستورعمل های نمایش داده شده در صفحه نمایش دستگاه خود برای تهیه پشتیبان را دنبال کنید.",
    text3: "بعد از تهیه پشتیبان، لطفا حافظه microSD را خارج کرده و در <strong>جای امن</strong> نگهداری کنید. اطلاعات microSD رمزنگاری نشده است.  هیچ وقت آن را در دستگاه دیگری جز BitBox02 خود نگذارید",
    userConfirmation1: "من باید اطلاعات پشتیبان خود را در محل امن نگهداری کنم.",
    userConfirmation2: "پشتیبان من رمزگذاری نشده است. هرکسی که به آن دسترسی داشته باشد می تواند به کیف پول من دسترسی داشته باشد.",
    userConfirmation3: "اگر من Bitbox02 خود را خراب یا گم کنم، تنها راه بازیابی پول خود ازطریق فایل پشتیابن من است.",
    userConfirmation4: "اگر من هم پشتیبان و هم BitBox02 خودم را خراب یا گم کنم پس پول های من برای همیشه گم می شوند"
  },
  create: {
    button: "نام گذاری دستگاه و ادامه",
    info: "در اینجا اصول اولیه ای که برای راه اندازی BitBox خود انجام می دهید نمایش داده شده است: ",
    inputTitle: "نام کیف پول",
    point1: "نام گذاری دستگاه",
    point2: "تنظیم رمزعبور برای دستگاه خود",
    point3: "تهیه پشتیبان",
    text: "خب ، بیایید یک کیف پول جدید ایجاد کنیم!"
  },
  initialize: {
    passwordText: "اکنون یک رمزعبور برای دستگاه خود تنظیم کنید. برای وارد کردن و انتخاب رمزعبور از کنترل های موجود در BitBox خود استفاده کنید.",
    passwordTitle: "تنظیم رمزعبور برای BitBox خود",
    text: "با موفقیت BitBox02 شما متصل شد! اکنون بیایید دستگاه خود را راه اندازی کنیم. با انتخاب ایجاد کیف پول جدید یا بازگرداندن کیف پول از یک نسخه پشتیبان موجود شروع کنید.  لطفاً اطمینان حاصل کنید که یک کارت microSD در BitBox02 خود وارد شده است",
    tip: "توصیه می کنیم در یک محیط امن پیش بروید.",
    title: "راه اندازی BitBox خود"
  },
  insertSDCard: "<strong>لطفاً اطمینان حاصل کنید که یک حافظه microSD در BitBox02 خود قرار دارد.</strong>",
  pairing: {
    failed: "اتصال تایید نشده. لطفا BitBox02 خود را مجددا مصل کنید.",
    paired: "شما بر روی دستگاه خود تأیید کرده اید که کد مطابقت دارد. اگر این صحیح است ، می توانید با کلیک روی دکمه زیر ادامه دهید.",
    title: "کد اتصال را تأیید کنید",
    unpaired: "BitBox02 جدید شناسایی شده است. لطفاً تأیید کنید که کد زیر مطابق با آنچه در دستگاه شما نشان داده شده است مطابقت دارد. اگر کد مطابقت دارد ، زیر علامت تیک در BitBox02 خود را لمس کنید و سپس برای ادامه بر روی دکمه زیر کلیک کنید."
  },
  restoreFromMnemonic: {
    failed: "بازیابی با کلمات بازیابی انجام نشد، لطفاً دوباره امتحان کنید."
  },
  stepBackup: {
    beforeProceed: "قبل از اقدام ، لطفاً این ملاحظات امنیتی مهم را بخوانید:",
    createBackup: "اکنون یک پشتیبان در کارت microSD خود ایجاد خواهید کرد."
  },
  stepBackupSuccess: {
    fundsSafe: "برای تأمین امنیت بودجه خود ، موارد زیر را بخاطر بسپار:",
    title: "پشتیبان گیری بازیابی شد"
  },
  stepConnected: {
    unlock: "رمزعبور BitBox02 را برای باز کردن قفل وارد کنید."
  },
  stepCreate: {
    nameLabel: "نام BitBox02",
    namePlaceholder: "BitBox02 من",
    title: "نام BitBox02 را انتخاب کنید",
    toastMicroSD: "لطفاً اطمینان حاصل کنید که کارت microSD شما در BitBox02 قرار دارد."
  },
  stepCreateSuccess: {
    removeMicroSD: "لطفاً کارت microSD را از BitBox02 خود جدا کرده و آن را در یک مکان امن نگهداری کنید.",
    success: "نسخه پشتیبان خود را با موفقیت ایجاد کرده اید."
  },
  stepPassword: {
    title: "رمزعبور BitBox02 را تنظیم کنید",
    useControls: "برای تنظیم رمزعبور از کنترل های موجود در BitBox02 استفاده کنید."
  },
  stepUninitialized: {
    create: "می خواهم یک BitBox02 جدید را تنظیم کنم.",
    restore: "می خواهم کیف پول خود را از یک نسخه پشتیبان بازیابی کنم.",
    restoreMicroSD: "بازیابی از حافظه microSD",
    restoreMnemonic: "بازیابی با کلمات بازیابی",
    title: "BitBox02 خود را تنظیم کنید"
  },
  success: {
    text: "هورا! اکنون BitBox02 شما آماده استفاده است.\n\nبرای کسب اطلاعات بیشتر در مورد نحوه استفاده از BitBoxApp ، لطفاً با کلیک روی علامت سؤال در گوشه بالا سمت راست ، از راهنمای برنامه استفاده کنید.",
    title: "شما آماده رفتن هستید!"
  }
};
const blink$4 = {
  button: "چشمک زدن"
};
const bootloader$4 = {
  button: "بروزرسانی سیستم عامل",
  progress: "بروزرسانی: {{progress}}%",
  success: "ارتقا موفقیت آمیز بود! لطفا دستگاه را دوباره متصل نمایید. این بار، دکمه را لمس نکنید."
};
const button$9 = {
  abort: "لغو",
  back: "بازگشت",
  changepin: "تغيير رمزعبور دستگاه",
  check: "بررسی پشتیبان",
  "continue": "ادامه",
  copy: "کپی",
  create: "ایجاد",
  download: "دانلود",
  hiddenwallet: "ساخت کیف پول مخفی",
  next: "بعدي",
  ok: "تاييد",
  previous: "قبلي",
  receive: "دریافت",
  restore: "بازیابی",
  select: "انتخاب",
  send: "واریز",
  unlock: "باز کردن",
  update: "بروز رسانی",
  upgrade: "ارتقاء"
};
const changePin$4 = {
  newTitle: "رمزعبور جدید دستگاه",
  oldLabel: "رمزعبور فعلي دستگاه "
};
const checkSDcard$4 = "بررسی حافظه microSD";
const clickHere$4 = "اینجا کلیک کنید.";
const confirm$6 = {
  abortInfo: "ضربه بزنید تا",
  abortInfoRedText: "لغو",
  approveInfo: "4 ثانیه نگه دارید تا",
  approveInfoGreenText: "تاييد ",
  info: "روی BitBox",
  infoWhenPaired: "اول بر روی موبایل و سپس BitBox"
};
const confirmOnDevice$4 = "لطفاً بر روی دستگاه خود تأیید کنید.";
const device$4 = {
  appUpradeRequired: "BitBox شما با این برنامه سازگار نیست. لطفا آخرین نسخه را دانلود و نصب کنید."
};
const deviceLock$4 = {
  button: "فعال کردن تایید دو مرحله ای (2FA)",
  condition1: "آیا پشتیبان دارین؟",
  condition2: "آیا برنامه تایید موبایل کار می کند؟",
  condition3: "تایید دو مرحله ای پشتیبان و اتصال موبایل را خاموش می کند. دستگاه برای خروج از تایید 2 مرحله ای باید ریست شود.",
  confirm: "فعال کردن تایید دو مرحله ای (2FA)",
  title: "فعال کردن تایید دو مرحله ای (2FA)"
};
const deviceSettings$4 = {
  firmware: {
    newVersion: {
      label: "نسخه موجود"
    },
    title: "سیستم عامل",
    upToDate: "دستگاه شما بروز است",
    version: {
      label: "نسخه"
    }
  },
  hardware: {
    sdcard: {
      "false": "قرار ندارد",
      label: "حافظه microSD",
      "true": "قرار دارد"
    },
    title: "سخت افزار"
  },
  loading: "بازگرداندن اطلاعات دستگاه...",
  pairing: {
    lock: {
      "false": "خاموش",
      label: "تایید دو مرحله ای (2FA)",
      "true": "روشن"
    },
    mobile: {
      "false": "بسته شده",
      label: "برنامه موبایل",
      "true": "باز"
    },
    status: {
      "false": "متصل نشده",
      label: "وضعیت",
      "true": "متصل"
    },
    title: "اتصالات"
  },
  secrets: {
    manageBackups: "مدیریت پشتیبان ها",
    title: "اسرار"
  }
};
const deviceTampered$4 = "آیا BitBox شما دارای رمز بازیابی است؟ اگر هست، پروسه نصب را انجام نداده و سریعا با بخش پشتیبانی تماس بگیرید. Shift هرگز به شما کیف پول از قبل ساخته شده یا رمزعبور پیشنهادی نمی دهد";
const dialog$5 = {
  cancel: "لغو",
  confirm: "تایید"
};
const fiat$6 = {
  "default": "پیش فرض",
  setDefault: "{{code}} را به عنوان پیشفرض تنظیم کنید",
  title: "ارزها"
};
const footer$6 = {
  appVersion: "نسخه برنامه:"
};
const genericError$4 = "یک خطا رخ داده است اگر متوجه شدید، لطفا برنامه را مجددا راه اندازی کنید.";
const goal$4 = {
  buttons: {
    create: "یک کیف پول جدید ایجاد کنید",
    restore: "بازگرداندن کیف پول از پشتیبان"
  },
  paragraph: "لطفا یکی از گزینه های زیر را انتخاب کنید:",
  step: {
    "1": {
      title: "اطلاعات امنیتی"
    },
    "2": {
      description: "رمز عبور دستگاه را تنظیم کنید",
      title: "دستگاه"
    },
    "3-create": {
      description: "یک کیف پول جدید ایجاد کنید",
      title: "كيف پول"
    },
    "3-restore": {
      description: "از یک پشتیبان",
      title: "بازیابی"
    },
    "4-create": {
      title: "خلاصه"
    },
    "4-restore": {
      title: "خلاصه"
    }
  }
};
const guide$5 = {
  accountDescription: {
    text: 'نمای کلی حساب شما موجودی شما و همچنین معاملات ورودی و خروجی را نشان می دهد. راهنمای ما در "تنظیمات" درباره هر نوع حساب اطلاعات بیشتری دارد. ',
    title: "چه چیزی در این صفحه به من نمایش داده می شود؟"
  },
  accountFiat: {
    text: "بله، شما می توانید با کلیک کردن بر روی نام ارز رایج، ارز های رایج دیگر را ببینید و می توانید لیست ارز ها را در بخش تنظیمات تغییر دهید.",
    title: "آیا می توانم دیگر نرخ تبدیل را نمایش دهم؟"
  },
  accountIncomingBalance: {
    text: "دریافتی به جمع مقادیری که به شما منتقل می شود ولی هنوز توسط شبکه تایید نشده است می گویند.",
    title: "معنی دریافتی چیست؟"
  },
  accountInfo: {
    xpub: {
      text: "یک کلید عمومی گسترش یافته یک کلید ریشه است که از آن می توان تمام آدرس های دریافتی یک حساب را دریافت کرد.\nاین در اینجا برای استفاده پیشرفته و قابلیت همکاری با کیف پول نمایشی مانند Electrum یا Sentinel ارائه شده است.",
      title: "کلید عمومی گسترش یافته چیست؟"
    }
  },
  accountRates: {
    text: "",
    title: "کدام نرخ استفاده می شود؟"
  },
  accountReload: {
    text: "همه اطلاعات تراکنش به صورت خودکار بروز می شود.",
    title: "چگونه می توانم سابقه تراکنش را بروز کنم؟"
  },
  accountSendDisabled: {
    text: "دکمه «ارسال» هنگامی فعال می شود که موجودی شما بیش از صفر باشد.",
    title: "چرا نمی توانم هر مقدار {{unit}} را بفرستم؟"
  },
  accountTransactionAttributesBTC: {
    text: "اندازه مجازی: برای تعیین هزینه شبکه استفاده می شود. شما با موفقیت در هزینه صرفه جویی کردید اگر کوچکتر از اندازه تراکنش باشد.\nاندازه: حجم معامله واقعی در بایت زمانی که با توجه به بلوک های زیرزمینی سرویسی می شود.\nوزن: با Segwit معرفی شده است، این یک متریک جدید برای ارزیابی معامله و اندازه بلوک است. هر شهود جداگانه شمرده شده به عنوان یک، هر چیز دیگری به عنوان چهار وزن واحد. به جای یک مگابایت در اندازه واقعی، محدودیت اندازه بلوک در حال حاضر ٤ میلیون وزن واحد است.",
    title: "جزئیات معاملات بیت کوین خاص چیست؟"
  },
  accountTransactionAttributesGeneric: {
    text: "تأییدیه: هنگامی که تراکنش شما برای اولین بار پخش می شود، تأیید نخواهد شد. شما باید منتظر بمانید تا یک معدنچی به یک بلوک اضافه شود و پس از آن یک تایید داشته باشد. هر بلوک پخش شده در شبکه پس از آن تایید دیگری برای معامله شما خواهد بود. به طور کلی، بازرگانان و بازیگران شبکه دیگر تنها قبل از اینکه معامله را به عنوان معامله انجام دهند، معاملات را بین ٣-٦ تایید پذیرفته اند.\nشناسه تراکنش: یک شماره شناسایی منحصر به فرد است که می تواند برای جستجوی تراکنش در جستوجوگر بلوک استفاده شود.\nهزینه: استخراج کنندگان هزینه معامله را به عنوان یک انگیزه برای شامل معاملات در بلوک هایی که معدن دارند، پرداخت می کنند. برای کسب اطلاعات بیشتر، روی دکمه ارسال کلیک کنید.",
    title: "اطلاعاتی که در جزئیات تراکنش نشان داده شده است چیست؟"
  },
  accountTransactionConfirmation: {
    text: "این تراکنشی است که به شبکه فرستاده شده و منتظر تایید آن است.",
    title: "تراکنش ،در انتظار چیست؟"
  },
  accountTransactionLabel: {
    text: "این آدرس است که در آن سکه ها را دریافت کرده اید یا سکه ها را ارسال می کنید.",
    title: "کدام آدرس برای هر تراکنش نمایش داده می شود؟"
  },
  accountTransactionTime: {
    text: "زمانی که تراکنش در بلاکچین تایید شود.",
    title: "چه زمانی نمایش داده می شود؟"
  },
  appendix: {
    link: "ارتباط با ما",
    text: "سوال دیگر؟"
  },
  backups: {
    check: {
      text: "«بررسی پشتیبان» به شما اجازه می دهد تا مطمعن شوید که پشتیبان تهیه شده مربوط به کیف پول فعلی شما سالم است. همچنین می توانید رمزعبور بازیابی خود را بررسی کنید. شما می توانید رمزعبور بازیابی اصلی یا رمزعبور بازیابی مخفی خود را بررسی کنید.",
      title: '"بررسی پشتیبان" چیست؟'
    },
    encrypt: {
      text: "خیر، برای بازگرداندن کیف پول از کلمات ذخیره شده رمزعبور بازیابی شما احتیاج است.",
      title: "آیا می توانم پشتیبان را رمزگذاری کنم؟"
    },
    howOften: {
      text: "زمانی که کیف پول جدید ساخته می شود پشتیبان به صورت خودکار تولید می شود. شما فقط زمانی پشتیبان جدید تهیه می کنید اگر حافظه microSD را گم کرده باشید یا خراب شده باشد، یا اگر می خواهید بر روی حافظه های microSD متعدد پشتیبان داشته باشید.\nشما احتیاجی به پشتیبان گیری بعد از انجام معامله ندارید. همه اطلاعات معاملات شما می توانند با یک پشتیبان که به صورت خودکار برای شما تهیه شده بازگردانده شوند.",
      title: "چند بار باید یک نسخه پشتیبان تهیه کنم؟"
    },
    whatIsABackup: {
      text: "این یک نسخه از کلمات در کارت حافظه میکرو SD است. کلمات به همراه رمزعبور بازیابی کیف پول شما را ایجاد می کند.",
      title: "پشتیبان چیست؟"
    }
  },
  backupsBB02: {
    check: {
      text: '"بررسی نسخه پشتیبان" به شما امکان می دهد تا اطمینان حاصل کنید که یک نسخه پشتیبان مربوط به کیف پول فعلی خود دارید.',
      title: "'بررسی نسخه پشتیبان' چیست؟"
    },
    encrypt: {
      text: 'خیر.  لطفاً کارت حافظه microSD را ایمن نگه دارید ، زیرا شامل کلمات بازیابی رمزنگاری نشده برای بازیابی کیف پول شما است. اگر می خواهید با گذرواژه از کلمات بازیابی خود محافظت کنید ، می توانید یک عبارت عادی را در تنظیمات پیشرفته تحت "مدیریت دستگاه" فعال کنید.',
      title: "آیا می توانم نسخه پشتیبان را رمزگذاری کنم؟"
    },
    whatIsABackup: {
      text: "این یک کپی از کلمات بازیابی در کارت microSD است.",
      title: "نسخه پشتیبان چیست؟"
    }
  },
  bitbox: {
    "2FA": {
      text: "زمانی که تایید دو مرحله ای فعال است، برای خرج کردن سکه ها همه معاملات باید با موبایل متصل شده تایید شوند. در پشت برنامه، یک شماره یک بار مصرف قفل گذاری شده به موبایل ارسال می شود، قفل باز می شود، و زمانی که کلید قبول را می زنید شماره برای BitBox بر می گردد. این ارتباط با دستگاه از طریق کانال بین موبایل و این برنامه کامپیوتری درهنگام اتصال ایجاد شده انجام می شود.\n\nمطمئن شوید قبل از فعال کردن تایید 2 مرحله ای از کیف پول خود پشتیبان تهیه کنید و موبایل خود را متصل کنید. پس از فعال کردن حافظه میکرو SD و اتصال برنامه موبایل غیر فعال  می شود. آنها با بازنشانی BitBox که دستگاه را پاک می کند، می تواند دوباره فعال شود.",
      title: "تایید دو مرحله ای (2ّFA) چگونه کار می کند؟"
    },
    disable2FA: {
      text: 'برای غیر فعال کردن تایید دو مرحله ای، شما نیاز به بازنشانی BitBox خود و سپس بازگرداندن کیف پول از پشتیبان. اطمینان حاصل نمایید که در حافظه میکرو SD پشتیبان داشته باشیدو همچنان رمز عبور بازیابی را به یاد داشته باشید. سپس "بازنشانی دستگاه" را فشار دهید. رمز عبور جدید دستگاه را وارد نمایید و گزینه  "یا بازگرداندن پشتیبان" را انتخاب کنید. پشتیبان کیف پول را انتخاب کنید، "بازگرداندن" را کلیک کنید و رمز عبور بازگرداندن که زمان ساخت کیف پول وارد کردید را وارد کنید.',
      title: "چگونه می توانم تایید دو مرحله ای را خاموش کنم؟"
    },
    ejectBitbox: {
      text: "شما می توانید BitBox را در هر زمان بدون نیاز به اولیای خود بکشید.",
      title: "چگونه می توانم BitBox را جدا کنم؟"
    },
    ejectSD: {
      text: "شما می توانید کارت microSD را از BitBox در هر زمانی که شما در حال ایجاد یا بازگرداندن پشتیبان نیستید حذف کنید.",
      title: "چگونه می توانم کارت microSD را حذف کنم؟"
    },
    hiddenWallet: {
      text: "این یک کیف پول دوم در همان دستگاه محافظت شده با یک رمز عبور دستگاه دیگر و بازیابی رمز عبور است که شما می توانید برای واکنش قابل اعتماد استفاده کنید. همان بوت پشتیبان برای هر دو کیف پول عادی و پنهان شما استفاده می شود، بنابراین هیچ پشتیبان اضافی لازم نیست.",
      title: "کیف پول مخفی چیست؟"
    },
    legacyHiddenWallet: {
      text: "اول باید روی دکمه زیر کلیک کنید (در صورتی دکمه فعال است که BitBox با رمزعبور اصلی دستگاه باز باشد و تایید دو مرحله ای غیر فعال باشد، فعال است)، سپس BitBox را دوباره متصل کنید و با رمزعبور مخفی دستگاه باز نمایید.",
      title: "چگونه می توانم به کیف پول legacy مخفی دسترسی داشته باشم؟"
    },
    pairing: {
      text: "بعد از نصب برنامه موبایل ما برای IOS یا Android، شما کد QR نمایش داده شده را اسکن می کنید. که اتصال امن بین برنامه موبایل و این برنامه ایجاد می کند. پس از اسکن، دستورالعمل های برنامه موبایل را دنبال کنید.",
      title: "چگونه اتصال امن با موبایل خود داشته باشید"
    }
  },
  receive: {
    address: {
      text: "آدرس را به دیگران بدهید تا به شما مقداری سکه بدهند. فقط مطمئن شوید ادرس را به درستی ارسال می کنید.",
      title: "با یک آدرس چه کار کنم؟"
    },
    addressChange: {
      text: "به محض اینکه یک آدرس در یک تراکنش استفاده می شود، آدرس جدید به لیست اضافه می شود تا آن را جایگزین کند. همیشه ٢٠ آدرس استفاده نشده موجود در لیست وجود دارد.",
      title: "چه وقت آدرس تغییر می کند؟"
    },
    howVerify: {
      text: "برای BitBox01، روی آیکون BitBox در نوار کناری سمت چپ کلیک کنید و بخش جفت شدن را ببینید. راهنمای به روز می شود و شما می توانید به دنبال دستورالعمل ها از آنجا ادامه دهید.\nبرای BitBox02، شما می توانید آدرس ها را بصورت مستقیم بر روی دستگاه هنگام دریافت و ارسال تایید کنید.",
      title: "چگونه می توانم یک آدرس را به صورت ایمن تأیید کنم؟"
    },
    why20: {
      text: 'در هنگام راه اندازی برنامه آدرس هایی را که از دانه شما گرفته می شود ، ایجاد می کند تا ببیند که آیا تراکنش دریافت کرده اند یا خیر. از آنجا که برنامه می تواند تعداد نامحدودی آدرس را ایجاد می کند ، می تواند سالها برای تعیین موجودی زمان صرف کند. برای محدود کردن این جستجو ، پس از مشاهده 20 نشانی که هرگز تراکنش دریافت نکرده اند ، متوقف می شود. این "حد فاصله" است و 20 استاندارد بالفعل است که هر چند تعداد دلخواه است. این 20 نشانی است که می توانید انتخاب کنید.',
      title: "چرا فقط 20 آدرس؟"
    },
    whyMany: {
      text: "برای حفظ حریم خصوصی و امنیت، شما نباید از یک آدرس دو بار استفاده نمایید. بر روی فلش سمت راست کلیک کنید تا آدرس جدید برای هدف دیگری بگیرید. شما می توانید ٢٠ آدرس در  لحظه بسازید. آدرس ها را مانند شماره فاکتور در نظر بگیرید. همه آدرس ها از seed پشتیبان شما تهیه شده اند.",
      title: "چرا آدرس های زیادی وجود دارد؟"
    },
    whyVerify: {
      text: "یکی از دلایل خرید کیف پول سخت افزاری مانند BitBox این است که شما نباید به دلیل سطح حمله بزرگ خود به کامپیوتر خود اعتماد کنید. در نتیجه، شما نباید به کامپیوتر خود اعتماد کنید تا آدرس های معتبر تولید و نمایش داده شود. این دکمه برای تایید ایمن آدرس BitBox را مجبور به ارسال آدرس به تلفن همراه متصل شده می کند، که از آن شما می توانید کد QR را اسکن و تایید نمایید. برای BitBox02 آدرس می تواند تایید شود بر روی صفحه نمایش BitBox02",
      title: "چرا باید آدرس ایمن را تأیید کنم؟"
    }
  },
  send: {
    fee: {
      text: "هزینه براساس اندازه داده های تراکنش و نه مقدار آن است. اهداف هزینه توسط الگوریتم تخمین هزینه هسته Bitcoin برای هر اولویت شبکه ای که انتخاب کرده اید محاسبه می شود. آنها نشان داده شده اند اگر ارزش دیگری از هدف زیر داشته باشند.\nاقتصاد: ٢٤ بلوک (حدود ٤ ساعت برای Bitcoin، ١ ساعت برای Litecoin)\nکم: ١٢ بلوک (حدود ٢ ساعت برای Bitcoin، ٣٠ دقیقه برای Litecoin)\nعادی: ٦ بلوک (حدود ١ ساعت برای Bitcoin، ١٥ دقیقه برای Litecoin)\nبالا: ٢ بلوک (حدود ٢٠ دقیقه برای Bitcoin، ٥ دقیقه برای Litecoin)\n(یک بلاک برای Bitcoin به طور متوسط ١٠ دقیقه طول می کشد (٢.٥ دقیقه در Litecoin) برای استخراج و بار شبکه ممکن است به طور قابل توجهی در دوره های بالا متفاوت باشد.)",
      title: "هزینه تراکنش چگونه تعیین می شود؟"
    },
    priority: {
      text: "هر چه هزینه بالاتری پرداخت کنید، معاملات شما توسط شبکه سریع تر تایید می شود.",
      title: "اولویت شبکه چیست؟"
    },
    revert: {
      text: "هنگامی که یک معامله امضا و ارسال می شود(یعنی در شبکه پخش می شود)، دیگر نمی توان برگرداند. قبل از امضای معامله با دقت معامله (حتی هزینه) را بررسی کنید.\nاگر می دانید گیرنده مایل به ارسال همان مقدار (منهی هزینه تراکنش) است، شما می توانید آدرس دریافت جدید به آنها بدهید.",
      title: "آیا می توانم تراکنش را بازگردانم؟"
    },
    whyFee: {
      text: "معاملات در حال رقابت برای تایید شدن توسط ماینر ها هستند. ماینرها معاملات را براساس هزینه آنها انتخاب می کنند تا در بلاکچین قرار بگیرند.\nماینرها براساس تاریخچه معاملات رای می دهند. از آنجایی که هیچ شخص سومقابل اعتمادی برای اجرای یک رای برای هر نفر (که پایه و اساس بلاک چین ها است) وجود ندارد، ماینرها با به خطر انداختن منابع هزینه ای مانند قدرت محاسبات، به معاملات رای میدهند. به عنوان پاداش کار خود، آنها می توانند سکه های تازه ایجاد شده و هزینه تمام معاملات موجود را دریافت کنند.",
      title: "چرا هزینه ی شبکه وجود دارد؟"
    }
  },
  "settings-electrum": {
    what: {
      text: "به جای استفاده از سرورهای Shift، ممکن است کیف پول خود را با کد های کامل خود فعال کنید.",
      title: "این چیه؟"
    }
  },
  settings: {
    servers: {
      text: "این برنامه با سرورهای Shift Crypto برای برسی بروزرسانی، دریافت معملات و ارسال اطلاعات به برنامه موبایل متصل شده در ارتباط است. علاوه بر این آخرین نرخ ارز تبدیل را از سابت CoinGecko دریافت می کند. (تبدیل به صورت محلی محاسبه می شود، هیچ مبلغی از شما ارسال نمی شود.)\nتوجه: برای توکن های Ethereum و ERC20 ، ما از API های Etherscan.io استفاده می کنیم.",
      title: "کدام سرور با این برنامه صحبت می کند؟"
    }
  },
  title: "راهنما",
  toggle: {
    close: "بستن راهنما",
    open: "راهنما"
  },
  unlock: {
    forgotDevicePassword: {
      text: "شما باید دستگاه را بازنشانی کنید و کیف پول را با استفاده از رمزعبور بازیابی بازگردانید.",
      title: "اگر رمز عبور دستگاه را فراموش کرده ام چه کاری انجام دهم؟"
    },
    reset: {
      text: "رمز عبور دستگاه اشتباه را ١٥ بار وارد کنید چندین تلاش اخیر نیاز به لمس طولانی در دستگاه دارد.",
      title: "چگونه دستگاه را بازنشانی کنم؟"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "چراغ دستگاه در زمان اتصال باید یک بار چشمک بزن. اطمینان حاصل فرمایید که دستگاه از راه درست وارد شده است. اگر شما با مشکل روبرو شدید، لطفا از طریق لینک زیر با ما در ارتباط باشید.",
      title: "BitBox01 من شناسایی نشده است"
    },
    getDevice: {
      link: {
        text: "سفارش BitBox"
      },
      text: "شما می توانید BitBox را در فروشگاه آنلاین ما خریداری کنید:",
      title: "چگونه مي توانم يك دستگاه بگيرم؟"
    },
    internet: {
      text: "بله، اتصال اینترنت برای همگام سازی کیف پول لازم است، ارسال معاملات و بازیابی آخرین نرخ ارز.",
      title: "آيا اين برنامه به اينترنت نياز دارد؟"
    },
    lostDevice: {
      link: {
        text: "مرکز پشتیبان گیری"
      },
      text: "شما می توانید حساب های خود را در BitBox جدید یا مرکز پشتیبان گیری خود بازیابی کنید.",
      title: "دستگاه خود را از دست دادم حالا چی؟"
    },
    useWithoutDevice: {
      text: "متأسفانه این هنوز در حال حاضر امکان پذیر نیست.",
      title: "آيا مي توانم  اين برنامه را بدون دستگاه استفاده كنم؟"
    },
    welcome: {
      text: "با تشکر از استفاده شما از این برنامه، که توسط Shift Crypto واقع در سویس، ساخته شده است. این هنوز نسخه بتا است و بابت هر نظری که با ما به اشتراک می گذارید قدر دانیم. لطفا با استفاده از لینک زیر بازخورد خود را برای ما ارسال نمایید.",
      title: "به برنامه BitBox خوش آمدید!"
    }
  }
};
const headerssync$4 = {
  blocksSynced: "{{blocks}} بلوک همگام سازی شده است"
};
const hiddenWallet$4 = {
  info1HTML: "برای اهداف معتبر قابل اعتماد، یک کیف پول پنهان را می توان بر اساس یک رمز عبور دستگاه،  متفاوت  + رمز عبور بازیابی ترکیب کرد.",
  info2HTML: "رمزعبور دستگاه و رمزعبور بازیابی که شما می خواهید با کیف پول پنهان خود مرتبط کنید تعیین کنید. رمزعبور دستگاه و رمزعبور بازیابی باید <strong>متفاوت</strong> با مواردی باشد که برای کیف پول اصلی وارد کردید.",
  passwordLabel: "رمز عبور بازیابی پنهان",
  passwordPlaceholder: "لطفا رمز عبور بازیابی پنهان را تایید کنید",
  pinLabel: "رمز عبور دستگاه مخفی",
  pinRepeatLabel: "رمز عبور دستگاه پنهان را تکرار کنید",
  pinRepeatPlaceholder: "لطفا رمز عبور دستگاه مخفی را تأیید کنید",
  success: "کیف پول مخفی با موفقیت ایجاد شد BitBox خود را دوباره متصل کنید تا آن را باز کنید."
};
const initialize$4 = {
  create: "رمز عبور دستگاه را تنظیم کنید",
  creating: "تنظیم گذرواژه دستگاه ...",
  error: {
    e102: "گذرواژه دستگاه باید حداقل ٤ کاراکتر داشته باشد."
  },
  info: {
    description1: "گذرواژه دستگاهتان را انتخاب کنید این برای باز کردن BitBox شما مورد استفاده قرار می گیرد.",
    description2: "شما می توانید از اعداد، حروف استفاده کنید. رمزهای طولانی امنیت بیشتری دارد.",
    description3: "اگر گذرواژه دستگاه را از دست بدهید، مجبورید دستگاه خود را بازنشانی کنید و پشتیبانگیری کیف پول خود را بازگردانید.",
    subtitle: "اکنون رمز عبور دستگاه خود را تنظیم می کنید",
    title: "راه اندازی دستگاه"
  },
  input: {
    label: "گذرواژه دستگاه",
    labelRepeat: "رمز عبور دستگاه را تکرار کنید",
    placeholderRepeat: "لطفا گذرواژه دستگاه را تأیید کنید"
  }
};
const invalidFormat$4 = "فرمت نامعتبر";
const language$5 = {
  title: "زبان مورد نظر را انتخاب كنيد"
};
const legacyhiddenwallet$4 = {
  disable: "غیر فعال کردن کیف پول legacy مخفی",
  enable: "فعال کردن کیف پول legacy مخفی",
  successDisable: "با موفقیت کیف پول legacy مخفی غیر فعال شد",
  successEnable: "با موفقیت کیف پول legacy مخفی فعال شد. BitBox را دوباره متصل نمایید و رمز عبور مخفی دستگاه را برای دسترسی به کیف پول legacy مخفی وارد کنید."
};
const loading$4 = "در حال بارگذاری…";
const notification$4 = {
  newTxs_one: "{{count}} معاملات جدید در: {{accountName}}"
};
const pairing$4 = {
  aborted: {
    text: "اتصال توسط برنامه موبایل قطع شده است.",
    title: "لغو شد"
  },
  button: "اتصال به برنامه موبایل",
  confirm: "آیا مطمعن هستید که BitBox  خود را به تلفن همراه متصل نمایید؟ این را بدانید که بعدا شما تلفن همراه را برای تایید تراکنش احتیاج دارید",
  connectOnly: {
    button: "اتصال به برنامه موبایل",
    title: "با انتخاب گزینه «اتصال با برنامه کامپیوتری جدید» در منوی برنامه موبایلی ما اسکن نمایید."
  },
  error: {
    text: "چیزی اشتباه شد لطفا دوباره سعی کنید",
    title: "خطا"
  },
  reconnectOnly: {
    button: "اتصال مجدد با برنامه موبایل"
  },
  start: {
    hideAppQRCode: "مخفی کردن کد QR",
    revealAppQRCode: "نمایش کد QR",
    step1: "اگر شما برنامه تلفن همراه را ندارید، می توانید کد QR برای اپل App Store یا فروشگاه Google Play را بسته به کدام گوشی داشته باشید اسکن نمایید.",
    step2: 'اسکن با برنامه تلفن همراه ما، که شما می توانید تحت نام "Digital Bitbox 2FA" در فروشگاه برنامه برای iOS و Android پیدا کنید:'
  },
  started: {
    text: "لطفا اکنون دستورالعمل های برنامه موبایل را دنبال کنید.",
    title: "عالی"
  },
  success: {
    text: "تبریک می گوییم، شما با موفقیت BitBox خود را به برنامه موبایل متصل کردید!",
    title: "موفقیت"
  },
  timeout: {
    text: "متصل شدن پس از دو دقیقه به پایان رسید. اگر هنوز می خواهید برنامه موبایل را متصل کنید، دوباره سعی کنید.",
    title: "وقفه"
  },
  title: "اتصال تلفن همراه"
};
const password$4 = {
  show: "نمایش {{label}}",
  warning: {
    caps: "هشدار: کلید Caps lock (⇪) فعال است",
    paste: 'برای جاگذاری، "نمایش {{label}}" را فعال نمایید.'
  }
};
const random$5 = {
  button: "تولید شماره تصادفی",
  description: "BitBox شما این شماره {{bits}}-بیت زیر را تولید کرد:"
};
const receive$6 = {
  label: "آدرس شما",
  onlyThisCoin: {
    description: "برای دریافت توکن های دیگر ، آنها را در تنظیمات فعال کنید. اگر توکن های دیگری را به آنها واریز می کنید ، ممکن است در دسترس نباشند.",
    warning: "اطمینان حاصل فرمایید که فقط {{coinName}} را با این آدرس دریافت کنید."
  },
  showFull: "نمایش و تأیید آدرس کامل روی دستگاه",
  title: "دریافت {{accountName}}",
  verify: "تایید ایمن آدرس",
  verifyBitBox01: "آدرس را در برنامه تلفن همراه تأیید کنید",
  verifyBitBox02: "آدرس را در BitBox02 تأیید کنید",
  verifyInstruction: "لطفا بررسی کنید آدرس را با آدرس نمایش داده شده در موبایل شما یکی است.",
  warning: {
    secureOutput: "لطفا BitBox خود را با موبایل خود متصل کنید تا تایید ایمن آدرس فعال شود. از طریق نوار کناری به صفحه 'مدیریت دستگاه' بروید."
  }
};
const reset$4 = {
  description: "تمام داده ها در دستگاه حذف خواهند شد. این شامل کلید خصوصی شما می شود!",
  notReset: "تنظیم مجدد دستگاه انجام نمی شود.",
  title: "تنظیم مجدد دستگاه",
  understand: "من یک نسخه پشتیبان تهیه کرده ام و رمز عبور بازیابی را می دانم",
  understandBB02: "من یک پشتیبان معتبر دارم"
};
const securityInformation$4 = {
  create: {
    description1: "قبل از تنظیم دستگاه خود، توصیه می شود این کار را در یک محیط امن انجام دهید.",
    description2: "از شما خواسته می شود که دو کلمه عبور ایجاد کنید.",
    description3: "اولی  رمز عبور دستگاه  است که دستگاه BitBox شما را باز میکند و بعدا می توانید آن را تغییر دهید.",
    description4: "دومی  رمز عبور بازیابی است که قفل کیف پول را باز می کند. این رمزعبور بعدا قابل تغییر نیست",
    description5: "زمانی که کیف پول را می سازید، یک فایل پشتیبان در حافظه microSD ساخته می شود. این می تواند در شرایط اضطراری برای بازیابی کیف پول شما با استفاده از  رمزعبور بازیابی  شما استفاده شود.",
    title: "اطلاعات امنیتی"
  },
  restore: {
    description1: "از شما درخواست می شود که حافشه microSD که بر روی آن پشتیبان گیری کردید را قرار دهید.",
    description2: "برای بازگرداندن دستگاه شما به رمز عبور بازیابی نیاز خواهید داشت.",
    description3: "لطفا هنگام وارد کردن رمزعبور بازیابی مراقب باشید. هر مرزعبوری که وارد می کنید کیف پول معتبر ایجاد می کند. اگر شما رمزعبور اشتباه را وارد کردید ممکن است شما موجودی که انتظار ندارید را ببینید.",
    title: "اطلاعات امنیتی"
  }
};
const seed$4 = {
  agreements: {
    "funds-access": "اگر رمز عبور بازیابی را فراموش کرده ام، نمیتوانم به موجودی خود دسترسی پیدا کنم",
    "password-change": "نمیتوانم پسورد بازیابی را تغییر دهم",
    "password-required": "رمز عبور بازیابی برای بازگرداندن کیف پول از یک پشتیبان نیاز است"
  },
  create: "ایجاد کیف پول",
  creating: "درحال یجاد کیف پول",
  description: "من متوجه هستم:",
  error: {
    e102: "گذرواژه باید حداقل ٨ کاراکتر داشته باشد.",
    e200: "شما نیاز به قراردادن حافظه microSD در BitBox برای ساخت کیف پول دارید، تا بتواند به صورت خودکار پشتیبان گیری انجام شود."
  },
  info: {
    button: "تنظیم رمز بازیابی",
    description1: "حافظه microSD را داخل BitBox قرار دهید",
    description2: 'رمزعبور کیف پول را انتخاب نمایید و سپس "تنظیم رمز بازیابی" را انتخاب کنید.',
    description3: "پشتیبان گیری در حافظه microSD و رمزعبور بازیابی تنها راه برگرداندن حساب های خود در زمان گم کردن یا دزدیده شدن دستگاه BitBox است.",
    description4: "بعدا نمیتوانید رمزعبور بازیابی خود را بدون انتقال وجوه خود تغییر دهید.",
    title: "ساخت کیف پول جدید"
  },
  password: {
    label: "رمز عبور بازیابی",
    repeatPlaceholder: "رمز عبور بازیابی را تکرار کنید"
  },
  walletName: {
    label: "نام كيف پول"
  }
};
const seedRestore$4 = {
  error: {
    e200: "بازگرداندن کیف پول از یک پشتیبان نیاز به کارت microSD دارد."
  },
  info: {
    description1: "کارت microSD را داخل BitBox قرار دهید و روی «ادامه» کلیک کنید.",
    description2: 'یک نسخه پشتیبان را انتخاب کنید و روی "بازیابی" کلیک کنید',
    description3: "رمز عبور بازیابی را وارد کنید",
    description4: "شما باید تأیید کنید که رمز عبور اشتباه یک کیف پول متفاوت را ایجاد می کند.",
    title: "چگونه یک کیف پول را از یک نسخه پشتیبان تهیه کنید"
  }
};
const send$6 = {
  abort: "تراکنش لغو شد.",
  address: {
    label: "آدرس گیرنده",
    placeholder: "آدرس را وارد کنید"
  },
  amount: {
    label: "مقدار",
    placeholder: "مقدار را وارد کنید"
  },
  button: "امضا و ارسال",
  coincontrol: {
    address: "آدرس",
    outpoint: "ارزیابی",
    title: "ارسال از خروجی"
  },
  confirm: {
    "selected-coins": "سکه های انتخاب شده",
    title: "تأیید تراکنش",
    total: "جمع"
  },
  error: {
    insufficientFunds: "موجودی کافی نیست",
    invalidAddress: "آدرس نامعتبر",
    invalidAmount: "مبلغ نامعتبر",
    invalidData: "داده های نامعتبر"
  },
  fee: {
    customPlaceholder: "مقدار را وارد کنید",
    label: "هزینه شبکه",
    placeholder: "در دسترس نیست"
  },
  feeTarget: {
    description: {
      economy: "٢٤ بلوک (حدود ٤ ساعت برای Bitcoin، ١ ساعت برای Litecoin)",
      high: "٢ بلوک (حدود ٢٠ دقیقه برای Bitcoin، ٥ دقیقه برای Litecoin)",
      low: "١٢ بلوک (حدود ٢ ساعت برای Bitcoin، ٣٠ دقیقه برای Litecoin)",
      normal: "٦ بلوک (حدود ١ ساعت برای Bitcoin، ١٥ دقیقه برای Litecoin)"
    },
    estimate: "زمان انتظار تخمینی:",
    label: {
      economy: "اقتصاد",
      high: "زیاد",
      low: "کم",
      normal: "متوسط"
    },
    placeholder: "محاسبه تخمین هزینه ..."
  },
  maximum: "ارسال همه",
  scanQR: "اسکن کد QR",
  signprogress: {
    description: "این معامله ای است که حاوی اطلاعات زیادی است. برای به طور کامل امضا کردن معامله، از شما خواسته می شود {{steps}} بار تأیید شود.",
    label: "پیشرفت"
  },
  success: "معامله امضا و ارسال شد .",
  title: "ارسال {{accountName}}",
  toggleCoinControl: "کنترل سکه را تغییر دهید"
};
const settings$5 = {
  electrum: {
    add: "افزودن سرور",
    "add-server": "افزودن",
    check: "بررسی",
    checkFailed: "ناموفق",
    checkSuccess: "اتصال به {{host}} با موفقیت انجام شد.",
    checking: "بررسی",
    "download-cert": "دریافت گواهینامه از راه دور",
    "remove-server": "حذف",
    removeConfirm: "حذف {{server}}؟",
    reset: "تنظیم مجدد به حالت پیش فرض",
    resetConfirm: "آیا شما می خواهید همه سرور ها را حذف و سرور های پیشفرض نصب شوند؟",
    servers: "سرور ها",
    step1: "١",
    "step1-text": "نقطه پایانی را وارد کنید",
    step2: "٢",
    "step2-text": "یک گواهی از زنجیره گواهی سرور را وارد کنید. در کنار آن گواهی دسترسی از راه دور را دانلود کنید و چشمی مقایسه کنید.",
    step3: "٣",
    "step3-text": "اتصال را بررسی کنید و سرور را اضافه کنید.",
    step4: "٤",
    "step4-text": "راه اندازی مجدد کیف پول اگر شما سرورهای پیش فرض را حذف نکنید، گره مخصوص شما به عنوان افزونه افزوده خواهد شد.",
    "title-btc": "سرورهای Bitcoin Electrum",
    "title-ltc": "سرورهای Litecoin Electrum",
    "title-tbtc": "سرورهای تست Bitcoin Electrum ",
    "title-tltc": "سرورهای تست Litecoin Electrum "
  },
  expert: {
    coinControl: "کنترل سکه را فعال کنید",
    electrum: {
      title: "گره کامل خود را وصل کنید"
    },
    setProxyAddress: "آدرس پراکسی را تنظیم کنید",
    title: "تنظیمات پیشرفته",
    useProxy: "فعال کردن پراکسی Tor"
  },
  header: {
    home: "خانه"
  },
  restart: "لطفا برنامه BitBox را دوباره اجرا فرمایید تا تغییرات اجرا شون.",
  success: "لطفا BitBox را جدا کنید و متصل کنید تا تغییرات اعمال شوند.",
  title: "تنظیمات"
};
const setup$4 = "راه اندازی دستگاه";
const sidebar$5 = {
  device: "مدیریت دستگاه",
  leave: "ترک",
  settings: "تنظیمات"
};
const success$b = {
  create: {
    info1: "کیف پول شما در حافظه microSD با موفقیت پشتیبان گیری شد. آن را جدا کنید و در مکان امن نگهداری کنید.",
    info2: "شما یک رمزعبور امن دستگاه ایجاد کرده اید که BitBox را باز می کند.",
    info3: "شما رمزعبور بازیابی امن برای کیف پول خود را ایجاد کرده اید که حساب های خود را باز کرده و پشتیبان های خود را بازیابی کنید.",
    summary: "در اینجا خلاصه ای از آنچه شما انجام داده اید",
    title: "موفقیت"
  },
  getstarted: "شروع کنید",
  restore: {
    summary: "شما با موفقیت کیف پول را از پشتیبان بازگرداندید.",
    title: "موفقیت"
  }
};
const transaction$5 = {
  confirmation: "تاییدیه ها",
  explorer: "شماره تراکنش",
  explorerTitle: "باز کردن در جستجوگر بلوک خارجی",
  fee: "هزینه",
  fiatHistorical: "تاریخی",
  gas: "گاز",
  pending: "تراکنش در انتظار",
  size: "اندازه",
  vsize: "اندازه مجازی",
  weight: "وزن"
};
const transactions$4 = {
  placeholder: "هیچ تراکنشی وجود ندارد."
};
const unknownError$4 = "یک خطای ناشناخته رخ داده است: {{errorMessage}}";
const unlock$4 = {
  description: "رمزعبور دستگاه را وارد نمایید تا دستگاه باز شود.",
  error: {
    e109_normal: "رمزعبور دستگاه اشتباه است. {{remainingAttempts}} تلاش باقی مانده قبل از ریست شدن دستگاه.",
    e109_touch: "$t(unlock.error.e109_normal) ورود بعدی نیاز به نگه داشتن اثر انگشت می باشد",
    e113: "بدلیل ورود ها متداول، ورود بعدی نیاز به نگه داشتن دکمه اثر انگشت برای 4 ثانیه می باشد."
  },
  input: {
    label: "رمز دستگاه",
    placeholder: "براي باز كردن قفل دستگاه رمز دستگاه را وارد كنيد "
  },
  unlocking: "قفل در حال باز شدن است"
};
const upgradeFirmware$5 = {
  button: "ارتقاء سیستم عامل",
  description: "آیا می خواهید سیستم عامل از نسخه {{currentVersion}} به نسخه {{newVersion}} ارتقا یابد",
  label: "BitBox نیاز به ارتقا سیستم عامل دارد.",
  locked: "برای ارتقا از نسخه {{currentVersion}} به نسخه {{newVersion}}، لطفا دکمه لمسی را نگه دارید.",
  title: "ارتقا سیستم عامل",
  unlocked: "قفل bootloader باز شد. برای ادامه، لطفا :",
  unlocked1: "Bitbox را جدا کرده و دوباره وصل نمایید",
  unlocked2: "هنگامی که BitBox شما دوباره وصل می شود، LED روشن می شود",
  unlocked3: "هنگامی که چراغ ال ای دی روشن شد،روی دکمه لمسی ضربه بزنید"
};
const warning$a = {
  receivePairing: "لطفا BitBox را برای فعال کردن تأیید ایمن آدرس به گوشی خود متصل کنید. برای این کار به «مدیریت دستگاه» در نوار کناری بروید.",
  sdcard: "حافظه microSD را جدا از BitBox نگهداری کنید، مگر اینکه بخواهید مدیریت پشتیبان را انجام دهید.",
  sendPairing: "لطفا BitBox را برای تأیید ایمن جزئیات معامله جفت کنید. به «مدیریت دستگاه» در نوار کناری بروید"
};
const welcome$4 = {
  insertBitBox02: "برای ادامه BitBox02 ، لطفاً روی دستگاه ضربه بزنید.",
  insertDevice: "لطفا دستگاه خود را برای شروع وصل کنید",
  title: "خوش آمديد"
};
const appTranslationsFA = {
  account: account$4,
  accountInfo: accountInfo$4,
  accountSummary: accountSummary$4,
  addAccount: addAccount$5,
  app: app$4,
  backup: backup$4,
  bb02Bootloader: bb02Bootloader$4,
  bitbox: bitbox$4,
  bitbox02Interact: bitbox02Interact$4,
  bitbox02Settings: bitbox02Settings$4,
  bitbox02Wizard: bitbox02Wizard$4,
  blink: blink$4,
  bootloader: bootloader$4,
  button: button$9,
  changePin: changePin$4,
  checkSDcard: checkSDcard$4,
  clickHere: clickHere$4,
  confirm: confirm$6,
  confirmOnDevice: confirmOnDevice$4,
  device: device$4,
  deviceLock: deviceLock$4,
  deviceSettings: deviceSettings$4,
  deviceTampered: deviceTampered$4,
  dialog: dialog$5,
  fiat: fiat$6,
  footer: footer$6,
  genericError: genericError$4,
  goal: goal$4,
  guide: guide$5,
  headerssync: headerssync$4,
  hiddenWallet: hiddenWallet$4,
  initialize: initialize$4,
  invalidFormat: invalidFormat$4,
  language: language$5,
  legacyhiddenwallet: legacyhiddenwallet$4,
  loading: loading$4,
  notification: notification$4,
  pairing: pairing$4,
  password: password$4,
  random: random$5,
  receive: receive$6,
  reset: reset$4,
  securityInformation: securityInformation$4,
  seed: seed$4,
  seedRestore: seedRestore$4,
  send: send$6,
  settings: settings$5,
  setup: setup$4,
  sidebar: sidebar$5,
  success: success$b,
  transaction: transaction$5,
  transactions: transactions$4,
  unknownError: unknownError$4,
  unlock: unlock$4,
  upgradeFirmware: upgradeFirmware$5,
  warning: warning$a,
  welcome: welcome$4
};
const account$3 = {
  disconnect: "Conexión perdida. Reintentando... ",
  "export": "Exportar ",
  exportTransactions: "Exportar transacciones a la carpeta de descargas como archivo CSV",
  fatalError: "Ha habido un error inesperado.",
  incoming: "Entrante",
  initializing: "Obteniendo información de la blockchain ...",
  insuranceExpired: "<strong>Cuenta que ya no está asegurada</strong>\n\nEl plan de seguro de esta cuenta ha sido modificado.\nConsulta la página de seguros para obtener más información.",
  insured: "Cuenta asegurada",
  maybeProxyError: "Tor Proxy activado. Asegúrese de que su Tor proxy está funcionando correctamente, o desactive la configuración del proxy.",
  reconnecting: "Conexión perdida, reconectando...",
  syncedAddressesCount: "Escaneado {{count}} direcciones",
  uncoveredFunds: "Tiene monedas en los siguientes tipos de dirección no cubiertos de su  <strong>{{name}}</strong> cuenta: {{uncovered}}. Dado que la cuenta está asegurada, sólo las monedas recibidas a través del <strong> Segwit nativo </strong> están cubiertas. Las monedas con direcciones diferentes, aunque pertenezcan a la misma cuenta, no están aseguradas.\nPor favor, mueve todas tus monedas de los tipos de dirección no soportados al tipo de dirección <strong> Segwit nativo</strong>, para que todas tus monedas en esta cuenta estén aseguradas.",
  uncoveredFundsLink: "Sigue esta guía sobre cómo mover tus monedas.",
  warning: "¡Atención!"
};
const accountInfo$3 = {
  address: "Dirección",
  buyCTA: {
    buy: "Comprar {{unit}}",
    buyCrypto: "Comprar Crypto",
    information: {
      looksEmpty: "Parece que esta cartera está vacía.",
      start: "Comience depositando algunas monedas en la cartera o comprando directamente a través de la BitBoxApp."
    }
  },
  extendedPublicKey: "Clave pública extendida",
  label: "Información de la cuenta",
  scriptType: "Tipo de script",
  title: "Información de la cuenta",
  verify: "Verificar en el dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Ver clave pública extendida legacy P2PKH",
    p2tr: "Ver Taproot",
    p2wpkh: "Ver Native Segwit",
    "p2wpkh-p2sh": "Ver clave pública extendida antiguo Segwit"
  },
  xpubTypeInfo: "Actualmente mostrando {{scriptType}} clave pública extendida ({{current}} de {{numberOfXPubs}})"
};
const accountSummary$3 = {
  availableBalance: "Saldo disponible",
  balance: "Saldo",
  exportSummary: "Resumen de cuentas de exportación a la carpeta de descargas como archivo CSV",
  fiatBalance: "Saldo de Fiat",
  name: "Nombre de cuenta",
  noAccount: "No hay cuentas para mostrar.",
  subtotalWithCoinName: "Total ({{coinName}})",
  title: "Mi portfolio",
  total: "Total",
  transactionHistory: "Historial de operaciones"
};
const addAccount$4 = {
  chooseName: {
    nextButton: "Añadir cuenta",
    step: "Nombre de la cuenta",
    title: "Nombre de su cuenta"
  },
  selectCoin: {
    nextButton: "Siguiente",
    step: "Elija moneda",
    title: "Elija cryptomoneda"
  },
  success: {
    addAnotherAccount: "Añadir otra cuenta",
    message: "<strong>{{accountName}}</strong> ha sido ahora añadida a sus cuentas.",
    nextButton: "Hecho",
    step: "Finalizado",
    title: "Cuenta añadida"
  },
  title: "Añadir cuenta"
};
const aopp$2 = {
  addressRequest: "{{host}} está solicitando una dirección de recepción.",
  addressRequestWithLogo: "está solicitando una dirección de recepción",
  banner: "Solicitud de dirección en curso. Conecte su dispositivo para continuar.",
  errorTitle: "Error durante la solicitud de dirección",
  labelAddress: "Dirección",
  labelMessage: "Mensaje",
  reverifyInfoText: "Verifique la dirección",
  signing: "Para proceder, firme el mensaje en su BitBox02",
  success: {
    message: "Proceder con {{host}}",
    title: "Dirección enviada con éxito"
  },
  syncing: "Sincronizando la cuenta, por favor espere.",
  title: "Solicitud de dirección"
};
const app$3 = {
  upgrade: "Una nueva versión de esta aplicación está disponible! Por favor actualiza desde {{current}} a {{version}}."
};
const auth$3 = {
  authButton: "Autentificar",
  title: "Por favor, autentifíquese para continuar"
};
const backup$3 = {
  check: {
    checking: "Comprobando copia de seguridad ...",
    confirmTitle: "Comprobar la copia de seguridad",
    notOK: "Copia de seguridad NO coincide con el monedero.",
    ok: "Copia de seguridad coincide con el monedero.",
    password: {
      label: "Contraseña de recuperación",
      placeholder: "Contraseña de recuperación",
      showLabel: "contraseña de recuperación"
    },
    success: "Copia de seguridad verificada con éxito:",
    title: "Comprobar la copia de seguridad"
  },
  create: {
    alreadyExists: "Ya tienes una copia de seguridad válida. ¿Quieres volverla a crear?",
    fail: "La creación de la copia de seguridad ha FALLADO!",
    info: "Por favor ingresa la contraseña de recuperación del monedero actual para su verificación.",
    name: {
      label: "Nombre de la copia de seguridad",
      placeholder: "Por favor pon el nombre de la copia de seguridad"
    },
    password: {
      label: "Contraseña de recuperación",
      placeholder: "Por favor ingresa tu contraseña de recuperación"
    },
    title: "Crea copia de seguridad",
    verificationFailed: "La contraseña de recuperación NO COINCIDE con el monedero actual. La copia de seguridad ha sido creada. Por favor utiliza 'Comprueba copia de seguridad' para verificar tu contraseña de recuperación nuevamente."
  },
  description: "Selecciona <strong>archivo de copia de seguridad del monedero</strong>",
  insert: "Por favor, inserta la tarjeta micro SD para administrar las copias de seguridad.",
  insertButton: "He insertado la tarjeta micro SD",
  list: "Tus copias de seguridad en la microSD",
  noBackups: "No hay copias de seguridad en esta tarjeta microSD.",
  restore: {
    confirmTitle: "Recupera copia de seguridad",
    error: {
      e200: "Tarjeta SD no encontrada",
      general: "Error restaurando copia de seguridad"
    },
    password: {
      label: "Contraseña de recuperación o contraseña de recuperación oculta",
      placeholder: "Contraseña de recuperación",
      repeatPlaceholder: "Repita la contraseña de recuperación",
      showLabel: "Contraseña de recuperación"
    },
    restoring: "Restaurando copia de seguridad ...",
    selectedBackup: "<strong>{{backupName}}</strong> creada en {{createdDateTime}} será restaurada.",
    title: "Restaurar",
    understand: "Entiendo que una contraseña de recuperación incorrecta creará un monedero diferente"
  },
  showMnemonic: {
    description: "Se le presentarán sus palabras de recuperación, que constituyen una copia de seguridad de su cartera. Escríbalas en un papel..\n\n<strong>No las almacenes digitalmente ni le tomes fotos.</strong>\n\n<strong>No las diga en voz alta.</strong>\n\n<strong>Esta copia de seguridad no está protegida por una contraseña.</strong>\n\nA continuación, se le pedirá que confirme cada palabra. ",
    title: "Muestra las claves de recuperación",
    warning: "<strong>Nunca compartas tus palabras de recuperación con nadie.</strong> Tus palabras de recuperación dan acceso completo a tu billetera. Si alguien te pide tus palabras de recuperación, es un estafador, ¡no las compartas! "
  },
  title: "Administrar copias de seguridad"
};
const bb02Bootloader$3 = {
  abort: "No actualices - vuelve atrás",
  abort_noUpgrade: "Llévame atrás",
  advanced: {
    label: "Configuración avanzada",
    toggleShowFirmwareHash: "Mostrar el hash del firmware en cada inicio"
  },
  flipscreen: "Gira la foto en la pantalla",
  orientation: "¿Está el dispositivo orientado de manera incorrecta?",
  success: "Actualizado con éxito! Continuando en {{rebootSeconds}} segundos...",
  success_install: "¡Instalación satisfactoria! Continúa en {{rebootSeconds}} segundos..."
};
const bitbox$3 = {
  error: {
    e10000: "Contraseña del dispositivo actual incorrecta.",
    e10001: "Error al reemplazar la contraseña del dispositivo",
    e102: "La contraseña debe contener al menos 4 caracteres.",
    e112: "La contraseña oculta del dispositivo no puede ser la misma que la contraseña principal del dispositivo."
  }
};
const bitbox02Interact$3 = {
  confirmDate: "Confirma la fecha de hoy en tu BitBox02",
  confirmDateText: "Esta fecha se utilizará para crear tu copia de seguridad.",
  confirmName: "Confirma el nombre en tu BitBox02",
  confirmWords: "Escriba la {{amount}} de palabras recuperación de su BitBox02",
  confirmWordsText: "Después el BitBox02 te pedirá que confirmes cada palabra para verificar que la copia de seguridad es correcta.",
  followInstructions: "Por favor, sigue las instrucciones en tu BitBox02",
  followInstructionsMnemonic: "Sigue las instrucciones de tu BitBox02 para introducir las palabras de recuperación de tu copia de seguridad y restaurar tu billetera.",
  followInstructionsMnemonicTitle: "Restaurar desde las palabras de recuperación"
};
const bitbox02Settings$3 = {
  deviceName: {
    current: "Nombre del dispositivo actual",
    error: "No se ha podido establecer el nombre del dispositivo",
    error_104: "La confirmación del nombre del dispositivo fue abortada en el dispositivo.",
    input: "Nombre de la BitBox02",
    placeholder: "Nuevo nombre del dispositivo",
    title: "Establece el nombre de la BitBox02"
  },
  gotoStartupSettings: {
    description: "Esto reiniciará tu BitBox02 y entrará en la configuración de inicio.",
    title: "Ir a configuración de inicio"
  }
};
const bitbox02Wizard$3 = {
  advanced: {
    button: "Opciones avanzadas",
    outOfDate: "Firmware obsoleto para esta función",
    seed12WordInfo: "Tenga en cuenta que el número de palabras no se puede cambiar después de crear la billetera.",
    seed12WordLabel: "Crear semilla de 12 palabras en lugar de 24 palabras",
    seed12WordText: "Predeterminadamente, la BitBox02 utiliza una semilla de 24 palabras. Ambas longitudes de semilla son seguras contra la fuerza bruta en la práctica. Algunos usuarios pueden preferir la conveniencia de la semilla de 12 palabras.",
    skipSDCardLabel: "Omitir la copia de seguridad de la tarjeta microSD y escribir las palabras de recuperación en su lugar",
    skipSDCardText: "Siempre tienes la opción de crear una copia de seguridad de la tarjeta microSD o escribir tus palabras de recuperación después de la configuración. Esto se puede hacer desde los ajustes.",
    title: "Opciones avanzadas de copia de seguridad"
  },
  attestationFailed: "La comprobación genuina del dispositivo ha fallado, que puede ser debido al reinicio de la aplicación mientras el dispositivo estaba esperando la interacción por parte del usuario. Por favor conecte de nuevo y inténtelo otra vez. Por favor contacte con support@bitbox.swiss si el error persiste.",
  backup: {
    point1: "Selecciona una copia de seguridad de la tarjeta microSD",
    point2: "Establece una contraseña para su dispositivo",
    restoreText: "Ok, restablezcamos una copia de seguridad!",
    text1: "Genial, has establecido la contraseña de tu BitBox02 y tu billetera se ha creado. Ahora es momento de crear tu primera copia de seguridad (backup). Por favor asegúrate de que tu tarjeta microSD se haya introducido en tu BitBox02 y continua.",
    text2: "Por favor sigue las instrucciones que aparecen en la pantalla de tu dispositivo para crear la copia de seguridad. ",
    text3: "Después de que tu copia de seguridad se haya creado, por favor extrae la tarjeta microSD y guárdala en un <strong>lugar seguro</strong>. El contenido de la tarjeta microSD no está protegido con contraseña. Nunca la insertes en ningún otro dispositivo que no sea tu BitBox02. ",
    userConfirmation1: "Debo guardar mi copia de seguridad en un lugar seguro.",
    userConfirmation2: "Mi copia de seguridad no está protegida por contraseña. Cualquiera con acceso a ella tiene acceso a mi billetera.",
    userConfirmation3: "Si pierdo o daño mi BitBox02, la única forma de recuperar mis fondos es recuperar mi billetera desde mi copia de seguridad.",
    userConfirmation4: "En caso de perder o dañar tanto mi copia de seguridad como mi BitBox02, mis fondos se habrán perdido.",
    userConfirmation5: "No debería insertar mi copia de seguridad de la tarjeta microSD en el ordenador, teléfono, impresora o en ningún otro dispositivo que no sea BitBox02.",
    userConfirmation5mnemonic: "No debo poner mis palabras de recuperación en un computador, teléfono, impresora o cualquier otro dispositivo que no sea un BitBox02."
  },
  create: {
    button: "Dale un nombre al dispositivo y continua",
    info: "Aquí están los pasos básicos que seguirás para instalar tu BitBox:",
    inputTitle: "Nombre del monedero",
    point1: "Dale un nombre a tu dispositivo",
    point2: "Establece una contraseña para su dispositivo",
    point3: "Crea una copia de seguridad",
    text: "Ok, creemos un nueva billetera!"
  },
  createBackupAborted: "Creación de copia de seguridad abortada.",
  createBackupFailed: "Creación de copia de seguridad fallida, vuelve a intentarlo.",
  initialize: {
    passwordText: "Ahora establezcamos una contraseña para tu dispositivo. Utiliza los controles en tu BitBox para introducir y escoger una contraseña.",
    passwordTitle: "Establece una contraseña para tu BitBox",
    text: "Tu BitBox02 se ha conectado con éxito! Ahora vamos a iniciar tu dispositivo. Empecemos seleccionando crear una billetera nueva o restablecer una billetera desde una copia de seguridad existente.<strong>Por favor asegúrate de tener una tarjeta microSD introducida en tu BitBox02</strong>",
    tip: "Te recomendamos que continuas en un entorno seguro.",
    title: "Inicia tu BitBox"
  },
  insertSDCard: "<strong>Por favor asegúrate de haber introducido una tarjeta microSD en tu BitBox02.</strong>",
  noPasswordMatch: "Las contraseñas no coinciden, por favor, vuelve a intentarlo.",
  pairing: {
    failed: "Conexión no confirmada. Por favor vuelve a conectar tu BitBox02.",
    paired: "Has confirmado el siguiente código en tu dispositivo.  Por favor continua.",
    title: "Comprueba el código de conexión.",
    unpaired: "Se ha detectado un BitBox02 no emparejado. Verifique que el código de emparejamiento coincida con lo que se muestra en su BitBox02. "
  },
  restoreFromMnemonic: {
    e104: "Se canceló la restauración desde las palabras de recuperación.",
    failed: "El restablecimiento desde tu clave de recuperación ha fallado, por favor vuelve a intentarlo."
  },
  stepBackup: {
    beforeProceed: "Antes de continuar, por favor lee estas importantes consideraciones de seguridad:",
    createBackup: "Ahora crearás una copia de seguridad en tu tarjeta microSD.",
    createBackupMnemonic: "Ahora escribirás las palabras de recuperación."
  },
  stepBackupSuccess: {
    fundsSafe: "Para mantener seguros tus fondos, por favor recuerda lo siguiente:",
    title: "Copia de seguridad restablecida!"
  },
  stepConnected: {
    unlock: "Introduce la contraseña de tu BitBox02 para desbloquearla."
  },
  stepCreate: {
    description: "Este nombre es utilizado como el nombre del dispositivo y el de la copia de seguridad.",
    error: {
      genericMessage: "Utilice letras, números, símbolos básicos y espacios. Máximo 30 caracteres.",
      invalidChars: "El nombre contiene caracteres no válidos: {{invalidChars}}.",
      tooLong: "El nombre es demasiado largo."
    },
    nameLabel: "Nombre de la BitBox02",
    namePlaceholder: "Mi BitBox02",
    title: "Selecciona el nombre de la BitBox02",
    toastMicroSD: "Por favor, inserte su tarjeta microSD en su BitBox02 que se utilizará para almacenar una copia de seguridad de la billetera."
  },
  stepCreateSuccess: {
    removeMicroSD: "Por favor, extrae la tarjeta microSD de tu BitBox02 y guárdala en un lugar seguro. ",
    storeMnemonic: "Guarde sus palabras de recuperación en un lugar seguro",
    success: "Ha creado su copia de seguridad con éxito."
  },
  stepInsertSD: {
    insertSDCard: "Por favor, introduce una microSD en tu BitBox02 para continuar.",
    insertSDcardTitle: "Introduce la tarjeta microSD"
  },
  stepPassword: {
    e104: "Se canceló la configuración de la contraseña.",
    title: "Establece la contraseña de tu BitBox02",
    useControls: "Utiliza los controles de tu BitBox02 para establecer la contraseña."
  },
  stepUninitialized: {
    create: "Quiero configurar una nueva BitBox02.",
    restore: "Quiero recuperar mi billetera desde una copia de seguridad.",
    restoreMicroSD: "Recupera desde una tarjeta microSD",
    restoreMnemonic: "Restaurar desde las palabras de recuperación",
    title: "Instala tu BitBox02"
  },
  success: {
    text: "Perfecto! Tu BitBox02 está lista para ser usada. \n\nPara más información sobre cómo usar la BitBoxApp, por favor utiliza la guía in-app haciendo clic en el signo de interrogación de la esquina superior derecha. ",
    title: "Estas preparado para usar la billetera BitBox."
  }
};
const bitsurance$2 = {
  dashboard: {
    active: "Póliza de seguro activa",
    button: "Asegura una nueva cuenta",
    canceled: "Cancelado",
    coverage: "Cobertura máxima",
    inactive: "Inactivo",
    processing: "Procesando ",
    refused: "Rechazado",
    supportLink: "Gestionar el contrato",
    title: "Cuentas aseguradas",
    waitpayment: "A la espera del pago"
  },
  detect: {
    button: "Comprobar el seguro existente",
    insured: "Cuenta asegurada detectada:",
    notInsured: "No se han detectado cuentas aseguradas. Si está seguro de que tiene una cuenta asegurada, asegúrese de que tiene conectada la billetera correcta.",
    text: "Si ya estás suscrito a Bitsurance, la BitBoxApp puede sincronizar automáticamente tu cobertura de seguro existente.",
    title: "¿Ya está asegurado?"
  },
  insure: {
    button: "Consultar disponibilidad y precios",
    faq: "Más información en Preguntas frecuentes sobre Bitsurance",
    listItem1: "Robo",
    listItem2: "Extorsión (por ejemplo, ataque con una llave inglesa de 5 dólares)",
    listItem3: "Destruction due to fire, water or natural disasters",
    month: "mes",
    text: "Asegura tu BitBox02 y hasta 100.000 euros en bitcoins contra",
    text2: "Los planes de seguro cuestan a partir de 30 euros al año (2,50 euros al mes). Puede obtener más información sobre Bitsurance y sus ofertas de seguros exactas en la página web",
    text3: "Actualmente disponible en Alemania y en otras regiones.",
    title: "Comienza"
  },
  intro: {
    link: "Sitio web de Bitsurance",
    text1: "BitBox trabaja con Bitsurance para añadir una capa adicional de protección para tu bitcoin. Mientras que la BitBox02 mantiene tus fondos seguros, Bitsurance cubre las amenazas en casa que no se pueden mitigar solo con tecnología, como robos, extorsiones o la destrucción de la propia billetera física."
  },
  terms: {
    link: "Política de privacidad de Bitsurance",
    text1: "Bitsurance es un servicio externo independiente. Para preguntas sobre sus ofertas y reclamaciones de seguros, ponte en contacto directamente con Bitsurance.",
    text2: "Actualmente, el seguro está disponible en Alemania y en otras regiones.",
    text3: "La cobertura máxima de Bitcoin disponible actualmente es de 100.000 euros por persona. Se prevén importes más elevados en el futuro.",
    text4: "La información personal y la clave pública ampliada de su cuenta asegurada forman parte de la póliza de seguro y se compartirán con Bitsurance y el proveedor de seguros.",
    text5: "Para más información sobre privacidad, consulte la"
  },
  title: "Seguro"
};
const bitsuranceAccount$2 = {
  errorNoXpub: "Error: No se ha podido obtener el xpub de la cuenta.",
  noAccount: "No hay cuentas que puedan asegurarse.",
  select: "Seleccionar cuenta",
  title: "Seguro"
};
const blink$3 = {
  button: "Parpadeo"
};
const bootloader$3 = {
  button: "Actualiza ahora el firmware",
  button_install: "Instalar el nuevo firmware ahora",
  progress: "Actualizando: {{progress}}%",
  progress_install: "Instalando: {{progress}}%",
  success: "Actualización completada! Por favor, vuelva a conectar el dispositivo. Esta vez, no toque el botón."
};
const button$8 = {
  abort: "Cancel",
  back: "Atrás",
  buy: "Compra",
  changepin: "Cambia contraseña del dispositivo",
  check: "Comprobar la copia de seguridad",
  "continue": "Continua",
  copy: "Copia",
  create: "Crea",
  dismiss: "Descartar",
  done: "Hecho",
  download: "Descarga",
  hiddenwallet: "Crea el monedero oculto",
  next: "Siguiente",
  ok: "OK",
  previous: "Anterior",
  receive: "Recibe",
  restore: "Restaurar",
  select: "Selecciona",
  send: "Envía",
  unlock: "Desbloquea",
  update: "Actualiza",
  upgrade: "Actualizar"
};
const buy$4 = {
  exchange: {
    bankTransfer: "Transferencia bancaria",
    bestDeal: "La mejor oferta",
    creditCard: "Tarjeta de crédito",
    fast: "Rápido",
    fee: "tarifa",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Transferencia bancaria: {{fee}}%%.",
          creditDebitCard: "Tarjeta de crédito/débito: {{fee}}%%.",
          learnMore: "Más información sobre Moonpay",
          title: "Tasas"
        },
        fullCurrenciesList: "Consulte aquí la lista completa de monedas",
        payment: {
          asteriskText: "* No disponible para residentes en EE.UU.",
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            pix: "PIX (transacciones BR sólo en Brasil)",
            sepa: "SEPA y SEPA Instant (sólo transacciones en euros en países SEPA)",
            uk: "Pagos rápidos en el Reino Unido (transacciones en GBP sólo en el Reino Unido)"
          },
          creditDebitCard: "Tarjeta de crédito/débito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa y Maestro"
          },
          learnMore: "Ver más detalles sobre los métodos de pago",
          title: "Formas de pago"
        },
        supportedCurrencies: "Compatible con las principales monedas fiduciarias: USD, EUR, CHF y más."
      },
      pocket: {
        fees: {
          info: "Transferencia bancaria: {{fee}}% ",
          title: "Tasas"
        },
        learnMore: "Más información sobre Pocket",
        payment: {
          bankTransfer: "Transferencia bancaria",
          bankTransferDetails: {
            sepa: "SEPA y SEPA Instant (sólo transacciones en euros en países SEPA)",
            sic: "Swiss Interbank Clearing (transacciones en CHF solo en CH/LI)",
            uk: "UK Faster Payments (transacciones en GBP sólo en el Reino Unido)"
          },
          bankTransferReccuring: "¿Cómo configurar compras recurrentes con una orden permanente? ",
          title: "Formas de pago"
        },
        supportedCurrencies: "Admite monedas europeas: EUR, GBP y CHF. ",
        verification: {
          info: "Solo requiere verificación de identidad por encima de los puntos de inicio diarios y anuales. ",
          link: "Encuentre los puntos de inicio actuales aquí ",
          title: "Verificación de identidad "
        }
      },
      region: {
        title: "Seleccione la región en la que está registrada su cuenta bancaria para ver las opciones disponibles."
      }
    },
    noExchanges: "Lo sentimos, no hay intercambios disponibles en esta región.",
    region: "Región",
    selectRegion: "No especificado",
    title: "Comprar {{nombre}}"
  },
  info: {
    "continue": "Acepta y continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Nos asociamos con MoonPay para ofrecerte una forma sencilla de comprar {{name}} directamente con BitBoxApp. Con unos pocos clics.  ",
        "MoonPay es una plataforma que hace fácil y rápida la compra de {{name}} en más de 160 países."
      ],
      payment: {
        details: "Puedes comprar {{name}} inmediatamente a través de MoonPay con los siguientes métodos de pago. Los pedidos con tarjeta de crédito o débito son inmediatos y prácticos, pero más caros debido al mayor riesgo de retrocesos de cargos a tarjetas. Recomendamos utilizar la opción de transferencia bancaria para grandes cantidades. La tarifa mínima es de 4 EUR.",
        footnote: "Tenga en cuenta que los tipos de cambio de MoonPay pueden diferenciarse de los utilizados en BitBoxApp, lo que se nota en cantidades ligeramente diferentes.",
        table: {
          "1_description": "Tarifa baja, puede tardar 3 días laborales",
          "1_method": "Transferencias bancarias (SEPA)",
          "2_description": "Tarifas altas pero inmediato y rápido",
          "2_method": "Tarjetas de crédito & débito",
          description: "Descripción",
          fee: "Comisión",
          method: "Metodo"
        },
        title: "Métodos de pago y tarifas"
      },
      privacyPolicy: "MoonPay política de privacidad",
      protection: {
        description: "BitBoxApp no ​​recopila ningún dato al comprar {{name}}, los fondos entrantes se tratan como una transacción normal. MoonPay necesita recoger algunos datos personales para operar. Su Política de privacidad explica en detalle cómo se manejan esos datos.",
        descriptionGeneric: "BitBoxApp no recopila ningún dato cuando se compra {{name}}, los fondos entrantes se tratan como una transacción normal. Sin embargo, las bolsas asociadas necesitan recopilar cierta información para operar. Consulta sus respectivas políticas de privacidad para ver con más detalle cómo se gestionan los datos.",
        title: "Protección de Datos"
      },
      security: {
        description: "Cuando compras {{name}} por MoonPay, utilizas un servicio externo. Este servicio está fuera del alcance de la modelación de riesgos de seguridad BitBox02 y depende de la seguridad y protección del entorno en el que se ejecuta el software BitBoxApp.\n\n",
        descriptionGeneric: "Cuando compras {{name}} a través de una casa de cambio asociada, estás utilizando un servicio externo. Este servicio está fuera del alcance del modelo de amenazas de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp.",
        link: "Modelación de riesgos",
        title: "Modelo de seguridad"
      },
      title: "Bienvenido. Estas en el sitio correcto para comprar {{name}}"
    },
    next: "Siguiente",
    selectLabel: "Elige tu cuenta",
    selectPlaceholder: "Seleccione una moneda",
    skip: "No mostrar de nuevo",
    title: "Comprar {{name}}"
  },
  pocket: {
    data: {
      link: "Política de privacidad de Pocket",
      p1: "La BitBoxApp no recoge ningún dato al comprar bitcoin, los fondos entrantes se tratan como una transacción normal. Pocket necesita recoger algunos datos personales para funcionar. Su Política de Privacidad explica en detalle cómo se manejan esos datos.",
      title: "Protección de datos"
    },
    kyc: {
      link: "Preguntas más frecuentes de Pocket",
      p1: "Pocket intenta reducir al mínimo los requisitos de identificación. Para compras inferiores a 950 EUR (1000 CHF) al día, no se requieren documentos adicionales. Para compras superiores a esta cantidad, tendrás que programar una llamada con Pocket para completar el proceso KYC/AML necesario.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puedes comprar bitcoin instantáneamente con Pocket a través de una transferencia bancaria SEPA. La comisión es del 1,5% y el bitcoin se deposita en su BitBox lo antes posible después de que Pocket reciba la transferencia bancaria (normalmente en el mismo día).",
      p2: "Tenga en cuenta que los tipos de cambio de Pocket pueden diferir de los utilizados en la BitBoxApp, dando lugar a importes ligeramente diferentes.",
      title: "Formas de pago y tasas"
    },
    previousTransactions: "El historial de transacciones de esta cuenta no está vacío. Compartir esta cuenta hará que todas sus transacciones pasadas y futuras sean visibles para Pocket. ¿Proceder de todos modos?",
    security: {
      link: "Modelo de amenazas a la seguridad BitBox02",
      p1: "Cuando compras bitcoin a través de Pocket, estás utilizando un servicio externo. Este servicio está fuera del alcance del modelo de amenaza de seguridad de BitBox02 y depende de la seguridad del entorno en el que se ejecuta el software de BitBoxApp. Sin embargo, trabajamos juntos para mejorar la seguridad utilizando un mecanismo de autenticación de dos factores para verificar la dirección a la que estás recibiendo.",
      title: "Modelo de seguridad"
    },
    usedAddress: "La dirección {{address}} ya ha sido utilizada, por favor comience de nuevo con una nueva dirección.",
    verifyBitBox02: "Compruebe que la dirección que ha recibido por correo electrónico coincide con la que aparece en su Bitbox. Si es posible, debería abrir el correo electrónico en un segundo dispositivo para mayor seguridad. ",
    welcome: {
      p1: "Nos asociamos con Pocket para ofrecerte una forma sencilla de comprar bitcoin directamente dentro de la BitBoxApp. Es sólo un par de clics.",
      p2: "Pocket es una plataforma suiza que facilita y agiliza la compra de bitcoins en la mayor parte de Europa (en cualquier lugar donde se admitan transferencias bancarias SEPA).",
      p3: "Con Pocket, también puede hacer compras periódicas a través de órdenes bancarias permanentes, por lo que puede hacer DCA (dollar-cost averaging) con facilidad.",
      title: "Bienvenido a su ventanilla única para comprar bitcoin"
    }
  },
  title: "Comprar {{name}}"
};
const changePin$3 = {
  newTitle: "Nueva contraseña del dispositivo",
  oldLabel: "Contraseña actual del dispositivo"
};
const chart$4 = {
  dataMissing: "Recopilando tus datos históricos. Permanece atento.",
  dataOldTimestamp: "Actualización de los tipos de cambio históricos. El gráfico no muestra datos después de {{time}}.",
  dataUpdating: "actualizando datos",
  filter: {
    all: "Todo",
    month: "Mes",
    week: "Semana",
    year: "Año"
  }
};
const checkSDcard$3 = "comprobando tarjeta micro SD";
const clickHere$3 = "Haz clic aquí.";
const confirm$5 = {
  abortInfo: "Toque para ",
  abortInfoRedText: "Cancel",
  approveInfo: "Mantenga 4+ segundos para ",
  approveInfoGreenText: "confirma",
  info: "Continua en tu Bitbox",
  infoWhenPaired: "Primero en el móvil sincronizado y luego tu BitBox"
};
const confirmOnDevice$3 = "Por favor confirma en tu dispositivo.";
const connectKeystore$3 = {
  promptNoName: "Por favor conecta tu BitBox02 para continuar",
  promptWithName: 'Por favor, conecta tu BitBox02 llamada "{{nombre}}" para continuar '
};
const darkmode$3 = {
  toggle: "Modo oscuro"
};
const device$3 = {
  appUpradeRequired: "Tu BitBox no es compatible con esta aplicación de escritorio. Por favor descarga e instale la última versión.",
  keystoreConnected: "Billetera conectada"
};
const deviceLock$3 = {
  button: "Activa autorización de dos factores (2FA)",
  condition1: "¿Tienes una copia de seguridad?",
  condition2: "¿Funciona la verificación de la aplicación móvil?",
  condition3: "2FA DESACTIVA las copias de seguridad y la sincronización con las aplicaciones móviles. El dispositivo debe ser REINICIADO para salir de 2FA!",
  confirm: "Activa autorización de dos factores (2FA)",
  title: "Activa autorización de dos factores (2FA)"
};
const deviceSettings$3 = {
  backups: {
    manageBackups: {
      description: "Crea o verifica la copia de seguridad de tu tarjeta microSD."
    },
    showRecoveryWords: {
      description: "Mostrar y verificar palabras de recuperación."
    },
    title: "Copias de seguridad"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp comprueba si tu dispositivo es auténtico."
    },
    deviceName: {
      description: "Cambia el nombre de tu dispositivo."
    },
    rootFingerprint: {
      description: "La huella raíz es un identificador único para la billetera actualmente en uso. Puede ayudarte a distinguir entre diferentes billeteras si utilizas frases de contraseña."
    },
    securechip: {
      description: "El modelo del chip seguro."
    },
    title: "Información del dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Restablece tu dispositivo a los valores de fábrica. ¡Esto borra la billetera de tu BitBox02!",
      title: "Restablecimiento de fábrica"
    },
    goToStartupSettings: {
      description: "Entra en el bootloader de la BitBox02. Puedes activar el hash del firmware desde aquí."
    },
    passphrase: {
      description: "",
      title: "Contraseña"
    }
  },
  firmware: {
    firmwareVersion: "Versión del firmware",
    newVersion: {
      label: "Versión disponible"
    },
    title: "Firmware",
    upToDate: "Tu dispositivo está actualizado.",
    upgradeAvailable: "Nueva actualización disponible",
    version: {
      label: "Versión"
    }
  },
  hardware: {
    attestation: {
      "false": "Error en la comprobación de autenticidad",
      label: "Comprobación de autenticidad",
      "true": "Su BitBox02 es auténtico"
    },
    sdcard: {
      "false": "No insertado",
      label: "Tarjeta micro SD",
      "true": "Insertado"
    },
    securechip: "Chip de seguridad",
    title: "Hardware"
  },
  loading: "Recuperando información del dispositivo ...",
  pairing: {
    lock: {
      "false": "Desactivado",
      label: "Autorización de dos factores (2FA)",
      "true": "Activado"
    },
    mobile: {
      "false": "Cerrado",
      label: "Aplicación móvil",
      "true": "Abre"
    },
    status: {
      "false": "No sincronizado",
      label: "Estado",
      "true": "Sincronizado"
    },
    title: "Sincronización"
  },
  secrets: {
    manageBackups: "Administrar copias de seguridad",
    title: "Seguridad"
  }
};
const deviceTampered$3 = "¿Tu BitBox ha sido suministrado con una contraseña de recuperación? Si es así, detenga el proceso de configuración y ponte en contacto con el servicio de asistencia inmediatamente. Shift nunca te dará una billetera confeccionado ni hará recomendaciones de contraseña.";
const dialog$4 = {
  cancel: "Cancela",
  confirm: "Confirma",
  confirmTitle: "Confirmación"
};
const error$4 = {
  accountAlreadyExists: "La cuenta ya existe.",
  accountLimitReached: "No se puede añadir la cuenta. El número máximo de cuentas para esta moneda ha sido alcanzado.",
  aoppCallback: "Ha habido un error entregando la dirección a{{host}}.",
  aoppInvalidRequest: "Solicitud inválida.",
  aoppNoAccounts: "No hay cuentas disponibles.",
  aoppSigningAborted: "Solicitud de propiedad de la dirección cancelada.",
  aoppUnknown: "Un error desconocido ha ocurrido.",
  aoppUnsupportedAsset: "El activo no es soportado.",
  aoppUnsupportedFormat: "No hay cuentas disponibles que soporten el formato de direcciones solicitado.",
  aoppUnsupportedKeystore: "El dispositivo conectado no puede firmar mensajes para este activo.",
  aoppVersion: "Versión desconocida.",
  keystoreTimeout: "La solicitud de su billetera ha caducado. Por favor, inténtelo de nuevo.",
  wrongKeystore: "Se ha conectado una billetera incorrecta. Por favor, asegúrese de insertar el dispositivo correcto que coincida con esta cuenta.",
  wrongKeystore2: " Si utiliza la frase de contraseña opcional, asegúrese de haber introducido la frase de contraseña correcta para la cuenta."
};
const fiat$5 = {
  "default": "predeterminado",
  setDefault: "Establecer {{code}} predeterminado",
  title: "Monedas"
};
const footer$5 = {
  appVersion: "Versión de app:"
};
const generic$4 = {
  enabled_false: "Desactivado",
  enabled_true: "Activado"
};
const genericError$3 = "Ocurrió un error. Si observa algún problema, por favor reinicie la aplicación.";
const goal$3 = {
  buttons: {
    create: "Crear una billetera nueva",
    restore: "Restaurar una billetera desde una copia de seguridad"
  },
  paragraph: "Por favor, selecciona una de las siguientes opciones:",
  step: {
    "1": {
      title: "Información de seguridad"
    },
    "2": {
      description: "Establece una contraseña del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crear una billetera nueva",
      title: "Billetera"
    },
    "3-restore": {
      description: "desde una copia de seguridad",
      title: "Restaurar"
    },
    "4-create": {
      title: "Resumen"
    },
    "4-restore": {
      title: "Resumen"
    }
  }
};
const guide$4 = {
  accountDescription: {
    text: "Este es el resumen de tu cuenta. Muestra las transacciones entrantes y salientes. El saldo se muestra para cada cuenta por separado. Consulta la guía de configuración para obtener más información sobre los diferentes tipos de cuentas.",
    title: "¿Qué me muestra esta página?"
  },
  accountFiat: {
    text: "Sí. Puedes hacer clic en cualquier ticker para rotar a través de varias monedas fiat. También puedes cambiar la lista de monedas en la configuración.",
    title: "¿Puedo mostrar otros tipos de cambio?"
  },
  accountIncomingBalance: {
    text: '"Entrante" resume los importes transferidos pero que todavía no han sido confirmados por la red.',
    title: '¿Qué significa "Entrante"?'
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Cada xpub está relacionada con el "Tipo" mostrado: tanto "Native Segwit (bech32)", "Wrapped Segwit" como "Taproot" (Bitcoin only). Estos son tipos de script utilizados por {{coinName}}. La BitBoxApp las combina, soportando múltiples tipos de script en la misma cuenta. Porque cada tipo de script proporciona una xpub diferente, hay múltiples xpubs por cuenta.\n\nSi constantemente recibe en la dirección por defecto (Native Segwit), solo necesita la "bech32" xpub. Sin embargo, si también recibe fondos en "Wrapped Segwit" o "Taproot", también necesitara utilizar las claves públicas extendidas de "Wrapped Segwit" y "Taproot" respectivamente.',
      title: "¿Porqué hay múltiples xpubs?"
    },
    privacy: {
      text: "Para esta cuenta específica, la clave pública extendida revela todo el historial financiero, el balance en la cuenta, y todas las transacciones futuras. Pero el xpub no permite que nadie gaste tus monedas.\n\nSi le proporcionas una xpub a alguien, deberás tener en cuenta que esa persona o empresa pueden ver otras transacciones de la misma cuenta. Por lo tanto, es una buena idea utilizar esa cuenta solamente con ese propósito y guardar otros fondos en cuentas diferentes.",
      title: "¿Necesito guardar mi xpub en secreto?"
    },
    verify: {
      text: "Si, siempre es una buena idea hacer una doble verificación de tu xpub. Si alguien va a generar direcciones a partir de esta xpub para mandarte dinero, esto es especialmente importante. Tendrá que verificarla en el dispositivo para asegurarse que esa xpub le pertenece; en caso contrario, todos los fondos podrían ir a direcciones incorrectas.",
      title: "¿Necesito verificar la xpub en el dispositivo?"
    },
    xpub: {
      text: "Una clave pública extendida (xpub) es una clave raíz de la cual se obtienen todas las direcciones de recepción de una cuenta.\nSe proporciona para uso avanzado e interoperabilidad con billeteras watch-only, como Electrum o Sentinel. Si recibe otro tipo de direcciones, por favor importe todos los formatos de xpub en la billetera watch-only para poder visualizar todas las monedas.\nTenga en cuenta que, las billeteras de terceros puede que no soporten Taproot xpubs todavía.",
      title: "¿Qué es una clave pública extendida?"
    }
  },
  accountRates: {
    text: "Los tipos de cambio se actualizan cada minuto desde CoinGecko.",
    title: "¿Qué tipo de cambio se utiliza?"
  },
  accountReload: {
    text: "No hace falta. Toda la información de las transacciones se actualiza automáticamente.",
    title: "¿Puedo recargar el historial de transacciones?"
  },
  accountSendDisabled: {
    text: 'El botón "Enviar" se activa cuando tu saldo es mayor que cero.',
    title: "¿Por qué no puedo enviar ningún {{unit}}?"
  },
  accountSummaryAmount: {
    text: "La cantidad total es la suma de todas tus cuentas criptográficas. Los tipos de cambio se consiguen de coingecko.com.\n\nNota: Si usas MyEtherWallet para tokens no admitidos en BitBoxApp, no se incluirán en la cantidad que se muestra.",
    title: "¿Cómo se calcula la suma total?"
  },
  accountSummaryDescription: {
    text: "Aquí puede ver el rendimiento de tu billetera a lo largo del tiempo. Debajo del gráfico se muestra un resumen de sus cuentas criptográficas individuales.",
    title: "¿Qué me muestra esta página?"
  },
  accountTransactionAttributesBTC: {
    text: "Tamaño virtual: se utiliza para determinar la tarifa de la red. Habrás ahorrado con éxito en comisiones si son más pequeñas que la transacción.\nTamaño: Tamaño real de la transacción en bytes cuando se presenta por entregas de acuerdo con la blockchain por debajo.\nPeso: Introducido con Segwit, es una nueva métrica para evaluar los tamaños de transacción y bloque. Cada byte testigo segregado cuenta como uno, todo lo demás como cuatro unidades de peso. En lugar de un megabyte en tamaño real, el límite de tamaño de bloque ahora es de cuatro millones de unidades de peso.",
    title: "Detalles de la transacción relacionados con Bitcoin"
  },
  accountTransactionAttributesGeneric: {
    text: "Confirmaciones: Cuando tu transacción se transmita por primera vez, no se confirmará. Tienes que esperar a que un minero lo incluya en un bloque, después de lo cual tendrá 1 confirmación. Desde ese momento, cada bloque transmitido en la red agregará otra confirmación a tu transacción. En general, los comerciantes y otros actores de la red solo aceptarán transacciones con confirmaciones de entre 3-6 antes de considerar la transacción como liquidada.\nID de transacción: un número de identificación único que se puede usar para buscar una transacción en un explorador de bloques.\nCuota: los mineros reciben una tarifa de transacción como incentivo para incluir las transacciones en los bloques que explotan. Para obtener más información, haz clic en el botón enviar.",
    title: "¿Cuál es la información que se muestra en los detalles de la transacción?"
  },
  accountTransactionConfirmation: {
    text: "Esta es una transacción que se ha transmitido a la red y espera ser confirmada.",
    title: "¿Qué es una transacción pendiente?"
  },
  accountTransactionLabel: {
    text: "Es la dirección donde recibiste o enviaste tus monedas. \nUna dirección codifica cómo (y por lo tanto, por quién) se pueden gastar las monedas.",
    title: "¿Qué dirección se muestra para cada transacción?"
  },
  accountTransactionTime: {
    text: "El tiempo que la transacción ha sido confirmada en el blockchain.",
    title: "¿Qué hora se muestra?"
  },
  accounts: {
    howManyAccounts: {
      text: "Bitcoin y Litecoin pueden tener una cantidad arbitraria de cuentas. Después de cinco cuentas, sólo se puede añadir otra cuenta si se ha utilizado la anterior. \nOtras monedas pueden tener un máximo de cinco cuentas.",
      title: "¿Cuántas cuentas puedo crear?"
    },
    howtoAddTokens: {
      text: 'Tokens que utilicen el estándar ERC20 están conectados a una cuenta específica de Ethereum. Para permitir o inutilizar un token en particular, abra la ventana de "Administrar cuentas", despliegue su cuenta Ethereum y active o desactive su token deseado.',
      title: "¿Cómo puedo añadir tokens adicionales?"
    },
    moveFunds: {
      text: "Si. Pero porque las cuentas son independientes, necesitará enviar los fondos utilizando una transacción normal.",
      title: "¿Puedo mover fondos entre cuentas?"
    },
    recoverAccounts: {
      text: "Si. La BitBoxApp crea cuentas utilizando estándares muy establecidos compatibles con la mayoría de otras carteras crypto.",
      title: "¿Puedo recuperar mis cuentas de otras carteras?"
    },
    whatAreAccounts: {
      text: "Su cartera puede administrar cuentas de la misma moneda. Las cuentas son útiles cuando se quiere guardar los fondos de forma separada.",
      title: "¿Qué son las cuentas?"
    },
    whatIsRememberWallet: {
      text: 'Activando "Recordar billetera" podrás ver las cuentas de esta billetera en la BitBoxApp incluso cuando la BitBox02 no esté conectada. Esto te permite comprobar tu saldo y portafolio siempre que quieras. La BitBox02 necesita estar conectada y desbloqueada para enviar o recibir monedas.\n\nDesactivar "Recordar billetera" requiere que conectes la BitBox02 respectiva (o frase de contraseña) para ver esas cuentas en la BitBoxApp.',
      title: '¿Qué ocurre cuando activo/desactivo "Recordar billetera"?'
    },
    whyIsThisUseful: {
      text: 'Las cuentas son geniales para la gestión de fondos para diferentes personas o propósitos porque están separados. También puede compartir la "clave pública extendida" de una cuenta sin revelar nada sobre las otras cuentas. Esto permite recibir fondos repetidamente sin reutilizar direcciones, tanto para recibir su salario o comprar crypto de forma habitual.',
      title: "¿Porqué es esto útil?"
    }
  },
  appendix: {
    link: "¡Contacta con nosotros!",
    text: "¿Otra pregunta?"
  },
  backups: {
    check: {
      text: '"Comprobar copia de seguridad" te permite verificar que tienes una copia de seguridad operativa correspondiente a tu monedero actual. También se puede usar para verificar que todavía tienes la contraseña de recuperación correcta. Puedes verificar tu contraseña de recuperación principal o tu contraseña de recuperación oculta.',
      title: "¿Qué es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: "No, pero necesitas tu contraseña de recuperación para obtener el monedero de la semilla guardada.",
      title: "¿Puedo encriptar la copia de seguridad?"
    },
    howOften: {
      text: "La copia de seguridad se genera automáticamente cuando se crea un nuevo monedero. Sólo tienes que hacer una nueva copia de seguridad si tu tarjeta micro SD está perdida o dañada, o si quieres usar varias tarjetas micro SD como copias de seguridad.\nNo es necesario crear nuevas copias de seguridad después de la actividad de transacción. Todos tus datos de transacción pueden ser recreados por tu única copia de seguridad que se generó automáticamente para ti.",
      title: "¿Con qué frecuencia tengo que hacer una copia de seguridad?"
    },
    whatIsABackup: {
      text: "Esto es una copia de la semilla en una tarjeta micro SD. La semilla junto con tu contraseña de recuperación genera tu monedero.",
      title: "¿Qué es una copia de seguridad?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Comprobar copia de seguridad' te permite verificar que tienes una copia de seguridad funcional y que corresponde a tu monedero actual.",
      title: "¿Qué es 'Comprobar la copia de seguridad'?"
    },
    encrypt: {
      text: 'No. Por favor mantén la microSD en un lugar seguro porque contiene la semilla para recuperar tu monedero sin encriptar. Si deseas proteger con contraseña tu semilla, puedes activar una frase de contraseña (passphrase) opcional en los ajustes, debajo de "Ajustes del dispositivo". ',
      title: "¿Puedo encriptar la copia de seguridad?"
    },
    whatIsABackup: {
      text: "Es una copia de la semilla en la tarjeta microSD.",
      title: "¿Qué es una copia de seguridad?"
    }
  },
  bitbox: {
    "2FA": {
      text: "Cuando 2FA está habilitado, todas las transacciones deben aprobarse en el teléfono móvil sincronizado para poder gastar monedas. Técnicamente, se envía un número encriptado de un solo uso a la aplicación móvil, donde se descifra y se devuelve al BitBox al presionar el botón Aceptar. Esta comunicación con el dispositivo se realiza a través del canal entre el teléfono móvil y esta aplicación de escritorio establecida durante la sincronización.\n\nAsegúrate de hacer una copia de seguridad de tu monedero y sincroniza la aplicación móvil antes de habilitar 2FA. Una vez habilitado, las sincronizaciones entre la ranura micro SD y las aplicaciones móviles se deshabilitan. Se pueden volver a habilitar reiniciando el BitBox, algo que borrará el dispositivo.",
      title: "¿Cómo funciona la autorización de dos factores (2FA)?"
    },
    disable2FA: {
      text: `Para deshabilitar 2FA, debes restablecer su BitBox y luego restaurar el monedero desde su copia de seguridad. Asegúrate de que todavía tienes la tarjeta micro SD con la copia de seguridad y que aún recuerdas la contraseña de recuperación. Luego pulsa 'Restablecer dispositivo'. Establece una nueva contraseña de dispositivo y elija 'O restaurar una copia de seguridad'. Selecciona la copia de seguridad que has hecho del monedero, haz clic en "Restaurar" e ingresa la contraseña de recuperación que utilizaste al crear el monedero.`,
      title: "¿Cómo puedo desactivar la autorización de dos factores (2FA)?"
    },
    ejectBitbox: {
      text: "Puedes desconectar el BitBox en cualquier momento sin tener que expulsarlo primero.",
      title: "¿Cómo puedo expulsar el BitBox?"
    },
    ejectSD: {
      text: "Puedes retirar la tarjeta micro SD de BitBox en cualquier momento siempre que no esté en el proceso de crear o restaurar una copia de seguridad.",
      title: "¿Cómo puedo expulsar la tarjeta micro SD?"
    },
    hiddenWallet: {
      text: "Es un segundo monedero en el mismo dispositivo protegido por una contraseña de dispositivo y una contraseña de recuperación diferentes, que puedes usar para una negación creíble. La misma semilla de copia de seguridad se usa para tu monedero normal y oculto, por lo que no se requiere una copia de seguridad adicional.",
      title: "¿Qué es un monedero oculto?"
    },
    legacyHiddenWallet: {
      text: "Primero haz clic en el botón de abajo (disponible si el BitBox está desbloqueado con la contraseña del dispositivo principal y la 2FA está desactivada), luego vuelve a conectar su Bitbox y desbloquea con la contraseña oculta del dispositivo.",
      title: "¿Cómo accedo el monedero oculto heredado?"
    },
    pairing: {
      text: "Después de haber descargado nuestra aplicación móvil para iOS o Android, escanea el código QR mostrado, que establece un canal seguro entre la aplicación móvil y esta aplicación. Una vez escaneado, sige las instrucciones en la aplicación móvil.",
      title: "Cómo sincronizo de forma segura con mi teléfono"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Consulte el sitio web de Bitsurance y sus preguntas frecuentes para obtener más información.",
      title: "¿Tiene más preguntas?"
    },
    privacy: {
      link: {
        text: "Política de privacidad de Bitsurance"
      },
      text: "Como cualquier póliza de seguro normal, contiene su nombre completo y dirección, y especifica el objeto asegurado (definido por la clave pública extendida de la cuenta Bitcoin asegurada). Estos datos se envían directamente a Bitsurance y no se comparten con Shift Crypto. Por favor, consulte la política de privacidad de Bitsurance para más información.",
      title: "¿Qué datos personales se necesitan para el seguro?"
    },
    renew: {
      text: 'El seguro se renovará automáticamente para el año siguiente. Puedes cancelar la renovación en cualquier momento haciendo clic en "Gestionar contrato" en la BitBoxApp, que te lleva al portal de clientes de Bitsurance.',
      title: "¿Cómo puedo renovar o cancelar el seguro?"
    },
    status: {
      text: 'Las cuentas aseguradas con éxito se marcan con una insignia verde de "asegurado" en la esquina superior izquierda de cada página de cuenta Bitcoin. En la sección "Seguro", puede ver el resumen de todas las cuentas Bitcoin aseguradas y su estado de seguro actual.',
      title: "¿Puedo comprobar el estado de una cuenta asegurada?"
    },
    what: {
      text: 'Cada contrato de seguro de Bitcoin cubre una cuenta de billetera específica. Puede asegurar varias cuentas contratando varias pólizas de seguro. Las cuentas aseguradas están limitadas al uso de direcciones Bitcoin "Segwit Nativo".',
      title: "¿Está asegurada toda la billatera BitBox?"
    },
    who: {
      text: "El seguro lo ofrece Bitsurance, un corredor de seguros creado por bitcoiners. Trabajan con ELEMENT insurance para ofrecer seguros de Bitcoin. Ambas empresas tienen su sede en Alemania.",
      title: "¿Quién asegura mi bitcoin?"
    },
    why: {
      text: "Bitsurance cubre algunos riesgos de la autocustodia que no están cubiertos ni siquiera por la billatera más segura, como el robo, la extorsión o la destrucción de la billetera. Es tu decisión personal si necesitas cobertura de seguro para estos riesgos.",
      title: "¿Necesito un seguro Bitcoin?"
    }
  },
  cointracking: {
    text: 'Haga click en el botón "Exportar" y abra la carpeta de descargas donde encontrará el CSV exportado.\nA continuación haga click en el enlace de abajo, cargue su archivo BitBox CSV e importe los datos para ser utilizados por su gestor de CoinTracking y crear sus informes fiscales.',
    title: "¿Cómo importar mis transacciones a CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Más información sobre el control de autenticidad"
      },
      text: "La BitBoxApp realiza una comprobación de atestación en la BitBox02 para verificar si el dispositivo es genuino. La comprobación se realiza localmente y no se conecta a ningún servidor.",
      title: "¿Cómo funciona el control de autenticidad?"
    },
    name: {
      text: "Este es el nombre de tu wallet y de la copia de seguridad. El nombre se utiliza para futuras copias de seguridad y se puede utilizar para ayudar a distinguir entre diferentes billeteras. Se puede cambiar en cualquier momento, pero ten en cuenta que las copias de seguridad realizadas antes del cambio seguirán utilizando el nombre anterior.",
      title: "¿Para qué se utiliza el nombre BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Más información sobre el chip seguro"
      },
      text: "Esta información muestra el número de modelo del chip seguro, el chip más actualizado es ATECC608B con características de seguridad mejoradas en comparación con los modelos anteriores.",
      title: "¿Por qué mostrar el modelo de chip seguro?"
    }
  },
  receive: {
    address: {
      text: "Puedes dar la dirección a otras personas para que te envíen monedas. Solo tienes que asegurarte de que envíen a la dirección correcta.",
      title: "¿Qué hago con una dirección?"
    },
    addressChange: {
      text: "En cuanto se utilice una dirección en una transacción, se agrega una nueva dirección a la lista para reemplazarla. Siempre habrá 20 direcciones no utilizadas disponibles en la lista.",
      title: "¿Cuándo cambian las direcciones?"
    },
    addressFormats: {
      text: "Por defecto, el tipo de dirección es Native Segwit. Esta dirección es ampliamente adoptada por otras carteras/exchanges y proporciona las mejores comisiones para las transacciones del día a día. En cambio, se puede elegir enviar a Taproot (Bitcoin Only), que es el último tipo de direcciones, pero puede que no sea ampliamente soportada todavía. Como alternativa, si tiene complicaciones enviando a Native Segwit (el tipo de dirección por defecto), puede intentar cambiar al antiguo tipo de dirección Wrapped Segwit que puede ser compatible con mas carteras/exchanges.\n",
      title: '¿Cuándo utilizar "cambio de tipo de dirección"?'
    },
    howVerify: {
      text: "Para la BitBox01, haz clic en el icono BitBox en la barra lateral de la izquierda y revisa las opciones de emparejamiento. Esta guía se actualizará y podrás seguir las nuevas instrucciones desde allí.\nPara la BitBox02, puedes verificar las direcciones directamente en tu dispositivo durante el proceso de envío y recepción. ",
      title: "¿Cómo puedo verificar una dirección de forma segura?"
    },
    plugout: {
      text: "No, una vez ha enviado las monedas a su dirección de BitBox, no tendrá que dejar su BitBox enchufada. Puede desconectar su BitBox cuando quiera.",
      title: "¿Necesito dejar conectada mi BitBox mientras recibo?"
    },
    why20: {
      text: 'Durante la inicialización, la app genera direcciones derivadas de tu semilla para ver si han recibido fondos. Como la app puede generar un número casi infinito de direcciones, se podría pasar años determinando el saldo. Para limitar esta búsqueda se para después de encontrar 20 direcciones que nunca han recibido fondos. Esto es un "intervalo límite" y  20 es el estándar de-facto aunque el número es arbitrario. Estas son las 20 direcciones que puedes escoger.',
      title: "¿Por qué solo 20 direcciones?"
    },
    whyMany: {
      text: "Por razones de privacidad y seguridad, nunca debes utilizar la misma dirección dos veces. Haz clic en 'Siguiente' para obtener una nueva dirección para un propósito diferente. Puedes generar hasta 20 direcciones a la vez. Todas las direcciones se derivan de tu semilla única de la copia de seguridad.",
      title: "¿Por qué hay tantas direcciones?"
    },
    whyVerify: {
      text: "Una de las razones por las que comprar una cartera de hardware como la BitBox es que no debes confiar en tu ordenador debido a sus numerosos vectores de ataque. No debes confiar en que tu ordenador genere y muestre direcciones auténticas. El botón para verificar la dirección de manera segura hace que BitBox envíe la dirección a un teléfono móvil sincronizado, desde el cual también puedes escanear y verificar el código QR.",
      title: "¿Por qué debo verificar la dirección de forma segura?"
    }
  },
  send: {
    change: {
      text: "El cambio será devuelto a una dirección Taproot si al menos tiene un UTXO Taproot. Si utiliza coin control, el cambio será devuelto a una dirección Taproot si al menos hay un Taproot UTXO entre los UTXOs seleccionados. En el resto de casos, el cambio será devuelto a una dirección Native Segwit.",
      title: "¿Cómo se determina la dirección de cambio?"
    },
    fee: {
      text: "La tarifa se basa en el tamaño de los datos de la transacción y no en su cantidad. Los objetivos de tiempo de la tarifa se calculan mediante el algoritmo de estimación de tarifa de Bitcoin Core para cada prioridad de red que elijas. Serán mostrados si tienen un valor diferente del siguiente objetivo.\nEconómico: 24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)\nBajo: 12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)\nNormal: 6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)\nAlto: 2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)\n(Un bloque de Bitcoin tarda un promedio diez minutos para que se mine (2.5 minutos en Litecoin), y la congestión de la red puede hacer variar considerablemente los períodos arriba mencionados).",
      title: "¿Cómo se determina la comisión?"
    },
    plugout: {
      text: "No, una vez ya ha realizado la transacción, no necesita dejar su BitBox conectada. Puede desconectar su BitBox cuando quiera.",
      title: "¿Necesito dejar mi BitBox conectada mientras envío?"
    },
    priority: {
      text: "Cuanto mayor sea la comisión que estás dispuesto a pagar, más rápido se confirmará tu transacción por la red.",
      title: "¿Cuál es la prioridad de la red?"
    },
    revert: {
      text: "Una vez que se firma y se envía una transacción (que se transmite a la red), ya no puede revertirse. ¡Verifica las transacciones (también la comisión) correctamente antes de firmar!\nSi conoces al destinatario y él o ella está dispuesto a enviarte la misma cantidad de vuelta (menos los cargos por transacción), puedes entonces enviarle una nueva dirección de recepción.",
      title: "¿Puedo revertir una transacción?"
    },
    whyFee: {
      text: "Las transacciones compiten para ser confirmadas por un minero. Los mineros eligen las transacciones que se incluirán en la blockchain en función de tu tarifa.\nLos mineros votan sobre el historial de las transacciones. Dado que no hay un tercero de confianza para imponer un voto por persona (que es el eje central de las blockchains), los mineros votan sobre las transacciones sacrificando un recurso caro como la potencia de cálculo. Como recompensa por su trabajo, pueden reclamar monedas recién creadas y la tarifa de todas las transacciones que incluyeron.",
      title: "¿Por qué hay una tarifa de red?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Si solo tiene la intención de conectarse a tu nodo cuando esté en la misma red (por ejemplo, la red wifi de tu hogar), entonces es suficiente usar la comunicación de red regular.\nEn este caso, es recomendable que el servidor Electrum proporcione un certificado TLS para encriptar la comunicación.\nSi tu intención es conectarse a tu nodo desde cualquier lugar, usar Tor es la mejor opción. En ese caso, no es necesario ningún certificado TLS.\n\n",
      title: "Debo usar Clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guía para conectar tu nodo"
      },
      text: "Para el tutorial competo, por favor visita nuestra guía: ",
      title: "¿Como conecto mi BitBoxApp con mi nodo?"
    },
    options: {
      text: "Hay varias opciones para usar su propio nodo, como comprar un dispositivo terminado, construir el tuyo propio o usar Bitcoin Core.\nSi quieres conectar tu BitBoxApp a tu nodo, asegúrate de que ejecutas un servidor Electrum. Este es un programa que permite que una app del monedero se comunica con su nodo completo.\nLas opciones  incluyencompatibles Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).",
      title: "¿Qué opciones existen para ejecutar un nodo?"
    },
    tor: {
      text: "Tor significa 'The Onion Router', es un software gratuito y de fuente abierta que ofrece muchos beneficios de privacidad. Es muy útil cuando se usa Bitcoin.\nSi tienes la intención de conectarte a su nodo a través de Tor, asegúrate de que Tor esté instalado en tu ordenador y luego activa Tor Proxy en la configuración de BitBoxApp.\nEn la mayoría de los sistemas operativos, hay dos formas de ejecutar Tor:\n1. Tor Browser: descarga y abre el Tor Browser. Esto permitirá que BitBoxApp se conecte a la red Tor configurando el puerto 9150 en la configuración del proxy Tor.\n2. Servicio Tor en segundo plano: instala el Tor daemon, que siempre se usa en segundo plano. BitBoxApp puede conectarse configurando el puerto 9050 en la configuración del proxy Tor.\n\n",
      title: "¿Que es un Tor, Tor proxy y en que puerto lo debería usar?"
    },
    what: {
      text: "Es posible conectar tu wallet a tu propio nodo completo Bitcoin en vez de utilizar los servidores Shift.",
      title: "¿Qué es esto?"
    },
    why: {
      text: "No es necesario ejecutar su propio nodo, pero mejora la privacidad y reduce la necesidad de confiar en los demás.\nEn primer lugar, significa que estás utilizando Bitcoin de forma más privada, ya que BitBoxApp no ​​se conectará a nuestros servidores para recuperar su historial de transacciones; en su lugar, obtendrá esa información de su propio nodo.\nEn segundo lugar, ejecutar tu propio nodo significa que tu nodo verifica todas las transacciones por sí mismo, asegurándose de que se cumplan las reglas de consenso.",
      title: "¿Por qué debería ejecutar mi propio nodo?"
    }
  },
  settings: {
    sats: {
      text: 'Un Satoshi ("sat" para abreviar) es la unidad más pequeña de Bitcoin. Un Satoshi es la cienmillonésima parte de un bitcoin (0,00000001 BTC). Debe su nombre al creador de Bitcoin, Satoshi Nakamoto.',
      title: "¿Qué es un Satoshi?"
    },
    servers: {
      text: "Esta aplicación se comunica con los servidores de Shift Crypto para buscar actualizaciones, cargar transacciones y enviar información a aplicaciones móviles sincronizadas.\nAdemás, recupera los últimos tipos de cambio de CoinGecko. Todas las conversiones se calculan de forma local lo que significa que no se envían las cantidades que uno tiene a ningún servidor. \nNota: Para Ethereum y tokens ERC20, utilizamos la API de Etherscan.io",
      title: "¿Con qué servidores se comunica esta aplicación?"
    }
  },
  title: "Guía",
  toggle: {
    close: "Cerrar la guía",
    open: "Guía"
  },
  trackingModePortfolioChart: {
    text: "En el ordenador de sobremesa, sitúe el cursor sobre el gráfico. En móvil, mantén el dedo sobre el gráfico y arrástralo horizontalmente.",
    title: "¿Cómo ver los valores históricos en el gráfico?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Debe restablecer el dispositivo y recuperar el mondero desde una copia de seguridad, utilizando la contraseña de recuperación.",
      title: "¿Qué hago si olvido la contraseña del dispositivo?"
    },
    reset: {
      text: "Introduzca una contraseña de dispositivo incorrecta 15 veces. Los últimos intentos requieren mantener pulsado el dispositivo .",
      title: "¿Cómo reinicio el dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "El dispositivo debe parpadear una vez se haya insertado. Asegúrese de que se inserta de la manera correcta. Si tiene problemas, por favor contáctenos a través del siguiente enlace.\nLa BitBox01 no es soportada en los móviles/celulares. Por favor utilice la BitBoxApp de escritorio para conectar su BitBox01.",
      title: "Mi dispositivo no está reconocido"
    },
    getDevice: {
      link: {
        text: "Encargue un BitBox"
      },
      text: "Puedes comprar un BitBox en nuestra tienda online:",
      title: "¿Cómo puedo obtener un dispositivo?"
    },
    internet: {
      text: "Sí, se necesita una conexión a Internet para sincronizar el monedero, enviar transacciones y recuperar los últimos tipos de cambio.",
      title: "¿Esta aplicación requiere conexión a internet?"
    },
    lostDevice: {
      link: {
        text: "Centro de respaldo (backup)"
      },
      text: "Puede recuperar sus cuentas en un nuevo BitBox o con nuestro centro de copia de seguridad.",
      title: "Perdí mi dispositivo. ¿Ahora qué?"
    },
    useWithoutDevice: {
      text: "Lamentablemente, esto todavía no es posible en este momento.",
      title: "¿Puedo usar la aplicación sin un dispositivo?"
    },
    welcome: {
      text: "Gracias por utilizar esta aplicación creada por Shift Crypto en Suiza. Todavía está en beta y agradecemos cualquier comentario que tenga que compartir. Por favor, de su opinión utilizando el enlace en la parte inferior.",
      title: "¡Bienvenido a la aplicación de BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Si estás usando un nuevo teléfono/ordenador con la BitBoxApp, entonces tendrás que conectarte de nuevo a la DApps. A continuación, verá sus monedas en la dapp de nuevo como de costumbre.",
      title: "No veo mis conexiones previas."
    },
    supportedNetworks: {
      text: "Actualmente, sólo Ethereum mainnet es compatible utilizando WalletConnect en la BitBoxApp. Para utilizar otras cadenas compatibles con EVM, por favor utilice la extensión de navegador Rabby wallet.",
      title: "¿Qué redes son compatibles?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect es un protocolo de comunicación para aplicaciones web3. Permite conectarse cómodamente a DApps basadas en Ethereum y billeteras web sin necesidad de utilizar una app de terceros, lo que resulta especialmente útil para los usuarios de Android de la BitBoxApp.",
      title: "¿Qué es WalletConnect?"
    }
  }
};
const headerssync$3 = {
  blocksSynced: "{{blocks}} bloques sincronizados"
};
const hiddenWallet$3 = {
  info1HTML: "Para fines de negación plausible, se puede crear un monedero oculto basada en una <strong>diferente</strong> combinación de contraseña de recuperación y contraseña del dispositivo.",
  info2HTML: "Defina la contraseña del dispositivo y la contraseña de recuperación que quieres asociar con su monedero oculto a continuación. La contraseña del dispositivo y la contraseña de recuperación deben ser <strong>diferentes</strong> de los que has definido para tu monedero principal.",
  passwordLabel: "Contraseña de recuperación oculta",
  passwordPlaceholder: "Por favor confirma la contraseña de recuperación oculta",
  pinLabel: "Contraseña oculta del dispositivo",
  pinRepeatLabel: "Repita la contraseña del dispositivo oculto",
  pinRepeatPlaceholder: "Por favor confirma la contraseña oculta del dispositivo",
  success: "Monedero oculto creado con éxito. Vuelve a enchufar tu BitBox para desbloquearlo."
};
const initialize$3 = {
  create: "Establece contraseña del dispositivo",
  creating: "Configuración de la contraseña del dispositivo ...",
  error: {
    e102: "La contraseña del dispositivo debe constar de al menos 4 caracteres."
  },
  info: {
    description1: "Elije la contraseña de tu dispositivo. Esto se utilizará para desbloquear su BitBox.",
    description2: "Puedes usar números, letras y símbolors. Las contraseñas largas ofrecen mayor seguridad.",
    description3: "Si pierdes la contraseña del dispositivo, tendrás que restablecer tu dispositivo y recuperar la copia de seguridad de su monedero.",
    subtitle: "Ahora configurará la contraseña de su dispositivo.",
    title: "Iniciando su dispositivo"
  },
  input: {
    label: "Contraseña del dispositivo",
    labelRepeat: "Repita la contraseña del dispositivo",
    placeholderRepeat: "Por favor confirma la contraseña del dispositivo"
  }
};
const invalidFormat$3 = "Formato inválido";
const language$4 = {
  title: "Selecciona el idioma"
};
const legacyhiddenwallet$3 = {
  disable: "Desactiva monedero oculto heredado",
  enable: "Activa monedero oculto heredado",
  successDisable: "Se desactivó con éxito el legado del monedero oculto.",
  successEnable: "El monedero oculto heredado se habilitó con éxito. Vuelva a enchufar su BitBox e ingresa la contraseña del dispositivo oculto para acceder al monedero oculto heredado."
};
const loading$3 = "cargando…";
const manageAccounts$2 = {
  accountHidden: "Esta cuenta ha sido ocultada de tus cuentas de sólo vigilancia. Para volver a verla, conecta tu BitBox02.",
  editAccount: "Editar",
  editAccountNameTitle: "Editar nombre de cuenta",
  noAccounts: "No se han encontrado cuentas",
  settings: {
    hideTokens: "Ocultar tokens",
    showTokens: "Mostrar tokens ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Añadir y mostrar/ocultar cuentas",
  title: "Administrar cuentas",
  watchAccount: "Cuenta de vigilancia",
  watchAccountDescription: "Esta cuenta forma parte de tus cuentas de vigilancia. Puedes ocultarla de tus cuentas de solo vigilancia utilizando el conmutador."
};
const mobile$3 = {
  usingMobileDataWarning: "Uso de datos móviles: esta aplicación puede descargar hasta unos cientos de megabytes de datos de blockchain después de desbloquear una cuenta. Por favor, conéctate a una red Wi-Fi para evitar el uso de datos móviles. Después de descartarlo, este mensaje no se mostrará nuevamente.\n\n"
};
const newSettings$2 = {
  about: {
    appVersion: {
      title: "Versión de la aplicación"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Bloquea el acceso a la aplicación con bloqueo de pantalla/huella dactilar.",
      title: "Bloqueo de pantalla"
    },
    coinControl: {
      description: ""
    },
    customFees: {
      description: "Le permite introducir su propia tarifa al enviar."
    },
    torProxy: {
      description: "Conéctate a través de Tor para mejorar la privacidad."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Estas monedas adicionales se pueden cambiar a través de la página de su cuenta.",
      title: "Divisas activas"
    },
    darkmode: {
      description: "Ver la BitBoxApp en modo oscuro."
    },
    defaultCurrency: {
      description: "Selecciona tu moneda predeterminada",
      title: "Moneda predeterminada"
    },
    enableAccount: {
      description: "Deshabilitar tu cuenta significa que no aparecerá en la barra lateral ni en la billetera. Siempre puedes volver a activarla desde aquí. Las monedas de esta cuenta no se verán afectadas y permanecerán seguras.",
      title: "Activar/desactivar cuenta"
    },
    hideAmounts: {
      description: "Muestra un conmutador para ocultar tu saldo y los importes para mejorar tu privacidad cuando utilices la aplicación en público.",
      hideAmounts: "Ocultar importes",
      showAmounts: "Mostrar importes",
      title: "Permitir ocultar importes"
    },
    language: {
      description: "Qué idioma quieres que utilice la BitBoxApp.",
      title: "Idioma"
    },
    remebmerWallet: {
      name: "Recuerde la billetera",
      warning: "Esto eliminará tu billetera recordada. Para verlo de nuevo, necesitará conectar la BitBox02 para esta billetera. Las monedas de esta billetera no se verán afectadas. ¿Desea continuar?",
      warningTitle: "Desactivar recuerde la billetera"
    },
    toggleSats: {
      description: "Habilitar o deshabilitar Satoshis."
    }
  }
};
const note$4 = {
  input: {
    description: "(opcional)",
    placeholder: "añade nota"
  },
  title: "Nota"
};
const notification$3 = {
  newTxs_one: "Nueva transacción en: {{accountName}}",
  newTxs_other: "{{count}} nuevas transacciones en: {{accountName}}"
};
const pairing$3 = {
  aborted: {
    text: "La sincronización ha sido cancelada desde la aplicación móvil.",
    title: "Abortado"
  },
  button: "Sincronizar aplicación móvil",
  confirm: "¿Estás seguro de que quieres sincronizar su BitBox? Ten en cuenta que después, se necesitará el teléfono móvil para realizar una transacción.",
  connectOnly: {
    button: "Conectar aplicación móvil",
    title: "Escanea con nuestra aplicación móvil seleccionando el elemento de menú 'Conectar a la nueva aplicación de escritorio'"
  },
  error: {
    text: "Algo salió mal. Por favor empieza de nuevo.",
    title: "Error"
  },
  pullFailed: {
    text: "Ha habido un error recibiendo un mensaje de tu móvil a través del relay server.  Éste puede estar sin conexión, por favor contacte al soporte técnico.",
    title: "Solicitud fallida"
  },
  reconnectOnly: {
    button: "Volver a conectar la aplicación móvil"
  },
  scanningFailed: {
    text: "El móvil no ha podido escanear el mensaje con éxito. Por favor inténtalo de nuevo.",
    title: "Escaneo fallido"
  },
  start: {
    hideAppQRCode: "Ocultar código QR",
    revealAppQRCode: "Mostrar código QR",
    step1: "Si no tiene la aplicación móvil, puede escanear el código QR para la App Store de Apple o la Play Store de Google, según el teléfono que tengas.",
    step2: "Escanee con nuestra aplicación móvil, que puede encontrar bajo el nombre 'Digital Bitbox 2FA' en las tiendas de aplicaciones para iOS y Android:"
  },
  started: {
    text: "Ahora sige por favor las instrucciones en la aplicación móvil.",
    title: "Genial"
  },
  success: {
    text: "¡Enhorabuena, has sincronizado su BitBox con la aplicación móvil!",
    title: "Éxito"
  },
  timeout: {
    text: "La sincronización expiró después de dos minutos. Empieza de nuevo si aún quieres sincronizar la aplicación móvil.",
    title: "Se acabó el tiempo"
  },
  title: "Sincronización móvil"
};
const passphrase$2 = {
  considerations: {
    button: "Consideraciones de la copia de seguridad",
    message: "La frase de contraseña añade una capa de protección a tu billetera de copia de seguridad (de la tarjeta microSD o palabras de recuperación). Si alguien tiene acceso a tu copia de seguridad, también necesitará la frase de contraseña para acceder a tu billetera. \n\n\nSin embargo, esto significa que necesitarás <strong>tanto la frase de contraseña como la copia de seguridad de tu billetera</strong> para restaurar tu billetera con la frase de contraseña, en caso de que tu BitBox02 se pierda o se rompa. Si olvidas o pierdes tu contraseña, perderás el acceso a todas las monedas de esa billetera.\n\nCuando almacenes tu frase de contraseña, considera ponerla en un lugar distinto a la de tu copia de seguridad. De este modo, si alguien encuentra la copia de seguridad, no encontrará también la frase de contraseña.",
    title: "Consideraciones de la copia de seguridad"
  },
  disable: "Desactivar passphrase",
  disableInfo: {
    button: "Desactivar",
    message: "Tras desactivar la passphrase, no se le volverá a preguntar para que introduzca una passphrase tras desbloquear su BitBox02. Por lo que entrara en su cartera por defecto.\nCualquier moneda de su cartera con passphrase seguirá estando en esa cartera, sin embargo no tendrá acceso a ella porque tras desbloquear su BitBox02, abrirá su cartera por defecto.\nPara acceder a su cartera con passphrase de nuevo, simplemente vuelva a activar la opción de passphrase e introduzca la passphrase correcta tras desbloquear la BitBox02.\n<strong>Consejo:</strong> Puede seguir entrando en su cartera original dejando la passphrase vacía."
  },
  enable: "Activar passphrase",
  error: {
    e104: "El cambio en la característica de passphrase fue abortado."
  },
  how: {
    button: "Cómo se ve",
    message: "Una passphrase no funciona como una contraseña a las que estamos habituados. Si se equivoca en un carácter de su passphrase, no será notificado. Esto es porque <strong>cada passphrase crea una cartera diferente y válida al mismo tiempo</strong>. Esto significa que se pueden utilizar tantas pasprases como carteras se deseen. Pero solo se puede acceder a cada cartera cuando se introduce su passphrase correspondiente.\nCuando conecte su BotBox02, será preguntado por su contraseña como siempre. Después, se le solicitará que introduzca la passphrase en el dispositivo.\nTras introducir la passphrase, se le mostrará la passphrase que ha introducido. Esto es para confirmar que ha sido introducida correctamente.",
    title: "Como funciona"
  },
  intro: {
    message: "Una passphrase proporciona una capa de seguridad por encima de su cartera.\nAprendamos cómo funciona.",
    title: "Configurar passphrase"
  },
  progressDisable: {
    message: "Confirme en su BitBox que quiere <strong>desactivar</strong> la opción de passphrase.",
    title: "Confirme en el dispositivo"
  },
  progressEnable: {
    message: "Confirme en su BitBox que quiere <strong>activar</strong> la opción de passphrase.",
    title: "Confirme en el dispositivo"
  },
  successDisabled: {
    message: "Passphrase opcional <strong>activada satisfactoriamente</strong>!\nA partir de ahora se le solicitara introducir una passphrase.",
    messageEnd: "Por favor vuelva a conectar ahora su BitBox02.",
    title: "Passphrase activado"
  },
  successEnabled: {
    message: "Passphrase opcional <strong>desactivada satisfactoriamente</strong>!\nA partir de ahora no se le solicitará introducir una passphrase.",
    messageEnd: "Por favor vuelva a conectar su BitBox02 ahora.",
    tips: "Consejos",
    tipsList: [
      "Le sugerimos enviar una pequeña cantidad a su cartera con passphrase primero. Después desconecte y vuelva a conectar la BitBox02 e introduzca su contraseña y su passphrase. Si ha introducido la passphrase correctamente, debería ver las monedas en su cartera.",
      "Si quiere entrar en su cartera original sin passphrase, puede seguir haciéndolo no introduciendo nada cuando le solicite introducir la passphrase. O puede desactivar la característica de passphrase."
    ],
    title: "Passphrase desactivada"
  },
  summary: {
    button: "Activar passphrase",
    title: "Resumen",
    understand: "Entiendo como funciona la passphrase y sus riesgos asociados.",
    understandList: [
      "La passphrase es una capa adicional de seguridad por encima de su copia de seguridad.",
      "Introducir un passphrase diferente siempre generará carteras diferentes.",
      "Para restaurar su cartera necesita <strong>tanto la passphrase como la copia de seguridad</strong>.",
      "Si olvidas tu frase de contraseña, ya no podrás <strong>acceder a tus monedas</strong>."
    ]
  },
  what: {
    button: "Aprenda como funciona",
    message: "Una billetera se crea (deriva) a partir de un número aleatorio muy grande, también conocido como semilla. Esta semilla se crea cuando configuras por primera vez tu BitBox02 y se respalda con la tarjeta microSD o las palabras de recuperación. Cualquiera que tenga acceso a la semilla tiene control total sobre los fondos de esa billetera.\n\nUna frase de contraseña es un <strong>secreto opcional</strong>, añadido a la semilla. Cuando se utiliza una frase de contraseña, cada frase de contraseña crea una nueva billetera basada en la semilla + frase de contraseña (secreto opcional). Una frase de contraseña puede ser cualquier cosa: letras, palabras, caracteres especiales o incluso puede estar vacía. De hecho, la billetera predeterminadamente se deriva de la semilla + frase de contraseña vacía.\n\nLa frase de contraseña forma parte del estándar BIP39, lo que significa que es compatible con todos las billeteras que admitan el mismo estándar.",
    title: "¿Qué es una passphrase?"
  },
  why: {
    button: "Porqué utilizar una passphrase",
    message: 'La BitBox02 protege la semilla contra la extracción desde el propio dispositivo, pero la copia de seguridad (tarjeta microSD o palabras de recuperación) da acceso completo a la billetera. ¡Por eso debe guardarse en un lugar seguro!\n\n\nDado que una frase de contraseña crea una nueva billetera utilizando tu semilla existente, la billetera con frase de contraseña requiere tanto tu <strong>reserva de seguridad</strong> COMO tu frase de contraseña para restaurarla. La ventaja de esto es que si alguien encuentra tu copia de seguridad, seguirá necesitando la frase de contraseña para acceder a la billetera con la frase de contraseña.\n\n\nAdemás, la función de la frase de contraseña permite crear varias billeteras en el mismo dispositivo, o "billeteras ocultas", además del predeterminado.',
    title: "¿Porqué utilizar una passphrase?"
  }
};
const password$3 = {
  show: "Mostrar {{label}}",
  warning: {
    caps: "AVISO: el bloqueo de mayúsculas (⇪) está activado",
    paste: 'para pegar texto, activa "MOSTRAR {{label}}"'
  }
};
const random$4 = {
  button: "Generar número aleatorio",
  description: "Tu BitBox ha generado el siguiente número aleatorio de {{bits}} bits:"
};
const receive$5 = {
  bitsuranceWarning: "Esta es una cuenta asegurada, lo que significa que sólo puede recibir a Segwit Nativo. Esto es para que no recibas accidentalmente a Wrapped Segwit o Taproot, que no están asegurados.",
  changeScriptType: "Tipo de dirección del cambio",
  label: "Tu dirección",
  onlyThisCoin: {
    description: "Para recibir otros tokens, por favor actívalos en la configuración. Si depositas otros tokens, podrían no ser accesibles. ",
    warning: "Asegúrate de recibir solo {{coinName}} en esta dirección."
  },
  scriptType: {
    p2tr: "Taproot (Nuevo formato)",
    p2wpkh: "Native Segwit (por defecto)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatible)"
  },
  selectAccount: "Seleccionar cuenta ",
  showFull: "Muestra y verifica la dirección completa en el dispositivo",
  taprootWarning: "Nota: Taproot es una nueva característica de Bitcoin y todavía no es ampliamente aceptada. Los fondos recibidos en direcciones Taproot pueden no ser mostradas en carteras de terceros. Muchas carteras y exchanges no pueden enviar a direcciones Taproot.",
  title: "Recibe {{accountName}}",
  verify: "Verificar la dirección de forma segura",
  verifyBitBox01: "Verifica la dirección completa en la app móvil",
  verifyBitBox02: "Verifica la dirección en la BitBox02",
  verifyInstruction: "Por favor, verifica que esta dirección encaja con la de tu dispositivo.",
  warning: {
    secureOutput: "Por favor, sincroniza su BitBox con tu dispositivo móvil para activar la verificación segura de la dirección. Ve a 'Administrar dispositivo' en la barra lateral."
  }
};
const reset$3 = {
  description: "Todos los datos serán borrados de este dispositivo. ¡Eso incluye tu clave privada!",
  notReset: "Dispositivo NO reseteado.",
  title: "Resetear dispositivo de fábrica",
  understand: "Tengo una copia de seguridad y conozco mi contraseña de recuperación",
  understandBB02: "Tengo una copia de seguridad válida"
};
const securityInformation$3 = {
  create: {
    description1: "Antes de configurar su dispositivo, se recomienda que lo hagas en un entorno seguro.",
    description2: "Se le pedirá que crea dos contraseñas.",
    description3: "La primera es la <strong>contraseña del dispositivo</strong> que desbloquea su dispositivo BitBox y puede cambiarse más tarde.",
    description4: "El segundo es el <strong>contraseña de recuperación</strong> que desbloquea tu monedero. Esta contraseña no se puede cambiar más tarde.",
    description5: "Se realizará una copia de seguridad del monedero que creaste en un archivo de la tarjeta micro SD proporcionada. Esto se puede usar en una emergencia para recuperar tus fondos usando tu <strong>contraseña de recuperación</strong>.",
    title: "Información de seguridad"
  },
  restore: {
    description1: "Se te pedirá que insertes la tarjeta micro SD que utilizó para guardar su copia de seguridad.",
    description2: "Para recuperar tu dispositivo necesitarás tu contraseña de recuperación. ",
    description3: "Por favor ten cuidado al ingresar la contraseña de recuperación. Cualquier contraseña que ingreses creará un monedero válida. Si introduces la contraseña incorrecta, es posible que ves un saldo del monedero que no esperas.",
    title: "Información de seguridad"
  }
};
const seed$3 = {
  agreements: {
    "funds-access": "NO podré acceder a mis fondos si olvido mi contraseña de recuperación",
    "password-change": "NO puedo cambiar la contraseña de recuperación más tarde",
    "password-required": "La contraseña de recuperación es necesaria para restaurar un monedero desde una copia de seguridad"
  },
  create: "Crea monedero",
  creating: "Creando monedero",
  description: "Entiendo que:",
  error: {
    e102: "La contraseña debe contener al menos 4 caracteres.",
    e200: "Debe insertar una tarjeta micro SD en su BitBox para crear un mondero, de modo que se pueda crear una copia de seguridad automáticamente."
  },
  info: {
    button: "Establecer contraseña de recuperación ahora",
    description1: "Inserta la tarjeta micro SD en el BitBox",
    description2: 'Elija una contraseña de recuperación para el monedero y seleccione "Establecer contraseña de recuperación ahora"',
    description3: "La copia de seguridad en la tarjeta micro SD y su contraseña de recuperación es el único método para recuperar sus fondos en caso de pérdida o robo del dispositivo BitBox.",
    description4: "No puede cambiar su contraseña de recuperación más adelante sin transferir sus fondos.",
    title: "Crear una cartera nueva"
  },
  password: {
    label: "Contraseña de recuperación",
    repeatPlaceholder: "Repita la contraseña de recuperación"
  },
  walletName: {
    label: "Nombre del monedero"
  }
};
const seedRestore$3 = {
  error: {
    e200: "La recuperación de un monedero a partir de una copia de seguridad requiere la tarjeta micro SD."
  },
  info: {
    description1: 'Inserta la tarjeta micro SD en el BitBox y haga clic en "Continuar"',
    description2: 'Elija una copia de seguridad y haga clic en "Restablecer"',
    description3: "Ingresa la contraseña de recuperación",
    description4: "Debes confirmar para entender que una contraseña incorrecta creará una cartera diferente.",
    title: "Cómo restaurar un monedero desde una copia de seguridad"
  }
};
const send$5 = {
  abort: "La transacción ha sido cancelada.",
  address: {
    label: "Dirección del receptor",
    placeholder: "Introduce dirección!"
  },
  amount: {
    label: "Cantidad",
    placeholder: "Introduzca la cantidad"
  },
  availableBalance: "Saldo disponible",
  button: "Revisar ",
  coincontrol: {
    address: "Dirección",
    outpoint: "Anotar",
    title: "Enviar desde salida"
  },
  confirm: {
    "selected-coins": "Monedas seleccionadas",
    title: "Confirma y envía la transacción",
    total: "Total"
  },
  error: {
    erc20InsufficientGasFunds: "Parece que no tiene suficiente Ether para pagar esta transacción ERC20. Por favor, asegúrese de que tiene suficiente Ether en su wallet.",
    feeTooLow: "La tarifa de red es demasiado baja",
    feesNotAvailable: "No se pueden estimar las tarifas de red",
    insufficientFunds: "fondos insuficientes",
    invalidAddress: "dirección inválida",
    invalidAmount: "Cantidad inválida",
    invalidData: "Datos inválidos"
  },
  fee: {
    customPlaceholder: "Introduzca la cantidad",
    label: "Tarifa de red",
    placeholder: "No disponible"
  },
  feeTarget: {
    customLabel: "Tarifa de red",
    customLabel_eth: "Precio del Gas",
    description: {
      economy: "24 bloques (alrededor de 4 horas para Bitcoin, 1 hora para Litecoin)",
      economy_eth: "30 minutos o menos",
      economy_ltc: "1 hora (24 bloques)",
      high: "2 bloques (alrededor de 20 minutos para Bitcoin, 5 minutos para Litecoin)",
      high_eth: "30 segundos o menos",
      high_ltc: "5 minutos (2 bloques)",
      low: "12 bloques (alrededor de 2 horas para Bitcoin, 30 minutos para Litecoin)",
      low_eth: "5 minutos o menos",
      low_ltc: "30 minutos (12 bloques)",
      normal: "6 bloques (alrededor de 1 hora para Bitcoin, 15 minutos para Litecoin)",
      normal_eth: "2 minutos o menos",
      normal_ltc: "15 minutos (6 bloques)"
    },
    estimate: "Tiempo de espera estimado:",
    label: {
      custom: "A medida",
      economy: "Económico",
      high: "Alto",
      low: "Bajo",
      normal: "Normal"
    },
    placeholder: "Calculando la tarifa de red..."
  },
  maximum: "Enviar todo",
  maximumSelectedCoins: "Enviar monedas seleccionadas",
  noFeeTargets: "Las estimaciones de tarifas no están disponibles actualmente. Vuelva a intentarlo más tarde o introduzca una tarifa personalizada.",
  priority: "Prioridad",
  scanQR: "Escanear código QR",
  signprogress: {
    description: "Esta es una transacción que contiene una gran cantidad de datos. Para firmar en su totalidad la transacción, se le pedirá que confirme {{steps}} veces.",
    label: "En curso"
  },
  success: "La transacción ha sido firmada y enviada.",
  title: "Envía {{accountName}}",
  toggleCoinControl: "Activar/Desactivar control de monedas/UTXO",
  transactionDetails: "Detalles de la transacción"
};
const settings$4 = {
  about: "Acerca de",
  accounts: "Cuentas",
  advancedSettings: "Configuración avanzada",
  appearance: "Apariencia",
  electrum: {
    add: "Añadir un servidor",
    "add-server": "Añadir",
    check: "Comprobar",
    checkFailed: "Falló",
    checkSuccess: "La conexión establecida con éxito a {{host}}",
    checking: "Comprobación",
    "download-cert": "Descarga certificado remoto",
    "remove-server": "Elimina",
    removeConfirm: "Eliminar {{server}}?",
    reset: "Restablecer a predeterminados",
    resetConfirm: "¿Desea eliminar todos los servidores e instalar los servidores predeterminados?",
    servers: "Servidores",
    step1: "1",
    "step1-text": "Introduzca el punto final.",
    step2: "2",
    "step2-text": "Introduzca un certificado de la cadena de certificados del servidor. Alternativamente, descarga el certificado remoto y compárelo visualmente.",
    "step2-text-tcp": "Puedes omitir este paso si no quieres utilizar TLS.",
    step3: "3",
    "step3-text": "Comprueba la conexión y añade el servidor.",
    step4: "4",
    "step4-text": "Reinicia el monedero. Si no eliminas los servidores predeterminados, tu propio nodo se agregará como redundancia.",
    "title-btc": "Servidores de Bitcoin Electrum",
    "title-ltc": "Servidores de Litecoin Electrum",
    "title-tbtc": "Servidores de Bitcoin Testnet Electrum",
    "title-tltc": "Servidores de Litecoin Testnet Electrum"
  },
  expert: {
    coinControl: "Activa control de monedas",
    electrum: {
      description: "Puedes conectarte a tu propio nodo Electrum completo.",
      title: "Conecta tu propio nodo completo"
    },
    fee: "Activar tarifas de red personalizadas",
    setProxyAddress: "Establece dirección proxy",
    title: "Configuración avanzada",
    useProxy: "Activar tor proxy",
    useSats: "Mostrar valores BTC en Satoshis"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nueva actualización disponible",
    title: "Información",
    "up-to-date": "Su aplicación está actualizada",
    version: "Versión del App"
  },
  restart: "Por favor, reinicia la BitBoxApp para que los cambios tengan efecto.",
  services: {
    title: "Servicios"
  },
  success: "Por favor desenchufa y vuelva a enchufar el BitBox para que los cambios surjan efecto.",
  title: "Ajustes"
};
const setup$3 = "Dispositivo de configuración";
const sidebar$4 = {
  buy: "Compra criptomoneda",
  device: "Administra dispositivo",
  insurance: "Seguro",
  leave: "Salir",
  settings: "Ajustes"
};
const success$a = {
  create: {
    info1: "Su monedero se ha respaldado de manera segura en la tarjeta micro SD. Retírelo y guárdalo en un lugar seguro. ",
    info2: "Has creado una contraseña de dispositivo seguro que desbloquea el BitBox.",
    info3: "Has creado una contraseña de recuperación segura para su monedero que desbloquea sus fondos y recupera sus copias de seguridad.",
    summary: "Aquí hay un resumen de lo que has hecho.",
    title: "Éxito"
  },
  getstarted: "Empieza",
  restore: {
    summary: "Has restaurado con éxito un monedero de su copia de seguridad.",
    title: "Éxito"
  }
};
const transaction$4 = {
  confirmation: "Confirmaciones",
  details: {
    activity: "Actividades",
    address: "Dirección",
    amount: "Cantidad",
    date: "Fecha",
    fiat: "Fiat",
    fiatAmount: "Cantidad Fiat",
    fiatAtTime: "Fiat en el momento de la transacción",
    status: "Estado",
    title: "Detalles de la transacción",
    type: "Tipo"
  },
  explorer: "ID de transacción",
  explorerTitle: "Abrir en el bloque externo Explorer",
  fee: "Tarifa de red",
  fiatHistorical: "Historial",
  gas: "Gas",
  note: {
    edit: "Edita nota",
    save: "Guarda nota"
  },
  pending: "Transacción pendiente",
  size: "Tamaño",
  status: {
    complete: "Acabado",
    failed: "Falló",
    pending: "Pendiente"
  },
  tx: {
    received: "Recibido a",
    sent: "Enviado a"
  },
  vsize: "Tamaño virtual",
  weight: "Peso"
};
const transactions$3 = {
  errorLoadTransactions: "Se ha producido un error al cargar las transacciones",
  placeholder: "Sin transacciones todavía."
};
const unknownError$3 = "Ocurrió un error desconocido: {{errorMessage}}";
const unlock$3 = {
  description: "Ingresa la contraseña de tu dispositivo para desbloquear el dispositivo.",
  error: {
    e109_normal: "Contraseña incorrecta del dispositivo. {{remainingAttempts}} intentos permanecen antes de que el dispositivo se reinicie.",
    e109_touch: "$t(unlock.error.e109_normal) El siguiente inicio de sesión requiere mantener presionado el botón táctil.",
    e113: "Debido a muchos intentos de inicio de sesión, el siguiente inicio de sesión requiere mantener presionado el botón táctil durante 4 segundos."
  },
  input: {
    label: "Contraseña del dispositivo",
    placeholder: "Ingresa la contraseña de tu dispositivo para desbloquear el dispositivo"
  },
  unlocking: "Desbloqueando..."
};
const upgradeFirmware$4 = {
  button: "Actualización de firmware",
  description: "¿Quieres actualizar el Firmware de la versión {{currentVersion}} a {{newVersion}}?",
  label: "Se requiere una actualización de firmware para tu BitBox.",
  locked: "Para actualizar desde {{currentVersion}} a {{newVersion}}, por favor haz un toque largo.",
  title: "Actualización de firmware",
  unlocked: "El gestor de arranque está desbloqueado. Para continuar, por favor:",
  unlocked1: "Desconecta y vuelva a conectar su Bitbox",
  unlocked2: "El LED se encenderá cuando su BitBox se vuelva a enchufar.",
  unlocked3: "Toque el botón táctil cuando el LED se encienda"
};
const walletConnect$4 = {
  connect: {
    button: "Conectar",
    dappLabel: "Introduzca la dirección URI de la aplicación ",
    invalidPairingUri: "Uri de emparejamiento no válido"
  },
  dashboard: {
    allSessions: "Todas las sesiones",
    disclaimer: "Walletconnect es un protocolo para conectarse a dapps basadas en Ethereum. Estas dapps están gestionadas por servicios de terceros, así que conéctate solo a dapps en las que confíes y asegúrate de saber siempre lo que estás firmando al realizar una transacción.",
    newConnection: "Nueva conexión",
    noConnectedSessions: "Actualmente no hay cuentas conectadas a ninguna dapps."
  },
  invalidPairingChain: "Error al aprobar el emparejamiento. Asegúrese de utilizar una de las cadenas admitidas: {{cadenas}}",
  pairingRequest: {
    approve: "Aprobar conexión",
    reject: "Rechazar",
    title: "Nueva solicitud de conexión de"
  },
  pairingSuccess: "Dapp conectada con éxito. Puede continuar en el sitio web de la dapp.",
  signingRequest: {
    account: "Cuenta",
    chain: "Cadena",
    dapp: "Dapp",
    data: "Datos",
    dataParsingError: "Error al analizar los datos",
    decodeError: "No se ha podido descodificar el mensaje",
    method: {
      sendTransaction: "Firmar y enviar la transacción",
      signMessage: "Firmar el mensaje",
      signTransaction: "Firmar la transacción",
      signTypedData: "Firmar los datos escritos"
    },
    successfullySigned: "Solicitud firmada con éxito",
    walletConnectRequest: "Solicitud de WalletConnect"
  },
  useNewUri: "Este URI ya ha sido utilizado para intentar una conexión. Por favor, utilice un nuevo URI.",
  walletConnect: "WalletConnect"
};
const warning$9 = {
  receivePairing: "Por favor, sincroniza el BitBox para activar la verificación segura de la dirección. Ve a 'Administrar dispositivo' en la barra lateral.",
  sdcard: "Manten la tarjeta micro SD guardada aparte del BitBox, a menos que desee administrar las copias de seguridad.",
  sendPairing: "Por favor, sincroniza el BitBox para verificar con seguridad los detalles de la transacción. Vaya a 'Administrar dispositivo' en la barra lateral."
};
const welcome$3 = {
  connect: "Conecta tu BitBox02",
  getStarted: "Vamos a comenzar instalando el firmware en su BitBox02.",
  insertBitBox02: "Si estás usando BitBox02, por favor toca el dispositivo para continuar.",
  insertDevice: "Por favor conecta tu dispositivo para comenzar",
  title: "Bienvenido"
};
const appTranslationsES = {
  account: account$3,
  accountInfo: accountInfo$3,
  accountSummary: accountSummary$3,
  addAccount: addAccount$4,
  aopp: aopp$2,
  app: app$3,
  auth: auth$3,
  backup: backup$3,
  bb02Bootloader: bb02Bootloader$3,
  bitbox: bitbox$3,
  bitbox02Interact: bitbox02Interact$3,
  bitbox02Settings: bitbox02Settings$3,
  bitbox02Wizard: bitbox02Wizard$3,
  bitsurance: bitsurance$2,
  bitsuranceAccount: bitsuranceAccount$2,
  blink: blink$3,
  bootloader: bootloader$3,
  button: button$8,
  buy: buy$4,
  changePin: changePin$3,
  chart: chart$4,
  checkSDcard: checkSDcard$3,
  clickHere: clickHere$3,
  confirm: confirm$5,
  confirmOnDevice: confirmOnDevice$3,
  connectKeystore: connectKeystore$3,
  darkmode: darkmode$3,
  device: device$3,
  deviceLock: deviceLock$3,
  deviceSettings: deviceSettings$3,
  deviceTampered: deviceTampered$3,
  dialog: dialog$4,
  error: error$4,
  fiat: fiat$5,
  footer: footer$5,
  generic: generic$4,
  genericError: genericError$3,
  goal: goal$3,
  guide: guide$4,
  headerssync: headerssync$3,
  hiddenWallet: hiddenWallet$3,
  initialize: initialize$3,
  invalidFormat: invalidFormat$3,
  language: language$4,
  legacyhiddenwallet: legacyhiddenwallet$3,
  loading: loading$3,
  manageAccounts: manageAccounts$2,
  mobile: mobile$3,
  newSettings: newSettings$2,
  note: note$4,
  notification: notification$3,
  pairing: pairing$3,
  passphrase: passphrase$2,
  password: password$3,
  random: random$4,
  receive: receive$5,
  reset: reset$3,
  securityInformation: securityInformation$3,
  seed: seed$3,
  seedRestore: seedRestore$3,
  send: send$5,
  settings: settings$4,
  setup: setup$3,
  sidebar: sidebar$4,
  success: success$a,
  transaction: transaction$4,
  transactions: transactions$3,
  unknownError: unknownError$3,
  unlock: unlock$3,
  upgradeFirmware: upgradeFirmware$4,
  walletConnect: walletConnect$4,
  warning: warning$9,
  welcome: welcome$3
};
const account$2 = {
  disconnect: "Povezava je prekinjena. Poizkušam ponovno...",
  "export": "Izvoz",
  exportTransactions: "Izvozite transakcije v CSV datoteko in odložite v lokalno mapo.",
  fatalError: "Ups, nepričakovana napaka",
  incoming: "Dohodni",
  initializing: "Pridobivam podatke iz verige blokov...",
  insuranceExpired: "<strong>Račun ni več zavarovan</strong>\n\nZavarovanje za ta račun je bilo spremenjeno. Za več informacij, prosimo preverite stran o zavarovanju.",
  insured: "Zavarovan račun",
  maybeProxyError: "Tor proxy omogočen. Prepričajte se, da Tor proxy deluje pravilno, ali onemogočite proxy.",
  reconnecting: "Povezava je prekinjena, poizkušam s ponovno vzpostavitvijo...",
  syncedAddressesCount: "Prešteto št. naslovov: {{count}}",
  uncoveredFunds: "Kovance imate na naslednjih nezavarovanih vrstah naslovov vašega računa <strong>{{name}}</strong>: {{uncovered}}. \nKer je račun zavarovan, so zajeti samo kovanci, prejeti preko naslova <strong>Native Segwit</strong>. Kovanci na ostalih vrstah naslovov, tudi če so na istem računu, niso zavarovani.\nPredlagamo, da premaknete vse kovance z nepodprtih tipov naslova na <strong>Native Segwit</strong> naslov, da bodo vsi kovanci na tem računu zavarovani. Hvala!",
  uncoveredFundsLink: "Za premik kovancev sledite temu navodilu.",
  warning: "Pozor!"
};
const accountInfo$2 = {
  address: "Naslov",
  buyCTA: {
    buy: "Kupi",
    buyCrypto: "Kupi kripto",
    information: {
      looksEmpty: "Denarnica je prazna.",
      start: "Začnite tako, da pošljete nekaj kovancev v denarnico ali jih kupite neposredno v aplikaciji BitBoxApp."
    }
  },
  extendedPublicKey: "Razširjen javni ključ",
  label: "Podatki o računu",
  scriptType: "Tip skripte",
  title: "Podatki o računu",
  verify: "Potrdi na napravi",
  xpubTypeChangeBtn: {
    p2pkh: "Ogled razširjenega javnega ključa P2PKH",
    p2tr: "Oglejte Taproot",
    p2wpkh: "Ogled Native Segwit",
    "p2wpkh-p2sh": "Ogled razširjenega javnega ključa P2SH"
  },
  xpubTypeInfo: "Prikazan je {{scriptType}} razširjen javni ključ ({{current}} od {{numberOfXPubs}})"
};
const accountSummary$2 = {
  availableBalance: "Razpoložljivo stanje",
  balance: "Stanje",
  exportSummary: "Izvozi povzetek računa v mapo za prenos, kot datoteko CSV",
  fiatBalance: "Stanje v fiat valuti",
  name: "Ime računa",
  noAccount: "Ni računov za prikaz.",
  subtotalWithCoinName: "Skupaj ({{coinName}})",
  title: "Moj portfelj",
  total: "Skupaj",
  transactionHistory: "Zgodovina transakcij"
};
const addAccount$3 = {
  chooseName: {
    nextButton: "Dodaj račun",
    step: "Poimenuj račun",
    title: "Poimenuj račun"
  },
  selectCoin: {
    nextButton: "Naprej",
    step: "Izberi kovanec",
    title: "Izberi kriptovaluto"
  },
  success: {
    addAnotherAccount: "Dodajte nov račun",
    message: "<strong> {{accountName}} </strong> je zdaj dodan med vaše račune.",
    nextButton: "OK",
    step: "Zaklljučeno",
    title: "Račun dodan"
  },
  title: "Dodajte račun"
};
const aopp$1 = {
  addressRequest: "{{host}} zahteva naslov prejemnika.",
  addressRequestWithLogo: "zahteva naslov prejemnika",
  banner: "Zahteva po naslovu je v teku. Priklopite BitBox02 za nadaljevanje.",
  errorTitle: "Napaka med zahtevo za naslov",
  labelAddress: "Naslov",
  labelMessage: "Sporočilo",
  reverifyInfoText: "Potrdite naslov",
  signing: "Za nadaljevanje podpišite sporočilo na napravi",
  success: {
    message: "Nadaljujte na {{host}}",
    title: "Naslov uspešno poslan"
  },
  syncing: "Počakajte trenutek, poteka sinhronizacija računa.",
  title: "Zahteva za naslov"
};
const app$2 = {
  upgrade: "Na voljo je nova verzija te aplikacije! Prosimo vas, da jo nadgradite iz verzije  {{current}} na {{version}}."
};
const auth$2 = {
  authButton: "Potrdi",
  title: "Za nadaljevanje potrdite"
};
const backup$2 = {
  check: {
    checking: "Preverjam varnostno kopijo...",
    confirmTitle: "Preverite varnostno kopijo",
    notOK: "Varnostna kopija se NE ujema s trenutno denarnico.",
    ok: "Varnostna kopija se ujema z denarnico.",
    password: {
      label: "Geslo za obnovo varnostne kopije",
      placeholder: "Geslo za obnovo varnostne kopije",
      showLabel: "geslo za obnovo varnostne kopije"
    },
    success: "Varnostna kopija uspešno preverjena:",
    title: "Preverite varnostno kopijo"
  },
  create: {
    alreadyExists: "Veljavno varnostno kopijo že imate. Ali jo ponovno želite ustvariti?",
    fail: "Ustvarjanje varnostne kopije NI uspelo!",
    info: "Prosimo vnesite geslo za obnovo trenutne denarnice za potrditev.",
    name: {
      label: "Ime varnostne kopije",
      placeholder: "Poimenujte varnostno kopijo"
    },
    password: {
      label: "Obnovitveno geslo",
      placeholder: "Prosimo vnesite obnovitveno geslo"
    },
    title: "Ustvarite varnostno kopijo - backup",
    verificationFailed: 'Obnovitveno geslo se NE ujema s trenutno denarnico. Varnostna kopija je bila ustvarjena. Prosimo uporabite "Preverite varnostno kopijo" da potrdite geslo za obnovo.'
  },
  description: "Izberite <strong>datoteko z varnostno kopijo denarnice</strong>",
  insert: "Prosimo vstavite microSD kartico za upravljanje z varnostnimi kopijami.",
  insertButton: "Vstavil sem microSD kartico",
  list: "Varnostne kopije na microSD kartici",
  noBackups: "Na tej microSD kartici ni varnostnih kopij.",
  restore: {
    confirmTitle: "Obnovite varnostno kopijo",
    error: {
      e200: "MicroSD kartica ni bila zaznana",
      general: "Napaka pri obnovitvi varnostne kopije"
    },
    password: {
      label: "Geslo za obnovitev ali skrito geslo za obnovitev varnostne kopije",
      placeholder: "Geslo za obnovitev",
      repeatPlaceholder: "Ponovite geslo za obnovitev",
      showLabel: "Geslo za obnovitev"
    },
    restoring: "Obnavljanje varnostne kopije ...",
    selectedBackup: "<strong>{{backupName}}</strong> ustvarjen {{createdDateTime}} bo obnovljen.",
    title: "Obnovi",
    understand: "Razumem, da bo nepravilno geslo za obnovitev ustvarilo drugo, novo denarnico"
  },
  showMnemonic: {
    description: "Na BitBox02 se bodo izpisale besede, ki tvorijo varnostno kopijo denarnice. Zapišite jih na papir.\n\n<strong>Ne hranite jih digitalno in ne fotografirajte jih!</strong>\n\n<strong>Ne izgovarjajte besed na glas.</strong>\n\n<strong>Ta varnostna kopija ni zaščitena z geslom.</strong>\n\nPo končanem prikazu besed boste morali vsako še potrditi na napravi.",
    title: "Prikaži seznam besed",
    warning: "<strong>Nikoli ne delite obnovitvenih besed z nikomer.</strong> Te besede omogočajo popoln dostop do vaše denarnice. Če vas kdo sprašuje po teh besedah, gre zelo verjetno za prevaro. Ne delite jih z neznanci!"
  },
  title: "Upravljanje varnostnih kopij"
};
const bb02Bootloader$2 = {
  abort: "Ne nadgradi - vrni me nazaj",
  abort_noUpgrade: "Vrni me nazaj",
  advanced: {
    label: "Napredne nastavitve",
    toggleShowFirmwareHash: "Ob zagonu vedno prikaži binarno vrednost strojne programske opreme (firmware hash)"
  },
  flipscreen: "Obrnite sliko na zaslonu",
  orientation: "Je zaslon na napravi obrnjen v napačno smer?",
  success: "Nadgradnja uspešna! Nadaljevanje v {{rebootSeconds}} sekundah...",
  success_install: "Namestitev uspešna! Nadaljevanje v {{rebootSeconds}} sekundah..."
};
const bitbox$2 = {
  error: {
    e10000: "Trenutno geslo naprave je napačno.",
    e10001: "Gesla naprave ni bilo mogoče zamenjati",
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e112: "Geslo skrite denarnice ne more biti enako kot geslo glavne denarnice."
  }
};
const bitbox02Interact$2 = {
  confirmDate: "Potrdite današnji datum na BitBox02",
  confirmDateText: "Vnešen datum bo uporabljen za kreiranje varnostne kopije.",
  confirmName: "Potrdite ime na zaslonu BitBox02",
  confirmWords: "Zapišite si {{amount}} obnovitvenih besed iz vašega BitBoxa",
  confirmWordsText: "Po tem koraku BitBox02 zahteva potrditev vsake besede na zaslonu, da se prepričate, da ste varnostno kopijo zapisali pravilno.",
  followInstructions: "Prosimo upoštevajte navodila na zaslonu naprave.",
  followInstructionsMnemonic: "Upoštevajte navodila za obnovitev iz seznama besed na napravi in obnovite denarnico.",
  followInstructionsMnemonicTitle: "Obnovi iz seznama besed"
};
const bitbox02Settings$2 = {
  deviceName: {
    current: "Trenutno ime naprave",
    error: "Imena naprave ni bilo mogoče nastaviti",
    error_104: "Potrditev imena je bilo prekinjeno na napravi",
    input: "Novo ime",
    placeholder: "Novo ime naprave",
    title: "Nastavite ime tej napravi"
  },
  gotoStartupSettings: {
    description: "To bo znova zagnalo vaš BitBox02 in začelo nastavitev zagona.",
    title: "Pojdite na začetne nastavitve"
  }
};
const bitbox02Wizard$2 = {
  advanced: {
    button: "Napredne možnosti",
    outOfDate: "Strojna programska oprema (firmware) je prestara za to funkcijo",
    seed12WordInfo: "Število besed kasneje ni možno spremeniti.",
    seed12WordLabel: "Ustvari 12 besedno seme namesto 24 besednega",
    seed12WordText: "BitBox privzeto uporablja 24 besedno seme. Na voljo je tudi 12 besedno seme. Obe podprti dolžini semena sta dovolj varni proti strojnemu uganjevanju (brute force). ",
    skipSDCardLabel: "Ne ustvari varnostne kopije na micro SD kartico ampak prikaži semenske besede",
    skipSDCardText: "Kasneje lahko vedno ustvarite varnostno kopijo na micro SD kartico ali ponovno prikažete semenske besede. To opcijo najdete v Nastavitvah.",
    title: "Napredne možnosti arhivske kopije"
  },
  attestationFailed: "Preverjanje ni uspelo, kar je lahko posledica ponovnega zagona aplikacije, medtem ko je naprava čakala na uporabniški vnos (dotik). Napravo znova vklopite in poskusite znova. Če težava ne izgine, se obrnite na support@bitbox.swiss (v angleščini).",
  backup: {
    point1: "Izberite varnostno kopijo na microSD kartici",
    point2: "Nastavite geslo za svojo napravo",
    restoreText: "Ok, obnovimo varnostno kopijo!",
    text1: "Super, vaše geslo za BitBox02 je zdaj nastavljeno in denarnica je ustvarjena. Zdaj je čas, da ustvarite prvo varnostno kopijo. Prepričajte se, da je microSD kartica vstavljena v BitBox02 in nato nadaljujte.",
    text2: "Če želite ustvariti varnostno kopijo, sledite navodilom na zaslonu naprave.",
    text3: "Ko ustvarite varnostno kopijo, odstranite microSD kartico in jo shranite na <strong>varno lokacijo</strong>. Vsebina kartice ni zaščitena z geslom. Nikoli je ne vstavite v nobeno drugo napravo, razen v vaš BitBox02.",
    userConfirmation1: "Varnostno kopijo je potrebno hraniti na varnem mestu",
    userConfirmation2: "Moja varnostna kopija ni zaščitena z geslom. Vsak, ki ima dostop do nje, lahko dostopa do moje denarnice.",
    userConfirmation3: "Če izgubim ali poškodujem svoj BitBox02, je edini način, da povrnem svoja sredstva, obnovitev iz varnostne kopije.",
    userConfirmation4: "Če izgubim ali poškodujem tako varnostno kopijo kot svoj BitBox02, so moja sredstva izgubljena.",
    userConfirmation5: "Ustvarjeno varnostno kopijo na microSD kartici ne smem vtakniti v PC, telefon, tiskalnik ali katero koli drugo napravo razen v BitBox02.",
    userConfirmation5mnemonic: "Semenskih besed NE bom vpisoval v računalnike, telefone, tablice ali katere koli druge naprave, kot le v BitBox02."
  },
  create: {
    button: "Poimenujte napravo in nadaljujte",
    info: "To so osnovni koraki, ki jih boste izvedli za nastavitev BitBoxa: ",
    inputTitle: "Ime denarnice",
    point1: "Poimenujte napravo",
    point2: "Izberite si geslo za svojo napravo",
    point3: "Ustvarite varnostno kopijo",
    text: "Ok, pa ustvarimo novo denarnico!"
  },
  createBackupAborted: "Kreiranje varnostne kopije je prekinjeno.",
  createBackupFailed: "Ustvarjanje varnostne kopije ni uspelo, poskusite znova.",
  initialize: {
    passwordText: "Zdaj pa določite geslo za vašo napravo. Za vnos in izbiro gesla uporabite kontrolne drsnike na BitBoxu.",
    passwordTitle: "Nastavite geslo za vaš BitBox",
    text: "Seznanjanje je bilo uspešno! Zdaj pa pripravimo vašo napravo. Začnite z ustvarjanjem nove denarnice ali obnovitvijo denarnice iz obstoječe varnostne kopije. <strong>Prepričajte se, da imate v BitBox02 vstavljeno microSD kartico </strong>",
    tip: "Priporočamo vam, da te postopke opravite v varnem in zasebnem okolju.",
    title: "Zaženite in nastavite BitBox02"
  },
  insertSDCard: "<strong>Prepričajte se, da imate v BitBox02 vstavljeno microSD kartico.</strong>",
  noPasswordMatch: "Gesli se nista ujemali. Poskusite znova.",
  pairing: {
    failed: "Seznanjanje je bilo prekinjeno. Ponovno priklopite BitBox02.",
    paired: "Na napravi ste potrdili, da se koda ujema. Prosimo nadaljujte.",
    title: "Potrditev seznanitvene kode",
    unpaired: "Zaznana je bila nova BitBox02 naprava. Preverite, ali se prikazana koda ujema s tisto na zaslonu naprave."
  },
  restoreFromMnemonic: {
    e104: "Ponastavitev iz semenskih besed je bilo ustavljeno.",
    failed: "Obnova iz seznama besed ni uspela. Poskusite znova."
  },
  stepBackup: {
    beforeProceed: "Pred nadaljevanjem preberite naslednje pomembne varnostne vidike:",
    createBackup: "Zdaj boste ustvarili varnostno kopijo na microSD kartici .",
    createBackupMnemonic: "Zdaj zapišite semenske besede na papir ali jeklo"
  },
  stepBackupSuccess: {
    fundsSafe: "Če želite ohraniti sredstva varna, upoštevajte naslednje:",
    title: "Varnostna kopija obnovljena!"
  },
  stepConnected: {
    unlock: "Vnesite izbrano geslo, kot ponazarja video"
  },
  stepCreate: {
    description: "To bo ime naprave in varnostne kopije.",
    error: {
      genericMessage: "Uporabite črke, številke, osnovne simbole, presledke. Največ 30 znakov.",
      invalidChars: "Ime vsebuje nepodprte znake: {{invalidChars}}.",
      tooLong: "Ime je predolgo."
    },
    nameLabel: "Vnesite željeno ime naprave",
    namePlaceholder: "Moj BitBox02",
    title: "Izberite ime za vaš BitBox02",
    toastMicroSD: "Vstavite microSD kartico v BitBox02. Na njo bo zapisana varnostna kopija denarnice."
  },
  stepCreateSuccess: {
    removeMicroSD: "Odstranite microSD kartico z naprave in jo shranite na varno mesto.",
    storeMnemonic: "Predlagamo, da shranite te obnovitvene besede na varno lokacijo",
    success: "Uspešno ste ustvarili varnostno kopijo."
  },
  stepInsertSD: {
    insertSDCard: "Vstavite microSD kartico v BitBox02.",
    insertSDcardTitle: "Vstavite microSD kartico"
  },
  stepPassword: {
    e104: "Nastavitev gesla je bila prekinjena.",
    title: "Nastavite geslo za BitBox02",
    useControls: "S pomočjo drsnikov na robu naprave si nastavite geslo."
  },
  stepUninitialized: {
    create: "Želim postaviti nov BitBox02.",
    restore: "Želim obnoviti denarnico iz varnostne kopije.",
    restoreMicroSD: "Obnovi iz microSD kartice",
    restoreMnemonic: "Obnovi iz seznama besed",
    title: "Nastavite svoj BitBox02"
  },
  success: {
    text: "Bravo! Vaš BitBox02 je zdaj pripravljen za uporabo.\n\nZa dodatne informacije o uporabi aplikacije BitBoxApp uporabite vodnik. Na voljo je s klikom na vprašaj v zgornjem desnem kotu.",
    title: "Zdaj ste pripravljeni za delo z BitBox denarnico!"
  }
};
const bitsurance$1 = {
  dashboard: {
    active: "Zavarovalna polica je aktivna",
    button: "Zavarujte nov račun",
    canceled: "Preklicano",
    coverage: "Najvišje kritje",
    inactive: "Neaktivno",
    processing: "Obdelujem",
    refused: "Zavrnjeno",
    supportLink: "Upravljanje pogodbe",
    title: "Zavarovani računi",
    waitpayment: "Čakamo plačilo"
  },
  detect: {
    button: "Preveri trenutno zavarovanje",
    insured: "Zaznan zavarovan račun:",
    notInsured: "Ni zaznanih zavarovanih računov. V kolikor ste prepričani, da imate zavarovane račune, preverite, da imate priključeno pravo denarnico.",
    text: "V kolikor že imate sklenjeno zavarovanje z Bitsurance lahko BitBoxApp samodejno prenese vaše obstoječe kritje.",
    title: "Ste že zavarovani?"
  },
  insure: {
    button: "Preverite cene in razpoložljivost",
    faq: "Preberite več na Bitsurance FAQ",
    listItem1: "Vlom",
    listItem2: "Izsiljevanje (npr. napad z nevarnim predmetom)",
    listItem3: "Uničenje zaradi požara, vode ali naravnih nesreč",
    month: "mesec",
    text: "Zavarujte svoj BitBox02 in bitcoin v protivrednosti do 100.000 €",
    text2: "Zavarovanja že od 30 € na leto (2,50 € na mesec). Več o zavarovalnici Bitsurance in njihovi natančni ponudbi zavarovanj preverite na ",
    text3: "Trenutno na voljo v Nemčiji, kmalu pa bo tudi drugje.",
    title: "Začnite"
  },
  intro: {
    link: "Spletna stran Bitsurance",
    text1: "BitBox sodeluje z družbo Bitsurance, da vam lahko ponudimo dodatno zaščito za vaš bitcoin. Medtem ko BitBox02 varuje vaša sredstva, Bitsurance krije grožnje na domu, ki jih ni mogoče ublažiti samo s tehnologijo, kot so vlom, izsiljevanje ali uničenje same strojne denarnice."
  },
  terms: {
    link: "Politika zasebnosti Bitsurance",
    text1: "Bitsurance je neodvisna storitev od BitBoxa. Za vprašanja v zvezi z njihovo ponudbo in zavarovalnimi zahtevki se vedno obrnite neposredno na Bitsurance.",
    text2: "Zavarovanje je trenutno na voljo le v Nemčiji, v drugih državah pa bo na voljo kasneje.",
    text3: "Najvišje trenutno razpoložljivo kritje Bitcoina je 100.000 € na osebo. Višji zneski bodo morda na voljo kasneje.",
    text4: "Osebni podatki in razširjeni javni ključ vašega zavarovanega računa so del zavarovalne police in bodo posredovani zavarovalnici Bitsurance in ponudniku zavarovanja.",
    text5: "Za več informacij o zasebnosti se obrnite na"
  },
  title: "Zavarovanje"
};
const bitsuranceAccount$1 = {
  errorNoXpub: "Napaka: xpub-a ni bilo mogoče pridobiti iz računa.",
  noAccount: "Ni računov, ki bi jih bilo mogoče zavarovati.",
  select: "Izberite račun",
  title: "Zavarovanje"
};
const blink$2 = {
  button: "Sproži utripanje na napravi"
};
const bootloader$2 = {
  button: 'Nadgradi "firmware"',
  button_install: "Namestite firmware",
  progress: "Nadgrajujem: {{progress}}%",
  progress_install: "Nameščanje: {{progress}}%",
  success: "Nadgradnja uspešna! Izključite in ponovno priključite napravo v USB režo. Tokrat se ne dotikajte gumba."
};
const button$7 = {
  abort: "Prekini",
  back: "Nazaj",
  buy: "Kupi",
  changepin: "Spremenite geslo naprave",
  check: "Preverite varnostno kopijo",
  "continue": "Nadaljujte",
  copy: "Kopiraj",
  create: "Ustvari",
  dismiss: "Zavrnite",
  done: "Potrdi izbiro",
  download: "Prenesi",
  hiddenwallet: "Ustvarite skrito denarnico",
  next: "Naprej",
  ok: "OK",
  previous: "Nazaj",
  receive: "Prejmi",
  restore: "Obnovi",
  select: "Izberite",
  send: "Pošlji",
  unlock: "Odklenite denarnico",
  update: "Osveži",
  upgrade: "Nadgradi"
};
const buy$3 = {
  exchange: {
    bankTransfer: "Bančno nakazilo",
    bestDeal: "Najboljša ponudba",
    creditCard: "Kreditna karica",
    fast: "Hitro",
    fee: "provizija",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bančno nakazilo: {{fee}}%",
          creditDebitCard: "Kreditna/debetna kartica: {{fee}}%",
          learnMore: "Več o storitvi MoonPay",
          title: "Provizije"
        },
        fullCurrenciesList: "Tu je na voljo seznam vseh valut",
        payment: {
          asteriskText: "* Ni na voljo za rezidente ZDA",
          bankTransfer: "Bančno nakazilo*",
          bankTransferDetails: {
            pix: "PIX (BR transakcije, samo v Braziliji)",
            sepa: "SEPA in SEPA Instant (samo EUR transakcije v državah SEPA)",
            uk: "UK Faster Payments (samo GBP transakcije v Združenem kraljestvu)"
          },
          creditDebitCard: "Kreditna/debetna kartica",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa in Maestro"
          },
          learnMore: "Oglejte si podrobnosti o načinih plačila",
          title: "Načini plačila"
        },
        supportedCurrencies: "Podpira vse glavne fiat valute: USD, EUR, CHF in druge"
      },
      pocket: {
        fees: {
          info: "Bančno nakazilo: {{fee}}%",
          title: "Provizije"
        },
        learnMore: "Več o storitvi Pocket",
        payment: {
          bankTransfer: "Bančno nakazilo",
          bankTransferDetails: {
            sepa: "SEPA in SEPA instant (transakcije v EUR znotraj SEPA podprtih držav)",
            sic: "Švicarska medbančna poravnava (samo za transakcije v CHF v CH/LIE)",
            uk: "UK Faster Payments (samo transakcije v GBP v UK)"
          },
          bankTransferReccuring: "Kako nastavimo ponavljajoče nakupe z enim naročilom?",
          title: "Načini plačila"
        },
        supportedCurrencies: "Podpira evropske valute: EUR, GBP in CHF",
        verification: {
          info: "Preverjanje identitete je zahtevano le nad dnevnim in letnim limitom.",
          link: "Trenutni limiti",
          title: "Preverjanje identitete"
        }
      },
      region: {
        title: "Izberite regijo, v kateri je registriran vaš bančni račun, da vidite možnosti, ki so vam na voljo."
      }
    },
    noExchanges: "V tej regiji žal ni razpoložljivih menjalnic.",
    region: "Regija",
    selectRegion: "Ni navedeno",
    title: "Kupi {{name}}"
  },
  info: {
    "continue": "Potrdi in nadaljuj",
    crypto: "kripto",
    disclaimer: {
      intro: [
        "V sodelovanju z MoonPay vam ponujamo možnost nakupa {{name}} neposredno znotraj BitBoxApp. S samo nekaj kliki.",
        "MoonPay je regulirana platforma za finančne storitve, ki omogoča preprost in hiter nakup {{name}} v več kot 160 državah"
      ],
      payment: {
        details: "{{name}} je možno kupiti takoj prek storitve MoonPay z naslednjimi načini plačila. Plačila s kreditno ali debetno kartico so takojšnja in priročna, vendar dražja. Za večje zneske priporočamo uporabo bančnega nakazila. Minimalna pristojbina je 4 EUR.",
        footnote: "Menjalni tečaji storitve MoonPay se lahko razlikujejo od tistih, ki se uporabljajo v BitBoxApp.",
        table: {
          "1_description": "Najnižja provizija, lahko traja do 3 delovne dni",
          "1_method": "Bančno nakazilo (SEPA)",
          "2_description": "Višja provizija a takojšnja izvršitev",
          "2_method": "Kreditna ali debetna kartica",
          description: "Opis",
          fee: "Provizija",
          method: "Način plačila"
        },
        title: "Načini plačila in provizije"
      },
      privacyPolicy: "Politika zasebnosti storitve MoonPay",
      protection: {
        description: "BitBoxApp ne zbira nobenih podatkov ob nakupu preko MoonPay. \nPrilivi se obravnavajo in so prikazani kot običajna transakcija. MoonPay za svoje delovanje zbira nekaj osebnih podatkov. Njihova politika zasebnosti podrobno pojasnjuje, kako ravna s temi podatki.",
        descriptionGeneric: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu {{name}}, vhodna sredstva se obravnavajo kot običajna transakcija. Pričakujemo, da morajo partnerske borze zbrati nekaj vaših informacij za njihovo poslovanje. Oglejte si njihove pravilnike o zasebnosti, da vidite kako postopajo z vašimi podatki.",
        title: "Zaščita podatkov"
      },
      security: {
        description: "Za nakup {{name}} preko MoonPay uporabljate zunanjo storitev. Ta storitev ne sodi v obseg zaščite, ki jo nudi BitBox02 in temelji na varnosti in zaščiti okolja, v katerem deluje programska oprema BitBoxApp.",
        descriptionGeneric: "Pojasnilo: Ko uporabite partnerske menjalnice za nakup {{name}}, uporabljate zunanjo storitev. Le-ta ni del naše varnostne politike in ni del zaščite, ki jo ponuja BitBox02 temveč je odvisna od okolja (operacijski sistem, omrežje) na katerem uporabljate BitBoxApp.",
        link: "Več o varni uporabi",
        title: "Model varnostnega sistema"
      },
      title: "Dobrodošli! Ste na pravem na mestu za nakup {{name}}"
    },
    next: "Naprej",
    selectLabel: "Izberite svoj račun",
    selectPlaceholder: "Izberi kovanec",
    skip: "Ne prikazuj več",
    title: "Kupi  {{name}}"
  },
  pocket: {
    data: {
      link: "Varovanje zasebnosti storitve Pocket",
      p1: "Aplikacija BitBoxApp ne zbira podatkov ob nakupu bitcoina, vhodna sredstva se obravnavajo kot običajna transakcija. Pocket mora za svoje delovanje zbrati nekaj vaših osebnih podatkov. Njihov pravilnik o zasebnosti podrobno pojasnjuje, kako ravnajo s temi podatki.",
      title: "Varovanje podatkov"
    },
    kyc: {
      link: "Preberite FAQ (odgovore na pogosta vprašanja) storitve Pocket",
      p1: "Storitev Pocket skuša število postopkov za KYC (know-your-customer; prepoznavo kupca) opraviti v najmanjši možni meri. Za nakupe pod 1000 CHF na dan dodatni dokumenti niso potrebni. Za nakupe nad tem zneskom se boste morali dogovoriti za klic z družbo Pocket, da opravite potreben postopek KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Bitcoin lahko zelo hitro kupite s storitvijo Pocket z bančnim nakazilom tipa SEPA. Provizija znaša 1,5 %, bitcoin pa se v vašo denarnico nakaže takoj, ko Pocket prejme vaše bančno nakazilo (običajno v istem dnevu).",
      p2: "Upoštevajte, da se lahko menjalni tečaji v aplikaciji BitBoxApp razlikujejo od menjalnih tečajev v aplikaciji Pocket, zaradi česar so zneski nekoliko drugačni.",
      title: "Načini plačila in provizije"
    },
    previousTransactions: "Zgodovina transakcij tega računa ni prazna. Če boste ta račun delili, bodo vse pretekle in prihodnje transakcije na njem vidne storitvi Pocket. Ali vseeno nadaljujete?",
    security: {
      link: "Model varnosti in zaščite BitBox02",
      p1: "Ob nakupu bitcoina preko storitve Pocket, uporabljate zunanjo storitev. Le-ta je izven zaščite, ki jo nudi BitBox02. Varnost in zaščita sta odvisna od okolja v katerem uporabljate BitBoxApp. \nSkupaj s storitvijo Pocket delujemo na način, da z dvofaktorsko avtentikacijo preverjamo naslov na katerega prejemate bitcoin.",
      title: "Varnostni model storitve Pocket"
    },
    usedAddress: "Naslov {{address}} je bil že uporabljen. Prosimo začnite ponovno.",
    verifyBitBox02: "Preverite, ali se naslov, ki ste ga prejeli po e-pošti, ujema z naslovom, prikazanim na napravi. Še bolj varno je, da e-poštno sporočilo odprete in preberete v drugi napravi, če je to mogoče.",
    welcome: {
      p1: "S storitvijo Pocket sodelujemo, da bi vam omogočili enostaven način nakupa bitcoina neposredno v BitBoxApp. V le nekaj klikih.",
      p2: "Pocket je Švicarska platforma ki omogoča hiter in enostaven nakup bitcoina v večini Evropskih držav.",
      p3: "S storitvijo Pocket lahko enostavno vzpostavite redni intervalni nakup bitcoina s pomočjo rednih bančnih nakazil. T.i. DCA (dollar-cost averaging) ",
      title: "Dobrodošli na pravem mestu za nakup bitcoinov"
    }
  },
  title: "Kupi {{name}}"
};
const changePin$2 = {
  newTitle: "Novo geslo naprave",
  oldLabel: "Trenutno geslo naprave"
};
const chart$3 = {
  dataMissing: "Še vedno pridobivamo informacije. Poskusite znova čez nekaj minut. Čiči pa čaki™",
  dataOldTimestamp: "Nalagamo tečaje. Graf ne prikazuje vrednosti po {{time}}.",
  dataUpdating: "posodabljam...",
  filter: {
    all: "Vse",
    month: "Mesec",
    week: "Teden",
    year: "Leto"
  }
};
const checkSDcard$2 = "preverjanje microSD kartice";
const clickHere$2 = "Kliknite tukaj.";
const confirm$4 = {
  abortInfo: "Hiter dotik za ",
  abortInfoRedText: "prekinitev",
  approveInfo: "Dotaknite se gumba za vsaj 4 sekunde ",
  approveInfoGreenText: " za potrditev",
  info: "Nadaljujte na BitBoxu.",
  infoWhenPaired: "Najprej na seznanjeni mobilni napravi in ​​nato na BitBoxu"
};
const confirmOnDevice$2 = "Nadgradnjo potrdite na BitBox-u";
const connectKeystore$2 = {
  promptNoName: "Za nadaljevanje priklopite BitBox02",
  promptWithName: 'Za nadaljevanje priklopite vaš BitBox02 z imenom "{{name}}"'
};
const darkmode$2 = {
  toggle: "Temen način"
};
const device$2 = {
  appUpradeRequired: "BitBox ni združljiv s to verzijo namizne aplikacije. Prenesite in namestite najnovejšo različico.",
  keystoreConnected: "Povezana denarnica"
};
const deviceLock$2 = {
  button: "Omogočite dvofaktorsko avtentikacijo (2FA)",
  condition1: "Imate varnostno kopijo?",
  condition2: "Ali deluje preverjanje v mobilni aplikaciji?",
  condition3: "2FA ONEMOGOČA varnostne kopije in seznanjanje z mobilno aplikacijo. Naprava mora biti resetirana za izhod iz dvofaktorskega (2FA) načina!",
  confirm: "Omogočite dvofaktorsko avtentikacijo (2FA)",
  title: "Omogočite dvofaktorsko avtentikacijo (2FA)"
};
const deviceSettings$2 = {
  backups: {
    manageBackups: {
      description: "Prikaži in preveri varnostno kopijo na Micro SD kartici."
    },
    showRecoveryWords: {
      description: "Prikaži in potrdi semenske besede."
    },
    title: "Varnostne kopije"
  },
  deviceInformation: {
    attestation: {
      description: "BitBoxApp preverja, če je naprava avtentična."
    },
    deviceName: {
      description: "Spremenite ime naprave"
    },
    rootFingerprint: {
      description: "Korenski prstni odtis je unikaten identifikator denarnice, ki je trenutno v uporabi. Če uporabljate frazemska gesla (passphrases), vam lahko pomaga pri razlikovanju med različnimi denarnicami."
    },
    securechip: {
      description: "Model varnega čipa"
    },
    title: "Informacije o napravi"
  },
  expert: {
    factoryReset: {
      description: "Ponastavite napravo na tovarniške nastavitve. Ta postopek izbriše denarnico na BitBoxu!",
      title: "Tovarniška nastavitev"
    },
    goToStartupSettings: {
      description: 'Vstopite v način "bootloader" na napravi. S tem lahko omogočite prikaz zgoščene vrednosti strojne programske opreme (firmware hash).'
    },
    passphrase: {
      description: "Vklopi ali izklopi možnost geselske fraze",
      title: "Geselska fraza"
    }
  },
  firmware: {
    firmwareVersion: "Različica strojne programske opreme (firmware)",
    newVersion: {
      label: "Razpoložljiva različica"
    },
    title: "Verzija strojne programske opreme (firmware)",
    upToDate: "Vaša naprava je posodobljena",
    upgradeAvailable: "Na voljo je nova nadgradnja",
    version: {
      label: "Različica"
    }
  },
  hardware: {
    attestation: {
      "false": "Preverjanje pristnosti ni uspelo",
      label: "Preverjanje pristnosti",
      "true": "BitBox02 je pristen!"
    },
    sdcard: {
      "false": "Ni vstavljena",
      label: "microSD kartica",
      "true": "Vstavljena"
    },
    securechip: "Verzija varnega čipa",
    title: "Naprava"
  },
  loading: "Pridobivam informacije o napravi ...",
  pairing: {
    lock: {
      "false": "Onemogočeno",
      label: "Dvo faktorska avtentikacija (2FA)",
      "true": "Omogočeno"
    },
    mobile: {
      "false": "Zaprto",
      label: "Mobilna aplikacija",
      "true": "Odpri"
    },
    status: {
      "false": "Ni uparjen",
      label: "Status",
      "true": "Uparjen"
    },
    title: "Seznanjanje (uparitev)"
  },
  secrets: {
    manageBackups: "Upravljanje varnostnih kopij",
    title: "Varnost"
  }
};
const deviceTampered$2 = "Ali ste prejeli BitBox skupaj z geslom za obnovitev?\nČe je tako, takoj zaustavite postopek namestitve in stopite v stik z nami.\nShift nikoli ne izroča pred-pripravljene denarnice ali pred pripravljenih gesel.";
const dialog$3 = {
  cancel: "Nazaj",
  confirm: "Potrdite",
  confirmTitle: "Potrditev"
};
const error$3 = {
  accountAlreadyExists: "Ta račun že obstaja.",
  accountLimitReached: "Novega računa ni mogoče dodati. Doseženo je največje število računov za ta kovanec.",
  aoppCallback: "Napaka pri dostavi naslova do {{host}}.",
  aoppInvalidRequest: "Napačna poizvedba",
  aoppNoAccounts: "Nobenega računa ni na razpolago.",
  aoppSigningAborted: "Aopp postopek preklican",
  aoppUnknown: "Neznana napaka...",
  aoppUnsupportedAsset: "Izbrano sredstvo ni podprto.",
  aoppUnsupportedFormat: "Na voljo ni računov, ki podpirajo zahtevano obliko naslova.",
  aoppUnsupportedKeystore: "Povezana naprava ne more podpisati sporočil za to sredstvo",
  aoppVersion: "Neznana različica",
  keystoreTimeout: "Čas za vklop se je iztekel. Poizkusite ponovno.",
  wrongKeystore: "Priključena je napačna denarnica. Vstavite pravo napravo BitBox02, ki ustreza temu računu.",
  wrongKeystore2: "Če uporabljate frazemsko geslo (passphrase), se prepričajte, da ste ga pravilno vnesli za ta račun."
};
const fiat$4 = {
  "default": "Privzeto",
  setDefault: "Nastavite {{code}} kot privzeto",
  title: "Valute"
};
const footer$4 = {
  appVersion: "Različica aplikacije:"
};
const generic$3 = {
  enabled_false: "Onemogočeno",
  enabled_true: "Omogočeno"
};
const genericError$2 = "Pojavila se je napaka. Če opazite kakršne koli težave, znova zaženite aplikacijo.";
const goal$2 = {
  buttons: {
    create: "Ustvarite novo denarnico",
    restore: "Obnovite denarnico iz varnostne kopije"
  },
  paragraph: "Izberite eno od naslednjih možnosti:",
  step: {
    "1": {
      title: "Varnostne informacije"
    },
    "2": {
      description: "Ustvarite geslo naprave",
      title: "Naprava"
    },
    "3-create": {
      description: "Ustvarite novo denarnico",
      title: "Denarnica"
    },
    "3-restore": {
      description: "iz varnostkopije",
      title: "Obnovi"
    },
    "4-create": {
      title: "Povzetek"
    },
    "4-restore": {
      title: "Povzetek"
    }
  }
};
const guide$3 = {
  accountDescription: {
    text: "To je pregled vašega računa. Prikazuje dohodne in odhodne transakcije. Stanje je prikazano za vsak račun posebej. Oglejte si pomoč v Nastavitvah, če želite izvedeti več o različnih vrstah računov.",
    title: "Kaj mi prikazuje ta stran?"
  },
  accountFiat: {
    text: "Seveda, kliknite na oznako valute in jo zamenjate. V nastavitvah lahko določate seznam valut, ki se prikazujejo tu.",
    title: "Ali lahko preverim vrednost v drugih fiat valutah?"
  },
  accountIncomingBalance: {
    text: "Tu je zbrana vsota zneskov, ki se prenašajo na vaš račun, vendar jih omrežje še ni potrdilo.",
    title: "Kaj pomeni dohodni?"
  },
  accountInfo: {
    multipleXPubs: {
      text: 'Vsak xpub (razširjen javni ključ) je vezan na prikazan tip naslova: "Native Segwit (bech32)", "Wrapped Segwit" ali "Taproot" (samo za Bitcoin). To so vrste skript, ki jih uporablja {{coinName}}. Aplikacija BitBoxApp jih združuje in podpira več vrst skript na istem računu. Ker vsaka vrsta skripta daje drugačen xpub, je na računu več xpubov.\n\nČe sredstva stalno prejemate na privzeti naslov (Native Segwit), potrebujete samo "bech32" xpub. Če pa sredstva prejemate tudi na tip naslova "Wrapped Segwit" ali "Taproot", morate uporabiti tudi razširjene javne ključe "Wrapped Segwit" oziroma "Taproot".',
      title: "Zakaj je tu več xpub-ov?"
    },
    privacy: {
      text: "xpub ali razširjen javni ključ za določen račun, razkriva celotno finančno zgodovino tega računa: transakcije v preteklosti, stanje računa in prihodnje transakcije. Dostop do xpub-a pa nikomur ne omogoča premika vaših kovancev.\n\nV kolikor nekomu posredujete xpub se morate zavedati, da lahko ta oseba ali podjetje vidi vse dogajanje na temu računu (za vsak naslov tega računa). Premislite torej katera in koliko sredstev boste upravljali na računu, ki ga dajete nekomu na vpogled.",
      title: "Ali moram svoje xpub-e ohraniti zasebne in na varnem?"
    },
    verify: {
      text: "Da, vedno je dobro dvakrat preveriti xpub. Če bo nekdo drug iz tega xpub-a ustvaril naslove za prejemanje in vam pošiljal denar, je to še posebej pomembno. Preveriti ga morate na napravi, da se prepričate, da ta xpub pripada vam. V nasprotnem primeru bi lahko vsa sredstva šla na napačne naslove (ki si jih morda ne lastite vi).",
      title: "Ali moram preveriti xpub na napravi?"
    },
    xpub: {
      text: 'Razširjeni javni ključ (xpub) je osnovni ključ, iz katerega izhajajo vsi prejemni naslovi računa.\nTu jih prikazujemo za namene napredne uporabe, kot na primer za uporabo v opazovalnih denarnicah (watch only wallets), kot sta Electrum ali Sentinel. Če imate prejeme sredstev na različne tipe naslovov, uporabite "xpub" vseh tipov naslovov, da jih boste lahko videli vse svoje kovance v teh denarnicah.\n\nPozor, nekatere denarnice še ne podpirajo vseh tipov naslovov, kot je npr Taproot.',
      title: "Kaj je razširjeni javni ključ?"
    }
  },
  accountRates: {
    text: "Menjalni tečaji se vsako minuto posodobijo s strani CoinGecko.",
    title: "Od kod izvirajo prikazani menjalni tečaji?"
  },
  accountReload: {
    text: "Vsi podatki o transakcijah se posodabljajo samodejno.",
    title: "Kako lahko ponovno naložim zgodovino transakcij?"
  },
  accountSendDisabled: {
    text: "Gumb »Pošlji« se aktivira, ko je stanje večje od nič.",
    title: "Zakaj ne morem poslati nobenega {{unit}}?"
  },
  accountSummaryAmount: {
    text: "Skupni znesek je vsota vseh vaših kripto računov. Menjalni tečaji so na voljo na spletnem mestu coingecko.com.\n\nOpomba: Če MyEtherWallet uporabljate za žetone, ki jih BitBoxApp ne podpira, ti ne bodo vključeni v prikazani znesek.",
    title: "Kako se izračunava skupni znesek?"
  },
  accountSummaryDescription: {
    text: "Tu si lahko ogledate gibanje vašega skupnega portfelja skozi čas. Povzetek posameznih računov je prikazan pod grafom.",
    title: "Kaj prikazuje ta stran?"
  },
  accountTransactionAttributesBTC: {
    text: 'Virtualna velikost: Uporablja se za določanje omrežnine. Na omrežnini ste uspešno prihranili, ko je ta manjša od velikosti transakcije.\nVelikost: Dejanska velikost transakcije v bajtih, ko je serializirana glede na izbrano verigo blokov.\nTeža: Uvedena s sistemom Segwit, je nova metrika za ovrednotenje velikosti transakcij in blokov. Vsak bajt "segregated witness" šteje kot ena, vsi ostali kot štiri enote teže. Namesto enega megabajta dejanske velikosti je zdaj nova omejitev velikosti blokov na štiri milijone enot teže.',
    title: "Kako je s podatki o Bitcoin transakcijah?"
  },
  accountTransactionAttributesGeneric: {
    text: "Potrditve: Ko se transakcija objavi v omrežju, je sprva nepotrjena. Počakati je potrebno da jo nek rudar vključi v blok in s tem potrdi (rudari). Po tem bo imela transakcija 1 (eno) potrditev. Vsak novi blok, ki se objavi v omrežju s to transakcijo, doda še eno potrditev. V splošnem velja, da trgovci in drugi prejemniki, kot dokončne sprejemajo samo transakcije s 3 do 6 potrditvami.\nID transakcije: Unikatna identifikacijska številka transakcije, ki jo lahko uporabite za iskanje v raziskovalcih verige blokov.\nOmrežnina: Rudarjem se plača omrežnina (provizija), kot spodbuda za vključitev transakcij v bloke, ki jih rudarijo oz izračunavajo.\nČe želite izvedeti več, kliknite gumb Pošlji.",
    title: "Kaj je prikazano v podatkih o transakcijah?"
  },
  accountTransactionConfirmation: {
    text: "To je transakcija, ki je že objavljena v omrežju, vendar še ni potrjena.",
    title: "Kaj je nepotrjena transakcija?"
  },
  accountTransactionLabel: {
    text: "To je naslov, na katerega ste prejeli kovance ali iz njega kovance poslali.",
    title: "Kateri naslov je prikazan za vsako transakcijo?"
  },
  accountTransactionTime: {
    text: "Zabeležen čas, ko je transakcija potrjena v verigi blokov (v blockchainu).",
    title: "Kateri čas je prikazan?"
  },
  accounts: {
    howManyAccounts: {
      text: "Za Bitcoin in Litecoin lahko odprete več računov. Po petih odprtih računih, lahko dodate novega le če je zadnji že v uporabi. Pri vseh preostalih kovancih podpiramo največ pet računov.",
      title: "Koliko računov lahko ustvarim?"
    },
    howtoAddTokens: {
      text: "Žetoni, ki uporabljajo standard ERC20, so vezani na določen Ethereum račun. Če želite omogočiti ali onemogočiti določen žeton, odprite »Upravljanje računov«, razširite račun Ethereum in vklopite ali izklopite želeni žeton.",
      title: "Kako lahko dodam dodatne žetone?"
    },
    moveFunds: {
      text: "Lahko a z običajno transakcijo, iz enega naslova na drugega. Računi so neodvisni med seboj, zato drugačna pot ni mogoča.",
      title: "Ali je možno premikati sredstva med računi?"
    },
    recoverAccounts: {
      text: "Da. BitBoxApp ustvarja račune z uveljavljenimi standardi, združljivimi z večino drugih kripto denarnic.",
      title: "Ali lahko obnovim račune na drugih denarnicah?"
    },
    whatAreAccounts: {
      text: "Vaša denarnica lahko upravlja več računov istega kovanca. Računi so koristni, če želite sredstva hraniti ločeno.",
      title: "Kaj so računi?"
    },
    whatIsRememberWallet: {
      text: 'Če si izberete "Zapomni si denarnico" potem boste lahko videli njeno vsebino v BitBoxApp tudi, ko boste izklopili napravo. S tem boste lahko preverjali stanje svojega portfelja kadarkoli, tudi brez BitBox02. Za premik sredstev boste še vedno potrebovali vklopljeno napravo.\n\nČe izberete, da si BitBoxApp ne zapomni več določene denarnice in njenih računov, boste za njen prikaz znova vsakokrat potrebovali prikjlučen BitBox02.',
      title: 'Kaj se zgodi, ko omogočim "Zapomni si denarnico"?'
    },
    whyIsThisUseful: {
      text: 'Računi so odlični za upravljanje sredstev za različne ljudi ali namene, ker so ločeni. Svoj "razširjeni javni ključ" računa lahko delite, ne da bi razkrili česarkoli o svojih drugih računih. To vam omogoča večkratno prejemanje sredstev brez ponovne uporabe naslovov, na primer prejemanja plače ali rednega nakupa kriptovalut.',
      title: "Zakaj je to uporabno?"
    }
  },
  appendix: {
    link: "Kontaktirajte nas!",
    text: "Imate še kakšno vprašanje?"
  },
  backups: {
    check: {
      text: "»Preverba varnostne kopije« služi preverjanju, ali imate pravilno ustvarjeno in aktualno varnostno kopijo, ki ustreza vaši trenutni denarnici. To uporabite tudi za preverjanje vašega gesla za obnovitev.",
      title: 'Kaj je "Preverba varnostne kopije"?'
    },
    encrypt: {
      text: "Ne, vendar je geslo za obnovo potrebno za pridobitev denarnice iz shranjenega semena.",
      title: "Ali lahko kriptiram varnostno kopijo?"
    },
    howOften: {
      text: "Varnostna kopija se ustvari samodejno, ko ustvarite novo denarnico. Novo varnostno kopijo morate ustvariti le v primeru, če je vaša microSD kartica z aktualno varnostno kopijo izgubljena, poškodovana ali če želite več varnostnih kopij.\nPo posameznih transakcijah vam ni treba ustvarjati novih varnostnih kopij! \nVse transakcije, ki ste jih naredili po kreiranju varnostne kopije, lahko obnovite z eno samo varnostno kopijo.",
      title: "Kako pogosto moram narediti varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena ki jo naprava shrani na microSD kartico. Seme, skupaj z vašim geslom za obnovitev, ustvari denarnico.",
      title: "Kaj je varnostna kopija?"
    }
  },
  backupsBB02: {
    check: {
      text: "To preverjanje vam omogoča, da ugotovite, ali imate delujočo varnostno kopijo, ki ustreza trenutni denarnici.",
      title: 'Kaj je "Preveri varnostne kopije"?'
    },
    encrypt: {
      text: "Ne. Prosimo, hranite microSD kartico na varnem mestu, saj vsebuje nešifrirano seme (seed) za obnovitev denarnice. Če želite zaščititi svoje seme z geselsko frazo, jo lahko omogočite v naprednih nastavitvah v razdelku Upravljanje naprave.",
      title: "Ali lahko šifriram varnostno kopijo?"
    },
    whatIsABackup: {
      text: "Gre za kopijo semena na microSD kartici.",
      title: "Kaj je varnostna kopija?"
    }
  },
  bitbox: {
    "2FA": {
      text: 'Ko je 2FA omogočena, je potrebno na uparjenem telefonu odobriti vse izvedene transakcije, da bi premaknili kovance. \nV ozadju se kriptirana unikatna vrednost pošlje v aplikacijo na telefonu, se tam dešifrira in ko pritisnete gumb "Sprejmi" se vrne v BitBox. Komunikacija z napravo se izvaja preko kanala, ki je bil vzpostavljen med uparjevanjem s telefonom, in to namizno aplikacijo.\n\nPOZOR: Predno omogočite 2FA, bodite pozorni, da varnostno kopirate svojo denarnico in uparite telefon. Ko je 2FA omogočena, je namreč microSD kartica onemogočena in uparjevanje s telefonom ni možno. To dvoje lahko znova omogočite le po ponastavitvi BitBox01, ki izbriše napravo (in s tem denarnico)!',
      title: "Kako deluje dvofaktorska avtentikacija (2FA)?"
    },
    disable2FA: {
      text: "Če želite onemogočiti 2FA, morate ponastaviti (resetirati) in s tem izbrisati denarnico na BitBox-u in jo nato obnoviti iz varnostne kopije. Prepričajte se, da imate še vedno microSD kartico z varnostno kopijo in shranjeno veljavno in pravilno geslo za obnovo te denarnice.\nŠele nato pritisnite »Ponastavi napravo«. Nastavite novo geslo naprave in izberite »Obnovite varnostno kopijo«. Izberite pravo varnostno kopijo, ki ste jo naredili iz denarnice, kliknite »Obnovi« in vnesite geslo za obnovitev, ki ste ga kreirali pri ustvarjanju denarnice.",
      title: "Kako onemogočim dvo faktorsko avtentikacijo (2FA)?"
    },
    ejectBitbox: {
      text: "BitBox lahko izklopite kadarkoli oz. iztaknete iz USB vhoda.",
      title: "Kako lahko odklopim BitBox?"
    },
    ejectSD: {
      text: "MicroSD lahko odstranite iz BitBoxa kadarkoli, razen, ko ste v procesu ustvarjanja ali obnavljanja varnostne kopije.",
      title: "Kdaj lahko odstranim microSD kartico?"
    },
    hiddenWallet: {
      text: "Gre za drugo denarnico na isti napravi, zaščiteno z različnim geslom naprave in obnovitvenim geslom, ki ga lahko uporabite za verodostojno zanikanje. Enako rezervno seme se uporablja za normalno in skrito denarnico, zato dodatna varnostna kopija ni potrebna.",
      title: "Kaj je skrita denarnica?"
    },
    legacyHiddenWallet: {
      text: "Najprej kliknite spodnji gumb (na voljo le, če je BitBox odklenjen z glavnim geslom naprave in je 2FA onemogočen), nato ponovno vklopite Bitbox in ga odklenite s svojim alternativnim geslom naprave.",
      title: "Kako dostopam do skrite denarnice?"
    },
    pairing: {
      text: "Ko naložite našo mobilno aplikacijo za iOS ali Android, skenirajte prikazano QR kodo, ki vzpostavi varen kanal med mobilno aplikacijo in to aplikacijo. Poskenirajte in sledite navodilom v mobilni aplikaciji.",
      title: "Kako varno uparite BitBox01 s telefonom"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Za več podrobnosti si oglejte spletno mesto Bitsurance in odgovore na pogosto zastavljena vprašanja (FAQ).",
      title: "Imate dodatna vprašanja?"
    },
    privacy: {
      link: {
        text: "Politika zasebnosti Bitsurance"
      },
      text: "Kot vsaka običajna zavarovalna polica, tudi ta vsebuje vaše polno ime, naslov prebivališča ter opredeljuje predmet zavarovanja (ta je opredeljen z razširjenim javnim ključem zavarovanca). Ti podatki so posredovani neposredno zavarovalnici Bitsurance in se ne delijo s podjejem Shift Crypto (in storitvijo BitBox). Za več informacij si oglejte pravilnik o zasebnosti zavarovalnice Bitsurance.",
      title: "Kateri osebni podatki so potrebni za zavarovanje?"
    },
    renew: {
      text: 'Zavarovanje se samodejno podaljša za naslednje leto. Podaljšanje lahko kadar koli prekličete s klikom na "Upravljanje pogodbe" v aplikaciji BitBoxApp, ki vas pripelje na portal za stranke Bitsurance.',
      title: "Kako lahko obnovim ali prekinem zavarovanje?"
    },
    status: {
      text: 'Uspešno zavarovani računi so označeni z zeleno oznako "zavarovano" v zgornjem levem kotu na strani vsakega Bitcoin računa. V razdelku "Zavarovanje" si lahko ogledate pregled vseh Bitcoin zavarovanih računov in njihovo trenutno stanje zavarovanja. Posodobitev stanja lahko traja do 48 ur.',
      title: "Ali lahko preverim stanje zavarovanega računa?"
    },
    what: {
      text: 'Vsaka zavarovalna polica za Bitcoin krije določen račun v denarnici. Več računov lahko zavarujete tako, da sklenete več zavarovalnih polic. Zavarovani so le Bitcoini na tipu naslova "Native Segwit" v posameznih zavarovanih računih.',
      title: "Ali so zaščiteni vsi Bitcoini v denarnici?"
    },
    who: {
      text: "Zavarovanje ponuja Bitsurance, zavarovalni posrednik, ki so ga zgradili bitcoinerji. Sodelujejo z zavarovalno hišo ELEMENT ki zagotavlja zavarovanja za Bitcoin. Obe podjetji imata sedež v Nemčiji.",
      title: "Kdo zavaruje moj Bitcoin?"
    },
    why: {
      text: "Zavarovanje Bitsurance krije nekatera tveganja samo-hrambe, pred katerimi ni varna nobena strojna denarnica (naprava), kot npr. vlom, izsiljevanje ali uničenje denarnice. Ali potrebujete zavarovalno kritje za ta tveganja ali ne, je izključno vaša osebna odločitev.",
      title: "Ali potrebujem zavarovanje za Bitcoin?"
    }
  },
  cointracking: {
    text: 'Kliknite gumb "Izvozi" in odprite mapo za prenose, v kateri boste našli izvoz v .CSV datoteki. Nato kliknite spodnjo povezavo, naložite to .CSV datoteko in uvozite podatke, da jih boste lahko uporabili za storitev CoinTracking in za pripravo davčnih poročil (samo za določene države!).',
    title: "Kako uvozim svoje transakcije v storitev CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Preberite si več o preverjanju pristnosti"
      },
      text: "Aplikacija BitBoxApp opravi preverjanje pristnosti na napravi BitBox02, da preveri, ali je naprava originalna. Preverjanje se opravi lokalno in brez povezave z zunanjim strežnikom.",
      title: "Kako poteka preverjanje pristnosti?"
    },
    name: {
      text: "To je ime vaše denarnice in varnostne kopije. Ime se uporablja za prihodnje varnostne kopije in se lahko uporablja za lažje razlikovanje med različnimi denarnicami. Spremenite ga lahko kadar koli, vendar upoštevajte, da bodo varnostne kopije, izdelane pred spremembo, še vedno uporabljale prejšnje ime.",
      title: "Za kaj se uporablja ime denarnice BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Preberite več o varnem čipu"
      },
      text: "Ker je verzija čipa dobra informacija o varnosti naprave. Najsodobnejši čip je ATECC608B z izboljšanimi varnostnimi funkcijami v primerjavi s starejšimi modeli.",
      title: "Zakaj prikazujemo model varnega čipa?"
    }
  },
  receive: {
    address: {
      text: "Pošljite ali predajte ga drugim, da vam lahko nanj pošiljajo kovance.\nPriporočamo, da se s prejemnikom naslova prepričate, da je prejel enak naslov, kot ste mu ga poslali. Obstaja namreč možnost, da na poti do prejemnika naslova programska oprema zamenjala naslov s svojim.",
      title: "Kaj lahko počnem z naslovom?"
    },
    addressChange: {
      text: "Takoj, ko opravite transakcijo, se na seznam samodejno doda nov naslov. Tako je vedno na voljo 20 naslovov, ki še nikoli niso prejeli nobenega kovanca.",
      title: "Kdaj se naslovi spremenijo?"
    },
    addressFormats: {
      text: 'Privzet tip naslova je "Native Segwit" t.i. bech32 tip naslova. Podprt je že v mnogih drugih denarnicah in menjalnicah, saj ponuja najnižje provizije na transakcije. Poleg tega, lahko izbirate še med drugimi tipi naslovov. Novejši je Taproot (velja samo za Bitcoin), starejši pa "Wrapped Segwit".\n',
      title: "Kdaj uporabiti »Spremenite tip naslova«?"
    },
    howVerify: {
      text: "Če imate BitBox01 kliknite ikono BitBox na stranskem stolpcu na levi strani in glejte poglavje seznanitve. Vodnik se bo posodobil in od tam lahko nadaljujete po navodilih.\nZ BitBox02 lahko med postopkom pošiljanja/prejemanja preverite naslove neposredno na napravi.",
      title: "Kako lahko varno preverim naslov?"
    },
    plugout: {
      text: "Ne, BitBox lahko odklopite. Ko pošljete kovance na naslov generiran z BitBox02, vam naprave ni treba pustiti priključene v računalnik ali telefon.",
      title: "Je potrebno imeti BitBox02 priklopljen vse dokler ne prejmem sredstev?"
    },
    why20: {
      text: "Med zagonom aplikacija ustvari naslove, pridobljene iz vašega semena, in preveri, ali so prejeli sredstva. Aplikacija lahko ustvari skoraj neskončno število naslovov in bi lahko porabila leta, da določi pravo stanje za vsak naslov.\nDa omejimo čas iskanja, se prikaz ustavi po prvih 20 najdenih naslovov, ki nikoli niso prejeli sredstev. To je namenska omejitev in 20 je de-facto standard, čeprav je število poljubno. To je 20 naslovov, med katerimi lahko izbirate.",
      title: "Zakaj le 20 naslovov?"
    },
    whyMany: {
      text: "Za ohranjanje vaše zasebnosti in varnosti nikoli ne uporabite istega naslova dvakrat. \nČe ste že uporabili naslov, kliknite na puščico v desno za nov naslov. Naenkrat lahko ustvarite do 20 naslovov. Na naslove lahko gledate, kot na številke izdanih računov. Vsi naslovi so pridobljeni iz istega semena.",
      title: "Zakaj toliko naslovov?"
    },
    whyVerify: {
      text: "Vašemu računalniku ne zaupajte, da ustvarja in prikazuje pristne naslove. Zaradi velike kompleksnosti je bistveno lažja tarča in bolj občutljiv kot denarnica s strojno opremo. \nZa BitBox01 - gumb za preverjanje naslova varno pošlje naslov na seznanjen mobilni telefon, iz katerega lahko tudi skenirate in preverite QR kodo. \nNa BitBox02 lahko naslov preverite neposredno na zaslonu.",
      title: "Zakaj moram varno preveriti naslov?"
    }
  },
  send: {
    change: {
      text: "Višek (change) bo vrnjen na naslov Taproot, če imate vsaj en Taproot UTXO (Taproot naslov z nekaj sredstvi). Če uporabljate nadzor kovancev, bo sprememba vrnjena na Taproot naslov, če je med izbranimi UTXO vsaj en tipa Taproot. V vseh drugih primerih se sprememba vrne na Native Segwit (bech32) naslov.",
      title: "Kako je definirano vračilo viškov?"
    },
    fee: {
      text: "Omrežnina (ali prostovoljni prispevek rudarjem, provizija) temelji na velikosti podatkov v transakciji in ne na njenem znesku. Ciljne omrežnine se izračunajo po algoritmu za ocenjevanje omrežnin Bitcoin Core glede na izbrano prioriteto. Prikažejo se, če imajo drugačno vrednost od spodnjih.\nVarčna: 24 blokov (približno 4 ure za Bitcoin, 1 ura za Litecoin)\nNizka: 12 blokov (približno 2 uri za Bitcoin, 30 minut za Litecoin)\nObičajna: 6 blokov (približno 1 ura za Bitcoin, 15 minut za Litecoin)\nVisoka: 2 bloka (približno 20 minut za Bitcoin, 5 minut za Litecoin)\n(Izračun bloka v Bitcoin omrežju traja v povprečju deset minut in 2,5 minute za Litecoin. Obremenitev omrežja in s tem omrežnine se lahko v zgornjih obdobjih močno razlikujejo.)",
      title: "Kako se določi vrednost omrežnine?"
    },
    plugout: {
      text: "Ne, ko enkrat opravite prenos sredstev (transakcijo), vam BitBoxa ni treba imeti več priklopljenega. Lahko jo izključite.",
      title: "Ali moram imeti BitBox priklopljen ves čas pošiljanja?"
    },
    priority: {
      text: "Višjo omrežnino, ki ste jo pripravljeni plačati, hitreje bo vaša transakcija potrjena v omrežju.",
      title: "Kakšna je prednost omrežja?"
    },
    revert: {
      text: "Ko je transakcija podpisana in poslana (tj. predvajana v omrežje), je ni več mogoče razveljaviti. Pred podpisom torej preverite transakcije (vključno s provizijo)!\nČe prejemnika poznate in vam je pripravljen poslati isti znesek (minus transakcijske provizije), mu lahko pošljete nov naslov za prejem kovancev.",
      title: "Ali lahko povrnem transakcijo?"
    },
    whyFee: {
      text: "S prispevkom oz. omrežnino, ki jo prinašajo, transakcije med seboj tekmujejo, da jih potrdi rudar. Rudarji praviloma najprej izberejo tiste transakcije, ki jim prinašajo višje omrežnine (provizije).\nBitcoin rudarji lahko za nagrado za opravljeno računsko delo poberejo omrežnine, plačane pri transakcijah, ki jih potrdijo, skupaj z novo nastalimi bitcoini. Rudarjenje je specializiran in konkurenčen trg, kjer se nagrade delijo glede na število opravljenih izračunov. ",
      title: "Zakaj obstaja omrežnina?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Če se želite s svojim vozliščem (full node) povezati le, ko ste v istem omrežju (npr. domači wifi), zadostuje uporaba običajne omrežne komunikacije.\nV tem primeru je priporočljivo, da strežnik Electrum zagotovi potrdilo TLS za šifriranje komunikacije.\nČe se nameravate s svojim vozliščem povezati od kjer koli drugje, je boljša možnost uporaba omrežja Tor. V tem primeru ni potrebno potrdilo TLS.",
      title: "Ali naj uporabim nešifrirano povezavo TCP, TLS ali Tor?"
    },
    instructions: {
      link: {
        text: "Vodnik za povezavo lastnega vozlišča"
      },
      text: "Za obširnejša navodila obiščite naš vodič (v angleščini):",
      title: "Kako povežem BitBoxApp s svojim polnim vozliščem?"
    },
    options: {
      text: "Obstaja več možnosti za postavitev lastnega vozlišča, kot na primer nakup končanega izdelka, ki je namenjen le temu, izdelava lastnega ali zagon programja Bitcoin Core na računalniku.\nČe želite BitBoxApp povezati s svojim vozliščem, se prepričajte, da na njem teče tudi strežnik Electrum. To je namenski program, ki aplikaciji denarnice (kot je BitBoxApp) omogoča komunikacijo s polnim vozliščem.\nPodprte možnosti vključujejo programje Electrs, Electrum Personal Server (EPS) ali Bitcoin Wallet Tracker (BTW).",
      title: "Kakšne možnosti obstajajo za zagon/nakup vozlišča?"
    },
    tor: {
      text: "Tor pomeni 'The Onion Router', ki je brezplačna in odprtokodna programska oprema, ki ponuja višjo stopnjo zasebnosti in je še posebej uporabna pri uporabi Bitcoina.\nČe se nameravate povezati s vozliščem prek omrežja Tor, se prepričajte, da je Tor nameščen na računalniku in nato v nastavitvah BitBoxApp omogočite Tor Proxy.\nV večini operacijskih sistemov obstaja dva načina dostopa do Tor-a:\n1. Brskalnik Tor: prenesite in odprite brskalnik Tor. To bo omogočilo BitBoxApp, da se poveže z omrežjem Tor. V nastavitvah vpišite vrata (port) 9150 v nastavitvah za proxy strežnik.\n2. To v ozadju: Namestite demon Tor, ki vedno deluje v ozadju operacijskega sistema. Nato se lahko BitBoxApp poveže preko Tor-a z nastavitvijo vrat 9050 v nastavitvah za proxy strežnik.",
      title: 'Kaj je Tor, Tor proxy in kater "port" naj uporabim?'
    },
    what: {
      text: "Denarnico lahko povežete s svojim polnim vozliščem, namesto da uporabljate strežnike podjetja Shift.",
      title: "Kaj je to?"
    },
    why: {
      text: "Vzdrževanje lastnega vozlišča ni potrebno, izboljša pa zasebnost in zniža potrebo po zaupanju drugim.\nPrvič, to pomeni, da bolj zasebno uporabljate Bitcoin (omrežje), saj se BitBoxApp ne bo povezal z našimi strežniki, da bi prejel vašo zgodovino transakcij; namesto tega bo podatke prejel od vašega vozlišča.\nDrugič, imeti lastno vozlišče pomeni, da vozlišče samo preverja vse transakcije in poskrbi, da so pravila omrežja Bitcoin za vas uveljavljena.",
      title: "Zakaj naj poganjam svoje vozlišče?"
    }
  },
  settings: {
    sats: {
      text: "Satoshi (satoši, krajše sat) je najmanjša enota Bitcoina. En satoši je stomilijonska enota bitcoina (0,00000001 BTC). Ime je dobila po avtorju Bitcoina, Satoshiju Nakamotu.",
      title: "Kaj je Satoshi?"
    },
    servers: {
      text: "Ta aplikacija komunicira s strežniki podjetja Shift Crypto AG, da preveri posodobitve, naloži transakcije in pošilja informacije v uparjene mobilne aplikacije.\nAplikacija pridobiva najnovejše tečaje pri CoinGecko. Vse konverzije so izračunane lokalno, kar pomeni, da se podatki o znesku vaše transakcije nikoli ne pošljejo ven iz aplikacije.\nOpomba: Za Ethereum in ERC20 žetone uporabljamo API-je Etherscan.io.",
      title: "S katerimi strežniki govori ta aplikacija?"
    }
  },
  title: "Vodič vam v pomoč",
  toggle: {
    close: "Zapri",
    open: "Pomoč"
  },
  trackingModePortfolioChart: {
    text: "V namizni aplikaciji pojdite z miško čez graf. V mobilni aplikaciji, pritisnite na grafi in podrsajte po njem levo ali desno.",
    title: "Kako preverim vrednosti na grafu za določen dan?"
  },
  unlock: {
    forgotDevicePassword: {
      text: "Ponastaviti morate napravo (reset) in obnoviti denarnico iz varnostne kopije z geslom za obnovitev.",
      title: "Kaj lahko storim, če pozabim geslo naprave?"
    },
    reset: {
      text: "Vnesite napačno geslo naprave 15-krat. V zadnjih nekaj poskusih je potreben dolg dotik naprave.",
      title: "Kako ponastavim napravo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Ko jo vstavite, naprava utripne enkrat. Prepričajte se, da je pravilno obrnjena v USB reži. Če imate težave, nas kontaktirajte preko spodnje povezave.\n\nBitBox01 ni podprt v mobilni aplikaciji. Za povezavo z BitBox01 uporabite BitBoxApp na namizju.",
      title: "Moj BitBox01 ni prepoznan"
    },
    getDevice: {
      link: {
        text: "Naročite BitBox"
      },
      text: "BitBox lahko kupite v naši spletni trgovini (link spodaj) ali pri naših partnerjih.",
      title: "Kje lahko kupim BitBox?"
    },
    internet: {
      text: "Da, internetna povezava je potrebna za sinhronizacijo denarnice, za pošiljanje transakcij in pridobivanje menjalnih tečajev.",
      title: "Ali ta aplikacija zahteva internetno povezavo?"
    },
    lostDevice: {
      link: {
        text: "Varnostne kopije"
      },
      text: "Vaša sredstva lahko enostavno obnovite z novo BitBox denarnico ali z drugo BIP39 napravo. V pomoč smo spisali postopek v članku:",
      title: "Izgubil sem napravo. Kaj pa zdaj?"
    },
    useWithoutDevice: {
      text: "Na žalost to trenutno še ni mogoče.",
      title: "Ali lahko aplikacijo uporabljam brez BitBoxa?"
    },
    welcome: {
      text: "Podjetje Shift Crypto iz Švice se vam zahvaljuje, ker uporabljate BitBoxApp. \nVaše predloge za izboljšavo zelo cenimo in si jih želimo. Vaš odziv pričakujemo na povezavi na dnu.",
      title: "Pozdravljeni v aplikaciji BitBox!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Če uporabljate nov telefon ali računalnik z aplikacijo BitBoxApp, se boste morali ponovno povezati z DApps. Svoje kovance boste nato ponovno videli v izbranih DApp kot običajno.",
      title: "Mojih prejšnjih povezav ne vidim."
    },
    supportedNetworks: {
      text: "V BitBoxApp je trenutno z WalletConnect podprto le Ethereum omrežje. Za uporabo drugih verig, združljivih z EVM, uporabite storitev Rabby v brskalniku (browser extension wallet).",
      title: "Katera omrežja so podprta?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect je komunikacijski protokol za web3 aplikacije. Omogoča vam priročno povezavo z decentraliziranimi avtonomnimi aplikacijami (DApps) in spletnimi denarnicami, ki temeljijo na Ethereumu, brez uporabe aplikacije tretje osebe. To je še posebej uporabno za uporabnike aplikacije BitBoxApp na Androidu.",
      title: "Kaj je WalletConnect?"
    }
  }
};
const headerssync$2 = {
  blocksSynced: "{{blocks}} sinhroniziranje blokov"
};
const hiddenWallet$2 = {
  info1HTML: "Za namene verodostojnega zanikanja (obstoja prave denarnice) lahko ustvarite skrito denarnico na podlagi <strong>drugačne (alternativne)</strong> kombinacije gesla in gesla za obnovitev varnostne kopije. ",
  info2HTML: "Določite geslo naprave in geslo za obnovitev, ki ju želite povezati s spodnjo skrito denarnico. To geslo naprave in geslo za obnovitev morata biti <strong> drugačna </strong> od tistih, ki ste ju določili za primarno denarnico.",
  passwordLabel: "Skrito geslo za obnovitev",
  passwordPlaceholder: "Potrdite skrito geslo za obnovitev",
  pinLabel: "Geslo za skrito denarnico",
  pinRepeatLabel: "Ponovite geslo skrite denarnice",
  pinRepeatPlaceholder: "Prosimo potrdite geslo skrite denarnice",
  success: "Skrita denarnica je bila uspešno ustvarjena. Iztaknite in ponovno vtaknite BitBox v USB vhod, da jo odklenete."
};
const initialize$2 = {
  create: "Ustvarite geslo naprave",
  creating: "Kreiram geslo naprave ...",
  error: {
    e102: "Geslo naprave mora vsebovati najmanj 4 znake."
  },
  info: {
    description1: "Vpišite novo geslo naprave. To bo uporabljeno za odklepanje BitBox-a.",
    description2: "Uporabite lahko številke, črke in simbole. Daljša gesla so varnejša.",
    description3: "Če izgubite geslo naprave, boste morali ponastaviti napravo in obnoviti varnostno kopijo denarnice.",
    subtitle: "Zdaj boste vpisali novo geslo naprave",
    title: "Izvaja se prvi zagon vaše naprave"
  },
  input: {
    label: "Geslo naprave",
    labelRepeat: "Ponovite geslo naprave",
    placeholderRepeat: "Prosimo, potrdite geslo naprave"
  }
};
const invalidFormat$2 = "Neveljavna oblika";
const language$3 = {
  title: "Izberite jezik"
};
const legacyhiddenwallet$2 = {
  disable: "Onemogoči starejšo skrito denarnico (legacy wallet)",
  enable: "Omogoči skrito denarnico starejšega formata (legacy)",
  successDisable: "Skita denarnica bitcoin računa starejše generacije je onemogočena.",
  successEnable: "Skrita denarnica starejšega formata je uspešno omogočena. Znova priključite svoj BitBox in skrbno vnesite geslo naprave za dostop do starejše skrite denarnice."
};
const loading$2 = "nalaganje…";
const manageAccounts$1 = {
  accountHidden: "Ta račun je bil skrit in ga ni več na seznamu opazovalnih računov. Če ga želite videti ponovno, priklopite vaš Bitbox02.",
  editAccount: "Uredi",
  editAccountNameTitle: "Uredi ime računa",
  noAccounts: "ni računov",
  settings: {
    hideTokens: "Skrij žetone",
    showTokens: "Prikaži žetone ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Dodajaj in aktiviraj/deaktiviraj račune",
  title: "Upravljanje računov",
  watchAccount: "Opazovalni račun",
  watchAccountDescription: "Ta račun je del vaših opazovalnih računov. Z drsnikom ga lahko skrijete."
};
const mobile$2 = {
  usingMobileDataWarning: "Uporaba podatkov na mobilni napravi: ta aplikacija lahko po odklepanju računa naloži do nekaj sto megabajtov podatkov. Če želite preprečiti uporabo mobilnih podatkov, se povežite z Wi-Fi omrežjem. \nTo sporočilo ne bo več prikazano, če ga ugasnete."
};
const newSettings$1 = {
  about: {
    appVersion: {
      title: "Verzija aplikacije"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Prepreči dostop do aplikacije z zaklepom zaslona.",
      title: "Zaklep zaslona"
    },
    coinControl: {
      description: "Za večjo stopnnjo zasebnosti izberite kateri UTXO naj bo del transakcije."
    },
    customFees: {
      description: "To vam omogoča vnos poljubne višine provizije za transakcijo."
    },
    torProxy: {
      description: "Povežite se preko Tor omrežja za več zasebnosti."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Te dodatne valute lahko izmenjujoče prikazujete na strani računov.",
      title: "Aktivne valute"
    },
    darkmode: {
      description: "BitBoxApp v temnem načinu"
    },
    defaultCurrency: {
      description: "Izberite privzeto valuto",
      title: "Privzeta valuta"
    },
    enableAccount: {
      description: "Če onemogočite posamezen račun, ne bo prikazan v stranski vrstici ali portfelju. Od tu ga lahko vedno znova omogočite. \nTo ne bo vplivalo na kovance v tem računu. Ostajajo na varnem, le prikazani ne bodo.",
      title: "Omogoči/ onemogoči račun"
    },
    hideAmounts: {
      description: "Prikaže preklopnik za skrivanje stanja in zneskov, za vašo večjo zasebnost, ko aplikacijo uporabljate na javnem mestu.",
      hideAmounts: "Skrij zneske",
      showAmounts: "Prikaži zneske",
      title: "Dovoli skrivanje zneskov"
    },
    language: {
      description: "Izberite jezik, ki ga želite uporabiti v BitBoxApp-u.",
      title: "Jezik"
    },
    remebmerWallet: {
      name: "Zapomni si denarnico",
      warning: "Odstranili boste prikaz denarnice, ko BitBox02 ni priključen. Vsebina denarnice in vsa sredstva s tem ostanejo varna in nedotaknjena, le BitBoxApp jo bo pozabil. Nadaljujem?",
      warningTitle: "Pozabi denarnico"
    },
    toggleSats: {
      description: "Prikažite ali skrijte Satošije (sats)."
    }
  }
};
const note$3 = {
  input: {
    description: "(opcijsko)",
    placeholder: "Dodaj opombo"
  },
  title: "Opomba"
};
const notification$2 = {
  newTxs_one: "{{count}} novih transakcij na: {{accountName}}",
  newTxs_other: "{{count}} novih transakcij na: {{accountName}}"
};
const pairing$2 = {
  aborted: {
    text: "Uparjanje je bilo prekinjeno s strani mobilne aplikacije.",
    title: "Prekinjeno"
  },
  button: "Uparite z mobilno aplikacijo",
  confirm: "Ali ste prepričani, da želite upariti svoj BitBox? Upoštevajte, da je po uparitvi mobilni telefon vedno potreben za izvedbo transakcije.",
  connectOnly: {
    button: "Povežite z mobilno aplikacijo",
    title: "Skenirajte z našo mobilno aplikacijo tako, da izberete menijsko točko »Connect to new desktop app«"
  },
  error: {
    text: "Nekaj ​​je šlo narobe. Prosimo, začnite znova.",
    title: "Napaka"
  },
  pullFailed: {
    text: "Sporočila iz mobilnega telefona ni bilo mogoče pridobiti prek relejskega strežnika. Strežnik je morda brez povezave. Prosimo, obrnite se na podporo.",
    title: "Parjenje ni uspelo"
  },
  reconnectOnly: {
    button: "Ponovno vzpostavite povezavo z mobilno aplikacijo"
  },
  scanningFailed: {
    text: "Mobilnik ni uspešno skeniral sporočila. Prosimo poskusite ponovno.",
    title: "Skeniranje ni uspelo"
  },
  start: {
    hideAppQRCode: "Skrij kodo QR",
    revealAppQRCode: "Prikaži QR kodo",
    step1: "Če mobilne aplikacije še nimate, lahko skenirate QR kodo za Apple App Store ali Google Play Store, odvisno od tega, kateri telefon imate.",
    step2: "Skenirajte z našo mobilno aplikacijo, ki jo najdete pod imenom „Digital Bitbox 2FA“ v trgovinah z aplikacijami za iOS in Android:"
  },
  started: {
    text: "Prosimo sledite navodilom v mobilni aplikaciji.",
    title: "Super"
  },
  success: {
    text: "Čestitamo, uspešno ste uparili BitBox z mobilno aplikacijo!",
    title: "Uspelo je!"
  },
  timeout: {
    text: "Seznanitev je potekla po dveh minutah. Začnite znova, če želite BitBox še vedno upariti z mobilno aplikacijo.",
    title: "Odmor"
  },
  title: "Mobilno seznanjanje"
};
const passphrase$1 = {
  considerations: {
    button: "",
    message: "Geselska fraza zagotavlja dodaten nivo zaščite varnostni kopiji vaše denarnice (bodisi na microSD kartici ali 24 besedam). Če nekdo pridobi dostop do vaše varnostne kopije (na kartici ali besede), bo za dostop do vaše denarnice potreboval tudi geselsko frazo.\n\nTo pa pomeni, da boste potrebovali <strong>oboje - geselsko frazo in varnostno kopijo denarnice</strong>, da bi obnovili tako zaščiteno denarnico, če se vaš BitBox02 pokvari ali ga izgubite. Če pozabite ali izgubite to geslo, boste izgubili dostop do vseh kovancev v tej denarnici!\n\nGeselsko frazo shranjujte ločeno od varnostne kopije. S tem preprečite vdor v denarnico, če nekdo najde le njeno varnostno kopijo.",
    title: "Razmislek o varnostni kopiji"
  },
  disable: "Onemogoči geselsko frazo",
  disableInfo: {
    button: "Izklopi",
    message: "Po izklopu geselske fraze, vas BitBox ob odklepu ne bo več spraševal po njej. S tem boste vstopili v privzeto denarnico.\n\nVsi kovanci v denarnici, zaščiteni z izbrano geselsko frazo, bodo še vedno v tej denarnici, vendar do njih ne boste mogli dostopati, saj boste po odklepanju naprave odprli svojo privzeto denarnico.\n\nDa bi znova odprli denarnico, ki je zaščitena z geselsko frazo, enostavno ponovno omogočite to funkcijo in vnesite izbrano geselsko frazo na BitBox02.\n\n<strong>Namig:</strong> Kljub temu lahko dostopate do privzete denarnice, le geselske fraze ne vtipkavajte ob vstopu v BitBox."
  },
  enable: "Omogoči geselsko frazo",
  error: {
    e104: "Sprememba geselske fraze je bila prekinjena..."
  },
  how: {
    button: "Kako izgleda",
    message: 'Geselska fraza ne deluje tako kot "navadno" geslo, ki ste ga vajeni. Če se ob vnosu geselske fraze zatipkate, na napako NE boste opozorjeni. To pa zato, ker <strong>vsaka geselska fraza ustvari različno a veljavno denarnico</strong>. To pomeni, da lahko uporabljate več geselskih fraz za več denarnic na BitBox02. Vse te denarnice so na BitBox02 dostopne le po vsakokratnem vnosu ustrezne geselske fraze.\n\nOb priključitvi naprave BitBox02 boste, kot običajno, pozvani k vpisu gesla naprave. Nato boste morali v napravo vnesti še geselsko frazo.\n\nPo vnosu fraze se vam bo ta prikazala na zaslonu. Tako boste lahko potrdili, da ste jo vnesli pravilno oz. da ste vnesli željeno.\n',
    title: "Kako deluje"
  },
  intro: {
    message: "Geselska fraza zagotavlja dodatni nivo varnosti za vašo denarnico.\nSpoznajmo, kako deluje.",
    title: "Vnesite željeno geselsko frazo"
  },
  progressDisable: {
    message: "Na BitBoxu potrdite, da želite <strong>onemogočiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  progressEnable: {
    message: "Na BitBoxu potrdite, da želite <strong>omogočiti</strong> geselsko frazo.",
    title: "Potrdite na napravi"
  },
  successDisabled: {
    message: "Geselska fraza <strong>uspešno omogočena</strong>!\nOdslej jo boste vselej vnašali v napravo.",
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    title: "Geselska fraza omogočena"
  },
  successEnabled: {
    message: "Geselska fraza <strong>uspešno onemogočena</strong>!\nNaprava vas po njej ne bo več spraševala ob odklepanju.",
    messageEnd: "Prosimo ponovno priklopite BitBox02",
    tips: "Namigi",
    tipsList: [
      "Priporočamo, da v denarnico zaščiteno s frazo najprej pošljete majhen znesek. Nato BitBox ponovno priklopite in vnesite geslo ter frazo. Če vse vnesete pravilno, boste lahko videli in upravljali kovance na tej denarnici.   ",
      "Če želite dostopati do privzete denarnice, nezaščitene z geselsko frazo, to še vedno lahko storite tako, da preskočite korak, ko vas BitBox povabi k vnosu faze."
    ],
    title: "Geselska fraza onemogočena"
  },
  summary: {
    button: "Omogočite geselsko frazo",
    title: "Povzetek",
    understand: "Razumem kako deluje geselska fraza in vsa povezana tveganja.",
    understandList: [
      "Geselska fraza je dodaten nivo zaščite za varnostno kopijo.",
      "Če vnesete različno geselsko frazo, boste vedno ustvarili različno denarnico.",
      "Za obnovitev denarnice potrebujete <strong>oboje, geselsko frazo in varnostno kopijo</strong>.",
      "Če pozabite ali izgubite svojo geselsko frazo, <strong>izgubite dostop do svojih kovancev.</strong>"
    ]
  },
  what: {
    button: "Spoznajte kako to deluje",
    message: 'Denarnica je ustvarjena (pridobljena) iz zelo velikega naključnega števila, znanega tudi kot seme (seed). To seme je ustvarjeno ob prvi nastavitvi naprave BitBox02 in je varnostno kopirano na microSD kartici ali z 24 besedami. Vsakdo, ki ima dostop do semena, ima popoln nadzor nad sredstvi v tej denarnici.\n\nGeselska fraza ali passphrase je <strong>opcijska skrivnost</strong>, ki je dodana semenu. Pri uporabi geselske fraze vsaka ustvari novo denarnico na podlagi preračuna semena + geselske fraze. Geselska fraza je lahko karkoli: črke, besede, posebni znaki ali pa je lahko celo prazna. Privzeta denarnica dejansko izhaja iz semena + prazne fraze.\n\n"Passphrase" ali geselska fraza je del BIP39 priporočila, kar pomeni, da je kompatibilna z vsemi denarnicami, ki sledijo temu priporočilu (ali kvazi standardu)',
    title: "Kaj je geselska fraza?"
  },
  why: {
    button: "Zakaj uporabiti geselsko frazo?",
    message: "BitBox02 varuje seme (skrivnost, ki jo ustvari) pred odtujitvijo (kopiranjem) iz same naprave, vendar varnostna kopija (na microSD kartici ali izpis 24 besed) omogoča popoln dostop do denarnice. Zato jo je treba hraniti na varnem mestu!\n\nKer geselska fraza ustvari novo denarnico z uporabo vašega obstoječega semena, denarnica zaščitena s frazo za obnovo zahteva oboje <strong>varnostno kopijo in geselsko frazo</strong>. Prednost tega je, da če nekdo najde vašo varnostno kopijo (v obliki 24 besed ali na microSD kartici), za dostop do kovancev še vedno potrebuje geselsko frazo.\n\nPoleg tega lahko z uporabo več geselskih fraz na enem BitBox-u upravljate mnogo med seboj ločenih denarnic!",
    title: "Zakaj uporabiti geselsko frazo?"
  }
};
const password$2 = {
  show: "Prikaži {{label}}",
  warning: {
    caps: "OPOZORILO: Vklopljene imate VELIKE ČRKE (⇪)",
    paste: 'da prilepite besedilo, omogočite "PRIKAŽI {{label}}"'
  }
};
const random$3 = {
  button: "Ustvari naključno število",
  description: "BitBox je ustvaril {{bits}}-bitno naključno število:"
};
const receive$4 = {
  bitsuranceWarning: "To je zavarovan račun, kar pomeni, da lahko prejema le tip Bitcoin naslova Native Segwit. To je zato, da slučajno ne prejmete t.i. starejšega  tipa Wrapped Segwit ali novejšega Taproot, ki nista zavarovana.",
  changeScriptType: "Spremenite tip naslova",
  label: "Vaš naslov",
  onlyThisCoin: {
    description: "Če želite prejemati druge podprte žetone, jih omogočite v nastavitvah. Če na naslove, ki so na voljo nakažete/pošljete nepodprte žetone, zelo verjetno ne bodo vidni/ dostopni.",
    warning: "Prepričajte se, da na ta naslov prejemate le {{coinName}}."
  },
  scriptType: {
    p2tr: "Taproot (najnovejša oblika)",
    p2wpkh: "Native Segwit (privzeto)",
    "p2wpkh-p2sh": "Wrapped Segwit (starejši tip)"
  },
  selectAccount: "Izberite račun",
  showFull: "Pokaži in preveri polni naslov na napravi",
  taprootWarning: "Opomba: Taproot je nov tip Bitcoin naslova, ki ni še povsod podprt. Sredstva, prejeta na Taproot naslov, morda ne bodo vidna v drugih denarnicah s katerim dostopate do svoje naprave. Številne denarnice in menjalnice še niso zmožne poslati na Taproot naslove.",
  title: "Prejmi {{accountName}}",
  verify: "Skrbno preverite naslov",
  verifyBitBox01: "Preverite naslov v mobilni aplikaciji",
  verifyBitBox02: "Preverite naslov na BitBox02",
  verifyInstruction: "Preverite, da se prikazan naslov ujema s tistim, ki je prikazan na BitBoxu in to potrdite na napravi.",
  warning: {
    secureOutput: "Prosimo, uparite BitBox z mobilno aplikacijo, da omogočite varno preverjanje naslovov. Pojdite na »Upravljanje naprave« v stranski vrstici."
  }
};
const reset$2 = {
  description: "Vsi podatki na napravi bodo izbrisani. To vključuje vaš zasebni ključ!",
  notReset: "Naprava NI ponastavljena.",
  title: "Ponastavi napravo (reset)",
  understand: "Imam varnostno kopijo in poznam geslo za njeno obnovitev",
  understandBB02: "Imam veljavno varnostno kopijo"
};
const securityInformation$2 = {
  create: {
    description1: "Priporočamo, da prvo nastavitev naprave izvedete v varnem okolju, kjer vas nihče ne opazuje in ne more beležiti vnašanja gesla.",
    description2: "Od vas se bo zahtevalo, da ustvarite dve gesli.",
    description3: "Prvo je <strong> geslo naprave</strong>, ki odklene vaš BitBox (napravo). Pozneje ga lahko spremenite.",
    description4: "Drugo je <strong>geslo za obnovitev</strong>, ki odklene vašo denarnico. Tega gesla kasneje ni mogoče spremeniti!",
    description5: "Ko ustvarite denarnico, bo ta shranjena v datoteko na microSD kartico. To lahko uporabite v nujnih primerih za povrnitev sredstev s pomočjo  <strong>gesla za obnovitev</strong>.",
    title: "Pomembne informacije"
  },
  restore: {
    description1: "Vstaviti boste morali microSD kartico, ki ste jo uporabili za shranjevanje varnostne kopije.",
    description2: "Če želite obnoviti denarnico, boste potrebovali geslo za obnovitev.",
    description3: "Bodite previdni in natančni pri vnosu gesla. Vsako geslo, ki ga vnesete, bo ustvarilo novo veljavno denarnico. Če vnesete napačno geslo, se vam bo verjetno prikazalo stanje denarnice, ki ga ne pričakujete.",
    title: "Varnostne informacije"
  }
};
const seed$2 = {
  agreements: {
    "funds-access": "da ostanem BREZ DOSTOPA do svojih sredstev, če pozabim to geslo!",
    "password-change": "pozneje NI MOŽNO spremeniti gesla za obnovitev!",
    "password-required": "Obnovitveno geslo je potrebno za obnovitev denarnice iz varnostne kopije"
  },
  create: "Ustvari denarnico",
  creating: "Ustvarjanje denarnice",
  description: "Razumem da:",
  error: {
    e102: "Geslo mora vsebovati najmanj 4 znake.",
    e200: "Za kreiranje nove denarnice morate v BitBox vstaviti microSD kartico. S tem omogočite samodejno kreiranje varnostne kopije."
  },
  info: {
    button: "Zdaj nastavite geslo za obnovo denarnice",
    description1: "Vstavite microSD kartico v BitBox",
    description2: 'Ustvarite geslo za obnovitev denarnice in izberite "Nastavi geslo za obnovitev"',
    description3: "Varnostna kopija na microSD kartici in geslo za obnovitev je edina metoda za povrnitev sredstev v primeru izgubljenega, uničenega ali ukradene denarnice BitBox01.",
    description4: "Pozneje ni možno spremeniti gesla za obnovitev brez prenosa sredstev.",
    title: "Ustvarite novo denarnico"
  },
  password: {
    label: "Geslo za obnovitev",
    repeatPlaceholder: "Ponovite geslo za obnovitev"
  },
  walletName: {
    label: "Ime denarnice"
  }
};
const seedRestore$2 = {
  error: {
    e200: "Obnova oz. priklic denarnice iz varnostne kopije zahteva microSD kartico."
  },
  info: {
    description1: 'Vstavite microSD kartico v BitBox in kliknite "Nadaljujte"',
    description2: "Izberite varnostno kopijo in kliknite »Obnovi«",
    description3: "Vnesite geslo za obnovo",
    description4: "Potrdite, da razumete, da bo napačno geslo ustvarilo drugo, novo denarnico.",
    title: "Kako obnoviti denarnico iz varnostne kopije"
  }
};
const send$4 = {
  abort: "Transakcija je bila prekinjena.",
  address: {
    label: "Naslov prejemnika",
    placeholder: "Vnesite naslov"
  },
  amount: {
    label: "Znesek",
    placeholder: "Vnesite znesek"
  },
  availableBalance: "Razpoložljivo stanje",
  button: "Podpiši in pošlji",
  coincontrol: {
    address: "Naslov",
    outpoint: "",
    title: "Pošlji iz (output):"
  },
  confirm: {
    "selected-coins": "Izbrani kovanci",
    title: "Potrdite in pošljite transakcijo",
    total: "Skupaj"
  },
  error: {
    erc20InsufficientGasFunds: "Kot kaže na vašem računu ni dovolj ETH za plačilo transakcije za premik ERC02 žetona. Poskrbite za zadostno količino ETH na vašem Ethereum računu.",
    feeTooLow: "Omrežnina je prenizka",
    feesNotAvailable: "Provizije ni moč oceniti",
    insufficientFunds: "nezadostna sredstva",
    invalidAddress: "neveljaven naslov",
    invalidAmount: "neveljaven znesek",
    invalidData: "neveljavni podatki"
  },
  fee: {
    customPlaceholder: "Vnesite znesek",
    label: "Omrežnina",
    placeholder: "Ni na voljo"
  },
  feeTarget: {
    customLabel: "Stopnja provizije",
    customLabel_eth: "Vrednost Gas-a",
    description: {
      economy: "4 ure (24 blokov)",
      economy_eth: "30 minut ali manj",
      economy_ltc: "1 ura (24 blokov)",
      high: "20 minut (2 bloka)",
      high_eth: "30 sekund ali manj",
      high_ltc: "5 minut (2 bloka)",
      low: "2 uri (12 blokov)",
      low_eth: "5 minut ali manj",
      low_ltc: "30 minut (12 blokov)",
      normal: "1 ura (6 blokov)",
      normal_eth: "2 minuti ali manj",
      normal_ltc: "15 minut (6 blokov)"
    },
    estimate: "Predviden čas potrditve:",
    label: {
      custom: "Po meri",
      economy: "Ekonomična",
      high: "Visoka",
      low: "Nizka",
      normal: "Normalna"
    },
    placeholder: "Preračunavam..."
  },
  maximum: "Pošlji vse",
  maximumSelectedCoins: "Pošlji izbrane kovance",
  noFeeTargets: "Generirane provizije trenutno niso dostopne. Prosimo poizkusite ponovno ali vnesite poljubno višino provizije.",
  priority: "Omrežnina",
  scanQR: "Skenirajte QR kodo",
  signprogress: {
    description: "Ta transakcija vsebuje veliko podatkov. Če želite v celoti podpisati transakcijo, boste morali potrditi {{steps}} krat.",
    label: "V teku"
  },
  success: "Transakcija je bila podpisana in poslana.",
  title: "Pošlji {{accountName}}",
  toggleCoinControl: "Odpri nadzor nad kovanci",
  transactionDetails: "Podrobnosti transakcije"
};
const settings$3 = {
  about: "Podatki o BitBoxApp",
  accounts: "Računi",
  advancedSettings: "Napredne nastavitve",
  appearance: "Izgled",
  electrum: {
    add: "Dodaj strežnik",
    "add-server": "Dodaj",
    check: "Preveri",
    checkFailed: "Ni uspelo",
    checkSuccess: "Uspelo je vzpostaviti povezavo do {{host}}",
    checking: "Preverjam",
    "download-cert": "Prenesite oddaljeni certifikat",
    "remove-server": "Odstrani",
    removeConfirm: "Odstrani {{server}}?",
    reset: "Ponastavi na privzeto",
    resetConfirm: "Ali želite odstraniti vse strežnike in namestiti privzete strežnike?",
    servers: "Strežniki",
    step1: "1",
    "step1-text": "Vnesite končno točko.",
    step2: "2",
    "step2-text": "Vnesite certifikat strežniške verige potrdil. Lahko pa prenesete oddaljeno potrdilo in ga vizualno primerjate.",
    "step2-text-tcp": "Ta korak lahko preskočite, če ne želite uporabljati TLS.",
    step3: "3",
    "step3-text": "Preverite povezavo in dodajte strežnik.",
    step4: "4",
    "step4-text": "Znova zaženite denarnico. Če ne odstranite privzetih strežnikov, bo vaše lastno vozlišče dodano kot redundančno.",
    "title-btc": "Strežniki Bitcoin Electrum-a",
    "title-ltc": "Strežniki Litecoin Electrum-a",
    "title-tbtc": "Strežniki Bitcoin Testnet Electrum-a",
    "title-tltc": "Strežniki Litecoin Testnet Electrum-a"
  },
  expert: {
    coinControl: "Omogoči nadzor nad kovanci (Coin control)",
    electrum: {
      description: "Povežete lahko svoje Electrum vozlišče.",
      title: "Povežite svoje polno vozlišče"
    },
    fee: "Omogoči provizije po meri",
    setProxyAddress: "Nastavite naslov proxy strežnika",
    title: "Napredne nastavitve",
    useProxy: "Omogoči tor proxy",
    useSats: "Prikaži vrednosti v Satoshi-jih"
  },
  header: {
    home: "Domov"
  },
  info: {
    "out-of-date": "Na voljo je nova nadgradnja",
    title: "Info",
    "up-to-date": "Aplikacija je posodobljena",
    version: "Verzija aplikacije"
  },
  restart: "Znova zaženite BitBoxApp, da spremembe začnejo veljati.",
  services: {
    title: "Storitve"
  },
  success: "Iztaknite in ponovno vtaknite BitBox v USB, da začnejo veljati ustvarjene spremembe.",
  title: "Nastavitve"
};
const setup$2 = "Nastavitev naprave";
const sidebar$3 = {
  buy: "Kupite kripto",
  device: "Upravljanje naprave",
  insurance: "Zavarovanje",
  leave: "Zapusti",
  settings: "Nastavitve"
};
const success$9 = {
  create: {
    info1: "Vaša denarnica je arhivirana na microSD kartico. \nOdstranite jo in jo varno shranite.",
    info2: "Ustvarili ste varno geslo, ki odklene BitBox.",
    info3: "Ustvarili ste varno geslo za obnovitev denarnice, ki odklene sredstva in obnovi varnostne kopije.",
    summary: "Preberite povzetek storjenega:",
    title: "Uspelo je!"
  },
  getstarted: "Začnite",
  restore: {
    summary: "Uspešno ste obnovili denarnico.",
    title: "Uspelo je!"
  }
};
const transaction$3 = {
  confirmation: "Št. potrditev",
  details: {
    activity: "Dejavnost",
    address: "Naslov",
    amount: "Znesek",
    date: "Datum",
    fiat: "V fiat valuti",
    fiatAmount: "Znesek v fiat valuti",
    fiatAtTime: "Vrednost v času transakcije",
    status: "Stanje",
    title: "Podrobnosti transakcije",
    type: "Tip"
  },
  explorer: "ID transakcije",
  explorerTitle: "Odpri v zunanjem raziskovalcu",
  fee: "Omrežnina",
  fiatHistorical: "Zgodovinsko",
  gas: "Gas",
  note: {
    edit: "Uredi opombo",
    save: "Shrani opombo"
  },
  pending: "Nedokončana transakcija",
  size: "Velikost",
  status: {
    complete: "Zaključeno",
    failed: "Ni uspelo",
    pending: "V teku"
  },
  tx: {
    received: "Prejeto na",
    sent: "Poslano na"
  },
  vsize: "Virtualna velikost",
  weight: "Utež"
};
const transactions$2 = {
  errorLoadTransactions: "Napaka pri nalaganju transakcij.",
  placeholder: "Ni transakcij."
};
const unknownError$2 = "Prišlo je do neznane napake: {{errorMessage}}";
const unlock$2 = {
  description: "Vnesite geslo, da odklenete napravo.",
  error: {
    e109_normal: "Napačno geslo naprave. Št. poskusov pred ponastavitvijo naprave: {{remainingAttempts}}",
    e109_touch: "$t(unlock.error.e109_normal) Naslednja prijava zahteva daljše držanje gumba na dotik.",
    e113: "Zaradi prevelikega števila poskusov prijave, morate za novo prijavo pridržati tipko za dotik vsaj 4 sekunde."
  },
  input: {
    label: "Geslo naprave",
    placeholder: "...vnesite tukaj."
  },
  unlocking: "Odklepanje..."
};
const upgradeFirmware$3 = {
  button: "Nadgradite strojno programsko opremo",
  description: "Ali želite nadgraditi strojno programsko opremo iz različice {{currentVersion}} na {{newVersion}}?",
  label: "Vaš BitBox zahteva nadgradnjo strojne programske opreme.",
  locked: "Za nadgradnjo z {{currentVersion}} na {{newVersion}}, izvedite dolg pritisk na LED lučko.",
  title: "Nadgradite strojno programsko opremo",
  unlocked: "Zaganjalnik (bootloader) je odklenjen. Če želite nadaljevati:",
  unlocked1: "Iztaknite in ponovno priključite svoj Bitbox",
  unlocked2: "Ko bo BitBox01 ponovno priključen bo zasvetila LED lučka",
  unlocked3: "Ko zasveti LED lučka, se jo dotaknite"
};
const walletConnect$3 = {
  connect: {
    button: "Poveži",
    dappLabel: "Vnesi URI naslov za DApp",
    invalidPairingUri: "Napačen povezovalni URI"
  },
  dashboard: {
    allSessions: "Vse seje",
    disclaimer: "WalletConnect je protokol za povezavo z decentraliziranimi avtonomnimi aplikacijami (Dapps), ki temeljijo na Ethereumu. Te Dapps-e upravljajo tretje oseb (in ne Shift Crypto ali WalletConnect), zato se povežite le s tistimi, ki jim zaupate, in se prepričajte, da vedno veste, kaj podpisujete, ko opravljate transakcijo.",
    newConnection: "Nova povezava",
    noConnectedSessions: "Noben račun ni povezan s katero od DApp-ov"
  },
  invalidPairingChain: "Napaka pri potrditvi povezave. Prepričajte se, da uporabljate eno od podprtih verig: {{chains}}",
  pairingRequest: {
    approve: "Potrdi povezavo",
    reject: "Zavrni",
    title: "Zahteva za novo povezavo od"
  },
  pairingSuccess: "DApp je uspešno povezana. Nadaljujete lahko na spletni strani te DApp.",
  signingRequest: {
    account: "Račun",
    chain: "Omrežje",
    dapp: "Dapp",
    data: "Podatki",
    dataParsingError: "Podatkov nismo uspeli razčleniti",
    decodeError: "Sporočila nismo uspeli dekodirati",
    method: {
      sendTransaction: "Podpiši in pošlji transakcijo",
      signMessage: "Podpiši sporočilo",
      signTransaction: "Podpiši transakcijo",
      signTypedData: "Podpiši vnesene podatke"
    },
    successfullySigned: "Zahteva je uspešno podpisana",
    walletConnectRequest: "WalletConnect zahteva "
  },
  useNewUri: "Ta URI je bil že uporabljen za poskus vzpostavitve povezave. Uporabite nov URI.",
  walletConnect: "WalletConnect"
};
const warning$8 = {
  receivePairing: "Prosimo, da seznanite BitBox01 s pametnim telefonom, da si omogočite varno preverjanje naslovov. Pojdite na »Upravljanje naprave« v stranski vrstici.",
  sdcard: "MicroSD kartico hranite ločeno od BitBoxa, razen ko upravljate z varnostnimi kopijami.",
  sendPairing: "Za varno preverjanje podrobnosti o transakcijah seznanite BitBox\nz mobilno napravo. Pojdite na »Upravljanje naprave« v stranski vrstici."
};
const welcome$2 = {
  connect: "Vklopi BitBox02",
  getStarted: "Začnimo z namestitvijo strojne programske opreme (firmware)",
  insertBitBox02: "Na BitBox02 se dotaknite željene strani zaslona. ",
  insertDevice: "Za začetek, priključite denarnico",
  title: "Dobrodošli"
};
const appTranslationsSL = {
  account: account$2,
  accountInfo: accountInfo$2,
  accountSummary: accountSummary$2,
  addAccount: addAccount$3,
  aopp: aopp$1,
  app: app$2,
  auth: auth$2,
  backup: backup$2,
  bb02Bootloader: bb02Bootloader$2,
  bitbox: bitbox$2,
  bitbox02Interact: bitbox02Interact$2,
  bitbox02Settings: bitbox02Settings$2,
  bitbox02Wizard: bitbox02Wizard$2,
  bitsurance: bitsurance$1,
  bitsuranceAccount: bitsuranceAccount$1,
  blink: blink$2,
  bootloader: bootloader$2,
  button: button$7,
  buy: buy$3,
  changePin: changePin$2,
  chart: chart$3,
  checkSDcard: checkSDcard$2,
  clickHere: clickHere$2,
  confirm: confirm$4,
  confirmOnDevice: confirmOnDevice$2,
  connectKeystore: connectKeystore$2,
  darkmode: darkmode$2,
  device: device$2,
  deviceLock: deviceLock$2,
  deviceSettings: deviceSettings$2,
  deviceTampered: deviceTampered$2,
  dialog: dialog$3,
  error: error$3,
  fiat: fiat$4,
  footer: footer$4,
  generic: generic$3,
  genericError: genericError$2,
  goal: goal$2,
  guide: guide$3,
  headerssync: headerssync$2,
  hiddenWallet: hiddenWallet$2,
  initialize: initialize$2,
  invalidFormat: invalidFormat$2,
  language: language$3,
  legacyhiddenwallet: legacyhiddenwallet$2,
  loading: loading$2,
  manageAccounts: manageAccounts$1,
  mobile: mobile$2,
  newSettings: newSettings$1,
  note: note$3,
  notification: notification$2,
  pairing: pairing$2,
  passphrase: passphrase$1,
  password: password$2,
  random: random$3,
  receive: receive$4,
  reset: reset$2,
  securityInformation: securityInformation$2,
  seed: seed$2,
  seedRestore: seedRestore$2,
  send: send$4,
  settings: settings$3,
  setup: setup$2,
  sidebar: sidebar$3,
  success: success$9,
  transaction: transaction$3,
  transactions: transactions$2,
  unknownError: unknownError$2,
  unlock: unlock$2,
  upgradeFirmware: upgradeFirmware$3,
  walletConnect: walletConnect$3,
  warning: warning$8,
  welcome: welcome$2
};
const account$1 = {
  disconnect: "...החיבור אבד. מנסה שוב",
  "export": "ייצוא",
  exportTransactions: "יצא עסקאות כקובץ רשומות לתיקיית ההורדות",
  fatalError: ".אירעה שגיאה לא צפויה",
  incoming: "נכנס",
  initializing: "מייבא נתונים מהבלוקצ׳יין..",
  reconnecting: "...החיבור אבד, מנסה להתחבר מחדש",
  syncedAddressesCount: "כתובות {{count}} סורק"
};
const accountInfo$1 = {
  address: "כתובת",
  extendedPublicKey: "מפתח ציבורי מורחב",
  label: "פרטי חשבון",
  title: "פרטי חשבון",
  verify: "אמת עם ההתקן"
};
const accountSummary$1 = {
  availableBalance: "יתרה זמינה",
  balance: "יתרה",
  exportSummary: "ייצא סיכום חשבונות כקובץ רשומות לתיקיית ההורדות",
  fiatBalance: "יתרה במטבע פיאט",
  name: "שם חשבון",
  noAccount: "אין חשבונות להצגה",
  title: "סיכום חשבונות",
  total: "סכום סופי",
  transactionHistory: "היסטוריית עסקאות"
};
const addAccount$2 = {
  title: "הוספת חשבון"
};
const app$1 = {
  upgrade: "גרסה חדשה של תכנה זו זמינה! אנא עדכן מ{{current}} ל{{version}}"
};
const backup$1 = {
  check: {
    checking: "...בודק גיבוי",
    confirmTitle: "בדיקת גיבוי",
    notOK: ".הגיבוי לא תואם את הארנק",
    ok: ".הגיבוי תואם את הארנק",
    password: {
      label: "סיסמת שיחזור",
      placeholder: "סיסמת שיחזור",
      showLabel: "סיסמת שיחזור"
    },
    success: ":גיבוי אומת בהצלחה",
    title: "בדיקת גיבוי"
  },
  create: {
    alreadyExists: "?ברשותך גיבוי תקין. האם ליצור חדש כעת",
    fail: "!יצירת הגיבוי לא הצליחה",
    info: ".אנא הזן את סיסמת הגיבוי של ארנק זה לצורך אימות",
    name: {
      label: "שם הגיבוי",
      placeholder: "אנא תן שם לגיבוי"
    },
    password: {
      label: "סיסמת שיחזור",
      placeholder: "אנא הזן את סיסמת שיחזור"
    },
    title: "יצירת גיבוי",
    verificationFailed: ".סיסמת השחזור אינה תואמת את הארנק הנוכחי. גיבוי נוצר. אנא בדוק את סיסמת השיחזור שוב"
  },
  description: "בחר <strong>קובץ גיבוי לארנק</strong>",
  insert: "אנא הכנס כרטיס זיכרון בכדי לנהל גיבויים",
  insertButton: "הכנסתי את כרטיס הזיכרון",
  list: "גיבויי כרטיס הזיכרון שלך",
  noBackups: "כרטיס הזיכרון אינו מכיל גיבויים",
  restore: {
    confirmTitle: "שיחזור גיבוי",
    error: {
      e200: "כרטיס זיכרון לא נמצא",
      general: "שגיאה בשיחזור הגיבוי"
    },
    password: {
      label: "סיסמת שיחזור או סיסמת שיחזור מוסתרת",
      placeholder: "סיסמת שיחזור",
      repeatPlaceholder: "חזור פעם נוספת על סיסמת השיחזור",
      showLabel: "סיסמת שיחזור"
    },
    restoring: "...משחזר גיבוי",
    title: "שיחזור",
    understand: "אני מבין שסיסמת שחזור שגויה תיצור ארנק שונה"
  },
  showMnemonic: {
    description: ".כעת יוצגו 24 מילים, המייצגות גיבוי לארנק. רשום אותם על דף נייר\n\n<strong>אל תאחסן אותם ברשת או תצלם אותם</strong>\n<strong>אל תאמר מילים אלו בקול</strong>\n<strong>הגיבוי אינו מאובטח בסיסמה</strong>\n\n.לאחר מכן, תתבקש לאשר כל מילה",
    title: "mnemonic seed -הצג"
  },
  title: "נהל גיבויים"
};
const bb02Bootloader$1 = {
  abort: "אל תשדרג - קח אותי חזרה",
  advanced: {
    label: "הגדרות מתקדמות",
    toggleShowFirmwareHash: "הצג את גיבוב הקושחה בכל הדלקה "
  },
  flipscreen: "הפוך מסך",
  orientation: "?ההתקן מכוון בכיוון שגוי",
  success: "...עדכון צלח! ממשיך בעוד {{rebootSeconds}} שניות"
};
const bitbox$1 = {
  error: {
    e10000: ".סיסמה שגויה עבור התקן נוכחי",
    e10001: "החלפת סיסמת התקן נכשלה",
    e102: ".הסיסמה חייבת להיות בת 4 תווים לפחות",
    e112: ".סיסמת התקן חבויה לא יכולה להיות זהה לסיסמת התקן ראשית"
  }
};
const bitbox02Interact$1 = {
  confirmDate: "אשר את התאריך של היום בביטבוקס02",
  confirmDateText: ".התאריך ישמש ליצירת הגיבוי",
  confirmName: "אשר את השם בביטבוקס02",
  followInstructions: "אנא התקדם לפי הוראות בביטבוקס02",
  followInstructionsMnemonic: "mnemonic seed -המשך עם ההוראות לפי המופיע בביטבוקס02 שלך כדי לשחזר מ"
};
const bitbox02Settings$1 = {
  deviceName: {
    current: "שם התקן נוכחי",
    input: "שם ביטבוקס02",
    placeholder: "שם התקן חדש",
    title: "קבע שם לביטבוקס02"
  }
};
const bitbox02Wizard$1 = {
  attestationFailed: ".תעודת ההתקן נכשלה, זה יכול לנבוע מההפעלה מחודשת של היישום בזמן שהמכשיר חיכה לקלט מהמשתמש. התחבר מחדש ונסה שוב",
  backup: {
    point1: "בחר גיבוי מכרטיס הזיכרון",
    point2: "קבע סיסמה להתקן",
    restoreText: "!אוקי, משחזר מהגיבוי",
    text1: ".נהדר, הסיסמה לביטבוקס02 נקבעה והארנק נוצר. כעת זה הזמן ליצור את הגיבוי הראשון. אנא וודא שכרטיס הזיכרון נמצא בתוך הביטבוקס02 ולאחר-מכן המשך",
    text2: "אנא עקוב אחר ההוראות המופיעות על גבי מסך ההתקן בכדי ליצור גיבוי",
    text3: ".לאחר שהגיבוי נוצר, אנא הסר את כרטיס הזיכרון ואחסן את זה <strong>במקום בטוח</strong>. המידע המוכל בכרטיס הזיכרון אינו מוגן בסיסמה. לעולם אל תכניס את כרטיס הזיכרון לביטבוקס02 שאינו שלך",
    userConfirmation1: ".אני אמור לשמור על הגיבוי במקום מאובטח",
    userConfirmation2: ".הגיבוי שלי אינו מוגן בסיסמה. כל אחד עם גישה לגיבוי יכול לגשת לארנק שלי",
    userConfirmation3: ".אם אאבד או שהביטבוקס02 יפגע, הדרך היחידה לשחזר את הנכסים היא באמצעות הגיבוי שלי",
    userConfirmation4: ".אם אאבד או יפגעו, ביטבוקס02 והגיבוי, כל הנכסים יאבדו",
    userConfirmation5: "אני לא אמור להכניס את כרטיס הזיכרון לשום מחשב, פלאפון, מדפסת או מכשיר אחר מלבד לארנק"
  },
  create: {
    button: "הזן שם להתקן והמשך",
    info: ":מספר צעדים בסיסיים בהגדרת ההתקן",
    inputTitle: "שם ארנק",
    point1: "הזן שם להתקן",
    point2: "הזן סיסמה להתקן",
    point3: "צור גיבוי",
    text: "!אוקיי, בואו ניצור ארנק חדש"
  },
  createBackupFailed: ".יצירת גיבוי נכשלה, נסה שוב",
  initialize: {
    passwordText: ".עכשיו נקבע סיסמה להתקן. השתמש בחיישני הביטבוקס כדי לבחור סיסמה",
    passwordTitle: "קבע סיסמה לביטבוקס שלך",
    text: "צימוד התקן נוצר בהצלחה! כעת יש לאתחל את הביטבוקס02. התחל בבחירת יצירת ארנק חדש או שיחזור מתוך גיבוי קיים. <strong>אנא וודא כי הכנסת את כרטיס הזיכרון לביטבוקס02</strong>",
    tip: ".אנו ממליצים שתמשיך במקום בטוח",
    title: "אתחל את ההתקן"
  },
  insertSDCard: "<strong>אנא וודא שכרטיס הזיכרון נמצא בתוך הביטבוקס02</strong>",
  noPasswordMatch: ".סיסמאות לא תואמות, אנא נסה שוב",
  pairing: {
    failed: ".צימוד לא אושר. חבר מחדש את הביטבוקס02",
    paired: ".אישרת כי הצופן זהה בהתקן. אם זה נכון, אתה יכול להמשיך בלחיצה על הכפתור מטה",
    title: "אמת צופן צימוד",
    unpaired: ".ביטבוקס02 חדש זוהה. אנא אמת שהצופן תואם לזה המוצג על המסך. אם הצופן זהה, גע בלחצן האישור ולחץ על הכפתור מטה כדי להמשיך"
  },
  restoreFromMnemonic: {
    failed: ".נכשל, אנא נסה שוב mnemonic seed -שיחזור מ"
  },
  stepBackup: {
    beforeProceed: ":לפני שתמשיך, אנא קרא את שיקולי האבטחה החשובים הבאים",
    createBackup: ".גיבוי לא יווצר בכרטיס הזיכרון"
  },
  stepBackupSuccess: {
    fundsSafe: ":על-מנת לאבטח את הנכסים, זכור",
    title: "!הגיבוי שוחזר"
  },
  stepConnected: {
    unlock: "הזן את סיסמת הביטבוקס02 כדי לבטל נעילה"
  },
  stepCreate: {
    nameLabel: "שם ביטבוקס02",
    namePlaceholder: "הביטבוקס02 שלי",
    title: "בחר שם לביטבוקס02",
    toastMicroSD: ".אנא וודא כי כרטיס הזיכרון נמצא בתוך הביטבוקס02"
  },
  stepCreateSuccess: {
    removeMicroSD: ".אנא הסר את כרטיס הזיכרון מהביטבוקס02 ואחסן אותו במקום בטוח",
    success: ".יצרת בהצלחה גיבוי"
  },
  stepInsertSD: {
    insertSDCard: ".אנא הכנס כרטיס זיכרון לתוך הביטבוקס02 כדי להמשיך",
    insertSDcardTitle: ".הכנס כרטיס זיכרון"
  },
  stepPassword: {
    title: "קבע סיסמה לביטבוקס02",
    useControls: ".השתמש בפקדים כדי לקבוע סיסמה לביטבוקס02"
  },
  stepUninitialized: {
    create: ".אני מעוניין להגדיר ביטבוקס02 חדש",
    restore: ".אני רוצה לשחזר את הארנק שלי מגיבוי",
    restoreMicroSD: "שחזר מכרטיס זיכרון",
    restoreMnemonic: "mnemonic seed -שיחזור",
    title: "הגדר את הביטבוקס02 שלך"
  },
  success: {
    text: ".הידד! הביטבוקס02 שלך מוכן לשימוש\n\n.בשביל מידע נוסף כיצד להשתמש בתכנה, השתמש במדריך המובנה בלחיצת על כפתור השאלה בפינה הימנית העליונה",
    title: "!אתה מוכן להמשיך"
  }
};
const blink$1 = {
  button: "הבהוב"
};
const bootloader$1 = {
  button: "שדרג קושחה עכשיו",
  progress: "%משדרג: {{progress}}",
  success: ".שודרג בהצלחה! אנא חבר מחדש את ההתקן. הפעם, אל תגע בכפתור"
};
const button$6 = {
  abort: "בטל",
  back: "חזור",
  buy: "קנה",
  changepin: "החלף סיסמת התקן",
  check: "בדוק גיבוי",
  "continue": "המשך",
  copy: "העתק",
  create: "צור",
  download: "הורד",
  hiddenwallet: "צור ארנק מוסתר",
  next: "הבא",
  ok: "בסדר",
  previous: "הקודם",
  receive: "קבל",
  restore: "שחזר",
  select: "בחר",
  send: "שלח",
  unlock: "בטל נעילה",
  update: "עדכן",
  upgrade: "שדרג"
};
const buy$2 = {
  title: "קנה {{name}}"
};
const changePin$1 = {
  newTitle: "סיסמת התקן חדשה",
  oldLabel: "סיסמת התקן נוכחית"
};
const chart$2 = {
  dataMissing: "אנחנו עדיין אוספים נתונים, נסה בעוד מספר דקות פעם נוספת",
  dataUpdating: "...מעדכן נתונים",
  filter: {
    all: "הכל",
    month: "חודש",
    week: "שבוע",
    year: "שנה"
  }
};
const checkSDcard$1 = "בודק כרטיס זיכרון";
const clickHere$1 = ".לחץ כאן";
const confirm$3 = {
  abortInfo: "הקש כדי",
  abortInfoRedText: "לבטל",
  approveInfo: "החזק 4+ שניות כדי",
  approveInfoGreenText: "לאשר",
  info: ".המשך בביטבוקס",
  infoWhenPaired: "תחילה במכשיר המוצמד ואז בביטבוקס"
};
const confirmOnDevice$1 = ".אנא אשר בהתקן שלך";
const device$1 = {
  appUpradeRequired: ".הביטבוקס שלך אינו נתמך על-ידי היישום. הורד והתקן את הגרסה האחרונה"
};
const deviceLock$1 = {
  button: "אשר אימות דו-שלבי",
  condition1: "?יש ברשותך גיבוי",
  condition2: "?האם האימות בידי היישום עובד",
  condition3: "אימות דו-שלבי משבית גיבויים וצימוד למכשיר נייד. ההתקן חייב להתאתחל בכדי לצאת מאימות דו-שלבי",
  confirm: "אפשר אימות דו-שלבי",
  title: "אפשר אימות דו-שלבי"
};
const deviceSettings$1 = {
  firmware: {
    newVersion: {
      label: "גרסה זמינה"
    },
    title: "קושחה",
    upToDate: "ההתקן שלך מעודכן",
    version: {
      label: "גרסה"
    }
  },
  hardware: {
    sdcard: {
      "false": "לא הוכנס",
      label: "כרטיס זיכרון",
      "true": "הכנס"
    },
    title: "תכנה"
  },
  loading: "מאחזר מידע על התקן",
  pairing: {
    lock: {
      "false": "בטל",
      label: "אימות דו-שלבי",
      "true": "אפשר"
    },
    mobile: {
      "false": "סגור",
      label: "יישום נייד",
      "true": "פתח"
    },
    status: {
      "false": "לא צומד",
      label: "מצב",
      "true": "צומד"
    },
    title: "מצמיד"
  },
  secrets: {
    manageBackups: "נהל גיבויים",
    title: "סודות"
  }
};
const deviceTampered$1 = ".הביטבוקס שלך סופק עם סיסמת שיחזור? אם כן, עצור מיד את התהליך וצור קשר עם התמיכה. החברה לעולם לא תספק ארנק מוגדר או תמליץ על סיסמאות";
const dialog$2 = {
  cancel: "בטל",
  confirm: "אשר",
  confirmTitle: "אישור"
};
const fiat$3 = {
  "default": "ברירת מחדל",
  setDefault: "הגדר {{code}} כברירת מחדל",
  title: "מטבעות"
};
const footer$3 = {
  appVersion: "גרסת תכנה:"
};
const generic$2 = {
  enabled_false: "מושבת",
  enabled_true: "מופעל"
};
const genericError$1 = "שגיאה התרחשה. אם אתה מבחין בחריגות, התחל מחדש את התכנה.";
const goal$1 = {
  buttons: {
    create: "צור ארנק חדש",
    restore: "שחזר ארנק מגיבוי"
  },
  paragraph: "בחר אחת מהאפשרויות הבאות:",
  step: {
    "1": {
      title: "מידע אודות אבטחה"
    },
    "2": {
      description: "קבע סיסמת התקן",
      title: "התקן"
    },
    "3-create": {
      description: "צור ארנק חדש",
      title: "ארנק"
    },
    "3-restore": {
      description: "מגיבוי",
      title: "שיחזור"
    },
    "4-create": {
      title: "סיכום"
    },
    "4-restore": {
      title: "סיכום"
    }
  }
};
const guide$2 = {
  accountDescription: {
    text: ".סקירת החשבון שלך מציגה את היתרה הזמינה שלך כמו גם עסקאות נכנסות ויוצאות. המדריך שלנו ב'הגדרות 'כולל מידע נוסף על כל סוג חשבון",
    title: "?מה עמוד זה מציג לי"
  },
  accountFiat: {
    text: ".כן. לחץ על השער ההמרה כדי לעבור למטבע פיאט אחר. ניתן לשנות את רשימת המטבעות בהגדרות",
    title: "?האם אוכל להציג שיעורי המרה אחרים"
  },
  accountIncomingBalance: {
    text: ".סכומים המתקבלים לארנק שלך אל טרם אושרו ברשת",
    title: "?למה הכוונה במתקבלים"
  },
  accountInfo: {
    xpub: {
      text: ".מפתח ציבורי מורחב הוא מקור כל כתובות הקבלה של המשתמש\n.המפתח מסופק פה לשימוש מתקדם ושיתוף עם ארנקי תצוגה בלבד, כמו אלקטרום או סנטינל",
      title: "?מה זה מפתח ציבורי מורחב"
    }
  },
  accountRates: {
    text: "אנחנו מעדכנים את שערי החליפין אחת לדקה לפי קריפטו-קומפר.",
    title: "?אילו שערי חליפין חלים"
  },
  accountReload: {
    text: ".אין צורך. פרטי העסקה שלך מתעדכנים אוטומטית",
    title: "?אני יכול לטעון מחדש את היסטוריית העסקאות"
  },
  accountSendDisabled: {
    text: ".כפתור 'שלח' זמין כשהיתרה גדולה מאפס",
    title: "?מדוע אני לא יכול לשלוח עד {{unit}}"
  },
  accountSummaryAmount: {
    text: "coingecko.com הסכום הסופי הוא סכימת כל חשבונות הקריפטו שלך. שערי המרה נלקחים מ\n\nלאסימונים שלא נתמכים בתכנה זו, הם לא יכללו בכמות המוצגת MyEtherWallet הערה: אם אתה משתמש ב\n\n",
    title: "?כיצד הכמות הסופית מחושבת"
  },
  accountSummaryDescription: {
    text: "כאן תוכל לראות את ביצועי תיק ההשקעות שלך לאורך זמן. סיכום של ארנקי הקריפטו שלך מוצגים תחת טבלה זו",
    title: "?מה עמוד זה מראה לי"
  },
  accountTransactionAttributesBTC: {
    text: ".גודל וירטואלי: קובע את דמי הרשת. חסכת בהצלחה בעמלות אם הוא קטן מגודל העסקה\n.גודל: גודל עסקה בפועל בבתים בהמשכים לפי הבלוקצ׳יין הבסיסי\n.כדי להעריך גדלים של עסקאות וחסימה. כל ביי עד מופרד נחשב לאחת, וכל השאר כארבע יחידות משקל. במקום מגה-בייט אחת בגודל בפועל, מגבלת גודל החסימה היא כעת ארבעה מיליון יחידות משקל SegWit משקל: ערך חדש שהוצג עם",
    title: "?מה לגבי פרטים מדוייקים של עסקת ביטקויין"
  },
  accountTransactionAttributesGeneric: {
    text: ".אישורים: שידור העסקה שלך אינו מאושר עד שכורה יכלול אותו בבלוק, שלאחריו יש אישור אחד. כל בלוק המשודר ברשת מוסיף אישור נוסף לעסקה שלך. בדרך כלל סוחרים ומשתמשים אחרים ברשת יאשרו עסקאות רק בין שלוש לשש אישורים\n.מזהה עסקה: מספר זיהוי ייחודי המאפשר לחפש עסקה בחוקר בלוקים\n.עמלה: לכורים משולמים עמלת עסקה כתמריץ לכלול עסקאות בגושים שהם מכורים. למידע נוסף, לחץ על כפתור שלח",
    title: "?מה הם האישורים בפרטי העסקה"
  },
  accountTransactionConfirmation: {
    text: ".עסקה ששודרה לרשת אך טרם אושרה",
    title: "?מה היא עסקה בהמתנה"
  },
  accountTransactionLabel: {
    text: ".זו היא הכתובת אליה התקבלו או נשלחו ממנה מטבעות",
    title: "?מה היא הכתובת המוצגת לכל עסקה"
  },
  accountTransactionTime: {
    text: ".שעת אישור ביצוע העסקה לפי הבלוקצ׳יין",
    title: "?מה הוא הזמן המוצג"
  },
  appendix: {
    link: "צור עימנו קשר",
    text: "שאלה נוספת?"
  },
  backups: {
    check: {
      text: ".בדיקת גיבוי' מאפשר לך לאשר כי ברשותך גיבוי תקין המגיב לארנק הנוכחי שלך. בדיקה זו גם מוודאת שיש ברשותך את סיסמת השיחזור הנכונה. באפשרותך לבדוק את סיסמת השיחזור הראשית או סיסמת השיחזור המוסתרת'",
      title: "'מה זה 'בדיקת גיבוי"
    },
    encrypt: {
      text: ".המאוחסן Seed -לא, אך סיסמת השחזור שלך נדרשת כדי להפיק את הארנק מה",
      title: "?האם ניתן להצפין את הגיבוי"
    },
    howOften: {
      text: ".הגיבוי נוצר באופן אוטומטי כשארנק חדש נוצר. עלייך ליצור גיבוי חדש רק אם כרטיס הזיכרון אבד או ניזוק, או אם ברצטנך להחזיק מספר עותקים לגיבוי\n.אין צורך ליצור גיבוי אחרי עסקאות. כל נתוני העסקאות נוצרים מחדש באמעצות הגיבוי שנוצר אוטומטית בשבילך",
      title: "?באיזו תדירות עלי לבצע גיבוי"
    },
    whatIsABackup: {
      text: ".עם סיסמת השיחזור יוצרים את הארנק שלך Seed -על גבי כרטיס הזיכרון. ה Seed -זהו העתק של ה",
      title: "?מה זה גיבוי"
    }
  },
  backupsBB02: {
    check: {
      text: ".בדיקת גיבוי' מאפשר לך לאשר כי ברשותך גיבוי תקין המגיב לארנק הנוכחי שלך'",
      title: "?'מה זה 'בדיקת גיבוי"
    },
    encrypt: {
      text: '.באמצעות סיסמה, תוכל לאפשר ביטוי סיסמא אופציונאלי בהגדרות המומחה תחת "נהל מכשיר״ Seed -הלא מוצפן כדי לשחזר את הארנק. אם ברצונך להגן על ה Seed -לא. אנא שמור על בטיחות כרטיס הזיכרון, מכיוון שהוא מכיל את ה',
      title: "?האם ניתן להצפין את הגיבוי"
    },
    whatIsABackup: {
      text: ".על גבי כרטיס הזיכרון Seed -זה הוא העתק של ה",
      title: "?מה זה גיבוי"
    }
  },
  bitbox: {
    "2FA": {
      text: ".כאשר אימות דו-שלבי מופעל, יש לאשר את כל העסקאות בטלפון הנייד המוצמד כדי לשלוח מטבעות. מתחת ל״פני השטח״ נשלח לאפליקציה הסלולרית מספר מוצפן לשימוש חד-פעמי, מפוענח שם, ומוחזר לביטבוקס בעת לחיצה על כפתור קבל. תקשורת זו עם המכשיר נעשית דרך הערוץ שבין הטלפון הנייד לבין אפליקציית שולחן העבודה הזו שנוצרה במהלך ההצמדה\n\n.הקפד לגבות את הארנק שלך ולשייך את האפליקציה לנייד לפני שתפעיל את האימות הדו-שלבי. לאחר ההפעלה, חריץ כרטיס הזיכרון והתאמת היישום לנייד מושבתים. ניתן להפעיל אותם מחדש על ידי איפוס הביטבוקס שמוחק את המכשיר",
      title: "?איך אימות דו-שלבי עובד"
    },
    disable2FA: {
      text: "על-מנת לבטל את האימות הדו-שלבי, עלייך לאתחל מחדש את הביטבוקס ולאחר מכן לשחזר את הארנק מהגיבוי. אנא וודא כי יש ברשותך את כרטיס הזיכרון עם הגיבוי ושהינך זוכר את סיסמת השיחזור. לאחר מכן לחץ 'אפס התקן'. הגדר סיסמת התקן חדשה ובחר באפשרות 'או שחזר מגיבוי'. בחר את הגיבוי שיצרת לארנק ולחץ 'שחזר' והזן את סיסמת השיחזור שהשתמשת בה בכדי ליצור את הארנק.",
      title: "?איך אני יכול להשבית את האימות הדו-שלבי"
    },
    ejectBitbox: {
      text: ".ניתוק הביטבוקס אפשרי בכל שלב",
      title: "?כיצד ניתן לנתק את הביטבוקס"
    },
    ejectSD: {
      text: ".הסרת כרטיס הזיכרון מהביטבוקס אפשרית בכל שלב, מלבד כאשר בתהליך או ביצירת גיבוי",
      title: "?כיצד ניתן לנתק את כרטיס הזיכרון"
    },
    hiddenWallet: {
      text: ".גיבוי משמש לארנק הרגיל והחבוי שלך, כך שלא נדרש גיבוי נוסף Seed -זהו ארנק שני על אותו התקן, מוגן באמצעות סיסמת התקן ושיחזור שונה עם אותו",
      title: "?מה הוא ארנק מוסתר"
    },
    legacyHiddenWallet: {
      text: ".תחילה הקש על הכפתור מטה (זמין אם הביטבוקס לא נעול עם הסיסמת ההתקן הראשית ואימות דו-שלבי מושבת), לאחר מכן חבר את הביטבוקס מחדש ותבטל את הנעילה עם סיסמת ההתקן הסודית",
      title: "?כיצד לגשת לארנק מוסתר מהדור הקודם"
    },
    pairing: {
      text: ".המגדיר ערוץ מאובטח בין המכשיר היישום לתכנה, QRלאחר הורדת יישום הנייד שלנו לאייפון או לאנדראודי, תסרוק את צופן ה \n.לאחר הסריקה, עקוב אחר ההוראות ביישום הנייד",
      title: "כיצד לצמד באופן מאובטח את מכשיר הפלאפון"
    }
  },
  receive: {
    address: {
      text: "באפשרותך לתת את הכתובת לאחרים בכדי לשלוח לך מטבעות. תוודא שאתה שולח את הכתובת הנכונה",
      title: "?מה אני עושה עם כתובת"
    },
    addressChange: {
      text: ".ברגע שעסקה מתבצעת, כתובת חדשה נוצרת ומוספת לרשימה, כך שתמיד יש ברשותך 20 כתובות שמעולם לא קיבלו מטבעות",
      title: "?מתי כתובות משתנות"
    },
    addressFormats: {
      text: "כברירת מחדל, ארנק הביטבוקס משתמש בכתובות מהסוג החדש ביותר. אם קיימת בעיה בשימוש בסוג כתובות אלו, ניתן ללחוץ על שינוי סוג הכתובות לסוג הקודם",
      title: "?מה ההבדלים בין כתובות מהדור הקודם לדור החדש"
    },
    howVerify: {
      text: "בביטבוקס01, לחץ על סמל הביטבוקס בתפריט בצד שמאל וחפש את הגדרת הצימוד. המדריך יתעדכן ותוכל להמשיך במעקב אחרי ההוראות משם\nבביטבוקס02, תוכל לאשר את הכתובת ישירות מההתקן בזמן תהליך השליחה או הקבלה",
      title: "?כיצד אני יכול לאמת בבטחה כתובת"
    },
    why20: {
      text: '.כדי לראות אם קיבלו כספים. מכיוון שהאפליקציה יכולה לייצר מספר אינסופי כמעט של כתובות, היא עשויה להקדיש שנים לקביעת היתרה. כדי להגביל חיפוש זה הוא מפסיק לאחר שהוא רואה 20 כתובות שמעולם לא קיבלו כספים. זהו "גבול הפער" ו- 20 הוא תקן דה-פקטו אם כי המספר הוא שרירותי. אלה 20 הכתובות בהן תוכלו לבחור Seed -במהלך האיתול, היישום מייצר כתובות הנגזרות מה',
      title: "?מדוע רק 20 כתובות"
    },
    whyMany: {
      text: ".הגיבוי היחיד שלך Seed -כדי לשמור על פרטיות וביטחון, לעולם אל תמסור את אותה כתובת פעמיים. אם השתמשת בכתובת, לחץ על החץ ימינה לקבלת כתובת חדשה. אתה יכול ליצור עד 20 כתובות בכל פעם. חשוב על כתובות כמו מספרי חשבוניות. כל הכתובות נגזרות מ",
      title: "?מדוע מספר רב כל-כך של כתובות"
    },
    whyVerify: {
      text: "אין לסמוך על המחשב שלך כדי ליצור ולהציג כתובות אותנטיות. מחשב המחובר לרשת הופך אותו לפגיע באופן משמעותי יותר מארנק חומרה. עבור ביטבוקס01, הכפתור לאימות הכתובת שולח את הכתובת בצורה בטוחה לטלפון הנייד המוצמד, ממנו תוכלו לסרוק ולאמת את צופן ה״קיו-אר״. לגבי ביטבוקס02, ניתן לאמת את הכתובת ישירות על גבי מסך הביטבוקס02",
      title: "מדוע עליי לאמת את הכתובת בצורה מאובטחת?"
    }
  },
  send: {
    fee: {
      text: ".העמלה מבוססת על גודל נתוני העסקה ולא על גובהם. יעדי העמלות מחושבים על ידי אלגוריתם הערכת העמלות של ליבת הביטקוין לכל עדיפות ברשת שבחרת. הם מוצגים אם יש להם ערך שונה מהיעד למטה\n(חסכוני: 24 בלוקים (בערך 4 שעות לביטקוין, שעה עבור לייטקויין\n(נמוך: 12 בלוקים (בערך שעתיים לביטקוין, 30 דקות עבור לייטקויין\n(רגיל: 6 בלוקים (כשעה לביטקוין, 15 דקות עבור לייטקויין\n(גבוה: 2 חסימות (בערך 20 דקות לביטקוין, 5 דקות עבור לייטקויין\nלבלוק לוקח עשר דקות בממוצע לביטקוין (2.5 דקות בלייטקויין) ועומס הרשת עשוי להשתנות במידה ניכרת בתקופות שלעיל",
      title: "?כיצד העמלה נקבעת"
    },
    priority: {
      text: ".ככל שהעמלה אותה תהיה מוכן לשלם תהיה גבוהה יותר, כך העסקה תאושר מהר יותר ברשת",
      title: "?מה היא עדיפות הרשת"
    },
    revert: {
      text: "!מרגע שעסקה נחתמה ונשלחה לרשת, אין אפשרות לבטלה. אשר את העסקאות (כולל עמלה) היטב לפני החתימה\n.אם אתה מכיר את המען והוא או היא מעוניים להשיב את הסכום (פחות עמלה העסקה) בחזרה אלייך, תוכל לשלוח להם כתובת חדשה לקבלה",
      title: "?האם אוכל לבטל עסקה"
    },
    whyFee: {
      text: ".עסקאות מתמודדות עם אישור הכורה. כורים בוחרים בעסקאות שייכללו בבלוקצ׳יין בהתבסס על עמלתם\nכורים מצביעים על היסטוריית העסקאות. מכיוון שאין גורם שלישי מהימן אשר יאכוף קול אחד לאדם (וזה כל העניין של מחסומי חסימות), כורים מצביעים על עסקאות בכך שהם מקריבים משאב יקר כמו כוח מחשוב. כפרס על עבודתם, הם יכולים לתבוע מטבעות חדשים שנוצרו ואת שכר הטרחה של כל העסקאות שהם כללו",
      title: "?מדוע יש עמלת רשת"
    }
  },
  "settings-electrum": {
    connection: {
      text: "אם ברצונך להתחבר לצומת רק כאשר אתה על אותה רשת (לדוגמה, רשת הוויפי הביתית), שימוש בתקשורת רגילה מספיק\nבמקרה שכזה, מומלץ ששרת האלקום יספק אישור טי.אל.אס להצפנת התקשורת\nאם ברצונך להתחבר לצומת שלך מכל מקום, שימוש בתור מומלץ יותר. אין צורך באישור טי.אל.אס במקרה זה",
      title: "?האם עלי להשתמש בתור, טי.אל.אס או טי.סי.פי"
    },
    instructions: {
      link: {
        text: "מדריך לחיבור לצומת שלך"
      },
      text: ":למדריך המלא, בקר בעמוד ההדרכה",
      title: "?כיצד אני מחבר את תכנת הארנק לצומת המלא שלי"
    },
    options: {
      text: "קיימות מספר דרכים להריץ צומת מלא. ניתן לקנות מוצר מוגמר, לבנות אחד לבד או להריץ ליבת ביטקוין\nאם ברצונך לחבר את תכנת הארנק לצומת שלך, וודא כי הוא מריץ שרת אלקטרום. זו תכנה ייעודית המאפשרת לארנק תקשורת לצומת המלא שלך\nתכנות אפשריות הינן אלקטרס, שרת אלקטרום פרטי או טראקר",
      title: "?אילו אופציות קיימות להרצת צומת"
    },
    tor: {
      text: "תור הינה תכנית קוד פתוח חינמית המאפשרת המון יתרונות פרטיות, במיוחד שימושי בשימוש בביטקוין. אם בכוונתך להתחבר לצומת שלך באמצעות תור, וודא שתור מותקן על המחשב ואפשר את תור פרוקסי בהגדרות התכנה. ברב מערכות ההפעלה קיימות שתי אפשריות להרצת תומר:\nהראשונה - להוריד דפדפן תור ולהתחבר לרשת באמצעות פורט 9150\nהשניה - הרצת שירותי תור ברקע\nתכנת הארנק תוכל כך להתחבר באמצעות פורט 9050 בהגדרות התכנה",
      title: "?מה זה תור, פרוקסי תור ובאיזה פורט עלי להשתמש"
    },
    what: {
      text: "קיימת אפשרות להפעיל את הארנק שלך בעזרת צומת במקום להשתמש בשרתי החברה",
      title: "?מה זה"
    },
    why: {
      text: "הרצת צומת משלך אינה הכרחית אך משפרת את הפרטיות ומורידה את הצורך בלסמוך על אחרים. ראשית, זה אומר שתשתמש בביטקוין בצורה פרטית יותר, שכן התכנה לא תתחבר לשרתים שלנו - ההיסטוריה תלקח מהצומת שלך. שנית, הרצת צומת משמעותה וידוא כל הטרנזקציות בעצמך.",
      title: "?מדוע שאריץ צומת מלא משלי"
    }
  },
  settings: {
    servers: {
      text: "כדי לבדוק עדכונים, לטעון עסקאות ולשלוח מידע לאפליקציות סלולריות מותאמות Shift Crypto -יישום זה מתקשר עם שרתי\n האפליקציה מאחזרת גם את שערי החליפין האחרונים מהפלטפורמה של קריפטו-קומפר\n,כל ההמרות מחושבות באופן מקומי, כלומר לא מועברים אי פעם נתונים על סכום העסקה שלך\n.Etherscan.io APIs -אנחנו משתמשים ב ERC20 -בשביל מטבעות אית׳ריום ו",
      title: "?עם אילו שרתים התכנה מתקשרת"
    }
  },
  title: "מדריך",
  toggle: {
    close: "סגור מדריך",
    open: "מדריך"
  },
  unlock: {
    forgotDevicePassword: {
      text: ".עלייך לאתחל מחדש את ההתקן ולשחזר את הארנק מגיבוי, באמצעות סיסמת השיחזור",
      title: "?מה לעשות אם שכחתי את סיסמת ההתקן"
    },
    reset: {
      text: ".הזן סיסמה שגויה 15 פעמים. הנסיונות האחרונים דורשים מגע ארוך יותר על ההתקן",
      title: "?כיצד אני מאתחל את ההתקן"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "ההתקן אמור להבהב פעם אחת כשמוכנס. וודא כי הכנסת בצד הנכון. אם קיימת בעיה, אנא צור קשר באמצעות הקישור למטה",
      title: "התקן הביטבוקס01 שלי לא מזוהה"
    },
    getDevice: {
      link: {
        text: "הזמן התקן ביטבוקס"
      },
      text: ":באפשרותך לרכוש התקן ביטבוקס בחנות המקוונת",
      title: "?כיצד אני יכול להשיג התקן"
    },
    internet: {
      text: "כן, חיבור לאינטרנט נדרש כדי לסנכרן את הארנק, להוציא עסקאות ולחזר שערי חליפין עדכניים",
      title: "האם התכנה דורשת חיבור לאינטרנט?"
    },
    lostDevice: {
      link: {
        text: "מרכז הגיבויים"
      },
      text: "באפשרותך לשחזר את חשבונותך באמצעות התקן ביטבוקס חדש או במרכז הגיבויים",
      title: "?איבדתי את ההתקן. מה עכשיו"
    },
    useWithoutDevice: {
      text: ".לצערנו, זה לא אפשרי כרגע",
      title: "?האם ניתן להשתמש בתכנה ללא התקן"
    },
    welcome: {
      text: "תודה על השימוש בתכנה שנבנתה ע״י שיפט קריפטו בשוויץ\nאנחנו מעריכים כל משוב, ניתן לרשום לנו בקישור למטה",
      title: "!ברוך הבא לתכנת הביטבוקס"
    }
  }
};
const headerssync$1 = {
  blocksSynced: "{{blocks}} בלוקים הסתנכרנו"
};
const hiddenWallet$1 = {
  info1HTML: ".<strong>שונות</strong>למטרות חשאיות ופרטיות, ארנק פרטי יווצר על בסיס שילוב סיסמת התקן + סיסמת שיחזור",
  info2HTML: ".הגדר את סיסמת ההתקן וסיסמת השיחזור שברצונך לשייך לארנק הסודי שמתחת. סיסמת ההתקן והשיחזור חייבות להיות <strong>שונות</strong> מאלו שהגדרת לארנק הראשי שלך",
  passwordLabel: "סיסמת שחזור מוסתרת",
  passwordPlaceholder: "נא אשר את סיסמת השחזור המוסתרת",
  pinLabel: "סיסמת התקן מוסתרת",
  pinRepeatLabel: "חזור על סיסמת ההתקן המוסתרת",
  pinRepeatPlaceholder: "נא אשר את סיסמת ההתקן המוסתרת",
  success: ".ארנק מוסתר נוצר בהצלחה. חבר מחדש את התקן הביטבוקס כדי לבטל את נעילתו"
};
const initialize$1 = {
  create: "קבע סיסמת התקן",
  creating: "...קובע סיסמת התקן",
  error: {
    e102: ".סיסמת ההתקן חייבת להכיל לפחות 4 תווים"
  },
  info: {
    description1: ".בחר את סיסמת ההתקן. סיסמה זו תשמש אותך בביטול נעילת הביטבוקס",
    description2: ".באפשרותך להשתמש במספרים, תווים וסימנים. סיסמאות ארוכות הינן בטוחות יותר",
    description3: ".אם סיסמת ההתקן תאבד, עלייך לבצע איתחול ושיחזור של גיבוי הארנק",
    subtitle: "כעת תגדיר את סיסמת ההתקן שלך",
    title: "מאתחל את ההתקן"
  },
  input: {
    label: "סיסמת התקן",
    labelRepeat: "חזור על סיסמת ההתקן",
    placeholderRepeat: "נא אשר את סיסמת ההתקן"
  }
};
const invalidFormat$1 = "תצורה שגויה";
const language$2 = {
  title: "בחר שפה"
};
const legacyhiddenwallet$1 = {
  disable: "השבת כתובת קדומה של ארנק מוסתר",
  enable: "הפעל כתובת קדומה של ארנק מוסתר",
  successDisable: "השבתת כתובת קדומה של ארנק מוסתר הצליחה",
  successEnable: "הפעלת כתובת קדומה של ארנק מוסתר הצליחה. חבר מחדש את הביטבוקס והזן את סיסמת ההתקן המוסתר בכדי לגשת לכתובת הארנק המוסתר הקדומה"
};
const loading$1 = "...טוען";
const mobile$1 = {
  usingMobileDataWarning: ".כדי להימנע משימוש בנתונים ניידים WiFi-שימוש בנתונים ניידים: יישום זה עשוי להוריד עד כמה מאות מגה-בייט של נתוני כותרות מהבלוקצ׳יין לאחר ביטול נעילת חשבון. אנא התחבר ל\n.לאחר הביטול, הודעה זו לא תוצג שוב"
};
const note$2 = {
  input: {
    description: "אופציונאלי",
    placeholder: "...הוסף הערה"
  },
  title: "הערה"
};
const notification$1 = {
  newTxs_one: "{{count}} עסקה חדשה ב: {{accountName}}",
  newTxs_other: "{{count}} עסקה חדשה ב: {{accountName}}"
};
const pairing$1 = {
  aborted: {
    text: ".הצימוד בוטל על-ידי יישום הנייד",
    title: "בוטל"
  },
  button: "הצמד ליישום הנייד",
  confirm: ".אתה בטוח שברצונך לצמד את הביטבוקס שלך? שים לב כי לאחר מכן, הנייד יידרש כדי לבצע עסקאות",
  connectOnly: {
    button: "חבר יישום נייד",
    title: "'סרוק באמצעות היישום הנייד שלנו, על-ידי בחירה בתפריט ב'חבר תכנה חדשה"
  },
  error: {
    text: ".משהו השתבש. התחל מחדש",
    title: "שגיאה"
  },
  pullFailed: {
    text: ".משיכת הודעה מהנייד שלך נכשלה דרך שרת הממסרים. שרת הממסר עשוי להיות במצב לא מקוון, אנא צור קשר עם התמיכה",
    title: "משיכה נכשלה"
  },
  reconnectOnly: {
    button: "חבר מחדש את יישום הנייד"
  },
  scanningFailed: {
    text: ".הנייד לא הצליח לסרוק את ההודעה בהצלחה. נסה שוב",
    title: "סריקה נכשלה"
  },
  start: {
    hideAppQRCode: "QR הסתר צופן",
    revealAppQRCode: "QR הצג צופן",
    step1: ".לחנות של אפל או גל גוגל, תלוי במכשיר הפלאפון שלך QR אם אין ברשותך את היישום הנייד, תוכל לסרוק צופן",
    step2: "Digital BitBox 2FA -סרוק באמצעות היישום הנייד, הניתן למציאה בחנות היישומים של אפל או אנדרואיד תחת השם"
  },
  started: {
    text: "כעת, עקוב אחר ההוראות ביישום הנייד",
    title: "נהדר"
  },
  success: {
    text: "!מזל טוב, הצמדת בהצלחה את התקן הביטבוקס שברשותך עם היישום הנייד",
    title: "הצלחה"
  },
  timeout: {
    text: "זמן הצימוד נגמר לאחר שתי דקות. התחל שוב אם ברצונך לצמד עם היישום הנייד",
    title: "הזמן תם"
  },
  title: "צימוד לנייד"
};
const password$1 = {
  show: "הצג {{label}}",
  warning: {
    caps: "אזהרה: קאפסלוק (⇪) מופעל",
    paste: "״בכדי להדביק תמליל, אפשר ״הצג {{label}}"
  }
};
const random$2 = {
  button: "צור מספר אקראי",
  description: ":הביטבוקס שלך יצר מספר של {{bits}}-ביטים אקראי"
};
const receive$3 = {
  label: "כתובתך",
  onlyThisCoin: {
    description: ".בכדי לקבל אסימונים אחרים, אפשר אותם בהגדרות. אם תפקיד אסימונים שונים, ייתכן שהם לא יהיו נגישים",
    warning: ".וודא כי אתה מקבל {{coinName}} בלבד בכתובת זו"
  },
  showFull: "הראה ואמת כתובת מלאה בהתקן",
  title: "קבל {{accountName}}",
  verify: "וודא כתובת בצורה מאובטחת",
  verifyBitBox01: "וודא כתובת ביישום הנייד",
  verifyBitBox02: "וודא כתובת בביטבוקס02",
  verifyInstruction: ".אנא וודא אם הכתובת הבאה תואמת את הכתובת המוצגת על גבי ההתקן שלך",
  warning: {
    secureOutput: ".אנא צמד את הביטבוקס שלך עם היישום הנייד בכדי לאבטח וידוא הכתובת. השתמש ב'נהל התקנים' בתפריט הצד"
  }
};
const reset$1 = {
  description: "!כל המידע שבהתקן יימחק, זה כולל את המפתח הפרטי שלך",
  notReset: ".התקן לא אופס",
  title: "שיחזור הגדרות יצרן",
  understand: "יש ברשותי גיבוי וסיסמת שיחזור",
  understandBB02: "יש ברשותי גיבוי תקין"
};
const securityInformation$1 = {
  create: {
    description1: ".אנו ממליצים שתגדיר את המכשיר סביבה בטוחה, כלומר הרחק מאנשים אחרים שעלולים לראות את הסיסמה שתבחר",
    description2: ".תתבקש ליצור שתי סיסמאות",
    description3: ".הראשונה הינה <strong>סיסמת ההתקן</strong> שתבטל את נעילת התקן הביטבוקס שלך וניתנת לשינוי מאוחר יותר",
    description4: ".השנייה הינה <strong>סיסמת השיחזור</strong>שמבטלת את נעילת הארנק שלך. סיסמה זו לא יכולה להשתנות מאוחר יותר",
    description5: "הארנק ייצור קובץ גיבוי על גבי כרטיס הזיכרון שסופק. ניתן להשתמש בו במקרה חירום בכדי לשחזר את הנכסים באמצעות <strong>סיסמת השיחזור</strong>",
    title: "מידע אודות אבטחה"
  },
  restore: {
    description1: ".תתבקש להכניס את כרטיס הזיכרון שעליו מאוחסן הגיבוי",
    description2: "בכדי לשחזר את ההתקן, תצטרך את סיסמת השיחזור",
    description3: ".אנא שים לב כאשר אתה מזין את סיסמת השיחזור. כל סיסמה שתזין תיצור ארנק תקין. אם תזין סיסמה שגויה יוצג בפנייך ארנק עם יתרה שלא ציפית לה",
    title: "מידע אודות אבטחה"
  }
};
const seed$1 = {
  agreements: {
    "funds-access": "אני לא אוכל לגשת לנכסים שלי אם אשכח את סיסמת השיחזור",
    "password-change": "אני לא יכול לשנות את סיסמת השחזור מאוחר יותר",
    "password-required": "סיסמת השיחזור נחוצה לכדי לשחזר ארנק מהגיבוי"
  },
  create: "צור ארנק",
  creating: "יוצר ארנק",
  description: ":אני מבין ש",
  error: {
    e102: ".הסיסמה חייבת להכין לפחות 4 תווים",
    e200: ".עלייך להכניס כרטיס זיכרון להתקן הביטבוקס, על-מנת ליצור ארנק, כדי שגיבוי יווצר אוטומטי"
  },
  info: {
    button: "קבע סיסמת שיחזור כעת",
    description1: "הכנס כרטיס זיכרון להתקן הביטבוקס",
    description2: "״בחר סיסמת שיחזור לארנק וסמן ״הגדר סיסמת שיחזור כעת",
    description3: ".הגיבוי באמצעות כרטיס הזיכרון וסיסמת השיחזור הן הדרכים היחידות לשחזר את הנכסים, במקרה של אובדן או גניבת התקן ביטבוקס",
    description4: ".אין באפשרותך לשנות את סיסמת השיחזור בהמשך, מבלי לשנע את נכסייך",
    title: "צור ארנק חדש"
  },
  password: {
    label: "סיסמת שיחזור",
    repeatPlaceholder: "חזור על סיסמת השיחזור"
  },
  walletName: {
    label: "שם ארנק"
  }
};
const seedRestore$1 = {
  error: {
    e200: ".בשיחזור ארנק מגיבוי נדרש כרטיס הזיכרון"
  },
  info: {
    description1: "״הכנס את כרטיס הזיכרון להתקן הביטבוקס ולחץ ״המשך",
    description2: "״בחר גיבוי ולחץ ״שחזר",
    description3: "הקש את סיסמת השיחזור",
    description4: ".עליך לאשר כדי הבנת שסיסמה שגויה תיצור ארנק שונה",
    title: "כיצד לשחזר ארנק מגיבוי"
  }
};
const send$3 = {
  abort: "העסקה בוטלה",
  address: {
    label: "כתובת מען",
    placeholder: "הכנס כתובת"
  },
  amount: {
    label: "סכום",
    placeholder: "הכנס סכום"
  },
  availableBalance: "יתרה זמינה",
  button: "סקירה",
  coincontrol: {
    address: "כתובת",
    outpoint: "נקודת יציאה",
    title: "שלח מהפלט"
  },
  confirm: {
    "selected-coins": "מטבעות נבחרים",
    title: "אשר ובצע עסקה",
    total: "סכום סופי"
  },
  error: {
    feeTooLow: "עמלה נמוכה מדי",
    insufficientFunds: "אין די כספים",
    invalidAddress: "כתובת שגויה",
    invalidAmount: "סכום שגוי",
    invalidData: "מידע שגוי"
  },
  fee: {
    customPlaceholder: "הכנס סכום",
    label: "עמלת רשת",
    placeholder: "לא זמין"
  },
  feeTarget: {
    description: {
      economy: "(בלוקים: 24 (סביב ה4 שעות לביטקויין, שעה ללייטקויין",
      economy_ltc: "(שעה (24 בלוקים",
      high: "(בלוקים: 2 (סביב ה20 דקות לביטקויין, 5 דקות ללייטקויין",
      high_ltc: "(חמש דקות (2 בלוקים",
      low: "(בלוקים: 12 (סביב השעתיים לביטקויין, 30 דקות ללייטקויין",
      low_ltc: "(חצי שעה (12 בלוקים",
      normal: "(בלוקים: 6 (סביב השעה לביטקויין, רבע שעה ללייטקויין",
      normal_ltc: "(רבע שעה (6 בלוקים"
    },
    estimate: ":זמן המתנה משוער",
    label: {
      custom: "מותאם",
      economy: "חסכוני",
      high: "גבוה",
      low: "נמוך",
      normal: "רגיל"
    },
    placeholder: "...מחשב הערכת עמלה"
  },
  maximum: "שלח הכל",
  priority: "עדיפות",
  scanQR: "QR סרוק צופן",
  signprogress: {
    description: ".עסקה זו כוללת המון מידע. כדי לחתום על עסקה זו לחלוטין, תתבקש לאשר {{steps}} פעמים",
    label: "התקדמות"
  },
  success: "העסקה נחתמה ונשלחה",
  title: "שלח {{accountName}}",
  toggleCoinControl: "הפעל שליטת מטבע",
  transactionDetails: "פרטי עסקה"
};
const settings$2 = {
  electrum: {
    add: "הוסף שרת",
    "add-server": "הוסף",
    check: "בדוק",
    checkFailed: "נכשל",
    checkSuccess: "חיבור נוצר בהצלחה ל{{host}}",
    checking: "בודק",
    "download-cert": "הורד אישור מרחוק",
    "remove-server": "הסר",
    removeConfirm: "?הסר {{server}}",
    reset: "אתחל לברירת מחדל",
    resetConfirm: "?האם ברצונך למחוק את כל השרתים ולהתקין את שרתי ברירת המחדל",
    servers: "שרתים",
    step1: "1",
    "step1-text": "הכנס נקודת קצה",
    step2: "2",
    "step2-text": "הזן אישור של שרשרת האישורים של השרת. לחלופין, הורד את האישור המרוחק והשווה אותו חזותית",
    "step2-text-tcp": "TLS -שלב זה ניתן למעבר אם אינך מעוניין להשתמש בפרוטוקול",
    step3: "3",
    "step3-text": "בדוק את החיבור והוסף את השרת",
    step4: "4",
    "step4-text": "אתחל מחדש את הארנק. אם לא תסיר את שרתי ברירת המחדל, הצומת שלך יתווסף כיתירות",
    "title-btc": "שרתי ביטקוין אלקטרום",
    "title-ltc": "שרתי לייטקויין אלקטרום",
    "title-tbtc": "Bitcoin Testnet Electrum שרתי",
    "title-tltc": "Litecoin Testnet Electrum שרתי"
  },
  expert: {
    coinControl: "אפשר ניהול מטבע",
    electrum: {
      title: "חבר את הצומת המלא שלך"
    },
    fee: "אפשר ניהול עמלות",
    setProxyAddress: "קבע כתובת פרוקסי",
    title: "הגדרות מתקדמות",
    useProxy: "הפעל פרוקסי תור"
  },
  header: {
    home: "בית"
  },
  restart: ".אתחל מחדש את התכנה בכדי שהשינויים יתממשו",
  services: {
    title: "שירותים"
  },
  success: ".נתק וחבר מחדש את ההתקן בכדי שהשינויים יתממשו",
  title: "הגדרות"
};
const setup$1 = "הגדר התקן";
const sidebar$2 = {
  device: "נהל התקן",
  leave: "עזוב",
  settings: "הגדרות"
};
const success$8 = {
  create: {
    info1: "הארנק שלך גובה באופן מאובטח לכרטיס הזיכרון. הסר ושמור אותו בבטחה.",
    info2: "יצרת סיסמת מאובטחת להתקן אשר מבטלת את נעילתו.",
    info3: ".יצרת סיסמת שיחזור מאובטחת לארנק שלך, כזו המאפשרת פתיחה ושיחזור כל הנכסים מהגיבוי",
    summary: "הנה סיכום של מה שעשית",
    title: "הצלחה"
  },
  getstarted: "התחל",
  restore: {
    summary: ".שיחזרת בהצלחה ארנק מתוך הגיבוי",
    title: "הצלחה"
  }
};
const transaction$2 = {
  confirmation: "אישורים",
  details: {
    activity: "פעילות",
    address: "כתובת",
    amount: "כמות",
    date: "תאריך",
    fiat: "פיאט",
    fiatAmount: "כמות פיאט",
    status: "מצב",
    type: "סוג"
  },
  explorer: "מזהה עסקה",
  explorerTitle: "פתח בחוקר בלוקים חיצוני",
  fee: "עמלה",
  fiatHistorical: "היסטורי",
  gas: "גז",
  note: {
    edit: "ערוך הערה",
    save: "שמור הערה"
  },
  pending: "עסקה ממתינה",
  size: "גודל",
  status: {
    complete: "הושלם",
    failed: "נכשל",
    pending: "ממתין"
  },
  tx: {
    received: "קבל אל",
    sent: "שלח ל"
  },
  vsize: "גודל וירטואלי",
  weight: "משקל"
};
const transactions$1 = {
  placeholder: ".אין עסקאות עדיין"
};
const unknownError$1 = "שגיאה לא ידועה התרחשה: {{errorMessage}}";
const unlock$1 = {
  description: ".הזן את סיסמת ההתקן בכדי לבטל את נעילתו",
  error: {
    e109_normal: ".סיסמת התקן שגויה. {{remainingAttempts}} נסיונות נותרו לפני מחיקת ההתקן",
    e109_touch: ".$t(unlock.error.e109_normal) ההתחברות הבאה תדרוש החזקה של מקש המגע",
    e113: ".עקב נסיונות רבים, ההתחברות הבאה דורשת החזקה של מקש המגע למשך 4 שניות"
  },
  input: {
    label: "סיסמת ההתקן",
    placeholder: "הזן את סיסמת ההתקן כדי לבטל את נעילתו"
  },
  unlocking: "...מבטל נעילה"
};
const upgradeFirmware$2 = {
  button: "עדכון קושחה",
  description: "?אתה מעוניין לשדרג את הקושחה מ{{currentVersion}} ל{{newVersion}}",
  label: "ההתקן שלך דורש עדכון קושחה",
  locked: "כדי לשדרג מ{{currentVersion}} ל{{newVersion}}}, גע לחיצה ארוכה",
  title: "עדכן קושחה",
  unlocked: ":האיתחול נעול. כדי להמשיך",
  unlocked1: "נתק וחבר מחדש את ההתקן",
  unlocked2: "נורית הלד תדלק בביטבוקס שלך כשהוא יחובר בחזרה",
  unlocked3: "גע במקש המגע כשמנורת הלד נדלקת"
};
const warning$7 = {
  receivePairing: ".הצמד את הביטבוקס שלך על-מנת לאפשר ווידוא עסקאות באופן בטוח. בחר ב'נהל התקן' בתפריט הצד",
  sdcard: "שמור על כרטיס הזיכרון הרחק מההתקן, אלמלא אתה מעוניין לנהל את הגיבויים",
  sendPairing: ".הצמד את הביטבוקס שלך על-מנת לאמת פרטי עסקאות. בחר ב'נהל התקן' בתפריט הצד"
};
const welcome$1 = {
  insertBitBox02: "גע בהתקן כדי להמשיך",
  insertDevice: "חבר את ההתקן בכדי להתחיל",
  title: "ברוך הבא"
};
const appTranslationsHE = {
  account: account$1,
  accountInfo: accountInfo$1,
  accountSummary: accountSummary$1,
  addAccount: addAccount$2,
  app: app$1,
  backup: backup$1,
  bb02Bootloader: bb02Bootloader$1,
  bitbox: bitbox$1,
  bitbox02Interact: bitbox02Interact$1,
  bitbox02Settings: bitbox02Settings$1,
  bitbox02Wizard: bitbox02Wizard$1,
  blink: blink$1,
  bootloader: bootloader$1,
  button: button$6,
  buy: buy$2,
  changePin: changePin$1,
  chart: chart$2,
  checkSDcard: checkSDcard$1,
  clickHere: clickHere$1,
  confirm: confirm$3,
  confirmOnDevice: confirmOnDevice$1,
  device: device$1,
  deviceLock: deviceLock$1,
  deviceSettings: deviceSettings$1,
  deviceTampered: deviceTampered$1,
  dialog: dialog$2,
  fiat: fiat$3,
  footer: footer$3,
  generic: generic$2,
  genericError: genericError$1,
  goal: goal$1,
  guide: guide$2,
  headerssync: headerssync$1,
  hiddenWallet: hiddenWallet$1,
  initialize: initialize$1,
  invalidFormat: invalidFormat$1,
  language: language$2,
  legacyhiddenwallet: legacyhiddenwallet$1,
  loading: loading$1,
  mobile: mobile$1,
  note: note$2,
  notification: notification$1,
  pairing: pairing$1,
  password: password$1,
  random: random$2,
  receive: receive$3,
  reset: reset$1,
  securityInformation: securityInformation$1,
  seed: seed$1,
  seedRestore: seedRestore$1,
  send: send$3,
  settings: settings$2,
  setup: setup$1,
  sidebar: sidebar$2,
  success: success$8,
  transaction: transaction$2,
  transactions: transactions$1,
  unknownError: unknownError$1,
  unlock: unlock$1,
  upgradeFirmware: upgradeFirmware$2,
  warning: warning$7,
  welcome: welcome$1
};
const account = {
  disconnect: "Connessione interrotta. Riprovo...",
  "export": "Esporta",
  exportTransactions: "Esporta transazioni in formato CSV nella cartella download",
  fatalError: "Si è verificato un errore inatteso",
  incoming: "In entrata",
  initializing: "Raccolgo informazioni dalla blockchain",
  insuranceExpired: "<strong>Account non più assicurato</strong>\n\nIl piano assicurativo per questo conto è stato modificato.\nControlla la pagina dell'assicurazione per i dettagli.",
  insured: "Account assicurato",
  maybeProxyError: "Proxy Tor attivato. Assicurati che il tuo proxy Tor funzioni correttamente, oppure disabilita l'impostazione del proxy.",
  reconnecting: "Connessione persa, provo a riconnettermi...",
  syncedAddressesCount: "{{count}} indirizzi letti",
  uncoveredFunds: "L'account <strong>{{name}}</strong> ha fondi sui seguenti tipi di indirizzi non coperti: {{uncovered}}.\nL'account è assicurato, ma solo i fondi ricevuti tramite indirizzi di tipo <strong>Native Segwit</strong> sono coperti. I fondi ricevuti tramite indirizzi di altro tipo, anche se si trovano sullo stesso account, non sono assicurati.\nSposta tutte i tuoi fondi dagli indirizzi non supportati a indirizzi di tipo <strong>Native Segwit</strong>, così che tutti i fondi di questo account siano coperti dall'assicurazione.",
  uncoveredFundsLink: "Segui questa guida per spostare i tuoi fondi.",
  warning: "Attenzione!"
};
const accountInfo = {
  address: "Indirizzo",
  buyCTA: {
    buy: "Acquista {{unit}}",
    buyCrypto: "Acquista cryptovalute",
    information: {
      looksEmpty: "Sembra che il wallet sia vuoto.",
      start: "Iniziate depositando alcune valute nel wallet o acquistando direttamente nella BitBoxApp."
    }
  },
  extendedPublicKey: "Chiave pubblica estesa",
  label: "Informazioni sull'account",
  scriptType: "Tipo di script",
  title: "Informazioni sull'account",
  verify: "Verifica sul dispositivo",
  xpubTypeChangeBtn: {
    p2pkh: "Visualizza la chiave pubblica estesa di P2PKH",
    p2tr: "Visualizza Taproot",
    p2wpkh: "Visualizza Native Segwit",
    "p2wpkh-p2sh": "Visualizza la chiave pubblica estesa Segwit più vecchia"
  },
  xpubTypeInfo: "Attualmente viene visualizzata la chiave pubblica estesa {{scriptType}} ({{current}} di {{numberOfXPubs}})"
};
const accountSummary = {
  availableBalance: "Saldo disponibile",
  balance: "Saldo",
  exportSummary: "Esporta il riepilogo dell'account in formato CSV nella cartella download",
  fiatBalance: "Saldo fiat",
  name: "Nome account",
  noAccount: "Non ci sono account da mostrare",
  subtotalWithCoinName: "Totale ({{coinName}})",
  title: "Il mio portafoglio",
  total: "Totale",
  transactionHistory: "Storico transazioni"
};
const addAccount$1 = {
  chooseName: {
    nextButton: "Aggiungi account",
    step: "Nome dell'account",
    title: "Assegna un nome all'account"
  },
  selectCoin: {
    nextButton: "Avanti",
    step: "Seleziona valuta",
    title: "Seleziona cryptovaluta"
  },
  success: {
    addAnotherAccount: "Aggiungi un nuovo account",
    message: "<strong>{{accountName}}</strong> è stato aggiunto ai tuoi account.",
    nextButton: "Fatto",
    step: "Finito",
    title: "Account aggiunto"
  },
  title: "Aggiungi account"
};
const aopp = {
  addressRequest: "{{host}} richiede un indirizzo di ricezione.",
  addressRequestWithLogo: "richiede un indirizzo di ricezione\n",
  banner: "Richiesta dell'indirizzo in corso. Connetti il dispositivo per continuare.",
  errorTitle: "Errore durante la richiesta dell'indirizzo",
  labelAddress: "Indirizzo",
  labelMessage: "Messaggio",
  reverifyInfoText: "Verifica indirizzo",
  signing: "Per procedere, firmare il messaggio sul BitBox02\n",
  success: {
    message: "Continua su {{host}}",
    title: "Indirizzo inviato con successo"
  },
  syncing: "Sincronizzazione dell'account, attendere prego.\n",
  title: "Richiesta di indirizzo"
};
const app = {
  upgrade: "E' disponibile una nuova versione di questa app! Aggiorna dalla {{current}} alla {{version}}."
};
const auth$1 = {
  authButton: "Autenticati",
  title: "Autenticati per continuare"
};
const backup = {
  check: {
    checking: "Sto verificando backup...",
    confirmTitle: "Verifica backup",
    notOK: "Il backup NON combacia con il wallet.",
    ok: "Il backup combacia con il wallet.",
    password: {
      label: "Password di recupero",
      placeholder: "Password di recupero",
      showLabel: "password di recupero"
    },
    success: "Back verificato con successo:",
    title: "Verifica backup"
  },
  create: {
    alreadyExists: "Hai già un backup valido. Vuoi ricrearlo?",
    fail: "Creazione backup FALLITA!",
    info: "Inserisci la password di recupero del wallet attuale per la verifica.",
    name: {
      label: "Nome del backup",
      placeholder: "Assegna un nome al backup"
    },
    password: {
      label: "Password di recupero",
      placeholder: "Inserisci la tua password di recupero"
    },
    title: "Crea backup",
    verificationFailed: "La password di recupero NON corrisponde al wallet attuale. Il backup è stato creato. Per favore usa 'Controlla backup' per verificare di nuovo la tua password di recupero."
  },
  description: "Scegli <strong>il file di backup del wallet</strong>",
  insert: "Inserisci la carta microSD per gestire i backup.",
  insertButton: "Ho inserito la carta microSD",
  list: "I tuoi backup sulla carta microSD",
  noBackups: "Non ci sono backup su questa carta microSD",
  restore: {
    confirmTitle: "Ripristina backup",
    error: {
      e200: "Carta microSD non trovata",
      general: "Errore nel ripristino del backup"
    },
    password: {
      label: "Password di recupero o password di recupero nascosta",
      placeholder: "Password di recupero",
      repeatPlaceholder: "Ripeti password di recupero",
      showLabel: "Password di recupero"
    },
    restoring: "Ripristino backup...",
    selectedBackup: "<strong>{{backupName}}</strong> creato in data {{createdDateTime}} verrà ripristinato.",
    title: "Ripristina",
    understand: "Capisco che una password di recupero errata creerà un wallet diverso"
  },
  showMnemonic: {
    description: "Ti verranno mostrate le parole di recupero, che formano un backup del tuo wallet. Scrivile su carta.\n\n<strong>Non custodirle digitalmente e non fotografarle.</strong>\n\n<strong>Non pronunciare le parole ad alta voce.</strong>\n\n<strong>Questo backup non è protetto da password.</strong>\n\nIn seguito ti sarà richiesto di confermare ogni parola.",
    title: "Mostra le parole di recupero",
    warning: "<strong>Non condividere le tue parole di recupero con nessuno.</strong> Le parole di recupero danno pieno accesso al tuo wallet. Se qualcuno ti chiede le tue parole di recupero, vuole truffarti. Non condividerle!"
  },
  title: "Gestisci i backup"
};
const bb02Bootloader = {
  abort: "Non aggiornare - riportami indietro",
  abort_noUpgrade: "Indietro",
  advanced: {
    label: "Impostazioni avanzate",
    toggleShowFirmwareHash: "Mostrami l'hash del firmware ogni volta all'avvio"
  },
  flipscreen: "Capovolgi schermo",
  orientation: "Orientamento del dispositivo sbagliato?",
  success: "Aggiornamento riuscito! Passo successivo in {{rebootSeconds}} secondi...",
  success_install: "Installazione riuscita! Continua tra {{rebootSeconds}} secondi..."
};
const bitbox = {
  error: {
    e10000: "Password errata per questo dispositivo",
    e10001: "Impossibile sostituire la password del dispositivo",
    e102: "La password deve essere di almeno 4 caratteri.",
    e112: "La password nascosta non può essere uguale alla password principale del dispositivo."
  }
};
const bitbox02Interact = {
  confirmDate: "Conferma la data di oggi sul tuo BitBox02",
  confirmDateText: "Questa data sarà usata per creare il tuo backup.",
  confirmName: "Conferma il nome sul BitBox02",
  confirmWords: "Prendi nota delle {{amount}} parole di recupero dal tuo BitBox02",
  confirmWordsText: "In seguito il BitBox02 ti chiederà di confermare ogni parola per verificare la correttezza del tuo backup.",
  followInstructions: "Segui le istruzioni sul tuo BitBox02",
  followInstructionsMnemonic: "Segui le istruzioni sul tuo BitBox02 per ripristinare utilizzando le parole di recupero.",
  followInstructionsMnemonicTitle: "Ripristina da parole di recupero\n"
};
const bitbox02Settings = {
  deviceName: {
    current: "Nome attuale del dispositivo",
    error: "Non è stato possibile configurare il nome del dispositivo",
    error_104: "La conferma del nome del dispositivo è stata abortita sul dispositivo.",
    input: "Nome del BitBox02",
    placeholder: "Nuovo nome del dispositivo",
    title: "Imposta il nome del BitBox02"
  },
  gotoStartupSettings: {
    description: "Questo riavvia il BitBox02 e inizializza le impostazioni di avvio.",
    title: "Vai alle impostazioni di avvio\n"
  }
};
const bitbox02Wizard = {
  advanced: {
    button: "Opzioni avanzate",
    outOfDate: "Firmware non aggiornato per questa funzionalità",
    seed12WordInfo: "Attenzione, il numero di parole non potrà essere modificato dopo la creazione del wallet.",
    seed12WordLabel: "Crea un seed da 12 parole invece di 24",
    seed12WordText: "Il BitBox02 di default usa un seed da 24 parole. All'atto pratico, entrambe le lunghezze del seed sono sicure contro attacchi di tipo brute force. Alcuni utenti potrebbero preferire la comodità di un seed da 12 parole.",
    skipSDCardLabel: "Salta il backup su microSD e sostituiscilo annotando le parole di recupero",
    skipSDCardText: "Hai sempre l'opzione di creare un backup su microSD o annotare le parole di recupero dopo il setup. Puoi farlo dalle impostazioni.",
    title: "Opzioni di backup avanzate"
  },
  attestationFailed: "L'attestazione del dispositivo non è riuscita. Ciò potrebbe essere dovuto al riavvio dell'app mentre il dispositivo stava aspettando l'input dell'utente. Si prega di ricollegarsi e riprovare. Contattare support@bitbox.swiss se l'errore persiste.",
  backup: {
    point1: "Scegli un backup sulla carta microSD",
    point2: "Imposta una password per il tuo dispositivo",
    restoreText: "Ok, ripristiniamo un backup!",
    text1: "Bene, la tua password di BitBox02 è ora impostata e il wallet creato. Ora è il momento di creare il tuo primo backup. Assicurati che la tua scheda microSD sia inserita nel tuo BitBox02 e continua.",
    text2: "Segui le istruzioni sullo schermo del tuo dispositivo per creare un backup.",
    text3: "Dopo che il backup è stato creato, rimuovi la scheda microSD e conservala in un luogo <strong>sicuro</strong>. Il contenuto della scheda microSD non è protetto da password. Non inserirla mai in nessun altro dispositivo che non sia il tuo BitBox02.",
    userConfirmation1: "Devo conservare il backup in un luogo sicuro.",
    userConfirmation2: "Il backup non è protetto da una password. Chiunque abbia accesso ad esso può accedere anche al mio wallet.",
    userConfirmation3: "Se perdo o danneggio il mio BitBox02, l'unico modo per recuperare i miei fondi è ripristinare il backup.",
    userConfirmation4: "Se perdo o danneggio sia il backup che il dispositivo BitBox02, i miei fondi andranno persi.",
    userConfirmation5: "Non devo inserire il mio backup su scheda microSD in un computer, telefono, stampante o qualsiasi altro dispositivo che non sia un BitBox02.",
    userConfirmation5mnemonic: "Non devo inserire le mie parole di recupero in un computer, telefono, stampante o altro dispositivo diverso da BitBox02."
  },
  create: {
    button: "Assegnare un nome al dispositivo e continuare",
    info: "Ecco i passaggi necessari per configurare il tuo BitBox: ",
    inputTitle: "Nome del wallet",
    point1: "Dai un nome al tuo dispositivo",
    point2: "Imposta una password per il tuo dispositivo",
    point3: "Crea un backup",
    text: "Bene, ora creiamo un nuovo wallet!"
  },
  createBackupAborted: "Creazione del backup interrotta.",
  createBackupFailed: "Creazione del backup fallita. Riprovare.",
  initialize: {
    passwordText: "Ora impostiamo la password del dispositivo. Usa i controlli sul tuo BitBox per scegliere i caratteri della password.",
    passwordTitle: "Imposta la password per il tuo BitBox",
    text: "BitBox02 abbinato con successo! Ora inizializziamo il tuo dispositivo. Inizia scegliendo se creare un nuovo wallet o ripristinare un wallet da un backup esistente. <strong>Assicurati di avere una scheda microSD inserita nel tuo BitBox02</strong>",
    tip: "Ti consigliamo di procedere in un luogo sicuro.",
    title: "Inizializza il tuo BitBox"
  },
  insertSDCard: "<strong>Assicurati di aver inserito la scheda microSD nel tuo BitBox02.</strong>",
  noPasswordMatch: "Le password non corrispondono. Riprovare.",
  pairing: {
    failed: "Abbinamento non confermato. Ricollega il tuo BitBox02.",
    paired: "Hai confermato il seguente codice sul tuo dispositivo. Puoi continuare.",
    title: "Verifica il codice di abbinamento",
    unpaired: "È stato rilevato un nuovo BitBox02. Si prega di verificare che il seguente codice corrisponda a quello mostrato sul tuo dispositivo. Se il codice corrisponde, tocca sotto il segno di spunta sul tuo BitBox02 e poi clicca sul pulsante qui sotto per continuare."
  },
  restoreFromMnemonic: {
    e104: "Il ripristino tramite parole di recupero è stato cancellato.",
    failed: "Ripristino con parole di recupero non riuscito. Riprovare."
  },
  stepBackup: {
    beforeProceed: "Prima di procedere, leggi queste importanti considerazioni sulla sicurezza:",
    createBackup: "Ora si procede a creare un backup sulla scheda microSD.",
    createBackupMnemonic: "Scrivi le parole di recupero."
  },
  stepBackupSuccess: {
    fundsSafe: "Per tenere i tuoi fondi al sicuro, ricordati quanto segue:",
    title: "Backup ripristinato!"
  },
  stepConnected: {
    unlock: "Inserisci la password del BitBox02 per sbloccare."
  },
  stepCreate: {
    description: "Questo nome viene utilizzato come nome del dispositivo e per il backup.",
    nameLabel: "Nome del BitBox02",
    namePlaceholder: "Il mio BitBox02",
    title: "Scegli il nome del BitBox02",
    toastMicroSD: "Inserisci nel tuo BitBox02 la scheda microSD che sarà utilizzata per salvare un backup del tuo wallet."
  },
  stepCreateSuccess: {
    removeMicroSD: "Rimuovere la scheda microSD dal BitBox02 e conservarla in un luogo sicuro.",
    storeMnemonic: "Custodisci le tue parole di recupero in un posto sicuro",
    success: "Il backup è stato creato con successo."
  },
  stepInsertSD: {
    insertSDCard: "Inserisci la scheda microSD nel BitBox02 per continuare.",
    insertSDcardTitle: "Inserire la scheda microSD"
  },
  stepPassword: {
    e104: "L'impostazione della password è stata cancellata.",
    title: "Impostare la password del BitBox02",
    useControls: "Usa i controlli sul tuo BitBox02 per impostare la password."
  },
  stepUninitialized: {
    create: "Vorrei configurare un nuovo BitBox02.",
    restore: "Vorrei ripristinare il mio wallet da un backup.",
    restoreMicroSD: "Ripristina dalla scheda microSD",
    restoreMnemonic: "Ripristina utilizzando le parole di recupero",
    title: "Configurare il BitBox02"
  },
  success: {
    text: "Urrà! Il tuo BitBox02 è ora pronto all'uso. \n\nPer ulteriori informazioni su come utilizzare la BitBoxApp, si prega di utilizzare la guida in-app cliccando sul punto di domanda in alto a destra.",
    title: "Pronti a partire!"
  }
};
const bitsurance = {
  dashboard: {
    active: "Polizza d'assicurazione attiva",
    button: "Assicura un nuovo account",
    canceled: "Cancellata",
    coverage: "Copertura massima",
    inactive: "Inattiva",
    processing: "In elaborazione",
    refused: "Rifiutata",
    supportLink: "Gestisci contratto",
    title: "Account assicurati",
    waitpayment: "In attesa di pagamento"
  },
  detect: {
    button: "Verifica copertura assicurativa",
    insured: "Account assicurati:",
    notInsured: "Nessuna assicurazione rilevata. Se sei sicuro che uno degli account sia assicurato, verifica di aver inserito il wallet corretto.",
    text: "Se hai già assicurato i tuoi fondi con Bitsurance, la BitBoxApp può rilevare automaticamente la tua copertura assicurativa.",
    title: "Sei già assicurato?"
  },
  insure: {
    button: "Verifica disponibilità e prezzi",
    faq: "Leggi di più sulle FAQ di Bitsurance",
    listItem1: "Furto",
    listItem2: "Estorsione (ad esempio, $5 wrench attack)",
    listItem3: "Distruzione dovuta a incendi, acqua o calamità naturali",
    month: "mese",
    text: "Assicura il tuo BitBox02 e fino a 100.000€ in bitcoin contro",
    text2: "I piani assicurativi partono da €30/anno (€2,50/mese). Puoi saperne di più su Bitsurance e sui dettagli dell'offerta sul",
    text3: "Attualmente disponibile in Germania, con altri Paesi in arrivo.",
    title: "Inizia"
  },
  intro: {
    link: "sito Bitsurance",
    text1: "BitBox collabora con Bitsurance per aggiungere un ulteriore livello di protezione per i tuoi bitcoin. Mentre BitBox02 mantiene i tuoi fondi al sicuro, Bitsurance copre le minacce domestiche che non possono essere mitigate con la sola tecnologia, come furti con scasso, estorsioni o la distruzione dello stesso hardware wallet."
  },
  terms: {
    link: "Privacy Policy di Bitsurance",
    text1: "Bitsurance è un servizio indipendente di terze parti. Per domande riguardanti le loro offerte e le richieste di risarcimento assicurativo, contatta direttamente Bitsurance.",
    text2: "La copertura assicurativa è attualmente disponibile in Germania, a cui seguiranno altri Paesi.",
    text3: "La copertura massima di Bitcoin attualmente disponibile è di €100.000 a persona. Prevediamo la disponibilità di importi più elevati in futuro.",
    text4: "Le informazioni personali e la chiave pubblica estesa del tuo account assicurato fanno parte della polizza assicurativa e saranno condivise con Bitsurance e la compagnia assicurativa.",
    text5: "Per ulteriori informazioni sulla privacy, consulta la"
  },
  title: "Assicurazione"
};
const bitsuranceAccount = {
  errorNoXpub: "Errore: non è stato possibile ottenere la chiave pubblica dell'account.",
  noAccount: "Non ci sono account che possono essere assicurati.",
  select: "Seleziona un account",
  title: "Assicurazione"
};
const blink = {
  button: "Lampeggia"
};
const bootloader = {
  button: "Aggiornare il firmware",
  button_install: "Installa il firmware adesso",
  progress: "Aggiornamento: {{progress}}%",
  progress_install: "Installazione: {{progress}}%\n",
  success: "Aggiornamento riuscito! Ricollegare il dispositivo. Questa volta non toccare il pulsante."
};
const button$5 = {
  abort: "Interrompere",
  back: "Indietro",
  buy: "Acquista",
  changepin: "Cambia la password del dispositivo",
  check: "Verifica il backup",
  "continue": "Continua",
  copy: "Copia",
  create: "Creare",
  dismiss: "Sospendi",
  done: "Fatto",
  download: "Scarica",
  hiddenwallet: "Crea un wallet nascosto",
  next: "Successivo",
  ok: "OK",
  previous: "Precedente",
  receive: "Ricevi",
  restore: "Ripristina",
  select: "Selezionare",
  send: "Invia",
  unlock: "Sblocca",
  update: "Aggiorna",
  upgrade: "Aggiorna"
};
const buy$1 = {
  exchange: {
    bankTransfer: "Bonifico bancario",
    bestDeal: "Miglior prezzo",
    creditCard: "Carta di credito",
    fast: "Rapido",
    fee: "commissione",
    infoContent: {
      moonpay: {
        fees: {
          bankTransfer: "Bonifico Bancario: {{fee}}%",
          creditDebitCard: "Carta di debito/credito: {{fee}}%",
          learnMore: "Scopri di più su Moonpay",
          title: "Commissioni"
        },
        fullCurrenciesList: "Vedi la lista completa di valute qui",
        payment: {
          asteriskText: "* Non disponibile per i residenti in US",
          bankTransfer: "Bonifico bancario*",
          bankTransferDetails: {
            pix: "PIX (Transazioni BR esclusivamente in Brasile)",
            sepa: "SEPA e SEPA istantaneo (transazioni EUR esclusivamente in Paesi SEPA)",
            uk: "UK Faster Payments (transazioni GBP esclusivamente in UK)"
          },
          creditDebitCard: "Carta di credito/debito",
          creditDebitCardDetails: {
            cards: "Amex, Mastercard, Visa e Maestro"
          },
          learnMore: "Vedi più dettagli sui metodi di pagamento",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta tutte le principali valute fiat: USD, EUR, CHF, and altre."
      },
      pocket: {
        fees: {
          info: "Bonifico bancario: {{fee}}%",
          title: "Commissioni"
        },
        learnMore: "Scopri di più su Pocket",
        payment: {
          bankTransfer: "Bonifico bancario",
          bankTransferDetails: {
            sepa: "SEPA e SEPA istantaneo (per le transazioni in EUR nei Paesi SEPA)",
            sic: "Swiss Interbank Clearing (per le transazioni in CHF in CH/LI)",
            uk: "UK Faster Payments (per le transazioni GBP in UK)"
          },
          bankTransferReccuring: "Come impostare degli acquisti ricorrenti tramite un ordine permanente?",
          title: "Metodi di pagamento"
        },
        supportedCurrencies: "Supporta le seguenti valute Europee: EUR, GBP e CHF",
        verification: {
          info: "Richiede una verifica dell'identità solamente al di sopra delle soglie giornaliere ed annuali",
          link: "Trova le soglie aggiornate qui",
          title: "Verifica dell'identità"
        }
      },
      region: {
        title: "Selezione il Paese in cui hai registrato il tuo conto bancario per vedere le opzioni disponibili per te."
      }
    },
    noExchanges: "Mi dispiace, non ci sono exchange disponibili in questo Paese",
    region: "Paese",
    selectRegion: "Non specificato",
    title: "Compra {{name}}"
  },
  info: {
    "continue": "Accetta e continua",
    crypto: "crypto",
    disclaimer: {
      intro: [
        "Siamo una partnership MoonPay per offrirti un modo semplice per comprare {{name}} direttamente all'interno della BitBoxApp. Bastano pochi click.",
        "MoonPay è una piattaforma che rende comprare {{name}} facile e veloce in oltre 160 paesi."
      ],
      payment: {
        details: "Puoi comprare {{name}} istantaneamente tramite MoonPay con i seguenti metodi di pagamento. Gli ordini con carta di credito o di debito sono immediati e convenienti, ma più costosi a causa del maggior rischio di chargeback. Raccomandiamo di usare l'opzione del bonifico bancario per importi maggiori. La tariffa minima è di 4 USD/EUR o equivalente.",
        footnote: "Si prega di notare che i tassi di cambio di MoonPay possono differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
        table: {
          "1_description": "Tariffe più basse, possono richiedere fino a 3 giorni lavorativi",
          "1_method": "Trasferimenti bancari (SEPA)",
          "2_description": "Commissioni più alte, ma veloce ed istantaneo",
          "2_method": "Carte di debito e credito",
          description: "Descrizione",
          fee: "Commissione",
          method: "Metodo"
        },
        title: "Metodi di pagamento e commissioni"
      },
      privacyPolicy: "Privacy policy di MoonPay",
      protection: {
        description: "La BitBoxApp non raccoglie alcun dato quando si acquista {{name}} ed i fondi in entrata sono trattati come una normale transazione. MoonPay ha bisogno di raccogliere alcuni dati personali per operare. La loro privacy policy spiega in dettaglio come questi dati vengono gestiti.",
        descriptionGeneric: "BitBoxApp non registra nessun dato durante l'acquisto di {{name}}, i fondi in entrata sono trattati come comuni transazioni. Ciò nonostante, gli exchange partner hanno bisogno di alcune informazioni per poter operare. Fai riferimento alle rispettive privacy policy per verificare come i dati vengono gestiti.",
        title: "Protezione dei dati"
      },
      security: {
        description: `Quando acquisti {{name}} tramite MoonPay, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione.`,
        descriptionGeneric: `Quando acquisti {{name}} tramite un exchange partner, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione.`,
        link: "Security threat model",
        title: "Security model"
      },
      title: "Benvenuto nel tuo sportello unico per l'acquisto di {{name}}"
    },
    next: "Prossimo",
    selectLabel: "Scegli un account",
    selectPlaceholder: "Seleziona una valuta",
    skip: "Non mostrare più",
    title: "Acquista {{name}}"
  },
  pocket: {
    data: {
      link: "Privacy policy di Pocket",
      p1: "BitBoxApp non registra nessun dato durante l'acquisto di Bitcoin, i fondi in entrata sono trattati come comuni transazioni. Pocket ha bisogno di alcune informazioni personali per poter operare. La loro privacy policy spiega in dettaglio come i dati vengono gestiti.",
      title: "Protezione dei dati"
    },
    kyc: {
      link: "Leggi le FAQ di Pocket",
      p1: "Pocket cerca di mantenere al minimo il KYC. Per acquisti al di sotto dei 950 EUR (1000 CHF) al giorno, non è necessario nessun documento aggiuntivo. Per acquisti di importi superiori, sarà necessario programmare una call con Pocket per completare le necessarie procedure KYC/AML.",
      title: "KYC/AML"
    },
    payment: {
      p1: "Puoi comprare Bitcoin istantaneamente con Pocket tramite un bonifico bancario SEPA. La commissione è del 1,5% e i Bitcoin vengono depositati sul tuo BitBox appena possibile una volta che Pocket ha ricevuto il bonifico (di solito in giornata).",
      p2: "Si prega di notare che i tassi di scambio utilizzati da Pocket potrebbero differire da quelli utilizzati nella BitBoxApp, risultando in importi leggermente diversi.",
      title: "Metodi di pagamento e commissioni"
    },
    previousTransactions: "Lo storico di transazioni di questo account non è vuoto. Condividere questo account renderà tutte le transazioni passate e future visibili per Pocket. Procedere comunque? ",
    security: {
      link: '"BitBox02 security threat model"',
      p1: `Quando acquisti Bitcoin tramite Pocket, stai usando un servizio esterno. Questo servizio è fuori dall'ambito del "Securiy Threat model" del BitBox02 e si affida al grado di sicurezza dell'ambiente in cui il software BitBoxApp è in esecuzione. Comunque, lavoriamo insieme per migliorare la sicurezza utilizzando un meccanismo di autenticazione a due fattori per verificare il tuo indirizzo di ricezione.`,
      title: "Modello di sicurezza "
    },
    usedAddress: "L'indirizzo {{address}} è già stato utilizzato, per favore ricomincia da capo con un nuovo indirizzo.",
    verifyBitBox02: "Per favore, verifica che l'indirizzo che hai ricevuto via email corrisponda a quello visualizzato sul tuo BitBox. Se possibile, dovresti aprire la mail su un secondo dispositivo per maggiore sicurezza.",
    welcome: {
      p1: "Collaboriamo con Pocket per offrirti un modo fluido per acquistare Bitcoin direttamente nella BitBoxApp. Sono solo pochi click.",
      p2: "Pocket è una piattaforma Svizzera che rende semplice e veloce acquistare Bitcoin in gran parte dell'Europa (ovunque un bonifico bancario SEPA sia supportato).",
      p3: "Con Pocket, puoi anche acquistare regolarmente tramite singoli bonifici bancari, quindi puoi fare DCA (dollar-cost averaging) con semplicità.",
      title: "Benvenuto nel tuo sportello unico per l'acquisto di Bitcoin"
    }
  },
  title: "Acquista {{name}}"
};
const changePin = {
  newTitle: "Nuova password del dispositivo",
  oldLabel: "Password attuale del dispositivo"
};
const chart$1 = {
  dataMissing: "Raccolta di dati ... rimanete collegati.",
  dataOldTimestamp: "Aggiornamento dei tassi di cambio storici. Il grafico non visualizza dati posteriori al {{time}}",
  dataUpdating: "aggiornamento dei dati ...",
  filter: {
    all: "Tutto",
    month: "Mese",
    week: "Settimana",
    year: "Anno"
  }
};
const checkSDcard = "verifica della scheda microSD";
const clickHere = "Clicca qui.";
const confirm$2 = {
  abortInfo: "Tocca per",
  abortInfoRedText: "interrompere",
  approveInfo: "Tocca per almeno 4 secondi per",
  approveInfoGreenText: "confermare",
  info: "Continua sul tuo BitBox",
  infoWhenPaired: "Prima sul cellulare accoppiato e poi sul tuo BitBox"
};
const confirmOnDevice = "Conferma sul tuo dispositivo.";
const connectKeystore$1 = {
  promptNoName: "Connetti il tuo BitBox02 per continuare",
  promptWithName: 'Connetti il tuo BitBox02 con nome "{{name}}" per continuare'
};
const darkmode$1 = {
  toggle: "Modalità scura"
};
const device = {
  appUpradeRequired: "Il tuo BitBox non è compatibile con questa versione dell'applicazione desktop. Installa l'ultima versione.",
  keystoreConnected: "Wallet connesso"
};
const deviceLock = {
  button: "Abilita autenticazione a due fattori (2FA)",
  condition1: "Hai un backup?",
  condition2: "La verifica via applicazione mobile funziona?",
  condition3: "2FA DISABILITA i backup e l'abbinamento dell'applicazione mobile. Il dispositivo deve essere resettato per uscire da 2FA!",
  confirm: "Abilita autenticazione a due fattori (2FA)",
  title: "Abilita autenticazione a due fattori (2FA)"
};
const deviceSettings = {
  backups: {
    manageBackups: {
      description: "Crea o verifica il tuo backup su microSD."
    },
    showRecoveryWords: {
      description: "Mostra e verifica le parole di recupero."
    },
    title: "Backup"
  },
  deviceInformation: {
    attestation: {
      description: "La BitBoxApp verifica che il tuo dispositivo sia autentico."
    },
    deviceName: {
      description: "Modifica il nome del tuo dispositivo."
    },
    rootFingerprint: {
      description: "La root fingerprint è un identificatore univoco del wallet attualmente in uso. Ti può aiutare a distinguere wallet diversi se usi la passphrase."
    },
    securechip: {
      description: "Modello del secur chip."
    },
    title: "Informazioni sul dispositivo"
  },
  expert: {
    factoryReset: {
      description: "Ripristina il dispositivo alle impostazioni di fabbrica. Questo cancella il wallet dal tuo BitBox02!",
      title: "Ripristino alle impostazioni di fabbrica"
    },
    goToStartupSettings: {
      description: "Entra nel bootloader del BitBox02. Da qui puoi abilitare il firmware hash"
    },
    passphrase: {
      description: "Abilita o disabilita la passphrase.",
      title: "Passphrase"
    }
  },
  firmware: {
    firmwareVersion: "Versione Firmware",
    newVersion: {
      label: "Versione disponibile"
    },
    title: "Firmware",
    upToDate: "Il tuo dispositivo è aggiornato",
    upgradeAvailable: "Nuovo upgrade disponibile",
    version: {
      label: "Versione"
    }
  },
  hardware: {
    attestation: {
      "false": "Verifica di autenticità fallita",
      label: "Verifica di autenticità",
      "true": "Il tuo Bitbox02 è autentico"
    },
    sdcard: {
      "false": "Non inserita",
      label: "carta microSD",
      "true": "Inserita"
    },
    securechip: "Secure chip",
    title: "Hardware"
  },
  loading: "Recupero delle informazioni sul dispositivo...",
  pairing: {
    lock: {
      "false": "Disabilitato",
      label: "Autenticazione a due fattori",
      "true": "Abilitato"
    },
    mobile: {
      "false": "Chiuso",
      label: "Applicazione mobile",
      "true": "Aperto"
    },
    status: {
      "false": "Non abbinato",
      label: "Status",
      "true": "Abbinato"
    },
    title: "Abbinamento"
  },
  secrets: {
    manageBackups: "Gestione backup",
    title: "Segreti"
  }
};
const deviceTampered = "Il tuo BitBox è stato fornito con una password di recupero? Se è così, interrompi il processo di configurazione e contatta il supporto immediatamente. Shift non ti fornirà mai un wallet pronto, né ti consiglierà una password.";
const dialog$1 = {
  cancel: "Annulla",
  confirm: "Conferma",
  confirmTitle: "Conferma"
};
const error$2 = {
  accountAlreadyExists: "L'account esiste già.",
  accountLimitReached: "Impossibile aggiungere un account. È stato raggiunto il numero massimo di account per questa moneta.",
  aoppCallback: "Si è verificato un errore nella consegna dell'indirizzo a {{host}}.\n",
  aoppInvalidRequest: "Richiesta non valida",
  aoppNoAccounts: "Non ci sono account disponibili.",
  aoppSigningAborted: "Richiesta di proprietà dell'indirizzo annullata.\n",
  aoppUnknown: "Si è verificato un errore sconosciuto.\n",
  aoppUnsupportedAsset: "The asset is not supported.",
  aoppUnsupportedFormat: "Non ci sono account disponibili che supportino il formato di indirizzo richiesto.",
  aoppUnsupportedKeystore: "Il dispositivo collegato non può firmare i messaggi per questo asset.\n",
  aoppVersion: "Versione sconosciuta.",
  wrongKeystore: "Wallet connesso errato. Assicurati di inserire il dispositivo corretto per questo account.",
  wrongKeystore2: "Se stai utilizzando la passphrase opzionale, assicurati di avere inserito quella corretta per questo account."
};
const fiat$2 = {
  "default": "predefinito",
  setDefault: "Imposta {{code}} come valuta predefinita",
  title: "Valute"
};
const footer$2 = {
  appVersion: "Versione dell'app:"
};
const generic$1 = {
  enabled_false: "Disabilitato",
  enabled_true: "Abilitato"
};
const genericError = "Si è verificato un errore. Se noti qualche problema, riavvia l'applicazione.";
const goal = {
  buttons: {
    create: "Creare un nuovo wallet",
    restore: "Ripristina un wallet dal backup"
  },
  paragraph: "Seleziona una delle seguenti opzioni:",
  step: {
    "1": {
      title: "Informazioni sulla sicurezza"
    },
    "2": {
      description: "Impostare la password del dispositivo",
      title: "Dispositivo"
    },
    "3-create": {
      description: "Crea un nuovo wallet",
      title: "Wallet"
    },
    "3-restore": {
      description: "da un backup",
      title: "Ripristina"
    },
    "4-create": {
      title: "Riassunto"
    },
    "4-restore": {
      title: "Riassunto"
    }
  }
};
const guide$1 = {
  accountDescription: {
    text: "La panoramica dell'account mostra il tuo saldo disponibile e le transazioni in entrata e in uscita. La nostra guida in 'Impostazioni' contiene maggiori informazioni sui diversi tipi di account. ",
    title: "Cosa contiene questa pagina?"
  },
  accountFiat: {
    text: "Si. Clicca su qualsiasi ticker per scorrere tra le valute fiat. Puoi cambiare la lista delle valute nelle impostazioni.",
    title: "Posso visualizzare altri tassi di conversione?"
  },
  accountIncomingBalance: {
    text: "Le somme in entrata riassumono gli importi trasferiti a voi ma non ancora confermati dalla rete.",
    title: "Cosa significa somme in entrata?"
  },
  accountInfo: {
    multipleXPubs: {
      text: `Ogni xpub è legata al "Tipo" indicato: "Native Segwit (bech32)", "Wrapped Segwit" o "Taproot" (solo Bitcoin). Questi sono i tipi di script utilizzati da {{coinName}}. La BitBoxApp li combina, supportando più tipi di script nello stesso account. Poiché ogni tipo di script fornisce un xpub diverso, esistono più xpub per account.

Se si riceve sempre sull'indirizzo predefinito (Native Segwit), è necessario solo l'xpub "bech32". Tuttavia, se si ricevono fondi anche su "Wrapped Segwit" o "Taproot", è necessario utilizzare anche le chiavi pubbliche estese "Wrapped Segwit" e "Taproot" rispettivamente.`,
      title: "Perché ci sono diverse xpub?\n"
    },
    privacy: {
      text: "Per questo specifico account, la chiave pubblica estesa rivela l'intera storia finanziaria, il saldo dell'account e tutte le transazioni future. L'xpub però non consente a nessuno di spendere i tuoi fondi.\n\nSe si condivide un'xpub con qualcuno, si deve essere consapevoli che questa persona o azienda può vedere tutte le altre transazioni dello stesso account. Pertanto, è bene utilizzare quell'account solo per questo scopo e conservare gli altri fondi in account diversi.",
      title: "Devo tenere la my xpub segreta?"
    },
    verify: {
      text: "Sì, è sempre una buona idea ricontrollare la propria xpub. E' particolarmente importante nel caso in cui qualcun altro generi indirizzi di ricezione da questa xpub per inviare denaro. È necessario verificarla sul dispositivo per assicurarsi che questa xpub appartenga a voi; in caso contrario, tutti i fondi potrebbero andare a indirizzi sbagliati.",
      title: "È necessario verificare l'xpub sul dispositivo?\n"
    },
    xpub: {
      text: `Una chiave pubblica estesa è una chiave "root" da cui derivano tutti gli indirizzi di ricezione di un account. 

È fornita qui per un uso avanzato e per l'interoperabilità con wallet watch-only, come Electrum o Sentinel. Se hai ricevuto su diversi tipi di indirizzo, importa tutti i diversi formati xpub nel wallet watch-only per vedere tutte le tue valute.

Nota bene: i wallet di terze parti potrebbero non supportare ancora gli xpub di Taproot.`,
      title: "Cos'è una chiave pubblica estesa?"
    }
  },
  accountRates: {
    text: "Aggiorniamo i tassi di cambio ogni minuto da CoinGecko.",
    title: "Quali tassi di cambio si applicano?"
  },
  accountReload: {
    text: "Non ce n'è bisogno. Le informazioni sulla tua transazione vengono aggiornate automaticamente.",
    title: "Posso ricaricare la cronologia delle transazioni?"
  },
  accountSendDisabled: {
    text: "Il pulsante 'Invia' è attivo quando hai un saldo maggiore di zero.",
    title: "Perché non posso inviare {{unit}}?"
  },
  accountSummaryAmount: {
    text: "L'importo totale è la somma di tutti i tuoi account. I tassi di cambio sono ottenuti da coingecko.com.\n\nNota: se usi MyEtherWallet per i token non supportati nella BitBoxApp, questi non saranno inclusi nell'importo visualizzato.",
    title: "Come viene calcolato l'importo totale?"
  },
  accountSummaryDescription: {
    text: "Qui pui vedere la performance del tuo portafogli nel tempo. Sotto il grafico viene visualizzato un riepilogo dei diversi account.",
    title: "Cosa contiene questa pagina?"
  },
  accountTransactionAttributesBTC: {
    text: 'Dimensione virtuale: Determina la tassa di rete. Si risparmia sulle commissioni se è più piccola della dimensione della transazione.\nDimensione: Dimensione effettiva della transazione in byte quando serializzata secondo la blockchain sottostante.\nPeso: Una nuova metrica introdotta con Segwit per valutare le dimensioni delle transazioni e dei blocchi. Ogni byte del "segregated witness" conta come uno, tutto il resto come quattro unità di peso. Invece di un megabyte di dimensione effettiva, il limite della dimensione del blocco è ora di quattro milioni di unità di peso.',
    title: "E i dettagli delle transazioni in Bitcoin?"
  },
  accountTransactionAttributesGeneric: {
    text: "Conferme: La tua prima transazione trasmessa non è confermata fino a quando un minatore la include in un blocco, dopo di che ha una conferma. Ogni blocco trasmesso sulla rete aggiunge un'altra conferma alla tua transazione. Generalmente i commercianti e gli altri attori della rete saldano solo le transazioni con un numero di conferme compreso tra tre e sei.\nID della transazione: Un numero di identificazione unico che permette di cercare una transazione in un esploratore di blocchi.\nCommissione: Ai minatori viene pagata una tassa di transazione come incentivo per includere le transazioni nei blocchi che estraggono. Per saperne di più, clicca sul pulsante invia.",
    title: "Quali sono le informazioni nei dettagli della transazione?"
  },
  accountTransactionConfirmation: {
    text: "Una transazione trasmessa alla rete ma non ancora confermata.",
    title: "Cos'è una transazione in sospeso?"
  },
  accountTransactionLabel: {
    text: "L'indirizzo da cui hai ricevuto o a cui hai inviato delle monete.",
    title: "Quale indirizzo viene visualizzato per ogni transazione?"
  },
  accountTransactionTime: {
    text: "Il tempo di conferma della transazione su blockchain.",
    title: "Che ora viene visualizzata?"
  },
  accounts: {
    howManyAccounts: {
      text: "Non c'è un limite al numero di account Bitcoin e Litecoin supportati. Dopo il quinto account, potrai aggiungerne uno nuovo solo se il precedente è già stato utilizzato.\n",
      title: "Quanti account posso creare?"
    },
    howtoAddTokens: {
      text: 'I token che utilizzano lo standard ERC20 sono legati a uno specifico account Ethereum. Per attivare o disattivare un determinato token, aprire la schermata "Gestisci account", espandere il proprio account Ethereum e attivare o disattivare il token desiderato.',
      title: "Come posso aggiungere più token?\n"
    },
    moveFunds: {
      text: "Sì, ma poiché gli account sono indipendenti, è necessario inviare i fondi con una transazione regolare.\n",
      title: "Posso spostare fondi tra account diversi?"
    },
    recoverAccounts: {
      text: "Sì. BitBoxApp crea account utilizzando standard consolidati e compatibili con la maggior parte degli altri wallet per criptovalute.",
      title: "Posso recuperare i miei account con altri wallet?"
    },
    whatAreAccounts: {
      text: "Il tuo wallet può gestire più account della stessa moneta. Diversi account sono utili quando si desidera mantenere i fondi separati.",
      title: "Cosa sono gli account?"
    },
    whatIsRememberWallet: {
      text: `Abilitando "Ricorda wallet" puoi vedere gli account di questo wallet nella BitBoxApp anche quando il BitBox02 non è collegato. Questo ti consente di controllare il tuo saldo e il tuo portafoglio ogni volta che vuoi. Il BitBox02 dovrà comunque essere collegato e sbloccato per inviare o ricevere fondi.

Disabilitando "Ricorda wallet" dovrai collegare il relativo BitBox02 (con l'eventuale passphrase) per vedere i suoi account nella BitBoxApp.`,
      title: "Cosa succede quando attivo/disattivo “Ricorda wallet”?"
    },
    whyIsThisUseful: {
      text: 'Gli account sono ottimi per gestire fondi per persone o scopi diversi, perché sono separati. È inoltre possibile condividere la "chiave pubblica estesa" di un account senza rivelare nulla degli altri account. Ciò consente di ricevere ripetutamente fondi senza riutilizzare gli indirizzi, ad esempio per ricevere lo stipendio o per acquistare regolarmente criptovalute.',
      title: "Perchè è utile?"
    }
  },
  appendix: {
    link: "Contattaci",
    text: "Altre domande?"
  },
  backups: {
    check: {
      text: "'Controlla backup' ti permette di verificare di avere un backup funzionante corrispondente al tuo wallet attuale. Può anche essere usato per verificare che tu abbia ancora la password di recupero corretta. Puoi controllare la tua password di recupero principale o la tua password di recupero nascosta.",
      title: "Cos'è il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No, ma la tua password di recupero è necessaria per ricavare il wallet dal "seed" memorizzato.',
      title: "Posso criptare il backup?"
    },
    howOften: {
      text: "Il backup viene generato automaticamente quando viene creato un nuovo wallet. Devi fare un nuovo backup solo se la tua scheda microSD viene persa o danneggiata, o se vuoi usare più schede microSD come backup.\nNon è necessario creare nuovi backup dopo aver inviato o ricevuto transazioni. Tutti i dati delle tue transazioni possono essere ricreati dal tuo singolo backup che è stato generato automaticamente per te.",
      title: "Quanto spesso devo fare un backup?"
    },
    whatIsABackup: {
      text: 'È una copia del "seed" su una scheda microSD. Il "seed" insieme alla tua password di recupero genera il tuo wallet.',
      title: "Cos'è un backup?"
    }
  },
  backupsBB02: {
    check: {
      text: "'Controlla backup' ti permette di verificare che hai un backup funzionante corrispondente al tuo wallet attuale.",
      title: "Cos'è il 'Controlla backup'?"
    },
    encrypt: {
      text: 'No. Tieni la scheda microSD al sicuro, perché contiene il "seed" non criptato per recuperare il tuo wallet. Se desideri proteggere con una password il tuo seed, puoi abilitare una passphrase opzionale nelle impostazioni avanzate sotto "Gestisci dispositivo".',
      title: "Posso criptare il backup?"
    },
    whatIsABackup: {
      text: 'È una copia del "seed" su una scheda microSD.',
      title: "Cos'è un backup?"
    }
  },
  bitbox: {
    "2FA": {
      text: `Quando la 2FA è abilitata, tutte le transazioni devono essere approvate sul cellulare abbinato per poter spendere fondi. Un numero monouso criptato viene inviato all'applicazione mobile, decriptato lì, e restituito al BitBox quando si preme il pulsante "Accetta". Questa comunicazione con il dispositivo avviene tramite un canale tra il telefono cellulare e l'applicazione desktop stabilita durante l'abbinamento.

Assicurati di fare il backup del tuo wallet e di abbinare l'applicazione mobile prima di abilitare il 2FA. Una volta abilitato, lo slot microSD e l'abbinamento dell'applicazione mobile sono disabilitati. Possono essere riabilitati resettando il BitBox, che cancella il dispositivo.`,
      title: "Come funziona l'autorizzazione a due fattori (2FA)?"
    },
    disable2FA: {
      text: "Per disabilitare il 2FA, è necessario resettare il BitBox e poi ripristinare il wallet dal suo backup. Assicurati di avere ancora la scheda microSD con il backup e di ricordare ancora la password di recupero. Poi premi 'Reset dispositivo'. Imposta una nuova password del dispositivo e scegli 'Ripristina un backup'. Seleziona il backup che hai fatto dal wallet. clicca su 'Ripristina' e inserisci la password di recupero che hai usato quando hai creato il wallet.",
      title: "Come posso disabilitare l'autorizzazione a due fattori (2FA)?"
    },
    ejectBitbox: {
      text: "È possibile scollegare il BitBox in qualsiasi momento senza doverlo prima espellere.",
      title: "Come posso espellere il BitBox?"
    },
    ejectSD: {
      text: "È possibile rimuovere la scheda microSD dal BitBox in qualsiasi momento, purché non si stia creando o ripristinando un backup.",
      title: "Come posso espellere la scheda microSD?"
    },
    hiddenWallet: {
      text: 'Si tratta di un secondo wallet sullo stesso dispositivo protetto da una password diversa da quella del dispositivo e quella di recupero, che puoi usare per una negazione plausibile. Lo stesso "seed" di backup viene utilizzato sia per il wallet normale che per quello nascosto, quindi non è necessario un backup aggiuntivo.',
      title: "Cos'è un wallet nascosto?"
    },
    legacyHiddenWallet: {
      text: "Prima clicca il pulsante qui sotto (disponibile se il BitBox è sbloccato con la password del dispositivo principale e 2FA è disabilitato), poi ricollega il tuo Bitbox e sbloccalo con la tua password del dispositivo nascosto.",
      title: "Come si accede al wallet nascosto legacy?"
    },
    pairing: {
      text: "Dopo aver scaricato la nostra applicazione mobile per iOS o Android, scansiona il codice QR visualizzato, che stabilisce un canale sicuro tra l'applicazione mobile e questa applicazione. Una volta scansionato, segui le istruzioni dell'applicazione mobile.",
      title: "Come abbinare in modo sicuro il tuo telefono"
    }
  },
  bitsurance: {
    faq: {
      link: {
        text: "www.bitsurance.eu"
      },
      text: "Per ulteriori dettagli, consulta il sito Web di Bitsurance e le FAQ",
      title: "Altre domande?"
    },
    privacy: {
      link: {
        text: "privacy policy di Bitsurance"
      },
      text: "Come ogni normale polizza assicurativa, contiene il tuo nome e indirizzo completo e specifica l'oggetto assicurato (definito dalla chiave pubblica estesa del conto Bitcoin assicurato). Questi dati vengono inviati direttamente a Bitsurance e non vengono condivisi con Shift Crypto. Per ulteriori informazioni, consultare la privacy policy Bitsurance",
      title: "Quali informazioni personali sono necessarie per l'assicurazione?"
    },
    renew: {
      text: 'L’assicurazione si rinnoverà automaticamente per l’anno successivo. Puoi annullare il rinnovo in qualsiasi momento facendo clic su "Gestisci contratto" nella BitBoxApp, che ti porta al portale clienti Bitsurance.',
      title: "Come posso rinnovare o annullare l'assicurazione?"
    },
    status: {
      text: `Gli account assicurati con successo sono contrassegnati con un badge verde "Account assicurato" nell'angolo in alto a sinistra nella pagina dell'account. Nella sezione "Assicura" puoi vedere una panoramica di tutti gli account Bitcoin assicurati e il loro attuale stato assicurativo. Può essere necessario attendere fino a 48 ore perchè lo stato dell'assicurazione venga aggiornato.`,
      title: "Posso verificare lo stato di un account assicurato?"
    },
    what: {
      text: `Ogni contratto assicurativo Bitcoin copre uno specifico account. Puoi assicurare più account stipulando più polizze assicurative. I conti assicurati sono limitati all'utilizzo di indirizzi Bitcoin di tipo "Native Segwit".`,
      title: "L'assicurazione copre l'intero wallet BitBox?"
    },
    who: {
      text: "L'assicurazione è offerta da Bitsurance, un broker assicurativo creato da bitcoiner. Lavorano con la compagnia di assicurazioni ELEMENT per fornire un'assicurazione su Bitcoin. Entrambe le società hanno sede in Germania.",
      title: "Chi assicura i miei bitcoin?"
    },
    why: {
      text: "Bitsurance copre alcuni rischi legati alla self-custody che non possono essere tutelati neanche dal più sicuro dei wallet, ad es. furto con scasso, estorsione o distruzione del wallet stesso. È una tua decisione personale se hai bisogno di una copertura assicurativa per questi rischi.",
      title: "Ho bisogno di un’assicurazione Bitcoin?"
    }
  },
  cointracking: {
    text: `Fai clic sul pulsante "Esporta" e apri la cartella dei download dove troverai l'esportazione CSV. Quindi fai clic sul link sottostante, carica il tuo file CSV BitBox e importa i dati per utilizzarli nel tuo gestore del portafoglio CoinTracking e per creare le tue dichiarazioni fiscali.`,
    title: "Come importo le mie transazioni in CoinTracking?"
  },
  device: {
    attestation: {
      link: {
        text: "Leggi di più sulla verifica di autenticità"
      },
      text: "La BitBoxApp effettua una verifica di autenticità sul BitBox02 per assicurarsi che il dispositivo sia autentico. La verifica viene eseguita localmente e non si connette a nessun server",
      title: "Come funziona la verifica di autenticità?"
    },
    name: {
      text: "Questo è il nome del tuo wallet e del backup. Il nome è utilizzato per i backup futuri e può essere utilizzato per distinguere tra wallet diversi. Può essere cambiato in ogni momento, ma tieni presente che i backup fatti prima del cambio avranno il nome precedente.",
      title: "Per cosa è utilizzato il nome del BitBox02?"
    },
    "secure-chip": {
      link: {
        text: "Leggi di più sul secure chip"
      },
      text: "Questa informazione mostra il modello del secure chip. Quello più aggiornato è ATECC608B, con funzionalità di sicurezza migliorate rispetto ai modelli precedenti.",
      title: "Perchè mostrare il modello del secure chip?"
    }
  },
  receive: {
    address: {
      text: "Puoi dare l'indirizzo ad altri per farti inviare dei fondi. Assicurati che stiano inviando all'indirizzo corretto.",
      title: "Cosa devo fare con un indirizzo?"
    },
    addressChange: {
      text: "Non appena si effettua una transazione, un nuovo indirizzo viene automaticamente aggiunto alla lista, quindi ci sono sempre 20 indirizzi disponibili che non hanno mai ricevuto fondi.",
      title: "Quando cambiano gli indirizzi?"
    },
    addressFormats: {
      text: "Da impostazione predefinita, il tipo di indirizzo è Native Segwit. Questo tipo di indirizzo è ampiamente adottato da altri wallet/exchange e offre le migliori tariffe per le transazioni quotidiane. Tuttavia, si può anche scegliere di inviare a Taproot (solo Bitcoin), il tipo di indirizzo più recente, ma potenzialmente non ancora ampiamente supportato. In alternativa, se hai problemi a inviare a Native Segwit (predefinito), puoi provare a passare al tipo di indirizzo più vecchio Wrapped Segwit, che potrebbe essere compatibile con più wallet/exchange.",
      title: 'Quando uso "Cambia tipo di indirizzo"?'
    },
    howVerify: {
      text: "Per il BitBox01, clicca sull'icona BitBox nella barra laterale a sinistra e vedi la sezione Abbinamento. La guida si aggiornerà e potrai continuare a seguire le istruzioni da lì.\nPer il BitBox02, è possibile verificare gli indirizzi direttamente sul dispositivo durante il processo di invio/ricezione.",
      title: "Come posso verificare un indirizzo in modo sicuro?"
    },
    plugout: {
      text: "No, una volta inviati fondi all'indirizzo del tuo BitBox, non è necessario lasciarlo collegato. Sei libero di scollegare il tuo BitBox.",
      title: "È necessario lasciare il BitBox collegato durante la ricezione?"
    },
    why20: {
      text: `Durante l'avvio l'app genera indirizzi derivati dal tuo "seed" per vedere se hanno ricevuto fondi. Poiché l'app può generare un numero quasi infinito di indirizzi, potrebbero volerci anni per determinare il saldo. Per limitare questa ricerca, la app si ferma quando vede 20 indirizzi che non hanno mai ricevuto fondi. Questo è il "gap limit" e 20 è uno standard de-facto anche se il numero è arbitrario. Questi sono i 20 indirizzi tra cui puoi scegliere.`,
      title: "Perché solo 20 indirizzi?"
    },
    whyMany: {
      text: 'Per mantenere la privacy e la sicurezza, non dare mai lo stesso indirizzo due volte. Se hai usato un indirizzo, clicca sulla freccia a destra per un nuovo indirizzo. Puoi generare fino a 20 indirizzi alla volta. Pensa agli indirizzi come ai numeri di fattura. Tutti gli indirizzi sono derivati dal tuo singolo "seed" di backup.',
      title: "Perché così tanti indirizzi?"
    },
    whyVerify: {
      text: "Non dovresti fidarti del computer per generare e visualizzare indirizzi genuini. L'ampia superficie di attacco lo rende molto più vulnerabile di un hardware wallet. Nel caso del BitBox01, il pulsante per verificare l'indirizzo invia in modo sicuro l'indirizzo a un telefono cellulare associato, dal quale è anche possibile scansionare e verificare il codice QR. Per il BitBox02, l'indirizzo può essere verificato direttamente sul display del BitBox02.",
      title: "Perché dovrei verificare l'indirizzo in modo sicuro?"
    }
  },
  send: {
    change: {
      text: "Il resto verrà restituito a un indirizzo Taproot se è presente almeno un UTXO Taproot. Se si usa il coin control, il resto verrà restituito a un indirizzo Taproot se c'è almeno un UTXO Taproot tra gli UTXO selezionati. In tutti gli altri casi, il resto viene restituito a un indirizzo Native Segwit.",
      title: "Come viene determinato l'output del resto?"
    },
    fee: {
      text: "La commissione si basa sulla dimensione dei dati della transazione e non sulla sua quantità. \nle commissioni sono calcolate dall'algoritmo di stima di Bitcoin Core per ogni priorità di rete scelta. Sono mostrate se hanno un valore diverso rispetto a quelli qui sotto.\nEconomica: 24 blocchi (circa 4 ore per Bitcoin, 1 ora per Litecoin)\nBasso: 12 blocchi (circa 2 ore per Bitcoin, 30 minuti per Litecoin)\nNormale: 6 blocchi (circa 1 ora per il Bitcoin, 15 minuti per il Litecoin)\nAlto: 2 blocchi (circa 20 minuti per il Bitcoin, 5 minuti per il Litecoin)\n(Un blocco impiega in media dieci minuti per Bitcoin (2,5 minuti in Litecoin) per essere estratto e il carico della rete può variare considerevolmente nei periodi di cui sopra).",
      title: "Come sono determinate le commissioni?"
    },
    plugout: {
      text: "No, una volta effettuata una transazione, non è necessario lasciare il BitBox collegato. Si è liberi di scollegare il BitBox.",
      title: "È necessario lasciare il BitBox collegato durante l'invio?"
    },
    priority: {
      text: "Più commissioni paghi, tipicamente più velocemente le transazioni sono confermate dalla rete",
      title: "Cos'è la priorità di rete?"
    },
    revert: {
      text: "Una volta che una transazione è firmata e inviata (cioè trasmessa alla rete), non può più essere annullata. Verificate bene le transazioni (compresa la commissione) prima di firmare!\nSe conosci il destinatario e lui/lei è disposto/a a rimandarti lo stesso importo (meno le commissioni della transazione), puoi inviargli/le un nuovo indirizzo di ricezione.",
      title: "Posso revocare una transazione?"
    },
    whyFee: {
      text: "Le transazioni sono in competizione per essere confermate da un minatore. I minatori scelgono le transazioni da includere nella blockchain in base al loro compenso.\nI minatori votano sulla storia delle transazioni. Dal momento che non c'è una terza parte fidata che faccia rispettare un voto per persona (che è l'intero scopo delle blockchain), i minatori votano sulle transazioni sacrificando una risorsa costosa come la potenza di calcolo. Come ricompensa per il loro lavoro, possono reclamare fondi appena creati e le commissioni di tutte le transazioni che hanno incluso.",
      title: "Perché ci sono delle commissioni di rete?"
    }
  },
  "settings-electrum": {
    connection: {
      text: "Se intendi connetterti al tuo nodo solo quando sei connesso alla stessa rete (ad esempio il wifi di casa tua) allora è sufficiente utilizzare la normale comunicazione di rete.\nIn questo caso è consigliabile che il tuo server Electrum fornisca un certificato TLS per cifrare la comunicazione.\nSe hai intenzione di connetterti al tuo nodo da qualsiasi luogo, usare Tor è l'opzione migliore. In questo caso non è necessario alcun certificato TLS.",
      title: "Meglio usare clearnet TCP, TLS o Tor?"
    },
    instructions: {
      link: {
        text: "Guida per collegare il tuo nodo"
      },
      text: "Per un tutorial completo, visitate la nostra guida:",
      title: "Come faccio a collegare la mia BitBoxApp al mio full node?"
    },
    options: {
      text: "Ci sono diverse opzioni per utilizzare un proprio nodo come acquistare un dispositivo finito, costruire il proprio o utilizzare Bitcoin Core.\nSe vuoi collegare la BitBoxApp al tuo nodo, assicurati che esegua un server Electrum. Questo è un programma dedicato che permette ad un'app wallet di comunicare con il tuo nodo.\nLe opzioni supportate includono Electrs, Electrum Personal Server (EPS) o Bitcoin Wallet Tracker (BTW).",
      title: "Quali opzioni ci sono per gestire un nodo?"
    },
    tor: {
      text: "Tor è l'acronimo di 'The Onion Router', che è un software gratuito e open source che offre un sacco di vantaggi per la privacy ed è particolarmente utile quando si usa Bitcoin.\nSe hai intenzione di connetterti al tuo nodo tramite Tor, assicurati che Tor sia installato sul tuo computer e poi abilita il Proxy Tor nelle impostazioni di BitBoxApp.\nSulla maggior parte dei sistemi operativi ci sono due modi per eseguire Tor:\n1. 1. Tor Browser: scaricare e aprire il Tor Browser. Questo permetterà alla BitBoxApp di connettersi alla rete Tor impostando la porta 9150 nelle impostazioni del proxy Tor.\n2. Servizio Tor in background: installare il daemon Tor, che viene sempre eseguito in background. La BitBoxApp può quindi connettersi impostando la porta 9050 nelle impostazioni del proxy Tor.",
      title: "Cos'è Tor, Tor proxy e quale porta usare?"
    },
    what: {
      text: "È possibile utilizzare il tuo wallet con il mio full node invece di usare i server di Shift.",
      title: "Cosa significa?"
    },
    why: {
      text: "Utilizzare il proprio nodo non è necessario, ma migliora la privacy e riduce la necessità di fidarsi degli altri.\nIn primo luogo, significa che stai usando Bitcoin più privatamente, poiché la BitBoxApp non si connetterà ai nostri server per recuperare la tua storia delle transazioni; invece recupererà quelle informazioni dal tuo nodo.\nIn secondo luogo, utilizzare il tuo nodo significa che il tuo nodo verifica tutte le transazioni, assicurandosi che le regole di consenso siano applicate.",
      title: "Perché dovrei utilizzare il mio nodo?"
    }
  },
  settings: {
    sats: {
      text: "Un Satoshi ('sat' in breve) è la più piccola unità di Bitcoin. Un Satoshi è un centomilionesimo di Bitcoin (0.00000001 BTC). E' stato chiamato così in omaggio al creatore di Bitcoin, Satoshi Nakamoto.",
      title: "Cos'è un Satoshi? "
    },
    servers: {
      text: "Questa app comunica con i server Shift Crypto per controllare gli aggiornamenti, caricare le transazioni e inviare informazioni alle app mobili abbinate.\nL'app recupera anche gli ultimi tassi di cambio da CoinGecko. Tutte le conversioni sono calcolate localmente, il che significa che nessun dato sull'importo della tua transazione viene mai trasmesso.\nNota: Per Ethereum e i Token ERC20, usiamo le API di Etherscan.io.",
      title: "A quali server si connette questa app?"
    }
  },
  title: "Guida",
  toggle: {
    close: "Chiudi guida",
    open: "Guida"
  },
  trackingModePortfolioChart: {
    text: "Su Desktop, sposta il cursore sopra al grafico. Da mobile, tieni il dito premuto sul grafico e spostalo orizzontalmente.",
    title: "Come visualizzare lo storico dei prezzi sul grafico? "
  },
  unlock: {
    forgotDevicePassword: {
      text: "Devi resettare il dispositivo e ripristinare il wallet da un backup, utilizzando la password di recupero.",
      title: "Cosa devo fare se ho dimenticato la password del dispositivo?"
    },
    reset: {
      text: "Inserisci una password errata del dispositivo per 15 volte. Gli ultimi tentativi richiedono un lungo tocco sul dispositivo.",
      title: "Come faccio a resettare il dispositivo?"
    }
  },
  waiting: {
    deviceNotRecognized: {
      text: "Il dispositivo dovrebbe lampeggiare una volta quando viene inserito. Assicurati che sia inserito nel modo giusto. Se hai problemi, contattaci attraverso il link qui sotto.\n\nIl BitBox01 non è supportato su dispositivi mobili. Utilizzare la BitBoxApp su desktop per collegare il BitBox01.",
      title: "Il mio BitBox01 non viene riconosciuto"
    },
    getDevice: {
      link: {
        text: "Ordina un BitBox"
      },
      text: "Puoi comprare una BitBox nel nostro negozio online:",
      title: "Come posso ottenere un dispositivo?"
    },
    internet: {
      text: "Sì, è necessaria una connessione internet per sincronizzare il wallet, inviare transazioni e recuperare gli ultimi tassi di cambio.",
      title: "Questa app richiede una connessione a internet?"
    },
    lostDevice: {
      link: {
        text: "Backup center"
      },
      text: "Puoi recuperare i tuoi account su un nuovo BitBox o con il nostro Backup center.",
      title: "Ho perso il mio dispositivo. E adesso?"
    },
    useWithoutDevice: {
      text: "Purtroppo, questo non è ancora possibile al momento.",
      title: "Posso usare l'applicazione senza un dispositivo?"
    },
    welcome: {
      text: "Grazie per aver usato questa app costruita da Shift Crypto in Svizzera. Apprezziamo qualsiasi input che hai da condividere. Inviaci il tuo feedback utilizzando il link in basso.",
      title: "Benvenuti nella BitBoxApp!"
    }
  },
  walletConnect: {
    noPreviousConnections: {
      text: "Se utilizzi la BitBoxApp su un nuovo telefono/computer, dovrai riconnetterti alle DApp per vedere le valute collegate come al solito.",
      title: "Non vedo le mie connessioni precedenti."
    },
    supportedNetworks: {
      text: "Al momento, solo la mainnet Ethereum è supportata da WalletConnect nella BiBoxApp. Se hai bisogno di un wallet per altre chain EVM puoi utilizzare l'estensione per il browser Rabby.",
      title: "Quali reti sono supportate?"
    },
    whatIsWalletConnect: {
      text: "WalletConnect è un protocollo di comunicazione per applicazioni web3. Ti permette di connetterti comodamente a DApp e web wallet senza dover usare un'altra app. Particolarmente utile per gli utenti Android della BitBoxApp.",
      title: "Cos'è WalletConnect?"
    }
  }
};
const headerssync = {
  blocksSynced: "{{blocks}} blocchi sincronizzati"
};
const hiddenWallet = {
  info1HTML: "Per scopi di negazione plausibile, un wallet nascosto può essere creato sulla base di una combinazione <strong>diversa</strong> di password del dispositivo + password di recupero.",
  info2HTML: "Definisci la password del dispositivo e la password di recupero che vuoi associare al tuo wallet nascosto qui sotto. La password del dispositivo e la password di recupero devono essere <strong>diverse</strong> da quelle che hai definito per il tuo wallet principale.",
  passwordLabel: "Password di recupero nascosta",
  passwordPlaceholder: "Si prega di confermare la password di recupero nascosta",
  pinLabel: "Password nascosta del dispositivo",
  pinRepeatLabel: "Ripetere la password del dispositivo nascosto",
  pinRepeatPlaceholder: "Si prega di confermare la password del dispositivo nascosto",
  success: "Wallet nascosto creato con successo. Ricollega il tuo BitBox per sbloccarlo."
};
const initialize = {
  create: "Imposta la password del dispositivo",
  creating: "Impostazione della password del dispositivo...",
  error: {
    e102: "La password del dispositivo deve essere composta da almeno 4 caratteri."
  },
  info: {
    description1: "Scegli la password del tuo dispositivo. Questa sarà usata per sbloccare il tuo BitBox.",
    description2: "Puoi usare numeri, lettere e simboli. Password più lunghe offrono maggiore sicurezza.",
    description3: "Se perdi la password del dispositivo, dovrai resettare il tuo dispositivo e ripristinare il backup del wallet.",
    subtitle: "Ora imposterai la password del tuo dispositivo",
    title: "Inizializzazione del dispositivo"
  },
  input: {
    label: "Password del dispositivo",
    labelRepeat: "Ripetere la password del dispositivo",
    placeholderRepeat: "Si prega di confermare la password del dispositivo"
  }
};
const invalidFormat = "Formato non valido";
const language$1 = {
  title: "Seleziona lingua"
};
const legacyhiddenwallet = {
  disable: "Disattiva il wallet nascosto legacy",
  enable: "Abilita il wallet nascosto legacy",
  successDisable: "Wallet nascosto legacy disattivato con successo",
  successEnable: "Il wallet nascosto legacy è stato attivato con successo. Ricollega il tuo BitBox e inserisci la password del dispositivo nascosto per accedere al wallet nascosto legacy."
};
const loading = "caricamento...";
const manageAccounts = {
  accountHidden: "Questo account è stato nascosto dalla lista degli account watch-only. Per vederlo di nuovo, connetti il tuo BitBox02",
  editAccount: "Modifica",
  editAccountNameTitle: "Modifica il nome dell'account",
  noAccounts: "Nessun account trovato",
  settings: {
    hideTokens: "Nascondi token",
    showTokens: "Mostra token ({{activeTokenCount}})"
  },
  settingsButtonDescription: "Aggiungi e mostra/nascondi gli account",
  title: "Gestisci gli account",
  watchAccount: "Watch-only account",
  watchAccountDescription: "Questo account è stato aggiunto alla lista degli account watch-only. Disattiva per nasconderlo."
};
const mobile = {
  usingMobileDataWarning: "Utilizzo di dati mobili: dopo aver sbloccato un account questa app può scaricare fino a qualche centinaio di megabyte di dati dell'intestazione della blockchain. Si prega di connettersi al Wi-Fi per evitare di utilizzare i dati mobili. Dopo averlo chiuso, questo messaggio non verrà più visualizzato."
};
const newSettings = {
  about: {
    appVersion: {
      title: "Versione dell'app"
    }
  },
  advancedSettings: {
    authentication: {
      description: "Blocca l'accesso all'app con blocco schermo/impronta digitale.",
      title: "Blocco schermo"
    },
    coinControl: {
      description: "Seleziona quali UTXOs fanno parte di una transazione per aiutarti ad aumentare la tua privacy."
    },
    customFees: {
      description: "Ti permette di inserire una fee a tua discrezione all'invio."
    },
    torProxy: {
      description: "Connettiti tramite Tor per una migliore privacy."
    }
  },
  appearance: {
    activeCurrencies: {
      description: "Puoi ruotare tra queste valute aggiuntive dalla pagina del tuo account.",
      title: "Valute attive"
    },
    darkmode: {
      description: "Visualizza la BitBoxApp in modalità scura."
    },
    defaultCurrency: {
      description: "Selezione la valuta di default",
      title: "Valuta di default"
    },
    enableAccount: {
      description: "Disabilitare il tuo account significa che non comparirà nella barra laterale o nel portafoglio. Puoi sempre riattivarlo da qui. I fondi su questo conto non saranno modificati e rimarranno al sicuro.",
      title: "Abilita/disabilita account"
    },
    hideAmounts: {
      description: "Visualizza un'opzione per nascondere il tuo bilancio e gli importi per aumentare la tua privacy quando usi l'app in pubblico.",
      hideAmounts: "Nascondi importi",
      showAmounts: "Mostra importi",
      title: "Abilita importi nascosti"
    },
    language: {
      description: "In che lingua preferisci visualizzare la BitBoxApp.",
      title: "Lingua"
    },
    remebmerWallet: {
      name: "Ricorda wallet",
      warning: "Questo farà dimenticare il tuo wallet. Per vederlo di nuovo, dovrai collegare il relativo BitBox02. I fondi presenti sul wallet non saranno modificati. Vuoi continuare?",
      warningTitle: 'Disattiva "Ricorda wallet"'
    },
    toggleSats: {
      description: "Abilita o disabilita i Satoshi"
    }
  }
};
const note$1 = {
  input: {
    description: "(facoltativo)",
    placeholder: "Aggiungi nota..."
  },
  title: "Nota"
};
const notification = {
  newTxs_one: "Nuova transazione in: {{accountName}}",
  newTxs_other: "{{count}} nuove transazioni in: {{accountName}}"
};
const pairing = {
  aborted: {
    text: "L'abbinamento è stato interrotto dall'applicazione mobile.",
    title: "Interrotto"
  },
  button: "Abbina l'applicazione mobile",
  confirm: "Sei sicuro/a di voler abbinare il tuo BitBox? Si noti che in seguito, il telefono cellulare sarà necessario per eseguire transazioni.",
  connectOnly: {
    button: "Collegare l'applicazione mobile",
    title: "Esegui la scansione con la nostra applicazione mobile selezionando la voce di menu 'Connetti a nuova applicazione desktop'."
  },
  error: {
    text: "Qualcosa è andato storto. Per favore, ricomincia.",
    title: "Errore"
  },
  pullFailed: {
    text: "Impossibile estrarre un messaggio dal tuo cellulare attraverso il server relay. Il server potrebbe essere offline, contatta il supporto.",
    title: "Fallito"
  },
  reconnectOnly: {
    button: "Riconnetti applicazione mobile"
  },
  scanningFailed: {
    text: "Il cellulare non è stato in grado di scansionare il messaggio con successo. Si prega di riprovare.",
    title: "Scansione fallita"
  },
  start: {
    hideAppQRCode: "Nascondi il codice QR",
    revealAppQRCode: "Mostra il codice QR",
    step1: "Se non hai l'applicazione mobile, puoi scansionare il codice QR per l'App Store di Apple o il Play Store di Google, a seconda del telefono che usi.",
    step2: "Scansiona con la nostra applicazione mobile, che puoi trovare sotto il nome 'Digital Bitbox 2FA' negli app store per iOS e Android:"
  },
  started: {
    text: "Ora segui le istruzioni dell'applicazione mobile.",
    title: "Ottimo"
  },
  success: {
    text: "Congratulazioni, hai abbinato con successo il tuo BitBox con l'applicazione mobile",
    title: "Successo"
  },
  timeout: {
    text: "L'abbinamento è scaduto dopo due minuti. Ricomincia se vuoi ancora abbinare l'applicaione mobile.",
    title: "Timeout"
  },
  title: "Abbinamento telefono cellulare"
};
const passphrase = {
  considerations: {
    button: "Considerazioni sul backup\n",
    message: "La passphrase aggiunge un livello di protezione al backup del wallet (scheda microSD o parole di recupero). Se qualcuno ha accesso al tuo backup, avrà bisogno anche della passphrase per accedere al tuo wallet.\n\nTuttavia, questo significa che saranno necessari <strong>sia la passphrase che il backup del wallet</strong> per ripristinare il wallet con passphrase, nel caso in cui il BitBox02 venga perso o rotto. Se si dimentica o si perde la passphrase, si perde l'accesso a tutti i fondi del wallet.\n\nTi consigliamo di conservare la passphrase in un luogo separato rispetto al backup. In questo modo, se qualcuno trova il backup, non troverà anche la passphrase.",
    title: "Considerazioni sul backup"
  },
  disable: "Disabilita la passphrase",
  disableInfo: {
    button: "Disabilita",
    message: "Una volta disabilitata la passphrase, non verrà più richiesto di inserire una passphrase dopo aver sbloccato il BitBox02. Pertanto, si accederà al proprio wallet predefinito.\n\nTutte le valute presenti nel wallet con la passphrase saranno ancora presenti in quel wallet, ma non sarà possibile accedervi perché, dopo aver sbloccato il BitBox02, si aprirà il wallet predefinito.\n\nPer accedere nuovamente ai wallet con passphrase, è sufficiente riattivare la funzione passphrase e inserire la stessa dopo aver sbloccato il BitBox02.\n\n<strong>Suggerimento:</strong> È ancora possibile accedere al wallet originale lasciando la passphrase vuota."
  },
  enable: "Abilita la passphrase",
  error: {
    e104: "La modifica dell'impostazione della passphrase è stata interrotta."
  },
  how: {
    button: "Come si presenta",
    message: "Una passphrase non funziona come una password a cui si è abituati. Se si sbaglia a digitare la passphrase, non si riceve alcuna notifica. Questo perché <strong>ogni passphrase crea un wallet diverso, ma valido</strong>. Ciò significa che è possibile utilizzare diverse passphrase per tanti wallet quanti se ne desiderano. Ma si può accedere a ciascun wallet solo digitando la passphrase corrispondente.\n\nQuando si collega il BitBox02, viene richiesta la password del dispositivo come di consueto. Successivamente, verrà richiesto di inserire una passphrase sul dispositivo.\n\nDopo aver inserito la passphrase, ti verrà mostrata la passphrase inserita. In questo modo puoi confermare di averla inserita correttamente.",
    title: "Come funziona"
  },
  intro: {
    message: "Una passphrase fornisce un livello di sicurezza aggiuntivo al tuo wallet.\nScopriamo come funziona.",
    title: "Impostare la passphrase"
  },
  progressDisable: {
    message: "Confermare sul BitBox che si desidera <strong>disabilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  progressEnable: {
    message: "Confermare su BitBox che si desidera <strong>abilitare</strong> la passphrase opzionale.",
    title: "Conferma sul dispositivo"
  },
  successDisabled: {
    message: "Passphrase opzionale <strong>attivata con successo</strong>!\nD'ora in poi verrà richiesto di fornire una passphrase.",
    messageEnd: "Ricollegare ora il BitBox02.\n",
    title: "Passphrase abilitata"
  },
  successEnabled: {
    message: "Passphrase opzionale <strong>disabilitata con successo</strong>!\n\nNon verrà più richiesto di fornire una passphrase.",
    messageEnd: "Ricollegare ora il BitBox02.\n",
    tips: "Suggerimenti",
    tipsList: [
      "Si consiglia di inviare prima un piccolo importo al wallet con passphrase. Quindi scollegare e ricollegare il BitBox02 e inserire la password e la passphrase. Se la passphrase è stata inserita correttamente, si dovrebbero vedere i fondi nel wallet.",
      "Se si desidera accedere al wallet originale senza passphrase, è ancora possibile farlo non inserendo nulla quando viene richiesto di inserire la passphrase. Oppure puoi disattivare la funzione passphrase."
    ],
    title: "Passphrase disabilitata"
  },
  summary: {
    button: "Passphrase disabilitata",
    title: "Riepilogo",
    understand: "Ho capito come funziona la passphrase e i rischi ad essa associati.\n",
    understandList: [
      "La passphrase è un ulteriore livello di sicurezza oltre al backup.\n",
      "L'inserimento di una passphrase diversa genererà sempre un wallet diverso.",
      "Per ripristinare il wallet sono necessari <strong>sia la passphrase che il backup</strong>.",
      "Se si dimentica la passphrase, <strong>non è più possibile accedere ai propri fondi</strong>.\n"
    ]
  },
  what: {
    button: "Scopri come funziona",
    message: "Un wallet viene creato (derivato) da un numero casuale molto grande, noto anche come seed. Questo seed viene creato quando si configura per la prima volta il BitBox02 e viene salvato nella scheda microSD o in una lista di parole di recupero. Chiunque abbia accesso al seed ha il pieno controllo sui fondi di quel wallet.\n\nUna passphrase è un <strong>segreto opzionale</strong>, aggiunto al seed. Quando si usa una passphrase, ogni passphrase crea un nuovo wallet basato sul seed + passphrase (segreto opzionale). Una passphrase può essere qualsiasi cosa: lettere, parole, caratteri speciali o può anche essere vuota. Il wallet predefinito deriva infatti dal seed + passphrase vuota.\n\nLa passphrase fa parte dello standard BIP39, il che significa che è compatibile con tutti i wallet che supportano lo stesso standard.",
    title: "Cos'è una passphrase?"
  },
  why: {
    button: "Perchè usare una passphrase",
    message: `BitBox02 protegge il seed dall'estrazione dal dispositivo stesso, ma il backup (scheda microSD o parole di recupero) dà pieno accesso al wallet. Per questo motivo deve essere conservato in un luogo sicuro!

Poiché una passphrase crea un nuovo wallet utilizzando il seed esistente, il wallet con la passphrase richiede sia il <strong>backup che la passphrase per il ripristino</strong>. Il vantaggio è che se qualcuno trova il tuo backup, ha comunque bisogno della passphrase per accedere al wallet con passphrase.

Inoltre, la funzione passphrase consente di creare piùwallet sullo stesso dispositivo, o "wallet nascosti", oltre a quello predefinito.`,
    title: "Perchè usare una passphrase?"
  }
};
const password = {
  show: "Mostra {{label}}",
  warning: {
    caps: 'per incollare il testo, attivare "MOSTRA {{etichetta}}"',
    paste: 'per incollare il testo, attivare "MOSTRA {{label}}"'
  }
};
const random$1 = {
  button: "Genera un numero casuale",
  description: "Il tuo BitBox ha generato il seguente numero casuale {{bits}}-bit:"
};
const receive$2 = {
  bitsuranceWarning: "Questo è un account assicurato, e può ricevere transazioni solo su indirizzi di tipo Native Segwit. In questo modo non riceverai accidentalmente fondi su indirizzi di tipo Wrapped Segwit o Taproot, che non sono assicurati.",
  changeScriptType: "Cambia il tipo di indirizzo",
  label: "Il tuo indirizzo",
  onlyThisCoin: {
    description: "Per ricevere altri token, abilitali nelle impostazioni. Se depositi altri token, potrebbero non essere accessibili.",
    warning: "Assicurati di ricevere solo {{coinName}} su questo indirizzo."
  },
  scriptType: {
    p2tr: "Taproot (formato più recente)",
    p2wpkh: "Native Segwit (predefinito)",
    "p2wpkh-p2sh": "Wrapped Segwit (formato compatibile)"
  },
  selectAccount: "Scegli un account",
  showFull: "Mostra e verifica l'indirizzo completo sul dispositivo",
  taprootWarning: "Nota: Taproot è una nuova funzione di Bitcoin e non è ancora ampiamente adottata. I fondi ricevuti sugli indirizzi Taproot potrebbero non essere visibili nei wallet di terze parti. Molti wallet e exchange non sono ancora in grado di inviare ad indirizzi Taproot.",
  title: "Ricevi {{accountName}}",
  verify: "Verificare l'indirizzo in modo sicuro",
  verifyBitBox01: "Verificare l'indirizzo sull'applicazione mobile",
  verifyBitBox02: "Verificare l'indirizzo sul BitBox02",
  verifyInstruction: "Verifica che il seguente indirizzo corrisponda a quello visualizzato sul tuo dispositivo.",
  warning: {
    secureOutput: "Si prega di associare il tuo BitBox con il tuo dispositivo mobile per abilitare la verifica sicura dell'indirizzo. Vai su 'Gestisci dispositivo' nella barra laterale."
  }
};
const reset = {
  description: "Tutti i dati saranno cancellati dal dispositivo. Inclusa la tua chiave privata!",
  notReset: "Dispositivo NON resettato.",
  title: "Ripristino di fabbrica del dispositivo",
  understand: "Ho un backup e conosco la mia password di recupero",
  understandBB02: "Ho un backup valido"
};
const securityInformation = {
  create: {
    description1: "Ti consigliamo di impostare il tuo dispositivo in un ambiente sicuro, cioè lontano da altre persone che potrebbero vedere la password che hai scelto.",
    description2: "Ti verrà chiesto di creare due password.",
    description3: "La prima è la <strong>password del dispositivo</strong> che sblocca il tuo dispositivo BitBox e può essere cambiata in seguito.",
    description4: "La seconda è la <strong>password di recupero</strong> che sblocca il tuo wallet. Questa password non può essere cambiata in seguito.",
    description5: "Il wallet creato sarà salvato in un file sulla scheda microSD fornita. Questo può essere utilizzato in caso di emergenza per recuperare i tuoi fondi utilizzando la tua <strong>password di recupero</strong>.",
    title: "Informazioni di sicurezza"
  },
  restore: {
    description1: "Ti verrà chiesto di inserire la scheda microSD che hai usato per memorizzare il tuo backup.",
    description2: "Per ripristinare il tuo dispositivo avrai bisogno della tua password di recupero. ",
    description3: "Fai attenzione quando inserisci la password di recupero. Qualsiasi password inserita creerà un wallet valido. Se inserisci la password sbagliata, potrebbe esserti mostrato un saldo del wallet che non ti aspetti.",
    title: "Informazioni di sicurezza"
  }
};
const seed = {
  agreements: {
    "funds-access": "NON potrò accedere ai miei fondi se dimentico la mia password di recupero",
    "password-change": "NON posso cambiare la password di recupero in futuro.",
    "password-required": "La password di recupero è necessaria per ripristinare un wallet da un backup"
  },
  create: "Crea un wallet",
  creating: "Creazione del wallet",
  description: "Capisco che:",
  error: {
    e102: "La password deve essere composta da almeno 4 caratteri.",
    e200: "È necessario inserire una scheda microSD nel tuo BitBox per creare un wallet, così un backup può essere creato automaticamente."
  },
  info: {
    button: "Imposta ora la password di recupero\n",
    description1: "Inserire la scheda microSD nel BitBox",
    description2: 'Scegli una password di recupero per il wallet e seleziona "Imposta password di recupero ora".',
    description3: "Il backup su scheda microSD e la password di recupero sono l'unico metodo per recuperare i tuoi fondi in caso di perdita o furto del dispositivo BitBox.",
    description4: "Non è possibile cambiare la password di recupero in futuro senza dover trasferire i tuoi fondi.",
    title: "Crea un nuovo wallet"
  },
  password: {
    label: "Password di recupero",
    repeatPlaceholder: "Ripeti la password di recupero"
  },
  walletName: {
    label: "Nome del wallet"
  }
};
const seedRestore = {
  error: {
    e200: "Il ripristino di un wallet da un backup richiede la scheda microSD."
  },
  info: {
    description1: 'Inserire la scheda microSD nel BitBox e cliccare su "Continua".',
    description2: 'Scegliete un backup e cliccate su "Ripristina".',
    description3: "Inserisci la password di recupero",
    description4: "Confermo di aver capito che una password errata creerà un wallet diverso.",
    title: "Come ripristinare un wallet da un backup"
  }
};
const send$2 = {
  abort: "La transazione è stata annullata",
  address: {
    label: "Indirizzo del destinatario",
    placeholder: "Inserisci indirizzo"
  },
  amount: {
    label: "Importo",
    placeholder: "Inserisci importo"
  },
  availableBalance: "Saldo disponibile",
  button: "Controlla",
  coincontrol: {
    address: "Indirizzo",
    outpoint: "Outpoint",
    title: "Invia da un output"
  },
  confirm: {
    "selected-coins": "Seleziona valute",
    title: "Conferma ed invia transazione",
    total: "Totale"
  },
  error: {
    erc20InsufficientGasFunds: "Sembra che tu non abbia abbastanza Ether per pagare questa transazione ERC20. Per favore, assicurati di avere abbastanza Ether nel tuo wallet.",
    feeTooLow: "commissione troppo bassa",
    feesNotAvailable: "Impossibile stimare le commissioni\n",
    insufficientFunds: "fondi insufficienti.",
    invalidAddress: "indirizzo non valido",
    invalidAmount: "importo non valido",
    invalidData: "dati non validi"
  },
  fee: {
    customPlaceholder: "Inserisci importo",
    label: "Commissioni di rete",
    placeholder: "Non disponibile"
  },
  feeTarget: {
    customLabel: "Tariffa",
    customLabel_eth: "Gas",
    description: {
      economy: "4 ore (24 blocchi)",
      economy_eth: "30 minuti al massimo",
      economy_ltc: "1 ora (24 blocchi)",
      high: "20 minuti (2 blocchi)",
      high_eth: "30 secondi al massimo",
      high_ltc: "5 minuti (2 blocchi)",
      low: "2 ore (12 blocchi)",
      low_eth: "5 minuti al massimo",
      low_ltc: "30 minuti (12 blocchi)",
      normal: "6 blocchi (circa 1 ora per Bitcoin, 15 minuti per Litecoin)",
      normal_eth: "2 minuti al massimo",
      normal_ltc: "15 minuti (6 blocchi)"
    },
    estimate: "Tempo di conferma stimato:",
    label: {
      custom: "Personalizzata",
      economy: "Economica",
      high: "Alta",
      low: "Bassa",
      normal: "Normale"
    },
    placeholder: "Calcolo delle commissioni..."
  },
  maximum: "Invia tutto",
  maximumSelectedCoins: "Invia le valute selezionate\n",
  noFeeTargets: "La stima delle fee al momento non è disponibile. Inserisci una fee a tua discrezione o riprova più tardi.",
  priority: "Priorità",
  scanQR: "Leggi il QR code",
  signprogress: {
    description: "Questa è una transazione che contiene molti dati. Per firmare la transazione, ti verrà chiesto di confermare {{steps}} volte.",
    label: "Progresso"
  },
  success: "La transazione è stata firmata ed inviata.",
  title: "Invia {{accountName}}",
  toggleCoinControl: "Toggle coin control",
  transactionDetails: "Dettagli della transazione"
};
const settings$1 = {
  about: "About",
  accounts: "Accounts",
  advancedSettings: "Impostazioni avanzate",
  appearance: "Aspetto",
  electrum: {
    add: "Aggiungi un server",
    "add-server": "Aggiungi",
    check: "Verifica",
    checkFailed: "Fallito",
    checkSuccess: "Connessione stabilita con {{host}}",
    checking: "Verifico",
    "download-cert": "Scarica certificato remoto",
    "remove-server": "Rimuovi",
    removeConfirm: "Rimuovere {{server}}?",
    reset: "Ripristina le impostazioni predefinite",
    resetConfirm: "Vuoi rimuovere tutti i server e installare quelli di default?",
    servers: "Server",
    step1: "1",
    "step1-text": "Inserisci l'endpoint.",
    step2: "2",
    "step2-text": "Inserisci un certificato della catena dei certificati del server. In alternativa, scarica il certificato remoto e confrontalo visivamente.",
    "step2-text-tcp": "Puoi saltare questo passo se non vuoi usare TLS.",
    step3: "3",
    "step3-text": "Controlla la connessione e aggiungi il server.",
    step4: "4",
    "step4-text": "Riavvia il wallet. Se non rimuovi i server di default, il tuo nodo sarà aggiunto come ridondanza.",
    "title-btc": "Bitcoin Electrum servers",
    "title-ltc": "Litecoin Electrum servers",
    "title-tbtc": "Bitcoin Testnet Electrum servers",
    "title-tltc": "Litecoin Testnet Electrum servers"
  },
  expert: {
    coinControl: 'Abilita "coin control"',
    electrum: {
      description: "Puoi connetterti al tuo full node Electrum",
      title: "Connetti il tuo full node"
    },
    fee: "Abilitare commissioni personalizzate",
    setProxyAddress: "Imposta indirizzo proxy",
    title: "Impostazioni avanzate",
    useProxy: "Abilita il proxy per tor",
    useSats: "Mostra i valori BTC in Satoshi"
  },
  header: {
    home: "Home"
  },
  info: {
    "out-of-date": "Nuovo aggiornamento disponibile",
    title: "Informazioni",
    "up-to-date": "La tua app è aggiornata",
    version: "Versione App"
  },
  restart: "Si prega di riavviare la BitBoxApp affinché le modifiche abbiano effetto.",
  services: {
    title: "Servizi"
  },
  success: "Si prega di scollegare e ricollegare il BitBox affinché le modifiche abbiano effetto.",
  title: "Impostazioni"
};
const setup = "Imposta il dispositivo";
const sidebar$1 = {
  buy: "Acquista criptovalute",
  device: "Gestisci il dispositivo",
  insurance: "Assicura",
  leave: "Esci",
  settings: "Impostazioni"
};
const success$7 = {
  create: {
    info1: "Il tuo wallet è stato salvato in modo sicuro sulla scheda microSD. Rimuovila e tienila al sicuro.",
    info2: "Hai creato una password sicura del dispositivo che sblocca il BitBox.",
    info3: "Hai creato una password di recupero sicura per il tuo wallet che sblocca i tuoi fondi e ripristina i tuoi backup.",
    summary: "Ecco un riassunto di quello che hai fatto",
    title: "Successo"
  },
  getstarted: "Inizia",
  restore: {
    summary: "Hai ripristinato con successo un wallet dal tuo backup.",
    title: "Successo"
  }
};
const transaction$1 = {
  confirmation: "Conferme",
  details: {
    activity: "Attività",
    address: "Indirizzo",
    amount: "Importo",
    date: "Data",
    fiat: "Fiat",
    fiatAmount: "Importo fiat",
    fiatAtTime: "Fiat al tempo della transazione",
    status: "Status",
    title: "Dettagli della Transazione",
    type: "Tipo"
  },
  explorer: "ID della transazione",
  explorerTitle: "Apri in un esploratore di blocchi esterno",
  fee: "Commissione",
  fiatHistorical: "Storico",
  gas: "Gas",
  note: {
    edit: "Modifica nota",
    save: "Salva nota"
  },
  pending: "Transazione in sospeso",
  size: "Dimensione",
  status: {
    complete: "Completata",
    failed: "Fallita",
    pending: "In sospeso"
  },
  tx: {
    received: "Ricevuta a",
    sent: "Inviata a"
  },
  vsize: "Dimensione virtuale",
  weight: "Peso"
};
const transactions = {
  errorLoadTransactions: "Si è verificato un errore nel carimento delle transazioni",
  placeholder: "Nessuna transazione."
};
const unknownError = "Si è verificato un errore sconosciuto: {{errorMessage}}";
const unlock = {
  description: "Inserisci la password del tuo dispositivo per sbloccarlo.",
  error: {
    e109_normal: "Password del dispositivo errata. Restano ancora {{remainingAttempts}} tentativi prima che il dispositivo venga resettato.",
    e109_touch: "$t(unlock.error.e109_normal) Il prossimo login richiede di tenere premuto il pulsante touch.",
    e113: "A causa di molti tentativi di login, il login successivo richiede di tenere premuto il pulsante a sfioramento per 4 secondi."
  },
  input: {
    label: "Password del dispositivo",
    placeholder: "Inserisci la password del tuo dispositivo per sbloccare il dispositivo"
  },
  unlocking: "Sblocco..."
};
const upgradeFirmware$1 = {
  button: "Aggiorna il firmware",
  description: "Vuoi aggiornare il firmware dalla versione {{currentVersion}} alla {{newVersion}}?",
  label: "Il tuo BitBox richiede un aggiornamento del firmware.",
  locked: "Per aggiornare da {{currentVersion}} a {{newVersion}}, fai un tocco lungo.",
  title: "Aggiorna il firmware",
  unlocked: "Il bootloader è sbloccato. Per continuare, per favore:",
  unlocked1: "Scollega e ricollega il tuo Bitbox",
  unlocked2: "Il LED si accende quando il tuo BitBox è ricollegato",
  unlocked3: "Tocca il pulsante a sfioramento quando il LED si accende"
};
const walletConnect$2 = {
  connect: {
    button: "Conneti",
    dappLabel: "Inserire indirizzo URI della DApp",
    invalidPairingUri: "URI di connessione non valido"
  },
  dashboard: {
    allSessions: "Tutte le sessioni",
    disclaimer: "WalletConnect è un protocollo per connettersi a Dapp basate su Ethereum. Queste DApp sono gestite da servizi di terze parti, per cui connettiti solo a DApp di cui ti fidi e accertati di sapere sempre cosa stai firmando quando crei una transazione.",
    newConnection: "Nuova Connessione",
    noConnectedSessions: "Nessun account è connesso a DApp al momento."
  },
  invalidPairingChain: "Errore nell'approvazione della connessione. Assicurati di utilizare una delle chain supportate: {{chains}}",
  pairingRequest: {
    approve: "Approva Connessione",
    reject: "Rifiuta",
    title: "Nuova richista di connessione da"
  },
  pairingSuccess: "DApp connessa. Puoi continuare sul sito della DApp.",
  signingRequest: {
    account: "Account",
    chain: "Chain",
    dapp: "DApp",
    data: "Dati",
    dataParsingError: "Parse dei dati fallto.",
    decodeError: "Decodifica del messaggio fallita",
    method: {
      sendTransaction: "Firma ed invia transazione",
      signMessage: "Firma messaggio",
      signTransaction: "Firma transazione",
      signTypedData: "Firma typed data"
    },
    successfullySigned: "Richiesta firmata con successo",
    walletConnectRequest: "Richiesta WalletConnect"
  },
  useNewUri: "Questo URI è già stato utilizzato per provare a connettersi. Per favore, utilizzare un nuovo URI.",
  walletConnect: "WalletConnect"
};
const warning$6 = {
  receivePairing: `Si prega di associare il BitBox per abilitare la verifica sicura dell'indirizzo. Vai su "Gestisci dispositivo" nella barra laterale.`,
  sdcard: "Tenere la scheda microSD separata dal BitBox, a meno che non si vogliano gestire i backup.",
  sendPairing: "Si prega di abbinare il BitBox per verificare in modo sicuro i dettagli della transazione. Vai su 'Gestisci dispositivo' nella barra laterale."
};
const welcome = {
  connect: "Connetti BitBox02",
  getStarted: "Iniziamo con l'installazione del firmware sul BitBox02.",
  insertBitBox02: "Se hai collegato un BitBox02, tocca il dispositivo per continuare.",
  insertDevice: "Collega il tuo dispositivo per cominciare",
  title: "Benvenuto"
};
const appTranslationsIT = {
  account,
  accountInfo,
  accountSummary,
  addAccount: addAccount$1,
  aopp,
  app,
  auth: auth$1,
  backup,
  bb02Bootloader,
  bitbox,
  bitbox02Interact,
  bitbox02Settings,
  bitbox02Wizard,
  bitsurance,
  bitsuranceAccount,
  blink,
  bootloader,
  button: button$5,
  buy: buy$1,
  changePin,
  chart: chart$1,
  checkSDcard,
  clickHere,
  confirm: confirm$2,
  confirmOnDevice,
  connectKeystore: connectKeystore$1,
  darkmode: darkmode$1,
  device,
  deviceLock,
  deviceSettings,
  deviceTampered,
  dialog: dialog$1,
  error: error$2,
  fiat: fiat$2,
  footer: footer$2,
  generic: generic$1,
  genericError,
  goal,
  guide: guide$1,
  headerssync,
  hiddenWallet,
  initialize,
  invalidFormat,
  language: language$1,
  legacyhiddenwallet,
  loading,
  manageAccounts,
  mobile,
  newSettings,
  note: note$1,
  notification,
  pairing,
  passphrase,
  password,
  random: random$1,
  receive: receive$2,
  reset,
  securityInformation,
  seed,
  seedRestore,
  send: send$2,
  settings: settings$1,
  setup,
  sidebar: sidebar$1,
  success: success$7,
  transaction: transaction$1,
  transactions,
  unknownError,
  unlock,
  upgradeFirmware: upgradeFirmware$1,
  walletConnect: walletConnect$2,
  warning: warning$6,
  welcome
};
function i18nextFormat(locale) {
  return locale.replace("_", "-");
}
const localeMainLanguage = (locale) => {
  return i18nextFormat(locale).split("-")[0];
};
const getRegionNameFromLocale = (nativeLocale) => {
  try {
    const formattedLocale = i18nextFormat(nativeLocale);
    return new Intl.Locale(formattedLocale).region || "";
  } catch {
    return "";
  }
};
const defaultUserLanguage = "en";
const languageFromConfig = {
  type: "languageDetector",
  async: true,
  detect: (cb2) => {
    apiGet("config").then(({ backend }) => {
      if (backend && backend.userLanguage) {
        cb2(backend.userLanguage);
        return;
      }
      apiGet("native-locale").then((locale) => {
        if (typeof locale === "string" && locale) {
          try {
            (/* @__PURE__ */ new Date()).toLocaleString(i18nextFormat(locale));
          } catch (e3) {
            cb2(defaultUserLanguage);
            return;
          }
          cb2(i18nextFormat(locale));
          return;
        }
        cb2(defaultUserLanguage);
      });
    });
  },
  init: () => {
  },
  cacheUserLanguage: () => {
  }
};
let pendingConfig = {};
const getConfig = () => {
  return apiGet("config");
};
const setConfig = (object) => {
  return getConfig().then((currentConfig = {}) => {
    const nextConfig = Object.assign(currentConfig, {
      backend: Object.assign({}, currentConfig.backend, pendingConfig.backend, object.backend),
      frontend: Object.assign({}, currentConfig.frontend, pendingConfig.frontend, object.frontend)
    });
    pendingConfig = nextConfig;
    return apiPost("config", nextConfig).then(() => {
      pendingConfig = {};
      return nextConfig;
    });
  });
};
const locizeProjectID = "fe4e5a24-e4a2-4903-96fc-3d62c11fc502";
let i18Init = instance.use(languageFromConfig);
i18Init.init({
  fallbackLng: "en",
  // have a common namespace used around the full app
  ns: ["app", "wallet"],
  defaultNS: "app",
  debug: false,
  returnObjects: true,
  interpolation: {
    escapeValue: false
    // not needed for react
  },
  react: {
    useSuspense: true
    // Not using Suspense you will need to handle the not ready state yourself
  },
  backend: {
    projectId: locizeProjectID,
    referenceLng: "en"
  }
});
instance.addResourceBundle("ar", "app", appTranslationsAR);
instance.addResourceBundle("cs", "app", appTranslationsCS);
instance.addResourceBundle("de", "app", appTranslationsDE);
instance.addResourceBundle("en", "app", appTranslationsEN);
instance.addResourceBundle("fr", "app", appTranslationsFR);
instance.addResourceBundle("ja", "app", appTranslationsJA);
instance.addResourceBundle("ms", "app", appTranslationsMS);
instance.addResourceBundle("nl", "app", appTranslationsNL);
instance.addResourceBundle("ru", "app", appTranslationsRU);
instance.addResourceBundle("pt", "app", appTranslationsPT);
instance.addResourceBundle("hi", "app", appTranslationsHI);
instance.addResourceBundle("bg", "app", appTranslationsBG);
instance.addResourceBundle("tr", "app", appTranslationsTR);
instance.addResourceBundle("zh", "app", appTranslationsZH);
instance.addResourceBundle("fa", "app", appTranslationsFA);
instance.addResourceBundle("es", "app", appTranslationsES);
instance.addResourceBundle("sl", "app", appTranslationsSL);
instance.addResourceBundle("he", "app", appTranslationsHE);
instance.addResourceBundle("it", "app", appTranslationsIT);
instance.on("languageChanged", (lng) => {
  return getNativeLocale().then((nativeLocale) => {
    let match2 = lng === nativeLocale;
    if (!match2) {
      const lngLang = localeMainLanguage(lng);
      const localeLang = localeMainLanguage(nativeLocale);
      match2 = lngLang === localeLang;
    }
    const uiLang = match2 ? null : lng;
    return setConfig({ backend: { userLanguage: uiLang } });
  });
});
const captureStrongElement = /^(.*)<strong>(.*)<\/strong>(.*)$/;
function SimpleMarkup({ tagName, markup, ...props }) {
  if (typeof markup !== "string") {
    return null;
  }
  const simpleMarkupChunks = captureStrongElement.exec(markup);
  if (simpleMarkupChunks === null || simpleMarkupChunks.length !== 4) {
    return reactExports.createElement(tagName, props, markup);
  }
  return reactExports.createElement(tagName, props, simpleMarkupChunks[1], reactExports.createElement("strong", null, simpleMarkupChunks[2]), simpleMarkupChunks[3]);
}
const MultilineMarkup = ({ tagName, markup, withBreaks, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: markup.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName, markup: line2, ...props }),
    withBreaks && /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
  ] }, `${line2}-${i}`)) });
};
const DarkModeContext = reactExports.createContext({});
const useDarkmode = () => {
  const { isDarkMode, toggleDarkmode } = reactExports.useContext(DarkModeContext);
  return { isDarkMode, toggleDarkmode };
};
const alert = "" + new URL("alert-triangle.svg", import.meta.url).href;
const BB02StylizedDark = "" + new URL("bitbox02-stylized-reflection-dark.png", import.meta.url).href;
const BB02StylizedLight = "" + new URL("bitbox02-stylized-reflection-light.png", import.meta.url).href;
const info$4 = "" + new URL("info.svg", import.meta.url).href;
const arrowCircleLeftSVG = "" + new URL("arrow-circle-left.svg", import.meta.url).href;
const arrowCircleLeftActiveSVG = "" + new URL("arrow-circle-left-active.svg", import.meta.url).href;
const arrowCircleRightSVG = "" + new URL("arrow-circle-right.svg", import.meta.url).href;
const arrowCircleRightActiveSVG = "" + new URL("arrow-circle-right-active.svg", import.meta.url).href;
const bankDarkSVG = "" + new URL("bank.svg", import.meta.url).href;
const bankLightSVG = "" + new URL("bank-light.svg", import.meta.url).href;
const buyInfoSVG = "" + new URL("buy-info.svg", import.meta.url).href;
const checkedSmallSVG = "" + new URL("checked-small.svg", import.meta.url).href;
const checkSVG = "" + new URL("check.svg", import.meta.url).href;
const chevronRightDark = "" + new URL("chevron-right-dark.svg", import.meta.url).href;
const chevronLeftDark = "" + new URL("chevron-left-dark.svg", import.meta.url).href;
const cancelSVG = "" + new URL("cancel.svg", import.meta.url).href;
const creditCardDarkSVG = "" + new URL("credit-card.svg", import.meta.url).href;
const creditCardLightSVG = "" + new URL("credit-card-light.svg", import.meta.url).href;
const editSVG = "" + new URL("edit.svg", import.meta.url).href;
const editLightSVG = "" + new URL("edit-light.svg", import.meta.url).href;
const editActiveSVG = "" + new URL("edit-active.svg", import.meta.url).href;
const ETH = "" + new URL("eth-color.svg", import.meta.url).href;
const redDotSVG = "" + new URL("red-dot.svg", import.meta.url).href;
const greenDotSVG = "" + new URL("green-dot.svg", import.meta.url).href;
const yellowDotSVG = "" + new URL("yellow-dot.svg", import.meta.url).href;
const orangeDotSVG = "" + new URL("orange-dot.svg", import.meta.url).href;
const copySVG = "" + new URL("copy.svg", import.meta.url).href;
const shieldSVG = "" + new URL("shield.svg", import.meta.url).href;
const closeSVG = "" + new URL("close.svg", import.meta.url).href;
const closeXWhiteSVG = "" + new URL("close-x-white.svg", import.meta.url).href;
const closeXDarkSVG = "" + new URL("close-x-dark.svg", import.meta.url).href;
const externalLink = "" + new URL("external-link.svg", import.meta.url).href;
const eyeClosedSVG = "" + new URL("eye-closed.svg", import.meta.url).href;
const eyeOpenedSVG = "" + new URL("eye-opened.svg", import.meta.url).href;
const eyeOpenedDarkSVG = "" + new URL("eye-opened-dark.svg", import.meta.url).href;
const globeDarkSVG = "" + new URL("globe-dark.svg", import.meta.url).href;
const globeLightSVG = "" + new URL("globe-light.svg", import.meta.url).href;
const guideSVG = "" + new URL("guide.svg", import.meta.url).href;
const menuDarkSVG = "" + new URL("menu-dark.svg", import.meta.url).href;
const menuLightSVG = "" + new URL("menu-light.svg", import.meta.url).href;
const walletConnectDarkSVG = "" + new URL("wallet-connect-dark.svg", import.meta.url).href;
const walletConnectLightSVG = "" + new URL("wallet-connect-light.svg", import.meta.url).href;
const walletConnectDefaultSVG = "" + new URL("wallet-connect-default.svg", import.meta.url).href;
const warningPNG = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAACowAAAqMBZNxfiQAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAOMSURBVGiB7ZjPS5RBGMe/877vrluJmLqR4KEfICJ46CB0CNwOGS5sLf0FYq63grqWseipJOzaD6N7lyBSUohAgkDpkgcREiI96Wp00d33dZ4Ou67uvvP6zjvvLFvg97bzzjzP892Z+bwzL3CsY4USq1Xg3FCqnwx+v5iEnra+mp6rRZ6aGNgaSV3hnH8GYJaaHIN4omVq5ovuXIbugJRNWJz4cxwUDwAWN4wXlE1YuvNpN5BbO5UBodv1gNC9ud44rDuf1iW0PZhu3rPsFQBxjy4bphPpPP3m3W9dObXOgGMWRuFdPADEuWU/1JlT2wxsZJKdjNgSgIhP1wIx6om/nF7RkVfbDDDOJuBfPABEGbEn2vLqCFJi/sdAiblxvfX1+9mwuUPPAGUTFpl8MvA4k0/qwGpoA57Y9JMmrIZaQhLY9FNorIaagRISVYsHgDiP2A/C1KA8AyVsfgcQrX4WSyQR679V0bYz8xb5eeE+D4VV5U3EOJsAcxcPAIhEYcbPVva3PAm7j9W0Sh1KSyg3lOoHww3PDoW8q4lsd9sh3cwNpfpVaglsQAabZBfcjQVB2+ExilgNbGBzvXHYD5skKNZnBopY/XXydtB6AhnYHkw3M6Ix346CYkWmqsUYG98eTDcHqSmQAVlsCosVLSu3AmNV2sBGJtlJwB2ZvqI9INwXorGEuxuZZKdsXdIGSqdNMTarJaKQxBIqKdBpVcqALzarJPy3/TZxpaSx6mtA5bQppJD8DBT7S2LV14AMNl0SUUhyDxwMkMPqkQaksVmd27bdjYJ94ScZrB5pQPW06XppEYEcgSl/+WLV00AQbLrkOADn5Z/k2ACRUig/rHpukiNPmxJyVpeBSHE45XdVwwA+p1XhfUDlkl5reX0EcC0h1Ut6reWFVZcBJWyKxBjMM+0w4+0A0/D1xgOrFZE1XNKLQWMn0HRvHNaFLgCA82MZf56NgnZ3woQFBB8BKmZAwyUdABDrGygXDwDWxS7E+gbChgUEWC0bCIXNKrHGJqk2FVVjtWyghCplbB5WYWG+4sVFjo3CwryO0AAQZcDj/R8MqA02zY5zaLh8FSAg//UT9tZ/6gxfxiqjbNbIrS0uAnRJa4ba61trR28v+xdfWtJiuGZwttdW7zpURUCb0WCaswC26l2MgnIN+egcA4CtkWQP5+wRgPN1LkpODKsGx1jL1IelepdyrP9efwF60oqTW0b3mgAAAABJRU5ErkJggg==";
const warningOutlinedSVG = "" + new URL("warning-outlined.svg", import.meta.url).href;
const qrCodeDarkSVG = "" + new URL("qr-dark.svg", import.meta.url).href;
const qrCodeLightSVG = "" + new URL("qr-light.svg", import.meta.url).href;
const saveSVG = "" + new URL("save.svg", import.meta.url).href;
const saveLightSVG = "" + new URL("save-light.svg", import.meta.url).href;
const syncSVG = "" + new URL("sync.svg", import.meta.url).href;
const syncLightSVG = "" + new URL("sync-light.svg", import.meta.url).href;
const selectedCheckLightSVG = "" + new URL("selected-check-light.svg", import.meta.url).href;
const usbSuccessSVG = "" + new URL("usb-success.svg", import.meta.url).href;
const expandIcon = "_expandIcon_j17uw_1";
const style$16 = {
  expandIcon
};
const ExpandOpen = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$16.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "11", y1: "8", x2: "11", y2: "14" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
);
const ExpandClose = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: style$16.expandIcon,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "11", cy: "11", r: "8" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "21", y1: "21", x2: "16.65", y2: "16.65" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "8", y1: "11", x2: "14", y2: "11" })
    ]
  }
);
const AnimatedChecked = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsxs("svg", { className: `checked ${className || ""}`, viewBox: "0 0 52 52", ...props, children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { className: "checked-circle", cx: "26", cy: "26", r: "25", fill: "none" }),
  /* @__PURE__ */ jsxRuntimeExports.jsx("path", { className: "checked-check", fill: "none", d: "M14.1 27.2l7.1 7.2 16.7-16.8" })
] });
const CaretDown = ({ className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: `caretDown ${className || ""}`, viewBox: "0 0 1024 1024", ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z" }) });
const ExpandIcon = ({
  expand = true
}) => expand ? /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandOpen, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandClose, {});
const ArrowCirlceLeft = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftSVG, draggable: false, ...props });
const ArrowCirlceLeftActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleLeftActiveSVG, draggable: false, ...props });
const ArrowCirlceRight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightSVG, draggable: false, ...props });
const ArrowCirlceRightActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: arrowCircleRightActiveSVG, draggable: false, ...props });
const BankDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankDarkSVG, draggable: false, ...props });
const Bank = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: bankLightSVG, draggable: false, ...props });
const BitBox02StylizedDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedDark, draggable: false, ...props });
const BitBox02StylizedLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: BB02StylizedLight, draggable: false, ...props });
const BuyInfo$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: buyInfoSVG, draggable: false, ...props });
const Checked = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkedSmallSVG, draggable: false, ...props });
const Check$3 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: checkSVG, draggable: false, ...props });
const ChevronLeftDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronLeftDark, draggable: false, ...props });
const ChevronRightDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: chevronRightDark, draggable: false, ...props });
const Cancel = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: cancelSVG, draggable: false, ...props });
const CreditCardDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardDarkSVG, draggable: false, ...props });
const CreditCard = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: creditCardLightSVG, draggable: false, ...props });
const Copy = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: copySVG, draggable: false, ...props });
const Close = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeSVG, draggable: false, ...props });
const CloseXWhite = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXWhiteSVG, draggable: false, ...props });
const CloseXDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: closeXDarkSVG, draggable: false, ...props });
const Edit = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editSVG, draggable: false, ...props });
const EditLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editLightSVG, draggable: false, ...props });
const EditActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: editActiveSVG, draggable: false, ...props });
const ETHLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: ETH, draggable: false, ...props });
const ExternalLink = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: externalLink, draggable: false, ...props });
const EyeClosed = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeClosedSVG, draggable: false, ...props });
const EyeOpened = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedSVG, draggable: false, ...props });
const EyeOpenedDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: eyeOpenedDarkSVG, draggable: false, ...props });
const GlobeDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeDarkSVG, draggable: false, ...props });
const GlobeLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: globeLightSVG, draggable: false, ...props });
const GreenDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: greenDotSVG, draggable: false, ...props });
const GuideActive = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: guideSVG, draggable: false, ...props });
const Info$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: info$4, draggable: false, ...props });
const MenuDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuDarkSVG, draggable: false, ...props });
const MenuLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: menuLightSVG, draggable: false, ...props });
const OrangeDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: orangeDotSVG, draggable: false, ...props });
const WalletConnectDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDarkSVG, draggable: false, ...props });
const WalletConnectLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectLightSVG, draggable: false, ...props });
const WalletConnectDefaultLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: walletConnectDefaultSVG, draggable: false, ...props });
const QRCodeDark = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeDarkSVG, draggable: false, ...props });
const QRCodeLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: qrCodeLightSVG, draggable: false, ...props });
const RedDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: redDotSVG, draggable: false, ...props });
const Save = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveSVG, draggable: false, ...props });
const SaveLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: saveLightSVG, draggable: false, ...props });
const Shield = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: shieldSVG, draggable: false, ...props });
const Sync = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: syncSVG, draggable: false, ...props });
const SyncLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: syncLightSVG, draggable: false, ...props });
const SelectedCheckLight = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: selectedCheckLightSVG, draggable: false, ...props });
const Warning = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningPNG, draggable: false, ...props });
const WarningOutlined = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: warningOutlinedSVG, draggable: false, ...props });
const YellowDot = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: yellowDotSVG, draggable: false, ...props });
const USBSuccess = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: usbSuccessSVG, draggable: false, ...props });
const Alert$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: alert, draggable: false, ...props });
const AppLogoInvertedImg = "" + new URL("app-logo-inverted.svg", import.meta.url).href;
const AppLogoImg = "" + new URL("app-logo.svg", import.meta.url).href;
const BitBoxLogo = "" + new URL("bitbox-logo.svg", import.meta.url).href;
const BitBox02Logo = "" + new URL("bitbox02-logo.svg", import.meta.url).href;
const BitBox02InvertedLogo = "" + new URL("bitbox02inverted-logo.svg", import.meta.url).href;
const BTC = "" + new URL("btc-color.svg", import.meta.url).href;
const BTC_GREY = "" + new URL("btc-white.svg", import.meta.url).href;
const ETH_GREY = "" + new URL("eth-white.svg", import.meta.url).href;
const LTC = "" + new URL("ltc-color.svg", import.meta.url).href;
const LTC_GREY = "" + new URL("ltc-white.svg", import.meta.url).href;
const SwissOpenSourceLight = "" + new URL("swiss-made-open-source-light.svg", import.meta.url).href;
const SwissOpenSourceDark = "" + new URL("swiss-made-open-source-dark.svg", import.meta.url).href;
const BAT = "" + new URL("bat-color.svg", import.meta.url).href;
const BAT_GREY = "" + new URL("bat-white.svg", import.meta.url).href;
const DAI = "" + new URL("dai-color.svg", import.meta.url).href;
const DAI_GREY = "" + new URL("dai-white.svg", import.meta.url).href;
const LINK = "" + new URL("link-color.svg", import.meta.url).href;
const LINK_GREY = "" + new URL("link-white.svg", import.meta.url).href;
const MKR = "" + new URL("mkr-color.svg", import.meta.url).href;
const MKR_GREY = "" + new URL("mkr-white.svg", import.meta.url).href;
const USDC = "" + new URL("usdc-color.svg", import.meta.url).href;
const USDC_GREY = "" + new URL("usdc-white.svg", import.meta.url).href;
const USDT = "" + new URL("usdt-color.svg", import.meta.url).href;
const USDT_GREY = "" + new URL("usdt-white.svg", import.meta.url).href;
const ZRX = "" + new URL("zrx-color.svg", import.meta.url).href;
const ZRX_GREY = "" + new URL("zrx-white.svg", import.meta.url).href;
const WBTC = "" + new URL("wbtc-color.svg", import.meta.url).href;
const WBTC_GREY = "" + new URL("wbtc-white.svg", import.meta.url).href;
const PAXG = "" + new URL("paxg-color.svg", import.meta.url).href;
const PAXG_GREY = "" + new URL("paxg-white.svg", import.meta.url).href;
const logo$1 = "_logo_gbled_1";
const swissOpenSource = "_swissOpenSource_gbled_7";
const large$2 = "_large_gbled_12";
const style$15 = {
  logo: logo$1,
  swissOpenSource,
  large: large$2
};
const BitBox = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBoxLogo, alt: "BitBox", className: style$15.logo });
const BitBox02$1 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBox02Logo, alt: "BitBox02", className: style$15.logo });
const BitBox02Inverted = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: BitBox02InvertedLogo, alt: "BitBox02", className: style$15.logo });
const AppLogo = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: AppLogoImg, alt: "BitBox", className: style$15.logo });
const AppLogoInverted = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: AppLogoInvertedImg, alt: "BitBox", className: style$15.logo });
const SwissMadeOpenSource = ({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: SwissOpenSourceLight, alt: "Swiss Made Open Source", className: `${style$15.swissOpenSource} ${props.large ? style$15.large : ""} ${className ? className : ""}` });
const SwissMadeOpenSourceDark = ({ large: boolean, className, ...props }) => /* @__PURE__ */ jsxRuntimeExports.jsx("img", { ...props, draggable: false, src: SwissOpenSourceDark, alt: "Swiss Made Open Source", className: `${style$15.swissOpenSource} ${props.large ? style$15.large : ""} ${className ? className : ""}` });
const logoMap = {
  "btc": [BTC, BTC_GREY],
  "tbtc": [BTC, BTC_GREY],
  "rbtc": [BTC, BTC_GREY],
  "ltc": [LTC, LTC_GREY],
  "tltc": [LTC, LTC_GREY],
  "eth": [ETH, ETH_GREY],
  "goeth": [ETH, ETH_GREY],
  "sepeth": [ETH, ETH_GREY],
  "erc20Test": [ETH, ETH_GREY],
  "eth-erc20-usdt": [USDT, USDT_GREY],
  "eth-erc20-usdc": [USDC, USDC_GREY],
  "eth-erc20-dai0x6b17": [DAI, DAI_GREY],
  "eth-erc20-link": [LINK, LINK_GREY],
  "eth-erc20-bat": [BAT, BAT_GREY],
  "eth-erc20-mkr": [MKR, MKR_GREY],
  "eth-erc20-zrx": [ZRX, ZRX_GREY],
  "eth-erc20-wbtc": [WBTC, WBTC_GREY],
  "eth-erc20-paxg": [PAXG, PAXG_GREY]
};
function Logo({ coinCode, active: active2, stacked, ...rest }) {
  if (!logoMap[coinCode]) {
    console.error("logo undefined for ", coinCode);
    return null;
  }
  if (!stacked) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: active2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][1], ...rest }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: logoMap[coinCode][0], ...rest })
  ] }) });
}
const point2bitbox02 = "_point2bitbox02_1vb0x_1";
const caret$1 = "_caret_1vb0x_5";
const bitbox02 = "_bitbox02_1vb0x_10";
const style$14 = {
  point2bitbox02,
  caret: caret$1,
  bitbox02
};
const PointToBitBox02 = () => {
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$14.point2bitbox02, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CaretDown, { className: style$14.caret }),
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: style$14.bitbox02 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: style$14.bitbox02 })
  ] });
};
const overlay$3 = "_overlay_1u8gr_1";
const activeOverlay$1 = "_activeOverlay_1u8gr_15";
const modal$1 = "_modal_1u8gr_19";
const header$9 = "_header_1u8gr_31";
const title$b = "_title_1u8gr_31";
const contentContainer$1 = "_contentContainer_1u8gr_37";
const small$2 = "_small_1u8gr_42";
const medium$1 = "_medium_1u8gr_47";
const large$1 = "_large_1u8gr_53";
const centered$1 = "_centered_1u8gr_68";
const closeButton$3 = "_closeButton_1u8gr_78";
const slim$1 = "_slim_1u8gr_105";
const padded$1 = "_padded_1u8gr_109";
const content$5 = "_content_1u8gr_37";
const actions$1 = "_actions_1u8gr_117";
const confirmationLabel$1 = "_confirmationLabel_1u8gr_135";
const confirmationLabelNumber$1 = "_confirmationLabelNumber_1u8gr_144";
const disabledLabel$1 = "_disabledLabel_1u8gr_150";
const noStep$1 = "_noStep_1u8gr_155";
const confirmationInstructions$1 = "_confirmationInstructions_1u8gr_159";
const confirm$1 = "_confirm_1u8gr_135";
const image$1 = "_image_1u8gr_179";
const modalContent$1 = "_modalContent_1u8gr_184";
const detail$2 = "_detail_1u8gr_193";
const description$1 = "_description_1u8gr_217";
const buttons$4 = "_buttons_1u8gr_221";
const dialogButtons$1 = "_dialogButtons_1u8gr_233";
const closingOverlay = "_closingOverlay_1u8gr_244";
const open$1 = "_open_1u8gr_268";
const style$13 = {
  overlay: overlay$3,
  activeOverlay: activeOverlay$1,
  modal: modal$1,
  header: header$9,
  title: title$b,
  contentContainer: contentContainer$1,
  small: small$2,
  medium: medium$1,
  large: large$1,
  centered: centered$1,
  closeButton: closeButton$3,
  slim: slim$1,
  padded: padded$1,
  content: content$5,
  actions: actions$1,
  confirmationLabel: confirmationLabel$1,
  confirmationLabelNumber: confirmationLabelNumber$1,
  disabledLabel: disabledLabel$1,
  noStep: noStep$1,
  confirmationInstructions: confirmationInstructions$1,
  confirm: confirm$1,
  image: image$1,
  modalContent: modalContent$1,
  detail: detail$2,
  description: description$1,
  buttons: buttons$4,
  dialogButtons: dialogButtons$1,
  closingOverlay,
  open: open$1
};
class Dialog extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.modalContent = reactExports.createRef();
    this.state = {
      currentTab: 0,
      renderDialog: false
    };
    this.handleFocus = (e3) => {
      const input2 = e3.target;
      const index2 = input2.getAttribute("index");
      this.setState({ currentTab: Number(index2) });
    };
    this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables) {
          c2.classList.add("tabbable");
          c2.setAttribute("index", focusables.indexOf(c2).toString());
          c2.addEventListener("focus", this.handleFocus);
        }
        document.addEventListener("keydown", this.handleKeyDown);
      }
    };
    this.focusFirst = () => {
      const focusables = this.focusableChildren;
      if (focusables.length && focusables[0].getAttribute("autofocus") !== "false") {
        focusables[0].focus();
      }
    };
    this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    };
    this.deactivateModal = (fireOnCloseProp) => {
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      this.overlay.current.classList.remove(style$13.closingOverlay);
      this.setState({ currentTab: 0, renderDialog: false }, () => {
        document.removeEventListener("keydown", this.handleKeyDown);
        if (this.props.onClose && fireOnCloseProp) {
          this.props.onClose();
        }
      });
    };
    this.handleKeyDown = (e3) => {
      const { disableEscape } = this.props;
      const isEsc = e3.keyCode === 27;
      const isTab = e3.keyCode === 9;
      if (!disableEscape && isEsc) {
        this.deactivate(true);
      } else if (isTab) {
        e3.preventDefault();
      }
      if (isTab && e3.shiftKey) {
        this.updateIndex(false);
      } else if (isTab) {
        this.updateIndex(true);
      }
    };
    this.deactivate = (fireOnCloseProp) => {
      var _a;
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      if (this.timerId) {
        clearTimeout(this.timerId);
      }
      this.overlay.current.classList.remove(style$13.activeOverlay);
      this.overlay.current.classList.add(style$13.closingOverlay);
      (_a = this.modal.current) == null ? void 0 : _a.classList.remove(style$13.open);
      const onTransitionEnd = (event2) => {
        var _a2;
        if (event2.target === this.modal.current) {
          this.deactivateModal(fireOnCloseProp);
          (_a2 = this.modal.current) == null ? void 0 : _a2.removeEventListener("transitionend", onTransitionEnd);
        }
      };
      const hasTransition = parseFloat(window.getComputedStyle(this.modal.current).transitionDuration) > 0;
      if (hasTransition) {
        this.modal.current.addEventListener("transitionend", onTransitionEnd);
        this.timerId = setTimeout(() => this.deactivateModal(fireOnCloseProp), 400);
      } else {
        this.deactivateModal(fireOnCloseProp);
      }
    };
    this.activate = () => {
      this.setState({ renderDialog: true }, () => {
        if (!this.modal.current || !this.overlay.current) {
          return;
        }
        if (this.timerId) {
          clearTimeout(this.timerId);
        }
        this.overlay.current.classList.add(style$13.activeOverlay);
        this.timerId = setTimeout(() => {
          var _a;
          (_a = this.modal.current) == null ? void 0 : _a.classList.add(style$13.open);
        }, 10);
        this.focusWithin();
        this.focusFirst();
      });
    };
  }
  componentDidMount() {
    if (this.props.open) {
      this.activate();
    }
  }
  componentDidUpdate(prevProps) {
    const { open: open2 } = this.props;
    if (open2 && !prevProps.open) {
      this.activate();
      return;
    }
    if (!open2 && prevProps.open) {
      this.deactivate(false);
      return;
    }
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state;
    const focusables = Array.from(this.focusableChildren);
    const arr = isNext ? focusables : focusables.reverse();
    const current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled"));
    next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2;
    return isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props;
    const { renderDialog } = this.state;
    const isSmall = small2 ? style$13.small : "";
    const isMedium = medium2 ? style$13.medium : "";
    const isLarge = large2 ? style$13.large : "";
    const isSlim = slim2 ? style$13.slim : "";
    const isCentered = centered2 && !onClose ? style$13.centered : "";
    if (!renderDialog) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$13.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$13.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$13.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$13.closeButton, onClick: () => {
              this.deactivate(true);
            }, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$13.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
}
function DialogButtons$1({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.dialogButtons, children: children2 });
}
const defaultLanguages = [
  { code: "ar", display: "العربية" },
  { code: "bg", display: "България" },
  { code: "cs", display: "Čeština" },
  { code: "de", display: "Deutsch" },
  { code: "en", display: "English" },
  { code: "es", display: "Español" },
  { code: "fa", display: "فارسی" },
  { code: "fr", display: "Français" },
  { code: "he", display: "עברית" },
  { code: "hi", display: "हिन्दी " },
  { code: "it", display: "Italiano" },
  { code: "ja", display: "日本語" },
  { code: "ms", display: "Bahasa Melayu" },
  { code: "nl", display: "Nederlands" },
  { code: "pt", display: "Português" },
  { code: "ru", display: "Русский" },
  { code: "sl", display: "Slovenščina" },
  { code: "tr", display: "Türkçe" },
  { code: "zh", display: "中文" }
];
const link$5 = "_link_28asd_1";
const language = "_language_28asd_20";
const selected = "_selected_28asd_38";
const checked = "_checked_28asd_46";
const style$12 = {
  link: link$5,
  language,
  selected,
  checked
};
const getSelectedIndex = (languages, i18n) => {
  const lang = i18n.language;
  let index2 = languages.findIndex(({ code }) => code === lang);
  if (index2 === -1 && lang.indexOf("-") > 0) {
    const tag = lang.slice(0, lang.indexOf("-"));
    index2 = languages.findIndex(({ code }) => code === tag);
  }
  if (index2 === -1 && lang.indexOf("_") > 0) {
    const tag = lang.slice(0, lang.indexOf("_"));
    index2 = languages.findIndex(({ code }) => code === tag);
  }
  if (index2 === -1) {
    return languages.findIndex(({ code }) => code === "en") || 0;
  }
  return index2;
};
const LanguageSwitch = ({ languages }) => {
  const { t: t2, i18n } = useTranslation();
  const allLanguages = languages || defaultLanguages;
  const [selectedIndex, setSelectedIndex] = reactExports.useState(getSelectedIndex(allLanguages, i18n));
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const changeLanguage = (langCode, index2) => {
    setSelectedIndex(index2);
    setActiveDialog(false);
    i18n.changeLanguage(langCode);
  };
  if (allLanguages.length === 1) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "button",
      {
        type: "button",
        title: "Select Language",
        className: style$12.link,
        onClick: () => setActiveDialog(true),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "24",
              height: "24",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "2", y1: "12", x2: "22", y2: "12" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" })
              ]
            }
          ),
          allLanguages[selectedIndex].code === "en" ? "Other languages" : "English"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { small: true, slim: true, title: t2("language.title"), onClose: () => setActiveDialog(false), open: activeDialog, children: allLanguages.map((language2, i) => {
      const selected2 = selectedIndex === i;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "button",
        {
          type: "button",
          className: [style$12.language, selected2 ? style$12.selected : ""].join(" "),
          onClick: () => changeLanguage(language2.code, i),
          "data-testid": `language-selection-${language2.code}`,
          children: [
            language2.display,
            selected2 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "svg",
              {
                className: style$12.checked,
                xmlns: "http://www.w3.org/2000/svg",
                width: "24",
                height: "24",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "20 6 9 17 4 12" })
              }
            )
          ]
        },
        language2.code
      );
    }) })
  ] });
};
const getVersion$1 = () => {
  return apiGet("version");
};
const getUpdate = () => {
  return apiGet("update");
};
const Version = () => {
  const { t: t2 } = useTranslation();
  const version = useLoad(getVersion$1);
  if (!version) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
    t2("footer.appVersion"),
    " ",
    version
  ] });
};
const fullscreen = "_fullscreen_zy4hy_1";
const dialog = "_dialog_zy4hy_22";
const fill = "_fill_zy4hy_28";
const inner = "_inner_zy4hy_38";
const verticallyCentered = "_verticallyCentered_zy4hy_46";
const fit = "_fit_zy4hy_50";
const content$4 = "_content_zy4hy_50";
const textCenter = "_textCenter_zy4hy_64";
const header$8 = "_header_zy4hy_112";
const smallHeader = "_smallHeader_zy4hy_133";
const title$a = "_title_zy4hy_158";
const closeButton$2 = "_closeButton_zy4hy_172";
const fullWidth = "_fullWidth_zy4hy_200";
const largeIcon = "_largeIcon_zy4hy_218";
const buttons$3 = "_buttons_zy4hy_243";
const reverseRow = "_reverseRow_zy4hy_250";
const footer$1 = "_footer_zy4hy_310";
const style$11 = {
  fullscreen,
  dialog,
  fill,
  inner,
  verticallyCentered,
  fit,
  content: content$4,
  textCenter,
  "text-center": "_text-center_zy4hy_65",
  "text-left": "_text-left_zy4hy_68",
  header: header$8,
  smallHeader,
  title: title$a,
  closeButton: closeButton$2,
  fullWidth,
  largeIcon,
  buttons: buttons$3,
  reverseRow,
  footer: footer$1
};
const View = ({
  dialog: dialog2 = false,
  fitContent = false,
  fullscreen: fullscreen2,
  children: children2,
  minHeight,
  onClose,
  textCenter: textCenter2,
  verticallyCentered: verticallyCentered2 = false,
  width,
  withBottomBar
}) => {
  const { isDarkMode } = useDarkmode();
  const containerClasses = `${style$11[fullscreen2 ? "fullscreen" : "fill"]} ${verticallyCentered2 ? style$11.verticallyCentered : ""} ${dialog2 ? style$11.dialog : ""}`;
  let classNames2 = style$11.inner;
  if (fitContent) {
    classNames2 += ` ${style$11.fit}`;
  }
  if (textCenter2) {
    classNames2 += ` ${style$11.textCenter}`;
  }
  const inlineStyles = {
    ...minHeight && { minHeight },
    ...width && { width }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: containerClasses, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: classNames2,
        style: inlineStyles,
        children: children2
      }
    ),
    onClose && /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$11.closeButton, onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Close, {}) }),
    withBottomBar && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginTop: "auto" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: style$11.footer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
    ] }) })
  ] });
};
const ViewContent = ({
  children: children2,
  fullWidth: fullWidth2,
  minHeight,
  textAlign,
  withIcon,
  ...props
}) => {
  const align = textAlign ? style$11[`text-${textAlign}`] : "";
  const containerWidth = fullWidth2 ? style$11.fullWidth : "";
  const classes = `${style$11.content} ${containerWidth} ${align}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: classes,
      style: minHeight ? { minHeight } : {},
      ...props,
      children: [
        withIcon === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: style$11.largeIcon }),
        children2
      ]
    }
  );
};
const ViewHeader = ({
  children: children2,
  small: small2,
  title: title2,
  withAppLogo
}) => {
  const { isDarkMode } = useDarkmode();
  const headerStyles = small2 ? `${style$11.header} ${style$11.smallHeader}` : style$11.header;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: headerStyles, children: [
    withAppLogo && (isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {})),
    title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$11.title, children: title2 }),
    children2
  ] });
};
const ViewButtons = ({ reverseRow: reverseRow2, children: children2 }) => {
  const classNames2 = `${style$11.buttons} ${reverseRow2 ? style$11.reverseRow : ""}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
};
const button$4 = "_button_1s0sp_1";
const primary$1 = "_primary_1s0sp_38 _button_1s0sp_1";
const secondary = "_secondary_1s0sp_49 _button_1s0sp_1";
const danger$1 = "_danger_1s0sp_67 _button_1s0sp_1";
const transparent = "_transparent_1s0sp_84 _button_1s0sp_1";
const style$10 = {
  button: button$4,
  primary: primary$1,
  secondary,
  danger: danger$1,
  transparent
};
const ButtonLink = ({
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  disabled: disabled2,
  ...props
}) => {
  const classNames2 = [
    style$10[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  if (disabled2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: classNames2,
        disabled: true,
        children: children2
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Link,
    {
      className: classNames2,
      ...props,
      children: children2
    }
  );
};
const Button = ({
  type: type2 = "button",
  primary: primary2,
  secondary: secondary2,
  transparent: transparent2,
  danger: danger2,
  className = "",
  children: children2,
  ...props
}) => {
  const classNames2 = [
    style$10[primary2 && "primary" || secondary2 && "secondary" || transparent2 && "transparent" || danger2 && "danger" || "button"],
    className
  ].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      type: type2,
      className: classNames2,
      ...props,
      children: children2
    }
  );
};
const checkbox = "_checkbox_1m6k1_1";
const success$6 = "_success_1m6k1_33";
const warning$5 = "_warning_1m6k1_37";
const info$3 = "_info_1m6k1_41";
const styles$r = {
  checkbox,
  success: success$6,
  warning: warning$5,
  info: info$3
};
const Checkbox = ({
  disabled: disabled2 = false,
  label: label2,
  id: id2,
  className = "",
  children: children2,
  checkboxStyle = "default",
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${styles$r.checkbox} ${className} ${styles$r[checkboxStyle] || ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      " ",
      children2
    ] })
  ] });
};
const radio$1 = "_radio_198i3_1";
const style$$ = {
  radio: radio$1
};
function Radio({
  disabled: disabled2 = false,
  label: label2,
  id: id2,
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$$.radio, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "radio",
        id: id2,
        disabled: disabled2,
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, children: [
      label2,
      children2
    ] })
  ] });
}
const field = "_field_d2mb0_1";
const style$_ = {
  field
};
function Field({
  children: children2,
  ...props
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$_.field, ...props, children: children2 });
}
const input = "_input_1dgl0_1";
const isTransparent = "_isTransparent_1dgl0_58";
const errorText = "_errorText_1dgl0_64";
const styles$q = {
  input,
  "align-left": "_align-left_1dgl0_12",
  "align-right": "_align-right_1dgl0_16",
  isTransparent,
  errorText
};
const Input$2 = reactExports.forwardRef(function Input({
  id: id2,
  label: label2 = "",
  error: error3,
  align = "left",
  className = "",
  children: children2,
  transparent: transparent2 = false,
  type: type2 = "text",
  labelSection,
  ...props
}, ref) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    styles$q.input,
    styles$q[`align-${align}`],
    className,
    transparent2 ? styles$q.isTransparent : ""
  ].join(" "), children: [
    label2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { htmlFor: id2, className: error3 ? styles$q.errorText : "", children: [
        label2,
        error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          ":",
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: error3.toString() })
        ] }) : null
      ] }),
      labelSection && labelSection
    ] }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: false,
        type: type2,
        id: id2,
        ref,
        ...props
      }
    ),
    children2
  ] });
});
const label$6 = "_label_53nw1_1";
const style$Z = {
  label: label$6
};
function Label({
  className,
  children: children2,
  id: id2,
  // TODO: change to htmlFor when mirgated away from preact@8.x
  ...props
}) {
  const classes = [style$Z.label, className].join(" ");
  return /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, className: classes, ...props, children: children2 });
}
const select$5 = "_select_yd5xu_1";
const styles$p = {
  select: select$5
};
const Select$1 = ({
  id: id2,
  label: label2,
  options: options2 = [],
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$p.select, children: [
    label2 && /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: id2, children: label2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("select", { id: id2, ...props, children: options2.map(({ value, text: text2, disabled: disabled2 = false }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "option",
      {
        value,
        disabled: disabled2,
        children: text2
      },
      `${value}`
    )) })
  ] });
};
let alertUser;
let callback;
const Alert = () => {
  const [active2, setActive] = reactExports.useState(false);
  const [asDialog, setAsDialog] = reactExports.useState(true);
  const [message2, setMessage] = reactExports.useState();
  const { t: t2 } = useTranslation();
  alertUser = (message22, options2 = {}) => {
    const {
      asDialog: asDialog2 = true
    } = options2;
    callback = options2.callback;
    setActive(true);
    setAsDialog(asDialog2);
    setMessage(message22);
  };
  const handleClose = () => {
    if (callback) {
      callback();
    }
    setActive(false);
  };
  return active2 && message2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: () => setActive(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      dialog: asDialog,
      fullscreen: true,
      textCenter: !asDialog,
      verticallyCentered: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "span", markup: message2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: true,
            primary: true,
            onClick: handleClose,
            children: t2("button.ok")
          }
        ) })
      ]
    },
    "alert-overlay"
  ) }) : null;
};
var QWebChannelMessageTypes = {
  signal: 1,
  propertyUpdate: 2,
  init: 3,
  idle: 4,
  debug: 5,
  invokeMethod: 6,
  connectToSignal: 7,
  disconnectFromSignal: 8,
  setProperty: 9,
  response: 10
};
const QWebChannel = function(transport, initCallback) {
  if (typeof transport !== "object" || typeof transport.send !== "function") {
    console.error("The QWebChannel expects a transport object with a send function and onmessage callback property. Given is: transport: " + typeof transport + ", transport.send: " + typeof transport.send);
    return;
  }
  var channel = this;
  this.transport = transport;
  this.send = function(data) {
    if (typeof data !== "string") {
      data = JSON.stringify(data);
    }
    channel.transport.send(data);
  };
  this.transport.onmessage = function(message2) {
    var data = message2.data;
    if (typeof data === "string") {
      data = JSON.parse(data);
    }
    switch (data.type) {
      case QWebChannelMessageTypes.signal:
        channel.handleSignal(data);
        break;
      case QWebChannelMessageTypes.response:
        channel.handleResponse(data);
        break;
      case QWebChannelMessageTypes.propertyUpdate:
        channel.handlePropertyUpdate(data);
        break;
      default:
        console.error("invalid message received:", message2.data);
        break;
    }
  };
  this.execCallbacks = {};
  this.execId = 0;
  this.exec = function(data, callback2) {
    if (!callback2) {
      channel.send(data);
      return;
    }
    if (channel.execId === Number.MAX_VALUE) {
      channel.execId = Number.MIN_VALUE;
    }
    if (data.hasOwnProperty("id")) {
      console.error("Cannot exec message with property id: " + JSON.stringify(data));
      return;
    }
    data.id = channel.execId++;
    channel.execCallbacks[data.id] = callback2;
    channel.send(data);
  };
  this.objects = {};
  this.handleSignal = function(message2) {
    var object = channel.objects[message2.object];
    if (object) {
      object.signalEmitted(message2.signal, message2.args);
    } else {
      console.warn("Unhandled signal: " + message2.object + "::" + message2.signal);
    }
  };
  this.handleResponse = function(message2) {
    if (!message2.hasOwnProperty("id")) {
      console.error("Invalid response message received: ", JSON.stringify(message2));
      return;
    }
    channel.execCallbacks[message2.id](message2.data);
    delete channel.execCallbacks[message2.id];
  };
  this.handlePropertyUpdate = function(message2) {
    for (var i in message2.data) {
      var data = message2.data[i];
      var object = channel.objects[data.object];
      if (object) {
        object.propertyUpdate(data.signals, data.properties);
      } else {
        console.warn("Unhandled property update: " + data.object + "::" + data.signal);
      }
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  };
  this.debug = function(message2) {
    channel.send({ type: QWebChannelMessageTypes.debug, data: message2 });
  };
  channel.exec({ type: QWebChannelMessageTypes.init }, function(data) {
    for (var objectName in data) {
      new QObject(objectName, data[objectName], channel);
    }
    for (var objectName in channel.objects) {
      channel.objects[objectName].unwrapProperties();
    }
    if (initCallback) {
      initCallback(channel);
    }
    channel.exec({ type: QWebChannelMessageTypes.idle });
  });
};
function QObject(name, data, webChannel2) {
  this.__id__ = name;
  webChannel2.objects[name] = this;
  this.__objectSignals__ = {};
  this.__propertyCache__ = {};
  var object = this;
  this.unwrapQObject = function(response) {
    if (response instanceof Array) {
      var ret = new Array(response.length);
      for (var i = 0; i < response.length; ++i) {
        ret[i] = object.unwrapQObject(response[i]);
      }
      return ret;
    }
    if (!response || !response["__QObject*__"] || response.id === void 0) {
      return response;
    }
    var objectId = response.id;
    if (webChannel2.objects[objectId])
      return webChannel2.objects[objectId];
    if (!response.data) {
      console.error("Cannot unwrap unknown QObject " + objectId + " without data.");
      return;
    }
    var qObject = new QObject(objectId, response.data, webChannel2);
    qObject.destroyed.connect(function() {
      if (webChannel2.objects[objectId] === qObject) {
        delete webChannel2.objects[objectId];
        var propertyNames = [];
        for (var propertyName in qObject) {
          propertyNames.push(propertyName);
        }
        for (var idx in propertyNames) {
          delete qObject[propertyNames[idx]];
        }
      }
    });
    qObject.unwrapProperties();
    return qObject;
  };
  this.unwrapProperties = function() {
    for (var propertyIdx in object.__propertyCache__) {
      object.__propertyCache__[propertyIdx] = object.unwrapQObject(object.__propertyCache__[propertyIdx]);
    }
  };
  function addSignal(signalData, isPropertyNotifySignal) {
    var signalName = signalData[0];
    var signalIndex = signalData[1];
    object[signalName] = {
      connect: function(callback2) {
        if (typeof callback2 !== "function") {
          console.error("Bad callback given to connect to signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        object.__objectSignals__[signalIndex].push(callback2);
        if (!isPropertyNotifySignal && signalName !== "destroyed") {
          webChannel2.exec({
            type: QWebChannelMessageTypes.connectToSignal,
            object: object.__id__,
            signal: signalIndex
          });
        }
      },
      disconnect: function(callback2) {
        if (typeof callback2 !== "function") {
          console.error("Bad callback given to disconnect from signal " + signalName);
          return;
        }
        object.__objectSignals__[signalIndex] = object.__objectSignals__[signalIndex] || [];
        var idx = object.__objectSignals__[signalIndex].indexOf(callback2);
        if (idx === -1) {
          console.error("Cannot find connection of signal " + signalName + " to " + callback2.name);
          return;
        }
        object.__objectSignals__[signalIndex].splice(idx, 1);
        if (!isPropertyNotifySignal && object.__objectSignals__[signalIndex].length === 0) {
          webChannel2.exec({
            type: QWebChannelMessageTypes.disconnectFromSignal,
            object: object.__id__,
            signal: signalIndex
          });
        }
      }
    };
  }
  function invokeSignalCallbacks(signalName, signalArgs) {
    var connections = object.__objectSignals__[signalName];
    if (connections) {
      connections.forEach(function(callback2) {
        callback2.apply(callback2, signalArgs);
      });
    }
  }
  this.propertyUpdate = function(signals, propertyMap) {
    for (var propertyIndex in propertyMap) {
      var propertyValue = propertyMap[propertyIndex];
      object.__propertyCache__[propertyIndex] = propertyValue;
    }
    for (var signalName in signals) {
      invokeSignalCallbacks(signalName, signals[signalName]);
    }
  };
  this.signalEmitted = function(signalName, signalArgs) {
    invokeSignalCallbacks(signalName, this.unwrapQObject(signalArgs));
  };
  function addMethod(methodData) {
    var methodName = methodData[0];
    var methodIdx = methodData[1];
    object[methodName] = function() {
      var args = [];
      var callback2;
      for (var i = 0; i < arguments.length; ++i) {
        var argument = arguments[i];
        if (typeof argument === "function")
          callback2 = argument;
        else if (argument instanceof QObject && webChannel2.objects[argument.__id__] !== void 0)
          args.push({
            "id": argument.__id__
          });
        else
          args.push(argument);
      }
      webChannel2.exec({
        "type": QWebChannelMessageTypes.invokeMethod,
        "object": object.__id__,
        "method": methodIdx,
        "args": args
      }, function(response) {
        if (response !== void 0) {
          var result = object.unwrapQObject(response);
          if (callback2) {
            callback2(result);
          }
        }
      });
    };
  }
  function bindGetterSetter(propertyInfo) {
    var propertyIndex = propertyInfo[0];
    var propertyName = propertyInfo[1];
    var notifySignalData = propertyInfo[2];
    object.__propertyCache__[propertyIndex] = propertyInfo[3];
    if (notifySignalData) {
      if (notifySignalData[0] === 1) {
        notifySignalData[0] = propertyName + "Changed";
      }
      addSignal(notifySignalData, true);
    }
    Object.defineProperty(object, propertyName, {
      configurable: true,
      get: function() {
        var propertyValue = object.__propertyCache__[propertyIndex];
        if (propertyValue === void 0) {
          console.warn('Undefined value in property cache for property "' + propertyName + '" in object ' + object.__id__);
        }
        return propertyValue;
      },
      set: function(value) {
        if (value === void 0) {
          console.warn("Property setter for " + propertyName + " called with undefined value!");
          return;
        }
        object.__propertyCache__[propertyIndex] = value;
        var valueToSend = value;
        if (valueToSend instanceof QObject && webChannel2.objects[valueToSend.__id__] !== void 0)
          valueToSend = { "id": valueToSend.__id__ };
        webChannel2.exec({
          "type": QWebChannelMessageTypes.setProperty,
          "object": object.__id__,
          "property": propertyIndex,
          "value": valueToSend
        });
      }
    });
  }
  data.methods.forEach(addMethod);
  data.properties.forEach(bindGetterSetter);
  data.signals.forEach(function(signal) {
    addSignal(signal, false);
  });
  for (var name in data.enums) {
    object[name] = data.enums[name];
  }
}
const debug = false;
function runningInQtWebEngine() {
  return typeof window.qt !== "undefined";
}
function runningInAndroid() {
  return typeof window.android !== "undefined";
}
function runningOnMobile() {
  return runningInAndroid();
}
let webChannel = null;
let queryID$1 = 0;
const queryPromises$1 = {};
const currentListeners$2 = [];
async function initTransport() {
  if (!runningInQtWebEngine()) {
    throw new Error("Must be running in Qt");
  }
  if (webChannel) {
    return webChannel;
  }
  const initWebChannel = function(channel) {
    channel.objects.backend.gotResponse.connect((queryID2, response) => {
      queryPromises$1[queryID2].resolve(JSON.parse(response));
      delete queryPromises$1[queryID2];
    });
    channel.objects.backend.pushNotify.connect((msg) => {
      currentListeners$2.forEach((listener) => listener(JSON.parse(msg)));
    });
    webChannel = channel;
  };
  new QWebChannel(window.qt.webChannelTransport, initWebChannel);
  while (!webChannel) {
    await new Promise((r2) => setTimeout(r2, 1));
  }
  return webChannel;
}
function call(query) {
  return new Promise((resolve, reject2) => {
    initTransport().then((channel) => {
      queryID$1++;
      queryPromises$1[queryID$1] = { resolve, reject: reject2 };
      channel.objects.backend.call(queryID$1, query);
    });
  });
}
function qtSubscribePushNotifications(msgCallback) {
  currentListeners$2.push(msgCallback);
  return () => {
    if (!currentListeners$2.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners$2.indexOf(msgCallback);
    currentListeners$2.splice(index2, 1);
    if (currentListeners$2.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
let queryID = 0;
const queryPromises = {};
const currentListeners$1 = [];
function mobileCall(query) {
  return new Promise((resolve, reject2) => {
    if (runningOnMobile()) {
      if (typeof window.onMobileCallResponse === "undefined") {
        window.onMobileCallResponse = (queryID2, response) => {
          queryPromises[queryID2].resolve(response);
          delete queryPromises[queryID2];
        };
      }
      queryID++;
      queryPromises[queryID] = { resolve, reject: reject2 };
      window.android.call(queryID, query);
    } else {
      reject2();
    }
  });
}
function mobileSubscribePushNotifications(msgCallback) {
  if (typeof window.onMobilePushNotification === "undefined") {
    window.onMobilePushNotification = (msg) => {
      currentListeners$1.forEach((listener) => listener(msg));
    };
  }
  currentListeners$1.push(msgCallback);
  return () => {
    if (!currentListeners$1.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners$1.indexOf(msgCallback);
    currentListeners$1.splice(index2, 1);
    if (currentListeners$1.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
function extConfig(key, defaultValue) {
  if (key.startsWith("{{ ") && key.endsWith(" }}")) {
    return defaultValue;
  }
  return key;
}
const apiPort = extConfig("{{ API_PORT }}", "8082");
const apiToken = extConfig("{{ API_TOKEN }}", "");
function isTLS() {
  return document.URL.startsWith("https://");
}
function apiURL(endpoint) {
  return (isTLS() ? "https://" : "http://") + "localhost:" + apiPort + "/api/" + endpoint;
}
function handleError(endpoint) {
  return function(json) {
    return new Promise((resolve, reject2) => {
      if (json && json.error) {
        if (json.error.indexOf("hidapi: unknown failure") !== -1) {
          return;
        }
        console.error("error from endpoint", endpoint, json);
        alertUser(instance.t("genericError"));
        reject2(json.error);
        return;
      }
      resolve(json);
    });
  };
}
function apiGet(endpoint) {
  if (runningInQtWebEngine()) {
    return call(JSON.stringify({
      method: "GET",
      endpoint
    }));
  }
  if (runningOnMobile()) {
    return mobileCall(JSON.stringify({
      method: "GET",
      endpoint
    }));
  }
  return fetch(apiURL(endpoint), {
    method: "GET"
  }).then((response) => response.json()).then(handleError(endpoint));
}
function apiPost(endpoint, body) {
  if (runningInQtWebEngine()) {
    return call(JSON.stringify({
      method: "POST",
      endpoint,
      body: JSON.stringify(body)
    }));
  }
  if (runningOnMobile()) {
    return mobileCall(JSON.stringify({
      method: "POST",
      endpoint,
      body: JSON.stringify(body)
    }));
  }
  return fetch(apiURL(endpoint), {
    method: "POST",
    body: JSON.stringify(body)
  }).then((response) => response.json()).then(handleError(endpoint));
}
let socket;
const currentListeners = [];
function webSubscribePushNotifications(msgCallback) {
  currentListeners.push(msgCallback);
  if (!socket) {
    socket = new WebSocket((isTLS() ? "wss://" : "ws://") + "localhost:" + apiPort + "/api/events");
    socket.onopen = function() {
      if (socket) {
        socket.send("Authorization: Basic " + apiToken);
      }
    };
    socket.onerror = function(event2) {
      console.error("websocket error", event2);
    };
    socket.onmessage = function(event2) {
      const payload = JSON.parse(event2.data);
      currentListeners.forEach((listener) => listener(payload));
    };
    socket.onclose = function() {
      currentListeners.forEach((listener) => listener({ subject: "backend/connected", action: "replace", object: false }));
    };
  }
  return () => {
    if (!currentListeners.includes(msgCallback)) {
      console.warn("!currentListeners.includes(msgCallback)");
    }
    const index2 = currentListeners.indexOf(msgCallback);
    currentListeners.splice(index2, 1);
    if (currentListeners.includes(msgCallback)) {
      console.warn("currentListeners.includes(msgCallback)");
    }
  };
}
function apiWebsocket(msgCallback) {
  if (runningInQtWebEngine()) {
    return qtSubscribePushNotifications(msgCallback);
  }
  if (runningOnMobile()) {
    return mobileSubscribePushNotifications(msgCallback);
  }
  return webSubscribePushNotifications(msgCallback);
}
const subscriptions$1 = {};
function handleEvent(payload) {
  if ("subject" in payload && typeof payload.subject === "string") {
    if (subscriptions$1[payload.subject]) {
      for (const observer of subscriptions$1[payload.subject]) {
        observer(payload);
      }
    }
  }
}
let subscribed = null;
function apiSubscribe(subject, observer) {
  if (!subscribed) {
    subscribed = apiWebsocket(handleEvent);
  }
  let observers = subscriptions$1[subject];
  if (observers === void 0) {
    observers = [];
    subscriptions$1[subject] = observers;
  }
  observers.push(observer);
  return () => {
    if (!observers.includes(observer)) {
      console.warn("!observers.includes(observer)");
    }
    const index2 = observers.indexOf(observer);
    observers.splice(index2, 1);
    if (observers.includes(observer)) {
      console.warn("observers.includes(observer)");
    }
  };
}
function subscribeEndpoint(endpoint, cb2) {
  return apiSubscribe(endpoint, (event2) => {
    switch (event2.action) {
      case "replace":
        cb2(event2.object);
        break;
      case "reload":
        apiGet(event2.subject).then((object) => cb2(object)).catch(console.error);
        break;
      default:
        throw new Error(`Event: ${event2} not supported`);
    }
  });
}
const backendConnected = (cb2) => {
  return subscribeEndpoint("backend/connected", cb2);
};
const getSupportedCoins = () => {
  return apiGet("supported-coins");
};
const setAccountActive = (accountCode, active2) => {
  return apiPost("set-account-active", { accountCode, active: active2 });
};
const setTokenActive = (accountCode, tokenCode, active2) => {
  return apiPost("set-token-active", { accountCode, tokenCode, active: active2 });
};
const renameAccount = (accountCode, name) => {
  return apiPost("rename-account", { accountCode, name });
};
const reinitializeAccounts = () => {
  return apiPost("accounts/reinitialize");
};
const getTesting = () => {
  return apiGet("testing");
};
const getQRCode = (data) => {
  return () => {
    return apiGet(`qr?data=${encodeURIComponent(data)}`);
  };
};
const getDefaultConfig = () => {
  return apiGet("config/default");
};
const socksProxyCheck = (proxyAddress) => {
  return apiPost("socksproxy/check", proxyAddress);
};
const syncConnectKeystore = () => {
  return (cb2) => {
    return subscribeEndpoint("connect-keystore", (obj) => {
      cb2(obj);
    });
  };
};
const cancelConnectKeystore = () => {
  return apiPost("cancel-connect-keystore");
};
const setWatchonly = (rootFingerprint, watchonly) => {
  return apiPost("set-watchonly", { rootFingerprint, watchonly });
};
const authenticate = (force = false) => {
  return apiPost("authenticate", force);
};
const forceAuth = () => {
  return apiPost("force-auth");
};
const subscribeAuth = (cb2) => subscribeEndpoint("auth", cb2);
const onAuthSettingChanged = () => {
  return apiPost("on-auth-setting-changed");
};
const subscribeKeystores = (cb2) => {
  return subscribeEndpoint("keystores", cb2);
};
const getKeystores = () => {
  return apiGet("keystores");
};
const message$1 = "_message_ncb43_1";
const small$1 = "_small_ncb43_15";
const success$5 = "_success_ncb43_28 _message_ncb43_1";
const info$2 = "_info_ncb43_34 _message_ncb43_1";
const warning$4 = "_warning_ncb43_40 _message_ncb43_1";
const error$1 = "_error_ncb43_46 _message_ncb43_1";
const styles$o = {
  message: message$1,
  small: small$1,
  success: success$5,
  info: info$2,
  warning: warning$4,
  error: error$1
};
function Message({
  hidden,
  small: small2,
  type: type2 = "message",
  children: children2
}) {
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$o[type2]} ${small2 ? styles$o.small : ""}`, children: children2 });
}
const AppContext = reactExports.createContext({});
const children$1 = "_children_byj6x_1";
const container$o = "_container_byj6x_22";
const fixed = "_fixed_byj6x_26";
const disabled$2 = "_disabled_byj6x_34";
const forceHidden = "_forceHidden_byj6x_38";
const sidebarToggler = "_sidebarToggler_byj6x_38";
const guideIcon = "_guideIcon_byj6x_42";
const guideIconContainer = "_guideIconContainer_byj6x_57";
const header$7 = "_header_byj6x_62";
const narrow = "_narrow_byj6x_76";
const title$9 = "_title_byj6x_99";
const hideSidebarToggler = "_hideSidebarToggler_byj6x_125";
const style$Y = {
  children: children$1,
  container: container$o,
  fixed,
  disabled: disabled$2,
  forceHidden,
  sidebarToggler,
  guideIcon,
  guideIconContainer,
  header: header$7,
  narrow,
  title: title$9,
  hideSidebarToggler
};
const Header = ({
  narrow: narrow2,
  title: title2,
  hideSidebarToggler: hideSidebarToggler2,
  children: children2
}) => {
  const { t: t2 } = useTranslation();
  const { guideShown, guideExists, toggleGuide, toggleSidebar, sidebarStatus } = reactExports.useContext(AppContext);
  const toggle2 = (e3) => {
    e3.preventDefault();
    if (!guideShown) {
      toggleGuide();
    }
    return false;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$Y.container, sidebarStatus ? style$Y[sidebarStatus] : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$Y.header, narrow2 ? style$Y.narrow : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$Y.sidebarToggler} ${hideSidebarToggler2 ? style$Y.hideSidebarToggler : ""}`, onClick: toggleSidebar, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, { className: "show-in-lightmode" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MenuLight, { className: "show-in-darkmode" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$Y.title, children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Y.children, children: [
      children2,
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$Y.guideIconContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", onClick: toggle2, className: [style$Y.guideIcon, guideShown ? style$Y.disabled : ""].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GuideActive, {}),
        t2("guide.toggle.open")
      ] }) })
    ] })
  ] }) });
};
const main$1 = "_main_1ntet_1";
const style$X = {
  main: main$1
};
const Main = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: style$X.main, children: children2 });
};
const columnAsCard = "_columnAsCard_1rob5_1";
const column$2 = "_column_1rob5_1";
const columnButtons = "_columnButtons_1rob5_10";
const columnButtonsInline = "_columnButtonsInline_1rob5_10";
const left$1 = "_left_1rob5_29";
const center = "_center_1rob5_33";
const grid = "_grid_1rob5_47";
const style$W = {
  columnAsCard,
  column: column$2,
  columnButtons,
  columnButtonsInline,
  left: left$1,
  center,
  grid,
  "grid-columns-1": "_grid-columns-1_1rob5_53",
  "grid-columns-2": "_grid-columns-2_1rob5_56"
};
const Grid = ({
  children: children2,
  col = "2",
  textAlign
}) => {
  const styles2 = `
    ${style$W.grid}
    ${style$W[`grid-columns-${col}`]}
    ${textAlign !== void 0 ? style$W[textAlign] : ""}
  `;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("section", { className: styles2, children: children2 });
};
const Column = ({
  asCard,
  children: children2,
  className
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$W.column} ${asCard ? style$W.columnAsCard : ""} ${className || ""}`, children: children2 });
};
const ColumnButtons = ({
  children: children2,
  className = "",
  inline
}) => {
  const classNames2 = `${style$W.columnButtons} ${inline ? style$W.columnButtonsInline : ""} ${className}`;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: classNames2, children: children2 });
};
const footer = "_footer_19w3c_1";
const style$V = {
  footer
};
function Footer({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("footer", { className: [style$V.footer, "flex flex-row flex-items-center flex-end"].join(" "), children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-right-half hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Version, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {})
  ] });
}
const contentWithGuide = "_contentWithGuide_1gscs_1";
const container$n = "_container_1gscs_8";
const styles$n = {
  contentWithGuide,
  container: container$n
};
const GuideWrapper = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.contentWithGuide, children: children2 });
};
const GuidedContent = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$n.container, children: children2 });
};
const steps = "_steps_1l429_6";
const step = "_step_1l429_6";
const dot = "_dot_1l429_38";
const line$1 = "_line_1l429_72";
const finish = "_finish_1l429_76";
const wait = "_wait_1l429_81";
const process$1 = "_process_1l429_97";
const content$3 = "_content_1l429_110";
const style$U = {
  steps,
  step,
  dot,
  line: line$1,
  finish,
  wait,
  process: process$1,
  content: content$3
};
const Steps = ({
  current,
  children: children2
}) => {
  let childrens = React.Children.toArray(children2).filter(React.isValidElement);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.steps, children: childrens.filter((child) => !child.props.hidden).map((child, step2) => {
    if (!child) {
      return null;
    }
    const status2 = step2 === current ? "process" : step2 < current ? "finish" : "wait";
    const line2 = step2 > 0;
    return reactExports.cloneElement(child, {
      step: step2 + 1,
      line: line2,
      status: status2
    });
  }) });
};
function Step({
  children: children2,
  hidden = false,
  line: line2,
  status: status2 = "wait"
}) {
  if (hidden) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$U.step} ${style$U[status2]} ${line2 ? style$U.line : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.dot }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$U.content, children: children2 })
  ] });
}
const CoinDropDown = ({
  onChange: onChange2,
  supportedCoins,
  value
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select$1,
    {
      autoFocus: true,
      options: [
        {
          text: t2("buy.info.selectPlaceholder"),
          disabled: true,
          value: "choose"
        },
        ...supportedCoins.map(({ coinCode, name, canAddAccount }) => ({
          value: coinCode,
          text: name,
          disabled: !canAddAccount
        }))
      ],
      onInput: (e3) => onChange2(supportedCoins.find((c2) => {
        return c2.coinCode === e3.target.value;
      })),
      value,
      id: "coinCodeDropDown"
    }
  );
};
const notifyUser = (text2) => {
  return apiPost("notify-user", { text: text2 });
};
const open = (href) => {
  return apiPost("open", href);
};
const link$4 = "_link_1o1mh_1";
const style$T = {
  link: link$4
};
const A$3 = ({
  href,
  icon: icon2,
  className,
  children: children2,
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$T.link} ${className || ""}`,
      title: props.title || href,
      onClick: (e3) => {
        e3.preventDefault();
        open(href).catch(console.error);
      },
      tabIndex: 0,
      ...props,
      children: [
        icon2 ? icon2 : null,
        children2
      ]
    }
  );
};
const overlay$2 = "_overlay_14an4_1";
const close$2 = "_close_14an4_13";
const wrapper = "_wrapper_14an4_29";
const guide = "_guide_14an4_33";
const header$6 = "_header_14an4_44";
const content$2 = "_content_14an4_62";
const show$1 = "_show_14an4_83";
const entry$1 = "_entry_14an4_87";
const entryTitle = "_entryTitle_14an4_91";
const entryToggle = "_entryToggle_14an4_99";
const entryTitleText = "_entryTitleText_14an4_109";
const entryContent = "_entryContent_14an4_113";
const expanded = "_expanded_14an4_121";
const link$3 = "_link_14an4_125";
const guideWrapper = "_guideWrapper_14an4_135";
const style$S = {
  overlay: overlay$2,
  close: close$2,
  wrapper,
  guide,
  header: header$6,
  content: content$2,
  show: show$1,
  entry: entry$1,
  entryTitle,
  entryToggle,
  entryTitleText,
  entryContent,
  expanded,
  link: link$3,
  guideWrapper
};
const Entry = (props) => {
  const [shown, setShown] = reactExports.useState(props.shown || false);
  const toggle2 = () => {
    setShown((shown2) => !shown2);
  };
  const entry2 = props.entry;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entry, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entryTitle, onClick: toggle2, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.entryToggle, children: shown ? "–" : "+" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$S.entryTitleText, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: entry2.title }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.entryContent, shown ? style$S.expanded : ""].join(" "), children: shown ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      entry2.text.trim().split("\n").map((p2, idx) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: p2 }, idx)),
      entry2.link && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        A$3,
        {
          className: style$S.link,
          "data-testid": "link",
          href: entry2.link.url,
          children: entry2.link.text
        }
      ) }),
      props.children
    ] }) : null })
  ] });
};
const Guide = ({ children: children2 }) => {
  const { guideShown, toggleGuide, setGuideExists } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => {
    setGuideExists(true);
    return () => {
      setGuideExists(false);
    };
  }, [setGuideExists]);
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.wrapper, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$S.overlay, guideShown && style$S.show].join(" "), onClick: toggleGuide }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.guide, guideShown && style$S.show].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$S.header, "flex flex-row flex-between flex-items-center"].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("guide.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("a", { href: "#", className: style$S.close, onClick: toggleGuide, children: [
          t2("guide.toggle.close"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.content, children: [
        children2,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$S.entry, children: [
          t2("guide.appendix.text"),
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { className: style$S.link, href: "https://bitbox.swiss/support/", children: t2("guide.appendix.link") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {})
        ] })
      ] })
    ] })
  ] });
};
function findAccount(accounts, accountCode) {
  return accounts.find(({ code }) => accountCode === code);
}
function getCryptoName(cryptoLabel, account2) {
  if (account2 && isBitcoinOnly(account2.coinCode)) {
    return "Bitcoin";
  }
  return cryptoLabel;
}
function isBitcoinOnly(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return true;
    default:
      return false;
  }
}
const isBitcoinCoin = (coin) => coin === "BTC" || coin === "TBTC" || coin === "sat" || coin === "tsat";
function isBitcoinBased(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
    case "ltc":
    case "tltc":
      return true;
    default:
      return false;
  }
}
function isEthereumBased(coinCode) {
  return coinCode === "eth" || coinCode === "goeth" || coinCode === "sepeth" || coinCode.startsWith("eth-erc20-");
}
function getCoinCode(coinCode) {
  switch (coinCode) {
    case "btc":
    case "tbtc":
      return "btc";
    case "ltc":
    case "tltc":
      return "ltc";
    case "eth":
    case "goeth":
    case "sepeth":
      return "eth";
  }
}
function getScriptName(scriptType) {
  switch (scriptType) {
    case "p2pkh":
      return "Legacy (P2PKH)";
    case "p2wpkh-p2sh":
      return "Wrapped Segwit (P2WPKH-P2SH)";
    case "p2wpkh":
      return "Native segwit (bech32, P2WPKH)";
    case "p2tr":
      return "Taproot (bech32m, P2TR)";
  }
}
function customFeeUnit$1(coinCode) {
  if (isBitcoinBased(coinCode)) {
    return "sat/vB";
  }
  if (isEthereumBased(coinCode)) {
    return "Gwei";
  }
  return "";
}
function getAccountsByKeystore(accounts) {
  return Object.values(accounts.reduce((acc, account2) => {
    const key = account2.keystore.rootFingerprint;
    if (!acc[key]) {
      acc[key] = {
        keystore: account2.keystore,
        accounts: []
      };
    }
    acc[key].accounts.push(account2);
    return acc;
  }, {}));
}
function isAmbiguiousName(name, accounts) {
  return accounts.filter((keystore2) => keystore2.keystore.name === name).length > 1;
}
const getCoinsLink$1 = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/coins/";
    case "es":
      return "https://bitbox.swiss/es/monedas/";
    default:
      return "https://bitbox.swiss/coins/";
  }
};
const AddAccountGuide = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    !hasOnlyBTCAccounts && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.accounts.supportedCoins.link.text"),
          url: getCoinsLink$1()
        },
        text: t2("guide.accounts.supportedCoins.text"),
        title: t2("guide.accounts.supportedCoins.title")
      } }, "supportedCoins"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
};
let navigate;
const route = (route2, replace2) => {
  navigate == null ? void 0 : navigate(route2, { replace: replace2 });
};
const RouterWatcher = () => {
  navigate = useNavigate();
  const { setActiveSidebar } = reactExports.useContext(AppContext);
  const { pathname } = useLocation();
  reactExports.useEffect(() => {
    setActiveSidebar(false);
  }, [pathname, setActiveSidebar]);
  return null;
};
const getAccounts = () => {
  return apiGet("accounts");
};
const getAccountsBalance = () => {
  return apiGet("accounts/balance");
};
const getAccountsTotalBalance = () => {
  return apiGet("accounts/total-balance");
};
const getEthAccountCodeAndNameByAddress = (address2) => {
  return apiPost("accounts/eth-account-code", { address: address2 });
};
const getStatus$2 = (code) => {
  return apiGet(`account/${code}/status`);
};
const allScriptTypes = ["p2pkh", "p2wpkh-p2sh", "p2wpkh", "p2tr"];
const getInfo = (code) => {
  return () => {
    return apiGet(`account/${code}/info`);
  };
};
const init = (code) => {
  return apiPost(`account/${code}/init`);
};
const getSummary = () => {
  return apiGet("account-summary");
};
const getBalance = (code) => {
  return apiGet(`account/${code}/balance`);
};
const postNotesTx = (code, {
  internalTxID,
  note: note2
}) => {
  return apiPost(`account/${code}/notes/tx`, { internalTxID, note: note2 });
};
const proposeTxNote = (code, note2) => {
  return apiPost(`account/${code}/propose-tx-note`, note2);
};
const getTransactionList = (code) => {
  return apiGet(`account/${code}/transactions`);
};
const getTransaction = (code, id2) => {
  return apiGet(`account/${code}/transaction?id=${id2}`);
};
const exportAccount = (code) => {
  return apiPost(`account/${code}/export`);
};
const verifyXPub = (code, signingConfigIndex) => {
  return apiPost(`account/${code}/verify-extended-public-key`, { signingConfigIndex });
};
const getReceiveAddressList = (code) => {
  return () => {
    return apiGet(`account/${code}/receive-addresses`);
  };
};
const sendTx = (code) => {
  return apiPost(`account/${code}/sendtx`);
};
const getFeeTargetList = (code) => {
  return apiGet(`account/${code}/fee-targets`);
};
const verifyAddress$1 = (code, addressID) => {
  return apiPost(`account/${code}/verify-address`, addressID);
};
const getUTXOs = (code) => {
  return apiGet(`account/${code}/utxos`);
};
const hasSecureOutput = (code) => {
  return () => {
    return apiGet(`account/${code}/has-secure-output`);
  };
};
const addAccount = (coinCode, name) => {
  return apiPost("account-add", {
    coinCode,
    name
  });
};
const testRegister = (pin) => {
  return apiPost("test/register", { pin });
};
const connectKeystore = (code) => {
  return apiPost(`account/${code}/connect-keystore`);
};
const ethSignMessage = (code, message2) => {
  return apiPost(`account/${code}/eth-sign-msg`, message2);
};
const ethSignTypedMessage = (code, chainId, data) => {
  return apiPost(`account/${code}/eth-sign-typed-msg`, { chainId, data });
};
const ethSignWalletConnectTx = (code, send2, chainId, tx) => {
  return apiPost(`account/${code}/eth-sign-wallet-connect-tx`, { send: send2, chainId, tx });
};
const signAddress = (format, msg, code) => {
  return apiPost(`account/${code}/sign-address`, { format, msg, code });
};
const manageContainer = "_manageContainer_1n5md_1";
const title$8 = "_title_1n5md_9";
const successCheck = "_successCheck_1n5md_14";
const successMessage = "_successMessage_1n5md_20";
const styles$m = {
  manageContainer,
  title: title$8,
  successCheck,
  successMessage
};
const AddAccount = ({ accounts }) => {
  const [accountCode, setAccountCode] = reactExports.useState();
  const [accountName2, setAccountName] = reactExports.useState("");
  const [coinCode, setCoinCode] = reactExports.useState("choose");
  const [errorMessage2, setErrorMessage] = reactExports.useState();
  const [step2, setStep] = reactExports.useState("select-coin");
  const [supportedCoins, setSupportedCoins] = reactExports.useState([]);
  const [adding, setAdding] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    var _a;
    if (step2 === "choose-name") {
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    }
  }, [step2]);
  const onlyOneSupportedCoin = () => {
    return supportedCoins.length === 1;
  };
  const startProcess = reactExports.useCallback(async () => {
    var _a;
    try {
      const coins2 = await getSupportedCoins();
      const onlyOneCoinIsSupported = coins2.length === 1;
      setCoinCode(onlyOneCoinIsSupported ? coins2[0].coinCode : "choose");
      setStep(onlyOneCoinIsSupported ? "choose-name" : "select-coin");
      setSupportedCoins(coins2);
      if (onlyOneCoinIsSupported) {
        setAccountCode(coins2[0].suggestedAccountName);
      }
      (_a = inputRef.current) == null ? void 0 : _a.focus();
    } catch (err) {
      console.error(err);
    }
  }, []);
  reactExports.useEffect(() => {
    startProcess();
    const unsubscribe2 = subscribeKeystores(() => {
      startProcess();
    });
    return unsubscribe2;
  }, [startProcess]);
  const back = () => {
    switch (step2) {
      case "select-coin":
        route("/settings/manage-accounts");
        break;
      case "choose-name":
        setStep("select-coin");
        setErrorMessage(void 0);
        break;
      case "success":
        setStep("choose-name");
        break;
    }
  };
  const next2 = async (e3) => {
    e3.preventDefault();
    switch (step2) {
      case "select-coin":
        setStep("choose-name");
        break;
      case "choose-name":
        setAdding(true);
        const responseData = await addAccount(coinCode, accountName2);
        setAdding(false);
        if (responseData.success) {
          setAccountCode(responseData.accountCode);
          setErrorMessage(void 0);
          setStep("success");
        } else if (responseData.errorCode) {
          setErrorMessage(t2(`error.${responseData.errorCode}`));
        } else if (responseData.errorMessage) {
          setErrorMessage(t2("unknownError", { errorMessage: responseData.errorMessage }));
        }
        break;
      case "success":
        if (accountCode) {
          route(`/account/${accountCode}`);
        }
        break;
    }
  };
  const renderContent = () => {
    switch (step2) {
      case "select-coin":
        if (supportedCoins.length === 0) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("connectKeystore.promptNoName") });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CoinDropDown,
          {
            onChange: (coin) => {
              setCoinCode(coin.coinCode);
              setAccountName(coin.suggestedAccountName);
            },
            supportedCoins,
            value: coinCode
          }
        );
      case "choose-name":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            autoFocus: true,
            ref: inputRef,
            id: "accountName",
            onInput: (e3) => setAccountName(e3.target.value),
            value: accountName2
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { className: styles$m.successCheck }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            SimpleMarkup,
            {
              className: styles$m.successMessage,
              markup: t2("addAccount.success.message", { accountName: accountName2 }),
              tagName: "p"
            }
          )
        ] });
    }
  };
  const getTextFor = (step22) => {
    switch (step22) {
      case "select-coin":
        return {
          titleText: t2("addAccount.selectCoin.title"),
          nextButtonText: t2("addAccount.selectCoin.nextButton")
        };
      case "choose-name":
        return {
          titleText: t2("addAccount.chooseName.title"),
          nextButtonText: t2("addAccount.chooseName.nextButton")
        };
      case "success":
        return {
          titleText: t2("addAccount.success.title"),
          nextButtonText: t2("addAccount.success.nextButton")
        };
    }
  };
  const handleAddAnotherAccount = async () => {
    setAccountCode(void 0);
    setAccountName("");
    setCoinCode("choose");
    setErrorMessage(void 0);
    setStep("select-coin");
    await startProcess();
  };
  const currentStep = [
    ...!onlyOneSupportedCoin() ? ["select-coin"] : [],
    "choose-name",
    "success"
  ].indexOf(step2);
  const { titleText, nextButtonText } = getTextFor(step2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("manageAccounts.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content larger isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "form",
        {
          className: `${styles$m.manageContainer} box larger flex flex-column flex-between`,
          onSubmit: next2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
              t2("addAccount.title"),
              /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$m.title, children: titleText })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", hidden: !errorMessage2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: errorMessage2 }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: renderContent() }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "row", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Steps, { current: currentStep, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { hidden: onlyOneSupportedCoin(), children: t2("addAccount.selectCoin.step") }, "select-coin"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.chooseName.step") }, "choose-name"),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Step, { children: t2("addAccount.success.step") }, "success")
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row flex flex-row flex-between m-bottom", style: { flexDirection: "row-reverse" }, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: step2 === "select-coin" && coinCode === "choose" || step2 === "choose-name" && (accountName2 === "" || adding),
                  primary: true,
                  type: "submit",
                  children: nextButtonText
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: back,
                  hidden: step2 === "success",
                  secondary: true,
                  children: t2("button.back")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: handleAddAnotherAccount,
                  hidden: step2 !== "success",
                  secondary: true,
                  children: t2("addAccount.success.addAnotherAccount")
                }
              )
            ] })
          ]
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccountGuide, { accounts })
  ] });
};
const getExchangesByRegion = (code) => {
  return () => {
    return apiGet(`exchange/by-region/${code}`);
  };
};
const getExchangeDeals = () => {
  return apiGet("exchange/deals");
};
const getMoonpayBuyInfo = (code) => {
  return () => {
    return apiGet(`exchange/moonpay/buy-info/${code}`);
  };
};
const verifyAddress = (address2, accountCode) => {
  return apiPost("exchange/pocket/verify-address", { address: address2, accountCode });
};
const getPocketURL = () => {
  return apiGet("exchange/pocket/api-url");
};
const getExchangeBuySupported = (code) => {
  return () => {
    return apiGet(`exchange/buy-supported/${code}`);
  };
};
function BuyGuide({ name, exchange }) {
  const { t: t2 } = useTranslation();
  const pocketLink = {
    text: t2("buy.pocket.data.link"),
    url: "https://pocketbitcoin.com/policy/privacy"
  };
  const moonpayLink = {
    text: t2("buy.info.disclaimer.privacyPolicy"),
    url: "https://www.moonpay.com/privacy_policy"
  };
  const privacyLink = exchange === "pocket" ? pocketLink : moonpayLink;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("buy.info.disclaimer.security.link"),
        url: "https://bitbox.swiss/bitbox02/threat-model/"
      },
      text: t2("buy.info.disclaimer.security.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.security.title")
    }, shown: true }, "guide.buy.security"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: exchange ? privacyLink : void 0,
      text: t2("buy.info.disclaimer.protection.descriptionGeneric", { name }),
      title: t2("buy.info.disclaimer.protection.title")
    } }, "guide.buy.protection")
  ] });
}
const spinnerContainer$2 = "_spinnerContainer_rthjr_1";
const spinner$2 = "_spinner_rthjr_1";
const spinnerText = "_spinnerText_rthjr_24";
const spinner1 = "_spinner1_rthjr_1";
const spinner2 = "_spinner2_rthjr_1";
const spinner3 = "_spinner3_rthjr_1";
const horizontallyCentered = "_horizontallyCentered_rthjr_59";
const overlay$1 = "_overlay_rthjr_81";
const fadein = "_fadein_rthjr_1";
const togglersContainer = "_togglersContainer_rthjr_98";
const guideToggler = "_guideToggler_rthjr_111";
const toggler = "_toggler_rthjr_98";
const togglerContainer = "_togglerContainer_rthjr_145";
const style$R = {
  spinnerContainer: spinnerContainer$2,
  spinner: spinner$2,
  spinnerText,
  spinner1,
  spinner2,
  spinner3,
  horizontallyCentered,
  overlay: overlay$1,
  fadein,
  togglersContainer,
  guideToggler,
  toggler,
  togglerContainer
};
const SpinnerAnimation = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.spinner, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", {})
  ] });
};
const HorizontallyCenteredSpinner = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.horizontallyCentered, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) });
};
const Spinner = ({ text: text2, guideExists }) => {
  const { t: t2 } = useTranslation();
  const { toggleGuide, toggleSidebar } = reactExports.useContext(AppContext);
  const handleKeyDown = (e3) => {
    e3.preventDefault();
    document.activeElement.blur();
  };
  reactExports.useEffect(() => {
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.spinnerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.togglersContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.togglerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.toggler, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuDark, {}) }) }),
      guideExists && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$R.guideToggler, onClick: toggleGuide, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 24 24",
            fill: "none",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "10" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("circle", { cx: "12", cy: "12", r: "4" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "4.93", x2: "9.17", y2: "9.17" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "14.83", x2: "19.07", y2: "19.07" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "19.07", y2: "4.93" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "14.83", y1: "9.17", x2: "18.36", y2: "5.64" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "4.93", y1: "19.07", x2: "9.17", y2: "14.83" })
            ]
          }
        ),
        t2("guide.toggle.open")
      ] })
    ] }),
    text2 && text2.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$R.spinnerText, children: line2 }, `${line2}-${i}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$R.overlay })
  ] });
};
const disclaimerContainer = "_disclaimerContainer_5gxwf_1";
const title$7 = "_title_5gxwf_15";
const disclaimer = "_disclaimer_5gxwf_1";
const table$1 = "_table_5gxwf_52";
const nowrap = "_nowrap_5gxwf_77";
const style$Q = {
  disclaimerContainer,
  title: title$7,
  disclaimer,
  table: table$1,
  nowrap
};
const MoonpayTerms = ({ account: account2, onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipMoonpayDisclaimer: e3.target.checked } });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.title", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.0", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.intro.1", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.details", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$Q.table, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "50px" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.method") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.fee") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("buy.info.disclaimer.payment.table.description") })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$Q.nowrap, children: "1.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.1_description") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_method") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$Q.nowrap, children: "4.9 %" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("td", { children: t2("buy.info.disclaimer.payment.table.2_description") })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.payment.footnote") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.security.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.info.disclaimer.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.info.disclaimer.protection.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.info.disclaimer.protection.description", { name }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/privacy_policy", children: t2("buy.info.disclaimer.privacyPolicy") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const container$m = "_container_yg57j_1";
const iframe$1 = "_iframe_yg57j_12";
const header$5 = "_header_yg57j_18";
const style$P = {
  container: container$m,
  iframe: iframe$1,
  header: header$5
};
const Moonpay = ({ accounts, code }) => {
  const { t: t2 } = useTranslation();
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [height, setHeight] = reactExports.useState(0);
  const { isDarkMode } = useDarkmode();
  const config = useLoad(getConfig);
  const moonpay = useLoad(getMoonpayBuyInfo(code));
  const account2 = findAccount(accounts, code);
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const ref = reactExports.createRef();
  let resizeTimerID;
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipMoonpayDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    return () => window.removeEventListener("resize", onResize);
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  if (!account2 || !config) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$P.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$P.container, children: !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        MoonpayTerms,
        {
          account: account2,
          onAgreedTerms: () => setAgreedTerms(true)
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
        moonpay && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(true);
              onResize();
            },
            title: "Moonpay",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$P.iframe,
            allow: "camera; payment",
            src: `${moonpay.url}&colorCode=%235E94BF&theme=${isDarkMode ? "dark" : "light"}`
          }
        )
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "moonpay" })
  ] });
};
function findLowestFee(providers) {
  let allFees = [];
  providers.exchanges.forEach((provider) => {
    provider.deals.forEach((deal) => {
      if (provider.supported) {
        allFees = [...allFees, deal.fee];
      }
    });
  });
  return Math.min(...allFees);
}
function findBestDeal(providers, lowestFee) {
  const hasMultipleSupportedExchanges = providers.exchanges.filter((p2) => p2.supported).length > 1;
  const exchanges = providers.exchanges.map((exchange) => ({
    ...exchange,
    deals: exchange.deals.map((deal) => ({
      ...deal,
      isBestDeal: deal.fee === lowestFee && hasMultipleSupportedExchanges
    }))
  }));
  return { exchanges };
}
function getFormattedName(name) {
  switch (name) {
    case "moonpay":
      return "MoonPay";
    case "pocket":
      return "Pocket";
  }
}
async function getExchangeSupportedAccounts(accounts) {
  const accountsWithFalsyValue = await Promise.all(
    accounts.map(async (account2) => {
      const supported = await getExchangeBuySupported(account2.code)();
      return supported.exchanges.length ? account2 : false;
    })
  );
  return accountsWithFalsyValue.filter((result) => result);
}
const button$3 = "_button_10lad_1";
const styles$l = {
  button: button$3
};
const HideAmountsButton = () => {
  const { t: t2 } = useTranslation();
  const { hideAmounts, toggleHideAmounts } = reactExports.useContext(AppContext);
  const config = useLoad(getConfig);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: config && config.frontend.allowHideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$l.button, onClick: toggleHideAmounts, transparent: true, children: hideAmounts ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeClosed, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.showAmounts") })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpened, {}),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("newSettings.appearance.hideAmounts.hideAmounts") })
  ] }) }) : null });
};
function ownKeys(e3, r2) {
  var t2 = Object.keys(e3);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e3);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e3, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e3) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e3, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e3, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e3;
}
var _excluded$6 = ["defaultInputValue", "defaultMenuIsOpen", "defaultValue", "inputValue", "menuIsOpen", "onChange", "onInputChange", "onMenuClose", "onMenuOpen", "value"];
function useStateManager(_ref3) {
  var _ref$defaultInputValu = _ref3.defaultInputValue, defaultInputValue = _ref$defaultInputValu === void 0 ? "" : _ref$defaultInputValu, _ref$defaultMenuIsOpe = _ref3.defaultMenuIsOpen, defaultMenuIsOpen = _ref$defaultMenuIsOpe === void 0 ? false : _ref$defaultMenuIsOpe, _ref$defaultValue = _ref3.defaultValue, defaultValue = _ref$defaultValue === void 0 ? null : _ref$defaultValue, propsInputValue = _ref3.inputValue, propsMenuIsOpen = _ref3.menuIsOpen, propsOnChange = _ref3.onChange, propsOnInputChange = _ref3.onInputChange, propsOnMenuClose = _ref3.onMenuClose, propsOnMenuOpen = _ref3.onMenuOpen, propsValue = _ref3.value, restSelectProps = _objectWithoutProperties(_ref3, _excluded$6);
  var _useState = reactExports.useState(propsInputValue !== void 0 ? propsInputValue : defaultInputValue), _useState2 = _slicedToArray(_useState, 2), stateInputValue = _useState2[0], setStateInputValue = _useState2[1];
  var _useState3 = reactExports.useState(propsMenuIsOpen !== void 0 ? propsMenuIsOpen : defaultMenuIsOpen), _useState4 = _slicedToArray(_useState3, 2), stateMenuIsOpen = _useState4[0], setStateMenuIsOpen = _useState4[1];
  var _useState5 = reactExports.useState(propsValue !== void 0 ? propsValue : defaultValue), _useState6 = _slicedToArray(_useState5, 2), stateValue = _useState6[0], setStateValue = _useState6[1];
  var onChange2 = reactExports.useCallback(function(value2, actionMeta) {
    if (typeof propsOnChange === "function") {
      propsOnChange(value2, actionMeta);
    }
    setStateValue(value2);
  }, [propsOnChange]);
  var onInputChange = reactExports.useCallback(function(value2, actionMeta) {
    var newValue;
    if (typeof propsOnInputChange === "function") {
      newValue = propsOnInputChange(value2, actionMeta);
    }
    setStateInputValue(newValue !== void 0 ? newValue : value2);
  }, [propsOnInputChange]);
  var onMenuOpen = reactExports.useCallback(function() {
    if (typeof propsOnMenuOpen === "function") {
      propsOnMenuOpen();
    }
    setStateMenuIsOpen(true);
  }, [propsOnMenuOpen]);
  var onMenuClose = reactExports.useCallback(function() {
    if (typeof propsOnMenuClose === "function") {
      propsOnMenuClose();
    }
    setStateMenuIsOpen(false);
  }, [propsOnMenuClose]);
  var inputValue = propsInputValue !== void 0 ? propsInputValue : stateInputValue;
  var menuIsOpen = propsMenuIsOpen !== void 0 ? propsMenuIsOpen : stateMenuIsOpen;
  var value = propsValue !== void 0 ? propsValue : stateValue;
  return _objectSpread2(_objectSpread2({}, restSelectProps), {}, {
    inputValue,
    menuIsOpen,
    onChange: onChange2,
    onInputChange,
    onMenuClose,
    onMenuOpen,
    value
  });
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i = 0; i < document.styleSheets.length; i++) {
    if (document.styleSheets[i].ownerNode === tag) {
      return document.styleSheets[i];
    }
  }
}
function createStyleElement(options2) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options2.key);
  if (options2.nonce !== void 0) {
    tag.setAttribute("nonce", options2.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options2) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options2.speedy === void 0 ? true : options2.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options2.nonce;
    this.key = options2.key;
    this.container = options2.container;
    this.prepend = options2.prepend;
    this.insertionPoint = options2.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e3) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from$1 = String.fromCharCode;
var assign = Object.assign;
function hash$1(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback2) {
  return array.map(callback2).join("");
}
var line = 1;
var column$1 = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node$1(value, root2, parent, type2, props, children2, length2) {
  return { value, root: root2, parent, type: type2, props, children: children2, line, column: column$1, length: length2, return: "" };
}
function copy(root2, props) {
  return assign(node$1("", null, null, "", null, null, 0), root2, { length: -root2.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column$1--, character === 10)
    column$1 = 1, line--;
  return character;
}
function next$1() {
  character = position < length ? charat(characters, position++) : 0;
  if (column$1++, character === 10)
    column$1 = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end2) {
  return substr(characters, begin, end2);
}
function token$2(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column$1 = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice(position - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next$1();
    else
      break;
  return token$2(type2) > 2 || token$2(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next$1())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next$1() == 32));
}
function delimiter(type2) {
  while (next$1())
    switch (character) {
      case type2:
        return position;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next$1();
        break;
    }
  return position;
}
function commenter(type2, index2) {
  while (next$1())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from$1(type2 === 47 ? type2 : next$1());
}
function identifier(index2) {
  while (!token$2(peek()))
    next$1();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous2 = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children2 = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous2 = character2, character2 = next$1()) {
      case 40:
        if (previous2 != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous2);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next$1(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children2 = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root2, reference, reference, props, rulesets, length2, points, children2);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children2), rules, children2, length2, points, rule ? props : children2);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children2, 0, points, children2);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous2;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next$1());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous2 === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children2, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size2 = sizeof(rule);
  for (var i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size2; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root2, parent, offset === 0 ? RULESET : type2, props, children2, length2);
}
function comment(value, root2, parent) {
  return node$1(value, root2, parent, COMMENT, from$1(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node$1(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children2, callback2) {
  var output2 = "";
  var length2 = sizeof(children2);
  for (var i = 0; i < length2; i++)
    output2 += callback2(children2[i], i, children2, callback2) || "";
  return output2;
}
function stringify(element, index2, children2, callback2) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback2) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children2 = serialize(element.children, callback2)) ? element.return = element.value + "{" + children2 + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children2, callback2) {
    var output2 = "";
    for (var i = 0; i < length2; i++)
      output2 += collection[i](element, index2, children2, callback2) || "";
    return output2;
  };
}
function rulesheet(callback2) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback2(element);
    }
  };
}
function memoize(fn3) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0)
      cache[arg] = fn3(arg);
    return cache[arg];
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index2) {
  var previous2 = 0;
  var character2 = 0;
  while (true) {
    previous2 = character2;
    character2 = peek();
    if (previous2 === 38 && character2 === 12) {
      points[index2] = 1;
    }
    if (token$2(character2)) {
      break;
    }
    next$1();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index2 = -1;
  var character2 = 44;
  do {
    switch (token$2(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index2] = 1;
        }
        parsed[index2] += identifierWithPointTracking(position - 1, points, index2);
        break;
      case 2:
        parsed[index2] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index2] = peek() === 58 ? "&\f" : "";
          points[index2] = parsed[index2].length;
          break;
        }
      default:
        parsed[index2] += from$1(character2);
    }
  } while (character2 = next$1());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i = 0, k2 = 0; i < rules.length; i++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i] ? rules[i].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index2, children2, callback2) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback2);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback2);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback2);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options2) {
  var key = options2.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options2.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container2;
  var nodesToHydrate = [];
  {
    container2 = options2.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i = 1; i < attrib.length; i++) {
          inserted[attrib[i]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache.inserted[serialized.name] = true;
      }
    };
  }
  var cache = {
    key,
    sheet: new StyleSheet({
      key,
      container: container2,
      nonce: options2.nonce,
      speedy: options2.speedy,
      prepend: options2.prepend,
      insertionPoint: options2.insertionPoint
    }),
    nonce: options2.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache.sheet.hydrate(nodesToHydrate);
  return cache;
};
var reactIs$1 = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = "function" === typeof Symbol && Symbol.for, c$1 = b$1 ? Symbol.for("react.element") : 60103, d$1 = b$1 ? Symbol.for("react.portal") : 60106, e$2 = b$1 ? Symbol.for("react.fragment") : 60107, f$1 = b$1 ? Symbol.for("react.strict_mode") : 60108, g$1 = b$1 ? Symbol.for("react.profiler") : 60114, h$2 = b$1 ? Symbol.for("react.provider") : 60109, k$2 = b$1 ? Symbol.for("react.context") : 60110, l$1 = b$1 ? Symbol.for("react.async_mode") : 60111, m$2 = b$1 ? Symbol.for("react.concurrent_mode") : 60111, n = b$1 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$1 ? Symbol.for("react.suspense") : 60113, q$1 = b$1 ? Symbol.for("react.suspense_list") : 60120, r$1 = b$1 ? Symbol.for("react.memo") : 60115, t = b$1 ? Symbol.for("react.lazy") : 60116, v$1 = b$1 ? Symbol.for("react.block") : 60121, w$3 = b$1 ? Symbol.for("react.fundamental") : 60117, x$1 = b$1 ? Symbol.for("react.responder") : 60118, y$1 = b$1 ? Symbol.for("react.scope") : 60119;
function z$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l$1:
          case m$2:
          case e$2:
          case g$1:
          case f$1:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n:
              case t:
              case r$1:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$1:
        return u2;
    }
  }
}
function A$2(a2) {
  return z$1(a2) === m$2;
}
reactIs_production_min.AsyncMode = l$1;
reactIs_production_min.ConcurrentMode = m$2;
reactIs_production_min.ContextConsumer = k$2;
reactIs_production_min.ContextProvider = h$2;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e$2;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d$1;
reactIs_production_min.Profiler = g$1;
reactIs_production_min.StrictMode = f$1;
reactIs_production_min.Suspense = p$2;
reactIs_production_min.isAsyncMode = function(a2) {
  return A$2(a2) || z$1(a2) === l$1;
};
reactIs_production_min.isConcurrentMode = A$2;
reactIs_production_min.isContextConsumer = function(a2) {
  return z$1(a2) === k$2;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z$1(a2) === h$2;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z$1(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z$1(a2) === e$2;
};
reactIs_production_min.isLazy = function(a2) {
  return z$1(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z$1(a2) === r$1;
};
reactIs_production_min.isPortal = function(a2) {
  return z$1(a2) === d$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return z$1(a2) === g$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z$1(a2) === f$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return z$1(a2) === p$2;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$2 || a2 === g$1 || a2 === f$1 || a2 === p$2 || a2 === q$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r$1 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n || a2.$$typeof === w$3 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$1);
};
reactIs_production_min.typeOf = z$1;
{
  reactIs$1.exports = reactIs_production_min;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames2) {
  var rawClassName = "";
  classNames2.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache, serialized, isStringTag) {
  var className = cache.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache.registered[className] === void 0
  ) {
    cache.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache, serialized, isStringTag) {
  registerStyles(cache, serialized, isStringTag);
  var className = cache.key + "-" + serialized.name;
  if (cache.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache.insert(serialized === current ? "." + className : "", current, cache.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i = 0, len = str.length;
  for (; len >= 4; ++i, len -= 4) {
    k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string2 = "";
  if (Array.isArray(obj)) {
    for (var i = 0; i < obj.length; i++) {
      string2 += handleInterpolation(mergedProps, registered, obj[i]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string2 += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string2 += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i2 = 0; _i2 < value.length; _i2++) {
            if (isProcessableValue(value[_i2])) {
              string2 += processStyleName(_key) + ":" + processStyleValue(_key, value[_i2]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string2 += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string2 += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string2;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i = 1; i < args.length; i++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i]);
    if (stringMode) {
      styles2 += strings[i];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var hasOwnProperty = {}.hasOwnProperty;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache = reactExports.useContext(EmotionCacheContext);
    return func(props, cache, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__";
var createEmotionProps = function createEmotionProps2(type2, props) {
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key)) {
      newProps[key] = props[key];
    }
  }
  newProps[typePropName] = type2;
  return newProps;
};
var Insertion = function Insertion2(_ref3) {
  var cache = _ref3.cache, serialized = _ref3.serialized, isStringTag = _ref3.isStringTag;
  registerStyles(cache, serialized, isStringTag);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache, serialized, isStringTag);
  });
  return null;
};
var Emotion = /* @__PURE__ */ withEmotionCache(function(props, cache, ref) {
  var cssProp = props.css;
  if (typeof cssProp === "string" && cache.registered[cssProp] !== void 0) {
    cssProp = cache.registered[cssProp];
  }
  var WrappedComponent = props[typePropName];
  var registeredStyles = [cssProp];
  var className = "";
  if (typeof props.className === "string") {
    className = getRegisteredStyles(cache.registered, registeredStyles, props.className);
  } else if (props.className != null) {
    className = props.className + " ";
  }
  var serialized = serializeStyles(registeredStyles, void 0, reactExports.useContext(ThemeContext));
  className += cache.key + "-" + serialized.name;
  var newProps = {};
  for (var key in props) {
    if (hasOwnProperty.call(props, key) && key !== "css" && key !== typePropName && true) {
      newProps[key] = props[key];
    }
  }
  newProps.ref = ref;
  newProps.className = className;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
    cache,
    serialized,
    isStringTag: typeof WrappedComponent === "string"
  }), /* @__PURE__ */ reactExports.createElement(WrappedComponent, newProps));
});
var Emotion$1 = Emotion;
var jsx = function jsx2(type2, props) {
  var args = arguments;
  if (props == null || !hasOwnProperty.call(props, "css")) {
    return reactExports.createElement.apply(void 0, args);
  }
  var argsLength = args.length;
  var createElementArgArray = new Array(argsLength);
  createElementArgArray[0] = Emotion$1;
  createElementArgArray[1] = createEmotionProps(type2, props);
  for (var i = 2; i < argsLength; i++) {
    createElementArgArray[i] = args[i];
  }
  return reactExports.createElement.apply(null, createElementArgArray);
};
function css$2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css$2.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString2() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
function _taggedTemplateLiteral(strings, raw) {
  if (!raw) {
    raw = strings.slice(0);
  }
  return Object.freeze(Object.defineProperties(strings, {
    raw: {
      value: Object.freeze(raw)
    }
  }));
}
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null ? void 0 : (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref3;
  return (_ref3 = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref3.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list2, traverseIframes) {
  var _node$ownerDocument2;
  if (list2 === void 0) {
    list2 = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list2.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list2.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getCssDimensions(element) {
  const css4 = getComputedStyle$1(element);
  let width = parseFloat(css4.width) || 0;
  let height = parseFloat(css4.height) || 0;
  const hasOffset = isHTMLElement(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect.width) : rect.width) / width;
  let y2 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css4 = getComputedStyle$1(currentIFrame);
      const left2 = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css4.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css4.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left2;
      y2 += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root2 = getDocumentElement(element);
  function cleanup() {
    clearTimeout(timeoutId);
    io && io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left: left2,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root2.clientWidth - (left2 + width));
    const insetBottom = floor(root2.clientHeight - (top + height));
    const insetLeft = floor(left2);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options2 = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options2,
        // Handle <iframe>s
        root: root2.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options2);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options2;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref3) => {
      let [firstEntry] = _ref3;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          resizeObserver && resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo && cleanupIo();
    resizeObserver && resizeObserver.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var index$1 = reactExports.useLayoutEffect;
var _excluded$4 = ["className", "clearValue", "cx", "getStyles", "getClassNames", "getValue", "hasValue", "isMulti", "isRtl", "options", "selectOption", "selectProps", "setValue", "theme"];
var noop = function noop2() {
};
function applyPrefixToName(prefix2, name) {
  if (!name) {
    return prefix2;
  } else if (name[0] === "-") {
    return prefix2 + name;
  } else {
    return prefix2 + "__" + name;
  }
}
function classNames(prefix2, state) {
  for (var _len = arguments.length, classNameList = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    classNameList[_key - 2] = arguments[_key];
  }
  var arr = [].concat(classNameList);
  if (state && prefix2) {
    for (var key in state) {
      if (state.hasOwnProperty(key) && state[key]) {
        arr.push("".concat(applyPrefixToName(prefix2, key)));
      }
    }
  }
  return arr.filter(function(i) {
    return i;
  }).map(function(i) {
    return String(i).trim();
  }).join(" ");
}
var cleanValue = function cleanValue2(value) {
  if (isArray$1(value))
    return value.filter(Boolean);
  if (_typeof(value) === "object" && value !== null)
    return [value];
  return [];
};
var cleanCommonProps = function cleanCommonProps2(props) {
  props.className;
  props.clearValue;
  props.cx;
  props.getStyles;
  props.getClassNames;
  props.getValue;
  props.hasValue;
  props.isMulti;
  props.isRtl;
  props.options;
  props.selectOption;
  props.selectProps;
  props.setValue;
  props.theme;
  var innerProps = _objectWithoutProperties(props, _excluded$4);
  return _objectSpread2({}, innerProps);
};
var getStyleProps = function getStyleProps2(props, name, classNamesState) {
  var cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, className = props.className;
  return {
    css: getStyles(name, props),
    className: cx(classNamesState !== null && classNamesState !== void 0 ? classNamesState : {}, getClassNames(name, props), className)
  };
};
function isDocumentElement(el2) {
  return [document.documentElement, document.body, window].indexOf(el2) > -1;
}
function normalizedHeight(el2) {
  if (isDocumentElement(el2)) {
    return window.innerHeight;
  }
  return el2.clientHeight;
}
function getScrollTop(el2) {
  if (isDocumentElement(el2)) {
    return window.pageYOffset;
  }
  return el2.scrollTop;
}
function scrollTo(el2, top) {
  if (isDocumentElement(el2)) {
    window.scrollTo(0, top);
    return;
  }
  el2.scrollTop = top;
}
function getScrollParent(element) {
  var style2 = getComputedStyle(element);
  var excludeStaticParent = style2.position === "absolute";
  var overflowRx = /(auto|scroll)/;
  if (style2.position === "fixed")
    return document.documentElement;
  for (var parent = element; parent = parent.parentElement; ) {
    style2 = getComputedStyle(parent);
    if (excludeStaticParent && style2.position === "static") {
      continue;
    }
    if (overflowRx.test(style2.overflow + style2.overflowY + style2.overflowX)) {
      return parent;
    }
  }
  return document.documentElement;
}
function easeOutCubic(t2, b2, c2, d2) {
  return c2 * ((t2 = t2 / d2 - 1) * t2 * t2 + 1) + b2;
}
function animatedScrollTo(element, to) {
  var duration = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 200;
  var callback2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : noop;
  var start = getScrollTop(element);
  var change = to - start;
  var increment = 10;
  var currentTime = 0;
  function animateScroll() {
    currentTime += increment;
    var val = easeOutCubic(currentTime, start, change, duration);
    scrollTo(element, val);
    if (currentTime < duration) {
      window.requestAnimationFrame(animateScroll);
    } else {
      callback2(element);
    }
  }
  animateScroll();
}
function scrollIntoView(menuEl, focusedEl) {
  var menuRect = menuEl.getBoundingClientRect();
  var focusedRect = focusedEl.getBoundingClientRect();
  var overScroll = focusedEl.offsetHeight / 3;
  if (focusedRect.bottom + overScroll > menuRect.bottom) {
    scrollTo(menuEl, Math.min(focusedEl.offsetTop + focusedEl.clientHeight - menuEl.offsetHeight + overScroll, menuEl.scrollHeight));
  } else if (focusedRect.top - overScroll < menuRect.top) {
    scrollTo(menuEl, Math.max(focusedEl.offsetTop - overScroll, 0));
  }
}
function getBoundingClientObj(element) {
  var rect = element.getBoundingClientRect();
  return {
    bottom: rect.bottom,
    height: rect.height,
    left: rect.left,
    right: rect.right,
    top: rect.top,
    width: rect.width
  };
}
function isTouchCapable() {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (e3) {
    return false;
  }
}
function isMobileDevice() {
  try {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  } catch (e3) {
    return false;
  }
}
var passiveOptionAccessed = false;
var options = {
  get passive() {
    return passiveOptionAccessed = true;
  }
};
var w$2 = typeof window !== "undefined" ? window : {};
if (w$2.addEventListener && w$2.removeEventListener) {
  w$2.addEventListener("p", noop, options);
  w$2.removeEventListener("p", noop, false);
}
var supportsPassiveEvents = passiveOptionAccessed;
function notNullish(item2) {
  return item2 != null;
}
function isArray$1(arg) {
  return Array.isArray(arg);
}
function valueTernary(isMulti, multiValue, singleValue) {
  return isMulti ? multiValue : singleValue;
}
function singleValueAsValue(singleValue) {
  return singleValue;
}
function multiValueAsValue(multiValue) {
  return multiValue;
}
var removeProps = function removeProps2(propsObj) {
  for (var _len2 = arguments.length, properties = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    properties[_key2 - 1] = arguments[_key2];
  }
  var propsMap = Object.entries(propsObj).filter(function(_ref3) {
    var _ref22 = _slicedToArray(_ref3, 1), key = _ref22[0];
    return !properties.includes(key);
  });
  return propsMap.reduce(function(newProps, _ref3) {
    var _ref4 = _slicedToArray(_ref3, 2), key = _ref4[0], val = _ref4[1];
    newProps[key] = val;
    return newProps;
  }, {});
};
var _excluded$3 = ["children", "innerProps"], _excluded2$1 = ["children", "innerProps"];
function getMenuPlacement(_ref3) {
  var preferredMaxHeight = _ref3.maxHeight, menuEl = _ref3.menuEl, minHeight = _ref3.minHeight, preferredPlacement = _ref3.placement, shouldScroll = _ref3.shouldScroll, isFixedPosition = _ref3.isFixedPosition, controlHeight2 = _ref3.controlHeight;
  var scrollParent = getScrollParent(menuEl);
  var defaultState = {
    placement: "bottom",
    maxHeight: preferredMaxHeight
  };
  if (!menuEl || !menuEl.offsetParent)
    return defaultState;
  var _scrollParent$getBoun = scrollParent.getBoundingClientRect(), scrollHeight = _scrollParent$getBoun.height;
  var _menuEl$getBoundingCl = menuEl.getBoundingClientRect(), menuBottom = _menuEl$getBoundingCl.bottom, menuHeight = _menuEl$getBoundingCl.height, menuTop = _menuEl$getBoundingCl.top;
  var _menuEl$offsetParent$ = menuEl.offsetParent.getBoundingClientRect(), containerTop = _menuEl$offsetParent$.top;
  var viewHeight = isFixedPosition ? window.innerHeight : normalizedHeight(scrollParent);
  var scrollTop = getScrollTop(scrollParent);
  var marginBottom = parseInt(getComputedStyle(menuEl).marginBottom, 10);
  var marginTop = parseInt(getComputedStyle(menuEl).marginTop, 10);
  var viewSpaceAbove = containerTop - marginTop;
  var viewSpaceBelow = viewHeight - menuTop;
  var scrollSpaceAbove = viewSpaceAbove + scrollTop;
  var scrollSpaceBelow = scrollHeight - scrollTop - menuTop;
  var scrollDown = menuBottom - viewHeight + scrollTop + marginBottom;
  var scrollUp = scrollTop + menuTop - marginTop;
  var scrollDuration = 160;
  switch (preferredPlacement) {
    case "auto":
    case "bottom":
      if (viewSpaceBelow >= menuHeight) {
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceBelow >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceBelow >= minHeight || isFixedPosition && viewSpaceBelow >= minHeight) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollDown, scrollDuration);
        }
        var constrainedHeight = isFixedPosition ? viewSpaceBelow - marginBottom : scrollSpaceBelow - marginBottom;
        return {
          placement: "bottom",
          maxHeight: constrainedHeight
        };
      }
      if (preferredPlacement === "auto" || isFixedPosition) {
        var _constrainedHeight = preferredMaxHeight;
        var spaceAbove = isFixedPosition ? viewSpaceAbove : scrollSpaceAbove;
        if (spaceAbove >= minHeight) {
          _constrainedHeight = Math.min(spaceAbove - marginBottom - controlHeight2, preferredMaxHeight);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight
        };
      }
      if (preferredPlacement === "bottom") {
        if (shouldScroll) {
          scrollTo(scrollParent, scrollDown);
        }
        return {
          placement: "bottom",
          maxHeight: preferredMaxHeight
        };
      }
      break;
    case "top":
      if (viewSpaceAbove >= menuHeight) {
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (scrollSpaceAbove >= menuHeight && !isFixedPosition) {
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: preferredMaxHeight
        };
      }
      if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
        var _constrainedHeight2 = preferredMaxHeight;
        if (!isFixedPosition && scrollSpaceAbove >= minHeight || isFixedPosition && viewSpaceAbove >= minHeight) {
          _constrainedHeight2 = isFixedPosition ? viewSpaceAbove - marginTop : scrollSpaceAbove - marginTop;
        }
        if (shouldScroll) {
          animatedScrollTo(scrollParent, scrollUp, scrollDuration);
        }
        return {
          placement: "top",
          maxHeight: _constrainedHeight2
        };
      }
      return {
        placement: "bottom",
        maxHeight: preferredMaxHeight
      };
    default:
      throw new Error('Invalid placement provided "'.concat(preferredPlacement, '".'));
  }
  return defaultState;
}
function alignToControl(placement) {
  var placementToCSSProp = {
    bottom: "top",
    top: "bottom"
  };
  return placement ? placementToCSSProp[placement] : "bottom";
}
var coercePlacement = function coercePlacement2(p2) {
  return p2 === "auto" ? "bottom" : p2;
};
var menuCSS = function menuCSS2(_ref22, unstyled) {
  var _objectSpread2$1;
  var placement = _ref22.placement, _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, spacing2 = _ref2$theme.spacing, colors2 = _ref2$theme.colors;
  return _objectSpread2((_objectSpread2$1 = {
    label: "menu"
  }, _defineProperty(_objectSpread2$1, alignToControl(placement), "100%"), _defineProperty(_objectSpread2$1, "position", "absolute"), _defineProperty(_objectSpread2$1, "width", "100%"), _defineProperty(_objectSpread2$1, "zIndex", 1), _objectSpread2$1), unstyled ? {} : {
    backgroundColor: colors2.neutral0,
    borderRadius: borderRadius2,
    boxShadow: "0 0 0 1px hsla(0, 0%, 0%, 0.1), 0 4px 11px hsla(0, 0%, 0%, 0.1)",
    marginBottom: spacing2.menuGutter,
    marginTop: spacing2.menuGutter
  });
};
var PortalPlacementContext = /* @__PURE__ */ reactExports.createContext(null);
var MenuPlacer = function MenuPlacer2(props) {
  var children2 = props.children, minMenuHeight = props.minMenuHeight, maxMenuHeight = props.maxMenuHeight, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition, menuShouldScrollIntoView = props.menuShouldScrollIntoView, theme = props.theme;
  var _ref3 = reactExports.useContext(PortalPlacementContext) || {}, setPortalPlacement = _ref3.setPortalPlacement;
  var ref = reactExports.useRef(null);
  var _useState = reactExports.useState(maxMenuHeight), _useState2 = _slicedToArray(_useState, 2), maxHeight = _useState2[0], setMaxHeight = _useState2[1];
  var _useState3 = reactExports.useState(null), _useState4 = _slicedToArray(_useState3, 2), placement = _useState4[0], setPlacement = _useState4[1];
  var controlHeight2 = theme.spacing.controlHeight;
  index$1(function() {
    var menuEl = ref.current;
    if (!menuEl)
      return;
    var isFixedPosition = menuPosition === "fixed";
    var shouldScroll = menuShouldScrollIntoView && !isFixedPosition;
    var state = getMenuPlacement({
      maxHeight: maxMenuHeight,
      menuEl,
      minHeight: minMenuHeight,
      placement: menuPlacement,
      shouldScroll,
      isFixedPosition,
      controlHeight: controlHeight2
    });
    setMaxHeight(state.maxHeight);
    setPlacement(state.placement);
    setPortalPlacement === null || setPortalPlacement === void 0 ? void 0 : setPortalPlacement(state.placement);
  }, [maxMenuHeight, menuPlacement, menuPosition, menuShouldScrollIntoView, minMenuHeight, setPortalPlacement, controlHeight2]);
  return children2({
    ref,
    placerProps: _objectSpread2(_objectSpread2({}, props), {}, {
      placement: placement || coercePlacement(menuPlacement),
      maxHeight
    })
  });
};
var Menu = function Menu2(props) {
  var children2 = props.children, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "menu", {
    menu: true
  }), {
    ref: innerRef
  }, innerProps), children2);
};
var Menu$1 = Menu;
var menuListCSS = function menuListCSS2(_ref4, unstyled) {
  var maxHeight = _ref4.maxHeight, baseUnit2 = _ref4.theme.spacing.baseUnit;
  return _objectSpread2({
    maxHeight,
    overflowY: "auto",
    position: "relative",
    // required for offset[Height, Top] > keyboard scroll
    WebkitOverflowScrolling: "touch"
  }, unstyled ? {} : {
    paddingBottom: baseUnit2,
    paddingTop: baseUnit2
  });
};
var MenuList = function MenuList2(props) {
  var children2 = props.children, innerProps = props.innerProps, innerRef = props.innerRef, isMulti = props.isMulti;
  return jsx("div", _extends({}, getStyleProps(props, "menuList", {
    "menu-list": true,
    "menu-list--is-multi": isMulti
  }), {
    ref: innerRef
  }, innerProps), children2);
};
var noticeCSS = function noticeCSS2(_ref5, unstyled) {
  var _ref5$theme = _ref5.theme, baseUnit2 = _ref5$theme.spacing.baseUnit, colors2 = _ref5$theme.colors;
  return _objectSpread2({
    textAlign: "center"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    padding: "".concat(baseUnit2 * 2, "px ").concat(baseUnit2 * 3, "px")
  });
};
var noOptionsMessageCSS = noticeCSS;
var loadingMessageCSS = noticeCSS;
var NoOptionsMessage = function NoOptionsMessage2(_ref6) {
  var _ref6$children = _ref6.children, children2 = _ref6$children === void 0 ? "No options" : _ref6$children, innerProps = _ref6.innerProps, restProps = _objectWithoutProperties(_ref6, _excluded$3);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "noOptionsMessage", {
    "menu-notice": true,
    "menu-notice--no-options": true
  }), innerProps), children2);
};
var LoadingMessage = function LoadingMessage2(_ref7) {
  var _ref7$children = _ref7.children, children2 = _ref7$children === void 0 ? "Loading..." : _ref7$children, innerProps = _ref7.innerProps, restProps = _objectWithoutProperties(_ref7, _excluded2$1);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    children: children2,
    innerProps
  }), "loadingMessage", {
    "menu-notice": true,
    "menu-notice--loading": true
  }), innerProps), children2);
};
var menuPortalCSS = function menuPortalCSS2(_ref8) {
  var rect = _ref8.rect, offset = _ref8.offset, position2 = _ref8.position;
  return {
    left: rect.left,
    position: position2,
    top: offset,
    width: rect.width,
    zIndex: 1
  };
};
var MenuPortal = function MenuPortal2(props) {
  var appendTo = props.appendTo, children2 = props.children, controlElement = props.controlElement, innerProps = props.innerProps, menuPlacement = props.menuPlacement, menuPosition = props.menuPosition;
  var menuPortalRef = reactExports.useRef(null);
  var cleanupRef = reactExports.useRef(null);
  var _useState5 = reactExports.useState(coercePlacement(menuPlacement)), _useState6 = _slicedToArray(_useState5, 2), placement = _useState6[0], setPortalPlacement = _useState6[1];
  var portalPlacementContext = reactExports.useMemo(function() {
    return {
      setPortalPlacement
    };
  }, []);
  var _useState7 = reactExports.useState(null), _useState8 = _slicedToArray(_useState7, 2), computedPosition = _useState8[0], setComputedPosition = _useState8[1];
  var updateComputedPosition = reactExports.useCallback(function() {
    if (!controlElement)
      return;
    var rect = getBoundingClientObj(controlElement);
    var scrollDistance = menuPosition === "fixed" ? 0 : window.pageYOffset;
    var offset = rect[placement] + scrollDistance;
    if (offset !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset) || rect.left !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left) || rect.width !== (computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width)) {
      setComputedPosition({
        offset,
        rect
      });
    }
  }, [controlElement, menuPosition, placement, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.offset, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.left, computedPosition === null || computedPosition === void 0 ? void 0 : computedPosition.rect.width]);
  index$1(function() {
    updateComputedPosition();
  }, [updateComputedPosition]);
  var runAutoUpdate = reactExports.useCallback(function() {
    if (typeof cleanupRef.current === "function") {
      cleanupRef.current();
      cleanupRef.current = null;
    }
    if (controlElement && menuPortalRef.current) {
      cleanupRef.current = autoUpdate(controlElement, menuPortalRef.current, updateComputedPosition, {
        elementResize: "ResizeObserver" in window
      });
    }
  }, [controlElement, updateComputedPosition]);
  index$1(function() {
    runAutoUpdate();
  }, [runAutoUpdate]);
  var setMenuPortalElement = reactExports.useCallback(function(menuPortalElement) {
    menuPortalRef.current = menuPortalElement;
    runAutoUpdate();
  }, [runAutoUpdate]);
  if (!appendTo && menuPosition !== "fixed" || !computedPosition)
    return null;
  var menuWrapper = jsx("div", _extends({
    ref: setMenuPortalElement
  }, getStyleProps(_objectSpread2(_objectSpread2({}, props), {}, {
    offset: computedPosition.offset,
    position: menuPosition,
    rect: computedPosition.rect
  }), "menuPortal", {
    "menu-portal": true
  }), innerProps), children2);
  return jsx(PortalPlacementContext.Provider, {
    value: portalPlacementContext
  }, appendTo ? /* @__PURE__ */ reactDomExports.createPortal(menuWrapper, appendTo) : menuWrapper);
};
var containerCSS = function containerCSS2(_ref3) {
  var isDisabled = _ref3.isDisabled, isRtl = _ref3.isRtl;
  return {
    label: "container",
    direction: isRtl ? "rtl" : void 0,
    pointerEvents: isDisabled ? "none" : void 0,
    // cancel mouse events when disabled
    position: "relative"
  };
};
var SelectContainer = function SelectContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps, isDisabled = props.isDisabled, isRtl = props.isRtl;
  return jsx("div", _extends({}, getStyleProps(props, "container", {
    "--is-disabled": isDisabled,
    "--is-rtl": isRtl
  }), innerProps), children2);
};
var valueContainerCSS = function valueContainerCSS2(_ref22, unstyled) {
  var spacing2 = _ref22.theme.spacing, isMulti = _ref22.isMulti, hasValue = _ref22.hasValue, controlShouldRenderValue = _ref22.selectProps.controlShouldRenderValue;
  return _objectSpread2({
    alignItems: "center",
    display: isMulti && hasValue && controlShouldRenderValue ? "flex" : "grid",
    flex: 1,
    flexWrap: "wrap",
    WebkitOverflowScrolling: "touch",
    position: "relative",
    overflow: "hidden"
  }, unstyled ? {} : {
    padding: "".concat(spacing2.baseUnit / 2, "px ").concat(spacing2.baseUnit * 2, "px")
  });
};
var ValueContainer = function ValueContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps, isMulti = props.isMulti, hasValue = props.hasValue;
  return jsx("div", _extends({}, getStyleProps(props, "valueContainer", {
    "value-container": true,
    "value-container--is-multi": isMulti,
    "value-container--has-value": hasValue
  }), innerProps), children2);
};
var indicatorsContainerCSS = function indicatorsContainerCSS2() {
  return {
    alignItems: "center",
    alignSelf: "stretch",
    display: "flex",
    flexShrink: 0
  };
};
var IndicatorsContainer = function IndicatorsContainer2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "indicatorsContainer", {
    indicators: true
  }), innerProps), children2);
};
var _templateObject;
var _excluded$2 = ["size"], _excluded2 = ["innerProps", "isRtl", "size"];
var _ref2$2 = {
  name: "8mmkcg",
  styles: "display:inline-block;fill:currentColor;line-height:1;stroke:currentColor;stroke-width:0"
};
var Svg = function Svg2(_ref3) {
  var size2 = _ref3.size, props = _objectWithoutProperties(_ref3, _excluded$2);
  return jsx("svg", _extends({
    height: size2,
    width: size2,
    viewBox: "0 0 20 20",
    "aria-hidden": "true",
    focusable: "false",
    css: _ref2$2
  }, props));
};
var CrossIcon = function CrossIcon2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M14.348 14.849c-0.469 0.469-1.229 0.469-1.697 0l-2.651-3.030-2.651 3.029c-0.469 0.469-1.229 0.469-1.697 0-0.469-0.469-0.469-1.229 0-1.697l2.758-3.15-2.759-3.152c-0.469-0.469-0.469-1.228 0-1.697s1.228-0.469 1.697 0l2.652 3.031 2.651-3.031c0.469-0.469 1.228-0.469 1.697 0s0.469 1.229 0 1.697l-2.758 3.152 2.758 3.15c0.469 0.469 0.469 1.229 0 1.698z"
  }));
};
var DownChevron = function DownChevron2(props) {
  return jsx(Svg, _extends({
    size: 20
  }, props), jsx("path", {
    d: "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747 3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0 1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502 0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0 0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z"
  }));
};
var baseCSS = function baseCSS2(_ref3, unstyled) {
  var isFocused = _ref3.isFocused, _ref3$theme = _ref3.theme, baseUnit2 = _ref3$theme.spacing.baseUnit, colors2 = _ref3$theme.colors;
  return _objectSpread2({
    label: "indicatorContainer",
    display: "flex",
    transition: "color 150ms"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2,
    ":hover": {
      color: isFocused ? colors2.neutral80 : colors2.neutral40
    }
  });
};
var dropdownIndicatorCSS = baseCSS;
var DropdownIndicator$3 = function DropdownIndicator(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "dropdownIndicator", {
    indicator: true,
    "dropdown-indicator": true
  }), innerProps), children2 || jsx(DownChevron, null));
};
var clearIndicatorCSS = baseCSS;
var ClearIndicator = function ClearIndicator2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "clearIndicator", {
    indicator: true,
    "clear-indicator": true
  }), innerProps), children2 || jsx(CrossIcon, null));
};
var indicatorSeparatorCSS = function indicatorSeparatorCSS2(_ref4, unstyled) {
  var isDisabled = _ref4.isDisabled, _ref4$theme = _ref4.theme, baseUnit2 = _ref4$theme.spacing.baseUnit, colors2 = _ref4$theme.colors;
  return _objectSpread2({
    label: "indicatorSeparator",
    alignSelf: "stretch",
    width: 1
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral10 : colors2.neutral20,
    marginBottom: baseUnit2 * 2,
    marginTop: baseUnit2 * 2
  });
};
var IndicatorSeparator = function IndicatorSeparator2(props) {
  var innerProps = props.innerProps;
  return jsx("span", _extends({}, innerProps, getStyleProps(props, "indicatorSeparator", {
    "indicator-separator": true
  })));
};
var loadingDotAnimations = keyframes(_templateObject || (_templateObject = _taggedTemplateLiteral(["\n  0%, 80%, 100% { opacity: 0; }\n  40% { opacity: 1; }\n"])));
var loadingIndicatorCSS = function loadingIndicatorCSS2(_ref5, unstyled) {
  var isFocused = _ref5.isFocused, size2 = _ref5.size, _ref5$theme = _ref5.theme, colors2 = _ref5$theme.colors, baseUnit2 = _ref5$theme.spacing.baseUnit;
  return _objectSpread2({
    label: "loadingIndicator",
    display: "flex",
    transition: "color 150ms",
    alignSelf: "center",
    fontSize: size2,
    lineHeight: 1,
    marginRight: size2,
    textAlign: "center",
    verticalAlign: "middle"
  }, unstyled ? {} : {
    color: isFocused ? colors2.neutral60 : colors2.neutral20,
    padding: baseUnit2 * 2
  });
};
var LoadingDot = function LoadingDot2(_ref6) {
  var delay2 = _ref6.delay, offset = _ref6.offset;
  return jsx("span", {
    css: /* @__PURE__ */ css$2({
      animation: "".concat(loadingDotAnimations, " 1s ease-in-out ").concat(delay2, "ms infinite;"),
      backgroundColor: "currentColor",
      borderRadius: "1em",
      display: "inline-block",
      marginLeft: offset ? "1em" : void 0,
      height: "1em",
      verticalAlign: "top",
      width: "1em"
    }, "", "")
  });
};
var LoadingIndicator = function LoadingIndicator2(_ref7) {
  var innerProps = _ref7.innerProps, isRtl = _ref7.isRtl, _ref7$size = _ref7.size, size2 = _ref7$size === void 0 ? 4 : _ref7$size, restProps = _objectWithoutProperties(_ref7, _excluded2);
  return jsx("div", _extends({}, getStyleProps(_objectSpread2(_objectSpread2({}, restProps), {}, {
    innerProps,
    isRtl,
    size: size2
  }), "loadingIndicator", {
    indicator: true,
    "loading-indicator": true
  }), innerProps), jsx(LoadingDot, {
    delay: 0,
    offset: isRtl
  }), jsx(LoadingDot, {
    delay: 160,
    offset: true
  }), jsx(LoadingDot, {
    delay: 320,
    offset: !isRtl
  }));
};
var css$1 = function css(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, _ref$theme = _ref3.theme, colors2 = _ref$theme.colors, borderRadius2 = _ref$theme.borderRadius, spacing2 = _ref$theme.spacing;
  return _objectSpread2({
    label: "control",
    alignItems: "center",
    cursor: "default",
    display: "flex",
    flexWrap: "wrap",
    justifyContent: "space-between",
    minHeight: spacing2.controlHeight,
    outline: "0 !important",
    position: "relative",
    transition: "all 100ms"
  }, unstyled ? {} : {
    backgroundColor: isDisabled ? colors2.neutral5 : colors2.neutral0,
    borderColor: isDisabled ? colors2.neutral10 : isFocused ? colors2.primary : colors2.neutral20,
    borderRadius: borderRadius2,
    borderStyle: "solid",
    borderWidth: 1,
    boxShadow: isFocused ? "0 0 0 1px ".concat(colors2.primary) : void 0,
    "&:hover": {
      borderColor: isFocused ? colors2.primary : colors2.neutral30
    }
  });
};
var Control = function Control2(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, innerRef = props.innerRef, innerProps = props.innerProps, menuIsOpen = props.menuIsOpen;
  return jsx("div", _extends({
    ref: innerRef
  }, getStyleProps(props, "control", {
    control: true,
    "control--is-disabled": isDisabled,
    "control--is-focused": isFocused,
    "control--menu-is-open": menuIsOpen
  }), innerProps), children2);
};
var Control$1 = Control;
var _excluded$1 = ["data"];
var groupCSS = function groupCSS2(_ref3, unstyled) {
  var spacing2 = _ref3.theme.spacing;
  return unstyled ? {} : {
    paddingBottom: spacing2.baseUnit * 2,
    paddingTop: spacing2.baseUnit * 2
  };
};
var Group$1 = function Group(props) {
  var children2 = props.children, cx = props.cx, getStyles = props.getStyles, getClassNames = props.getClassNames, Heading = props.Heading, headingProps = props.headingProps, innerProps = props.innerProps, label2 = props.label, theme = props.theme, selectProps = props.selectProps;
  return jsx("div", _extends({}, getStyleProps(props, "group", {
    group: true
  }), innerProps), jsx(Heading, _extends({}, headingProps, {
    selectProps,
    theme,
    getStyles,
    getClassNames,
    cx
  }), label2), jsx("div", null, children2));
};
var groupHeadingCSS = function groupHeadingCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, colors2 = _ref2$theme.colors, spacing2 = _ref2$theme.spacing;
  return _objectSpread2({
    label: "group",
    cursor: "default",
    display: "block"
  }, unstyled ? {} : {
    color: colors2.neutral40,
    fontSize: "75%",
    fontWeight: 500,
    marginBottom: "0.25em",
    paddingLeft: spacing2.baseUnit * 3,
    paddingRight: spacing2.baseUnit * 3,
    textTransform: "uppercase"
  });
};
var GroupHeading$1 = function GroupHeading(props) {
  var _cleanCommonProps = cleanCommonProps(props);
  _cleanCommonProps.data;
  var innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$1);
  return jsx("div", _extends({}, getStyleProps(props, "groupHeading", {
    "group-heading": true
  }), innerProps));
};
var Group$1$1 = Group$1;
var _excluded$5 = ["innerRef", "isDisabled", "isHidden", "inputClassName"];
var inputCSS = function inputCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, value = _ref3.value, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2(_objectSpread2({
    visibility: isDisabled ? "hidden" : "visible",
    // force css to recompute when value change due to @emotion bug.
    // We can remove it whenever the bug is fixed.
    transform: value ? "translateZ(0)" : ""
  }, containerStyle), unstyled ? {} : {
    margin: spacing2.baseUnit / 2,
    paddingBottom: spacing2.baseUnit / 2,
    paddingTop: spacing2.baseUnit / 2,
    color: colors2.neutral80
  });
};
var spacingStyle = {
  gridArea: "1 / 2",
  font: "inherit",
  minWidth: "2px",
  border: 0,
  margin: 0,
  outline: 0,
  padding: 0
};
var containerStyle = {
  flex: "1 1 auto",
  display: "inline-grid",
  gridArea: "1 / 1 / 2 / 3",
  gridTemplateColumns: "0 min-content",
  "&:after": _objectSpread2({
    content: 'attr(data-value) " "',
    visibility: "hidden",
    whiteSpace: "pre"
  }, spacingStyle)
};
var inputStyle = function inputStyle2(isHidden) {
  return _objectSpread2({
    label: "input",
    color: "inherit",
    background: 0,
    opacity: isHidden ? 0 : 1,
    width: "100%"
  }, spacingStyle);
};
var Input2 = function Input3(props) {
  var cx = props.cx, value = props.value;
  var _cleanCommonProps = cleanCommonProps(props), innerRef = _cleanCommonProps.innerRef, isDisabled = _cleanCommonProps.isDisabled, isHidden = _cleanCommonProps.isHidden, inputClassName = _cleanCommonProps.inputClassName, innerProps = _objectWithoutProperties(_cleanCommonProps, _excluded$5);
  return jsx("div", _extends({}, getStyleProps(props, "input", {
    "input-container": true
  }), {
    "data-value": value || ""
  }), jsx("input", _extends({
    className: cx({
      input: true
    }, inputClassName),
    ref: innerRef,
    style: inputStyle(isHidden),
    disabled: isDisabled
  }, innerProps)));
};
var Input$1 = Input2;
var multiValueCSS = function multiValueCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, borderRadius2 = _ref$theme.borderRadius, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "multiValue",
    display: "flex",
    minWidth: 0
  }, unstyled ? {} : {
    backgroundColor: colors2.neutral10,
    borderRadius: borderRadius2 / 2,
    margin: spacing2.baseUnit / 2
  });
};
var multiValueLabelCSS = function multiValueLabelCSS2(_ref22, unstyled) {
  var _ref2$theme = _ref22.theme, borderRadius2 = _ref2$theme.borderRadius, colors2 = _ref2$theme.colors, cropWithEllipsis = _ref22.cropWithEllipsis;
  return _objectSpread2({
    overflow: "hidden",
    textOverflow: cropWithEllipsis || cropWithEllipsis === void 0 ? "ellipsis" : void 0,
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    color: colors2.neutral80,
    fontSize: "85%",
    padding: 3,
    paddingLeft: 6
  });
};
var multiValueRemoveCSS = function multiValueRemoveCSS2(_ref3, unstyled) {
  var _ref3$theme = _ref3.theme, spacing2 = _ref3$theme.spacing, borderRadius2 = _ref3$theme.borderRadius, colors2 = _ref3$theme.colors, isFocused = _ref3.isFocused;
  return _objectSpread2({
    alignItems: "center",
    display: "flex"
  }, unstyled ? {} : {
    borderRadius: borderRadius2 / 2,
    backgroundColor: isFocused ? colors2.dangerLight : void 0,
    paddingLeft: spacing2.baseUnit,
    paddingRight: spacing2.baseUnit,
    ":hover": {
      backgroundColor: colors2.dangerLight,
      color: colors2.danger
    }
  });
};
var MultiValueGeneric = function MultiValueGeneric2(_ref4) {
  var children2 = _ref4.children, innerProps = _ref4.innerProps;
  return jsx("div", innerProps, children2);
};
var MultiValueContainer = MultiValueGeneric;
var MultiValueLabel = MultiValueGeneric;
function MultiValueRemove(_ref5) {
  var children2 = _ref5.children, innerProps = _ref5.innerProps;
  return jsx("div", _extends({
    role: "button"
  }, innerProps), children2 || jsx(CrossIcon, {
    size: 14
  }));
}
var MultiValue = function MultiValue2(props) {
  var children2 = props.children, components2 = props.components, data = props.data, innerProps = props.innerProps, isDisabled = props.isDisabled, removeProps3 = props.removeProps, selectProps = props.selectProps;
  var Container = components2.Container, Label2 = components2.Label, Remove = components2.Remove;
  return jsx(Container, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValue", {
      "multi-value": true,
      "multi-value--is-disabled": isDisabled
    })), innerProps),
    selectProps
  }, jsx(Label2, {
    data,
    innerProps: _objectSpread2({}, getStyleProps(props, "multiValueLabel", {
      "multi-value__label": true
    })),
    selectProps
  }, children2), jsx(Remove, {
    data,
    innerProps: _objectSpread2(_objectSpread2({}, getStyleProps(props, "multiValueRemove", {
      "multi-value__remove": true
    })), {}, {
      "aria-label": "Remove ".concat(children2 || "option")
    }, removeProps3),
    selectProps
  }));
};
var MultiValue$1 = MultiValue;
var optionCSS = function optionCSS2(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, isFocused = _ref3.isFocused, isSelected = _ref3.isSelected, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "option",
    cursor: "default",
    display: "block",
    fontSize: "inherit",
    width: "100%",
    userSelect: "none",
    WebkitTapHighlightColor: "rgba(0, 0, 0, 0)"
  }, unstyled ? {} : {
    backgroundColor: isSelected ? colors2.primary : isFocused ? colors2.primary25 : "transparent",
    color: isDisabled ? colors2.neutral20 : isSelected ? colors2.neutral0 : "inherit",
    padding: "".concat(spacing2.baseUnit * 2, "px ").concat(spacing2.baseUnit * 3, "px"),
    // provide some affordance on touch devices
    ":active": {
      backgroundColor: !isDisabled ? isSelected ? colors2.primary : colors2.primary50 : void 0
    }
  });
};
var Option$1 = function Option(props) {
  var children2 = props.children, isDisabled = props.isDisabled, isFocused = props.isFocused, isSelected = props.isSelected, innerRef = props.innerRef, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "option", {
    option: true,
    "option--is-disabled": isDisabled,
    "option--is-focused": isFocused,
    "option--is-selected": isSelected
  }), {
    ref: innerRef,
    "aria-disabled": isDisabled
  }, innerProps), children2);
};
var Option$1$1 = Option$1;
var placeholderCSS = function placeholderCSS2(_ref3, unstyled) {
  var _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "placeholder",
    gridArea: "1 / 1 / 2 / 3"
  }, unstyled ? {} : {
    color: colors2.neutral50,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var Placeholder = function Placeholder2(props) {
  var children2 = props.children, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "placeholder", {
    placeholder: true
  }), innerProps), children2);
};
var Placeholder$1 = Placeholder;
var css2 = function css3(_ref3, unstyled) {
  var isDisabled = _ref3.isDisabled, _ref$theme = _ref3.theme, spacing2 = _ref$theme.spacing, colors2 = _ref$theme.colors;
  return _objectSpread2({
    label: "singleValue",
    gridArea: "1 / 1 / 2 / 3",
    maxWidth: "100%",
    overflow: "hidden",
    textOverflow: "ellipsis",
    whiteSpace: "nowrap"
  }, unstyled ? {} : {
    color: isDisabled ? colors2.neutral40 : colors2.neutral80,
    marginLeft: spacing2.baseUnit / 2,
    marginRight: spacing2.baseUnit / 2
  });
};
var SingleValue$1 = function SingleValue(props) {
  var children2 = props.children, isDisabled = props.isDisabled, innerProps = props.innerProps;
  return jsx("div", _extends({}, getStyleProps(props, "singleValue", {
    "single-value": true,
    "single-value--is-disabled": isDisabled
  }), innerProps), children2);
};
var SingleValue$1$1 = SingleValue$1;
var components = {
  ClearIndicator,
  Control: Control$1,
  DropdownIndicator: DropdownIndicator$3,
  DownChevron,
  CrossIcon,
  Group: Group$1$1,
  GroupHeading: GroupHeading$1,
  IndicatorsContainer,
  IndicatorSeparator,
  Input: Input$1,
  LoadingIndicator,
  Menu: Menu$1,
  MenuList,
  MenuPortal,
  LoadingMessage,
  NoOptionsMessage,
  MultiValue: MultiValue$1,
  MultiValueContainer,
  MultiValueLabel,
  MultiValueRemove,
  Option: Option$1$1,
  Placeholder: Placeholder$1,
  SelectContainer,
  SingleValue: SingleValue$1$1,
  ValueContainer
};
var defaultComponents = function defaultComponents2(props) {
  return _objectSpread2(_objectSpread2({}, components), props.components);
};
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual(first2, second) {
  if (first2 === second) {
    return true;
  }
  if (safeIsNaN(first2) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i = 0; i < newInputs.length; i++) {
    if (!isEqual(newInputs[i], lastInputs[i])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual2) {
  if (isEqual2 === void 0) {
    isEqual2 = areInputsEqual;
  }
  var cache = null;
  function memoized() {
    var newArgs = [];
    for (var _i2 = 0; _i2 < arguments.length; _i2++) {
      newArgs[_i2] = arguments[_i2];
    }
    if (cache && cache.lastThis === this && isEqual2(newArgs, cache.lastArgs)) {
      return cache.lastResult;
    }
    var lastResult = resultFn.apply(this, newArgs);
    cache = {
      lastResult,
      lastArgs: newArgs,
      lastThis: this
    };
    return lastResult;
  }
  memoized.clear = function clear() {
    cache = null;
  };
  return memoized;
}
var _ref = {
  name: "7pg0cj-a11yText",
  styles: "label:a11yText;z-index:9999;border:0;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0;white-space:nowrap"
};
var A11yText = function A11yText2(props) {
  return jsx("span", _extends({
    css: _ref
  }, props));
};
var A11yText$1 = A11yText;
var defaultAriaLiveMessages = {
  guidance: function guidance(props) {
    var isSearchable = props.isSearchable, isMulti = props.isMulti, isDisabled = props.isDisabled, tabSelectsValue = props.tabSelectsValue, context = props.context;
    switch (context) {
      case "menu":
        return "Use Up and Down to choose options".concat(isDisabled ? "" : ", press Enter to select the currently focused option", ", press Escape to exit the menu").concat(tabSelectsValue ? ", press Tab to select the option and exit the menu" : "", ".");
      case "input":
        return "".concat(props["aria-label"] || "Select", " is focused ").concat(isSearchable ? ",type to refine list" : "", ", press Down to open the menu, ").concat(isMulti ? " press left to focus selected values" : "");
      case "value":
        return "Use left and right to toggle between focused values, press Backspace to remove the currently focused value";
      default:
        return "";
    }
  },
  onChange: function onChange(props) {
    var action2 = props.action, _props$label = props.label, label2 = _props$label === void 0 ? "" : _props$label, labels2 = props.labels, isDisabled = props.isDisabled;
    switch (action2) {
      case "deselect-option":
      case "pop-value":
      case "remove-value":
        return "option ".concat(label2, ", deselected.");
      case "clear":
        return "All selected options have been cleared.";
      case "initial-input-focus":
        return "option".concat(labels2.length > 1 ? "s" : "", " ").concat(labels2.join(","), ", selected.");
      case "select-option":
        return isDisabled ? "option ".concat(label2, " is disabled. Select another option.") : "option ".concat(label2, ", selected.");
      default:
        return "";
    }
  },
  onFocus: function onFocus(props) {
    var context = props.context, focused = props.focused, options2 = props.options, _props$label2 = props.label, label2 = _props$label2 === void 0 ? "" : _props$label2, selectValue = props.selectValue, isDisabled = props.isDisabled, isSelected = props.isSelected;
    var getArrayIndex = function getArrayIndex2(arr, item2) {
      return arr && arr.length ? "".concat(arr.indexOf(item2) + 1, " of ").concat(arr.length) : "";
    };
    if (context === "value" && selectValue) {
      return "value ".concat(label2, " focused, ").concat(getArrayIndex(selectValue, focused), ".");
    }
    if (context === "menu") {
      var disabled2 = isDisabled ? " disabled" : "";
      var status2 = "".concat(isSelected ? "selected" : "focused").concat(disabled2);
      return "option ".concat(label2, " ").concat(status2, ", ").concat(getArrayIndex(options2, focused), ".");
    }
    return "";
  },
  onFilter: function onFilter(props) {
    var inputValue = props.inputValue, resultsMessage = props.resultsMessage;
    return "".concat(resultsMessage).concat(inputValue ? " for search term " + inputValue : "", ".");
  }
};
var LiveRegion = function LiveRegion2(props) {
  var ariaSelection = props.ariaSelection, focusedOption = props.focusedOption, focusedValue = props.focusedValue, focusableOptions = props.focusableOptions, isFocused = props.isFocused, selectValue = props.selectValue, selectProps = props.selectProps, id2 = props.id;
  var ariaLiveMessages = selectProps.ariaLiveMessages, getOptionLabel4 = selectProps.getOptionLabel, inputValue = selectProps.inputValue, isMulti = selectProps.isMulti, isOptionDisabled3 = selectProps.isOptionDisabled, isSearchable = selectProps.isSearchable, menuIsOpen = selectProps.menuIsOpen, options2 = selectProps.options, screenReaderStatus2 = selectProps.screenReaderStatus, tabSelectsValue = selectProps.tabSelectsValue;
  var ariaLabel = selectProps["aria-label"];
  var ariaLive = selectProps["aria-live"];
  var messages = reactExports.useMemo(function() {
    return _objectSpread2(_objectSpread2({}, defaultAriaLiveMessages), ariaLiveMessages || {});
  }, [ariaLiveMessages]);
  var ariaSelected = reactExports.useMemo(function() {
    var message2 = "";
    if (ariaSelection && messages.onChange) {
      var option = ariaSelection.option, selectedOptions = ariaSelection.options, removedValue = ariaSelection.removedValue, removedValues = ariaSelection.removedValues, value = ariaSelection.value;
      var asOption = function asOption2(val) {
        return !Array.isArray(val) ? val : null;
      };
      var selected2 = removedValue || option || asOption(value);
      var label2 = selected2 ? getOptionLabel4(selected2) : "";
      var multiSelected = selectedOptions || removedValues || void 0;
      var labels2 = multiSelected ? multiSelected.map(getOptionLabel4) : [];
      var onChangeProps = _objectSpread2({
        // multiSelected items are usually items that have already been selected
        // or set by the user as a default value so we assume they are not disabled
        isDisabled: selected2 && isOptionDisabled3(selected2, selectValue),
        label: label2,
        labels: labels2
      }, ariaSelection);
      message2 = messages.onChange(onChangeProps);
    }
    return message2;
  }, [ariaSelection, messages, isOptionDisabled3, selectValue, getOptionLabel4]);
  var ariaFocused = reactExports.useMemo(function() {
    var focusMsg = "";
    var focused = focusedOption || focusedValue;
    var isSelected = !!(focusedOption && selectValue && selectValue.includes(focusedOption));
    if (focused && messages.onFocus) {
      var onFocusProps = {
        focused,
        label: getOptionLabel4(focused),
        isDisabled: isOptionDisabled3(focused, selectValue),
        isSelected,
        options: focusableOptions,
        context: focused === focusedOption ? "menu" : "value",
        selectValue
      };
      focusMsg = messages.onFocus(onFocusProps);
    }
    return focusMsg;
  }, [focusedOption, focusedValue, getOptionLabel4, isOptionDisabled3, messages, focusableOptions, selectValue]);
  var ariaResults = reactExports.useMemo(function() {
    var resultsMsg = "";
    if (menuIsOpen && options2.length && messages.onFilter) {
      var resultsMessage = screenReaderStatus2({
        count: focusableOptions.length
      });
      resultsMsg = messages.onFilter({
        inputValue,
        resultsMessage
      });
    }
    return resultsMsg;
  }, [focusableOptions, inputValue, menuIsOpen, messages, options2, screenReaderStatus2]);
  var ariaGuidance = reactExports.useMemo(function() {
    var guidanceMsg = "";
    if (messages.guidance) {
      var context = focusedValue ? "value" : menuIsOpen ? "menu" : "input";
      guidanceMsg = messages.guidance({
        "aria-label": ariaLabel,
        context,
        isDisabled: focusedOption && isOptionDisabled3(focusedOption, selectValue),
        isMulti,
        isSearchable,
        tabSelectsValue
      });
    }
    return guidanceMsg;
  }, [ariaLabel, focusedOption, focusedValue, isMulti, isOptionDisabled3, isSearchable, menuIsOpen, messages, selectValue, tabSelectsValue]);
  var ariaContext = "".concat(ariaFocused, " ").concat(ariaResults, " ").concat(ariaGuidance);
  var ScreenReaderText = jsx(reactExports.Fragment, null, jsx("span", {
    id: "aria-selection"
  }, ariaSelected), jsx("span", {
    id: "aria-context"
  }, ariaContext));
  var isInitialFocus = (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus";
  return jsx(reactExports.Fragment, null, jsx(A11yText$1, {
    id: id2
  }, isInitialFocus && ScreenReaderText), jsx(A11yText$1, {
    "aria-live": ariaLive,
    "aria-atomic": "false",
    "aria-relevant": "additions text"
  }, isFocused && !isInitialFocus && ScreenReaderText));
};
var LiveRegion$1 = LiveRegion;
var diacritics = [{
  base: "A",
  letters: "AⒶＡÀÁÂẦẤẪẨÃĀĂẰẮẴẲȦǠÄǞẢÅǺǍȀȂẠẬẶḀĄȺⱯ"
}, {
  base: "AA",
  letters: "Ꜳ"
}, {
  base: "AE",
  letters: "ÆǼǢ"
}, {
  base: "AO",
  letters: "Ꜵ"
}, {
  base: "AU",
  letters: "Ꜷ"
}, {
  base: "AV",
  letters: "ꜸꜺ"
}, {
  base: "AY",
  letters: "Ꜽ"
}, {
  base: "B",
  letters: "BⒷＢḂḄḆɃƂƁ"
}, {
  base: "C",
  letters: "CⒸＣĆĈĊČÇḈƇȻꜾ"
}, {
  base: "D",
  letters: "DⒹＤḊĎḌḐḒḎĐƋƊƉꝹ"
}, {
  base: "DZ",
  letters: "ǱǄ"
}, {
  base: "Dz",
  letters: "ǲǅ"
}, {
  base: "E",
  letters: "EⒺＥÈÉÊỀẾỄỂẼĒḔḖĔĖËẺĚȄȆẸỆȨḜĘḘḚƐƎ"
}, {
  base: "F",
  letters: "FⒻＦḞƑꝻ"
}, {
  base: "G",
  letters: "GⒼＧǴĜḠĞĠǦĢǤƓꞠꝽꝾ"
}, {
  base: "H",
  letters: "HⒽＨĤḢḦȞḤḨḪĦⱧⱵꞍ"
}, {
  base: "I",
  letters: "IⒾＩÌÍÎĨĪĬİÏḮỈǏȈȊỊĮḬƗ"
}, {
  base: "J",
  letters: "JⒿＪĴɈ"
}, {
  base: "K",
  letters: "KⓀＫḰǨḲĶḴƘⱩꝀꝂꝄꞢ"
}, {
  base: "L",
  letters: "LⓁＬĿĹĽḶḸĻḼḺŁȽⱢⱠꝈꝆꞀ"
}, {
  base: "LJ",
  letters: "Ǉ"
}, {
  base: "Lj",
  letters: "ǈ"
}, {
  base: "M",
  letters: "MⓂＭḾṀṂⱮƜ"
}, {
  base: "N",
  letters: "NⓃＮǸŃÑṄŇṆŅṊṈȠƝꞐꞤ"
}, {
  base: "NJ",
  letters: "Ǌ"
}, {
  base: "Nj",
  letters: "ǋ"
}, {
  base: "O",
  letters: "OⓄＯÒÓÔỒỐỖỔÕṌȬṎŌṐṒŎȮȰÖȪỎŐǑȌȎƠỜỚỠỞỢỌỘǪǬØǾƆƟꝊꝌ"
}, {
  base: "OI",
  letters: "Ƣ"
}, {
  base: "OO",
  letters: "Ꝏ"
}, {
  base: "OU",
  letters: "Ȣ"
}, {
  base: "P",
  letters: "PⓅＰṔṖƤⱣꝐꝒꝔ"
}, {
  base: "Q",
  letters: "QⓆＱꝖꝘɊ"
}, {
  base: "R",
  letters: "RⓇＲŔṘŘȐȒṚṜŖṞɌⱤꝚꞦꞂ"
}, {
  base: "S",
  letters: "SⓈＳẞŚṤŜṠŠṦṢṨȘŞⱾꞨꞄ"
}, {
  base: "T",
  letters: "TⓉＴṪŤṬȚŢṰṮŦƬƮȾꞆ"
}, {
  base: "TZ",
  letters: "Ꜩ"
}, {
  base: "U",
  letters: "UⓊＵÙÚÛŨṸŪṺŬÜǛǗǕǙỦŮŰǓȔȖƯỪỨỮỬỰỤṲŲṶṴɄ"
}, {
  base: "V",
  letters: "VⓋＶṼṾƲꝞɅ"
}, {
  base: "VY",
  letters: "Ꝡ"
}, {
  base: "W",
  letters: "WⓌＷẀẂŴẆẄẈⱲ"
}, {
  base: "X",
  letters: "XⓍＸẊẌ"
}, {
  base: "Y",
  letters: "YⓎＹỲÝŶỸȲẎŸỶỴƳɎỾ"
}, {
  base: "Z",
  letters: "ZⓏＺŹẐŻŽẒẔƵȤⱿⱫꝢ"
}, {
  base: "a",
  letters: "aⓐａẚàáâầấẫẩãāăằắẵẳȧǡäǟảåǻǎȁȃạậặḁąⱥɐ"
}, {
  base: "aa",
  letters: "ꜳ"
}, {
  base: "ae",
  letters: "æǽǣ"
}, {
  base: "ao",
  letters: "ꜵ"
}, {
  base: "au",
  letters: "ꜷ"
}, {
  base: "av",
  letters: "ꜹꜻ"
}, {
  base: "ay",
  letters: "ꜽ"
}, {
  base: "b",
  letters: "bⓑｂḃḅḇƀƃɓ"
}, {
  base: "c",
  letters: "cⓒｃćĉċčçḉƈȼꜿↄ"
}, {
  base: "d",
  letters: "dⓓｄḋďḍḑḓḏđƌɖɗꝺ"
}, {
  base: "dz",
  letters: "ǳǆ"
}, {
  base: "e",
  letters: "eⓔｅèéêềếễểẽēḕḗĕėëẻěȅȇẹệȩḝęḙḛɇɛǝ"
}, {
  base: "f",
  letters: "fⓕｆḟƒꝼ"
}, {
  base: "g",
  letters: "gⓖｇǵĝḡğġǧģǥɠꞡᵹꝿ"
}, {
  base: "h",
  letters: "hⓗｈĥḣḧȟḥḩḫẖħⱨⱶɥ"
}, {
  base: "hv",
  letters: "ƕ"
}, {
  base: "i",
  letters: "iⓘｉìíîĩīĭïḯỉǐȉȋịįḭɨı"
}, {
  base: "j",
  letters: "jⓙｊĵǰɉ"
}, {
  base: "k",
  letters: "kⓚｋḱǩḳķḵƙⱪꝁꝃꝅꞣ"
}, {
  base: "l",
  letters: "lⓛｌŀĺľḷḹļḽḻſłƚɫⱡꝉꞁꝇ"
}, {
  base: "lj",
  letters: "ǉ"
}, {
  base: "m",
  letters: "mⓜｍḿṁṃɱɯ"
}, {
  base: "n",
  letters: "nⓝｎǹńñṅňṇņṋṉƞɲŉꞑꞥ"
}, {
  base: "nj",
  letters: "ǌ"
}, {
  base: "o",
  letters: "oⓞｏòóôồốỗổõṍȭṏōṑṓŏȯȱöȫỏőǒȍȏơờớỡởợọộǫǭøǿɔꝋꝍɵ"
}, {
  base: "oi",
  letters: "ƣ"
}, {
  base: "ou",
  letters: "ȣ"
}, {
  base: "oo",
  letters: "ꝏ"
}, {
  base: "p",
  letters: "pⓟｐṕṗƥᵽꝑꝓꝕ"
}, {
  base: "q",
  letters: "qⓠｑɋꝗꝙ"
}, {
  base: "r",
  letters: "rⓡｒŕṙřȑȓṛṝŗṟɍɽꝛꞧꞃ"
}, {
  base: "s",
  letters: "sⓢｓßśṥŝṡšṧṣṩșşȿꞩꞅẛ"
}, {
  base: "t",
  letters: "tⓣｔṫẗťṭțţṱṯŧƭʈⱦꞇ"
}, {
  base: "tz",
  letters: "ꜩ"
}, {
  base: "u",
  letters: "uⓤｕùúûũṹūṻŭüǜǘǖǚủůűǔȕȗưừứữửựụṳųṷṵʉ"
}, {
  base: "v",
  letters: "vⓥｖṽṿʋꝟʌ"
}, {
  base: "vy",
  letters: "ꝡ"
}, {
  base: "w",
  letters: "wⓦｗẁẃŵẇẅẘẉⱳ"
}, {
  base: "x",
  letters: "xⓧｘẋẍ"
}, {
  base: "y",
  letters: "yⓨｙỳýŷỹȳẏÿỷẙỵƴɏỿ"
}, {
  base: "z",
  letters: "zⓩｚźẑżžẓẕƶȥɀⱬꝣ"
}];
var anyDiacritic = new RegExp("[" + diacritics.map(function(d2) {
  return d2.letters;
}).join("") + "]", "g");
var diacriticToBase = {};
for (var i = 0; i < diacritics.length; i++) {
  var diacritic = diacritics[i];
  for (var j$1 = 0; j$1 < diacritic.letters.length; j$1++) {
    diacriticToBase[diacritic.letters[j$1]] = diacritic.base;
  }
}
var stripDiacritics = function stripDiacritics2(str) {
  return str.replace(anyDiacritic, function(match2) {
    return diacriticToBase[match2];
  });
};
var memoizedStripDiacriticsForInput = memoizeOne(stripDiacritics);
var trimString = function trimString2(str) {
  return str.replace(/^\s+|\s+$/g, "");
};
var defaultStringify = function defaultStringify2(option) {
  return "".concat(option.label, " ").concat(option.value);
};
var createFilter = function createFilter2(config) {
  return function(option, rawInput) {
    if (option.data.__isNew__)
      return true;
    var _ignoreCase$ignoreAcc = _objectSpread2({
      ignoreCase: true,
      ignoreAccents: true,
      stringify: defaultStringify,
      trim: true,
      matchFrom: "any"
    }, config), ignoreCase = _ignoreCase$ignoreAcc.ignoreCase, ignoreAccents = _ignoreCase$ignoreAcc.ignoreAccents, stringify2 = _ignoreCase$ignoreAcc.stringify, trim2 = _ignoreCase$ignoreAcc.trim, matchFrom = _ignoreCase$ignoreAcc.matchFrom;
    var input2 = trim2 ? trimString(rawInput) : rawInput;
    var candidate = trim2 ? trimString(stringify2(option)) : stringify2(option);
    if (ignoreCase) {
      input2 = input2.toLowerCase();
      candidate = candidate.toLowerCase();
    }
    if (ignoreAccents) {
      input2 = memoizedStripDiacriticsForInput(input2);
      candidate = stripDiacritics(candidate);
    }
    return matchFrom === "start" ? candidate.substr(0, input2.length) === input2 : candidate.indexOf(input2) > -1;
  };
};
var _excluded = ["innerRef"];
function DummyInput(_ref3) {
  var innerRef = _ref3.innerRef, props = _objectWithoutProperties(_ref3, _excluded);
  var filteredProps = removeProps(props, "onExited", "in", "enter", "exit", "appear");
  return jsx("input", _extends({
    ref: innerRef
  }, filteredProps, {
    css: /* @__PURE__ */ css$2({
      label: "dummyInput",
      // get rid of any default styles
      background: 0,
      border: 0,
      // important! this hides the flashing cursor
      caretColor: "transparent",
      fontSize: "inherit",
      gridArea: "1 / 1 / 2 / 3",
      outline: 0,
      padding: 0,
      // important! without `width` browsers won't allow focus
      width: 1,
      // remove cursor on desktop
      color: "transparent",
      // remove cursor on mobile whilst maintaining "scroll into view" behaviour
      left: -100,
      opacity: 0,
      position: "relative",
      transform: "scale(.01)"
    }, "", "")
  }));
}
var cancelScroll = function cancelScroll2(event2) {
  event2.preventDefault();
  event2.stopPropagation();
};
function useScrollCapture(_ref3) {
  var isEnabled = _ref3.isEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var isBottom = reactExports.useRef(false);
  var isTop = reactExports.useRef(false);
  var touchStart = reactExports.useRef(0);
  var scrollTarget = reactExports.useRef(null);
  var handleEventDelta = reactExports.useCallback(function(event2, delta) {
    if (scrollTarget.current === null)
      return;
    var _scrollTarget$current = scrollTarget.current, scrollTop = _scrollTarget$current.scrollTop, scrollHeight = _scrollTarget$current.scrollHeight, clientHeight = _scrollTarget$current.clientHeight;
    var target = scrollTarget.current;
    var isDeltaPositive = delta > 0;
    var availableScroll = scrollHeight - clientHeight - scrollTop;
    var shouldCancelScroll = false;
    if (availableScroll > delta && isBottom.current) {
      if (onBottomLeave)
        onBottomLeave(event2);
      isBottom.current = false;
    }
    if (isDeltaPositive && isTop.current) {
      if (onTopLeave)
        onTopLeave(event2);
      isTop.current = false;
    }
    if (isDeltaPositive && delta > availableScroll) {
      if (onBottomArrive && !isBottom.current) {
        onBottomArrive(event2);
      }
      target.scrollTop = scrollHeight;
      shouldCancelScroll = true;
      isBottom.current = true;
    } else if (!isDeltaPositive && -delta > scrollTop) {
      if (onTopArrive && !isTop.current) {
        onTopArrive(event2);
      }
      target.scrollTop = 0;
      shouldCancelScroll = true;
      isTop.current = true;
    }
    if (shouldCancelScroll) {
      cancelScroll(event2);
    }
  }, [onBottomArrive, onBottomLeave, onTopArrive, onTopLeave]);
  var onWheel = reactExports.useCallback(function(event2) {
    handleEventDelta(event2, event2.deltaY);
  }, [handleEventDelta]);
  var onTouchStart = reactExports.useCallback(function(event2) {
    touchStart.current = event2.changedTouches[0].clientY;
  }, []);
  var onTouchMove = reactExports.useCallback(function(event2) {
    var deltaY = touchStart.current - event2.changedTouches[0].clientY;
    handleEventDelta(event2, deltaY);
  }, [handleEventDelta]);
  var startListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    var notPassive = supportsPassiveEvents ? {
      passive: false
    } : false;
    el2.addEventListener("wheel", onWheel, notPassive);
    el2.addEventListener("touchstart", onTouchStart, notPassive);
    el2.addEventListener("touchmove", onTouchMove, notPassive);
  }, [onTouchMove, onTouchStart, onWheel]);
  var stopListening = reactExports.useCallback(function(el2) {
    if (!el2)
      return;
    el2.removeEventListener("wheel", onWheel, false);
    el2.removeEventListener("touchstart", onTouchStart, false);
    el2.removeEventListener("touchmove", onTouchMove, false);
  }, [onTouchMove, onTouchStart, onWheel]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    startListening(element);
    return function() {
      stopListening(element);
    };
  }, [isEnabled, startListening, stopListening]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var STYLE_KEYS = ["boxSizing", "height", "overflow", "paddingRight", "position"];
var LOCK_STYLES = {
  boxSizing: "border-box",
  // account for possible declaration `width: 100%;` on body
  overflow: "hidden",
  position: "relative",
  height: "100%"
};
function preventTouchMove(e3) {
  e3.preventDefault();
}
function allowTouchMove(e3) {
  e3.stopPropagation();
}
function preventInertiaScroll() {
  var top = this.scrollTop;
  var totalScroll = this.scrollHeight;
  var currentScroll = top + this.offsetHeight;
  if (top === 0) {
    this.scrollTop = 1;
  } else if (currentScroll === totalScroll) {
    this.scrollTop = top - 1;
  }
}
function isTouchDevice() {
  return "ontouchstart" in window || navigator.maxTouchPoints;
}
var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
var activeScrollLocks = 0;
var listenerOptions = {
  capture: false,
  passive: false
};
function useScrollLock(_ref3) {
  var isEnabled = _ref3.isEnabled, _ref$accountForScroll = _ref3.accountForScrollbars, accountForScrollbars = _ref$accountForScroll === void 0 ? true : _ref$accountForScroll;
  var originalStyles = reactExports.useRef({});
  var scrollTarget = reactExports.useRef(null);
  var addScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    if (accountForScrollbars) {
      STYLE_KEYS.forEach(function(key) {
        var val = targetStyle && targetStyle[key];
        originalStyles.current[key] = val;
      });
    }
    if (accountForScrollbars && activeScrollLocks < 1) {
      var currentPadding = parseInt(originalStyles.current.paddingRight, 10) || 0;
      var clientWidth = document.body ? document.body.clientWidth : 0;
      var adjustedPadding = window.innerWidth - clientWidth + currentPadding || 0;
      Object.keys(LOCK_STYLES).forEach(function(key) {
        var val = LOCK_STYLES[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
      if (targetStyle) {
        targetStyle.paddingRight = "".concat(adjustedPadding, "px");
      }
    }
    if (target && isTouchDevice()) {
      target.addEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.addEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.addEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
    activeScrollLocks += 1;
  }, [accountForScrollbars]);
  var removeScrollLock = reactExports.useCallback(function(touchScrollTarget) {
    if (!canUseDOM)
      return;
    var target = document.body;
    var targetStyle = target && target.style;
    activeScrollLocks = Math.max(activeScrollLocks - 1, 0);
    if (accountForScrollbars && activeScrollLocks < 1) {
      STYLE_KEYS.forEach(function(key) {
        var val = originalStyles.current[key];
        if (targetStyle) {
          targetStyle[key] = val;
        }
      });
    }
    if (target && isTouchDevice()) {
      target.removeEventListener("touchmove", preventTouchMove, listenerOptions);
      if (touchScrollTarget) {
        touchScrollTarget.removeEventListener("touchstart", preventInertiaScroll, listenerOptions);
        touchScrollTarget.removeEventListener("touchmove", allowTouchMove, listenerOptions);
      }
    }
  }, [accountForScrollbars]);
  reactExports.useEffect(function() {
    if (!isEnabled)
      return;
    var element = scrollTarget.current;
    addScrollLock(element);
    return function() {
      removeScrollLock(element);
    };
  }, [isEnabled, addScrollLock, removeScrollLock]);
  return function(element) {
    scrollTarget.current = element;
  };
}
var blurSelectInput = function blurSelectInput2() {
  return document.activeElement && document.activeElement.blur();
};
var _ref2$1 = {
  name: "1kfdb0e",
  styles: "position:fixed;left:0;bottom:0;right:0;top:0"
};
function ScrollManager(_ref3) {
  var children2 = _ref3.children, lockEnabled = _ref3.lockEnabled, _ref$captureEnabled = _ref3.captureEnabled, captureEnabled = _ref$captureEnabled === void 0 ? true : _ref$captureEnabled, onBottomArrive = _ref3.onBottomArrive, onBottomLeave = _ref3.onBottomLeave, onTopArrive = _ref3.onTopArrive, onTopLeave = _ref3.onTopLeave;
  var setScrollCaptureTarget = useScrollCapture({
    isEnabled: captureEnabled,
    onBottomArrive,
    onBottomLeave,
    onTopArrive,
    onTopLeave
  });
  var setScrollLockTarget = useScrollLock({
    isEnabled: lockEnabled
  });
  var targetRef = function targetRef2(element) {
    setScrollCaptureTarget(element);
    setScrollLockTarget(element);
  };
  return jsx(reactExports.Fragment, null, lockEnabled && jsx("div", {
    onClick: blurSelectInput,
    css: _ref2$1
  }), children2(targetRef));
}
var _ref2 = {
  name: "1a0ro4n-requiredInput",
  styles: "label:requiredInput;opacity:0;pointer-events:none;position:absolute;bottom:0;left:0;right:0;width:100%"
};
var RequiredInput = function RequiredInput2(_ref3) {
  var name = _ref3.name, onFocus2 = _ref3.onFocus;
  return jsx("input", {
    required: true,
    name,
    tabIndex: -1,
    "aria-hidden": "true",
    onFocus: onFocus2,
    css: _ref2,
    value: "",
    onChange: function onChange2() {
    }
  });
};
var RequiredInput$1 = RequiredInput;
var formatGroupLabel = function formatGroupLabel2(group) {
  return group.label;
};
var getOptionLabel$1 = function getOptionLabel(option) {
  return option.label;
};
var getOptionValue$1 = function getOptionValue(option) {
  return option.value;
};
var isOptionDisabled = function isOptionDisabled2(option) {
  return !!option.isDisabled;
};
var defaultStyles = {
  clearIndicator: clearIndicatorCSS,
  container: containerCSS,
  control: css$1,
  dropdownIndicator: dropdownIndicatorCSS,
  group: groupCSS,
  groupHeading: groupHeadingCSS,
  indicatorsContainer: indicatorsContainerCSS,
  indicatorSeparator: indicatorSeparatorCSS,
  input: inputCSS,
  loadingIndicator: loadingIndicatorCSS,
  loadingMessage: loadingMessageCSS,
  menu: menuCSS,
  menuList: menuListCSS,
  menuPortal: menuPortalCSS,
  multiValue: multiValueCSS,
  multiValueLabel: multiValueLabelCSS,
  multiValueRemove: multiValueRemoveCSS,
  noOptionsMessage: noOptionsMessageCSS,
  option: optionCSS,
  placeholder: placeholderCSS,
  singleValue: css2,
  valueContainer: valueContainerCSS
};
var colors = {
  primary: "#2684FF",
  primary75: "#4C9AFF",
  primary50: "#B2D4FF",
  primary25: "#DEEBFF",
  danger: "#DE350B",
  dangerLight: "#FFBDAD",
  neutral0: "hsl(0, 0%, 100%)",
  neutral5: "hsl(0, 0%, 95%)",
  neutral10: "hsl(0, 0%, 90%)",
  neutral20: "hsl(0, 0%, 80%)",
  neutral30: "hsl(0, 0%, 70%)",
  neutral40: "hsl(0, 0%, 60%)",
  neutral50: "hsl(0, 0%, 50%)",
  neutral60: "hsl(0, 0%, 40%)",
  neutral70: "hsl(0, 0%, 30%)",
  neutral80: "hsl(0, 0%, 20%)",
  neutral90: "hsl(0, 0%, 10%)"
};
var borderRadius = 4;
var baseUnit = 4;
var controlHeight = 38;
var menuGutter = baseUnit * 2;
var spacing = {
  baseUnit,
  controlHeight,
  menuGutter
};
var defaultTheme = {
  borderRadius,
  colors,
  spacing
};
var defaultProps = {
  "aria-live": "polite",
  backspaceRemovesValue: true,
  blurInputOnSelect: isTouchCapable(),
  captureMenuScroll: !isTouchCapable(),
  classNames: {},
  closeMenuOnSelect: true,
  closeMenuOnScroll: false,
  components: {},
  controlShouldRenderValue: true,
  escapeClearsValue: false,
  filterOption: createFilter(),
  formatGroupLabel,
  getOptionLabel: getOptionLabel$1,
  getOptionValue: getOptionValue$1,
  isDisabled: false,
  isLoading: false,
  isMulti: false,
  isRtl: false,
  isSearchable: true,
  isOptionDisabled,
  loadingMessage: function loadingMessage() {
    return "Loading...";
  },
  maxMenuHeight: 300,
  minMenuHeight: 140,
  menuIsOpen: false,
  menuPlacement: "bottom",
  menuPosition: "absolute",
  menuShouldBlockScroll: false,
  menuShouldScrollIntoView: !isMobileDevice(),
  noOptionsMessage: function noOptionsMessage() {
    return "No options";
  },
  openMenuOnFocus: false,
  openMenuOnClick: true,
  options: [],
  pageSize: 5,
  placeholder: "Select...",
  screenReaderStatus: function screenReaderStatus(_ref3) {
    var count = _ref3.count;
    return "".concat(count, " result").concat(count !== 1 ? "s" : "", " available");
  },
  styles: {},
  tabIndex: 0,
  tabSelectsValue: true,
  unstyled: false
};
function toCategorizedOption(props, option, selectValue, index2) {
  var isDisabled = _isOptionDisabled(props, option, selectValue);
  var isSelected = _isOptionSelected(props, option, selectValue);
  var label2 = getOptionLabel2(props, option);
  var value = getOptionValue2(props, option);
  return {
    type: "option",
    data: option,
    isDisabled,
    isSelected,
    label: label2,
    value,
    index: index2
  };
}
function buildCategorizedOptions(props, selectValue) {
  return props.options.map(function(groupOrOption, groupOrOptionIndex) {
    if ("options" in groupOrOption) {
      var categorizedOptions = groupOrOption.options.map(function(option, optionIndex) {
        return toCategorizedOption(props, option, selectValue, optionIndex);
      }).filter(function(categorizedOption2) {
        return isFocusable(props, categorizedOption2);
      });
      return categorizedOptions.length > 0 ? {
        type: "group",
        data: groupOrOption,
        options: categorizedOptions,
        index: groupOrOptionIndex
      } : void 0;
    }
    var categorizedOption = toCategorizedOption(props, groupOrOption, selectValue, groupOrOptionIndex);
    return isFocusable(props, categorizedOption) ? categorizedOption : void 0;
  }).filter(notNullish);
}
function buildFocusableOptionsFromCategorizedOptions(categorizedOptions) {
  return categorizedOptions.reduce(function(optionsAccumulator, categorizedOption) {
    if (categorizedOption.type === "group") {
      optionsAccumulator.push.apply(optionsAccumulator, _toConsumableArray(categorizedOption.options.map(function(option) {
        return option.data;
      })));
    } else {
      optionsAccumulator.push(categorizedOption.data);
    }
    return optionsAccumulator;
  }, []);
}
function buildFocusableOptions(props, selectValue) {
  return buildFocusableOptionsFromCategorizedOptions(buildCategorizedOptions(props, selectValue));
}
function isFocusable(props, categorizedOption) {
  var _props$inputValue = props.inputValue, inputValue = _props$inputValue === void 0 ? "" : _props$inputValue;
  var data = categorizedOption.data, isSelected = categorizedOption.isSelected, label2 = categorizedOption.label, value = categorizedOption.value;
  return (!shouldHideSelectedOptions(props) || !isSelected) && _filterOption(props, {
    label: label2,
    value,
    data
  }, inputValue);
}
function getNextFocusedValue(state, nextSelectValue) {
  var focusedValue = state.focusedValue, lastSelectValue = state.selectValue;
  var lastFocusedIndex = lastSelectValue.indexOf(focusedValue);
  if (lastFocusedIndex > -1) {
    var nextFocusedIndex = nextSelectValue.indexOf(focusedValue);
    if (nextFocusedIndex > -1) {
      return focusedValue;
    } else if (lastFocusedIndex < nextSelectValue.length) {
      return nextSelectValue[lastFocusedIndex];
    }
  }
  return null;
}
function getNextFocusedOption(state, options2) {
  var lastFocusedOption = state.focusedOption;
  return lastFocusedOption && options2.indexOf(lastFocusedOption) > -1 ? lastFocusedOption : options2[0];
}
var getOptionLabel2 = function getOptionLabel3(props, data) {
  return props.getOptionLabel(data);
};
var getOptionValue2 = function getOptionValue3(props, data) {
  return props.getOptionValue(data);
};
function _isOptionDisabled(props, option, selectValue) {
  return typeof props.isOptionDisabled === "function" ? props.isOptionDisabled(option, selectValue) : false;
}
function _isOptionSelected(props, option, selectValue) {
  if (selectValue.indexOf(option) > -1)
    return true;
  if (typeof props.isOptionSelected === "function") {
    return props.isOptionSelected(option, selectValue);
  }
  var candidate = getOptionValue2(props, option);
  return selectValue.some(function(i) {
    return getOptionValue2(props, i) === candidate;
  });
}
function _filterOption(props, option, inputValue) {
  return props.filterOption ? props.filterOption(option, inputValue) : true;
}
var shouldHideSelectedOptions = function shouldHideSelectedOptions2(props) {
  var hideSelectedOptions = props.hideSelectedOptions, isMulti = props.isMulti;
  if (hideSelectedOptions === void 0)
    return isMulti;
  return hideSelectedOptions;
};
var instanceId = 1;
var Select = /* @__PURE__ */ function(_Component) {
  _inherits(Select2, _Component);
  var _super = _createSuper(Select2);
  function Select2(_props) {
    var _this;
    _classCallCheck(this, Select2);
    _this = _super.call(this, _props);
    _this.state = {
      ariaSelection: null,
      focusedOption: null,
      focusedValue: null,
      inputIsHidden: false,
      isFocused: false,
      selectValue: [],
      clearFocusValueOnUpdate: false,
      prevWasFocused: false,
      inputIsHiddenAfterUpdate: void 0,
      prevProps: void 0
    };
    _this.blockOptionHover = false;
    _this.isComposing = false;
    _this.commonProps = void 0;
    _this.initialTouchX = 0;
    _this.initialTouchY = 0;
    _this.instancePrefix = "";
    _this.openAfterFocus = false;
    _this.scrollToFocusedOptionOnUpdate = false;
    _this.userIsDragging = void 0;
    _this.controlRef = null;
    _this.getControlRef = function(ref) {
      _this.controlRef = ref;
    };
    _this.focusedOptionRef = null;
    _this.getFocusedOptionRef = function(ref) {
      _this.focusedOptionRef = ref;
    };
    _this.menuListRef = null;
    _this.getMenuListRef = function(ref) {
      _this.menuListRef = ref;
    };
    _this.inputRef = null;
    _this.getInputRef = function(ref) {
      _this.inputRef = ref;
    };
    _this.focus = _this.focusInput;
    _this.blur = _this.blurInput;
    _this.onChange = function(newValue, actionMeta) {
      var _this$props = _this.props, onChange2 = _this$props.onChange, name = _this$props.name;
      actionMeta.name = name;
      _this.ariaOnChange(newValue, actionMeta);
      onChange2(newValue, actionMeta);
    };
    _this.setValue = function(newValue, action2, option) {
      var _this$props2 = _this.props, closeMenuOnSelect = _this$props2.closeMenuOnSelect, isMulti = _this$props2.isMulti, inputValue = _this$props2.inputValue;
      _this.onInputChange("", {
        action: "set-value",
        prevInputValue: inputValue
      });
      if (closeMenuOnSelect) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      }
      _this.setState({
        clearFocusValueOnUpdate: true
      });
      _this.onChange(newValue, {
        action: action2,
        option
      });
    };
    _this.selectOption = function(newValue) {
      var _this$props3 = _this.props, blurInputOnSelect = _this$props3.blurInputOnSelect, isMulti = _this$props3.isMulti, name = _this$props3.name;
      var selectValue = _this.state.selectValue;
      var deselected = isMulti && _this.isOptionSelected(newValue, selectValue);
      var isDisabled = _this.isOptionDisabled(newValue, selectValue);
      if (deselected) {
        var candidate = _this.getOptionValue(newValue);
        _this.setValue(multiValueAsValue(selectValue.filter(function(i) {
          return _this.getOptionValue(i) !== candidate;
        })), "deselect-option", newValue);
      } else if (!isDisabled) {
        if (isMulti) {
          _this.setValue(multiValueAsValue([].concat(_toConsumableArray(selectValue), [newValue])), "select-option", newValue);
        } else {
          _this.setValue(singleValueAsValue(newValue), "select-option");
        }
      } else {
        _this.ariaOnChange(singleValueAsValue(newValue), {
          action: "select-option",
          option: newValue,
          name
        });
        return;
      }
      if (blurInputOnSelect) {
        _this.blurInput();
      }
    };
    _this.removeValue = function(removedValue) {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var candidate = _this.getOptionValue(removedValue);
      var newValueArray = selectValue.filter(function(i) {
        return _this.getOptionValue(i) !== candidate;
      });
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "remove-value",
        removedValue
      });
      _this.focusInput();
    };
    _this.clearValue = function() {
      var selectValue = _this.state.selectValue;
      _this.onChange(valueTernary(_this.props.isMulti, [], null), {
        action: "clear",
        removedValues: selectValue
      });
    };
    _this.popValue = function() {
      var isMulti = _this.props.isMulti;
      var selectValue = _this.state.selectValue;
      var lastSelectedValue = selectValue[selectValue.length - 1];
      var newValueArray = selectValue.slice(0, selectValue.length - 1);
      var newValue = valueTernary(isMulti, newValueArray, newValueArray[0] || null);
      _this.onChange(newValue, {
        action: "pop-value",
        removedValue: lastSelectedValue
      });
    };
    _this.getValue = function() {
      return _this.state.selectValue;
    };
    _this.cx = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return classNames.apply(void 0, [_this.props.classNamePrefix].concat(args));
    };
    _this.getOptionLabel = function(data) {
      return getOptionLabel2(_this.props, data);
    };
    _this.getOptionValue = function(data) {
      return getOptionValue2(_this.props, data);
    };
    _this.getStyles = function(key, props) {
      var unstyled = _this.props.unstyled;
      var base3 = defaultStyles[key](props, unstyled);
      base3.boxSizing = "border-box";
      var custom = _this.props.styles[key];
      return custom ? custom(base3, props) : base3;
    };
    _this.getClassNames = function(key, props) {
      var _this$props$className, _this$props$className2;
      return (_this$props$className = (_this$props$className2 = _this.props.classNames)[key]) === null || _this$props$className === void 0 ? void 0 : _this$props$className.call(_this$props$className2, props);
    };
    _this.getElementId = function(element) {
      return "".concat(_this.instancePrefix, "-").concat(element);
    };
    _this.getComponents = function() {
      return defaultComponents(_this.props);
    };
    _this.buildCategorizedOptions = function() {
      return buildCategorizedOptions(_this.props, _this.state.selectValue);
    };
    _this.getCategorizedOptions = function() {
      return _this.props.menuIsOpen ? _this.buildCategorizedOptions() : [];
    };
    _this.buildFocusableOptions = function() {
      return buildFocusableOptionsFromCategorizedOptions(_this.buildCategorizedOptions());
    };
    _this.getFocusableOptions = function() {
      return _this.props.menuIsOpen ? _this.buildFocusableOptions() : [];
    };
    _this.ariaOnChange = function(value, actionMeta) {
      _this.setState({
        ariaSelection: _objectSpread2({
          value
        }, actionMeta)
      });
    };
    _this.onMenuMouseDown = function(event2) {
      if (event2.button !== 0) {
        return;
      }
      event2.stopPropagation();
      event2.preventDefault();
      _this.focusInput();
    };
    _this.onMenuMouseMove = function(event2) {
      _this.blockOptionHover = false;
    };
    _this.onControlMouseDown = function(event2) {
      if (event2.defaultPrevented) {
        return;
      }
      var openMenuOnClick = _this.props.openMenuOnClick;
      if (!_this.state.isFocused) {
        if (openMenuOnClick) {
          _this.openAfterFocus = true;
        }
        _this.focusInput();
      } else if (!_this.props.menuIsOpen) {
        if (openMenuOnClick) {
          _this.openMenu("first");
        }
      } else {
        if (event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA") {
          _this.onMenuClose();
        }
      }
      if (event2.target.tagName !== "INPUT" && event2.target.tagName !== "TEXTAREA") {
        event2.preventDefault();
      }
    };
    _this.onDropdownIndicatorMouseDown = function(event2) {
      if (event2 && event2.type === "mousedown" && event2.button !== 0) {
        return;
      }
      if (_this.props.isDisabled)
        return;
      var _this$props4 = _this.props, isMulti = _this$props4.isMulti, menuIsOpen = _this$props4.menuIsOpen;
      _this.focusInput();
      if (menuIsOpen) {
        _this.setState({
          inputIsHiddenAfterUpdate: !isMulti
        });
        _this.onMenuClose();
      } else {
        _this.openMenu("first");
      }
      event2.preventDefault();
    };
    _this.onClearIndicatorMouseDown = function(event2) {
      if (event2 && event2.type === "mousedown" && event2.button !== 0) {
        return;
      }
      _this.clearValue();
      event2.preventDefault();
      _this.openAfterFocus = false;
      if (event2.type === "touchend") {
        _this.focusInput();
      } else {
        setTimeout(function() {
          return _this.focusInput();
        });
      }
    };
    _this.onScroll = function(event2) {
      if (typeof _this.props.closeMenuOnScroll === "boolean") {
        if (event2.target instanceof HTMLElement && isDocumentElement(event2.target)) {
          _this.props.onMenuClose();
        }
      } else if (typeof _this.props.closeMenuOnScroll === "function") {
        if (_this.props.closeMenuOnScroll(event2)) {
          _this.props.onMenuClose();
        }
      }
    };
    _this.onCompositionStart = function() {
      _this.isComposing = true;
    };
    _this.onCompositionEnd = function() {
      _this.isComposing = false;
    };
    _this.onTouchStart = function(_ref22) {
      var touches = _ref22.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      _this.initialTouchX = touch.clientX;
      _this.initialTouchY = touch.clientY;
      _this.userIsDragging = false;
    };
    _this.onTouchMove = function(_ref3) {
      var touches = _ref3.touches;
      var touch = touches && touches.item(0);
      if (!touch) {
        return;
      }
      var deltaX = Math.abs(touch.clientX - _this.initialTouchX);
      var deltaY = Math.abs(touch.clientY - _this.initialTouchY);
      var moveThreshold = 5;
      _this.userIsDragging = deltaX > moveThreshold || deltaY > moveThreshold;
    };
    _this.onTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      if (_this.controlRef && !_this.controlRef.contains(event2.target) && _this.menuListRef && !_this.menuListRef.contains(event2.target)) {
        _this.blurInput();
      }
      _this.initialTouchX = 0;
      _this.initialTouchY = 0;
    };
    _this.onControlTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onControlMouseDown(event2);
    };
    _this.onClearIndicatorTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onClearIndicatorMouseDown(event2);
    };
    _this.onDropdownIndicatorTouchEnd = function(event2) {
      if (_this.userIsDragging)
        return;
      _this.onDropdownIndicatorMouseDown(event2);
    };
    _this.handleInputChange = function(event2) {
      var prevInputValue = _this.props.inputValue;
      var inputValue = event2.currentTarget.value;
      _this.setState({
        inputIsHiddenAfterUpdate: false
      });
      _this.onInputChange(inputValue, {
        action: "input-change",
        prevInputValue
      });
      if (!_this.props.menuIsOpen) {
        _this.onMenuOpen();
      }
    };
    _this.onInputFocus = function(event2) {
      if (_this.props.onFocus) {
        _this.props.onFocus(event2);
      }
      _this.setState({
        inputIsHiddenAfterUpdate: false,
        isFocused: true
      });
      if (_this.openAfterFocus || _this.props.openMenuOnFocus) {
        _this.openMenu("first");
      }
      _this.openAfterFocus = false;
    };
    _this.onInputBlur = function(event2) {
      var prevInputValue = _this.props.inputValue;
      if (_this.menuListRef && _this.menuListRef.contains(document.activeElement)) {
        _this.inputRef.focus();
        return;
      }
      if (_this.props.onBlur) {
        _this.props.onBlur(event2);
      }
      _this.onInputChange("", {
        action: "input-blur",
        prevInputValue
      });
      _this.onMenuClose();
      _this.setState({
        focusedValue: null,
        isFocused: false
      });
    };
    _this.onOptionHover = function(focusedOption) {
      if (_this.blockOptionHover || _this.state.focusedOption === focusedOption) {
        return;
      }
      _this.setState({
        focusedOption
      });
    };
    _this.shouldHideSelectedOptions = function() {
      return shouldHideSelectedOptions(_this.props);
    };
    _this.onValueInputFocus = function(e3) {
      e3.preventDefault();
      e3.stopPropagation();
      _this.focus();
    };
    _this.onKeyDown = function(event2) {
      var _this$props5 = _this.props, isMulti = _this$props5.isMulti, backspaceRemovesValue = _this$props5.backspaceRemovesValue, escapeClearsValue = _this$props5.escapeClearsValue, inputValue = _this$props5.inputValue, isClearable = _this$props5.isClearable, isDisabled = _this$props5.isDisabled, menuIsOpen = _this$props5.menuIsOpen, onKeyDown = _this$props5.onKeyDown, tabSelectsValue = _this$props5.tabSelectsValue, openMenuOnFocus = _this$props5.openMenuOnFocus;
      var _this$state = _this.state, focusedOption = _this$state.focusedOption, focusedValue = _this$state.focusedValue, selectValue = _this$state.selectValue;
      if (isDisabled)
        return;
      if (typeof onKeyDown === "function") {
        onKeyDown(event2);
        if (event2.defaultPrevented) {
          return;
        }
      }
      _this.blockOptionHover = true;
      switch (event2.key) {
        case "ArrowLeft":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("previous");
          break;
        case "ArrowRight":
          if (!isMulti || inputValue)
            return;
          _this.focusValue("next");
          break;
        case "Delete":
        case "Backspace":
          if (inputValue)
            return;
          if (focusedValue) {
            _this.removeValue(focusedValue);
          } else {
            if (!backspaceRemovesValue)
              return;
            if (isMulti) {
              _this.popValue();
            } else if (isClearable) {
              _this.clearValue();
            }
          }
          break;
        case "Tab":
          if (_this.isComposing)
            return;
          if (event2.shiftKey || !menuIsOpen || !tabSelectsValue || !focusedOption || // don't capture the event if the menu opens on focus and the focused
          // option is already selected; it breaks the flow of navigation
          openMenuOnFocus && _this.isOptionSelected(focusedOption, selectValue)) {
            return;
          }
          _this.selectOption(focusedOption);
          break;
        case "Enter":
          if (event2.keyCode === 229) {
            break;
          }
          if (menuIsOpen) {
            if (!focusedOption)
              return;
            if (_this.isComposing)
              return;
            _this.selectOption(focusedOption);
            break;
          }
          return;
        case "Escape":
          if (menuIsOpen) {
            _this.setState({
              inputIsHiddenAfterUpdate: false
            });
            _this.onInputChange("", {
              action: "menu-close",
              prevInputValue: inputValue
            });
            _this.onMenuClose();
          } else if (isClearable && escapeClearsValue) {
            _this.clearValue();
          }
          break;
        case " ":
          if (inputValue) {
            return;
          }
          if (!menuIsOpen) {
            _this.openMenu("first");
            break;
          }
          if (!focusedOption)
            return;
          _this.selectOption(focusedOption);
          break;
        case "ArrowUp":
          if (menuIsOpen) {
            _this.focusOption("up");
          } else {
            _this.openMenu("last");
          }
          break;
        case "ArrowDown":
          if (menuIsOpen) {
            _this.focusOption("down");
          } else {
            _this.openMenu("first");
          }
          break;
        case "PageUp":
          if (!menuIsOpen)
            return;
          _this.focusOption("pageup");
          break;
        case "PageDown":
          if (!menuIsOpen)
            return;
          _this.focusOption("pagedown");
          break;
        case "Home":
          if (!menuIsOpen)
            return;
          _this.focusOption("first");
          break;
        case "End":
          if (!menuIsOpen)
            return;
          _this.focusOption("last");
          break;
        default:
          return;
      }
      event2.preventDefault();
    };
    _this.instancePrefix = "react-select-" + (_this.props.instanceId || ++instanceId);
    _this.state.selectValue = cleanValue(_props.value);
    if (_props.menuIsOpen && _this.state.selectValue.length) {
      var focusableOptions = _this.buildFocusableOptions();
      var optionIndex = focusableOptions.indexOf(_this.state.selectValue[0]);
      _this.state.focusedOption = focusableOptions[optionIndex];
    }
    return _this;
  }
  _createClass(Select2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.startListeningComposition();
      this.startListeningToTouch();
      if (this.props.closeMenuOnScroll && document && document.addEventListener) {
        document.addEventListener("scroll", this.onScroll, true);
      }
      if (this.props.autoFocus) {
        this.focusInput();
      }
      if (this.props.menuIsOpen && this.state.focusedOption && this.menuListRef && this.focusedOptionRef) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props6 = this.props, isDisabled = _this$props6.isDisabled, menuIsOpen = _this$props6.menuIsOpen;
      var isFocused = this.state.isFocused;
      if (
        // ensure focus is restored correctly when the control becomes enabled
        isFocused && !isDisabled && prevProps.isDisabled || // ensure focus is on the Input when the menu opens
        isFocused && menuIsOpen && !prevProps.menuIsOpen
      ) {
        this.focusInput();
      }
      if (isFocused && isDisabled && !prevProps.isDisabled) {
        this.setState({
          isFocused: false
        }, this.onMenuClose);
      } else if (!isFocused && !isDisabled && prevProps.isDisabled && this.inputRef === document.activeElement) {
        this.setState({
          isFocused: true
        });
      }
      if (this.menuListRef && this.focusedOptionRef && this.scrollToFocusedOptionOnUpdate) {
        scrollIntoView(this.menuListRef, this.focusedOptionRef);
        this.scrollToFocusedOptionOnUpdate = false;
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.stopListeningComposition();
      this.stopListeningToTouch();
      document.removeEventListener("scroll", this.onScroll, true);
    }
    // ==============================
    // Consumer Handlers
    // ==============================
  }, {
    key: "onMenuOpen",
    value: function onMenuOpen() {
      this.props.onMenuOpen();
    }
  }, {
    key: "onMenuClose",
    value: function onMenuClose() {
      this.onInputChange("", {
        action: "menu-close",
        prevInputValue: this.props.inputValue
      });
      this.props.onMenuClose();
    }
  }, {
    key: "onInputChange",
    value: function onInputChange(newValue, actionMeta) {
      this.props.onInputChange(newValue, actionMeta);
    }
    // ==============================
    // Methods
    // ==============================
  }, {
    key: "focusInput",
    value: function focusInput() {
      if (!this.inputRef)
        return;
      this.inputRef.focus();
    }
  }, {
    key: "blurInput",
    value: function blurInput() {
      if (!this.inputRef)
        return;
      this.inputRef.blur();
    }
    // aliased for consumers
  }, {
    key: "openMenu",
    value: function openMenu(focusOption) {
      var _this2 = this;
      var _this$state2 = this.state, selectValue = _this$state2.selectValue, isFocused = _this$state2.isFocused;
      var focusableOptions = this.buildFocusableOptions();
      var openAtIndex = focusOption === "first" ? 0 : focusableOptions.length - 1;
      if (!this.props.isMulti) {
        var selectedIndex = focusableOptions.indexOf(selectValue[0]);
        if (selectedIndex > -1) {
          openAtIndex = selectedIndex;
        }
      }
      this.scrollToFocusedOptionOnUpdate = !(isFocused && this.menuListRef);
      this.setState({
        inputIsHiddenAfterUpdate: false,
        focusedValue: null,
        focusedOption: focusableOptions[openAtIndex]
      }, function() {
        return _this2.onMenuOpen();
      });
    }
  }, {
    key: "focusValue",
    value: function focusValue(direction) {
      var _this$state3 = this.state, selectValue = _this$state3.selectValue, focusedValue = _this$state3.focusedValue;
      if (!this.props.isMulti)
        return;
      this.setState({
        focusedOption: null
      });
      var focusedIndex = selectValue.indexOf(focusedValue);
      if (!focusedValue) {
        focusedIndex = -1;
      }
      var lastIndex = selectValue.length - 1;
      var nextFocus = -1;
      if (!selectValue.length)
        return;
      switch (direction) {
        case "previous":
          if (focusedIndex === 0) {
            nextFocus = 0;
          } else if (focusedIndex === -1) {
            nextFocus = lastIndex;
          } else {
            nextFocus = focusedIndex - 1;
          }
          break;
        case "next":
          if (focusedIndex > -1 && focusedIndex < lastIndex) {
            nextFocus = focusedIndex + 1;
          }
          break;
      }
      this.setState({
        inputIsHidden: nextFocus !== -1,
        focusedValue: selectValue[nextFocus]
      });
    }
  }, {
    key: "focusOption",
    value: function focusOption() {
      var direction = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "first";
      var pageSize = this.props.pageSize;
      var focusedOption = this.state.focusedOption;
      var options2 = this.getFocusableOptions();
      if (!options2.length)
        return;
      var nextFocus = 0;
      var focusedIndex = options2.indexOf(focusedOption);
      if (!focusedOption) {
        focusedIndex = -1;
      }
      if (direction === "up") {
        nextFocus = focusedIndex > 0 ? focusedIndex - 1 : options2.length - 1;
      } else if (direction === "down") {
        nextFocus = (focusedIndex + 1) % options2.length;
      } else if (direction === "pageup") {
        nextFocus = focusedIndex - pageSize;
        if (nextFocus < 0)
          nextFocus = 0;
      } else if (direction === "pagedown") {
        nextFocus = focusedIndex + pageSize;
        if (nextFocus > options2.length - 1)
          nextFocus = options2.length - 1;
      } else if (direction === "last") {
        nextFocus = options2.length - 1;
      }
      this.scrollToFocusedOptionOnUpdate = true;
      this.setState({
        focusedOption: options2[nextFocus],
        focusedValue: null
      });
    }
  }, {
    key: "getTheme",
    value: (
      // ==============================
      // Getters
      // ==============================
      function getTheme() {
        if (!this.props.theme) {
          return defaultTheme;
        }
        if (typeof this.props.theme === "function") {
          return this.props.theme(defaultTheme);
        }
        return _objectSpread2(_objectSpread2({}, defaultTheme), this.props.theme);
      }
    )
  }, {
    key: "getCommonProps",
    value: function getCommonProps() {
      var clearValue = this.clearValue, cx = this.cx, getStyles = this.getStyles, getClassNames = this.getClassNames, getValue = this.getValue, selectOption = this.selectOption, setValue = this.setValue, props = this.props;
      var isMulti = props.isMulti, isRtl = props.isRtl, options2 = props.options;
      var hasValue = this.hasValue();
      return {
        clearValue,
        cx,
        getStyles,
        getClassNames,
        getValue,
        hasValue,
        isMulti,
        isRtl,
        options: options2,
        selectOption,
        selectProps: props,
        setValue,
        theme: this.getTheme()
      };
    }
  }, {
    key: "hasValue",
    value: function hasValue() {
      var selectValue = this.state.selectValue;
      return selectValue.length > 0;
    }
  }, {
    key: "hasOptions",
    value: function hasOptions() {
      return !!this.getFocusableOptions().length;
    }
  }, {
    key: "isClearable",
    value: function isClearable() {
      var _this$props7 = this.props, isClearable2 = _this$props7.isClearable, isMulti = _this$props7.isMulti;
      if (isClearable2 === void 0)
        return isMulti;
      return isClearable2;
    }
  }, {
    key: "isOptionDisabled",
    value: function isOptionDisabled3(option, selectValue) {
      return _isOptionDisabled(this.props, option, selectValue);
    }
  }, {
    key: "isOptionSelected",
    value: function isOptionSelected(option, selectValue) {
      return _isOptionSelected(this.props, option, selectValue);
    }
  }, {
    key: "filterOption",
    value: function filterOption(option, inputValue) {
      return _filterOption(this.props, option, inputValue);
    }
  }, {
    key: "formatOptionLabel",
    value: function formatOptionLabel(data, context) {
      if (typeof this.props.formatOptionLabel === "function") {
        var _inputValue = this.props.inputValue;
        var _selectValue = this.state.selectValue;
        return this.props.formatOptionLabel(data, {
          context,
          inputValue: _inputValue,
          selectValue: _selectValue
        });
      } else {
        return this.getOptionLabel(data);
      }
    }
  }, {
    key: "formatGroupLabel",
    value: function formatGroupLabel3(data) {
      return this.props.formatGroupLabel(data);
    }
    // ==============================
    // Mouse Handlers
    // ==============================
  }, {
    key: "startListeningComposition",
    value: (
      // ==============================
      // Composition Handlers
      // ==============================
      function startListeningComposition() {
        if (document && document.addEventListener) {
          document.addEventListener("compositionstart", this.onCompositionStart, false);
          document.addEventListener("compositionend", this.onCompositionEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningComposition",
    value: function stopListeningComposition() {
      if (document && document.removeEventListener) {
        document.removeEventListener("compositionstart", this.onCompositionStart);
        document.removeEventListener("compositionend", this.onCompositionEnd);
      }
    }
  }, {
    key: "startListeningToTouch",
    value: (
      // ==============================
      // Touch Handlers
      // ==============================
      function startListeningToTouch() {
        if (document && document.addEventListener) {
          document.addEventListener("touchstart", this.onTouchStart, false);
          document.addEventListener("touchmove", this.onTouchMove, false);
          document.addEventListener("touchend", this.onTouchEnd, false);
        }
      }
    )
  }, {
    key: "stopListeningToTouch",
    value: function stopListeningToTouch() {
      if (document && document.removeEventListener) {
        document.removeEventListener("touchstart", this.onTouchStart);
        document.removeEventListener("touchmove", this.onTouchMove);
        document.removeEventListener("touchend", this.onTouchEnd);
      }
    }
  }, {
    key: "renderInput",
    value: (
      // ==============================
      // Renderers
      // ==============================
      function renderInput() {
        var _this$props8 = this.props, isDisabled = _this$props8.isDisabled, isSearchable = _this$props8.isSearchable, inputId = _this$props8.inputId, inputValue = _this$props8.inputValue, tabIndex = _this$props8.tabIndex, form = _this$props8.form, menuIsOpen = _this$props8.menuIsOpen, required = _this$props8.required;
        var _this$getComponents = this.getComponents(), Input4 = _this$getComponents.Input;
        var _this$state4 = this.state, inputIsHidden = _this$state4.inputIsHidden, ariaSelection = _this$state4.ariaSelection;
        var commonProps = this.commonProps;
        var id2 = inputId || this.getElementId("input");
        var ariaAttributes = _objectSpread2(_objectSpread2(_objectSpread2({
          "aria-autocomplete": "list",
          "aria-expanded": menuIsOpen,
          "aria-haspopup": true,
          "aria-errormessage": this.props["aria-errormessage"],
          "aria-invalid": this.props["aria-invalid"],
          "aria-label": this.props["aria-label"],
          "aria-labelledby": this.props["aria-labelledby"],
          "aria-required": required,
          role: "combobox"
        }, menuIsOpen && {
          "aria-controls": this.getElementId("listbox"),
          "aria-owns": this.getElementId("listbox")
        }), !isSearchable && {
          "aria-readonly": true
        }), this.hasValue() ? (ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus" && {
          "aria-describedby": this.getElementId("live-region")
        } : {
          "aria-describedby": this.getElementId("placeholder")
        });
        if (!isSearchable) {
          return /* @__PURE__ */ reactExports.createElement(DummyInput, _extends({
            id: id2,
            innerRef: this.getInputRef,
            onBlur: this.onInputBlur,
            onChange: noop,
            onFocus: this.onInputFocus,
            disabled: isDisabled,
            tabIndex,
            inputMode: "none",
            form,
            value: ""
          }, ariaAttributes));
        }
        return /* @__PURE__ */ reactExports.createElement(Input4, _extends({}, commonProps, {
          autoCapitalize: "none",
          autoComplete: "off",
          autoCorrect: "off",
          id: id2,
          innerRef: this.getInputRef,
          isDisabled,
          isHidden: inputIsHidden,
          onBlur: this.onInputBlur,
          onChange: this.handleInputChange,
          onFocus: this.onInputFocus,
          spellCheck: "false",
          tabIndex,
          form,
          type: "text",
          value: inputValue
        }, ariaAttributes));
      }
    )
  }, {
    key: "renderPlaceholderOrValue",
    value: function renderPlaceholderOrValue() {
      var _this3 = this;
      var _this$getComponents2 = this.getComponents(), MultiValue3 = _this$getComponents2.MultiValue, MultiValueContainer2 = _this$getComponents2.MultiValueContainer, MultiValueLabel2 = _this$getComponents2.MultiValueLabel, MultiValueRemove2 = _this$getComponents2.MultiValueRemove, SingleValue3 = _this$getComponents2.SingleValue, Placeholder3 = _this$getComponents2.Placeholder;
      var commonProps = this.commonProps;
      var _this$props9 = this.props, controlShouldRenderValue = _this$props9.controlShouldRenderValue, isDisabled = _this$props9.isDisabled, isMulti = _this$props9.isMulti, inputValue = _this$props9.inputValue, placeholder = _this$props9.placeholder;
      var _this$state5 = this.state, selectValue = _this$state5.selectValue, focusedValue = _this$state5.focusedValue, isFocused = _this$state5.isFocused;
      if (!this.hasValue() || !controlShouldRenderValue) {
        return inputValue ? null : /* @__PURE__ */ reactExports.createElement(Placeholder3, _extends({}, commonProps, {
          key: "placeholder",
          isDisabled,
          isFocused,
          innerProps: {
            id: this.getElementId("placeholder")
          }
        }), placeholder);
      }
      if (isMulti) {
        return selectValue.map(function(opt, index2) {
          var isOptionFocused = opt === focusedValue;
          var key = "".concat(_this3.getOptionLabel(opt), "-").concat(_this3.getOptionValue(opt));
          return /* @__PURE__ */ reactExports.createElement(MultiValue3, _extends({}, commonProps, {
            components: {
              Container: MultiValueContainer2,
              Label: MultiValueLabel2,
              Remove: MultiValueRemove2
            },
            isFocused: isOptionFocused,
            isDisabled,
            key,
            index: index2,
            removeProps: {
              onClick: function onClick() {
                return _this3.removeValue(opt);
              },
              onTouchEnd: function onTouchEnd() {
                return _this3.removeValue(opt);
              },
              onMouseDown: function onMouseDown(e3) {
                e3.preventDefault();
              }
            },
            data: opt
          }), _this3.formatOptionLabel(opt, "value"));
        });
      }
      if (inputValue) {
        return null;
      }
      var singleValue = selectValue[0];
      return /* @__PURE__ */ reactExports.createElement(SingleValue3, _extends({}, commonProps, {
        data: singleValue,
        isDisabled
      }), this.formatOptionLabel(singleValue, "value"));
    }
  }, {
    key: "renderClearIndicator",
    value: function renderClearIndicator() {
      var _this$getComponents3 = this.getComponents(), ClearIndicator3 = _this$getComponents3.ClearIndicator;
      var commonProps = this.commonProps;
      var _this$props10 = this.props, isDisabled = _this$props10.isDisabled, isLoading = _this$props10.isLoading;
      var isFocused = this.state.isFocused;
      if (!this.isClearable() || !ClearIndicator3 || isDisabled || !this.hasValue() || isLoading) {
        return null;
      }
      var innerProps = {
        onMouseDown: this.onClearIndicatorMouseDown,
        onTouchEnd: this.onClearIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(ClearIndicator3, _extends({}, commonProps, {
        innerProps,
        isFocused
      }));
    }
  }, {
    key: "renderLoadingIndicator",
    value: function renderLoadingIndicator() {
      var _this$getComponents4 = this.getComponents(), LoadingIndicator3 = _this$getComponents4.LoadingIndicator;
      var commonProps = this.commonProps;
      var _this$props11 = this.props, isDisabled = _this$props11.isDisabled, isLoading = _this$props11.isLoading;
      var isFocused = this.state.isFocused;
      if (!LoadingIndicator3 || !isLoading)
        return null;
      var innerProps = {
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(LoadingIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderIndicatorSeparator",
    value: function renderIndicatorSeparator() {
      var _this$getComponents5 = this.getComponents(), DropdownIndicator3 = _this$getComponents5.DropdownIndicator, IndicatorSeparator3 = _this$getComponents5.IndicatorSeparator;
      if (!DropdownIndicator3 || !IndicatorSeparator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      return /* @__PURE__ */ reactExports.createElement(IndicatorSeparator3, _extends({}, commonProps, {
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderDropdownIndicator",
    value: function renderDropdownIndicator() {
      var _this$getComponents6 = this.getComponents(), DropdownIndicator3 = _this$getComponents6.DropdownIndicator;
      if (!DropdownIndicator3)
        return null;
      var commonProps = this.commonProps;
      var isDisabled = this.props.isDisabled;
      var isFocused = this.state.isFocused;
      var innerProps = {
        onMouseDown: this.onDropdownIndicatorMouseDown,
        onTouchEnd: this.onDropdownIndicatorTouchEnd,
        "aria-hidden": "true"
      };
      return /* @__PURE__ */ reactExports.createElement(DropdownIndicator3, _extends({}, commonProps, {
        innerProps,
        isDisabled,
        isFocused
      }));
    }
  }, {
    key: "renderMenu",
    value: function renderMenu() {
      var _this4 = this;
      var _this$getComponents7 = this.getComponents(), Group3 = _this$getComponents7.Group, GroupHeading3 = _this$getComponents7.GroupHeading, Menu3 = _this$getComponents7.Menu, MenuList3 = _this$getComponents7.MenuList, MenuPortal3 = _this$getComponents7.MenuPortal, LoadingMessage3 = _this$getComponents7.LoadingMessage, NoOptionsMessage3 = _this$getComponents7.NoOptionsMessage, Option3 = _this$getComponents7.Option;
      var commonProps = this.commonProps;
      var focusedOption = this.state.focusedOption;
      var _this$props12 = this.props, captureMenuScroll = _this$props12.captureMenuScroll, inputValue = _this$props12.inputValue, isLoading = _this$props12.isLoading, loadingMessage2 = _this$props12.loadingMessage, minMenuHeight = _this$props12.minMenuHeight, maxMenuHeight = _this$props12.maxMenuHeight, menuIsOpen = _this$props12.menuIsOpen, menuPlacement = _this$props12.menuPlacement, menuPosition = _this$props12.menuPosition, menuPortalTarget = _this$props12.menuPortalTarget, menuShouldBlockScroll = _this$props12.menuShouldBlockScroll, menuShouldScrollIntoView = _this$props12.menuShouldScrollIntoView, noOptionsMessage2 = _this$props12.noOptionsMessage, onMenuScrollToTop = _this$props12.onMenuScrollToTop, onMenuScrollToBottom = _this$props12.onMenuScrollToBottom;
      if (!menuIsOpen)
        return null;
      var render = function render2(props, id2) {
        var type2 = props.type, data = props.data, isDisabled = props.isDisabled, isSelected = props.isSelected, label2 = props.label, value = props.value;
        var isFocused = focusedOption === data;
        var onHover = isDisabled ? void 0 : function() {
          return _this4.onOptionHover(data);
        };
        var onSelect = isDisabled ? void 0 : function() {
          return _this4.selectOption(data);
        };
        var optionId = "".concat(_this4.getElementId("option"), "-").concat(id2);
        var innerProps = {
          id: optionId,
          onClick: onSelect,
          onMouseMove: onHover,
          onMouseOver: onHover,
          tabIndex: -1
        };
        return /* @__PURE__ */ reactExports.createElement(Option3, _extends({}, commonProps, {
          innerProps,
          data,
          isDisabled,
          isSelected,
          key: optionId,
          label: label2,
          type: type2,
          value,
          isFocused,
          innerRef: isFocused ? _this4.getFocusedOptionRef : void 0
        }), _this4.formatOptionLabel(props.data, "menu"));
      };
      var menuUI;
      if (this.hasOptions()) {
        menuUI = this.getCategorizedOptions().map(function(item2) {
          if (item2.type === "group") {
            var _data = item2.data, options2 = item2.options, groupIndex = item2.index;
            var groupId = "".concat(_this4.getElementId("group"), "-").concat(groupIndex);
            var headingId = "".concat(groupId, "-heading");
            return /* @__PURE__ */ reactExports.createElement(Group3, _extends({}, commonProps, {
              key: groupId,
              data: _data,
              options: options2,
              Heading: GroupHeading3,
              headingProps: {
                id: headingId,
                data: item2.data
              },
              label: _this4.formatGroupLabel(item2.data)
            }), item2.options.map(function(option) {
              return render(option, "".concat(groupIndex, "-").concat(option.index));
            }));
          } else if (item2.type === "option") {
            return render(item2, "".concat(item2.index));
          }
        });
      } else if (isLoading) {
        var message2 = loadingMessage2({
          inputValue
        });
        if (message2 === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(LoadingMessage3, commonProps, message2);
      } else {
        var _message = noOptionsMessage2({
          inputValue
        });
        if (_message === null)
          return null;
        menuUI = /* @__PURE__ */ reactExports.createElement(NoOptionsMessage3, commonProps, _message);
      }
      var menuPlacementProps = {
        minMenuHeight,
        maxMenuHeight,
        menuPlacement,
        menuPosition,
        menuShouldScrollIntoView
      };
      var menuElement = /* @__PURE__ */ reactExports.createElement(MenuPlacer, _extends({}, commonProps, menuPlacementProps), function(_ref4) {
        var ref = _ref4.ref, _ref4$placerProps = _ref4.placerProps, placement = _ref4$placerProps.placement, maxHeight = _ref4$placerProps.maxHeight;
        return /* @__PURE__ */ reactExports.createElement(Menu3, _extends({}, commonProps, menuPlacementProps, {
          innerRef: ref,
          innerProps: {
            onMouseDown: _this4.onMenuMouseDown,
            onMouseMove: _this4.onMenuMouseMove,
            id: _this4.getElementId("listbox")
          },
          isLoading,
          placement
        }), /* @__PURE__ */ reactExports.createElement(ScrollManager, {
          captureEnabled: captureMenuScroll,
          onTopArrive: onMenuScrollToTop,
          onBottomArrive: onMenuScrollToBottom,
          lockEnabled: menuShouldBlockScroll
        }, function(scrollTargetRef) {
          return /* @__PURE__ */ reactExports.createElement(MenuList3, _extends({}, commonProps, {
            innerRef: function innerRef(instance2) {
              _this4.getMenuListRef(instance2);
              scrollTargetRef(instance2);
            },
            isLoading,
            maxHeight,
            focusedOption
          }), menuUI);
        }));
      });
      return menuPortalTarget || menuPosition === "fixed" ? /* @__PURE__ */ reactExports.createElement(MenuPortal3, _extends({}, commonProps, {
        appendTo: menuPortalTarget,
        controlElement: this.controlRef,
        menuPlacement,
        menuPosition
      }), menuElement) : menuElement;
    }
  }, {
    key: "renderFormField",
    value: function renderFormField() {
      var _this5 = this;
      var _this$props13 = this.props, delimiter2 = _this$props13.delimiter, isDisabled = _this$props13.isDisabled, isMulti = _this$props13.isMulti, name = _this$props13.name, required = _this$props13.required;
      var selectValue = this.state.selectValue;
      if (required && !this.hasValue() && !isDisabled) {
        return /* @__PURE__ */ reactExports.createElement(RequiredInput$1, {
          name,
          onFocus: this.onValueInputFocus
        });
      }
      if (!name || isDisabled)
        return;
      if (isMulti) {
        if (delimiter2) {
          var value = selectValue.map(function(opt) {
            return _this5.getOptionValue(opt);
          }).join(delimiter2);
          return /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value
          });
        } else {
          var input2 = selectValue.length > 0 ? selectValue.map(function(opt, i) {
            return /* @__PURE__ */ reactExports.createElement("input", {
              key: "i-".concat(i),
              name,
              type: "hidden",
              value: _this5.getOptionValue(opt)
            });
          }) : /* @__PURE__ */ reactExports.createElement("input", {
            name,
            type: "hidden",
            value: ""
          });
          return /* @__PURE__ */ reactExports.createElement("div", null, input2);
        }
      } else {
        var _value = selectValue[0] ? this.getOptionValue(selectValue[0]) : "";
        return /* @__PURE__ */ reactExports.createElement("input", {
          name,
          type: "hidden",
          value: _value
        });
      }
    }
  }, {
    key: "renderLiveRegion",
    value: function renderLiveRegion() {
      var commonProps = this.commonProps;
      var _this$state6 = this.state, ariaSelection = _this$state6.ariaSelection, focusedOption = _this$state6.focusedOption, focusedValue = _this$state6.focusedValue, isFocused = _this$state6.isFocused, selectValue = _this$state6.selectValue;
      var focusableOptions = this.getFocusableOptions();
      return /* @__PURE__ */ reactExports.createElement(LiveRegion$1, _extends({}, commonProps, {
        id: this.getElementId("live-region"),
        ariaSelection,
        focusedOption,
        focusedValue,
        isFocused,
        selectValue,
        focusableOptions
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$getComponents8 = this.getComponents(), Control3 = _this$getComponents8.Control, IndicatorsContainer3 = _this$getComponents8.IndicatorsContainer, SelectContainer3 = _this$getComponents8.SelectContainer, ValueContainer3 = _this$getComponents8.ValueContainer;
      var _this$props14 = this.props, className = _this$props14.className, id2 = _this$props14.id, isDisabled = _this$props14.isDisabled, menuIsOpen = _this$props14.menuIsOpen;
      var isFocused = this.state.isFocused;
      var commonProps = this.commonProps = this.getCommonProps();
      return /* @__PURE__ */ reactExports.createElement(SelectContainer3, _extends({}, commonProps, {
        className,
        innerProps: {
          id: id2,
          onKeyDown: this.onKeyDown
        },
        isDisabled,
        isFocused
      }), this.renderLiveRegion(), /* @__PURE__ */ reactExports.createElement(Control3, _extends({}, commonProps, {
        innerRef: this.getControlRef,
        innerProps: {
          onMouseDown: this.onControlMouseDown,
          onTouchEnd: this.onControlTouchEnd
        },
        isDisabled,
        isFocused,
        menuIsOpen
      }), /* @__PURE__ */ reactExports.createElement(ValueContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderPlaceholderOrValue(), this.renderInput()), /* @__PURE__ */ reactExports.createElement(IndicatorsContainer3, _extends({}, commonProps, {
        isDisabled
      }), this.renderClearIndicator(), this.renderLoadingIndicator(), this.renderIndicatorSeparator(), this.renderDropdownIndicator())), this.renderMenu(), this.renderFormField());
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(props, state) {
      var prevProps = state.prevProps, clearFocusValueOnUpdate = state.clearFocusValueOnUpdate, inputIsHiddenAfterUpdate = state.inputIsHiddenAfterUpdate, ariaSelection = state.ariaSelection, isFocused = state.isFocused, prevWasFocused = state.prevWasFocused;
      var options2 = props.options, value = props.value, menuIsOpen = props.menuIsOpen, inputValue = props.inputValue, isMulti = props.isMulti;
      var selectValue = cleanValue(value);
      var newMenuOptionsState = {};
      if (prevProps && (value !== prevProps.value || options2 !== prevProps.options || menuIsOpen !== prevProps.menuIsOpen || inputValue !== prevProps.inputValue)) {
        var focusableOptions = menuIsOpen ? buildFocusableOptions(props, selectValue) : [];
        var focusedValue = clearFocusValueOnUpdate ? getNextFocusedValue(state, selectValue) : null;
        var focusedOption = getNextFocusedOption(state, focusableOptions);
        newMenuOptionsState = {
          selectValue,
          focusedOption,
          focusedValue,
          clearFocusValueOnUpdate: false
        };
      }
      var newInputIsHiddenState = inputIsHiddenAfterUpdate != null && props !== prevProps ? {
        inputIsHidden: inputIsHiddenAfterUpdate,
        inputIsHiddenAfterUpdate: void 0
      } : {};
      var newAriaSelection = ariaSelection;
      var hasKeptFocus = isFocused && prevWasFocused;
      if (isFocused && !hasKeptFocus) {
        newAriaSelection = {
          value: valueTernary(isMulti, selectValue, selectValue[0] || null),
          options: selectValue,
          action: "initial-input-focus"
        };
        hasKeptFocus = !prevWasFocused;
      }
      if ((ariaSelection === null || ariaSelection === void 0 ? void 0 : ariaSelection.action) === "initial-input-focus") {
        newAriaSelection = null;
      }
      return _objectSpread2(_objectSpread2(_objectSpread2({}, newMenuOptionsState), newInputIsHiddenState), {}, {
        prevProps: props,
        ariaSelection: newAriaSelection,
        prevWasFocused: hasKeptFocus
      });
    }
  }]);
  return Select2;
}(reactExports.Component);
Select.defaultProps = defaultProps;
var StateManagedSelect = /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
  var baseSelectProps = useStateManager(props);
  return /* @__PURE__ */ reactExports.createElement(Select, _extends({
    ref
  }, baseSelectProps));
});
var StateManagedSelect$1 = StateManagedSelect;
const badge$3 = "_badge_f2nw5_1";
const iconOnly = "_iconOnly_f2nw5_11";
const badgeIcon = "_badgeIcon_f2nw5_20";
const withChildren = "_withChildren_f2nw5_24";
const success$4 = "_success_f2nw5_34";
const warning$3 = "_warning_f2nw5_40";
const style$O = {
  badge: badge$3,
  iconOnly,
  badgeIcon,
  withChildren,
  success: success$4,
  warning: warning$3
};
const Badge = ({
  children: children2,
  className,
  icon: icon2,
  type: type2 = "success",
  ...props
}) => {
  const withChildrenStyle = children2 !== void 0 ? style$O.withChildren : "";
  const iconOnlyStyle = children2 === void 0 && icon2 ? style$O.iconOnly : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "span",
    {
      className: `${style$O.badge} ${style$O[type2]} ${withChildrenStyle} ${iconOnlyStyle} ${className || ""}`,
      ...props,
      children: [
        icon2 && icon2({ className: style$O.badgeIcon }),
        children2
      ]
    }
  );
};
const insured = "_insured_15jr2_1";
const insuredShield = "_insuredShield_15jr2_30";
const style$N = {
  insured,
  insuredShield
};
const Insured = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { className: style$N.insured, to: "/bitsurance/dashboard", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("account.insured") })
  ] }) });
};
const InsuredShield = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$N.insured} ${style$N.insuredShield}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Shield, {}) });
};
const createGroupedOptions = (accountsByKeystore) => {
  return accountsByKeystore.map(({ keystore: keystore2, accounts }) => ({
    label: `${keystore2.name} ${isAmbiguiousName(keystore2.name, accountsByKeystore) ? `(${keystore2.rootFingerprint})` : ""}`,
    connected: keystore2.connected,
    options: accounts.map((account2) => ({ label: account2.name, value: account2.code, coinCode: account2.coinCode, disabled: false }))
  }));
};
const appendBalance = async (option) => {
  const balance2 = await getBalance(option.value);
  return { ...option, balance: `${balance2.available.amount} ${balance2.available.unit}` };
};
const getBalancesForGroupedAccountSelector = async (originalGroupedOptions) => {
  const groupedOptions = originalGroupedOptions.map((group) => ({
    ...group,
    options: [...group.options]
  }));
  for (const group of groupedOptions) {
    const promises = group.options.map(appendBalance);
    group.options = await Promise.all(promises);
  }
  return groupedOptions;
};
const balance = "_balance_1lxsi_1";
const balanceSingleValue = "_balanceSingleValue_1lxsi_1";
const dropdown$2 = "_dropdown_1lxsi_12";
const groupHeader = "_groupHeader_1lxsi_21";
const select$4 = "_select_1lxsi_28";
const selectLabelText$1 = "_selectLabelText_1lxsi_82";
const singleValueContainer$1 = "_singleValueContainer_1lxsi_86";
const valueContainer = "_valueContainer_1lxsi_94";
const styles$k = {
  balance,
  balanceSingleValue,
  dropdown: dropdown$2,
  groupHeader,
  select: select$4,
  selectLabelText: selectLabelText$1,
  singleValueContainer: singleValueContainer$1,
  valueContainer
};
const SelectSingleValue$1 = (props) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const { label: label2, coinCode, balance: balance2, insured: insured2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.singleValueContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }),
    insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InsuredShield, {}),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.balanceSingleValue, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) }) });
};
const SelectOption$1 = (props) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const { label: label2, coinCode, balance: balance2, insured: insured2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$k.valueContainer, children: [
    coinCode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { coinCode, alt: coinCode }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.selectLabelText, children: label2 }),
    insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InsuredShield, {}),
    coinCode && balance2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$k.balance, children: hideAmounts ? `*** ${coinCode}` : balance2 })
  ] }) });
};
const DropdownIndicator$2 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$k.dropdown }) });
};
const Group2 = (props) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(components.Group, { ...props }) });
const GroupHeading2 = ({ customData, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$k.groupHeader}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.GroupHeading, { ...props, data: customData }),
    customData.connected && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Badge,
      {
        icon: (props2) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props2 }),
        type: "success"
      }
    )
  ] });
};
const GroupedAccountSelector = ({ title: title2, disabled: disabled2, selected: selected2, onChange: onChange2, onProceed, accounts }) => {
  const { t: t2 } = useTranslation();
  const [options2, setOptions] = reactExports.useState();
  reactExports.useEffect(() => {
    const accountsByKeystore = getAccountsByKeystore(accounts);
    const groupedOpts = createGroupedOptions(accountsByKeystore);
    setOptions(groupedOpts);
    getBalancesForGroupedAccountSelector(groupedOpts).then(setOptions);
  }, [accounts]);
  if (!options2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "title text-center", children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      StateManagedSelect$1,
      {
        className: styles$k.select,
        classNamePrefix: "react-select",
        options: options2,
        isSearchable: false,
        value: selected2 === "" ? {
          label: t2("buy.info.selectLabel"),
          value: "choose",
          disabled: true
        } : options2.flatMap((o2) => o2.options).find((opt) => opt.value === selected2),
        onChange: (e3) => {
          const value = (e3 == null ? void 0 : e3.value) || "";
          onChange2(value);
        },
        components: {
          Group: Group2,
          GroupHeading: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(GroupHeading2, { customData: props.data, ...props }),
          DropdownIndicator: DropdownIndicator$2,
          Option: SelectOption$1,
          SingleValue: SelectSingleValue$1,
          IndicatorSeparator: () => null
        },
        defaultValue: options2[0].options[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onProceed,
        disabled: !selected2 || disabled2,
        children: t2("buy.info.next")
      }
    ) })
  ] });
};
const BuyInfo = ({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState();
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    try {
      getExchangeSupportedAccounts(accounts).then((exchangeSupportedAccounts) => {
        setSupportedAccounts(exchangeSupportedAccounts);
      });
    } catch (e3) {
      console.error(e3);
    }
  }, [accounts]);
  reactExports.useEffect(() => {
    if (supportedAccounts !== void 0 && supportedAccounts.length === 1) {
      const accountCode = supportedAccounts[0].code;
      connectKeystore$12(accountCode).then((connected) => {
        if (connected) {
          route(`/buy/exchange/${accountCode}`);
        }
      });
    }
  }, [supportedAccounts]);
  const handleProceed = async () => {
    setDisabled(true);
    try {
      const connected = await connectKeystore$12(selected2);
      if (connected) {
        route(`/buy/exchange/${selected2}`);
      }
    } finally {
      setDisabled(false);
    }
  };
  const connectKeystore$12 = async (keystore2) => {
    const connectResult = await connectKeystore(keystore2);
    return connectResult.success;
  };
  if (supportedAccounts === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") });
  }
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const name = hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: !supportedAccounts || supportedAccounts.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: t2("accountSummary.noAccount") }) : supportedAccounts && /* @__PURE__ */ jsxRuntimeExports.jsx(
        GroupedAccountSelector,
        {
          accounts: supportedAccounts,
          title: t2("buy.title", { name }),
          disabled: disabled2,
          selected: selected2,
          onChange: setSelected,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] }) });
};
const flagIcons = "";
const button$2 = "_button_diw5d_1";
const style$M = {
  button: button$2
};
const InfoButton = ({ onClick, ...props }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick, ...props, className: style$M.button, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BuyInfo$1, {}) });
};
const container$l = "_container_1ksto_17";
const paymentMethodContainer = "_paymentMethodContainer_1ksto_17";
const exchangeName = "_exchangeName_1ksto_21";
const infoButton = "_infoButton_1ksto_25";
const outerContainer$2 = "_outerContainer_1ksto_37";
const paymentMethodsContainer = "_paymentMethodsContainer_1ksto_41";
const paymentMethodName = "_paymentMethodName_1ksto_47";
const radio = "_radio_1ksto_67";
const radioLabel = "_radioLabel_1ksto_123";
const text$2 = "_text_1ksto_127";
const style$L = {
  container: container$l,
  paymentMethodContainer,
  exchangeName,
  infoButton,
  outerContainer: outerContainer$2,
  paymentMethodsContainer,
  paymentMethodName,
  radio,
  radioLabel,
  text: text$2
};
const PaymentMethod = ({ methodName }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  switch (methodName) {
    case "bank-transfer":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$L.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(Bank, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BankDark, {}),
        t2("buy.exchange.bankTransfer")
      ] });
    case "card":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$L.paymentMethodName, children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCard, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(CreditCardDark, {}),
        t2("buy.exchange.creditCard")
      ] });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: methodName });
  }
};
const Deal = ({ deal }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.paymentMethodContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(PaymentMethod, { methodName: deal.payment }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      deal.isBestDeal && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "success", children: t2("buy.exchange.bestDeal") }),
      deal.isFast && /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { type: "warning", children: t2("buy.exchange.fast") })
    ] })
  ] });
};
function ExchangeSelectionRadio({
  disabled: disabled2 = false,
  id: id2,
  children: children2,
  checked: checked2,
  deals,
  onChange: onChange2,
  exchangeName: exchangeName2,
  onClickInfoButton,
  ...props
}) {
  const handleClick = () => {
    if (!disabled2) {
      onChange2();
    }
  };
  const handleKeyDown = (e3) => {
    if (!disabled2 && e3.key === "Enter") {
      onChange2();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.outerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "aria-checked": checked2, onKeyDown: handleKeyDown, "aria-disabled": disabled2, role: "radio", tabIndex: 0, onClick: handleClick, className: style$L.radio, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "input",
        {
          checked: checked2,
          type: "radio",
          id: id2,
          disabled: disabled2,
          onChange: onChange2,
          ...props
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: style$L.radioLabel, htmlFor: id2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$L.container, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$L.text, style$L.exchangeName].join(" "), children: getFormattedName(exchangeName2) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$L.paymentMethodsContainer, children: deals.map((deal) => /* @__PURE__ */ jsxRuntimeExports.jsx(Deal, { deal }, deal.payment)) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => onClickInfoButton(exchangeName2) })
  ] });
}
const container$k = "_container_h94uh_1";
const style$K = {
  container: container$k
};
const MoonPayInfo = ({ cardFee, bankTransferFee }) => {
  const { t: t2 } = useTranslation();
  const formattedCardFee = cardFee && cardFee * 100;
  const formattedBankTransferFee = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/360011931457-Which-fiat-currencies-are-supported-", children: t2("buy.exchange.infoContent.moonpay.fullCurrenciesList") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCard") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.creditDebitCardDetails.cards") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.payment.bankTransferDetails.pix") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("i", { children: t2("buy.exchange.infoContent.moonpay.payment.asteriskText") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://support.moonpay.com/hc/en-gb/articles/4406210084113-What-payment-methods-do-you-support-", children: t2("buy.exchange.infoContent.moonpay.payment.learnMore") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.moonpay.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.creditDebitCard", { fee: formattedCardFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.moonpay.fees.bankTransfer", { fee: formattedBankTransferFee }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://www.moonpay.com/", children: t2("buy.exchange.infoContent.moonpay.fees.learnMore") }) })
  ] });
};
const PocketInfo = ({ bankTransferFee }) => {
  const { t: t2 } = useTranslation();
  const fee2 = bankTransferFee && bankTransferFee * 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$K.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.supportedCurrencies") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.payment.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransfer") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sepa") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.uk") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.payment.bankTransferDetails.sic") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/how-do-I-set-up-my-standing-order", children: t2("buy.exchange.infoContent.pocket.payment.bankTransferReccuring") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.verification.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.pocket.verification.info") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq/are-there-any-limits-with-pocket", children: t2("buy.exchange.infoContent.pocket.verification.link") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: t2("buy.exchange.infoContent.pocket.fees.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("buy.exchange.infoContent.pocket.fees.info", { fee: fee2 }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/", children: t2("buy.exchange.infoContent.pocket.learnMore") }) })
  ] });
};
const RegionInfo = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.exchange.infoContent.region.title") }) });
};
const InfoContent = ({ info: info2, cardFee, bankTransferFee }) => {
  switch (info2) {
    case "moonpay":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MoonPayInfo, { cardFee, bankTransferFee });
    case "pocket":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PocketInfo, { bankTransferFee });
    case "region":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RegionInfo, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {});
};
const buttonBack = "_buttonBack_62uya_17";
const buttonsContainer$1 = "_buttonsContainer_62uya_21";
const container$j = "_container_62uya_27";
const exchangeContainer = "_exchangeContainer_62uya_31";
const header$4 = "_header_62uya_44";
const selectContainer = "_selectContainer_62uya_49";
const label$5 = "_label_62uya_62";
const noExchangeText = "_noExchangeText_62uya_69";
const radioButtonsContainer = "_radioButtonsContainer_62uya_77";
const title$6 = "_title_62uya_81";
const style$J = {
  buttonBack,
  buttonsContainer: buttonsContainer$1,
  container: container$j,
  exchangeContainer,
  header: header$4,
  selectContainer,
  label: label$5,
  noExchangeText,
  radioButtonsContainer,
  title: title$6
};
const dropdown$1 = "_dropdown_9chnx_1";
const flag = "_flag_9chnx_10";
const globe = "_globe_9chnx_14";
const optionsContainer = "_optionsContainer_9chnx_20";
const select$3 = "_select_9chnx_25";
const selectLabelText = "_selectLabelText_9chnx_59";
const singleValueContainer = "_singleValueContainer_9chnx_64";
const styles$j = {
  dropdown: dropdown$1,
  flag,
  globe,
  optionsContainer,
  select: select$3,
  selectLabelText,
  singleValueContainer
};
const SelectedRegionIcon = ({ regionCode }) => {
  const { isDarkMode } = useDarkmode();
  const globe2 = isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeLight, { className: styles$j.globe }) : /* @__PURE__ */ jsxRuntimeExports.jsx(GlobeDark, { className: styles$j.globe });
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: regionCode === "" ? globe2 : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `fi fi-${regionCode} ${styles$j.flag}` }) });
};
const SelectSingleValue = (props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.singleValueContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.selectLabelText, children: label2 }) })
  ] });
};
const SelectOption = (props) => {
  const { label: label2, value } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$j.optionsContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedRegionIcon, { regionCode: value.toLowerCase() }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$j.selectLabelText, children: label2 })
  ] }) });
};
const DropdownIndicator$1 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$j.dropdown }) });
};
const CountrySelect = ({ onChangeRegion, regions, selectedRegion }) => {
  const { t: t2 } = useTranslation();
  const formattedRegionName = new Intl.DisplayNames([instance.language], { type: "region" }).of(selectedRegion) || "";
  const selectedRegionName = selectedRegion === "" ? t2("buy.exchange.selectRegion") : formattedRegionName;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: styles$j.select,
      classNamePrefix: "react-select",
      components: { DropdownIndicator: DropdownIndicator$1, SingleValue: SelectSingleValue, Option: SelectOption, IndicatorSeparator: () => null },
      defaultValue: { label: selectedRegionName, value: selectedRegion },
      isSearchable: true,
      onChange: (e3) => onChangeRegion(e3),
      options: [
        {
          label: t2("buy.exchange.selectRegion") || "",
          value: ""
        },
        ...regions
      ]
    }
  );
};
const Exchange = ({ code, accounts }) => {
  var _a, _b, _c;
  const { t: t2 } = useTranslation();
  const [showPocket, setShowPocket] = reactExports.useState(false);
  const [showMoonpay, setShowMoonpay] = reactExports.useState(false);
  const [selectedRegion, setSelectedRegion] = reactExports.useState("");
  const [selectedExchange, setSelectedExchange] = reactExports.useState("");
  const [regions, setRegions] = reactExports.useState([]);
  const [allExchangeDeals, setAllExchanges] = reactExports.useState();
  const [info2, setInfo] = reactExports.useState();
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState([]);
  const regionList = useLoad(getExchangesByRegion(code));
  const exchangeDeals = useLoad(getExchangeDeals);
  const nativeLocale = useLoad(getNativeLocale);
  const supportedExchanges = useLoad(getExchangeBuySupported(code));
  const config = useLoad(getConfig);
  const account2 = findAccount(accounts, code);
  const name = getCryptoName(t2("buy.info.crypto"), account2);
  const hasOnlyOneSupportedExchange = allExchangeDeals ? allExchangeDeals.exchanges.filter((exchange) => exchange.supported).length === 1 : false;
  reactExports.useEffect(() => {
    getExchangeSupportedAccounts(accounts).then(setSupportedAccounts);
  }, [accounts]);
  reactExports.useEffect(() => {
    if (!regionList || !config) {
      return;
    }
    const regionNames = new Intl.DisplayNames([instance.language], { type: "region" }) || "";
    const regions2 = regionList.regions.map((region) => ({ value: region.code, label: regionNames.of(region.code) }));
    regions2.sort((a2, b2) => a2.label.localeCompare(b2.label, instance.language));
    setRegions(regions2);
    if (config.frontend.selectedExchangeRegion === "") {
      return;
    }
    if (config.frontend.selectedExchangeRegion) {
      setSelectedRegion(config.frontend.selectedExchangeRegion);
      return;
    }
    const userRegion = getRegionNameFromLocale(nativeLocale || "");
    const regionAvailable = !!regionList.regions.find((region) => region.code === userRegion);
    setSelectedRegion(regionAvailable ? userRegion : "");
  }, [regionList, config, nativeLocale]);
  reactExports.useEffect(() => {
    if (!exchangeDeals) {
      return;
    }
    const deals = { exchanges: exchangeDeals.exchanges.map((ex) => ({ ...ex, supported: ex.exchangeName === "pocket" ? showPocket : showMoonpay })) };
    const lowestFee = findLowestFee(deals);
    const exchangesWithBestDeal = findBestDeal(deals, lowestFee);
    setAllExchanges(exchangesWithBestDeal);
  }, [selectedRegion, showMoonpay, showPocket, exchangeDeals]);
  reactExports.useEffect(() => {
    if (hasOnlyOneSupportedExchange && allExchangeDeals && selectedRegion !== "") {
      const exchange = allExchangeDeals.exchanges.filter((exchange2) => exchange2.supported);
      setSelectedExchange(exchange[0].exchangeName);
    }
  }, [hasOnlyOneSupportedExchange, allExchangeDeals, selectedRegion]);
  reactExports.useEffect(() => {
    setSelectedExchange("");
    if (!supportedExchanges) {
      setShowPocket(false);
      setShowMoonpay(false);
      return;
    }
    if (selectedRegion === "") {
      setShowPocket(supportedExchanges.exchanges.includes("pocket"));
      setShowMoonpay(supportedExchanges.exchanges.includes("moonpay"));
      return;
    }
    if (!regionList) {
      return;
    }
    setShowPocket(false);
    setShowMoonpay(false);
    regionList.regions.forEach((region) => {
      if (region.code === selectedRegion) {
        setShowPocket(region.isPocketEnabled);
        setShowMoonpay(region.isMoonpayEnabled);
        return;
      }
    });
  }, [selectedRegion, regionList, supportedExchanges]);
  const goToExchange = () => {
    if (!selectedExchange) {
      return;
    }
    route(`/buy/${selectedExchange}/${code}`);
  };
  const handleChangeRegion = (newValue) => {
    if (newValue) {
      const selectedRegion2 = newValue.value;
      setSelectedRegion(selectedRegion2);
      setConfig({ frontend: { selectedExchangeRegion: selectedRegion2 } });
    }
  };
  const noExchangeAvailable = !showMoonpay && !showPocket;
  const infoFeesDetail = (_a = exchangeDeals == null ? void 0 : exchangeDeals.exchanges.find((exchange) => exchange.exchangeName === info2)) == null ? void 0 : _a.deals;
  const cardFee = infoFeesDetail && ((_b = infoFeesDetail.find((feeDetail) => feeDetail.payment === "card")) == null ? void 0 : _b.fee);
  const bankTransferFee = infoFeesDetail && ((_c = infoFeesDetail.find((feeDetail) => feeDetail.payment === "bank-transfer")) == null ? void 0 : _c.fee);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { medium: true, title: info2 && info2 !== "region" ? getFormattedName(info2) : t2("buy.exchange.region"), onClose: () => setInfo(void 0), open: !!info2, children: info2 && /* @__PURE__ */ jsxRuntimeExports.jsx(InfoContent, { info: info2, cardFee, bankTransferFee }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.exchange.title", { name }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$J.exchangeContainer, "content", "narrow", "isVerticallyCentered"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: style$J.title, children: t2("buy.title", { name }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$J.label, children: t2("buy.exchange.region") }),
          regions.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.selectContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CountrySelect,
                {
                  onChangeRegion: handleChangeRegion,
                  regions,
                  selectedRegion
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(InfoButton, { onClick: () => setInfo("region") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.radioButtonsContainer, children: [
              noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$J.noExchangeText, children: t2("buy.exchange.noExchanges") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !noExchangeAvailable && allExchangeDeals && allExchangeDeals.exchanges.map((exchange) => exchange.supported && /* @__PURE__ */ jsxRuntimeExports.jsx(
                ExchangeSelectionRadio,
                {
                  id: exchange.exchangeName,
                  exchangeName: exchange.exchangeName,
                  deals: exchange.deals,
                  checked: selectedExchange === exchange.exchangeName,
                  onChange: () => setSelectedExchange(exchange.exchangeName),
                  onClickInfoButton: setInfo
                },
                exchange.exchangeName
              )) }),
              !noExchangeAvailable && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$J.buttonsContainer, children: [
                supportedAccounts.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    className: style$J.buttonBack,
                    secondary: true,
                    onClick: () => route("/buy/info"),
                    children: t2("button.back")
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    primary: true,
                    disabled: !selectedExchange,
                    onClick: goToExchange,
                    children: t2("button.next")
                  }
                )
              ] })
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name })
  ] });
};
var dist = {};
var utils$1 = {};
Object.defineProperty(utils$1, "__esModule", { value: true });
utils$1.isOneOf = utils$1.isLiteral = utils$1.isNullish = utils$1.isBoolean = utils$1.isString = utils$1.isObject = void 0;
function isObject(value) {
  return Object(value) === value;
}
utils$1.isObject = isObject;
function isString(value) {
  return typeof value === "string";
}
utils$1.isString = isString;
function isBoolean(value) {
  return typeof value === "boolean";
}
utils$1.isBoolean = isBoolean;
function isNullish(value) {
  return value === void 0 || value === null;
}
utils$1.isNullish = isNullish;
function isLiteral(value, literal) {
  return value === literal;
}
utils$1.isLiteral = isLiteral;
function isOneOf(value, ...literal) {
  return literal.some((l2) => l2 === value);
}
utils$1.isOneOf = isOneOf;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parseMessage = exports.serializeMessage = exports.V0MessageScriptType = exports.V0MessageType = exports.MessageVersion = void 0;
  const utils_1 = utils$1;
  var MessageVersion;
  (function(MessageVersion2) {
    MessageVersion2["V0"] = "0";
  })(MessageVersion = exports.MessageVersion || (exports.MessageVersion = {}));
  var V0MessageType;
  (function(V0MessageType2) {
    V0MessageType2["RequestAddress"] = "requestAddress";
    V0MessageType2["RequestExtendedPublicKey"] = "requestExtendedPublicKey";
    V0MessageType2["VerifyAddress"] = "verifyAddress";
    V0MessageType2["Address"] = "address";
    V0MessageType2["ExtendedPublicKey"] = "extendedPublicKey";
  })(V0MessageType = exports.V0MessageType || (exports.V0MessageType = {}));
  var V0MessageScriptType;
  (function(V0MessageScriptType2) {
    V0MessageScriptType2["P2PKH"] = "p2pkh";
    V0MessageScriptType2["P2WPKH"] = "p2wpkh";
    V0MessageScriptType2["P2SH"] = "p2sh";
    V0MessageScriptType2["P2TR"] = "p2tr";
  })(V0MessageScriptType = exports.V0MessageScriptType || (exports.V0MessageScriptType = {}));
  function serializeMessage(message2) {
    return JSON.stringify(message2);
  }
  exports.serializeMessage = serializeMessage;
  function parseMessage(value) {
    let object = value;
    if (typeof object === "string") {
      try {
        object = JSON.parse(object);
      } catch (e3) {
        throw new Error("could not parse as json");
      }
    }
    if (!(0, utils_1.isObject)(object)) {
      throw new Error("not an object");
    }
    const { version } = object;
    if ((0, utils_1.isLiteral)(version, MessageVersion.V0)) {
      const { type: type2 } = object;
      if (!(0, utils_1.isOneOf)(type2, ...Object.values(V0MessageType))) {
        throw new Error("invalid type");
      }
      if (type2 === V0MessageType.RequestAddress) {
        const { withMessageSignature } = object;
        if (!(0, utils_1.isString)(withMessageSignature) && !(0, utils_1.isNullish)(withMessageSignature)) {
          throw new Error("message signature indicator invalid");
        }
        const { withExtendedPublicKey } = object;
        if (!(0, utils_1.isBoolean)(withExtendedPublicKey) && !(0, utils_1.isNullish)(withExtendedPublicKey)) {
          throw new Error("extended public key indicator invalid");
        }
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType)) {
          throw new Error("script type indicator invalid");
        }
        return {
          version,
          type: type2,
          withMessageSignature,
          withExtendedPublicKey,
          withScriptType
        };
      } else if (type2 === V0MessageType.RequestExtendedPublicKey) {
        const { withScriptType } = object;
        if (!(0, utils_1.isOneOf)(withScriptType, ...Object.values(V0MessageScriptType)) && !(0, utils_1.isNullish)(withScriptType)) {
          throw new Error("script type indicator invalid");
        }
        return {
          version,
          type: type2,
          withScriptType
        };
      } else if (type2 === V0MessageType.VerifyAddress) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress)) {
          throw new Error("bitcoin address missing");
        }
        return {
          version,
          type: type2,
          bitcoinAddress
        };
      } else if (type2 === V0MessageType.Address) {
        const { bitcoinAddress } = object;
        if (!(0, utils_1.isString)(bitcoinAddress)) {
          throw new Error("bitcoin address missing");
        }
        const { signature } = object;
        if (!(0, utils_1.isString)(signature) && !(0, utils_1.isNullish)(signature)) {
          throw new Error("signature invalid");
        }
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey) && !(0, utils_1.isNullish)(extendedPublicKey)) {
          throw new Error("extended public key invalid");
        }
        return {
          version,
          type: type2,
          bitcoinAddress,
          signature,
          extendedPublicKey
        };
      } else if (type2 === V0MessageType.ExtendedPublicKey) {
        const { extendedPublicKey } = object;
        if (!(0, utils_1.isString)(extendedPublicKey)) {
          throw new Error("extended public key missing");
        }
        return {
          version,
          type: type2,
          extendedPublicKey
        };
      } else {
        throw new Error("unsupported type");
      }
    }
    throw new Error("unsupported version");
  }
  exports.parseMessage = parseMessage;
})(dist);
const overlay = "_overlay_12k4v_1";
const activeOverlay = "_activeOverlay_12k4v_16";
const modal = "_modal_12k4v_20";
const activeModal = "_activeModal_12k4v_32";
const active$3 = "_active_12k4v_16";
const small = "_small_12k4v_38";
const medium = "_medium_12k4v_43";
const large = "_large_12k4v_49";
const header$3 = "_header_12k4v_54";
const centered = "_centered_12k4v_64";
const title$5 = "_title_12k4v_68";
const closeButton$1 = "_closeButton_12k4v_74";
const contentContainer = "_contentContainer_12k4v_95";
const slim = "_slim_12k4v_101";
const padded = "_padded_12k4v_105";
const content$1 = "_content_12k4v_95";
const actions = "_actions_12k4v_113";
const confirmationLabel = "_confirmationLabel_12k4v_131";
const confirmationLabelNumber = "_confirmationLabelNumber_12k4v_140";
const disabledLabel = "_disabledLabel_12k4v_146";
const noStep = "_noStep_12k4v_151";
const confirmationInstructions = "_confirmationInstructions_12k4v_155";
const confirm = "_confirm_12k4v_131";
const image = "_image_12k4v_175";
const modalContent = "_modalContent_12k4v_180";
const detail$1 = "_detail_12k4v_189";
const description = "_description_12k4v_213";
const buttons$2 = "_buttons_12k4v_217";
const dialogButtons = "_dialogButtons_12k4v_229";
const style$I = {
  overlay,
  activeOverlay,
  modal,
  activeModal,
  active: active$3,
  small,
  medium,
  large,
  header: header$3,
  centered,
  title: title$5,
  closeButton: closeButton$1,
  contentContainer,
  slim,
  padded,
  content: content$1,
  actions,
  confirmationLabel,
  confirmationLabelNumber,
  disabledLabel,
  noStep,
  confirmationInstructions,
  confirm,
  image,
  modalContent,
  detail: detail$1,
  description,
  buttons: buttons$2,
  dialogButtons
};
class DialogLegacy extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.modalContent = reactExports.createRef();
    this.state = {
      active: false,
      currentTab: 0
    };
    this.handleFocus = (e3) => {
      const input2 = e3.target;
      const index2 = input2.getAttribute("index");
      this.setState({ currentTab: Number(index2) });
    };
    this.focusWithin = () => {
      if (this.modalContent.current) {
        this.focusableChildren = this.modalContent.current.querySelectorAll("a, button, input, textarea");
        const focusables = Array.from(this.focusableChildren);
        for (const c2 of focusables) {
          c2.classList.add("tabbable");
          c2.setAttribute("index", focusables.indexOf(c2).toString());
          c2.addEventListener("focus", this.handleFocus);
        }
        document.addEventListener("keydown", this.handleKeyDown);
      }
    };
    this.focusFirst = () => {
      const focusables = this.focusableChildren;
      if (focusables.length && focusables[0].getAttribute("autofocus") !== "false") {
        focusables[0].focus();
      }
    };
    this.updateIndex = (isNext) => {
      const target = this.getNextIndex(isNext);
      this.setState({ currentTab: target }, () => {
        this.focusableChildren[target].focus();
      });
    };
    this.handleKeyDown = (e3) => {
      const { disableEscape } = this.props;
      const isEsc = e3.keyCode === 27;
      const isTab = e3.keyCode === 9;
      if (!disableEscape && isEsc) {
        this.deactivate();
      } else if (isTab) {
        e3.preventDefault();
      }
      if (isTab && e3.shiftKey) {
        this.updateIndex(false);
      } else if (isTab) {
        this.updateIndex(true);
      }
    };
    this.deactivate = () => {
      if (!this.modal.current || !this.overlay.current) {
        return;
      }
      this.modal.current.classList.remove(style$I.activeModal);
      this.overlay.current.classList.remove(style$I.activeOverlay);
      this.setState({ active: false, currentTab: 0 }, () => {
        document.removeEventListener("keydown", this.handleKeyDown);
        if (this.props.onClose) {
          this.props.onClose();
        }
      });
    };
    this.activate = () => {
      this.setState({ active: true }, () => {
        if (!this.modal.current || !this.overlay.current) {
          return;
        }
        this.overlay.current.classList.add(style$I.activeOverlay);
        this.modal.current.classList.add(style$I.activeModal);
        this.focusWithin();
        this.focusFirst();
      });
    };
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.removeEventListener("keydown", this.handleKeyDown);
  }
  getNextIndex(isNext) {
    const { currentTab } = this.state;
    const focusables = Array.from(this.focusableChildren);
    const arr = isNext ? focusables : focusables.reverse();
    const current = isNext ? currentTab : arr.length - 1 - currentTab;
    let next2 = isNext ? currentTab + 1 : arr.length - currentTab;
    next2 = arr.findIndex((item2, i) => i >= next2 && !item2.hasAttribute("disabled"));
    next2 = next2 < 0 ? arr.findIndex((item2, i) => i <= current && !item2.hasAttribute("disabled")) : next2;
    return isNext ? next2 : arr.length - 1 - next2;
  }
  render() {
    const {
      title: title2,
      small: small2,
      medium: medium2,
      large: large2,
      slim: slim2,
      centered: centered2,
      onClose,
      disabledClose,
      children: children2
    } = this.props;
    const isSmall = small2 ? style$I.small : "";
    const isMedium = medium2 ? style$I.medium : "";
    const isLarge = large2 ? style$I.large : "";
    const isSlim = slim2 ? style$I.slim : "";
    const isCentered = centered2 && !onClose ? style$I.centered : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.overlay, ref: this.overlay, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: [style$I.modal, isSmall, isMedium, isLarge].join(" "),
        ref: this.modal,
        children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$I.header, isCentered].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$I.title, children: title2 }),
            onClose ? /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$I.closeButton, onClick: this.deactivate, disabled: disabledClose, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXDark, { className: "show-in-lightmode" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, { className: "show-in-darkmode" })
            ] }) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              className: [style$I.contentContainer, isSlim].join(" "),
              ref: this.modalContent,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.content, children: children2 })
            }
          )
        ]
      }
    ) });
  }
}
function DialogButtons({ children: children2 }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$I.dialogButtons, children: children2 });
}
let confirmation;
const Confirm = () => {
  const [state, setState] = reactExports.useState({ active: false });
  const { t: t2 } = useTranslation();
  const callback2 = reactExports.useRef(() => {
  });
  confirmation = (message22, cb2, customButtonText2) => {
    callback2.current = cb2;
    setState({
      active: true,
      message: message22,
      customButtonText: customButtonText2
    });
  };
  const respond = (response) => {
    callback2.current(response);
    setState({
      active: false
    });
  };
  const { message: message2, active: active2, customButtonText } = state;
  if (!active2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("dialog.confirmTitle"), onClose: () => respond(false), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: message2 ? message2.split("\n").map((line2, i) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: i === 0 ? "first" : "",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: line2 })
      },
      i
    )) : null }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: () => respond(true), children: customButtonText ? customButtonText : t2("dialog.confirm") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: () => respond(false), children: t2("dialog.cancel") })
    ] })
  ] });
};
const PocketTerms = ({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipPocketDisclaimer: e3.target.checked } });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.welcome.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.welcome.p3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.payment.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.payment.p2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.security.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.security.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://bitbox.swiss/bitbox02/threat-model/", children: t2("buy.pocket.security.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.kyc.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.kyc.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/faq", children: t2("buy.pocket.kyc.link") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$Q.title, children: t2("buy.pocket.data.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("buy.pocket.data.p1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: "https://pocketbitcoin.com/policy/privacy", children: t2("buy.pocket.data.link") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const Pocket = ({ code }) => {
  const { t: t2 } = useTranslation();
  const [height, setHeight] = reactExports.useState(0);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const [verifying, setVerifying] = reactExports.useState(false);
  const iframeURL = useLoad(getPocketURL);
  const config = useLoad(getConfig);
  const accountInfo2 = useLoad(getInfo(code));
  const ref = reactExports.createRef();
  const iframeRef = reactExports.createRef();
  let signing = false;
  let resizeTimerID = void 0;
  const name = "Bitcoin";
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipPocketDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    window.addEventListener("message", onMessage);
    return () => {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("message", onMessage);
    };
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  const sendAddress = (address2, sig) => {
    var _a;
    const { current } = iframeRef;
    if (!current) {
      return;
    }
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      signature: sig
    });
    (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
  };
  const handleRequestAddress = (message2) => {
    signing = true;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "";
    const withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = false;
      if (response.success) {
        sendAddress(response.address, response.signature);
      } else {
        if (response.errorCode !== "userAbort") {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const handleVerifyAddress = (address2) => {
    setVerifying(true);
    verifyAddress(address2, code).then((response) => {
      setVerifying(false);
      if (!response.success) {
        if (response.errorCode === "addressNotFound") {
          alertUser(t2("buy.pocket.usedAddress", { address: address2 }));
        } else {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const sendXpub = () => {
    var _a;
    if (accountInfo2) {
      const bitcoinSimple = accountInfo2.signingConfigurations[0].bitcoinSimple;
      if (bitcoinSimple) {
        const xpub = bitcoinSimple.keyInfo.xpub;
        const { current } = iframeRef;
        if (!current) {
          return;
        }
        const message2 = dist.serializeMessage({
          version: dist.MessageVersion.V0,
          type: dist.V0MessageType.ExtendedPublicKey,
          extendedPublicKey: xpub
        });
        (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
      }
    }
  };
  const handleRequestXpub = () => {
    getTransactionList(code).then((txs) => {
      if (!txs.success) {
        alertUser(t2("transactions.errorLoadTransactions"));
        return;
      }
      if (txs.list.length > 0) {
        confirmation(t2("buy.pocket.previousTransactions"), (result) => {
          if (result) {
            sendXpub();
          }
        });
      } else {
        sendXpub();
      }
    });
  };
  const onMessage = (m2) => {
    if (!iframeURL || !code) {
      return;
    }
    if (m2.origin !== new URL(iframeURL).origin) {
      return;
    }
    try {
      const message2 = dist.parseMessage(m2.data);
      switch (message2.type) {
        case dist.V0MessageType.RequestAddress:
          if (!signing) {
            handleRequestAddress(message2);
          }
          break;
        case dist.V0MessageType.VerifyAddress:
          if (!verifying) {
            handleVerifyAddress(message2.bitcoinAddress);
          }
          break;
        case dist.V0MessageType.RequestExtendedPublicKey:
          handleRequestXpub();
      }
    } catch (e3) {
      console.log(e3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$P.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("buy.info.title", { name }) }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref, className: style$P.container, children: [
        !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          PocketTerms,
          {
            onAgreedTerms: () => setAgreedTerms(true)
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
          !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "iframe",
            {
              onLoad: () => {
                setIframeLoaded(true);
              },
              ref: iframeRef,
              title: "Pocket",
              width: "100%",
              height,
              frameBorder: "0",
              className: style$P.iframe,
              allow: "camera; payment",
              src: iframeURL
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: verifying,
            title: t2("receive.verifyBitBox02"),
            disableEscape: true,
            medium: true,
            centered: true,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: t2("buy.pocket.verifyBitBox02") })
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BuyGuide, { name, exchange: "pocket" })
  ] });
};
const useEsc = (callback2) => {
  reactExports.useEffect(() => {
    const handleKeyDown = (e3) => {
      if (e3.key === "Escape") {
        callback2();
      }
    };
    document.addEventListener("keydown", handleKeyDown);
    return () => document.removeEventListener("keydown", handleKeyDown);
  }, [callback2]);
};
const button$1 = "_button_1djzh_1";
const success$3 = "_success_1djzh_34";
const container$i = "_container_1djzh_38";
const inputField = "_inputField_1djzh_42";
const flexibleHeight = "_flexibleHeight_1djzh_72";
const alignLeft = "_alignLeft_1djzh_76";
const alignRight = "_alignRight_1djzh_80";
const borderLess = "_borderLess_1djzh_84";
const style$H = {
  button: button$1,
  success: success$3,
  container: container$i,
  inputField,
  flexibleHeight,
  alignLeft,
  alignRight,
  borderLess
};
const CopyableInput = ({ alignLeft: alignLeft2, alignRight: alignRight2, borderLess: borderLess2, value, className, disabled: disabled2, flexibleHeight: flexibleHeight2 }) => {
  const [success2, setSuccess] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const textAreaRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setHeight();
  }, []);
  reactExports.useEffect(() => {
    if (success2) {
      setTimeout(() => setSuccess(false), 1500);
    }
  }, [success2]);
  const setHeight = () => {
    const textarea2 = textAreaRef.current;
    if (!textarea2) {
      return;
    }
    const fontSize = window.getComputedStyle(textarea2, null).getPropertyValue("font-size");
    const units = Number(fontSize.replace("px", "")) + 2;
    textarea2.setAttribute("rows", "1");
    textarea2.setAttribute("rows", String(Math.round(textarea2.scrollHeight / units - 2)));
  };
  const onFocus2 = (e3) => {
    e3.currentTarget.focus();
  };
  const copy2 = () => {
    var _a;
    (_a = textAreaRef.current) == null ? void 0 : _a.select();
    if (document.execCommand("copy")) {
      setSuccess(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [
    "flex flex-row flex-start flex-items-start",
    style$H.container,
    className ? className : ""
  ].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        disabled: disabled2,
        readOnly: true,
        onFocus: onFocus2,
        value,
        ref: textAreaRef,
        rows: 1,
        className: [
          style$H.inputField,
          flexibleHeight2 && style$H.flexibleHeight,
          alignLeft2 && style$H.alignLeft,
          alignRight2 && style$H.alignRight,
          borderLess2 && style$H.borderLess
        ].join(" ")
      }
    ),
    disabled2 ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        onClick: copy2,
        className: [style$H.button, success2 && style$H.success, "ignore"].join(" "),
        title: t2("button.copy"),
        children: success2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, {})
      }
    )
  ] });
};
const checkContainer = "_checkContainer_a90m5_2";
const copiedText = "_copiedText_a90m5_14";
const empty$1 = "_empty_a90m5_19";
const hide$1 = "_hide_a90m5_25";
const hiddenInput = "_hiddenInput_a90m5_29";
const outerContainer$1 = "_outerContainer_a90m5_34";
const qrCodeContainer$1 = "_qrCodeContainer_a90m5_40";
const show = "_show_a90m5_53";
const style$G = {
  checkContainer,
  copiedText,
  empty: empty$1,
  hide: hide$1,
  hiddenInput,
  outerContainer: outerContainer$1,
  qrCodeContainer: qrCodeContainer$1,
  show
};
const QRCode = ({
  data,
  size: size2 = 256,
  tapToCopy = true
}) => {
  const qrCode2 = useLoad(data !== void 0 ? getQRCode(data) : null, [data]);
  if (!qrCode2) {
    if (data !== void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$G.empty });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: style$G.empty, style: { verticalAlign: "middle", fill: "currentColor", overflow: "hidden" }, viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { d: "M433.282171 47.939849 94.944396 47.939849c-23.327288 0-42.304502 18.975167-42.304502 42.300408l0 338.341868c0 23.324218 18.977213 42.300408 42.304502 42.300408L433.282171 470.882534c23.324218 0 42.300408-18.97619 42.300408-42.300408L475.582579 90.240257C475.581556 66.915016 456.606389 47.939849 433.282171 47.939849zM438.742533 428.582125c0 3.01159-2.449795 5.461385-5.461385 5.461385L94.944396 434.04351c-3.013637 0-5.465478-2.450818-5.465478-5.461385L89.478917 90.240257c0-3.01159 2.451842-5.461385 5.465478-5.461385L433.282171 84.778872c3.01159 0 5.461385 2.449795 5.461385 5.461385L438.743556 428.582125zM322.914504 173.887352l-117.608581 0c-14.733563 0-26.719548 11.985986-26.719548 26.719548l0 117.608581c0 14.735609 11.985986 26.724665 26.719548 26.724665l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581C349.640192 185.873338 337.651137 173.887352 322.914504 173.887352zM312.801169 308.101123l-97.374748 0 0-97.374748 97.374748 0L312.801169 308.101123zM322.914504 675.606195l-117.608581 0c-14.733563 0-26.719548 11.989055-26.719548 26.724665l0 117.608581c0 14.732539 11.985986 26.719548 26.719548 26.719548l117.608581 0c14.735609 0 26.724665-11.987009 26.724665-26.719548l0-117.608581C349.640192 687.59525 337.651137 675.606195 322.914504 675.606195zM312.801169 809.819966l-97.374748 0 0-97.374748 97.374748 0L312.801169 809.819966zM699.123818 344.940147l117.608581 0c14.735609 0 26.724665-11.989055 26.724665-26.724665l0-117.608581c0-14.733563-11.989055-26.719548-26.724665-26.719548l-117.608581 0c-14.732539 0-26.719548 11.985986-26.719548 26.719548l0 117.608581C672.40427 332.951091 684.391279 344.940147 699.123818 344.940147zM709.243293 210.726376l97.374748 0 0 97.374748-97.374748 0L709.243293 210.726376zM433.282171 546.435277 94.944396 546.435277c-23.327288 0-42.304502 18.97619-42.304502 42.300408L52.639894 927.077553c0 23.325241 18.977213 42.301432 42.304502 42.301432L433.282171 969.378985c23.324218 0 42.300408-18.97619 42.300408-42.301432L475.582579 588.735685C475.581556 565.411467 456.606389 546.435277 433.282171 546.435277zM438.742533 927.077553c0 3.01159-2.449795 5.462408-5.461385 5.462408L94.944396 932.539962c-3.013637 0-5.465478-2.450818-5.465478-5.462408L89.478917 588.735685c0-3.010567 2.451842-5.461385 5.465478-5.461385L433.282171 583.2743c3.01159 0 5.461385 2.450818 5.461385 5.461385L438.743556 927.077553zM590.849836 547.776831c-23.325241 0-42.301432 18.978237-42.301432 42.305525l0 194.649212c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L585.387427 590.082356c0-3.013637 2.450818-5.466502 5.462408-5.466502l204.825992 0c10.172687 0 18.419512-8.246825 18.419512-18.419512s-8.246825-18.419512-18.419512-18.419512L590.849836 547.776831zM588.757175 470.882534l338.341868 0c23.325241 0 42.301432-18.97619 42.301432-42.300408L969.400474 90.240257c0-23.324218-18.97619-42.300408-42.301432-42.300408L588.757175 47.939849c-23.324218 0-42.300408 18.975167-42.300408 42.300408l0 338.341868C546.456766 451.906343 565.432956 470.882534 588.757175 470.882534zM583.295789 90.240257c0-3.01159 2.450818-5.461385 5.461385-5.461385l338.341868 0c3.01159 0 5.462408 2.449795 5.462408 5.461385l0 338.341868c0 3.01159-2.450818 5.461385-5.462408 5.461385L588.757175 434.04351c-3.010567 0-5.461385-2.450818-5.461385-5.461385L583.295789 90.240257zM969.676767 566.196343c0-10.172687-8.246825-18.419512-18.419512-18.419512l-67.50444 0c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l49.084928 0 0 71.009264L779.708158 655.625118c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l171.549098 0c10.172687 0 18.419512-8.246825 18.419512-18.419512 0-0.076748-0.010233-0.151449-0.011256-0.228197 0.001023-0.076748 0.011256-0.150426 0.011256-0.228197L969.676767 566.196343zM630.202099 933.142689l-44.813648 0 0-51.2922c0-10.172687-8.246825-18.419512-18.419512-18.419512s-18.419512 8.246825-18.419512 18.419512l0 69.711711c0 10.172687 8.246825 18.419512 18.419512 18.419512l63.23316 0c10.172687 0 18.419512-8.246825 18.419512-18.419512S640.374786 933.142689 630.202099 933.142689zM834.04981 790.359752c0-10.172687-8.246825-18.419512-18.419512-18.419512L699.257871 771.940241c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 163.013701c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512L717.677383 808.779264 815.630299 808.779264C825.802986 808.779264 834.04981 800.532439 834.04981 790.359752zM951.060781 723.425294c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 194.301288L765.943666 936.146093c-10.172687 0-18.419512 8.246825-18.419512 18.419512s8.246825 18.419512 18.419512 18.419512l185.117115 0c10.172687 0 18.419512-8.246825 18.419512-18.419512L969.480292 741.844805C969.480292 731.672118 961.234491 723.425294 951.060781 723.425294zM655.979182 623.620194c-10.172687 0-18.419512 8.246825-18.419512 18.419512l0 59.869552c0 10.172687 8.246825 18.419512 18.419512 18.419512s18.419512-8.246825 18.419512-18.419512l0-59.869552C674.398694 631.867018 666.151869 623.620194 655.979182 623.620194z" }) });
  }
  if (!qrCode2.success) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: qrCode2.message });
  }
  return tapToCopy ? /* @__PURE__ */ jsxRuntimeExports.jsx(TapToCopyQRCode, { data, qrCodeData: qrCode2.data, size: size2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx("img", { width: size2, height: size2, src: qrCode2.data });
};
const TapToCopyQRCode = ({ data, qrCodeData, size: size2 }) => {
  const inputRef = reactExports.useRef(null);
  const [success2, setSuccess] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (success2) {
      setTimeout(() => setSuccess(false), 1500);
    }
  }, [success2]);
  const handleCopy = () => {
    var _a;
    (_a = inputRef.current) == null ? void 0 : _a.select();
    if (document.execCommand("copy")) {
      setSuccess(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { onClick: handleCopy, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("input", { className: style$G.hiddenInput, ref: inputRef, value: data, readOnly: true }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { width: size2, height: size2 }, className: style$G.outerContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: `${style$G.qrCodeContainer}  ${success2 ? style$G.hide : style$G.show}`, width: size2, height: size2, src: qrCodeData }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$G.checkContainer} ${style$G.show}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check$3, { width: size2 / 2, height: size2 / 2 }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$G.copiedText} ${success2 ? style$G.show : style$G.hide}`, children: t2("receive.qrCodeCopiedMessage") })
  ] });
};
const title$4 = "_title_nnme6_1";
const nextButton = "_nextButton_nnme6_6";
const details = "_details_nnme6_17";
const qrCode = "_qrCode_nnme6_22";
const address$3 = "_address_nnme6_32";
const buttons$1 = "_buttons_nnme6_35";
const verifyButton = "_verifyButton_nnme6_42";
const entry = "_entry_nnme6_46";
const xPubInfo = "_xPubInfo_nnme6_55";
const infoContent = "_infoContent_nnme6_82";
const largeEntry = "_largeEntry_nnme6_86";
const addressField = "_addressField_nnme6_96";
const style$F = {
  title: title$4,
  nextButton,
  details,
  qrCode,
  address: address$3,
  buttons: buttons$1,
  verifyButton,
  entry,
  xPubInfo,
  infoContent,
  largeEntry,
  addressField
};
const SigningConfiguration = ({ account: account2, info: info2, code, signingConfigIndex, children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const getSimpleInfo = () => {
    if (info2.bitcoinSimple !== void 0) {
      return info2.bitcoinSimple;
    }
    return info2.ethereumSimple;
  };
  const config = getSimpleInfo();
  const bitcoinBased = isBitcoinBased(account2.coinCode);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.address, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$F.qrCode, children: bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      QRCode,
      {
        data: config.keyInfo.xpub
      }
    ) : null }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.details, children: [
      account2.isToken ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountSummary.name"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name })
      ] }, "accountname"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Keypath:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.keypath })
      ] }, "keypath"),
      "scriptType" in config ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          t2("accountInfo.scriptType"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: getScriptName(config.scriptType) })
      ] }, "scriptName") : null,
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: "Root fingerprint:" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: config.keyInfo.rootFingerprint })
      ] }, "rootFingerprint"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.entry, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
          account2.isToken ? "Token" : "Coin",
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
          account2.coinName,
          " (",
          account2.coinUnit,
          ")"
        ] })
      ] }, "coinName"),
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$F.entry} ${style$F.largeEntry}`, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { className: "m-right-half", children: [
          t2("accountInfo.extendedPublicKey"),
          ":"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CopyableInput,
          {
            className: "flex-grow",
            alignLeft: true,
            flexibleHeight: true,
            value: config.keyInfo.xpub
          }
        )
      ] }, "xpub") : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$F.buttons, children: [
      bitcoinBased ? /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$F.verifyButton, primary: true, disabled: verifying, onClick: async () => {
        setVerifying(true);
        try {
          const result = await verifyXPub(code, signingConfigIndex);
          if (!result.success) {
            alertUser(result.errorMessage);
          }
        } finally {
          setVerifying(false);
        }
      }, children: t2("accountInfo.verify") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: style$F.verifyButton, primary: true, onClick: () => route(`/account/${code}/receive`), children: t2("receive.verify") }),
      children2
    ] })
  ] });
};
function BitcoinBasedAccountInfoGuide({
  coinName: coinName2
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.xpub"), shown: true }, "guide.accountInfo.xpub"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      text: t2("guide.accountInfo.multipleXPubs.text", { coinName: coinName2 }),
      title: t2("guide.accountInfo.multipleXPubs.title")
    } }, "guide.accountInfo.multipleXPubs"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.privacy") }, "guide.accountInfo.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountInfo.verify") }, "guide.accountInfo.verify")
  ] });
}
const Info = ({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation();
  const info2 = useLoad(getInfo(code));
  const [viewXPub, setViewXPub] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  useEsc(() => route(`/account/${code}`));
  if (!account2 || !info2) {
    return null;
  }
  const config = info2.signingConfigurations[viewXPub];
  const numberOfXPubs = info2.signingConfigurations.length;
  const xpubTypes = info2.signingConfigurations.map((cfg) => {
    var _a;
    return (_a = cfg.bitcoinSimple) == null ? void 0 : _a.scriptType;
  });
  const showNextXPub = () => {
    if (!info2) {
      return;
    }
    const numberOfXPubs2 = info2.signingConfigurations.length;
    setViewXPub((viewXPub + 1) % numberOfXPubs2);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountInfo.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box larger", children: [
        isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: style$F.title, children: t2("accountInfo.extendedPublicKey") }) : null,
        config.bitcoinSimple !== void 0 && numberOfXPubs > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$F.xPubInfo, children: [
          t2("accountInfo.xpubTypeInfo", {
            current: `${viewXPub + 1}`,
            numberOfXPubs: numberOfXPubs.toString(),
            scriptType: config.bitcoinSimple.scriptType.toUpperCase()
          }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$F.nextButton, onClick: showNextXPub, children: t2(`accountInfo.xpubTypeChangeBtn.${xpubTypes[(viewXPub + 1) % numberOfXPubs]}`) })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          SigningConfiguration,
          {
            account: account2,
            code,
            info: config,
            signingConfigIndex: viewXPub,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: true,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          },
          viewXPub
        )
      ] }) })
    ] }) }),
    isBitcoinBased(account2.coinCode) ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitcoinBasedAccountInfoGuide, { coinName: account2.coinName }) : null
  ] });
};
function ReceiveGuide({
  hasMultipleAddresses,
  hasDifferentFormats
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.address") }, "guide.receive.address"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyVerify") }, "guide.receive.whyVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.howVerify") }, "guide.receive.howVerify"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.plugout") }, "guide.receive.plugout"),
    hasMultipleAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.whyMany") }, "guide.receive.whyMany"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.why20") }, "guide.receive.why20"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressChange") }, "guide.receive.addressChange"),
      hasDifferentFormats && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.receive.addressFormats") }, "guide.receive.addressFormats")
    ] })
  ] });
}
const labels = "_labels_1m4jx_1";
const label$4 = "_label_1m4jx_1";
const qrCodeContainer = "_qrCodeContainer_1m4jx_17";
const arrowLeft = "_arrowLeft_1m4jx_22";
const arrowRight = "_arrowRight_1m4jx_23";
const previous = "_previous_1m4jx_37";
const next = "_next_1m4jx_38";
const hide = "_hide_1m4jx_49";
const changeType = "_changeType_1m4jx_58";
const style$E = {
  labels,
  label: label$4,
  qrCodeContainer,
  arrowLeft,
  arrowRight,
  previous,
  next,
  hide,
  changeType
};
const scriptTypes$1 = ["p2wpkh", "p2tr", "p2wpkh-p2sh"];
const getIndexOfMatchingScriptType$1 = (receiveAddresses, scriptType) => {
  if (!receiveAddresses) {
    return -1;
  }
  return receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType);
};
const Receive$2 = ({
  accounts,
  code
}) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const [activeIndex, setActiveIndex] = reactExports.useState(0);
  const [addressType, setAddressType] = reactExports.useState(0);
  const [addressDialog, setAddressDialog] = reactExports.useState();
  const [currentAddresses, setCurrentAddresses] = reactExports.useState();
  const [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  const insured2 = (account2 == null ? void 0 : account2.bitsuranceStatus) === "active";
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const availableScriptTypes = reactExports.useRef();
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  const scriptTypeDialogOpened = !!(addressDialog && (hasManyScriptTypes || insured2));
  useEsc(() => !scriptTypeDialogOpened && !verifying && route(`/account/${code}`));
  reactExports.useEffect(() => {
    if (receiveAddresses) {
      availableScriptTypes.current = scriptTypes$1.filter((sc2) => getIndexOfMatchingScriptType$1(receiveAddresses, sc2) >= 0);
    }
  }, [receiveAddresses]);
  reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType$1(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      if (addressIndex === -1) {
        addressIndex = 0;
      }
      setCurrentAddressIndex(addressIndex);
      setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const handleSubmit = (e3) => {
    if (addressDialog) {
      e3.preventDefault();
      setActiveIndex(0);
      setAddressType(addressDialog.addressType);
      setAddressDialog(void 0);
    }
  };
  const verifyAddress2 = async (addressesIndex) => {
    if (!receiveAddresses || code === void 0) {
      return;
    }
    const connectResult = await connectKeystore(code);
    if (!connectResult.success) {
      return;
    }
    const hasSecureOutput$1 = await hasSecureOutput(code)();
    if (!hasSecureOutput$1.hasSecureOutput) {
      setVerifying("insecure");
      return;
    }
    setVerifying("secure");
    try {
      await verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID);
    } finally {
      setVerifying(false);
    }
  };
  const previous2 = (e3) => {
    e3.preventDefault();
    if (!verifying && activeIndex > 0) {
      setActiveIndex(activeIndex - 1);
    }
  };
  const next2 = (e3, numAddresses) => {
    e3.preventDefault();
    if (!verifying && activeIndex < numAddresses - 1) {
      setActiveIndex(activeIndex + 1);
    }
  };
  let uriPrefix = "";
  if (account2) {
    if (account2.coinCode === "btc" || account2.coinCode === "tbtc") {
      uriPrefix = "bitcoin:";
    } else if (account2.coinCode === "ltc" || account2.coinCode === "tltc") {
      uriPrefix = "litecoin:";
    }
  }
  let address2 = "";
  if (currentAddresses) {
    address2 = currentAddresses[activeIndex].address;
    if (!verifying) {
      address2 = address2.substring(0, 8) + "...";
    }
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: void 0 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$E.labels, children: [
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.previous,
              onClick: previous2,
              children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$E.label, children: [
            t2("receive.label"),
            " ",
            currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
          ] }),
          currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.next,
              onClick: (e3) => next2(e3, currentAddresses.length),
              children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: true, value: address2, flexibleHeight: true }),
        (hasManyScriptTypes || insured2) && /* @__PURE__ */ jsxRuntimeExports.jsx(
          "button",
          {
            className: style$E.changeType,
            onClick: () => setAddressDialog(!addressDialog ? { addressType } : void 0),
            children: t2("receive.changeScriptType")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: handleSubmit, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: scriptTypeDialogOpened, onClose: () => setAddressDialog(void 0), medium: true, title: t2("receive.changeScriptType"), children: [
          availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Radio,
              {
                checked: addressDialog.addressType === i,
                id: scriptType,
                name: "scriptType",
                onChange: () => setAddressDialog({ addressType: i }),
                title: getScriptName(scriptType),
                children: t2(`receive.scriptType.${scriptType}`)
              }
            ),
            scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
          ] }) }, scriptType)),
          insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.bitsuranceWarning") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.done") }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              disabled: verifying !== false,
              onClick: () => verifyAddress2(currentAddressIndex),
              primary: true,
              children: t2("receive.verifyBitBox02")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ButtonLink,
            {
              secondary: true,
              to: `/account/${code}`,
              children: t2("button.back")
            }
          )
        ] }),
        verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.hide }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Dialog,
          {
            open: !!(account2 && verifying),
            title: t2("receive.verifyBitBox02"),
            disableEscape: verifying === "secure",
            onClose: verifying === "insecure" ? () => {
              setVerifying(false);
            } : void 0,
            medium: true,
            centered: true,
            children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-center", children: [
                isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                    coinName: account2.coinName
                  }) }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                  t2("receive.onlyThisCoin.description")
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { data: uriPrefix + address2 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: true }) })
            ] })
          }
        )
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : false,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : false
      }
    )
  ] });
};
const getDeviceList = () => {
  return apiGet("devices/registered");
};
const hasMobileChannel = (deviceID) => {
  return () => {
    return apiGet(`devices/${deviceID}/has-mobile-channel`);
  };
};
const container$h = "_container_1ooxc_1";
const withCloseBtn = "_withCloseBtn_1ooxc_7";
const status$2 = "_status_1ooxc_15";
const success$2 = "_success_1ooxc_21";
const warning$2 = "_warning_1ooxc_25";
const info$1 = "_info_1ooxc_29";
const close$1 = "_close_1ooxc_42";
const style$D = {
  container: container$h,
  withCloseBtn,
  status: status$2,
  success: success$2,
  warning: warning$2,
  info: info$1,
  "close-success": "_close-success_1ooxc_42",
  "close-warning": "_close-warning_1ooxc_46",
  "close-info": "_close-info_1ooxc_50",
  close: close$1
};
const Status = ({
  hidden,
  type: type2 = "warning",
  dismissible,
  className,
  children: children2
}) => {
  const [show2, setShow] = reactExports.useState(dismissible ? false : true);
  const checkConfig = reactExports.useCallback(async () => {
    if (dismissible) {
      const config = await getConfig();
      setShow(!config ? true : !config.frontend[dismissible]);
    }
  }, [dismissible]);
  reactExports.useEffect(() => {
    checkConfig();
  }, [checkConfig]);
  const dismiss = async () => {
    if (!dismissible) {
      return;
    }
    setConfig({
      frontend: {
        [dismissible]: true
      }
    });
    setShow(false);
  };
  if (hidden || !show2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$D.container, style$D[type2], className ? className : "", dismissible ? style$D.withCloseBtn : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$D.status, children: [
    children2,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        hidden: !dismissible,
        className: `${style$D.close} ${style$D[`close-${type2}`]}`,
        onClick: dismiss,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {})
      }
    )
  ] }) });
};
const PairedWarning = ({
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const paired = useLoad(hasMobileChannel(deviceID));
  if (paired) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== false, children: t2("warning.receivePairing") });
};
const useVerifyLabel = (device2) => {
  const { t: t2 } = useTranslation();
  if (device2 === "bitbox") {
    return t2("receive.verifyBitBox01");
  } else if (device2 === "bitbox02") {
    return t2("receive.verifyBitBox02");
  }
  return t2("receive.verify");
};
const VerifyButton = ({
  device: device2,
  forceVerification,
  ...props
}) => {
  const { t: t2 } = useTranslation();
  const verifyLabel = useVerifyLabel(device2);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, ...props, children: forceVerification ? t2("receive.showFull") : verifyLabel });
};
const scriptTypes = ["p2wpkh", "p2tr", "p2wpkh-p2sh"];
const getIndexOfMatchingScriptType = (receiveAddresses, scriptType) => {
  if (!receiveAddresses) {
    return -1;
  }
  return receiveAddresses.findIndex((addrs) => addrs.scriptType !== null && scriptType === addrs.scriptType);
};
const Receive$1 = ({
  accounts,
  code,
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const [verifying, setVerifying] = reactExports.useState(false);
  const [activeIndex, setActiveIndex] = reactExports.useState(0);
  const [addressType, setAddressType] = reactExports.useState(0);
  const [addressDialog, setAddressDialog] = reactExports.useState();
  const [currentAddresses, setCurrentAddresses] = reactExports.useState();
  const [currentAddressIndex, setCurrentAddressIndex] = reactExports.useState(0);
  const account2 = accounts.find(({ code: accountCode }) => accountCode === code);
  const verifyLabel = useVerifyLabel("bitbox");
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const secureOutput = useLoad(hasSecureOutput(code));
  useEsc(() => !verifying && route(`/account/${code}`));
  const availableScriptTypes = reactExports.useRef();
  reactExports.useEffect(() => {
    if (receiveAddresses) {
      availableScriptTypes.current = scriptTypes.filter((sc2) => getIndexOfMatchingScriptType(receiveAddresses, sc2) >= 0);
    }
  }, [receiveAddresses]);
  reactExports.useEffect(() => {
    if (receiveAddresses && availableScriptTypes.current) {
      let addressIndex = availableScriptTypes.current.length > 0 ? getIndexOfMatchingScriptType(receiveAddresses, availableScriptTypes.current[addressType]) : 0;
      if (addressIndex === -1) {
        addressIndex = 0;
      }
      setCurrentAddressIndex(addressIndex);
      setCurrentAddresses(receiveAddresses[addressIndex].addresses);
    }
  }, [addressType, availableScriptTypes, receiveAddresses]);
  const verifyAddress2 = (addressesIndex) => {
    if (receiveAddresses && secureOutput) {
      if (code === void 0) {
        return;
      }
      if (!secureOutput.hasSecureOutput) {
        alertUser(t2("receive.warning.secureOutput"));
        return;
      }
      setVerifying(true);
      verifyAddress$1(code, receiveAddresses[addressesIndex].addresses[activeIndex].addressID).then(() => setVerifying(false));
    }
  };
  const previous2 = (e3) => {
    e3.preventDefault();
    if (!verifying && activeIndex > 0) {
      setActiveIndex(activeIndex - 1);
    }
  };
  const next2 = (e3, numAddresses) => {
    e3.preventDefault();
    if (!verifying && activeIndex < numAddresses - 1) {
      setActiveIndex(activeIndex + 1);
    }
  };
  const forceVerification = secureOutput === void 0 ? true : secureOutput.hasSecureOutput && !secureOutput.optional;
  const enableCopy = !forceVerification;
  let uriPrefix = "";
  if (account2) {
    if (account2.coinCode === "btc" || account2.coinCode === "tbtc") {
      uriPrefix = "bitcoin:";
    } else if (account2.coinCode === "ltc" || account2.coinCode === "tltc") {
      uriPrefix = "litecoin:";
    }
  }
  let address2 = "";
  if (currentAddresses) {
    address2 = currentAddresses[activeIndex].address;
    if (!enableCopy && !verifying) {
      address2 = address2.substring(0, 8) + "...";
    }
  }
  const hasManyScriptTypes = availableScriptTypes.current && availableScriptTypes.current.length > 1;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(PairedWarning, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("receive.title", { accountName: account2 == null ? void 0 : account2.coinName }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large text-center", children: currentAddresses && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { position: "relative" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.qrCodeContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: enableCopy ? uriPrefix + address2 : void 0 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$E.labels, children: [
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$E.previous,
                onClick: previous2,
                children: verifying || activeIndex === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeft, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceLeftActive, { height: "24", width: "24", title: t2("button.previous") })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$E.label, children: [
              t2("receive.label"),
              " ",
              currentAddresses.length > 1 ? `(${activeIndex + 1}/${currentAddresses.length})` : ""
            ] }),
            currentAddresses.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: style$E.next,
                onClick: (e3) => next2(e3, currentAddresses.length),
                children: verifying || activeIndex >= currentAddresses.length - 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRight, { height: "24", width: "24" }) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowCirlceRightActive, { height: "24", width: "24", title: t2("button.next") })
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { disabled: !enableCopy, value: address2, flexibleHeight: true }),
          hasManyScriptTypes && /* @__PURE__ */ jsxRuntimeExports.jsx(
            "button",
            {
              className: style$E.changeType,
              onClick: () => setAddressDialog(!addressDialog ? { addressType } : void 0),
              children: t2("receive.changeScriptType")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: (e3) => {
            e3.preventDefault();
            setActiveIndex(0);
            setAddressType(addressDialog ? addressDialog == null ? void 0 : addressDialog.addressType : addressType);
            setAddressDialog(void 0);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !!addressDialog, medium: true, title: t2("receive.changeScriptType"), children: [
            availableScriptTypes.current && availableScriptTypes.current.map((scriptType, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: addressDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Radio,
                {
                  checked: addressDialog.addressType === i,
                  id: scriptType,
                  name: "scriptType",
                  onChange: () => setAddressDialog({ addressType: i }),
                  title: getScriptName(scriptType),
                  children: t2(`receive.scriptType.${scriptType}`)
                }
              ),
              scriptType === "p2tr" && addressDialog.addressType === i && /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: t2("receive.taprootWarning") })
            ] }) }, scriptType)),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.done") }) })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              VerifyButton,
              {
                device: "bitbox",
                disabled: verifying || secureOutput === void 0,
                forceVerification,
                onClick: () => verifyAddress2(currentAddressIndex)
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ButtonLink,
              {
                secondary: true,
                to: `/account/${code}`,
                children: t2("button.back")
              }
            )
          ] }),
          forceVerification && verifying && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$E.hide }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Dialog,
            {
              open: !!account2 && forceVerification && verifying,
              title: verifyLabel,
              disableEscape: true,
              medium: true,
              centered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: account2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                  isEthereumBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("receive.onlyThisCoin.warning", {
                      coinName: account2.coinName
                    }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                    t2("receive.onlyThisCoin.description")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: uriPrefix + address2 }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("receive.verifyInstruction") })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: address2, flexibleHeight: true }) })
              ]
            }
          )
        ] }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ReceiveGuide,
      {
        hasMultipleAddresses: currentAddresses ? currentAddresses.length > 1 : false,
        hasDifferentFormats: receiveAddresses ? receiveAddresses.length > 1 : false
      }
    )
  ] });
};
const Receive = (props) => {
  const {
    devices,
    deviceIDs
  } = props;
  const deviceID = deviceIDs[0];
  const device2 = deviceIDs.length ? devices[deviceID] : void 0;
  switch (device2) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$1,
        {
          deviceID,
          ...props
        }
      );
    case "bitbox02":
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Receive$2,
        {
          ...props
        }
      );
  }
};
const RatesContext = reactExports.createContext({});
const subscriptions = {};
function handleMessages(payload) {
  if ("type" in payload && payload.data && typeof payload.data === "string" && payload.data in subscriptions && subscriptions[payload.data].length) {
    for (const observer of subscriptions[payload.data]) {
      observer(payload);
    }
  }
}
function subscribe(subject, observer) {
  if (!subscriptions[subject]) {
    subscriptions[subject] = [];
  }
  const observers = subscriptions[subject];
  if (observers.includes(observer)) {
    console.error(`observer already registered for ${subject}`);
  }
  observers.push(observer);
  return () => {
    if (!observers.includes(observer)) {
      console.error("!observers.includes(observer)");
    }
    const index2 = observers.indexOf(observer);
    observers.splice(index2, 1);
  };
}
apiWebsocket(handleMessages);
const syncAccountsList = (cb2) => {
  return subscribeEndpoint("accounts", cb2);
};
const syncAddressesCount = (code) => {
  return (cb2) => {
    return subscribeEndpoint(`account/${code}/synced-addresses-count`, (count) => {
      cb2(count);
    });
  };
};
const statusChanged$1 = (cb2) => {
  const unsubscribe2 = subscribe("statusChanged", (event2) => {
    if (event2.type === "account" && event2.code) {
      cb2(event2.code);
    }
  });
  return unsubscribe2;
};
const syncdone = (cb2) => {
  return subscribe("syncdone", (event2) => {
    if (event2.type === "account" && event2.code) {
      cb2(event2.code);
    }
  });
};
const subscribeCoinHeaders = (coinCode) => (cb2) => subscribeEndpoint(`coins/${coinCode}/headers/status`, cb2);
const setBtcUnit = (unit2) => {
  return apiPost("coins/btc/set-unit", { unit: unit2 });
};
const parseExternalBtcAmount = (amount2) => {
  return apiGet(`coins/btc/parse-external-amount?amount=${amount2}`);
};
const getDeviceInfo$1 = (deviceID) => {
  return apiGet(`devices/${deviceID}/info`);
};
const space = "_space_tpxrt_1";
const style$C = {
  space
};
const Amount = ({ amount: amount2, unit: unit2, removeBtcTrailingZeroes, alwaysShowAmounts = false }) => {
  const { hideAmounts } = reactExports.useContext(AppContext);
  const formatSats = (amount22) => {
    const blocks = [];
    const blockSize = 3;
    for (let i = amount22.length; i > 0; i -= blockSize) {
      const start = Math.max(0, i - blockSize);
      blocks.push(
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: start === 0 ? "" : style$C.space, children: amount22.slice(start, i) }, "block_" + blocks.length)
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { "data-testid": "amountBlocks", children: blocks.reverse() });
  };
  const formatBtc = (amount22) => {
    const dot2 = amount22.indexOf(".");
    if (dot2 === -1) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount22 });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "amountBlocks", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: amount22.slice(0, dot2 + 3) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$C.space, children: amount22.slice(dot2 + 3, dot2 + 6) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$C.space, children: amount22.slice(dot2 + 6, dot2 + 9) })
    ] });
  };
  if (hideAmounts && !alwaysShowAmounts) {
    return "***";
  }
  switch (unit2) {
    case "BTC":
    case "TBTC":
    case "LTC":
    case "TLTC":
      if (removeBtcTrailingZeroes && amount2.includes(".")) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2.replace(/\.?0+$/, "") });
      } else {
        return formatBtc(amount2);
      }
    case "sat":
    case "tsat":
      return formatSats(amount2);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: amount2 });
};
const rates = "_rates_19qqe_1";
const unit$1 = "_unit_19qqe_8";
const unitAction = "_unitAction_19qqe_13";
const fiatRow = "_fiatRow_19qqe_20";
const availableFiatAmount = "_availableFiatAmount_19qqe_24";
const availableFiatUnitNoAction = "_availableFiatUnitNoAction_19qqe_29";
const availableFiatUnit = "_availableFiatUnit_19qqe_29";
const notAvailable = "_notAvailable_19qqe_46";
const style$B = {
  rates,
  unit: unit$1,
  unitAction,
  fiatRow,
  availableFiatAmount,
  availableFiatUnitNoAction,
  availableFiatUnit,
  notAvailable
};
const currenciesWithDisplayName = [
  { currency: "AUD", displayName: "Australian Dollar" },
  { currency: "BRL", displayName: "Brazilian Real" },
  { currency: "CAD", displayName: "Canadian Dollar" },
  { currency: "CHF", displayName: "Swiss franc" },
  { currency: "CNY", displayName: "Chinese Yuan" },
  { currency: "CZK", displayName: "Czech Koruna" },
  { currency: "EUR", displayName: "Euro" },
  { currency: "GBP", displayName: "British Pound" },
  { currency: "HKD", displayName: "Hong Kong Dollar" },
  { currency: "ILS", displayName: "Israeli New Shekel" },
  { currency: "JPY", displayName: "Japanese Yen" },
  { currency: "KRW", displayName: "South Korean Won" },
  { currency: "NOK", displayName: "Norwegian Krone" },
  { currency: "PLN", displayName: "Polish Zloty" },
  { currency: "RUB", displayName: "Russian ruble" },
  { currency: "SEK", displayName: "Swedish Krona" },
  { currency: "SGD", displayName: "Singapore Dollar" },
  { currency: "USD", displayName: "United States Dollar" },
  { currency: "BTC", displayName: "Bitcoin" }
];
function Conversion({
  amount: amount2,
  tableRow,
  unstyled,
  skipUnit,
  noAction,
  sign,
  noBtcZeroes,
  alwaysShowAmounts = false
}) {
  const { rotateFiat, defaultCurrency: defaultCurrency2, btcUnit } = reactExports.useContext(RatesContext);
  let formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: "---" });
  let isAvailable = false;
  let activeUnit = defaultCurrency2;
  if (defaultCurrency2 === "BTC" && btcUnit === "sat") {
    activeUnit = "sat";
  }
  if (amount2 && amount2.conversions && amount2.conversions[defaultCurrency2] && amount2.conversions[defaultCurrency2] !== "") {
    isAvailable = true;
    formattedAmount = /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts, amount: amount2.conversions[defaultCurrency2], unit: activeUnit, removeBtcTrailingZeroes: !!noBtcZeroes });
  }
  if (tableRow) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: unstyled ? "" : style$B.fiatRow, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatAmount, children: formattedAmount }),
      !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatUnit, onClick: rotateFiat, children: activeUnit }),
      noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: unstyled ? "" : style$B.availableFiatUnitNoAction, children: activeUnit })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: `${style$B.rates} ${!isAvailable ? style$B.notAvailable : ""}`, children: [
    isAvailable ? sign : "",
    formattedAmount,
    " ",
    !skipUnit && !noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$B.unitAction, onClick: rotateFiat, children: activeUnit }),
    !skipUnit && noAction && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$B.unit, children: activeUnit })
  ] });
}
const formattedCurrencies = currenciesWithDisplayName.map((fiat2) => ({ label: `${fiat2.displayName} (${fiat2.currency})`, value: fiat2.currency }));
const FiatConversion = Conversion;
const balanceTable$1 = "_balanceTable_m2hui_1";
const availableAmount = "_availableAmount_m2hui_27";
const availableUnit = "_availableUnit_m2hui_32";
const pendingBalance = "_pendingBalance_m2hui_37";
const style$A = {
  balanceTable: balanceTable$1,
  availableAmount,
  availableUnit,
  pendingBalance
};
const Balance = ({
  balance: balance2,
  noRotateFiat
}) => {
  const { t: t2 } = useTranslation();
  if (!balance2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("header", { className: style$A.balance });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: style$A.balance, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("table", { className: style$A.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { "data-testid": "availableBalance", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$A.availableAmount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.available.amount,
            unit: balance2.available.unit,
            removeBtcTrailingZeroes: true
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: style$A.availableUnit, children: balance2.available.unit })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FiatConversion,
        {
          amount: balance2.available,
          tableRow: true,
          noAction: noRotateFiat,
          noBtcZeroes: true
        }
      )
    ] }) }),
    balance2.hasIncoming && /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$A.pendingBalance, children: [
      t2("account.incoming"),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { "data-testid": "incomingBalance", children: [
        "+",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Amount,
          {
            amount: balance2.incoming.amount,
            unit: balance2.incoming.unit,
            removeBtcTrailingZeroes: true
          }
        ),
        " ",
        balance2.incoming.unit,
        " /",
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$A.incomingConversion, children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.incoming, noBtcZeroes: true })
        ] })
      ] })
    ] })
  ] });
};
const translate = withTranslation;
const row$2 = "_row_1qpuo_1";
const rowCustomFee = "_rowCustomFee_1qpuo_6";
const column = "_column_1qpuo_12";
const priority = "_priority_1qpuo_38";
const fee$1 = "_fee_1qpuo_42";
const feeCustom = "_feeCustom_1qpuo_91";
const feeDescription = "_feeDescription_1qpuo_95";
const feeProposed = "_feeProposed_1qpuo_96";
const customFeeUnit = "_customFeeUnit_1qpuo_112";
const style$z = {
  row: row$2,
  rowCustomFee,
  column,
  priority,
  fee: fee$1,
  feeCustom,
  feeDescription,
  feeProposed,
  customFeeUnit
};
const FeeTargets = ({
  accountCode,
  coinCode,
  disabled: disabled2,
  fiatUnit,
  proposedFee,
  customFee,
  showCalculatingFeeLabel,
  onFeeTargetChange,
  onCustomFee,
  error: error3
}) => {
  const { t: t2 } = useTranslation();
  const config = useLoad(getConfig);
  const [feeTarget, setFeeTarget] = reactExports.useState("");
  const [options2, setOptions] = reactExports.useState(null);
  const [noFeeTargets, setNoFeeTargets] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  const focusInput = reactExports.useCallback(() => {
    if (!disabled2 && inputRef.current && inputRef.current.autofocus) {
      inputRef.current.focus();
    }
  }, [disabled2]);
  reactExports.useEffect(() => {
    getFeeTargetList(accountCode).then(({ feeTargets, defaultFeeTarget }) => {
      if (config) {
        const expert = config.frontend.expertFee || feeTargets.length === 0;
        const options22 = feeTargets.map(({ code, feeRateInfo }) => ({
          value: code,
          text: t2(`send.feeTarget.label.${code}`) + (expert && feeRateInfo ? ` (${feeRateInfo})` : "")
        }));
        if (expert) {
          options22.push({
            value: "custom",
            text: t2("send.feeTarget.label.custom")
          });
        }
        setOptions(options22);
        setFeeTarget(defaultFeeTarget);
        onFeeTargetChange(defaultFeeTarget);
        if (feeTargets.length === 0) {
          setNoFeeTargets(true);
        }
      }
    }).catch(console.error);
    focusInput();
  }, [t2, focusInput, accountCode, config, onFeeTargetChange]);
  const handleFeeTargetChange = (event2) => {
    const target = event2.target;
    const value = target.options[target.selectedIndex].value;
    setFeeTarget(value);
    onFeeTargetChange(value);
  };
  const handleCustomFee = (event2) => {
    onCustomFee(event2.target.value);
  };
  const getProposeFeeText = () => {
    if (!proposedFee) {
      return "";
    }
    const { amount: amount2, unit: unit2, conversions } = proposedFee;
    return `${amount2} ${unit2} ${conversions ? ` = ${conversions[fiatUnit === "sat" ? "BTC" : fiatUnit]} ${fiatUnit}` : ""}`;
  };
  if (options2 === null) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.priority"),
        id: "feetarget",
        placeholder: t2("send.feeTarget.placeholder"),
        disabled: true,
        value: "",
        transparent: true
      }
    );
  }
  const isCustom = feeTarget === "custom";
  const hasOptions = options2.length > 0;
  const proposeFeeText = getProposeFeeText();
  const preventFocus = document.activeElement && document.activeElement.nodeName === "INPUT";
  return hasOptions ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    !isCustom ? showCalculatingFeeLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        disabled: true,
        label: t2("send.priority"),
        placeholder: t2("send.feeTarget.placeholder"),
        value: "",
        transparent: true
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Select$1,
      {
        className: style$z.priority,
        label: t2("send.priority"),
        id: "feeTarget",
        disabled: disabled2,
        onChange: handleFeeTargetChange,
        value: feeTarget,
        options: options2
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$z.rowCustomFee, children: [
      noFeeTargets ? /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { small: true, type: "warning", children: t2("send.noFeeTargets") }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$z.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select$1,
        {
          className: style$z.priority,
          label: t2("send.priority"),
          id: "feeTarget",
          disabled: disabled2,
          onChange: handleFeeTargetChange,
          value: feeTarget,
          options: options2
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$z.column, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          type: disabled2 ? "text" : "number",
          min: "0",
          step: "any",
          autoFocus: !preventFocus,
          align: "right",
          className: `${style$z.fee} ${style$z.feeCustom}`,
          disabled: disabled2,
          label: t2("send.feeTarget.customLabel", {
            context: isEthereumBased(coinCode) ? "eth" : ""
          }),
          id: "proposedFee",
          placeholder: t2("send.fee.customPlaceholder"),
          error: error3,
          transparent: true,
          onInput: handleCustomFee,
          ref: inputRef,
          value: customFee,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$z.customFeeUnit, children: customFeeUnit$1(coinCode) })
        }
      ) })
    ] }),
    feeTarget && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      showCalculatingFeeLabel || proposeFeeText ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$z.feeProposed, children: [
        t2("send.fee.label"),
        ":",
        " ",
        showCalculatingFeeLabel ? t2("send.feeTarget.placeholder") : proposeFeeText
      ] }) : null,
      !isCustom ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$z.feeDescription, children: [
        t2("send.feeTarget.estimate"),
        " ",
        t2(`send.feeTarget.description.${feeTarget}`, {
          context: getCoinCode(coinCode) || ""
        })
      ] }) : null
    ] })
  ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      disabled: true,
      label: t2("send.fee.label"),
      id: "proposedFee",
      placeholder: t2("send.fee.placeholder"),
      error: error3,
      transparent: true,
      value: proposeFeeText
    }
  );
};
const syncDeviceList = (cb2) => {
  return subscribeEndpoint("devices/registered", cb2);
};
const statusChanged = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("statusChanged", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2();
    }
  });
  return unsubscribe2;
};
const channelHashChanged = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("channelHashChanged", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2(deviceID);
    }
  });
  return unsubscribe2;
};
const attestationCheckDone = (deviceID, cb2) => {
  const unsubscribe2 = subscribe("attestationCheckDone", (event2) => {
    if (event2.type === "device" && event2.deviceID === deviceID) {
      cb2();
    }
  });
  return unsubscribe2;
};
const signProgress = (cb2) => {
  const unsubscribe2 = subscribe("signProgress", (event2) => {
    if ("type" in event2 && event2.type === "device" && event2.data === "signProgress") {
      cb2(event2.meta);
    }
  });
  return unsubscribe2;
};
const signConfirm = (cb2) => {
  const unsubscribe2 = subscribe("signConfirm", (event2) => {
    if ("type" in event2 && event2.type === "device" && event2.data === "signConfirm") {
      cb2();
    }
  });
  return unsubscribe2;
};
function unsubscribe(unsubscribeList) {
  for (const unsubscribeCallback of unsubscribeList) {
    unsubscribeCallback();
  }
  unsubscribeList.splice(0, unsubscribeList.length);
}
const approve$1 = "" + new URL("hold.png", import.meta.url).href;
const reject = "" + new URL("tap.png", import.meta.url).href;
class WaitDialog extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.overlay = reactExports.createRef();
    this.modal = reactExports.createRef();
    this.state = {
      active: false
    };
    this.handleKeyDown = (e3) => {
      const activeElement = document.activeElement;
      if (activeElement && activeElement instanceof HTMLElement) {
        activeElement.blur();
      }
      e3.preventDefault();
      e3.stopPropagation();
    };
    this.activate = () => {
      this.setState({ active: true }, () => {
        if (!this.overlay.current || !this.modal.current) {
          return;
        }
        this.overlay.current.classList.add(style$13.activeOverlay);
        this.modal.current.classList.add(style$13.activeModal);
      });
    };
  }
  UNSAFE_componentWillMount() {
    document.body.addEventListener("keydown", this.handleKeyDown);
  }
  componentDidMount() {
    setTimeout(this.activate, 10);
  }
  componentWillUnmount() {
    document.body.removeEventListener("keydown", this.handleKeyDown);
  }
  render() {
    const {
      t: t2,
      includeDefault,
      prequel,
      title: title2,
      paired = false,
      touchConfirm = true,
      children: children2
    } = this.props;
    const defaultContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      prequel && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: prequel }),
      paired ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$13.confirmationLabel, touchConfirm && paired ? style$13.disabledLabel : "", "m-top-none"].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$13.confirmationLabelNumber, children: "1." }),
          t2("confirm.infoWhenPaired")
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: [style$13.confirmationLabel, !touchConfirm && paired ? style$13.disabledLabel : ""].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$13.confirmationLabelNumber, children: "2." }),
          t2("confirm.info")
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: [style$13.confirmationLabel, style$13.noStep, "m-top-none"].join(" "), children: t2("confirm.info") }),
      touchConfirm && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-between flex-items-stretch", style$13.confirmationInstructions].join(" "), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$13.image, src: reject, alt: "Reject" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.abortInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-red", children: t2("confirm.abortInfoRedText") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: style$13.image, src: approve$1, alt: "Approve" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            t2("confirm.approveInfo"),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-green", children: t2("confirm.approveInfoGreenText") })
          ] })
        ] })
      ] })
    ] });
    const hasChildren = React.Children.toArray(children2).length > 0;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: style$13.overlay,
        ref: this.overlay,
        style: { zIndex: 10001 },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$13.modal, style$13.open].join(" "), ref: this.modal, children: [
          title2 && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$13.title, children: title2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.contentContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.content, children: [
            hasChildren && includeDefault ? defaultContent : null,
            hasChildren ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-start", children: children2 }) : defaultContent
          ] }) })
        ] })
      }
    );
  }
}
const TranslatedWaitDialog = translate()(WaitDialog);
const confirmItem = "_confirmItem_1e5e5_1";
const confirmationValue = "_confirmationValue_1e5e5_6";
const total = "_total_1e5e5_15";
const style$y = {
  confirmItem,
  confirmationValue,
  total
};
const ConfirmingWaitDialog = ({
  paired,
  baseCurrencyUnit,
  note: note2,
  hasSelectedUTXOs,
  selectedUTXOs,
  coinCode,
  transactionStatus,
  transactionDetails
}) => {
  const { t: t2 } = useTranslation();
  const { isConfirming, signConfirm: signConfirm2, signProgress: signProgress2 } = transactionStatus;
  const {
    proposedFee,
    proposedAmount,
    proposedTotal,
    customFee,
    feeTarget,
    recipientAddress,
    fiatUnit
  } = transactionDetails;
  if (!isConfirming) {
    return null;
  }
  const confirmPrequel = signProgress2 && signProgress2.steps > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    t2("send.signprogress.description", {
      steps: signProgress2.steps.toString()
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
    t2("send.signprogress.label"),
    ": ",
    signProgress2.step,
    "/",
    signProgress2.steps
  ] }) : void 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    TranslatedWaitDialog,
    {
      title: t2("send.confirm.title"),
      prequel: confirmPrequel,
      paired,
      touchConfirm: signConfirm2,
      includeDefault: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.address.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: recipientAddress || "N/A" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.amount.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedAmount && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedAmount.amount, unit: proposedAmount.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedAmount && proposedAmount.unit || "N/A" })
            ] }, "proposedAmount"),
            proposedAmount && proposedAmount.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedAmount.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("note.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: note2 })
        ] }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$y.confirmItem, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { children: [
            t2("send.fee.label"),
            feeTarget ? " (" + t2(`send.feeTarget.label.${feeTarget}`) + ")" : ""
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              proposedFee && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedFee.amount, unit: proposedFee.unit }) || "N/A",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedFee && proposedFee.unit || "N/A" })
            ] }, "amount"),
            proposedFee && proposedFee.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedFee.conversions[fiatUnit], unit: baseCurrencyUnit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] }, "conversation"),
            customFee ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                "(",
                customFee,
                " ",
                customFeeUnit$1(coinCode),
                ")"
              ] })
            ] }, "customFee") : null
          ] })
        ] }),
        hasSelectedUTXOs && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$y.confirmItem].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.selected-coins") }),
          selectedUTXOs.map((uxto, i) => /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$y.confirmationValue, children: uxto }, `selectedCoin-${i}`))
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$y.confirmItem, style$y.total].join(" "), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("send.confirm.total") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: proposedTotal && /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedTotal.amount, unit: proposedTotal.unit }) || "N/A" }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: proposedTotal && proposedTotal.unit || "N/A" })
            ] }),
            proposedTotal && proposedTotal.conversions && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-gray", children: " / " }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: proposedTotal.conversions[fiatUnit], unit: baseCurrencyUnit }) }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: baseCurrencyUnit })
            ] })
          ] })
        ] })
      ]
    }
  );
};
const SendGuide = ({ coinCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.whyFee") }, "guide.send.whyFee"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.priority") }, "guide.send.priority"),
    isBitcoinBased(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.fee") }, "guide.send.fee"),
    isBitcoinOnly(coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.change") }, "guide.send.change"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.revert") }, "guide.send.revert"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.send.plugout") }, "guide.send.plugout")
  ] });
};
const MessageWaitDialog = ({ isShown, messageType }) => {
  if (!isShown) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-center flex-items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(IconAndMessage, { messageType }) }) });
};
const IconAndMessage = ({ messageType }) => {
  const { t: t2 } = useTranslation();
  switch (messageType) {
    case "sent":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, { style: { height: 18, marginRight: "1rem" } }),
        t2("send.success")
      ] });
    case "abort":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { alt: "Abort", style: { height: 18, marginRight: "1rem" } }),
        t2("send.abort")
      ] });
    default:
      return null;
  }
};
const useMediaQuery = (query) => {
  const getMatches = (query2) => window.matchMedia(query2).matches;
  const [matches, setMatches] = reactExports.useState(getMatches(query));
  reactExports.useEffect(() => {
    const handleChange = () => {
      setMatches(getMatches(query));
    };
    const matchMedia = window.matchMedia(query);
    handleChange();
    matchMedia.addEventListener("change", handleChange);
    return () => {
      matchMedia.removeEventListener("change", handleChange);
    };
  }, [query]);
  return matches;
};
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep, importerUrl);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i = links.length - 1; i >= 0; i--) {
        const link3 = links[i];
        if (link3.href === dep && (!isCss || link3.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link2 = document.createElement("link");
    link2.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link2.as = "script";
      link2.crossOrigin = "";
    }
    link2.href = dep;
    document.head.appendChild(link2);
    if (isCss) {
      return new Promise((res, rej) => {
        link2.addEventListener("load", res);
        link2.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule()).catch((err) => {
    const e3 = new Event("vite:preloadError", { cancelable: true });
    e3.payload = err;
    window.dispatchEvent(e3);
    if (!e3.defaultPrevented) {
      throw err;
    }
  });
};
let e$1 = class e {
  constructor(a2, b2, c2, d2, f2) {
    this._legacyCanvasSize = e.DEFAULT_CANVAS_SIZE;
    this._preferredCamera = "environment";
    this._maxScansPerSecond = 25;
    this._lastScanTimestamp = -1;
    this._destroyed = this._flashOn = this._paused = this._active = false;
    this.$video = a2;
    this.$canvas = document.createElement("canvas");
    c2 && "object" === typeof c2 ? this._onDecode = b2 : (c2 || d2 || f2 ? console.warn("You're using a deprecated version of the QrScanner constructor which will be removed in the future") : console.warn("Note that the type of the scan result passed to onDecode will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true."), this._legacyOnDecode = b2);
    b2 = "object" === typeof c2 ? c2 : {};
    this._onDecodeError = b2.onDecodeError || ("function" === typeof c2 ? c2 : this._onDecodeError);
    this._calculateScanRegion = b2.calculateScanRegion || ("function" === typeof d2 ? d2 : this._calculateScanRegion);
    this._preferredCamera = b2.preferredCamera || f2 || this._preferredCamera;
    this._legacyCanvasSize = "number" === typeof c2 ? c2 : "number" === typeof d2 ? d2 : this._legacyCanvasSize;
    this._maxScansPerSecond = b2.maxScansPerSecond || this._maxScansPerSecond;
    this._onPlay = this._onPlay.bind(this);
    this._onLoadedMetaData = this._onLoadedMetaData.bind(this);
    this._onVisibilityChange = this._onVisibilityChange.bind(this);
    this._updateOverlay = this._updateOverlay.bind(this);
    a2.disablePictureInPicture = true;
    a2.playsInline = true;
    a2.muted = true;
    let h2 = false;
    a2.hidden && (a2.hidden = false, h2 = true);
    document.body.contains(a2) || (document.body.appendChild(a2), h2 = true);
    c2 = a2.parentElement;
    if (b2.highlightScanRegion || b2.highlightCodeOutline) {
      d2 = !!b2.overlay;
      this.$overlay = b2.overlay || document.createElement("div");
      f2 = this.$overlay.style;
      f2.position = "absolute";
      f2.display = "none";
      f2.pointerEvents = "none";
      this.$overlay.classList.add("scan-region-highlight");
      if (!d2 && b2.highlightScanRegion) {
        this.$overlay.innerHTML = '<svg class="scan-region-highlight-svg" viewBox="0 0 238 238" preserveAspectRatio="none" style="position:absolute;width:100%;height:100%;left:0;top:0;fill:none;stroke:#e9b213;stroke-width:4;stroke-linecap:round;stroke-linejoin:round"><path d="M31 2H10a8 8 0 0 0-8 8v21M207 2h21a8 8 0 0 1 8 8v21m0 176v21a8 8 0 0 1-8 8h-21m-176 0H10a8 8 0 0 1-8-8v-21"/></svg>';
        try {
          this.$overlay.firstElementChild.animate({ transform: [
            "scale(.98)",
            "scale(1.01)"
          ] }, { duration: 400, iterations: Infinity, direction: "alternate", easing: "ease-in-out" });
        } catch (m2) {
        }
        c2.insertBefore(this.$overlay, this.$video.nextSibling);
      }
      b2.highlightCodeOutline && (this.$overlay.insertAdjacentHTML("beforeend", '<svg class="code-outline-highlight" preserveAspectRatio="none" style="display:none;width:100%;height:100%;fill:none;stroke:#e9b213;stroke-width:5;stroke-dasharray:25;stroke-linecap:round;stroke-linejoin:round"><polygon/></svg>'), this.$codeOutlineHighlight = this.$overlay.lastElementChild);
    }
    this._scanRegion = this._calculateScanRegion(a2);
    requestAnimationFrame(() => {
      let m2 = window.getComputedStyle(a2);
      "none" === m2.display && (a2.style.setProperty("display", "block", "important"), h2 = true);
      "visible" !== m2.visibility && (a2.style.setProperty("visibility", "visible", "important"), h2 = true);
      h2 && (console.warn("QrScanner has overwritten the video hiding style to avoid Safari stopping the playback."), a2.style.opacity = "0", a2.style.width = "0", a2.style.height = "0", this.$overlay && this.$overlay.parentElement && this.$overlay.parentElement.removeChild(this.$overlay), delete this.$overlay, delete this.$codeOutlineHighlight);
      this.$overlay && this._updateOverlay();
    });
    a2.addEventListener("play", this._onPlay);
    a2.addEventListener("loadedmetadata", this._onLoadedMetaData);
    document.addEventListener("visibilitychange", this._onVisibilityChange);
    window.addEventListener("resize", this._updateOverlay);
    this._qrEnginePromise = e.createQrEngine();
  }
  static set WORKER_PATH(a2) {
    console.warn("Setting QrScanner.WORKER_PATH is not required and not supported anymore. Have a look at the README for new setup instructions.");
  }
  static async hasCamera() {
    try {
      return !!(await e.listCameras(false)).length;
    } catch (a2) {
      return false;
    }
  }
  static async listCameras(a2 = false) {
    if (!navigator.mediaDevices)
      return [];
    let b2 = async () => (await navigator.mediaDevices.enumerateDevices()).filter((d2) => "videoinput" === d2.kind), c2;
    try {
      a2 && (await b2()).every((d2) => !d2.label) && (c2 = await navigator.mediaDevices.getUserMedia({ audio: false, video: true }));
    } catch (d2) {
    }
    try {
      return (await b2()).map((d2, f2) => ({ id: d2.deviceId, label: d2.label || (0 === f2 ? "Default Camera" : `Camera ${f2 + 1}`) }));
    } finally {
      c2 && (console.warn("Call listCameras after successfully starting a QR scanner to avoid creating a temporary video stream"), e._stopVideoStream(c2));
    }
  }
  async hasFlash() {
    let a2;
    try {
      if (this.$video.srcObject) {
        if (!(this.$video.srcObject instanceof MediaStream))
          return false;
        a2 = this.$video.srcObject;
      } else
        a2 = (await this._getCameraStream()).stream;
      return "torch" in a2.getVideoTracks()[0].getSettings();
    } catch (b2) {
      return false;
    } finally {
      a2 && a2 !== this.$video.srcObject && (console.warn("Call hasFlash after successfully starting the scanner to avoid creating a temporary video stream"), e._stopVideoStream(a2));
    }
  }
  isFlashOn() {
    return this._flashOn;
  }
  async toggleFlash() {
    this._flashOn ? await this.turnFlashOff() : await this.turnFlashOn();
  }
  async turnFlashOn() {
    if (!this._flashOn && !this._destroyed && (this._flashOn = true, this._active && !this._paused))
      try {
        if (!await this.hasFlash())
          throw "No flash available";
        await this.$video.srcObject.getVideoTracks()[0].applyConstraints({ advanced: [{ torch: true }] });
      } catch (a2) {
        throw this._flashOn = false, a2;
      }
  }
  async turnFlashOff() {
    this._flashOn && (this._flashOn = false, await this._restartVideoStream());
  }
  destroy() {
    this.$video.removeEventListener("loadedmetadata", this._onLoadedMetaData);
    this.$video.removeEventListener("play", this._onPlay);
    document.removeEventListener(
      "visibilitychange",
      this._onVisibilityChange
    );
    window.removeEventListener("resize", this._updateOverlay);
    this._destroyed = true;
    this._flashOn = false;
    this.stop();
    e._postWorkerMessage(this._qrEnginePromise, "close");
  }
  async start() {
    if (this._destroyed)
      throw Error("The QR scanner can not be started as it had been destroyed.");
    if (!this._active || this._paused) {
      if ("https:" !== window.location.protocol && console.warn("The camera stream is only accessible if the page is transferred via https."), this._active = true, !document.hidden)
        if (this._paused = false, this.$video.srcObject)
          await this.$video.play();
        else
          try {
            let { stream: a2, facingMode: b2 } = await this._getCameraStream();
            !this._active || this._paused ? e._stopVideoStream(a2) : (this._setVideoMirror(b2), this.$video.srcObject = a2, await this.$video.play(), this._flashOn && (this._flashOn = false, this.turnFlashOn().catch(() => {
            })));
          } catch (a2) {
            if (!this._paused)
              throw this._active = false, a2;
          }
    }
  }
  stop() {
    this.pause();
    this._active = false;
  }
  async pause(a2 = false) {
    this._paused = true;
    if (!this._active)
      return true;
    this.$video.pause();
    this.$overlay && (this.$overlay.style.display = "none");
    let b2 = () => {
      this.$video.srcObject instanceof MediaStream && (e._stopVideoStream(this.$video.srcObject), this.$video.srcObject = null);
    };
    if (a2)
      return b2(), true;
    await new Promise((c2) => setTimeout(c2, 300));
    if (!this._paused)
      return false;
    b2();
    return true;
  }
  async setCamera(a2) {
    a2 !== this._preferredCamera && (this._preferredCamera = a2, await this._restartVideoStream());
  }
  static async scanImage(a2, b2, c2, d2, f2 = false, h2 = false) {
    let m2, n2 = false;
    b2 && ("scanRegion" in b2 || "qrEngine" in b2 || "canvas" in b2 || "disallowCanvasResizing" in b2 || "alsoTryWithoutScanRegion" in b2 || "returnDetailedScanResult" in b2) ? (m2 = b2.scanRegion, c2 = b2.qrEngine, d2 = b2.canvas, f2 = b2.disallowCanvasResizing || false, h2 = b2.alsoTryWithoutScanRegion || false, n2 = true) : b2 || c2 || d2 || f2 || h2 ? console.warn("You're using a deprecated api for scanImage which will be removed in the future.") : console.warn("Note that the return type of scanImage will change in the future. To already switch to the new api today, you can pass returnDetailedScanResult: true.");
    b2 = !!c2;
    try {
      let p2, k2;
      [c2, p2] = await Promise.all([c2 || e.createQrEngine(), e._loadImage(a2)]);
      [d2, k2] = e._drawToCanvas(p2, m2, d2, f2);
      let q2;
      if (c2 instanceof Worker) {
        let g2 = c2;
        b2 || e._postWorkerMessageSync(g2, "inversionMode", "both");
        q2 = await new Promise((l2, v2) => {
          let w2, u2, r2, y2 = -1;
          u2 = (t2) => {
            t2.data.id === y2 && (g2.removeEventListener("message", u2), g2.removeEventListener("error", r2), clearTimeout(w2), null !== t2.data.data ? l2({ data: t2.data.data, cornerPoints: e._convertPoints(t2.data.cornerPoints, m2) }) : v2(e.NO_QR_CODE_FOUND));
          };
          r2 = (t2) => {
            g2.removeEventListener("message", u2);
            g2.removeEventListener("error", r2);
            clearTimeout(w2);
            v2("Scanner error: " + (t2 ? t2.message || t2 : "Unknown Error"));
          };
          g2.addEventListener("message", u2);
          g2.addEventListener("error", r2);
          w2 = setTimeout(() => r2("timeout"), 1e4);
          let x2 = k2.getImageData(0, 0, d2.width, d2.height);
          y2 = e._postWorkerMessageSync(g2, "decode", x2, [x2.data.buffer]);
        });
      } else
        q2 = await Promise.race([new Promise((g2, l2) => window.setTimeout(() => l2("Scanner error: timeout"), 1e4)), (async () => {
          try {
            var [g2] = await c2.detect(d2);
            if (!g2)
              throw e.NO_QR_CODE_FOUND;
            return { data: g2.rawValue, cornerPoints: e._convertPoints(g2.cornerPoints, m2) };
          } catch (l2) {
            g2 = l2.message || l2;
            if (/not implemented|service unavailable/.test(g2))
              return e._disableBarcodeDetector = true, e.scanImage(a2, { scanRegion: m2, canvas: d2, disallowCanvasResizing: f2, alsoTryWithoutScanRegion: h2 });
            throw `Scanner error: ${g2}`;
          }
        })()]);
      return n2 ? q2 : q2.data;
    } catch (p2) {
      if (!m2 || !h2)
        throw p2;
      let k2 = await e.scanImage(a2, { qrEngine: c2, canvas: d2, disallowCanvasResizing: f2 });
      return n2 ? k2 : k2.data;
    } finally {
      b2 || e._postWorkerMessage(c2, "close");
    }
  }
  setGrayscaleWeights(a2, b2, c2, d2 = true) {
    e._postWorkerMessage(this._qrEnginePromise, "grayscaleWeights", {
      red: a2,
      green: b2,
      blue: c2,
      useIntegerApproximation: d2
    });
  }
  setInversionMode(a2) {
    e._postWorkerMessage(this._qrEnginePromise, "inversionMode", a2);
  }
  static async createQrEngine(a2) {
    a2 && console.warn("Specifying a worker path is not required and not supported anymore.");
    a2 = () => __vitePreload(() => import("./qr-scanner-worker.min.js"), true ? [] : void 0, import.meta.url).then((c2) => c2.createWorker());
    if (!(!e._disableBarcodeDetector && "BarcodeDetector" in window && BarcodeDetector.getSupportedFormats && (await BarcodeDetector.getSupportedFormats()).includes("qr_code")))
      return a2();
    let b2 = navigator.userAgentData;
    return b2 && b2.brands.some(({ brand: c2 }) => /Chromium/i.test(c2)) && /mac ?OS/i.test(b2.platform) && await b2.getHighEntropyValues(["architecture", "platformVersion"]).then(({ architecture: c2, platformVersion: d2 }) => /arm/i.test(c2 || "arm") && 13 <= parseInt(d2 || "13")).catch(() => true) ? a2() : new BarcodeDetector({ formats: ["qr_code"] });
  }
  _onPlay() {
    this._scanRegion = this._calculateScanRegion(this.$video);
    this._updateOverlay();
    this.$overlay && (this.$overlay.style.display = "");
    this._scanFrame();
  }
  _onLoadedMetaData() {
    this._scanRegion = this._calculateScanRegion(this.$video);
    this._updateOverlay();
  }
  _onVisibilityChange() {
    document.hidden ? this.pause() : this._active && this.start();
  }
  _calculateScanRegion(a2) {
    let b2 = Math.round(2 / 3 * Math.min(a2.videoWidth, a2.videoHeight));
    return { x: Math.round((a2.videoWidth - b2) / 2), y: Math.round((a2.videoHeight - b2) / 2), width: b2, height: b2, downScaledWidth: this._legacyCanvasSize, downScaledHeight: this._legacyCanvasSize };
  }
  _updateOverlay() {
    requestAnimationFrame(() => {
      if (this.$overlay) {
        var a2 = this.$video, b2 = a2.videoWidth, c2 = a2.videoHeight, d2 = a2.offsetWidth, f2 = a2.offsetHeight, h2 = a2.offsetLeft, m2 = a2.offsetTop, n2 = window.getComputedStyle(a2), p2 = n2.objectFit, k2 = b2 / c2, q2 = d2 / f2;
        switch (p2) {
          case "none":
            var g2 = b2;
            var l2 = c2;
            break;
          case "fill":
            g2 = d2;
            l2 = f2;
            break;
          default:
            ("cover" === p2 ? k2 > q2 : k2 < q2) ? (l2 = f2, g2 = l2 * k2) : (g2 = d2, l2 = g2 / k2), "scale-down" === p2 && (g2 = Math.min(g2, b2), l2 = Math.min(l2, c2));
        }
        var [v2, w2] = n2.objectPosition.split(" ").map((r2, y2) => {
          const x2 = parseFloat(r2);
          return r2.endsWith("%") ? (y2 ? f2 - l2 : d2 - g2) * x2 / 100 : x2;
        });
        n2 = this._scanRegion.width || b2;
        q2 = this._scanRegion.height || c2;
        p2 = this._scanRegion.x || 0;
        var u2 = this._scanRegion.y || 0;
        k2 = this.$overlay.style;
        k2.width = `${n2 / b2 * g2}px`;
        k2.height = `${q2 / c2 * l2}px`;
        k2.top = `${m2 + w2 + u2 / c2 * l2}px`;
        c2 = /scaleX\(-1\)/.test(a2.style.transform);
        k2.left = `${h2 + (c2 ? d2 - v2 - g2 : v2) + (c2 ? b2 - p2 - n2 : p2) / b2 * g2}px`;
        k2.transform = a2.style.transform;
      }
    });
  }
  static _convertPoints(a2, b2) {
    if (!b2)
      return a2;
    let c2 = b2.x || 0, d2 = b2.y || 0, f2 = b2.width && b2.downScaledWidth ? b2.width / b2.downScaledWidth : 1;
    b2 = b2.height && b2.downScaledHeight ? b2.height / b2.downScaledHeight : 1;
    for (let h2 of a2)
      h2.x = h2.x * f2 + c2, h2.y = h2.y * b2 + d2;
    return a2;
  }
  _scanFrame() {
    !this._active || this.$video.paused || this.$video.ended || ("requestVideoFrameCallback" in this.$video ? this.$video.requestVideoFrameCallback.bind(this.$video) : requestAnimationFrame)(async () => {
      if (!(1 >= this.$video.readyState)) {
        var a2 = Date.now() - this._lastScanTimestamp, b2 = 1e3 / this._maxScansPerSecond;
        a2 < b2 && await new Promise((d2) => setTimeout(d2, b2 - a2));
        this._lastScanTimestamp = Date.now();
        try {
          var c2 = await e.scanImage(this.$video, { scanRegion: this._scanRegion, qrEngine: this._qrEnginePromise, canvas: this.$canvas });
        } catch (d2) {
          if (!this._active)
            return;
          this._onDecodeError(d2);
        }
        !e._disableBarcodeDetector || await this._qrEnginePromise instanceof Worker || (this._qrEnginePromise = e.createQrEngine());
        c2 ? (this._onDecode ? this._onDecode(c2) : this._legacyOnDecode && this._legacyOnDecode(c2.data), this.$codeOutlineHighlight && (clearTimeout(this._codeOutlineHighlightRemovalTimeout), this._codeOutlineHighlightRemovalTimeout = void 0, this.$codeOutlineHighlight.setAttribute("viewBox", `${this._scanRegion.x || 0} ${this._scanRegion.y || 0} ${this._scanRegion.width || this.$video.videoWidth} ${this._scanRegion.height || this.$video.videoHeight}`), this.$codeOutlineHighlight.firstElementChild.setAttribute(
          "points",
          c2.cornerPoints.map(({ x: d2, y: f2 }) => `${d2},${f2}`).join(" ")
        ), this.$codeOutlineHighlight.style.display = "")) : this.$codeOutlineHighlight && !this._codeOutlineHighlightRemovalTimeout && (this._codeOutlineHighlightRemovalTimeout = setTimeout(() => this.$codeOutlineHighlight.style.display = "none", 100));
      }
      this._scanFrame();
    });
  }
  _onDecodeError(a2) {
    a2 !== e.NO_QR_CODE_FOUND && console.log(a2);
  }
  async _getCameraStream() {
    if (!navigator.mediaDevices)
      throw "Camera not found.";
    let a2 = /^(environment|user)$/.test(this._preferredCamera) ? "facingMode" : "deviceId", b2 = [{ width: { min: 1024 } }, { width: { min: 768 } }, {}], c2 = b2.map((d2) => Object.assign({}, d2, { [a2]: { exact: this._preferredCamera } }));
    for (let d2 of [...c2, ...b2])
      try {
        let f2 = await navigator.mediaDevices.getUserMedia({ video: d2, audio: false }), h2 = this._getFacingMode(f2) || (d2.facingMode ? this._preferredCamera : "environment" === this._preferredCamera ? "user" : "environment");
        return { stream: f2, facingMode: h2 };
      } catch (f2) {
      }
    throw "Camera not found.";
  }
  async _restartVideoStream() {
    let a2 = this._paused;
    await this.pause(true) && !a2 && this._active && await this.start();
  }
  static _stopVideoStream(a2) {
    for (let b2 of a2.getTracks())
      b2.stop(), a2.removeTrack(b2);
  }
  _setVideoMirror(a2) {
    this.$video.style.transform = "scaleX(" + ("user" === a2 ? -1 : 1) + ")";
  }
  _getFacingMode(a2) {
    return (a2 = a2.getVideoTracks()[0]) ? /rear|back|environment/i.test(a2.label) ? "environment" : /front|user|face/i.test(a2.label) ? "user" : null : null;
  }
  static _drawToCanvas(a2, b2, c2, d2 = false) {
    c2 = c2 || document.createElement("canvas");
    let f2 = b2 && b2.x ? b2.x : 0, h2 = b2 && b2.y ? b2.y : 0, m2 = b2 && b2.width ? b2.width : a2.videoWidth || a2.width, n2 = b2 && b2.height ? b2.height : a2.videoHeight || a2.height;
    d2 || (d2 = b2 && b2.downScaledWidth ? b2.downScaledWidth : m2, b2 = b2 && b2.downScaledHeight ? b2.downScaledHeight : n2, c2.width !== d2 && (c2.width = d2), c2.height !== b2 && (c2.height = b2));
    b2 = c2.getContext("2d", { alpha: false });
    b2.imageSmoothingEnabled = false;
    b2.drawImage(a2, f2, h2, m2, n2, 0, 0, c2.width, c2.height);
    return [c2, b2];
  }
  static async _loadImage(a2) {
    if (a2 instanceof Image)
      return await e._awaitImageLoad(a2), a2;
    if (a2 instanceof HTMLVideoElement || a2 instanceof HTMLCanvasElement || a2 instanceof SVGImageElement || "OffscreenCanvas" in window && a2 instanceof OffscreenCanvas || "ImageBitmap" in window && a2 instanceof ImageBitmap)
      return a2;
    if (a2 instanceof File || a2 instanceof Blob || a2 instanceof URL || "string" === typeof a2) {
      let b2 = new Image();
      b2.src = a2 instanceof File || a2 instanceof Blob ? URL.createObjectURL(a2) : a2.toString();
      try {
        return await e._awaitImageLoad(b2), b2;
      } finally {
        (a2 instanceof File || a2 instanceof Blob) && URL.revokeObjectURL(b2.src);
      }
    } else
      throw "Unsupported image type.";
  }
  static async _awaitImageLoad(a2) {
    a2.complete && 0 !== a2.naturalWidth || await new Promise((b2, c2) => {
      let d2 = (f2) => {
        a2.removeEventListener("load", d2);
        a2.removeEventListener("error", d2);
        f2 instanceof ErrorEvent ? c2("Image load error") : b2();
      };
      a2.addEventListener("load", d2);
      a2.addEventListener("error", d2);
    });
  }
  static async _postWorkerMessage(a2, b2, c2, d2) {
    return e._postWorkerMessageSync(await a2, b2, c2, d2);
  }
  static _postWorkerMessageSync(a2, b2, c2, d2) {
    if (!(a2 instanceof Worker))
      return -1;
    let f2 = e._workerMessageId++;
    a2.postMessage({ id: f2, type: b2, data: c2 }, d2);
    return f2;
  }
};
e$1.DEFAULT_CANVAS_SIZE = 400;
e$1.NO_QR_CODE_FOUND = "No QR code found";
e$1._disableBarcodeDetector = false;
e$1._workerMessageId = 0;
const useQRScanner = (videoRef, {
  onStart,
  onResult,
  onError
}) => {
  const { t: t2 } = useTranslation();
  const [initErrorMessage, setInitErrorMessage] = reactExports.useState();
  const scanner = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (videoRef.current && !scanner.current) {
      scanner.current = new e$1(
        videoRef.current,
        (result) => {
          var _a;
          (_a = scanner.current) == null ? void 0 : _a.stop();
          onResult(result);
        },
        {
          onDecodeError: (err) => {
            const errorString = err.toString();
            if (err && !errorString.includes("No QR code found")) {
              onError(err);
            }
          },
          highlightScanRegion: true,
          highlightCodeOutline: true,
          calculateScanRegion: (v2) => {
            const videoWidth = v2.videoWidth;
            const videoHeight = v2.videoHeight;
            const factor = 0.5;
            const size2 = Math.floor(Math.min(videoWidth, videoHeight) * factor);
            return {
              x: (videoWidth - size2) / 2,
              y: (videoHeight - size2) / 2,
              width: size2,
              height: size2
            };
          }
        }
      );
    }
  });
  reactExports.useEffect(() => {
    (async () => {
      var _a;
      try {
        await ((_a = scanner.current) == null ? void 0 : _a.start());
        if (onStart) {
          onStart();
        }
      } catch (error3) {
        const stringifiedError = error3.toString();
        const cameraNotFound = stringifiedError === "Camera not found.";
        setInitErrorMessage(cameraNotFound ? t2("send.scanQRNoCameraMessage") : stringifiedError);
      }
    })();
  }, [videoRef, onStart, onResult, onError, t2]);
  reactExports.useEffect(() => {
    return () => {
      var _a, _b;
      (_a = scanner.current) == null ? void 0 : _a.stop();
      (_b = scanner.current) == null ? void 0 : _b.destroy();
      scanner.current = null;
    };
  });
  return { initErrorMessage };
};
const spinnerAnimationContainer = "_spinnerAnimationContainer_1utsx_1";
const qrVideo = "_qrVideo_1utsx_13";
const style$x = {
  spinnerAnimationContainer,
  qrVideo
};
const ScanQRVideo = ({
  onResult
}) => {
  const videoRef = reactExports.useRef(null);
  const { initErrorMessage } = useQRScanner(videoRef, {
    onResult: (result) => onResult(result.data),
    onError: (err) => console.error(err)
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$x.spinnerAnimationContainer, children: initErrorMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: initErrorMessage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SpinnerAnimation, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "video",
      {
        className: style$x.qrVideo,
        ref: videoRef,
        poster: "data:image/svg+xml,%3Csvg%20xmlns=%22http://www.w3.org/2000/svg%22%3E%20width=%2264%22%20height=%2248%22%3C/svg%3E"
      }
    )
  ] });
};
const ScanQRDialog = ({
  parseQRResult,
  toggleScanQR,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: true,
      fullscreen: true,
      dialog: !isMobile,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ScanQRVideo,
          {
            onResult: (result) => {
              parseQRResult(result);
              onChangeActiveScanQR(false);
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { reverseRow: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: toggleScanQR,
            children: t2("button.back")
          }
        ) })
      ]
    }
  );
};
const inputWithIcon$1 = "_inputWithIcon_drrz7_1";
const action$2 = "_action_drrz7_9";
const qrButton = "_qrButton_drrz7_18";
const style$w = {
  inputWithIcon: inputWithIcon$1,
  action: action$2,
  qrButton
};
const ScanQRButton = ({ onClick }) => {
  const { isDarkMode } = reactExports.useContext(DarkModeContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", onClick, className: style$w.qrButton, children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(QRCodeDark, {}) });
};
const ReceiverAddressInput = ({
  accountCode,
  addressError,
  onInputChange,
  recipientAddress,
  activeScanQR,
  parseQRResult,
  onChangeActiveScanQR
}) => {
  const { t: t2 } = useTranslation();
  reactExports.useCallback(async () => {
    if (!accountCode) {
      return;
    }
    try {
      const receiveAddresses = await getReceiveAddressList(accountCode)();
      if (receiveAddresses && receiveAddresses.length > 0 && receiveAddresses[0].addresses.length > 1) {
        onInputChange(receiveAddresses[0].addresses[0].address);
      }
    } catch (e3) {
      console.error(e3);
    }
  }, [accountCode, onInputChange]);
  const toggleScanQR = reactExports.useCallback(() => {
    if (activeScanQR) {
      onChangeActiveScanQR(false);
      return;
    }
    onChangeActiveScanQR(true);
  }, [activeScanQR, onChangeActiveScanQR]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    activeScanQR && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScanQRDialog,
      {
        toggleScanQR,
        onChangeActiveScanQR,
        parseQRResult
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        label: t2("send.address.label"),
        placeholder: t2("send.address.placeholder"),
        id: "recipientAddress",
        error: addressError,
        onInput: (e3) => onInputChange(e3.target.value),
        value: recipientAddress,
        className: style$w.inputWithIcon,
        labelSection: void 0,
        autoFocus: true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
      }
    )
  ] });
};
const maxAmount = "_maxAmount_1t5n0_1";
const style$v = {
  maxAmount
};
const CoinInput = ({
  balance: balance2,
  onAmountChange,
  onSendAllChange,
  sendAll,
  amountError,
  proposedAmount,
  amount: amount2,
  hasSelectedUTXOs
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: balance2 ? balance2.available.unit : t2("send.amount.label"),
      id: "amount",
      onInput: (e3) => onAmountChange(e3.target.value),
      disabled: sendAll,
      error: amountError,
      value: sendAll ? proposedAmount ? proposedAmount.amount : "" : amount2,
      placeholder: t2("send.amount.placeholder"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          label: t2(hasSelectedUTXOs ? "send.maximumSelectedCoins" : "send.maximum"),
          id: "sendAll",
          onChange: (e3) => onSendAllChange(e3.target.checked),
          checked: sendAll,
          className: style$v.maxAmount
        }
      )
    }
  );
};
const FiatInput = ({ label: label2, onFiatChange, disabled: disabled2, error: error3, fiatAmount }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: "number",
      step: "any",
      min: "0",
      label: label2,
      id: "fiatAmount",
      onInput: onFiatChange,
      disabled: disabled2,
      error: error3,
      value: fiatAmount,
      placeholder: t2("send.amount.placeholder")
    }
  );
};
const labelDescription = "_labelDescription_5etm5_1";
const style$u = {
  labelDescription
};
const NoteInput = ({ onNoteChange, note: note2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      label: t2("note.title"),
      labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$u.labelDescription, children: t2("note.input.description") }),
      id: "note",
      onInput: onNoteChange,
      value: note2,
      placeholder: t2("note.input.placeholder")
    }
  );
};
const utxosList = "_utxosList_8ra1q_1";
const utxo = "_utxo_8ra1q_1";
const utxoContent = "_utxoContent_8ra1q_17";
const note = "_note_8ra1q_25";
const utxoData = "_utxoData_8ra1q_33";
const utxoExplorer = "_utxoExplorer_8ra1q_41";
const amounts = "_amounts_8ra1q_51";
const amount$1 = "_amount_8ra1q_51";
const label$3 = "_label_8ra1q_59";
const unit = "_unit_8ra1q_60";
const address$2 = "_address_8ra1q_73";
const transaction = "_transaction_8ra1q_74";
const shrink = "_shrink_8ra1q_81";
const style$t = {
  utxosList,
  utxo,
  utxoContent,
  note,
  utxoData,
  utxoExplorer,
  amounts,
  amount: amount$1,
  label: label$3,
  unit,
  address: address$2,
  transaction,
  shrink
};
const UTXOs = ({
  accountCode,
  active: active2,
  explorerURL,
  onChange: onChange2,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  const [utxos, setUtxos] = reactExports.useState([]);
  const [selectedUTXOs, setSelectedUTXOs] = reactExports.useState({});
  reactExports.useEffect(() => {
    getUTXOs(accountCode).then(setUtxos);
    return () => setUtxos([]);
  }, [accountCode]);
  reactExports.useEffect(() => {
    const unsubscribe2 = syncdone((code) => {
      if (accountCode === code) {
        getUTXOs(accountCode).then(setUtxos);
      }
    });
    return () => unsubscribe2();
  }, [accountCode]);
  const handleUTXOChange = (event2) => {
    const target = event2.target;
    const outPoint = target.dataset.outpoint;
    const proposedUTXOs = Object.assign({}, selectedUTXOs);
    if (target.checked) {
      proposedUTXOs[outPoint] = true;
    } else {
      delete proposedUTXOs[outPoint];
    }
    setSelectedUTXOs(proposedUTXOs);
    onChange2(proposedUTXOs);
  };
  const renderUTXOs = (scriptType) => {
    const filteredUTXOs = utxos.filter((utxo2) => utxo2.scriptType === scriptType);
    if (filteredUTXOs.length === 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "subTitle", children: getScriptName(scriptType) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$t.utxosList, children: filteredUTXOs.map((utxo2) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: style$t.utxo, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Checkbox,
        {
          checked: !!selectedUTXOs[utxo2.outPoint],
          id: "utxo-" + utxo2.outPoint,
          "data-outpoint": utxo2.outPoint,
          onChange: handleUTXOChange,
          children: [
            utxo2.note && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$t.note, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("strong", { children: [
              utxo2.note,
              " "
            ] }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.utxoContent, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.utxoData, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.amounts, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.amount, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { alwaysShowAmounts: true, amount: utxo2.amount.amount, unit: utxo2.amount.unit }),
                    " ",
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.unit, children: utxo2.amount.unit })
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { alwaysShowAmounts: true, amount: utxo2.amount, unstyled: true, noAction: true })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.address, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.label, children: [
                    t2("send.coincontrol.address"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.shrink, children: utxo2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$t.transaction, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$t.label, children: [
                    t2("send.coincontrol.outpoint"),
                    ":"
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$t.shrink, children: utxo2.txId }),
                  ":",
                  utxo2.txOutput
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: style$t.utxoExplorer,
                  href: explorerURL + utxo2.txId,
                  title: t2("transaction.explorerTitle"),
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, {})
                }
              )
            ] })
          ]
        }
      ) }, "utxo-" + utxo2.outPoint)) })
    ] }, "utxos-" + scriptType);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Dialog,
    {
      open: active2,
      title: t2("send.coincontrol.title"),
      large: true,
      onClose,
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        allScriptTypes.map(renderUTXOs),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-top-none m-bottom-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onClose, children: t2("button.continue") }) })
      ] })
    }
  );
};
const txProposalErrorHandling = (registerEvents, unregisterEvents, errorCode) => {
  const { t: t2 } = instance;
  switch (errorCode) {
    case "invalidAddress":
      return { addressError: t2("send.error.invalidAddress") };
    case "invalidAmount":
    case "insufficientFunds":
      return { amountError: t2(`send.error.${errorCode}`), proposedFee: void 0 };
    case "feeTooLow":
    case "feesNotAvailable":
      return { feeError: t2(`send.error.${errorCode}`) };
    default:
      if (errorCode) {
        unregisterEvents();
        alertUser(errorCode, { callback: registerEvents });
      }
      return { proposedFee: void 0 };
  }
};
const container$g = "_container_8f83b_1";
const style$s = {
  container: container$g
};
class Send extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.selectedUTXOs = {};
    this.unsubscribeList = [];
    this.pendingProposals = [];
    this.proposeTimeout = null;
    this.state = {
      recipientAddress: "",
      amount: "",
      fiatAmount: "",
      valid: false,
      sendAll: false,
      isConfirming: false,
      signConfirm: false,
      isSent: false,
      isAborted: false,
      isUpdatingProposal: false,
      noMobileChannelError: false,
      fiatUnit: this.props.activeCurrency,
      coinControl: false,
      btcUnit: "default",
      activeCoinControl: false,
      activeScanQR: false,
      note: "",
      customFee: ""
    };
    this.isBitcoinBased = () => {
      const account2 = this.getAccount();
      if (!account2) {
        return false;
      }
      return isBitcoinBased(account2.coinCode);
    };
    this.registerEvents = () => {
      document.addEventListener("keydown", this.handleKeyDown);
    };
    this.unregisterEvents = () => {
      document.removeEventListener("keydown", this.handleKeyDown);
    };
    this.handleKeyDown = (e3) => {
      if (e3.keyCode === 27 && !this.state.activeCoinControl && !this.state.activeScanQR) {
        route(`/account/${this.props.code}`);
      }
    };
    this.send = async () => {
      if (this.state.noMobileChannelError) {
        alertUser(this.props.t("warning.sendPairing"));
        return;
      }
      const code = this.getAccount().code;
      const connectResult = await connectKeystore(code);
      if (!connectResult.success) {
        return;
      }
      this.setState({ signProgress: void 0, isConfirming: true });
      try {
        const result = await sendTx(code);
        if (result.success) {
          this.setState({
            sendAll: false,
            isConfirming: false,
            isSent: true,
            recipientAddress: "",
            proposedAmount: void 0,
            proposedFee: void 0,
            proposedTotal: void 0,
            fiatAmount: "",
            amount: "",
            note: "",
            customFee: ""
          });
          this.selectedUTXOs = {};
          setTimeout(() => this.setState({
            isSent: false,
            isConfirming: false
          }), 5e3);
        } else if (result.aborted) {
          this.setState({ isAborted: true });
          setTimeout(() => this.setState({ isAborted: false }), 5e3);
        } else {
          switch (result.errorCode) {
            case "erc20InsufficientGasFunds":
              alertUser(this.props.t(`send.error.${result.errorCode}`));
              break;
            default:
              const { errorMessage: errorMessage2 } = result;
              alertUser(this.props.t("unknownError", errorMessage2 && { errorMessage: errorMessage2 }));
          }
        }
      } catch (err) {
        console.error(err);
      } finally {
        this.setState({ isConfirming: false, signProgress: void 0, signConfirm: false });
      }
    };
    this.txInput = () => ({
      address: this.state.recipientAddress,
      amount: this.state.amount,
      feeTarget: this.state.feeTarget || "",
      customFee: this.state.customFee,
      sendAll: this.state.sendAll ? "yes" : "no",
      selectedUTXOs: Object.keys(this.selectedUTXOs)
    });
    this.sendDisabled = () => {
      const txInput = this.txInput();
      return !txInput.address || this.state.feeTarget === void 0 || txInput.sendAll === "no" && !txInput.amount || this.state.feeTarget === "custom" && !this.state.customFee;
    };
    this.validateAndDisplayFee = (updateFiat = true) => {
      this.setState({
        proposedTotal: void 0,
        addressError: void 0,
        amountError: void 0,
        feeError: void 0
      });
      if (this.sendDisabled()) {
        return;
      }
      const txInput = this.txInput();
      if (this.proposeTimeout) {
        clearTimeout(this.proposeTimeout);
        this.proposeTimeout = null;
      }
      this.setState({ isUpdatingProposal: true });
      this.proposeTimeout = setTimeout(() => {
        const propose = apiPost("account/" + this.getAccount().code + "/tx-proposal", txInput).then((result) => {
          const pos = this.pendingProposals.indexOf(propose);
          if (this.pendingProposals.length - 1 === pos) {
            this.txProposal(updateFiat, result);
          }
          this.pendingProposals.splice(pos, 1);
        }).catch(() => {
          this.setState({ valid: false });
          this.pendingProposals.splice(this.pendingProposals.indexOf(propose), 1);
        });
        this.pendingProposals.push(propose);
      }, 400);
    };
    this.handleNoteInput = (event2) => {
      const target = event2.target;
      this.setState({
        "note": target.value
      }, () => {
        proposeTxNote(this.getAccount().code, this.state.note);
      });
    };
    this.txProposal = (updateFiat, result) => {
      this.setState({ valid: result.success });
      if (result.success) {
        this.setState({
          addressError: void 0,
          amountError: void 0,
          feeError: void 0,
          proposedFee: result.fee,
          proposedAmount: result.amount,
          proposedTotal: result.total,
          isUpdatingProposal: false
        });
        if (updateFiat) {
          this.convertToFiat(result.amount.amount);
        }
      } else {
        const errorHandling = txProposalErrorHandling(this.registerEvents, this.unregisterEvents, result.errorCode);
        this.setState({ ...errorHandling, isUpdatingProposal: false });
      }
    };
    this.handleFiatInput = (event2) => {
      const value = event2.target.value;
      this.setState({ fiatAmount: value });
      this.convertFromFiat(value);
    };
    this.convertToFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-to-plain-fiat?from=${coinCode}&to=${this.state.fiatUnit}&amount=${value}`).then((data) => {
          if (data.success) {
            this.setState({ fiatAmount: data.fiatAmount });
          } else {
            this.setState({ amountError: this.props.t("send.error.invalidAmount") });
          }
        });
      } else {
        this.setState({ fiatAmount: "" });
      }
    };
    this.convertFromFiat = (value) => {
      if (value) {
        const coinCode = this.getAccount().coinCode;
        apiGet(`coins/convert-from-fiat?from=${this.state.fiatUnit}&to=${coinCode}&amount=${value}`).then((data) => {
          if (data.success) {
            this.setState({ amount: data.amount }, () => this.validateAndDisplayFee(false));
          } else {
            this.setState({ amountError: this.props.t("send.error.invalidAmount") });
          }
        });
      } else {
        this.setState({ amount: "" });
      }
    };
    this.feeTargetChange = (feeTarget) => {
      this.setState(
        { feeTarget, customFee: "" },
        () => this.validateAndDisplayFee(this.state.sendAll)
      );
    };
    this.onSelectedUTXOsChange = (selectedUTXOs) => {
      this.selectedUTXOs = selectedUTXOs;
      this.validateAndDisplayFee(true);
    };
    this.hasSelectedUTXOs = () => {
      return Object.keys(this.selectedUTXOs).length !== 0;
    };
    this.getAccount = () => {
      if (!this.props.code) {
        return void 0;
      }
      return findAccount(this.props.accounts, this.props.code);
    };
    this.toggleCoinControl = () => {
      this.setState(({ activeCoinControl }) => {
        if (activeCoinControl) {
          this.selectedUTXOs = {};
        }
        return { activeCoinControl: !activeCoinControl };
      });
    };
    this.setActiveScanQR = (activeScanQR) => {
      this.setState({ activeScanQR });
    };
    this.parseQRResult = async (uri) => {
      let address2;
      let amount2 = "";
      try {
        const url = new URL(uri);
        if (url.protocol !== "bitcoin:" && url.protocol !== "litecoin:" && url.protocol !== "ethereum:") {
          alertUser(this.props.t("invalidFormat"));
          return;
        }
        address2 = url.pathname;
        if (this.isBitcoinBased()) {
          amount2 = url.searchParams.get("amount") || "";
        }
      } catch {
        address2 = uri;
      }
      let updateState = {
        recipientAddress: address2,
        sendAll: false,
        fiatAmount: ""
      };
      const coinCode = this.getAccount().coinCode;
      if (amount2) {
        if (coinCode === "btc" || coinCode === "tbtc") {
          const result = await parseExternalBtcAmount(amount2);
          if (result.success) {
            updateState["amount"] = result.amount;
          } else {
            updateState["amountError"] = this.props.t("send.error.invalidAmount");
            this.setState(updateState);
            return;
          }
        } else {
          updateState["amount"] = amount2;
        }
      }
      this.setState(updateState, () => {
        this.convertToFiat(this.state.amount);
        this.validateAndDisplayFee(true);
      });
    };
    this.deactivateCoinControl = () => {
      this.setState({ activeCoinControl: false });
    };
    this.onReceiverAddressInputChange = (recipientAddress) => {
      this.setState({ recipientAddress }, () => {
        this.validateAndDisplayFee(true);
      });
    };
    this.onCoinAmountChange = (amount2) => {
      this.convertToFiat(amount2);
      this.setState({ amount: amount2 }, () => {
        this.validateAndDisplayFee(true);
      });
    };
    this.onSendAllChange = (sendAll) => {
      if (!sendAll) {
        this.convertToFiat(this.state.amount);
      }
      this.setState({ sendAll }, () => {
        this.validateAndDisplayFee(true);
      });
    };
  }
  componentDidMount() {
    const updateBalance = (code) => getBalance(code).then((balance2) => this.setState({ balance: balance2 })).catch(console.error);
    if (this.props.code) {
      updateBalance(this.props.code);
    }
    if (this.props.deviceIDs.length > 0 && this.props.devices[this.props.deviceIDs[0]] === "bitbox") {
      apiGet("devices/" + this.props.deviceIDs[0] + "/has-mobile-channel").then((mobileChannel) => {
        getDeviceInfo$1(this.props.deviceIDs[0]).then(({ pairing: pairing2 }) => {
          const account2 = this.getAccount();
          const paired = mobileChannel && pairing2;
          const noMobileChannelError = pairing2 && !mobileChannel && account2 && isBitcoinBased(account2.coinCode);
          this.setState((prevState) => ({ ...prevState, paired, noMobileChannelError }));
        });
      });
    }
    apiGet("config").then((config) => {
      this.setState({ btcUnit: config.backend.btcUnit });
      if (this.isBitcoinBased()) {
        this.setState({ coinControl: !!(config.frontend || {}).coinControl });
      }
    });
    this.unsubscribeList = [
      signProgress(
        (progress) => this.setState({ signProgress: progress, signConfirm: false })
      ),
      signConfirm(
        () => this.setState({ signConfirm: true })
      ),
      syncdone((code) => {
        if (this.props.code === code) {
          updateBalance(code);
        }
      })
    ];
  }
  UNSAFE_componentWillMount() {
    this.registerEvents();
  }
  componentWillUnmount() {
    this.unregisterEvents();
    unsubscribe(this.unsubscribeList);
  }
  render() {
    var _a;
    const { t: t2, code } = this.props;
    const {
      balance: balance2,
      proposedFee,
      proposedTotal,
      recipientAddress,
      proposedAmount,
      valid,
      amount: amount2,
      /* data, */
      fiatAmount,
      fiatUnit,
      sendAll,
      feeTarget,
      customFee,
      isConfirming,
      isSent,
      isAborted,
      isUpdatingProposal,
      addressError,
      amountError,
      feeError,
      paired,
      signProgress: signProgress2,
      signConfirm: signConfirm2,
      coinControl,
      btcUnit,
      activeCoinControl,
      activeScanQR,
      note: note2
    } = this.state;
    const waitDialogTransactionDetails = {
      proposedFee,
      proposedAmount,
      proposedTotal,
      customFee,
      feeTarget,
      recipientAddress,
      fiatUnit
    };
    const waitDialogTransactionStatus = {
      isConfirming,
      signProgress: signProgress2,
      signConfirm: signConfirm2
    };
    const account2 = this.getAccount();
    if (!account2) {
      return null;
    }
    const baseCurrencyUnit = fiatUnit === "BTC" && btcUnit === "sat" ? "sat" : fiatUnit;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", hidden: paired !== false, children: t2("warning.sendPairing") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Header,
          {
            title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("send.title", { accountName: account2.coinName }) }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {})
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.availableBalance") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2, noRotateFiat: true }),
            coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
              UTXOs,
              {
                accountCode: account2.code,
                active: activeCoinControl,
                explorerURL: account2.blockExplorerTxPrefix,
                onClose: this.deactivateCoinControl,
                onChange: this.onSelectedUTXOsChange
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `flex flex-row flex-between ${style$s.container}`, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("send.transactionDetails") }),
              coinControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  className: "m-bottom-quarter p-right-none",
                  transparent: true,
                  onClick: this.toggleCoinControl,
                  children: t2("send.toggleCoinControl")
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              ReceiverAddressInput,
              {
                accountCode: (_a = this.getAccount()) == null ? void 0 : _a.code,
                addressError,
                onInputChange: this.onReceiverAddressInputChange,
                recipientAddress,
                parseQRResult: this.parseQRResult,
                activeScanQR,
                onChangeActiveScanQR: this.setActiveScanQR
              }
            ) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CoinInput,
                {
                  balance: balance2,
                  onAmountChange: this.onCoinAmountChange,
                  onSendAllChange: this.onSendAllChange,
                  sendAll,
                  amountError,
                  proposedAmount,
                  amount: amount2,
                  hasSelectedUTXOs: this.hasSelectedUTXOs()
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FiatInput,
                {
                  onFiatChange: this.handleFiatInput,
                  disabled: sendAll,
                  error: amountError,
                  fiatAmount,
                  label: baseCurrencyUnit
                }
              ) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Column, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                FeeTargets,
                {
                  accountCode: account2.code,
                  coinCode: account2.coinCode,
                  disabled: !amount2 && !sendAll,
                  fiatUnit: baseCurrencyUnit,
                  proposedFee,
                  customFee,
                  showCalculatingFeeLabel: isUpdatingProposal,
                  onFeeTargetChange: this.feeTargetChange,
                  onCustomFee: (customFee2) => this.setState({ customFee: customFee2 }, this.validateAndDisplayFee),
                  error: feeError
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  NoteInput,
                  {
                    note: note2,
                    onNoteChange: this.handleNoteInput
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  ColumnButtons,
                  {
                    className: "m-top-default m-bottom-xlarge",
                    inline: true,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Button,
                        {
                          primary: true,
                          onClick: this.send,
                          disabled: this.sendDisabled() || !valid || isUpdatingProposal,
                          children: t2("send.button")
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        ButtonLink,
                        {
                          secondary: true,
                          to: `/account/${code}`,
                          children: t2("button.back")
                        }
                      )
                    ]
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ConfirmingWaitDialog,
            {
              paired,
              baseCurrencyUnit,
              note: note2,
              hasSelectedUTXOs: this.hasSelectedUTXOs(),
              selectedUTXOs: Object.keys(this.selectedUTXOs),
              coinCode: account2.coinCode,
              transactionDetails: waitDialogTransactionDetails,
              transactionStatus: waitDialogTransactionStatus
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isSent, messageType: "sent" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(MessageWaitDialog, { isShown: isAborted, messageType: "abort" })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SendGuide, { coinCode: account2.coinCode })
    ] });
  }
}
const TranslatedSend = translate()(Send);
const SendWrapper = ({ accounts, code, deviceIDs, devices }) => {
  const { defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedSend,
    {
      accounts,
      code,
      devices,
      deviceIDs,
      activeCurrency: defaultCurrency2
    }
  );
};
const errUserAbort = 104;
const resetDevice = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/reset`);
};
const getDeviceInfo = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/info`);
};
const checkSDCard = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/check-sdcard`);
};
const insertSDCard = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/insert-sdcard`);
};
const setDeviceName = (deviceID, newDeviceName) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-device-name`, {
    name: newDeviceName
  });
};
const getVersion = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/version`);
};
const setMnemonicPassphraseEnabled = (deviceID, enabled) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-mnemonic-passphrase-enabled`, enabled);
};
const verifyAttestation = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/attestation`);
};
const checkBackup = (deviceID, silent) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/check`, { silent });
};
const createBackup = (deviceID, method) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/create`, method);
};
const restoreBackup = (deviceID, selectedBackup) => {
  return apiPost(`devices/bitbox02/${deviceID}/backups/restore`, selectedBackup);
};
const upgradeDeviceFirmware = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/upgrade-firmware`);
};
const showMnemonic = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/show-mnemonic`);
};
const restoreFromMnemonic = (deviceID) => {
  return apiPost(`devices/bitbox02/${deviceID}/restore-from-mnemonic`);
};
const getStatus$1 = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/status`);
};
const getChannelHash = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/channel-hash`);
};
const verifyChannelHash = (deviceID, ok2) => {
  return apiPost(`devices/bitbox02/${deviceID}/channel-hash-verify`, ok2);
};
const setPassword = (deviceID, seedLen) => {
  return apiPost(`devices/bitbox02/${deviceID}/set-password`, seedLen);
};
const getRootFingerprint = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/root-fingerprint`);
};
const useSDCard = (devices, dependencies) => {
  const [sdcard, setSDCard] = reactExports.useState(false);
  const mounted = useMountedRef();
  reactExports.useEffect(() => {
    const deviceIDs = Object.keys(devices);
    Promise.all(deviceIDs.map((deviceID) => {
      switch (devices[deviceID]) {
        case "bitbox":
          return getDeviceInfo$1(deviceID).then(({ sdcard: sdcard2 }) => sdcard2);
        case "bitbox02":
          return checkSDCard(deviceID);
        default:
          return false;
      }
    })).then((sdcards) => sdcards.some((sdcard2) => sdcard2)).then((result) => {
      if (mounted.current) {
        setSDCard(result);
      }
    }).catch(console.error);
  }, [devices, ...dependencies || []]);
  return sdcard;
};
function size(_a) {
  var width = _a.width, height = _a.height;
  if (width < 0) {
    throw new Error("Negative width is not allowed for Size");
  }
  if (height < 0) {
    throw new Error("Negative height is not allowed for Size");
  }
  return {
    width,
    height
  };
}
function equalSizes(first2, second) {
  return first2.width === second.width && first2.height === second.height;
}
var Observable = (
  /** @class */
  function() {
    function Observable2(win) {
      var _this = this;
      this._resolutionListener = function() {
        return _this._onResolutionChanged();
      };
      this._resolutionMediaQueryList = null;
      this._observers = [];
      this._window = win;
      this._installResolutionListener();
    }
    Observable2.prototype.dispose = function() {
      this._uninstallResolutionListener();
      this._window = null;
    };
    Object.defineProperty(Observable2.prototype, "value", {
      get: function() {
        return this._window.devicePixelRatio;
      },
      enumerable: false,
      configurable: true
    });
    Observable2.prototype.subscribe = function(next2) {
      var _this = this;
      var observer = { next: next2 };
      this._observers.push(observer);
      return {
        unsubscribe: function() {
          _this._observers = _this._observers.filter(function(o2) {
            return o2 !== observer;
          });
        }
      };
    };
    Observable2.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        throw new Error("Resolution listener is already installed");
      }
      var dppx = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(dppx, "dppx)"));
      this._resolutionMediaQueryList.addListener(this._resolutionListener);
    };
    Observable2.prototype._uninstallResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) {
        this._resolutionMediaQueryList.removeListener(this._resolutionListener);
        this._resolutionMediaQueryList = null;
      }
    };
    Observable2.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener();
      this._installResolutionListener();
    };
    Observable2.prototype._onResolutionChanged = function() {
      var _this = this;
      this._observers.forEach(function(observer) {
        return observer.next(_this._window.devicePixelRatio);
      });
      this._reinstallResolutionListener();
    };
    return Observable2;
  }()
);
function createObservable(win) {
  return new Observable(win);
}
var DevicePixelContentBoxBinding = (
  /** @class */
  function() {
    function DevicePixelContentBoxBinding2(canvasElement, transformBitmapSize, options2) {
      var _a;
      this._canvasElement = null;
      this._bitmapSizeChangedListeners = [];
      this._suggestedBitmapSize = null;
      this._suggestedBitmapSizeChangedListeners = [];
      this._devicePixelRatioObservable = null;
      this._canvasElementResizeObserver = null;
      this._canvasElement = canvasElement;
      this._canvasElementClientSize = size({
        width: this._canvasElement.clientWidth,
        height: this._canvasElement.clientHeight
      });
      this._transformBitmapSize = transformBitmapSize !== null && transformBitmapSize !== void 0 ? transformBitmapSize : function(size2) {
        return size2;
      };
      this._allowResizeObserver = (_a = options2 === null || options2 === void 0 ? void 0 : options2.allowResizeObserver) !== null && _a !== void 0 ? _a : true;
      this._chooseAndInitObserver();
    }
    DevicePixelContentBoxBinding2.prototype.dispose = function() {
      var _a, _b;
      if (this._canvasElement === null) {
        throw new Error("Object is disposed");
      }
      (_a = this._canvasElementResizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
      this._canvasElementResizeObserver = null;
      (_b = this._devicePixelRatioObservable) === null || _b === void 0 ? void 0 : _b.dispose();
      this._devicePixelRatioObservable = null;
      this._suggestedBitmapSizeChangedListeners.length = 0;
      this._bitmapSizeChangedListeners.length = 0;
      this._canvasElement = null;
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElement", {
      get: function() {
        if (this._canvasElement === null) {
          throw new Error("Object is disposed");
        }
        return this._canvasElement;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "canvasElementClientSize", {
      get: function() {
        return this._canvasElementClientSize;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "bitmapSize", {
      get: function() {
        return size({
          width: this.canvasElement.width,
          height: this.canvasElement.height
        });
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.resizeCanvasElement = function(clientSize) {
      this._canvasElementClientSize = size(clientSize);
      this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px");
      this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px");
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype.subscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeBitmapSizeChanged = function(listener) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    Object.defineProperty(DevicePixelContentBoxBinding2.prototype, "suggestedBitmapSize", {
      get: function() {
        return this._suggestedBitmapSize;
      },
      enumerable: false,
      configurable: true
    });
    DevicePixelContentBoxBinding2.prototype.subscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners.push(listener);
    };
    DevicePixelContentBoxBinding2.prototype.unsubscribeSuggestedBitmapSizeChanged = function(listener) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(l2) {
        return l2 !== listener;
      });
    };
    DevicePixelContentBoxBinding2.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize === null) {
        return;
      }
      var oldSuggestedSize = this._suggestedBitmapSize;
      this._suggestedBitmapSize = null;
      this._resizeBitmap(oldSuggestedSize);
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, this._suggestedBitmapSize);
    };
    DevicePixelContentBoxBinding2.prototype._resizeBitmap = function(newSize) {
      var oldSize = this.bitmapSize;
      if (equalSizes(oldSize, newSize)) {
        return;
      }
      this.canvasElement.width = newSize.width;
      this.canvasElement.height = newSize.height;
      this._emitBitmapSizeChanged(oldSize, newSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._bitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._suggestNewBitmapSize = function(newSize) {
      var oldSuggestedSize = this._suggestedBitmapSize;
      var finalNewSize = size(this._transformBitmapSize(newSize, this._canvasElementClientSize));
      var newSuggestedSize = equalSizes(this.bitmapSize, finalNewSize) ? null : finalNewSize;
      if (oldSuggestedSize === null && newSuggestedSize === null) {
        return;
      }
      if (oldSuggestedSize !== null && newSuggestedSize !== null && equalSizes(oldSuggestedSize, newSuggestedSize)) {
        return;
      }
      this._suggestedBitmapSize = newSuggestedSize;
      this._emitSuggestedBitmapSizeChanged(oldSuggestedSize, newSuggestedSize);
    };
    DevicePixelContentBoxBinding2.prototype._emitSuggestedBitmapSizeChanged = function(oldSize, newSize) {
      var _this = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(listener) {
        return listener.call(_this, oldSize, newSize);
      });
    };
    DevicePixelContentBoxBinding2.prototype._chooseAndInitObserver = function() {
      var _this = this;
      if (!this._allowResizeObserver) {
        this._initDevicePixelRatioObservable();
        return;
      }
      isDevicePixelContentBoxSupported().then(function(isSupported) {
        return isSupported ? _this._initResizeObserver() : _this._initDevicePixelRatioObservable();
      });
    };
    DevicePixelContentBoxBinding2.prototype._initDevicePixelRatioObservable = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        throw new Error("No window is associated with the canvas");
      }
      this._devicePixelRatioObservable = createObservable(win);
      this._devicePixelRatioObservable.subscribe(function() {
        return _this._invalidateBitmapSize();
      });
      this._invalidateBitmapSize();
    };
    DevicePixelContentBoxBinding2.prototype._invalidateBitmapSize = function() {
      var _a, _b;
      if (this._canvasElement === null) {
        return;
      }
      var win = canvasElementWindow(this._canvasElement);
      if (win === null) {
        return;
      }
      var ratio = (_b = (_a = this._devicePixelRatioObservable) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : win.devicePixelRatio;
      var canvasRects = this._canvasElement.getClientRects();
      var newSize = (
        // eslint-disable-next-line no-negated-condition
        canvasRects[0] !== void 0 ? predictedBitmapSize(canvasRects[0], ratio) : size({
          width: this._canvasElementClientSize.width * ratio,
          height: this._canvasElementClientSize.height * ratio
        })
      );
      this._suggestNewBitmapSize(newSize);
    };
    DevicePixelContentBoxBinding2.prototype._initResizeObserver = function() {
      var _this = this;
      if (this._canvasElement === null) {
        return;
      }
      this._canvasElementResizeObserver = new ResizeObserver(function(entries) {
        var entry2 = entries.find(function(entry3) {
          return entry3.target === _this._canvasElement;
        });
        if (!entry2 || !entry2.devicePixelContentBoxSize || !entry2.devicePixelContentBoxSize[0]) {
          return;
        }
        var entrySize = entry2.devicePixelContentBoxSize[0];
        var newSize = size({
          width: entrySize.inlineSize,
          height: entrySize.blockSize
        });
        _this._suggestNewBitmapSize(newSize);
      });
      this._canvasElementResizeObserver.observe(this._canvasElement, { box: "device-pixel-content-box" });
    };
    return DevicePixelContentBoxBinding2;
  }()
);
function bindTo(canvasElement, target) {
  if (target.type === "device-pixel-content-box") {
    return new DevicePixelContentBoxBinding(canvasElement, target.transform, target.options);
  }
  throw new Error("Unsupported binding target");
}
function canvasElementWindow(canvasElement) {
  return canvasElement.ownerDocument.defaultView;
}
function isDevicePixelContentBoxSupported() {
  return new Promise(function(resolve) {
    var ro = new ResizeObserver(function(entries) {
      resolve(entries.every(function(entry2) {
        return "devicePixelContentBoxSize" in entry2;
      }));
      ro.disconnect();
    });
    ro.observe(document.body, { box: "device-pixel-content-box" });
  }).catch(function() {
    return false;
  });
}
function predictedBitmapSize(canvasRect, ratio) {
  return size({
    width: Math.round(canvasRect.left * ratio + canvasRect.width * ratio) - Math.round(canvasRect.left * ratio),
    height: Math.round(canvasRect.top * ratio + canvasRect.height * ratio) - Math.round(canvasRect.top * ratio)
  });
}
var CanvasRenderingTarget2D = (
  /** @class */
  function() {
    function CanvasRenderingTarget2D2(context, mediaSize, bitmapSize) {
      if (mediaSize.width === 0 || mediaSize.height === 0) {
        throw new TypeError("Rendering target could only be created on a media with positive width and height");
      }
      this._mediaSize = mediaSize;
      if (bitmapSize.width === 0 || bitmapSize.height === 0) {
        throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      }
      this._bitmapSize = bitmapSize;
      this._context = context;
    }
    CanvasRenderingTarget2D2.prototype.useMediaCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize
        });
      } finally {
        this._context.restore();
      }
    };
    CanvasRenderingTarget2D2.prototype.useBitmapCoordinateSpace = function(f2) {
      try {
        this._context.save();
        this._context.setTransform(1, 0, 0, 1, 0, 0);
        return f2({
          context: this._context,
          mediaSize: this._mediaSize,
          bitmapSize: this._bitmapSize,
          horizontalPixelRatio: this._horizontalPixelRatio,
          verticalPixelRatio: this._verticalPixelRatio
        });
      } finally {
        this._context.restore();
      }
    };
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_horizontalPixelRatio", {
      get: function() {
        return this._bitmapSize.width / this._mediaSize.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CanvasRenderingTarget2D2.prototype, "_verticalPixelRatio", {
      get: function() {
        return this._bitmapSize.height / this._mediaSize.height;
      },
      enumerable: false,
      configurable: true
    });
    return CanvasRenderingTarget2D2;
  }()
);
function tryCreateCanvasRenderingTarget2D(binding, contextOptions) {
  var mediaSize = binding.canvasElementClientSize;
  if (mediaSize.width === 0 || mediaSize.height === 0) {
    return null;
  }
  var bitmapSize = binding.bitmapSize;
  if (bitmapSize.width === 0 || bitmapSize.height === 0) {
    return null;
  }
  var context = binding.canvasElement.getContext("2d", contextOptions);
  if (context === null) {
    return null;
  }
  return new CanvasRenderingTarget2D(context, mediaSize, bitmapSize);
}
/*!
 * @license
 * TradingView Lightweight Charts™ v4.1.1
 * Copyright (c) 2023 TradingView, Inc.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
const e2 = { upColor: "#26a69a", downColor: "#ef5350", wickVisible: true, borderVisible: true, borderColor: "#378658", borderUpColor: "#26a69a", borderDownColor: "#ef5350", wickColor: "#737375", wickUpColor: "#26a69a", wickDownColor: "#ef5350" }, r = { upColor: "#26a69a", downColor: "#ef5350", openVisible: true, thinBars: true }, h$1 = { color: "#2196f3", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, l = { topColor: "rgba( 46, 220, 135, 0.4)", bottomColor: "rgba( 40, 221, 100, 0)", invertFilledArea: false, lineColor: "#33D778", lineStyle: 0, lineWidth: 3, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, a = { baseValue: { type: "price", price: 0 }, topFillColor1: "rgba(38, 166, 154, 0.28)", topFillColor2: "rgba(38, 166, 154, 0.05)", topLineColor: "rgba(38, 166, 154, 1)", bottomFillColor1: "rgba(239, 83, 80, 0.05)", bottomFillColor2: "rgba(239, 83, 80, 0.28)", bottomLineColor: "rgba(239, 83, 80, 1)", lineWidth: 3, lineStyle: 0, lineType: 0, lineVisible: true, crosshairMarkerVisible: true, crosshairMarkerRadius: 4, crosshairMarkerBorderColor: "", crosshairMarkerBorderWidth: 2, crosshairMarkerBackgroundColor: "", lastPriceAnimation: 0, pointMarkersVisible: false }, o = { color: "#26a69a", base: 0 }, _$1 = { color: "#2196f3" }, u = { title: "", visible: true, lastValueVisible: true, priceLineVisible: true, priceLineSource: 0, priceLineWidth: 1, priceLineColor: "", priceLineStyle: 2, baseLineVisible: true, baseLineWidth: 1, baseLineColor: "#B2B5BE", baseLineStyle: 0, priceFormat: { type: "price", precision: 2, minMove: 0.01 } };
var c, d;
function f(t2, i) {
  const n2 = { 0: [], 1: [t2.lineWidth, t2.lineWidth], 2: [2 * t2.lineWidth, 2 * t2.lineWidth], 3: [6 * t2.lineWidth, 6 * t2.lineWidth], 4: [t2.lineWidth, 4 * t2.lineWidth] }[i];
  t2.setLineDash(n2);
}
function v(t2, i, n2, s) {
  t2.beginPath();
  const e3 = t2.lineWidth % 2 ? 0.5 : 0;
  t2.moveTo(n2, i + e3), t2.lineTo(s, i + e3), t2.stroke();
}
function p$1(t2, i) {
  if (!t2)
    throw new Error("Assertion failed" + (i ? ": " + i : ""));
}
function m$1(t2) {
  if (void 0 === t2)
    throw new Error("Value is undefined");
  return t2;
}
function b(t2) {
  if (null === t2)
    throw new Error("Value is null");
  return t2;
}
function w$1(t2) {
  return b(m$1(t2));
}
!function(t2) {
  t2[t2.Simple = 0] = "Simple", t2[t2.WithSteps = 1] = "WithSteps", t2[t2.Curved = 2] = "Curved";
}(c || (c = {})), function(t2) {
  t2[t2.Solid = 0] = "Solid", t2[t2.Dotted = 1] = "Dotted", t2[t2.Dashed = 2] = "Dashed", t2[t2.LargeDashed = 3] = "LargeDashed", t2[t2.SparseDotted = 4] = "SparseDotted";
}(d || (d = {}));
const g = { khaki: "#f0e68c", azure: "#f0ffff", aliceblue: "#f0f8ff", ghostwhite: "#f8f8ff", gold: "#ffd700", goldenrod: "#daa520", gainsboro: "#dcdcdc", gray: "#808080", green: "#008000", honeydew: "#f0fff0", floralwhite: "#fffaf0", lightblue: "#add8e6", lightcoral: "#f08080", lemonchiffon: "#fffacd", hotpink: "#ff69b4", lightyellow: "#ffffe0", greenyellow: "#adff2f", lightgoldenrodyellow: "#fafad2", limegreen: "#32cd32", linen: "#faf0e6", lightcyan: "#e0ffff", magenta: "#f0f", maroon: "#800000", olive: "#808000", orange: "#ffa500", oldlace: "#fdf5e6", mediumblue: "#0000cd", transparent: "#0000", lime: "#0f0", lightpink: "#ffb6c1", mistyrose: "#ffe4e1", moccasin: "#ffe4b5", midnightblue: "#191970", orchid: "#da70d6", mediumorchid: "#ba55d3", mediumturquoise: "#48d1cc", orangered: "#ff4500", royalblue: "#4169e1", powderblue: "#b0e0e6", red: "#f00", coral: "#ff7f50", turquoise: "#40e0d0", white: "#fff", whitesmoke: "#f5f5f5", wheat: "#f5deb3", teal: "#008080", steelblue: "#4682b4", bisque: "#ffe4c4", aquamarine: "#7fffd4", aqua: "#0ff", sienna: "#a0522d", silver: "#c0c0c0", springgreen: "#00ff7f", antiquewhite: "#faebd7", burlywood: "#deb887", brown: "#a52a2a", beige: "#f5f5dc", chocolate: "#d2691e", chartreuse: "#7fff00", cornflowerblue: "#6495ed", cornsilk: "#fff8dc", crimson: "#dc143c", cadetblue: "#5f9ea0", tomato: "#ff6347", fuchsia: "#f0f", blue: "#00f", salmon: "#fa8072", blanchedalmond: "#ffebcd", slateblue: "#6a5acd", slategray: "#708090", thistle: "#d8bfd8", tan: "#d2b48c", cyan: "#0ff", darkblue: "#00008b", darkcyan: "#008b8b", darkgoldenrod: "#b8860b", darkgray: "#a9a9a9", blueviolet: "#8a2be2", black: "#000", darkmagenta: "#8b008b", darkslateblue: "#483d8b", darkkhaki: "#bdb76b", darkorchid: "#9932cc", darkorange: "#ff8c00", darkgreen: "#006400", darkred: "#8b0000", dodgerblue: "#1e90ff", darkslategray: "#2f4f4f", dimgray: "#696969", deepskyblue: "#00bfff", firebrick: "#b22222", forestgreen: "#228b22", indigo: "#4b0082", ivory: "#fffff0", lavenderblush: "#fff0f5", feldspar: "#d19275", indianred: "#cd5c5c", lightgreen: "#90ee90", lightgrey: "#d3d3d3", lightskyblue: "#87cefa", lightslategray: "#789", lightslateblue: "#8470ff", snow: "#fffafa", lightseagreen: "#20b2aa", lightsalmon: "#ffa07a", darksalmon: "#e9967a", darkviolet: "#9400d3", mediumpurple: "#9370d8", mediumaquamarine: "#66cdaa", skyblue: "#87ceeb", lavender: "#e6e6fa", lightsteelblue: "#b0c4de", mediumvioletred: "#c71585", mintcream: "#f5fffa", navajowhite: "#ffdead", navy: "#000080", olivedrab: "#6b8e23", palevioletred: "#d87093", violetred: "#d02090", yellow: "#ff0", yellowgreen: "#9acd32", lawngreen: "#7cfc00", pink: "#ffc0cb", paleturquoise: "#afeeee", palegoldenrod: "#eee8aa", darkolivegreen: "#556b2f", darkseagreen: "#8fbc8f", darkturquoise: "#00ced1", peachpuff: "#ffdab9", deeppink: "#ff1493", violet: "#ee82ee", palegreen: "#98fb98", mediumseagreen: "#3cb371", peru: "#cd853f", saddlebrown: "#8b4513", sandybrown: "#f4a460", rosybrown: "#bc8f8f", purple: "#800080", seagreen: "#2e8b57", seashell: "#fff5ee", papayawhip: "#ffefd5", mediumslateblue: "#7b68ee", plum: "#dda0dd", mediumspringgreen: "#00fa9a" };
function M(t2) {
  return t2 < 0 ? 0 : t2 > 255 ? 255 : Math.round(t2) || 0;
}
function x(t2) {
  return t2 <= 0 || t2 > 0 ? t2 < 0 ? 0 : t2 > 1 ? 1 : Math.round(1e4 * t2) / 1e4 : 0;
}
const S$1 = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i, k$1 = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i, y = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/, C$1 = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?[\d]{0,10}(?:\.\d+)?)\s*\)$/;
function T$1(t2) {
  (t2 = t2.toLowerCase()) in g && (t2 = g[t2]);
  {
    const i = C$1.exec(t2) || y.exec(t2);
    if (i)
      return [M(parseInt(i[1], 10)), M(parseInt(i[2], 10)), M(parseInt(i[3], 10)), x(i.length < 5 ? 1 : parseFloat(i[4]))];
  }
  {
    const i = k$1.exec(t2);
    if (i)
      return [M(parseInt(i[1], 16)), M(parseInt(i[2], 16)), M(parseInt(i[3], 16)), 1];
  }
  {
    const i = S$1.exec(t2);
    if (i)
      return [M(17 * parseInt(i[1], 16)), M(17 * parseInt(i[2], 16)), M(17 * parseInt(i[3], 16)), 1];
  }
  throw new Error(`Cannot parse color: ${t2}`);
}
function P(t2) {
  const i = T$1(t2);
  return { t: `rgb(${i[0]}, ${i[1]}, ${i[2]})`, i: (n2 = i, 0.199 * n2[0] + 0.687 * n2[1] + 0.114 * n2[2] > 160 ? "black" : "white") };
  var n2;
}
class R {
  constructor() {
    this.h = [];
  }
  l(t2, i, n2) {
    const s = { o: t2, _: i, u: true === n2 };
    this.h.push(s);
  }
  v(t2) {
    const i = this.h.findIndex((i2) => t2 === i2.o);
    i > -1 && this.h.splice(i, 1);
  }
  p(t2) {
    this.h = this.h.filter((i) => i._ !== t2);
  }
  m(t2, i, n2) {
    const s = [...this.h];
    this.h = this.h.filter((t3) => !t3.u), s.forEach((s2) => s2.o(t2, i, n2));
  }
  M() {
    return this.h.length > 0;
  }
  S() {
    this.h = [];
  }
}
function D$1(t2, ...i) {
  for (const n2 of i)
    for (const i2 in n2)
      void 0 !== n2[i2] && ("object" != typeof n2[i2] || void 0 === t2[i2] || Array.isArray(n2[i2]) ? t2[i2] = n2[i2] : D$1(t2[i2], n2[i2]));
  return t2;
}
function O$1(t2) {
  return "number" == typeof t2 && isFinite(t2);
}
function A$1(t2) {
  return "number" == typeof t2 && t2 % 1 == 0;
}
function V$1(t2) {
  return "string" == typeof t2;
}
function B$1(t2) {
  return "boolean" == typeof t2;
}
function I(t2) {
  const i = t2;
  if (!i || "object" != typeof i)
    return i;
  let n2, s, e3;
  for (s in n2 = Array.isArray(i) ? [] : {}, i)
    i.hasOwnProperty(s) && (e3 = i[s], n2[s] = e3 && "object" == typeof e3 ? I(e3) : e3);
  return n2;
}
function z(t2) {
  return null !== t2;
}
function E(t2) {
  return null === t2 ? void 0 : t2;
}
const L$1 = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";
function N$1(t2, i, n2) {
  return void 0 === i && (i = L$1), `${n2 = void 0 !== n2 ? `${n2} ` : ""}${t2}px ${i}`;
}
let F$1 = class F {
  constructor(t2) {
    this.k = { C: 1, T: 5, P: NaN, R: "", D: "", O: "", A: "", V: 0, B: 0, I: 0, L: 0, N: 0 }, this.F = t2;
  }
  W() {
    const t2 = this.k, i = this.j(), n2 = this.H();
    return t2.P === i && t2.D === n2 || (t2.P = i, t2.D = n2, t2.R = N$1(i, n2), t2.L = 2.5 / 12 * i, t2.V = t2.L, t2.B = i / 12 * t2.T, t2.I = i / 12 * t2.T, t2.N = 0), t2.O = this.$(), t2.A = this.U(), this.k;
  }
  $() {
    return this.F.W().layout.textColor;
  }
  U() {
    return this.F.q();
  }
  j() {
    return this.F.W().layout.fontSize;
  }
  H() {
    return this.F.W().layout.fontFamily;
  }
};
class W {
  constructor() {
    this.Y = [];
  }
  X(t2) {
    this.Y = t2;
  }
  K(t2, i, n2) {
    this.Y.forEach((s) => {
      s.K(t2, i, n2);
    });
  }
}
class j {
  K(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
  G(t2, i, n2) {
    t2.useMediaCoordinateSpace((t3) => this.J(t3, i, n2));
  }
  J(t2, i, n2) {
  }
}
let H$1 = class H extends j {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z({ context: t2 }) {
    if (null === this.tt || null === this.tt.nt)
      return;
    const i = this.tt.nt, n2 = this.tt, s = (s2) => {
      t2.beginPath();
      for (let e3 = i.to - 1; e3 >= i.from; --e3) {
        const i2 = n2.st[e3];
        t2.moveTo(i2.et, i2.rt), t2.arc(i2.et, i2.rt, s2, 0, 2 * Math.PI);
      }
      t2.fill();
    };
    n2.ht > 0 && (t2.fillStyle = n2.lt, s(n2.ot + n2.ht)), t2.fillStyle = n2._t, s(n2.ot);
  }
};
function $$1() {
  return { st: [{ et: 0, rt: 0, ut: 0, ct: 0 }], _t: "", lt: "", ot: 0, ht: 0, nt: null };
}
const U$1 = { from: 0, to: 1 };
class q {
  constructor(t2, i) {
    this.dt = new W(), this.ft = [], this.vt = [], this.bt = true, this.F = t2, this.wt = i, this.dt.X(this.ft);
  }
  gt(t2) {
    const i = this.F.Mt();
    i.length !== this.ft.length && (this.vt = i.map($$1), this.ft = this.vt.map((t3) => {
      const i2 = new H$1();
      return i2.it(t3), i2;
    }), this.dt.X(this.ft)), this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.dt;
  }
  St() {
    const t2 = 2 === this.wt.W().mode, i = this.F.Mt(), n2 = this.wt.kt(), s = this.F.yt();
    i.forEach((i2, e3) => {
      var r2;
      const h2 = this.vt[e3], l2 = i2.Ct(n2);
      if (t2 || null === l2 || !i2.Tt())
        return void (h2.nt = null);
      const a2 = b(i2.Pt());
      h2._t = l2.Rt, h2.ot = l2.ot, h2.ht = l2.Dt, h2.st[0].ct = l2.ct, h2.st[0].rt = i2.At().Ot(l2.ct, a2.Vt), h2.lt = null !== (r2 = l2.Bt) && void 0 !== r2 ? r2 : this.F.It(h2.st[0].rt / i2.At().zt()), h2.st[0].ut = n2, h2.st[0].et = s.Et(n2), h2.nt = U$1;
    });
  }
}
class Y {
  K(t2, i, n2) {
    t2.useBitmapCoordinateSpace((t3) => this.Z(t3, i, n2));
  }
}
let X$1 = class X extends Y {
  constructor(t2) {
    super(), this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    const e3 = this.Lt.Nt.Tt, r2 = this.Lt.Ft.Tt;
    if (!e3 && !r2)
      return;
    const h2 = Math.round(this.Lt.et * n2), l2 = Math.round(this.Lt.rt * s);
    t2.lineCap = "butt", e3 && h2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Nt.ht * n2), t2.strokeStyle = this.Lt.Nt.O, t2.fillStyle = this.Lt.Nt.O, f(t2, this.Lt.Nt.Wt), function(t3, i2, n3, s2) {
      t3.beginPath();
      const e4 = t3.lineWidth % 2 ? 0.5 : 0;
      t3.moveTo(i2 + e4, n3), t3.lineTo(i2 + e4, s2), t3.stroke();
    }(t2, h2, 0, i.height)), r2 && l2 >= 0 && (t2.lineWidth = Math.floor(this.Lt.Ft.ht * s), t2.strokeStyle = this.Lt.Ft.O, t2.fillStyle = this.Lt.Ft.O, f(t2, this.Lt.Ft.Wt), v(t2, l2, 0, i.width));
  }
};
class K {
  constructor(t2) {
    this.bt = true, this.jt = { Nt: { ht: 1, Wt: 0, O: "", Tt: false }, Ft: { ht: 1, Wt: 0, O: "", Tt: false }, et: 0, rt: 0 }, this.Ht = new X$1(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht;
  }
  St() {
    const t2 = this.$t.Tt(), i = b(this.$t.Ut()), n2 = i.qt().W().crosshair, s = this.jt;
    if (2 === n2.mode)
      return s.Ft.Tt = false, void (s.Nt.Tt = false);
    s.Ft.Tt = t2 && this.$t.Yt(i), s.Nt.Tt = t2 && this.$t.Xt(), s.Ft.ht = n2.horzLine.width, s.Ft.Wt = n2.horzLine.style, s.Ft.O = n2.horzLine.color, s.Nt.ht = n2.vertLine.width, s.Nt.Wt = n2.vertLine.style, s.Nt.O = n2.vertLine.color, s.et = this.$t.Kt(), s.rt = this.$t.Zt();
  }
}
function Z$1(t2, i, n2, s, e3, r2) {
  t2.fillRect(i + r2, n2, s - 2 * r2, r2), t2.fillRect(i + r2, n2 + e3 - r2, s - 2 * r2, r2), t2.fillRect(i, n2, r2, e3), t2.fillRect(i + s - r2, n2, r2, e3);
}
function G$1(t2, i, n2, s, e3, r2) {
  t2.save(), t2.globalCompositeOperation = "copy", t2.fillStyle = r2, t2.fillRect(i, n2, s, e3), t2.restore();
}
function J$1(t2, i) {
  return t2.map((t3) => 0 === t3 ? t3 : t3 + i);
}
function Q$1(t2, i, n2, s, e3, r2) {
  t2.beginPath(), t2.lineTo(i + s - r2[1], n2), 0 !== r2[1] && t2.arcTo(i + s, n2, i + s, n2 + r2[1], r2[1]), t2.lineTo(i + s, n2 + e3 - r2[2]), 0 !== r2[2] && t2.arcTo(i + s, n2 + e3, i + s - r2[2], n2 + e3, r2[2]), t2.lineTo(i + r2[3], n2 + e3), 0 !== r2[3] && t2.arcTo(i, n2 + e3, i, n2 + e3 - r2[3], r2[3]), t2.lineTo(i, n2 + r2[0]), 0 !== r2[0] && t2.arcTo(i, n2, i + r2[0], n2, r2[0]);
}
function tt(t2, i, n2, s, e3, r2, h2 = 0, l2 = [0, 0, 0, 0], a2 = "") {
  if (t2.save(), !h2 || !a2 || a2 === r2)
    return Q$1(t2, i, n2, s, e3, l2), t2.fillStyle = r2, t2.fill(), void t2.restore();
  const o2 = h2 / 2;
  if ("transparent" !== r2) {
    Q$1(t2, i + h2, n2 + h2, s - 2 * h2, e3 - 2 * h2, J$1(l2, -h2)), t2.fillStyle = r2, t2.fill();
  }
  if ("transparent" !== a2) {
    Q$1(t2, i + o2, n2 + o2, s - h2, e3 - h2, J$1(l2, -o2)), t2.lineWidth = h2, t2.strokeStyle = a2, t2.closePath(), t2.stroke();
  }
  t2.restore();
}
function it(t2, i, n2, s, e3, r2, h2) {
  t2.save(), t2.globalCompositeOperation = "copy";
  const l2 = t2.createLinearGradient(0, 0, 0, e3);
  l2.addColorStop(0, r2), l2.addColorStop(1, h2), t2.fillStyle = l2, t2.fillRect(i, n2, s, e3), t2.restore();
}
class nt {
  constructor(t2, i) {
    this.it(t2, i);
  }
  it(t2, i) {
    this.Lt = t2, this.Gt = i;
  }
  zt(t2, i) {
    return this.Lt.Tt ? t2.P + t2.L + t2.V : 0;
  }
  K(t2, i, n2, s) {
    if (!this.Lt.Tt || 0 === this.Lt.Jt.length)
      return;
    const e3 = this.Lt.O, r2 = this.Gt.t, h2 = t2.useBitmapCoordinateSpace((t3) => {
      const h3 = t3.context;
      h3.font = i.R;
      const l2 = this.Qt(t3, i, n2, s), a2 = l2.ti, o2 = (t4, i2) => {
        l2.ii ? tt(h3, a2.ni, a2.si, a2.ei, a2.ri, t4, a2.hi, [a2.ot, 0, 0, a2.ot], i2) : tt(h3, a2.li, a2.si, a2.ei, a2.ri, t4, a2.hi, [0, a2.ot, a2.ot, 0], i2);
      };
      return o2(r2, "transparent"), this.Lt.ai && (h3.fillStyle = e3, h3.fillRect(a2.li, a2.oi, a2._i - a2.li, a2.ui)), o2("transparent", r2), this.Lt.ci && (h3.fillStyle = i.A, h3.fillRect(l2.ii ? a2.di - a2.hi : 0, a2.si, a2.hi, a2.fi - a2.si)), l2;
    });
    t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = h2.vi;
      t3.font = i.R, t3.textAlign = h2.ii ? "right" : "left", t3.textBaseline = "middle", t3.fillStyle = e3, t3.fillText(this.Lt.Jt, n3.pi, (n3.si + n3.fi) / 2 + n3.mi);
    });
  }
  Qt(t2, i, n2, s) {
    var e3;
    const { context: r2, bitmapSize: h2, mediaSize: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = this.Lt.ai || !this.Lt.bi ? i.T : 0, u2 = this.Lt.wi ? i.C : 0, c2 = i.L + this.Gt.gi, d2 = i.V + this.Gt.Mi, f2 = i.B, v2 = i.I, p2 = this.Lt.Jt, m2 = i.P, b2 = n2.xi(r2, p2), w2 = Math.ceil(n2.Si(r2, p2)), g2 = m2 + c2 + d2, M2 = i.C + f2 + v2 + w2 + _24, x2 = Math.max(1, Math.floor(o2));
    let S2 = Math.round(g2 * o2);
    S2 % 2 != x2 % 2 && (S2 += 1);
    const k2 = u2 > 0 ? Math.max(1, Math.floor(u2 * a2)) : 0, y2 = Math.round(M2 * a2), C2 = Math.round(_24 * a2), T2 = null !== (e3 = this.Gt.ki) && void 0 !== e3 ? e3 : this.Gt.yi, P2 = Math.round(T2 * o2) - Math.floor(0.5 * o2), R2 = Math.floor(P2 + x2 / 2 - S2 / 2), D2 = R2 + S2, O2 = "right" === s, A2 = O2 ? l2.width - u2 : u2, V2 = O2 ? h2.width - k2 : k2;
    let B2, I2, z2;
    return O2 ? (B2 = V2 - y2, I2 = V2 - C2, z2 = A2 - _24 - f2 - u2) : (B2 = V2 + y2, I2 = V2 + C2, z2 = A2 + _24 + f2), { ii: O2, ti: { si: R2, oi: P2, fi: D2, ei: y2, ri: S2, ot: 2 * a2, hi: k2, ni: B2, li: V2, _i: I2, ui: x2, di: h2.width }, vi: { si: R2 / o2, fi: D2 / o2, pi: z2, mi: b2 } };
  }
}
class st {
  constructor(t2) {
    this.Ci = { yi: 0, t: "#000", Mi: 0, gi: 0 }, this.Ti = { Jt: "", Tt: false, ai: true, bi: false, Bt: "", O: "#FFF", ci: false, wi: false }, this.Pi = { Jt: "", Tt: false, ai: false, bi: true, Bt: "", O: "#FFF", ci: true, wi: true }, this.bt = true, this.Ri = new (t2 || nt)(this.Ti, this.Ci), this.Di = new (t2 || nt)(this.Pi, this.Ci);
  }
  Jt() {
    return this.Oi(), this.Ti.Jt;
  }
  yi() {
    return this.Oi(), this.Ci.yi;
  }
  gt() {
    this.bt = true;
  }
  zt(t2, i = false) {
    return Math.max(this.Ri.zt(t2, i), this.Di.zt(t2, i));
  }
  Ai() {
    return this.Ci.ki || 0;
  }
  Vi(t2) {
    this.Ci.ki = t2;
  }
  Bi() {
    return this.Oi(), this.Ti.Tt || this.Pi.Tt;
  }
  Ii() {
    return this.Oi(), this.Ti.Tt;
  }
  xt(t2) {
    return this.Oi(), this.Ti.ai = this.Ti.ai && t2.W().ticksVisible, this.Pi.ai = this.Pi.ai && t2.W().ticksVisible, this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Ri;
  }
  zi() {
    return this.Oi(), this.Ri.it(this.Ti, this.Ci), this.Di.it(this.Pi, this.Ci), this.Di;
  }
  Oi() {
    this.bt && (this.Ti.ai = true, this.Pi.ai = false, this.Ei(this.Ti, this.Pi, this.Ci));
  }
}
class et extends st {
  constructor(t2, i, n2) {
    super(), this.$t = t2, this.Li = i, this.Ni = n2;
  }
  Ei(t2, i, n2) {
    if (t2.Tt = false, 2 === this.$t.W().mode)
      return;
    const s = this.$t.W().horzLine;
    if (!s.labelVisible)
      return;
    const e3 = this.Li.Pt();
    if (!this.$t.Tt() || this.Li.Fi() || null === e3)
      return;
    const r2 = P(s.labelBackgroundColor);
    n2.t = r2.t, t2.O = r2.i;
    const h2 = 2 / 12 * this.Li.P();
    n2.gi = h2, n2.Mi = h2;
    const l2 = this.Ni(this.Li);
    n2.yi = l2.yi, t2.Jt = this.Li.Wi(l2.ct, e3), t2.Tt = true;
  }
}
const rt$1 = /[1-9]/g;
let ht$1 = class ht {
  constructor() {
    this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  K(t2, i) {
    if (null === this.Lt || false === this.Lt.Tt || 0 === this.Lt.Jt.length)
      return;
    const n2 = t2.useMediaCoordinateSpace(({ context: t3 }) => (t3.font = i.R, Math.round(i.ji.Si(t3, b(this.Lt).Jt, rt$1))));
    if (n2 <= 0)
      return;
    const s = i.Hi, e3 = n2 + 2 * s, r2 = e3 / 2, h2 = this.Lt.$i;
    let l2 = this.Lt.yi, a2 = Math.floor(l2 - r2) + 0.5;
    a2 < 0 ? (l2 += Math.abs(0 - a2), a2 = Math.floor(l2 - r2) + 0.5) : a2 + e3 > h2 && (l2 -= Math.abs(h2 - (a2 + e3)), a2 = Math.floor(l2 - r2) + 0.5);
    const o2 = a2 + e3, _24 = Math.ceil(0 + i.C + i.T + i.L + i.P + i.V);
    t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: n3, verticalPixelRatio: s2 }) => {
      const e4 = b(this.Lt);
      t3.fillStyle = e4.t;
      const r3 = Math.round(a2 * n3), h3 = Math.round(0 * s2), l3 = Math.round(o2 * n3), u2 = Math.round(_24 * s2), c2 = Math.round(2 * n3);
      if (t3.beginPath(), t3.moveTo(r3, h3), t3.lineTo(r3, u2 - c2), t3.arcTo(r3, u2, r3 + c2, u2, c2), t3.lineTo(l3 - c2, u2), t3.arcTo(l3, u2, l3, u2 - c2, c2), t3.lineTo(l3, h3), t3.fill(), e4.ai) {
        const r4 = Math.round(e4.yi * n3), l4 = h3, a3 = Math.round((l4 + i.T) * s2);
        t3.fillStyle = e4.O;
        const o3 = Math.max(1, Math.floor(n3)), _25 = Math.floor(0.5 * n3);
        t3.fillRect(r4 - _25, l4, o3, a3 - l4);
      }
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const n3 = b(this.Lt), e4 = 0 + i.C + i.T + i.L + i.P / 2;
      t3.font = i.R, t3.textAlign = "left", t3.textBaseline = "middle", t3.fillStyle = n3.O;
      const r3 = i.ji.xi(t3, "Apr0");
      t3.translate(a2 + s, e4 + r3), t3.fillText(n3.Jt, 0, 0);
    });
  }
};
let lt$1 = class lt {
  constructor(t2, i, n2) {
    this.bt = true, this.Ht = new ht$1(), this.jt = { Tt: false, t: "#4c525e", O: "white", Jt: "", $i: 0, yi: NaN, ai: true }, this.wt = t2, this.Ui = i, this.Ni = n2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht.it(this.jt), this.Ht;
  }
  St() {
    const t2 = this.jt;
    if (t2.Tt = false, 2 === this.wt.W().mode)
      return;
    const i = this.wt.W().vertLine;
    if (!i.labelVisible)
      return;
    const n2 = this.Ui.yt();
    if (n2.Fi())
      return;
    t2.$i = n2.$i();
    const s = this.Ni();
    if (null === s)
      return;
    t2.yi = s.yi;
    const e3 = n2.qi(this.wt.kt());
    t2.Jt = n2.Yi(b(e3)), t2.Tt = true;
    const r2 = P(i.labelBackgroundColor);
    t2.t = r2.t, t2.O = r2.i, t2.ai = n2.W().ticksVisible;
  }
};
let at$1 = class at {
  constructor() {
    this.Xi = null, this.Ki = 0;
  }
  Zi() {
    return this.Ki;
  }
  Gi(t2) {
    this.Ki = t2;
  }
  At() {
    return this.Xi;
  }
  Ji(t2) {
    this.Xi = t2;
  }
  Qi(t2) {
    return [];
  }
  tn() {
    return [];
  }
  Tt() {
    return true;
  }
};
var ot$1;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Magnet = 1] = "Magnet", t2[t2.Hidden = 2] = "Hidden";
}(ot$1 || (ot$1 = {}));
let _t$1 = class _t extends at$1 {
  constructor(t2, i) {
    super(), this.nn = null, this.sn = NaN, this.en = 0, this.rn = true, this.hn = /* @__PURE__ */ new Map(), this.ln = false, this.an = NaN, this.on = NaN, this._n = NaN, this.un = NaN, this.Ui = t2, this.cn = i, this.dn = new q(t2, this);
    this.fn = ((t3, i2) => (n3) => {
      const s = i2(), e3 = t3();
      if (n3 === b(this.nn).vn())
        return { ct: e3, yi: s };
      {
        const t4 = b(n3.Pt());
        return { ct: n3.pn(s, t4), yi: s };
      }
    })(() => this.sn, () => this.on);
    const n2 = ((t3, i2) => () => {
      const n3 = this.Ui.yt().mn(t3()), s = i2();
      return n3 && Number.isFinite(s) ? { ut: n3, yi: s } : null;
    })(() => this.en, () => this.Kt());
    this.bn = new lt$1(this, t2, n2), this.wn = new K(this);
  }
  W() {
    return this.cn;
  }
  gn(t2, i) {
    this._n = t2, this.un = i;
  }
  Mn() {
    this._n = NaN, this.un = NaN;
  }
  xn() {
    return this._n;
  }
  Sn() {
    return this.un;
  }
  kn(t2, i, n2) {
    this.ln || (this.ln = true), this.rn = true, this.yn(t2, i, n2);
  }
  kt() {
    return this.en;
  }
  Kt() {
    return this.an;
  }
  Zt() {
    return this.on;
  }
  Tt() {
    return this.rn;
  }
  Cn() {
    this.rn = false, this.Tn(), this.sn = NaN, this.an = NaN, this.on = NaN, this.nn = null, this.Mn();
  }
  Pn(t2) {
    return null !== this.nn ? [this.wn, this.dn] : [];
  }
  Yt(t2) {
    return t2 === this.nn && this.cn.horzLine.visible;
  }
  Xt() {
    return this.cn.vertLine.visible;
  }
  Rn(t2, i) {
    this.rn && this.nn === t2 || this.hn.clear();
    const n2 = [];
    return this.nn === t2 && n2.push(this.Dn(this.hn, i, this.fn)), n2;
  }
  tn() {
    return this.rn ? [this.bn] : [];
  }
  Ut() {
    return this.nn;
  }
  On() {
    this.wn.gt(), this.hn.forEach((t2) => t2.gt()), this.bn.gt(), this.dn.gt();
  }
  An(t2) {
    return t2 && !t2.vn().Fi() ? t2.vn() : null;
  }
  yn(t2, i, n2) {
    this.Vn(t2, i, n2) && this.On();
  }
  Vn(t2, i, n2) {
    const s = this.an, e3 = this.on, r2 = this.sn, h2 = this.en, l2 = this.nn, a2 = this.An(n2);
    this.en = t2, this.an = isNaN(t2) ? NaN : this.Ui.yt().Et(t2), this.nn = n2;
    const o2 = null !== a2 ? a2.Pt() : null;
    return null !== a2 && null !== o2 ? (this.sn = i, this.on = a2.Ot(i, o2)) : (this.sn = NaN, this.on = NaN), s !== this.an || e3 !== this.on || h2 !== this.en || r2 !== this.sn || l2 !== this.nn;
  }
  Tn() {
    const t2 = this.Ui.Mt().map((t3) => t3.In().Bn()).filter(z), i = 0 === t2.length ? null : Math.max(...t2);
    this.en = null !== i ? i : NaN;
  }
  Dn(t2, i, n2) {
    let s = t2.get(i);
    return void 0 === s && (s = new et(this, i, n2), t2.set(i, s)), s;
  }
};
function ut$1(t2) {
  return "left" === t2 || "right" === t2;
}
class ct {
  constructor(t2) {
    this.zn = /* @__PURE__ */ new Map(), this.En = [], this.Ln = t2;
  }
  Nn(t2, i) {
    const n2 = function(t3, i2) {
      return void 0 === t3 ? i2 : { Fn: Math.max(t3.Fn, i2.Fn), Wn: t3.Wn || i2.Wn };
    }(this.zn.get(t2), i);
    this.zn.set(t2, n2);
  }
  jn() {
    return this.Ln;
  }
  Hn(t2) {
    const i = this.zn.get(t2);
    return void 0 === i ? { Fn: this.Ln } : { Fn: Math.max(this.Ln, i.Fn), Wn: i.Wn };
  }
  $n() {
    this.Un(), this.En = [{ qn: 0 }];
  }
  Yn(t2) {
    this.Un(), this.En = [{ qn: 1, Vt: t2 }];
  }
  Xn(t2) {
    this.Kn(), this.En.push({ qn: 5, Vt: t2 });
  }
  Un() {
    this.Kn(), this.En.push({ qn: 6 });
  }
  Zn() {
    this.Un(), this.En = [{ qn: 4 }];
  }
  Gn(t2) {
    this.Un(), this.En.push({ qn: 2, Vt: t2 });
  }
  Jn(t2) {
    this.Un(), this.En.push({ qn: 3, Vt: t2 });
  }
  Qn() {
    return this.En;
  }
  ts(t2) {
    for (const i of t2.En)
      this.ns(i);
    this.Ln = Math.max(this.Ln, t2.Ln), t2.zn.forEach((t3, i) => {
      this.Nn(i, t3);
    });
  }
  static ss() {
    return new ct(2);
  }
  static es() {
    return new ct(3);
  }
  ns(t2) {
    switch (t2.qn) {
      case 0:
        this.$n();
        break;
      case 1:
        this.Yn(t2.Vt);
        break;
      case 2:
        this.Gn(t2.Vt);
        break;
      case 3:
        this.Jn(t2.Vt);
        break;
      case 4:
        this.Zn();
        break;
      case 5:
        this.Xn(t2.Vt);
        break;
      case 6:
        this.Kn();
    }
  }
  Kn() {
    const t2 = this.En.findIndex((t3) => 5 === t3.qn);
    -1 !== t2 && this.En.splice(t2, 1);
  }
}
const dt$1 = ".";
function ft$1(t2, i) {
  if (!O$1(t2))
    return "n/a";
  if (!A$1(i))
    throw new TypeError("invalid length");
  if (i < 0 || i > 16)
    throw new TypeError("invalid length");
  if (0 === i)
    return t2.toString();
  return ("0000000000000000" + t2.toString()).slice(-i);
}
let vt$1 = class vt {
  constructor(t2, i) {
    if (i || (i = 1), O$1(t2) && A$1(t2) || (t2 = 100), t2 < 0)
      throw new TypeError("invalid base");
    this.Li = t2, this.rs = i, this.hs();
  }
  format(t2) {
    const i = t2 < 0 ? "−" : "";
    return t2 = Math.abs(t2), i + this.ls(t2);
  }
  hs() {
    if (this.os = 0, this.Li > 0 && this.rs > 0) {
      let t2 = this.Li;
      for (; t2 > 1; )
        t2 /= 10, this.os++;
    }
  }
  ls(t2) {
    const i = this.Li / this.rs;
    let n2 = Math.floor(t2), s = "";
    const e3 = void 0 !== this.os ? this.os : NaN;
    if (i > 1) {
      let r2 = +(Math.round(t2 * i) - n2 * i).toFixed(this.os);
      r2 >= i && (r2 -= i, n2 += 1), s = dt$1 + ft$1(+r2.toFixed(this.os) * this.rs, e3);
    } else
      n2 = Math.round(n2 * i) / i, e3 > 0 && (s = dt$1 + ft$1(0, e3));
    return n2.toFixed(0) + s;
  }
};
let pt$1 = class pt extends vt$1 {
  constructor(t2 = 100) {
    super(t2);
  }
  format(t2) {
    return `${super.format(t2)}%`;
  }
};
let mt$1 = class mt {
  constructor(t2) {
    this._s = t2;
  }
  format(t2) {
    let i = "";
    return t2 < 0 && (i = "-", t2 = -t2), t2 < 995 ? i + this.us(t2) : t2 < 999995 ? i + this.us(t2 / 1e3) + "K" : t2 < 999999995 ? (t2 = 1e3 * Math.round(t2 / 1e3), i + this.us(t2 / 1e6) + "M") : (t2 = 1e6 * Math.round(t2 / 1e6), i + this.us(t2 / 1e9) + "B");
  }
  us(t2) {
    let i;
    const n2 = Math.pow(10, this._s);
    return i = (t2 = Math.round(t2 * n2) / n2) >= 1e-15 && t2 < 1 ? t2.toFixed(this._s).replace(/\.?0+$/, "") : String(t2), i.replace(/(\.[1-9]*)0+$/, (t3, i2) => i2);
  }
};
function bt$1(t2, i, n2, s, e3, r2, h2) {
  if (0 === i.length || s.from >= i.length || s.to <= 0)
    return;
  const { context: l2, horizontalPixelRatio: a2, verticalPixelRatio: o2 } = t2, _24 = i[s.from];
  let u2 = r2(t2, _24), c2 = _24;
  if (s.to - s.from < 2) {
    const i2 = e3 / 2;
    l2.beginPath();
    const n3 = { et: _24.et - i2, rt: _24.rt }, s2 = { et: _24.et + i2, rt: _24.rt };
    l2.moveTo(n3.et * a2, n3.rt * o2), l2.lineTo(s2.et * a2, s2.rt * o2), h2(t2, u2, n3, s2);
  } else {
    const e4 = (i2, n3) => {
      h2(t2, u2, c2, n3), l2.beginPath(), u2 = i2, c2 = n3;
    };
    let d2 = c2;
    l2.beginPath(), l2.moveTo(_24.et * a2, _24.rt * o2);
    for (let h3 = s.from + 1; h3 < s.to; ++h3) {
      d2 = i[h3];
      const s2 = r2(t2, d2);
      switch (n2) {
        case 0:
          l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 1:
          l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2), s2 !== u2 && (e4(s2, d2), l2.lineTo(d2.et * a2, i[h3 - 1].rt * o2)), l2.lineTo(d2.et * a2, d2.rt * o2);
          break;
        case 2: {
          const [t3, n3] = xt$1(i, h3 - 1, h3);
          l2.bezierCurveTo(t3.et * a2, t3.rt * o2, n3.et * a2, n3.rt * o2, d2.et * a2, d2.rt * o2);
          break;
        }
      }
      1 !== n2 && s2 !== u2 && (e4(s2, d2), l2.moveTo(d2.et * a2, d2.rt * o2));
    }
    (c2 !== d2 || c2 === d2 && 1 === n2) && h2(t2, u2, c2, d2);
  }
}
const wt$1 = 6;
function gt$1(t2, i) {
  return { et: t2.et - i.et, rt: t2.rt - i.rt };
}
function Mt(t2, i) {
  return { et: t2.et / i, rt: t2.rt / i };
}
function xt$1(t2, i, n2) {
  const s = Math.max(0, i - 1), e3 = Math.min(t2.length - 1, n2 + 1);
  var r2, h2;
  return [(r2 = t2[i], h2 = Mt(gt$1(t2[n2], t2[s]), wt$1), { et: r2.et + h2.et, rt: r2.rt + h2.rt }), gt$1(t2[n2], Mt(gt$1(t2[e3], t2[i]), wt$1))];
}
function St$1(t2, i, n2, s, e3) {
  const { context: r2, horizontalPixelRatio: h2, verticalPixelRatio: l2 } = i;
  r2.lineTo(e3.et * h2, t2 * l2), r2.lineTo(s.et * h2, t2 * l2), r2.closePath(), r2.fillStyle = n2, r2.fill();
}
class kt extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    var i;
    if (null === this.tt)
      return;
    const { st: n2, nt: s, cs: e3, ht: r2, Wt: h2, ds: l2 } = this.tt, a2 = null !== (i = this.tt.fs) && void 0 !== i ? i : this.tt.vs ? 0 : t2.mediaSize.height;
    if (null === s)
      return;
    const o2 = t2.context;
    o2.lineCap = "butt", o2.lineJoin = "round", o2.lineWidth = r2, f(o2, h2), o2.lineWidth = 1, bt$1(t2, n2, l2, s, e3, this.ps.bind(this), St$1.bind(null, a2));
  }
}
function yt$1(t2, i, n2) {
  return Math.min(Math.max(t2, i), n2);
}
function Ct$1(t2, i, n2) {
  return i - t2 <= n2;
}
function Tt$1(t2) {
  const i = Math.ceil(t2);
  return i % 2 == 0 ? i - 1 : i;
}
let Pt$1 = class Pt {
  bs(t2, i) {
    const n2 = this.ws, { gs: s, Ms: e3, xs: r2, Ss: h2, ks: l2, fs: a2 } = i;
    if (void 0 === this.ys || void 0 === n2 || n2.gs !== s || n2.Ms !== e3 || n2.xs !== r2 || n2.Ss !== h2 || n2.fs !== a2 || n2.ks !== l2) {
      const n3 = t2.context.createLinearGradient(0, 0, 0, l2);
      if (n3.addColorStop(0, s), null != a2) {
        const i2 = yt$1(a2 * t2.verticalPixelRatio / l2, 0, 1);
        n3.addColorStop(i2, e3), n3.addColorStop(i2, r2);
      }
      n3.addColorStop(1, h2), this.ys = n3, this.ws = i;
    }
    return this.ys;
  }
};
let Rt$1 = class Rt extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    return this.Cs.bs(t2, { gs: i.Ts, Ms: "", xs: "", Ss: i.Ps, ks: t2.bitmapSize.height });
  }
};
function Dt$1(t2, i) {
  const n2 = t2.context;
  n2.strokeStyle = i, n2.stroke();
}
let Ot$1 = class Ot extends Y {
  constructor() {
    super(...arguments), this.tt = null;
  }
  it(t2) {
    this.tt = t2;
  }
  Z(t2) {
    if (null === this.tt)
      return;
    const { st: i, nt: n2, cs: s, ds: e3, ht: r2, Wt: h2, Rs: l2 } = this.tt;
    if (null === n2)
      return;
    const a2 = t2.context;
    a2.lineCap = "butt", a2.lineWidth = r2 * t2.verticalPixelRatio, f(a2, h2), a2.lineJoin = "round";
    const o2 = this.Ds.bind(this);
    void 0 !== e3 && bt$1(t2, i, e3, n2, s, o2, Dt$1), l2 && function(t3, i2, n3, s2, e4) {
      const { horizontalPixelRatio: r3, verticalPixelRatio: h3, context: l3 } = t3;
      let a3 = null;
      const o3 = Math.max(1, Math.floor(r3)) % 2 / 2, _24 = n3 * h3 + o3;
      for (let n4 = s2.to - 1; n4 >= s2.from; --n4) {
        const s3 = i2[n4];
        if (s3) {
          const i3 = e4(t3, s3);
          i3 !== a3 && (l3.beginPath(), null !== a3 && l3.fill(), l3.fillStyle = i3, a3 = i3);
          const n5 = Math.round(s3.et * r3) + o3, u2 = s3.rt * h3;
          l3.moveTo(n5, u2), l3.arc(n5, u2, _24, 0, 2 * Math.PI);
        }
      }
      l3.fill();
    }(t2, i, l2, n2, o2);
  }
};
let At$1 = class At extends Ot$1 {
  Ds(t2, i) {
    return i._t;
  }
};
function Vt$1(t2, i, n2, s, e3 = 0, r2 = i.length) {
  let h2 = r2 - e3;
  for (; 0 < h2; ) {
    const r3 = h2 >> 1, l2 = e3 + r3;
    s(i[l2], n2) === t2 ? (e3 = l2 + 1, h2 -= r3 + 1) : h2 = r3;
  }
  return e3;
}
const Bt$1 = Vt$1.bind(null, true), It$1 = Vt$1.bind(null, false);
function zt$1(t2, i) {
  return t2.ut < i;
}
function Et$1(t2, i) {
  return i < t2.ut;
}
function Lt$1(t2, i, n2) {
  const s = i.Os(), e3 = i.di(), r2 = Bt$1(t2, s, zt$1), h2 = It$1(t2, e3, Et$1);
  if (!n2)
    return { from: r2, to: h2 };
  let l2 = r2, a2 = h2;
  return r2 > 0 && r2 < t2.length && t2[r2].ut >= s && (l2 = r2 - 1), h2 > 0 && h2 < t2.length && t2[h2 - 1].ut <= e3 && (a2 = h2 + 1), { from: l2, to: a2 };
}
let Nt$1 = class Nt {
  constructor(t2, i, n2) {
    this.As = true, this.Vs = true, this.Bs = true, this.Is = [], this.zs = null, this.Es = t2, this.Ls = i, this.Ns = n2;
  }
  gt(t2) {
    this.As = true, "data" === t2 && (this.Vs = true), "options" === t2 && (this.Bs = true);
  }
  xt() {
    return this.Es.Tt() ? (this.Fs(), null === this.zs ? null : this.Ws) : null;
  }
  js() {
    this.Is = this.Is.map((t2) => Object.assign(Object.assign({}, t2), this.Es.$s().Hs(t2.ut)));
  }
  Us() {
    this.zs = null;
  }
  Fs() {
    this.Vs && (this.qs(), this.Vs = false), this.Bs && (this.js(), this.Bs = false), this.As && (this.Ys(), this.As = false);
  }
  Ys() {
    const t2 = this.Es.At(), i = this.Ls.yt();
    if (this.Us(), i.Fi() || t2.Fi())
      return;
    const n2 = i.Xs();
    if (null === n2)
      return;
    if (0 === this.Es.In().Ks())
      return;
    const s = this.Es.Pt();
    null !== s && (this.zs = Lt$1(this.Is, n2, this.Ns), this.Zs(t2, i, s.Vt), this.Gs());
  }
};
let Ft$1 = class Ft extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, true);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.Qs(this.Is, n2, E(this.zs));
  }
  te(t2, i) {
    return { ut: t2, ct: i, et: NaN, rt: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => {
      const n2 = i.Vt[3];
      return this.ne(i.se, n2, t2);
    });
  }
};
let Wt$1 = class Wt extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.ee = new Rt$1(), this.re = new At$1(), this.Ws.X([this.ee, this.re]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.ee.it({ ds: t2.lineType, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, fs: null, vs: t2.invertFilledArea, nt: this.zs, cs: this.Ls.yt().he() }), this.re.it({ ds: t2.lineVisible ? t2.lineType : void 0, st: this.Is, Wt: t2.lineStyle, ht: t2.lineWidth, nt: this.zs, cs: this.Ls.yt().he(), Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0 });
  }
};
let jt$1 = class jt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0, this.ae = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (null === this.Lt || 0 === this.Lt.In.length || null === this.Lt.nt)
      return;
    if (this.le = this.oe(i), this.le >= 2) {
      Math.max(1, Math.floor(i)) % 2 != this.le % 2 && this.le--;
    }
    this.ae = this.Lt._e ? Math.min(this.le, Math.floor(i)) : this.le;
    let s = null;
    const e3 = this.ae <= this.le && this.Lt.he >= Math.floor(1.5 * i);
    for (let r2 = this.Lt.nt.from; r2 < this.Lt.nt.to; ++r2) {
      const h2 = this.Lt.In[r2];
      s !== h2.ue && (t2.fillStyle = h2.ue, s = h2.ue);
      const l2 = Math.floor(0.5 * this.ae), a2 = Math.round(h2.et * i), o2 = a2 - l2, _24 = this.ae, u2 = o2 + _24 - 1, c2 = Math.min(h2.ce, h2.de), d2 = Math.max(h2.ce, h2.de), f2 = Math.round(c2 * n2) - l2, v2 = Math.round(d2 * n2) + l2, p2 = Math.max(v2 - f2, this.ae);
      t2.fillRect(o2, f2, _24, p2);
      const m2 = Math.ceil(1.5 * this.le);
      if (e3) {
        if (this.Lt.fe) {
          const i3 = a2 - m2;
          let s3 = Math.max(f2, Math.round(h2.ve * n2) - l2), e5 = s3 + _24 - 1;
          e5 > f2 + p2 - 1 && (e5 = f2 + p2 - 1, s3 = e5 - _24 + 1), t2.fillRect(i3, s3, o2 - i3, e5 - s3 + 1);
        }
        const i2 = a2 + m2;
        let s2 = Math.max(f2, Math.round(h2.pe * n2) - l2), e4 = s2 + _24 - 1;
        e4 > f2 + p2 - 1 && (e4 = f2 + p2 - 1, s2 = e4 - _24 + 1), t2.fillRect(u2 + 1, s2, i2 - u2, e4 - s2 + 1);
      }
    }
  }
  oe(t2) {
    const i = Math.floor(t2);
    return Math.max(i, Math.floor(function(t3, i2) {
      return Math.floor(0.3 * t3 * i2);
    }(b(this.Lt).he, t2)));
  }
};
let Ht$1 = class Ht extends Nt$1 {
  constructor(t2, i) {
    super(t2, i, false);
  }
  Zs(t2, i, n2) {
    i.Js(this.Is, E(this.zs)), t2.me(this.Is, n2, E(this.zs));
  }
  be(t2, i, n2) {
    return { ut: t2, we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3], et: NaN, ve: NaN, ce: NaN, de: NaN, pe: NaN };
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => this.ne(i.se, i, t2));
  }
};
let $t$1 = class $t extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new jt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), fe: t2.openVisible, _e: t2.thinBars, nt: this.zs });
  }
};
let Ut$1 = class Ut extends kt {
  constructor() {
    super(...arguments), this.Cs = new Pt$1();
  }
  ps(t2, i) {
    const n2 = this.tt;
    return this.Cs.bs(t2, { gs: i.Se, Ms: i.ke, xs: i.ye, Ss: i.Ce, ks: t2.bitmapSize.height, fs: n2.fs });
  }
};
let qt$1 = class qt extends Ot$1 {
  constructor() {
    super(...arguments), this.Te = new Pt$1();
  }
  Ds(t2, i) {
    const n2 = this.tt;
    return this.Te.bs(t2, { gs: i.Pe, Ms: i.Pe, xs: i.Re, Ss: i.Re, ks: t2.bitmapSize.height, fs: n2.fs });
  }
};
let Yt$1 = class Yt extends Ft$1 {
  constructor(t2, i) {
    super(t2, i), this.Ws = new W(), this.De = new Ut$1(), this.Oe = new qt$1(), this.Ws.X([this.De, this.Oe]);
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.Pt();
    if (null === t2)
      return;
    const i = this.Es.W(), n2 = this.Es.At().Ot(i.baseValue.price, t2.Vt), s = this.Ls.yt().he();
    this.De.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineType, fs: n2, vs: false, nt: this.zs, cs: s }), this.Oe.it({ st: this.Is, ht: i.lineWidth, Wt: i.lineStyle, ds: i.lineVisible ? i.lineType : void 0, Rs: i.pointMarkersVisible ? i.pointMarkersRadius || i.lineWidth / 2 + 2 : void 0, fs: n2, nt: this.zs, cs: s });
  }
};
let Xt$1 = class Xt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.le = 0;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z(t2) {
    if (null === this.Lt || 0 === this.Lt.In.length || null === this.Lt.nt)
      return;
    const { horizontalPixelRatio: i } = t2;
    if (this.le = function(t3, i2) {
      if (t3 >= 2.5 && t3 <= 4)
        return Math.floor(3 * i2);
      const n3 = 1 - 0.2 * Math.atan(Math.max(4, t3) - 4) / (0.5 * Math.PI), s2 = Math.floor(t3 * n3 * i2), e3 = Math.floor(t3 * i2), r2 = Math.min(s2, e3);
      return Math.max(Math.floor(i2), r2);
    }(this.Lt.he, i), this.le >= 2) {
      Math.floor(i) % 2 != this.le % 2 && this.le--;
    }
    const n2 = this.Lt.In;
    this.Lt.Ae && this.Ve(t2, n2, this.Lt.nt), this.Lt.ci && this.Be(t2, n2, this.Lt.nt);
    const s = this.Ie(i);
    (!this.Lt.ci || this.le > 2 * s) && this.ze(t2, n2, this.Lt.nt);
  }
  Ve(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "", l2 = Math.min(Math.floor(e3), Math.floor(this.Lt.he * e3));
    l2 = Math.max(Math.floor(e3), Math.min(l2, this.le));
    const a2 = Math.floor(0.5 * l2);
    let o2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Ee !== h2 && (s.fillStyle = n3.Ee, h2 = n3.Ee);
      const _24 = Math.round(Math.min(n3.ve, n3.pe) * r2), u2 = Math.round(Math.max(n3.ve, n3.pe) * r2), c2 = Math.round(n3.ce * r2), d2 = Math.round(n3.de * r2);
      let f2 = Math.round(e3 * n3.et) - a2;
      const v2 = f2 + l2 - 1;
      null !== o2 && (f2 = Math.max(o2 + 1, f2), f2 = Math.min(f2, v2));
      const p2 = v2 - f2 + 1;
      s.fillRect(f2, c2, p2, _24 - c2), s.fillRect(f2, u2 + 1, p2, d2 - u2), o2 = v2;
    }
  }
  Ie(t2) {
    let i = Math.floor(1 * t2);
    this.le <= 2 * i && (i = Math.floor(0.5 * (this.le - 1)));
    const n2 = Math.max(Math.floor(t2), i);
    return this.le <= 2 * n2 ? Math.max(Math.floor(t2), Math.floor(1 * t2)) : n2;
  }
  Be(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e3);
    let a2 = null;
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      n3.Le !== h2 && (s.fillStyle = n3.Le, h2 = n3.Le);
      let o2 = Math.round(n3.et * e3) - Math.floor(0.5 * this.le);
      const _24 = o2 + this.le - 1, u2 = Math.round(Math.min(n3.ve, n3.pe) * r2), c2 = Math.round(Math.max(n3.ve, n3.pe) * r2);
      if (null !== a2 && (o2 = Math.max(a2 + 1, o2), o2 = Math.min(o2, _24)), this.Lt.he * e3 > 2 * l2)
        Z$1(s, o2, u2, _24 - o2 + 1, c2 - u2 + 1, l2);
      else {
        const t4 = _24 - o2 + 1;
        s.fillRect(o2, u2, t4, c2 - u2 + 1);
      }
      a2 = _24;
    }
  }
  ze(t2, i, n2) {
    if (null === this.Lt)
      return;
    const { context: s, horizontalPixelRatio: e3, verticalPixelRatio: r2 } = t2;
    let h2 = "";
    const l2 = this.Ie(e3);
    for (let t3 = n2.from; t3 < n2.to; t3++) {
      const n3 = i[t3];
      let a2 = Math.round(Math.min(n3.ve, n3.pe) * r2), o2 = Math.round(Math.max(n3.ve, n3.pe) * r2), _24 = Math.round(n3.et * e3) - Math.floor(0.5 * this.le), u2 = _24 + this.le - 1;
      if (n3.ue !== h2) {
        const t4 = n3.ue;
        s.fillStyle = t4, h2 = t4;
      }
      this.Lt.ci && (_24 += l2, a2 += l2, u2 -= l2, o2 -= l2), a2 > o2 || s.fillRect(_24, a2, u2 - _24 + 1, o2 - a2 + 1);
    }
  }
};
let Kt$1 = class Kt extends Ht$1 {
  constructor() {
    super(...arguments), this.Ws = new Xt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.be(t2, i, n2)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W();
    this.Ws.it({ In: this.Is, he: this.Ls.yt().he(), Ae: t2.wickVisible, ci: t2.borderVisible, nt: this.zs });
  }
};
let Zt$1 = class Zt {
  constructor(t2, i) {
    this.Ne = t2, this.Li = i;
  }
  K(t2, i, n2) {
    this.Ne.draw(t2, this.Li, i, n2);
  }
};
let Gt$1 = class Gt extends Nt$1 {
  constructor(t2, i, n2) {
    super(t2, i, false), this.wn = n2, this.Ws = new Zt$1(this.wn.renderer(), (i2) => {
      const n3 = t2.Pt();
      return null === n3 ? null : t2.At().Ot(i2, n3.Vt);
    });
  }
  Fe(t2) {
    return this.wn.priceValueBuilder(t2);
  }
  We(t2) {
    return this.wn.isWhitespace(t2);
  }
  qs() {
    const t2 = this.Es.$s();
    this.Is = this.Es.In().ie().map((i) => Object.assign(Object.assign({ ut: i.se, et: NaN }, t2.Hs(i.se)), { je: i.He }));
  }
  Zs(t2, i) {
    i.Js(this.Is, E(this.zs));
  }
  Gs() {
    this.wn.update({ bars: this.Is.map(Jt$1), barSpacing: this.Ls.yt().he(), visibleRange: this.zs }, this.Es.W());
  }
};
function Jt$1(t2) {
  return { x: t2.et, time: t2.ut, originalData: t2.je, barColor: t2.ue };
}
let Qt$1 = class Qt extends Y {
  constructor() {
    super(...arguments), this.Lt = null, this.$e = [];
  }
  it(t2) {
    this.Lt = t2, this.$e = [];
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    if (null === this.Lt || 0 === this.Lt.st.length || null === this.Lt.nt)
      return;
    this.$e.length || this.Ue(i);
    const s = Math.max(1, Math.floor(n2)), e3 = Math.round(this.Lt.qe * n2) - Math.floor(s / 2), r2 = e3 + s;
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const h2 = this.Lt.st[i2], l2 = this.$e[i2 - this.Lt.nt.from], a2 = Math.round(h2.rt * n2);
      let o2, _24;
      t2.fillStyle = h2.ue, a2 <= e3 ? (o2 = a2, _24 = r2) : (o2 = e3, _24 = a2 - Math.floor(s / 2) + s), t2.fillRect(l2.Os, o2, l2.di - l2.Os + 1, _24 - o2);
    }
  }
  Ue(t2) {
    if (null === this.Lt || 0 === this.Lt.st.length || null === this.Lt.nt)
      return void (this.$e = []);
    const i = Math.ceil(this.Lt.he * t2) <= 1 ? 0 : Math.max(1, Math.floor(t2)), n2 = Math.round(this.Lt.he * t2) - i;
    this.$e = new Array(this.Lt.nt.to - this.Lt.nt.from);
    for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
      const s2 = this.Lt.st[i2], e3 = Math.round(s2.et * t2);
      let r2, h2;
      if (n2 % 2) {
        const t3 = (n2 - 1) / 2;
        r2 = e3 - t3, h2 = e3 + t3;
      } else {
        const t3 = n2 / 2;
        r2 = e3 - t3, h2 = e3 + t3 - 1;
      }
      this.$e[i2 - this.Lt.nt.from] = { Os: r2, di: h2, Ye: e3, Xe: s2.et * t2, ut: s2.ut };
    }
    for (let t3 = this.Lt.nt.from + 1; t3 < this.Lt.nt.to; t3++) {
      const n3 = this.$e[t3 - this.Lt.nt.from], s2 = this.$e[t3 - this.Lt.nt.from - 1];
      n3.ut === s2.ut + 1 && (n3.Os - s2.di !== i + 1 && (s2.Ye > s2.Xe ? s2.di = n3.Os - i - 1 : n3.Os = s2.di + i + 1));
    }
    let s = Math.ceil(this.Lt.he * t2);
    for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
      const i2 = this.$e[t3 - this.Lt.nt.from];
      i2.di < i2.Os && (i2.di = i2.Os);
      const n3 = i2.di - i2.Os + 1;
      s = Math.min(n3, s);
    }
    if (i > 0 && s < 4)
      for (let t3 = this.Lt.nt.from; t3 < this.Lt.nt.to; t3++) {
        const i2 = this.$e[t3 - this.Lt.nt.from];
        i2.di - i2.Os + 1 > s && (i2.Ye > i2.Xe ? i2.di -= 1 : i2.Os += 1);
      }
  }
};
class ti extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new Qt$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = { st: this.Is, he: this.Ls.yt().he(), nt: this.zs, qe: this.Es.At().Ot(this.Es.W().base, b(this.Es.Pt()).Vt) };
    this.Ws.it(t2);
  }
}
class ii extends Ft$1 {
  constructor() {
    super(...arguments), this.Ws = new At$1();
  }
  ne(t2, i, n2) {
    return Object.assign(Object.assign({}, this.te(t2, i)), n2.Hs(t2));
  }
  Gs() {
    const t2 = this.Es.W(), i = { st: this.Is, Wt: t2.lineStyle, ds: t2.lineVisible ? t2.lineType : void 0, ht: t2.lineWidth, Rs: t2.pointMarkersVisible ? t2.pointMarkersRadius || t2.lineWidth / 2 + 2 : void 0, nt: this.zs, cs: this.Ls.yt().he() };
    this.Ws.it(i);
  }
}
const ni = /[2-9]/g;
class si {
  constructor(t2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Je = {}, this.Qe = /* @__PURE__ */ new Map(), this.tr = t2;
  }
  ir() {
    this.Ke = 0, this.Qe.clear(), this.Ze = 1, this.Ge = 1, this.Je = {};
  }
  Si(t2, i, n2) {
    return this.nr(t2, i, n2).width;
  }
  xi(t2, i, n2) {
    const s = this.nr(t2, i, n2);
    return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2;
  }
  nr(t2, i, n2) {
    const s = n2 || ni, e3 = String(i).replace(s, "0");
    if (this.Qe.has(e3))
      return m$1(this.Qe.get(e3)).sr;
    if (this.Ke === this.tr) {
      const t3 = this.Je[this.Ge];
      delete this.Je[this.Ge], this.Qe.delete(t3), this.Ge++, this.Ke--;
    }
    t2.save(), t2.textBaseline = "middle";
    const r2 = t2.measureText(e3);
    return t2.restore(), 0 === r2.width && i.length || (this.Qe.set(e3, { sr: r2, er: this.Ze }), this.Je[this.Ze] = e3, this.Ke++, this.Ze++), r2;
  }
}
class ei {
  constructor(t2) {
    this.rr = null, this.k = null, this.hr = "right", this.lr = t2;
  }
  ar(t2, i, n2) {
    this.rr = t2, this.k = i, this.hr = n2;
  }
  K(t2) {
    null !== this.k && null !== this.rr && this.rr.K(t2, this.k, this.lr, this.hr);
  }
}
class ri {
  constructor(t2, i, n2) {
    this._r = t2, this.lr = new si(50), this.ur = i, this.F = n2, this.j = -1, this.Ht = new ei(this.lr);
  }
  xt() {
    const t2 = this.F.cr(this.ur);
    if (null === t2)
      return null;
    const i = t2.dr(this.ur) ? t2.vr() : this.ur.At();
    if (null === i)
      return null;
    const n2 = t2.pr(i);
    if ("overlay" === n2)
      return null;
    const s = this.F.mr();
    return s.P !== this.j && (this.j = s.P, this.lr.ir()), this.Ht.ar(this._r.zi(), s, n2), this.Ht;
  }
}
class hi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  br(t2, i) {
    var n2;
    if (!(null === (n2 = this.Lt) || void 0 === n2 ? void 0 : n2.Tt))
      return null;
    const { rt: s, ht: e3, wr: r2 } = this.Lt;
    return i >= s - e3 - 7 && i <= s + e3 + 7 ? { gr: this.Lt, wr: r2 } : null;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    if (false === this.Lt.Tt)
      return;
    const e3 = Math.round(this.Lt.rt * s);
    e3 < 0 || e3 > i.height || (t2.lineCap = "butt", t2.strokeStyle = this.Lt.O, t2.lineWidth = Math.floor(this.Lt.ht * n2), f(t2, this.Lt.Wt), v(t2, e3, 0, i.width));
  }
}
class li {
  constructor(t2) {
    this.Mr = { rt: 0, O: "rgba(0, 0, 0, 0)", ht: 1, Wt: 0, Tt: false }, this.Sr = new hi(), this.bt = true, this.Es = t2, this.Ls = t2.qt(), this.Sr.it(this.Mr);
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.Es.Tt() ? (this.bt && (this.kr(), this.bt = false), this.Sr) : null;
  }
}
class ai extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    this.Mr.Tt = false;
    const t2 = this.Es.At(), i = t2.yr().yr;
    if (2 !== i && 3 !== i)
      return;
    const n2 = this.Es.W();
    if (!n2.baseLineVisible || !this.Es.Tt())
      return;
    const s = this.Es.Pt();
    null !== s && (this.Mr.Tt = true, this.Mr.rt = t2.Ot(s.Vt, s.Vt), this.Mr.O = n2.baseLineColor, this.Mr.ht = n2.baseLineWidth, this.Mr.Wt = n2.baseLineStyle);
  }
}
class oi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  He() {
    return this.Lt;
  }
  Z({ context: t2, horizontalPixelRatio: i, verticalPixelRatio: n2 }) {
    const s = this.Lt;
    if (null === s)
      return;
    const e3 = Math.max(1, Math.floor(i)), r2 = e3 % 2 / 2, h2 = Math.round(s.Xe.x * i) + r2, l2 = s.Xe.y * n2;
    t2.fillStyle = s.Cr, t2.beginPath();
    const a2 = Math.max(2, 1.5 * s.Tr) * i;
    t2.arc(h2, l2, a2, 0, 2 * Math.PI, false), t2.fill(), t2.fillStyle = s.Pr, t2.beginPath(), t2.arc(h2, l2, s.ot * i, 0, 2 * Math.PI, false), t2.fill(), t2.lineWidth = e3, t2.strokeStyle = s.Rr, t2.beginPath(), t2.arc(h2, l2, s.ot * i + e3 / 2, 0, 2 * Math.PI, false), t2.stroke();
  }
}
const _i = [{ Dr: 0, Or: 0.25, Ar: 4, Vr: 10, Br: 0.25, Ir: 0, zr: 0.4, Er: 0.8 }, { Dr: 0.25, Or: 0.525, Ar: 10, Vr: 14, Br: 0, Ir: 0, zr: 0.8, Er: 0 }, { Dr: 0.525, Or: 1, Ar: 14, Vr: 14, Br: 0, Ir: 0, zr: 0, Er: 0 }];
function ui(t2, i, n2, s) {
  return function(t3, i2) {
    if ("transparent" === t3)
      return t3;
    const n3 = T$1(t3), s2 = n3[3];
    return `rgba(${n3[0]}, ${n3[1]}, ${n3[2]}, ${i2 * s2})`;
  }(t2, n2 + (s - n2) * i);
}
function ci(t2, i) {
  const n2 = t2 % 2600 / 2600;
  let s;
  for (const t3 of _i)
    if (n2 >= t3.Dr && n2 <= t3.Or) {
      s = t3;
      break;
    }
  p$1(void 0 !== s, "Last price animation internal logic error");
  const e3 = (n2 - s.Dr) / (s.Or - s.Dr);
  return { Pr: ui(i, e3, s.Br, s.Ir), Rr: ui(i, e3, s.zr, s.Er), ot: (r2 = e3, h2 = s.Ar, l2 = s.Vr, h2 + (l2 - h2) * r2) };
  var r2, h2, l2;
}
class di {
  constructor(t2) {
    this.Ht = new oi(), this.bt = true, this.Lr = true, this.Nr = performance.now(), this.Fr = this.Nr - 1, this.Wr = t2;
  }
  jr() {
    this.Fr = this.Nr - 1, this.gt();
  }
  Hr() {
    if (this.gt(), 2 === this.Wr.W().lastPriceAnimation) {
      const t2 = performance.now(), i = this.Fr - t2;
      if (i > 0)
        return void (i < 650 && (this.Fr += 2600));
      this.Nr = t2, this.Fr = t2 + 2600;
    }
  }
  gt() {
    this.bt = true;
  }
  $r() {
    this.Lr = true;
  }
  Tt() {
    return 0 !== this.Wr.W().lastPriceAnimation;
  }
  Ur() {
    switch (this.Wr.W().lastPriceAnimation) {
      case 0:
        return false;
      case 1:
        return true;
      case 2:
        return performance.now() <= this.Fr;
    }
  }
  xt() {
    return this.bt ? (this.St(), this.bt = false, this.Lr = false) : this.Lr && (this.qr(), this.Lr = false), this.Ht;
  }
  St() {
    this.Ht.it(null);
    const t2 = this.Wr.qt().yt(), i = t2.Xs(), n2 = this.Wr.Pt();
    if (null === i || null === n2)
      return;
    const s = this.Wr.Yr(true);
    if (s.Xr || !i.Kr(s.se))
      return;
    const e3 = { x: t2.Et(s.se), y: this.Wr.At().Ot(s.ct, n2.Vt) }, r2 = s.O, h2 = this.Wr.W().lineWidth, l2 = ci(this.Zr(), r2);
    this.Ht.it({ Cr: r2, Tr: h2, Pr: l2.Pr, Rr: l2.Rr, ot: l2.ot, Xe: e3 });
  }
  qr() {
    const t2 = this.Ht.He();
    if (null !== t2) {
      const i = ci(this.Zr(), t2.Cr);
      t2.Pr = i.Pr, t2.Rr = i.Rr, t2.ot = i.ot;
    }
  }
  Zr() {
    return this.Ur() ? performance.now() - this.Nr : 2599;
  }
}
function fi(t2, i) {
  return Tt$1(Math.min(Math.max(t2, 12), 30) * i);
}
function vi(t2, i) {
  switch (t2) {
    case "arrowDown":
    case "arrowUp":
      return fi(i, 1);
    case "circle":
      return fi(i, 0.8);
    case "square":
      return fi(i, 0.7);
  }
}
function pi(t2) {
  return function(t3) {
    const i = Math.ceil(t3);
    return i % 2 != 0 ? i - 1 : i;
  }(fi(t2, 1));
}
function mi(t2) {
  return Math.max(fi(t2, 0.1), 3);
}
function bi(t2, i, n2, s, e3) {
  const r2 = vi("square", n2), h2 = (r2 - 1) / 2, l2 = t2 - h2, a2 = i - h2;
  return s >= l2 && s <= l2 + r2 && e3 >= a2 && e3 <= a2 + r2;
}
function wi(t2, i, n2, s, e3) {
  const r2 = (vi("arrowUp", e3) - 1) / 2, h2 = (Tt$1(e3 / 2) - 1) / 2;
  i.beginPath(), t2 ? (i.moveTo(n2 - r2, s), i.lineTo(n2, s - r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s + r2), i.lineTo(n2 - h2, s + r2), i.lineTo(n2 - h2, s)) : (i.moveTo(n2 - r2, s), i.lineTo(n2, s + r2), i.lineTo(n2 + r2, s), i.lineTo(n2 + h2, s), i.lineTo(n2 + h2, s - r2), i.lineTo(n2 - h2, s - r2), i.lineTo(n2 - h2, s)), i.fill();
}
function gi(t2, i, n2, s, e3, r2) {
  return bi(i, n2, s, e3, r2);
}
class Mi extends j {
  constructor() {
    super(...arguments), this.Lt = null, this.lr = new si(), this.j = -1, this.H = "", this.Gr = "";
  }
  it(t2) {
    this.Lt = t2;
  }
  ar(t2, i) {
    this.j === t2 && this.H === i || (this.j = t2, this.H = i, this.Gr = N$1(t2, i), this.lr.ir());
  }
  br(t2, i) {
    if (null === this.Lt || null === this.Lt.nt)
      return null;
    for (let n2 = this.Lt.nt.from; n2 < this.Lt.nt.to; n2++) {
      const s = this.Lt.st[n2];
      if (Si(s, t2, i))
        return { gr: s.Jr, wr: s.wr };
    }
    return null;
  }
  Z({ context: t2 }, i, n2) {
    if (null !== this.Lt && null !== this.Lt.nt) {
      t2.textBaseline = "middle", t2.font = this.Gr;
      for (let i2 = this.Lt.nt.from; i2 < this.Lt.nt.to; i2++) {
        const n3 = this.Lt.st[i2];
        void 0 !== n3.Jt && (n3.Jt.$i = this.lr.Si(t2, n3.Jt.Qr), n3.Jt.zt = this.j, n3.Jt.et = n3.et - n3.Jt.$i / 2), xi(n3, t2);
      }
    }
  }
}
function xi(t2, i) {
  i.fillStyle = t2.O, void 0 !== t2.Jt && function(t3, i2, n2, s) {
    t3.fillText(i2, n2, s);
  }(i, t2.Jt.Qr, t2.Jt.et, t2.Jt.rt), function(t3, i2) {
    if (0 === t3.Ks)
      return;
    switch (t3.th) {
      case "arrowDown":
        return void wi(false, i2, t3.et, t3.rt, t3.Ks);
      case "arrowUp":
        return void wi(true, i2, t3.et, t3.rt, t3.Ks);
      case "circle":
        return void function(t4, i3, n2, s) {
          const e3 = (vi("circle", s) - 1) / 2;
          t4.beginPath(), t4.arc(i3, n2, e3, 0, 2 * Math.PI, false), t4.fill();
        }(i2, t3.et, t3.rt, t3.Ks);
      case "square":
        return void function(t4, i3, n2, s) {
          const e3 = vi("square", s), r2 = (e3 - 1) / 2, h2 = i3 - r2, l2 = n2 - r2;
          t4.fillRect(h2, l2, e3, e3);
        }(i2, t3.et, t3.rt, t3.Ks);
    }
    t3.th;
  }(t2, i);
}
function Si(t2, i, n2) {
  return !(void 0 === t2.Jt || !function(t3, i2, n3, s, e3, r2) {
    const h2 = s / 2;
    return e3 >= t3 && e3 <= t3 + n3 && r2 >= i2 - h2 && r2 <= i2 + h2;
  }(t2.Jt.et, t2.Jt.rt, t2.Jt.$i, t2.Jt.zt, i, n2)) || function(t3, i2, n3) {
    if (0 === t3.Ks)
      return false;
    switch (t3.th) {
      case "arrowDown":
      case "arrowUp":
        return gi(0, t3.et, t3.rt, t3.Ks, i2, n3);
      case "circle":
        return function(t4, i3, n4, s, e3) {
          const r2 = 2 + vi("circle", n4) / 2, h2 = t4 - s, l2 = i3 - e3;
          return Math.sqrt(h2 * h2 + l2 * l2) <= r2;
        }(t3.et, t3.rt, t3.Ks, i2, n3);
      case "square":
        return bi(t3.et, t3.rt, t3.Ks, i2, n3);
    }
  }(t2, i, n2);
}
function ki(t2, i, n2, s, e3, r2, h2, l2, a2) {
  const o2 = O$1(n2) ? n2 : n2.xe, _24 = O$1(n2) ? n2 : n2.ge, u2 = O$1(n2) ? n2 : n2.Me, c2 = O$1(i.size) ? Math.max(i.size, 0) : 1, d2 = pi(l2.he()) * c2, f2 = d2 / 2;
  switch (t2.Ks = d2, i.position) {
    case "inBar":
      return t2.rt = h2.Ot(o2, a2), void (void 0 !== t2.Jt && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e3));
    case "aboveBar":
      return t2.rt = h2.Ot(_24, a2) - f2 - s.ih, void 0 !== t2.Jt && (t2.Jt.rt = t2.rt - f2 - 0.6 * e3, s.ih += 1.2 * e3), void (s.ih += d2 + r2);
    case "belowBar":
      return t2.rt = h2.Ot(u2, a2) + f2 + s.nh, void 0 !== t2.Jt && (t2.Jt.rt = t2.rt + f2 + r2 + 0.6 * e3, s.nh += 1.2 * e3), void (s.nh += d2 + r2);
  }
  i.position;
}
class yi {
  constructor(t2, i) {
    this.bt = true, this.sh = true, this.eh = true, this.rh = null, this.Ht = new Mi(), this.Wr = t2, this.Ui = i, this.Lt = { st: [], nt: null };
  }
  gt(t2) {
    this.bt = true, this.eh = true, "data" === t2 && (this.sh = true);
  }
  xt(t2) {
    if (!this.Wr.Tt())
      return null;
    this.bt && this.hh();
    const i = this.Ui.W().layout;
    return this.Ht.ar(i.fontSize, i.fontFamily), this.Ht.it(this.Lt), this.Ht;
  }
  lh() {
    if (this.eh) {
      if (this.Wr.ah().length > 0) {
        const t2 = this.Ui.yt().he(), i = mi(t2), n2 = 1.5 * pi(t2) + 2 * i;
        this.rh = { above: n2, below: n2 };
      } else
        this.rh = null;
      this.eh = false;
    }
    return this.rh;
  }
  hh() {
    const t2 = this.Wr.At(), i = this.Ui.yt(), n2 = this.Wr.ah();
    this.sh && (this.Lt.st = n2.map((t3) => ({ ut: t3.time, et: 0, rt: 0, Ks: 0, th: t3.shape, O: t3.color, Jr: t3.Jr, wr: t3.id, Jt: void 0 })), this.sh = false);
    const s = this.Ui.W().layout;
    this.Lt.nt = null;
    const e3 = i.Xs();
    if (null === e3)
      return;
    const r2 = this.Wr.Pt();
    if (null === r2)
      return;
    if (0 === this.Lt.st.length)
      return;
    let h2 = NaN;
    const l2 = mi(i.he()), a2 = { ih: l2, nh: l2 };
    this.Lt.nt = Lt$1(this.Lt.st, e3, true);
    for (let e4 = this.Lt.nt.from; e4 < this.Lt.nt.to; e4++) {
      const o2 = n2[e4];
      o2.time !== h2 && (a2.ih = l2, a2.nh = l2, h2 = o2.time);
      const _24 = this.Lt.st[e4];
      _24.et = i.Et(o2.time), void 0 !== o2.text && o2.text.length > 0 && (_24.Jt = { Qr: o2.text, et: 0, rt: 0, $i: 0, zt: 0 });
      const u2 = this.Wr.oh(o2.time);
      null !== u2 && ki(_24, o2, u2, a2, s.fontSize, l2, t2, i, r2.Vt);
    }
    this.bt = false;
  }
}
class Ci extends li {
  constructor(t2) {
    super(t2);
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = false;
    const i = this.Es.W();
    if (!i.priceLineVisible || !this.Es.Tt())
      return;
    const n2 = this.Es.Yr(0 === i.priceLineSource);
    n2.Xr || (t2.Tt = true, t2.rt = n2.yi, t2.O = this.Es._h(n2.O), t2.ht = i.priceLineWidth, t2.Wt = i.priceLineStyle);
  }
}
class Ti extends st {
  constructor(t2) {
    super(), this.$t = t2;
  }
  Ei(t2, i, n2) {
    t2.Tt = false, i.Tt = false;
    const s = this.$t;
    if (!s.Tt())
      return;
    const e3 = s.W(), r2 = e3.lastValueVisible, h2 = "" !== s.uh(), l2 = 0 === e3.seriesLastValueMode, a2 = s.Yr(false);
    if (a2.Xr)
      return;
    r2 && (t2.Jt = this.dh(a2, r2, l2), t2.Tt = 0 !== t2.Jt.length), (h2 || l2) && (i.Jt = this.fh(a2, r2, h2, l2), i.Tt = i.Jt.length > 0);
    const o2 = s._h(a2.O), _24 = P(o2);
    n2.t = _24.t, n2.yi = a2.yi, i.Bt = s.qt().It(a2.yi / s.At().zt()), t2.Bt = o2, t2.O = _24.i, i.O = _24.i;
  }
  fh(t2, i, n2, s) {
    let e3 = "";
    const r2 = this.$t.uh();
    return n2 && 0 !== r2.length && (e3 += `${r2} `), i && s && (e3 += this.$t.At().ph() ? t2.mh : t2.bh), e3.trim();
  }
  dh(t2, i, n2) {
    return i ? n2 ? this.$t.At().ph() ? t2.bh : t2.mh : t2.Jt : "";
  }
}
function Pi(t2, i, n2, s) {
  const e3 = Number.isFinite(i), r2 = Number.isFinite(n2);
  return e3 && r2 ? t2(i, n2) : e3 || r2 ? e3 ? i : n2 : s;
}
class Ri {
  constructor(t2, i) {
    this.wh = t2, this.gh = i;
  }
  Mh(t2) {
    return null !== t2 && (this.wh === t2.wh && this.gh === t2.gh);
  }
  xh() {
    return new Ri(this.wh, this.gh);
  }
  Sh() {
    return this.wh;
  }
  kh() {
    return this.gh;
  }
  yh() {
    return this.gh - this.wh;
  }
  Fi() {
    return this.gh === this.wh || Number.isNaN(this.gh) || Number.isNaN(this.wh);
  }
  ts(t2) {
    return null === t2 ? this : new Ri(Pi(Math.min, this.Sh(), t2.Sh(), -1 / 0), Pi(Math.max, this.kh(), t2.kh(), 1 / 0));
  }
  Ch(t2) {
    if (!O$1(t2))
      return;
    if (0 === this.gh - this.wh)
      return;
    const i = 0.5 * (this.gh + this.wh);
    let n2 = this.gh - i, s = this.wh - i;
    n2 *= t2, s *= t2, this.gh = i + n2, this.wh = i + s;
  }
  Th(t2) {
    O$1(t2) && (this.gh += t2, this.wh += t2);
  }
  Ph() {
    return { minValue: this.wh, maxValue: this.gh };
  }
  static Rh(t2) {
    return null === t2 ? null : new Ri(t2.minValue, t2.maxValue);
  }
}
class Di {
  constructor(t2, i) {
    this.Dh = t2, this.Oh = i || null;
  }
  Ah() {
    return this.Dh;
  }
  Vh() {
    return this.Oh;
  }
  Ph() {
    return null === this.Dh ? null : { priceRange: this.Dh.Ph(), margins: this.Oh || void 0 };
  }
  static Rh(t2) {
    return null === t2 ? null : new Di(Ri.Rh(t2.priceRange), t2.margins);
  }
}
class Oi extends li {
  constructor(t2, i) {
    super(t2), this.Bh = i;
  }
  kr() {
    const t2 = this.Mr;
    t2.Tt = false;
    const i = this.Bh.W();
    if (!this.Es.Tt() || !i.lineVisible)
      return;
    const n2 = this.Bh.Ih();
    null !== n2 && (t2.Tt = true, t2.rt = n2, t2.O = i.color, t2.ht = i.lineWidth, t2.Wt = i.lineStyle, t2.wr = this.Bh.W().id);
  }
}
class Ai extends st {
  constructor(t2, i) {
    super(), this.Wr = t2, this.Bh = i;
  }
  Ei(t2, i, n2) {
    t2.Tt = false, i.Tt = false;
    const s = this.Bh.W(), e3 = s.axisLabelVisible, r2 = "" !== s.title, h2 = this.Wr;
    if (!e3 || !h2.Tt())
      return;
    const l2 = this.Bh.Ih();
    if (null === l2)
      return;
    r2 && (i.Jt = s.title, i.Tt = true), i.Bt = h2.qt().It(l2 / h2.At().zt()), t2.Jt = this.zh(s.price), t2.Tt = true;
    const a2 = P(s.axisLabelColor || s.color);
    n2.t = a2.t;
    const o2 = s.axisLabelTextColor || a2.i;
    t2.O = o2, i.O = o2, n2.yi = l2;
  }
  zh(t2) {
    const i = this.Wr.Pt();
    return null === i ? "" : this.Wr.At().Wi(t2, i.Vt);
  }
}
class Vi {
  constructor(t2, i) {
    this.Wr = t2, this.cn = i, this.Eh = new Oi(t2, this), this._r = new Ai(t2, this), this.Lh = new ri(this._r, t2, t2.qt());
  }
  Nh(t2) {
    D$1(this.cn, t2), this.gt(), this.Wr.qt().Fh();
  }
  W() {
    return this.cn;
  }
  Wh() {
    return this.Eh;
  }
  jh() {
    return this.Lh;
  }
  Hh() {
    return this._r;
  }
  gt() {
    this.Eh.gt(), this._r.gt();
  }
  Ih() {
    const t2 = this.Wr, i = t2.At();
    if (t2.qt().yt().Fi() || i.Fi())
      return null;
    const n2 = t2.Pt();
    return null === n2 ? null : i.Ot(this.cn.price, n2.Vt);
  }
}
class Bi extends at$1 {
  constructor(t2) {
    super(), this.Ui = t2;
  }
  qt() {
    return this.Ui;
  }
}
const Ii = { Bar: (t2, i, n2, s) => {
  var e3;
  const r2 = i.upColor, h2 = i.downColor, l2 = b(t2(n2, s)), a2 = w$1(l2.Vt[0]) <= w$1(l2.Vt[3]);
  return { ue: null !== (e3 = l2.O) && void 0 !== e3 ? e3 : a2 ? r2 : h2 };
}, Candlestick: (t2, i, n2, s) => {
  var e3, r2, h2;
  const l2 = i.upColor, a2 = i.downColor, o2 = i.borderUpColor, _24 = i.borderDownColor, u2 = i.wickUpColor, c2 = i.wickDownColor, d2 = b(t2(n2, s)), f2 = w$1(d2.Vt[0]) <= w$1(d2.Vt[3]);
  return { ue: null !== (e3 = d2.O) && void 0 !== e3 ? e3 : f2 ? l2 : a2, Le: null !== (r2 = d2.Bt) && void 0 !== r2 ? r2 : f2 ? o2 : _24, Ee: null !== (h2 = d2.$h) && void 0 !== h2 ? h2 : f2 ? u2 : c2 };
}, Custom: (t2, i, n2, s) => {
  var e3;
  return { ue: null !== (e3 = b(t2(n2, s)).O) && void 0 !== e3 ? e3 : i.color };
}, Area: (t2, i, n2, s) => {
  var e3, r2, h2, l2;
  const a2 = b(t2(n2, s));
  return { ue: null !== (e3 = a2._t) && void 0 !== e3 ? e3 : i.lineColor, _t: null !== (r2 = a2._t) && void 0 !== r2 ? r2 : i.lineColor, Ts: null !== (h2 = a2.Ts) && void 0 !== h2 ? h2 : i.topColor, Ps: null !== (l2 = a2.Ps) && void 0 !== l2 ? l2 : i.bottomColor };
}, Baseline: (t2, i, n2, s) => {
  var e3, r2, h2, l2, a2, o2;
  const _24 = b(t2(n2, s));
  return { ue: _24.Vt[3] >= i.baseValue.price ? i.topLineColor : i.bottomLineColor, Pe: null !== (e3 = _24.Pe) && void 0 !== e3 ? e3 : i.topLineColor, Re: null !== (r2 = _24.Re) && void 0 !== r2 ? r2 : i.bottomLineColor, Se: null !== (h2 = _24.Se) && void 0 !== h2 ? h2 : i.topFillColor1, ke: null !== (l2 = _24.ke) && void 0 !== l2 ? l2 : i.topFillColor2, ye: null !== (a2 = _24.ye) && void 0 !== a2 ? a2 : i.bottomFillColor1, Ce: null !== (o2 = _24.Ce) && void 0 !== o2 ? o2 : i.bottomFillColor2 };
}, Line: (t2, i, n2, s) => {
  var e3, r2;
  const h2 = b(t2(n2, s));
  return { ue: null !== (e3 = h2.O) && void 0 !== e3 ? e3 : i.color, _t: null !== (r2 = h2.O) && void 0 !== r2 ? r2 : i.color };
}, Histogram: (t2, i, n2, s) => {
  var e3;
  return { ue: null !== (e3 = b(t2(n2, s)).O) && void 0 !== e3 ? e3 : i.color };
} };
class zi {
  constructor(t2) {
    this.Uh = (t3, i) => void 0 !== i ? i.Vt : this.Wr.In().qh(t3), this.Wr = t2, this.Yh = Ii[t2.Xh()];
  }
  Hs(t2, i) {
    return this.Yh(this.Uh, this.Wr.W(), t2, i);
  }
}
var Ei;
!function(t2) {
  t2[t2.NearestLeft = -1] = "NearestLeft", t2[t2.None = 0] = "None", t2[t2.NearestRight = 1] = "NearestRight";
}(Ei || (Ei = {}));
const Li = 30;
class Ni {
  constructor() {
    this.Kh = [], this.Zh = /* @__PURE__ */ new Map(), this.Gh = /* @__PURE__ */ new Map();
  }
  Jh() {
    return this.Ks() > 0 ? this.Kh[this.Kh.length - 1] : null;
  }
  Qh() {
    return this.Ks() > 0 ? this.tl(0) : null;
  }
  Bn() {
    return this.Ks() > 0 ? this.tl(this.Kh.length - 1) : null;
  }
  Ks() {
    return this.Kh.length;
  }
  Fi() {
    return 0 === this.Ks();
  }
  Kr(t2) {
    return null !== this.il(t2, 0);
  }
  qh(t2) {
    return this.nl(t2);
  }
  nl(t2, i = 0) {
    const n2 = this.il(t2, i);
    return null === n2 ? null : Object.assign(Object.assign({}, this.sl(n2)), { se: this.tl(n2) });
  }
  ie() {
    return this.Kh;
  }
  el(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    for (const e3 of n2) {
      s = Fi(s, this.rl(t2, i, e3));
    }
    return s;
  }
  it(t2) {
    this.Gh.clear(), this.Zh.clear(), this.Kh = t2;
  }
  tl(t2) {
    return this.Kh[t2].se;
  }
  sl(t2) {
    return this.Kh[t2];
  }
  il(t2, i) {
    const n2 = this.hl(t2);
    if (null === n2 && 0 !== i)
      switch (i) {
        case -1:
          return this.ll(t2);
        case 1:
          return this.al(t2);
        default:
          throw new TypeError("Unknown search mode");
      }
    return n2;
  }
  ll(t2) {
    let i = this.ol(t2);
    return i > 0 && (i -= 1), i !== this.Kh.length && this.tl(i) < t2 ? i : null;
  }
  al(t2) {
    const i = this._l(t2);
    return i !== this.Kh.length && t2 < this.tl(i) ? i : null;
  }
  hl(t2) {
    const i = this.ol(t2);
    return i === this.Kh.length || t2 < this.Kh[i].se ? null : i;
  }
  ol(t2) {
    return Bt$1(this.Kh, t2, (t3, i) => t3.se < i);
  }
  _l(t2) {
    return It$1(this.Kh, t2, (t3, i) => t3.se > i);
  }
  ul(t2, i, n2) {
    let s = null;
    for (let e3 = t2; e3 < i; e3++) {
      const t3 = this.Kh[e3].Vt[n2];
      Number.isNaN(t3) || (null === s ? s = { cl: t3, dl: t3 } : (t3 < s.cl && (s.cl = t3), t3 > s.dl && (s.dl = t3)));
    }
    return s;
  }
  rl(t2, i, n2) {
    if (this.Fi())
      return null;
    let s = null;
    const e3 = b(this.Qh()), r2 = b(this.Bn()), h2 = Math.max(t2, e3), l2 = Math.min(i, r2), a2 = Math.ceil(h2 / Li) * Li, o2 = Math.max(a2, Math.floor(l2 / Li) * Li);
    {
      const t3 = this.ol(h2), e4 = this._l(Math.min(l2, a2, i));
      s = Fi(s, this.ul(t3, e4, n2));
    }
    let _24 = this.Zh.get(n2);
    void 0 === _24 && (_24 = /* @__PURE__ */ new Map(), this.Zh.set(n2, _24));
    for (let t3 = Math.max(a2 + 1, h2); t3 < o2; t3 += Li) {
      const i2 = Math.floor(t3 / Li);
      let e4 = _24.get(i2);
      if (void 0 === e4) {
        const t4 = this.ol(i2 * Li), s2 = this._l((i2 + 1) * Li - 1);
        e4 = this.ul(t4, s2, n2), _24.set(i2, e4);
      }
      s = Fi(s, e4);
    }
    {
      const t3 = this.ol(o2), i2 = this._l(l2);
      s = Fi(s, this.ul(t3, i2, n2));
    }
    return s;
  }
}
function Fi(t2, i) {
  if (null === t2)
    return i;
  if (null === i)
    return t2;
  return { cl: Math.min(t2.cl, i.cl), dl: Math.max(t2.dl, i.dl) };
}
class Wi {
  constructor(t2) {
    this.fl = t2;
  }
  K(t2, i, n2) {
    this.fl.draw(t2);
  }
  G(t2, i, n2) {
    var s, e3;
    null === (e3 = (s = this.fl).drawBackground) || void 0 === e3 || e3.call(s, t2);
  }
}
class ji {
  constructor(t2) {
    this.Qe = null, this.wn = t2;
  }
  xt() {
    var t2;
    const i = this.wn.renderer();
    if (null === i)
      return null;
    if ((null === (t2 = this.Qe) || void 0 === t2 ? void 0 : t2.vl) === i)
      return this.Qe.pl;
    const n2 = new Wi(i);
    return this.Qe = { vl: i, pl: n2 }, n2;
  }
  ml() {
    var t2, i, n2;
    return null !== (n2 = null === (i = (t2 = this.wn).zOrder) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : "normal";
  }
}
function Hi(t2) {
  var i, n2, s, e3, r2;
  return { Jt: t2.text(), yi: t2.coordinate(), ki: null === (i = t2.fixedCoordinate) || void 0 === i ? void 0 : i.call(t2), O: t2.textColor(), t: t2.backColor(), Tt: null === (s = null === (n2 = t2.visible) || void 0 === n2 ? void 0 : n2.call(t2)) || void 0 === s || s, ai: null === (r2 = null === (e3 = t2.tickVisible) || void 0 === e3 ? void 0 : e3.call(t2)) || void 0 === r2 || r2 };
}
class $i {
  constructor(t2, i) {
    this.Ht = new ht$1(), this.bl = t2, this.wl = i;
  }
  xt() {
    return this.Ht.it(Object.assign({ $i: this.wl.$i() }, Hi(this.bl))), this.Ht;
  }
}
class Ui extends st {
  constructor(t2, i) {
    super(), this.bl = t2, this.Li = i;
  }
  Ei(t2, i, n2) {
    const s = Hi(this.bl);
    n2.t = s.t, t2.O = s.O;
    const e3 = 2 / 12 * this.Li.P();
    n2.gi = e3, n2.Mi = e3, n2.yi = s.yi, n2.ki = s.ki, t2.Jt = s.Jt, t2.Tt = s.Tt, t2.ai = s.ai;
  }
}
class qi {
  constructor(t2, i) {
    this.gl = null, this.Ml = null, this.xl = null, this.Sl = null, this.kl = null, this.yl = t2, this.Wr = i;
  }
  Cl() {
    return this.yl;
  }
  On() {
    var t2, i;
    null === (i = (t2 = this.yl).updateAllViews) || void 0 === i || i.call(t2);
  }
  Pn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).paneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.gl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.gl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.gl = { vl: e3, pl: r2 }, r2;
  }
  tn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).timeAxisViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.Ml) || void 0 === s ? void 0 : s.vl) === e3)
      return this.Ml.pl;
    const r2 = this.Wr.qt().yt(), h2 = e3.map((t3) => new $i(t3, r2));
    return this.Ml = { vl: e3, pl: h2 }, h2;
  }
  Rn() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).priceAxisViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.xl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.xl.pl;
    const r2 = this.Wr.At(), h2 = e3.map((t3) => new Ui(t3, r2));
    return this.xl = { vl: e3, pl: h2 }, h2;
  }
  Tl() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).priceAxisPaneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.Sl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.Sl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.Sl = { vl: e3, pl: r2 }, r2;
  }
  Pl() {
    var t2, i, n2, s;
    const e3 = null !== (n2 = null === (i = (t2 = this.yl).timeAxisPaneViews) || void 0 === i ? void 0 : i.call(t2)) && void 0 !== n2 ? n2 : [];
    if ((null === (s = this.kl) || void 0 === s ? void 0 : s.vl) === e3)
      return this.kl.pl;
    const r2 = e3.map((t3) => new ji(t3));
    return this.kl = { vl: e3, pl: r2 }, r2;
  }
  Rl(t2, i) {
    var n2, s, e3;
    return null !== (e3 = null === (s = (n2 = this.yl).autoscaleInfo) || void 0 === s ? void 0 : s.call(n2, t2, i)) && void 0 !== e3 ? e3 : null;
  }
  br(t2, i) {
    var n2, s, e3;
    return null !== (e3 = null === (s = (n2 = this.yl).hitTest) || void 0 === s ? void 0 : s.call(n2, t2, i)) && void 0 !== e3 ? e3 : null;
  }
}
function Yi(t2, i, n2, s) {
  t2.forEach((t3) => {
    i(t3).forEach((t4) => {
      t4.ml() === n2 && s.push(t4);
    });
  });
}
function Xi(t2) {
  return t2.Pn();
}
function Ki(t2) {
  return t2.Tl();
}
function Zi(t2) {
  return t2.Pl();
}
class Gi extends Bi {
  constructor(t2, i, n2, s, e3) {
    super(t2), this.Lt = new Ni(), this.Eh = new Ci(this), this.Dl = [], this.Ol = new ai(this), this.Al = null, this.Vl = null, this.Bl = [], this.Il = [], this.zl = null, this.El = [], this.cn = i, this.Ll = n2;
    const r2 = new Ti(this);
    this.hn = [r2], this.Lh = new ri(r2, this, t2), "Area" !== n2 && "Line" !== n2 && "Baseline" !== n2 || (this.Al = new di(this)), this.Nl(), this.Fl(e3);
  }
  S() {
    null !== this.zl && clearTimeout(this.zl);
  }
  _h(t2) {
    return this.cn.priceLineColor || t2;
  }
  Yr(t2) {
    const i = { Xr: true }, n2 = this.At();
    if (this.qt().yt().Fi() || n2.Fi() || this.Lt.Fi())
      return i;
    const s = this.qt().yt().Xs(), e3 = this.Pt();
    if (null === s || null === e3)
      return i;
    let r2, h2;
    if (t2) {
      const t3 = this.Lt.Jh();
      if (null === t3)
        return i;
      r2 = t3, h2 = t3.se;
    } else {
      const t3 = this.Lt.nl(s.di(), -1);
      if (null === t3)
        return i;
      if (r2 = this.Lt.qh(t3.se), null === r2)
        return i;
      h2 = t3.se;
    }
    const l2 = r2.Vt[3], a2 = this.$s().Hs(h2, { Vt: r2 }), o2 = n2.Ot(l2, e3.Vt);
    return { Xr: false, ct: l2, Jt: n2.Wi(l2, e3.Vt), mh: n2.Wl(l2), bh: n2.jl(l2, e3.Vt), O: a2.ue, yi: o2, se: h2 };
  }
  $s() {
    return null !== this.Vl || (this.Vl = new zi(this)), this.Vl;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    const i = t2.priceScaleId;
    void 0 !== i && i !== this.cn.priceScaleId && this.qt().Hl(this, i), D$1(this.cn, t2), void 0 !== t2.priceFormat && (this.Nl(), this.qt().$l()), this.qt().Ul(this), this.qt().ql(), this.wn.gt("options");
  }
  it(t2, i) {
    this.Lt.it(t2), this.Yl(), this.wn.gt("data"), this.dn.gt("data"), null !== this.Al && (i && i.Xl ? this.Al.Hr() : 0 === t2.length && this.Al.jr());
    const n2 = this.qt().cr(this);
    this.qt().Kl(n2), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Zl(t2) {
    this.Bl = t2, this.Yl();
    const i = this.qt().cr(this);
    this.dn.gt("data"), this.qt().Kl(i), this.qt().Ul(this), this.qt().ql(), this.qt().Fh();
  }
  Gl() {
    return this.Bl;
  }
  ah() {
    return this.Il;
  }
  Jl(t2) {
    const i = new Vi(this, t2);
    return this.Dl.push(i), this.qt().Ul(this), i;
  }
  Ql(t2) {
    const i = this.Dl.indexOf(t2);
    -1 !== i && this.Dl.splice(i, 1), this.qt().Ul(this);
  }
  Xh() {
    return this.Ll;
  }
  Pt() {
    const t2 = this.ta();
    return null === t2 ? null : { Vt: t2.Vt[3], ia: t2.ut };
  }
  ta() {
    const t2 = this.qt().yt().Xs();
    if (null === t2)
      return null;
    const i = t2.Os();
    return this.Lt.nl(i, 1);
  }
  In() {
    return this.Lt;
  }
  oh(t2) {
    const i = this.Lt.qh(t2);
    return null === i ? null : "Bar" === this.Ll || "Candlestick" === this.Ll || "Custom" === this.Ll ? { we: i.Vt[0], ge: i.Vt[1], Me: i.Vt[2], xe: i.Vt[3] } : i.Vt[3];
  }
  na(t2) {
    const i = [];
    Yi(this.El, Xi, "top", i);
    const n2 = this.Al;
    return null !== n2 && n2.Tt() ? (null === this.zl && n2.Ur() && (this.zl = setTimeout(() => {
      this.zl = null, this.qt().sa();
    }, 0)), n2.$r(), i.push(n2), i) : i;
  }
  Pn() {
    const t2 = [];
    this.ea() || t2.push(this.Ol), t2.push(this.wn, this.Eh, this.dn);
    const i = this.Dl.map((t3) => t3.Wh());
    return t2.push(...i), Yi(this.El, Xi, "normal", t2), t2;
  }
  ra() {
    return this.ha(Xi, "bottom");
  }
  la(t2) {
    return this.ha(Ki, t2);
  }
  aa(t2) {
    return this.ha(Zi, t2);
  }
  oa(t2, i) {
    return this.El.map((n2) => n2.br(t2, i)).filter((t3) => null !== t3);
  }
  Qi(t2) {
    return [this.Lh, ...this.Dl.map((t3) => t3.jh())];
  }
  Rn(t2, i) {
    if (i !== this.Xi && !this.ea())
      return [];
    const n2 = [...this.hn];
    for (const t3 of this.Dl)
      n2.push(t3.Hh());
    return this.El.forEach((t3) => {
      n2.push(...t3.Rn());
    }), n2;
  }
  tn() {
    const t2 = [];
    return this.El.forEach((i) => {
      t2.push(...i.tn());
    }), t2;
  }
  Rl(t2, i) {
    if (void 0 !== this.cn.autoscaleInfoProvider) {
      const n2 = this.cn.autoscaleInfoProvider(() => {
        const n3 = this._a(t2, i);
        return null === n3 ? null : n3.Ph();
      });
      return Di.Rh(n2);
    }
    return this._a(t2, i);
  }
  ua() {
    return this.cn.priceFormat.minMove;
  }
  ca() {
    return this.da;
  }
  On() {
    var t2;
    this.wn.gt(), this.dn.gt();
    for (const t3 of this.hn)
      t3.gt();
    for (const t3 of this.Dl)
      t3.gt();
    this.Eh.gt(), this.Ol.gt(), null === (t2 = this.Al) || void 0 === t2 || t2.gt(), this.El.forEach((t3) => t3.On());
  }
  At() {
    return b(super.At());
  }
  Ct(t2) {
    if (!(("Line" === this.Ll || "Area" === this.Ll || "Baseline" === this.Ll) && this.cn.crosshairMarkerVisible))
      return null;
    const i = this.Lt.qh(t2);
    if (null === i)
      return null;
    return { ct: i.Vt[3], ot: this.fa(), Bt: this.va(), Dt: this.pa(), Rt: this.ma(t2) };
  }
  uh() {
    return this.cn.title;
  }
  Tt() {
    return this.cn.visible;
  }
  ba(t2) {
    this.El.push(new qi(t2, this));
  }
  wa(t2) {
    this.El = this.El.filter((i) => i.Cl() !== t2);
  }
  ga() {
    if (this.wn instanceof Gt$1 != false)
      return (t2) => this.wn.Fe(t2);
  }
  Ma() {
    if (this.wn instanceof Gt$1 != false)
      return (t2) => this.wn.We(t2);
  }
  ea() {
    return !ut$1(this.At().xa());
  }
  _a(t2, i) {
    if (!A$1(t2) || !A$1(i) || this.Lt.Fi())
      return null;
    const n2 = "Line" === this.Ll || "Area" === this.Ll || "Baseline" === this.Ll || "Histogram" === this.Ll ? [3] : [2, 1], s = this.Lt.el(t2, i, n2);
    let e3 = null !== s ? new Ri(s.cl, s.dl) : null;
    if ("Histogram" === this.Xh()) {
      const t3 = this.cn.base, i2 = new Ri(t3, t3);
      e3 = null !== e3 ? e3.ts(i2) : i2;
    }
    let r2 = this.dn.lh();
    return this.El.forEach((n3) => {
      const s2 = n3.Rl(t2, i);
      if (null == s2 ? void 0 : s2.priceRange) {
        const t3 = new Ri(s2.priceRange.minValue, s2.priceRange.maxValue);
        e3 = null !== e3 ? e3.ts(t3) : t3;
      }
      var h2, l2, a2, o2;
      (null == s2 ? void 0 : s2.margins) && (h2 = r2, l2 = s2.margins, r2 = { above: Math.max(null !== (a2 = null == h2 ? void 0 : h2.above) && void 0 !== a2 ? a2 : 0, l2.above), below: Math.max(null !== (o2 = null == h2 ? void 0 : h2.below) && void 0 !== o2 ? o2 : 0, l2.below) });
    }), new Di(e3, r2);
  }
  fa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerRadius;
    }
    return 0;
  }
  va() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t2 = this.cn.crosshairMarkerBorderColor;
        if (0 !== t2.length)
          return t2;
      }
    }
    return null;
  }
  pa() {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline":
        return this.cn.crosshairMarkerBorderWidth;
    }
    return 0;
  }
  ma(t2) {
    switch (this.Ll) {
      case "Line":
      case "Area":
      case "Baseline": {
        const t3 = this.cn.crosshairMarkerBackgroundColor;
        if (0 !== t3.length)
          return t3;
      }
    }
    return this.$s().Hs(t2).ue;
  }
  Nl() {
    switch (this.cn.priceFormat.type) {
      case "custom":
        this.da = { format: this.cn.priceFormat.formatter };
        break;
      case "volume":
        this.da = new mt$1(this.cn.priceFormat.precision);
        break;
      case "percent":
        this.da = new pt$1(this.cn.priceFormat.precision);
        break;
      default: {
        const t2 = Math.pow(10, this.cn.priceFormat.precision);
        this.da = new vt$1(t2, this.cn.priceFormat.minMove * t2);
      }
    }
    null !== this.Xi && this.Xi.Sa();
  }
  Yl() {
    const t2 = this.qt().yt();
    if (!t2.ka() || this.Lt.Fi())
      return void (this.Il = []);
    const i = b(this.Lt.Qh());
    this.Il = this.Bl.map((n2, s) => {
      const e3 = b(t2.ya(n2.time, true)), r2 = e3 < i ? 1 : -1;
      return { time: b(this.Lt.nl(e3, r2)).se, position: n2.position, shape: n2.shape, color: n2.color, id: n2.id, Jr: s, text: n2.text, size: n2.size, originalTime: n2.originalTime };
    });
  }
  Fl(t2) {
    switch (this.dn = new yi(this, this.qt()), this.Ll) {
      case "Bar":
        this.wn = new $t$1(this, this.qt());
        break;
      case "Candlestick":
        this.wn = new Kt$1(this, this.qt());
        break;
      case "Line":
        this.wn = new ii(this, this.qt());
        break;
      case "Custom":
        this.wn = new Gt$1(this, this.qt(), m$1(t2));
        break;
      case "Area":
        this.wn = new Wt$1(this, this.qt());
        break;
      case "Baseline":
        this.wn = new Yt$1(this, this.qt());
        break;
      case "Histogram":
        this.wn = new ti(this, this.qt());
        break;
      default:
        throw Error("Unknown chart style assigned: " + this.Ll);
    }
  }
  ha(t2, i) {
    const n2 = [];
    return Yi(this.El, t2, i, n2), n2;
  }
}
class Ji {
  constructor(t2) {
    this.cn = t2;
  }
  Ca(t2, i, n2) {
    let s = t2;
    if (0 === this.cn.mode)
      return s;
    const e3 = n2.vn(), r2 = e3.Pt();
    if (null === r2)
      return s;
    const h2 = e3.Ot(t2, r2), l2 = n2.Ta().filter((t3) => t3 instanceof Gi).reduce((t3, s2) => {
      if (n2.dr(s2) || !s2.Tt())
        return t3;
      const e4 = s2.At(), r3 = s2.In();
      if (e4.Fi() || !r3.Kr(i))
        return t3;
      const h3 = r3.qh(i);
      if (null === h3)
        return t3;
      const l3 = w$1(s2.Pt());
      return t3.concat([e4.Ot(h3.Vt[3], l3.Vt)]);
    }, []);
    if (0 === l2.length)
      return s;
    l2.sort((t3, i2) => Math.abs(t3 - h2) - Math.abs(i2 - h2));
    const a2 = l2[0];
    return s = e3.pn(a2, r2), s;
  }
}
class Qi extends Y {
  constructor() {
    super(...arguments), this.Lt = null;
  }
  it(t2) {
    this.Lt = t2;
  }
  Z({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (null === this.Lt)
      return;
    const e3 = Math.max(1, Math.floor(n2));
    t2.lineWidth = e3, function(t3, i2) {
      t3.save(), t3.lineWidth % 2 && t3.translate(0.5, 0.5), i2(), t3.restore();
    }(t2, () => {
      const r2 = b(this.Lt);
      if (r2.Pa) {
        t2.strokeStyle = r2.Ra, f(t2, r2.Da), t2.beginPath();
        for (const s2 of r2.Oa) {
          const r3 = Math.round(s2.Aa * n2);
          t2.moveTo(r3, -e3), t2.lineTo(r3, i.height + e3);
        }
        t2.stroke();
      }
      if (r2.Va) {
        t2.strokeStyle = r2.Ba, f(t2, r2.Ia), t2.beginPath();
        for (const n3 of r2.za) {
          const r3 = Math.round(n3.Aa * s);
          t2.moveTo(-e3, r3), t2.lineTo(i.width + e3, r3);
        }
        t2.stroke();
      }
    });
  }
}
let tn$1 = class tn {
  constructor(t2) {
    this.Ht = new Qi(), this.bt = true, this.nn = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    if (this.bt) {
      const t2 = this.nn.qt().W().grid, i = { Va: t2.horzLines.visible, Pa: t2.vertLines.visible, Ba: t2.horzLines.color, Ra: t2.vertLines.color, Ia: t2.horzLines.style, Da: t2.vertLines.style, za: this.nn.vn().Ea(), Oa: (this.nn.qt().yt().Ea() || []).map((t3) => ({ Aa: t3.coord })) };
      this.Ht.it(i), this.bt = false;
    }
    return this.Ht;
  }
};
let nn$1 = class nn {
  constructor(t2) {
    this.wn = new tn$1(t2);
  }
  Wh() {
    return this.wn;
  }
};
const sn$1 = { La: 4, Na: 1e-4 };
function en$1(t2, i) {
  const n2 = 100 * (t2 - i) / i;
  return i < 0 ? -n2 : n2;
}
function rn$1(t2, i) {
  const n2 = en$1(t2.Sh(), i), s = en$1(t2.kh(), i);
  return new Ri(n2, s);
}
function hn$1(t2, i) {
  const n2 = 100 * (t2 - i) / i + 100;
  return i < 0 ? -n2 : n2;
}
function ln$1(t2, i) {
  const n2 = hn$1(t2.Sh(), i), s = hn$1(t2.kh(), i);
  return new Ri(n2, s);
}
function an$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.log10(n2 + i.Na) + i.La;
  return t2 < 0 ? -s : s;
}
function on$1(t2, i) {
  const n2 = Math.abs(t2);
  if (n2 < 1e-15)
    return 0;
  const s = Math.pow(10, n2 - i.La) - i.Na;
  return t2 < 0 ? -s : s;
}
function _n(t2, i) {
  if (null === t2)
    return null;
  const n2 = an$1(t2.Sh(), i), s = an$1(t2.kh(), i);
  return new Ri(n2, s);
}
function un$1(t2, i) {
  if (null === t2)
    return null;
  const n2 = on$1(t2.Sh(), i), s = on$1(t2.kh(), i);
  return new Ri(n2, s);
}
function cn$1(t2) {
  if (null === t2)
    return sn$1;
  const i = Math.abs(t2.kh() - t2.Sh());
  if (i >= 1 || i < 1e-15)
    return sn$1;
  const n2 = Math.ceil(Math.abs(Math.log10(i))), s = sn$1.La + n2;
  return { La: s, Na: 1 / Math.pow(10, s) };
}
let dn$1 = class dn {
  constructor(t2, i) {
    if (this.Fa = t2, this.Wa = i, function(t3) {
      if (t3 < 0)
        return false;
      for (let i2 = t3; i2 > 1; i2 /= 10)
        if (i2 % 10 != 0)
          return false;
      return true;
    }(this.Fa))
      this.ja = [2, 2.5, 2];
    else {
      this.ja = [];
      for (let t3 = this.Fa; 1 !== t3; ) {
        if (t3 % 2 == 0)
          this.ja.push(2), t3 /= 2;
        else {
          if (t3 % 5 != 0)
            throw new Error("unexpected base");
          this.ja.push(2, 2.5), t3 /= 5;
        }
        if (this.ja.length > 100)
          throw new Error("something wrong with base");
      }
    }
  }
  Ha(t2, i, n2) {
    const s = 0 === this.Fa ? 0 : 1 / this.Fa;
    let e3 = Math.pow(10, Math.max(0, Math.ceil(Math.log10(t2 - i)))), r2 = 0, h2 = this.Wa[0];
    for (; ; ) {
      const t3 = Ct$1(e3, s, 1e-14) && e3 > s + 1e-14, i2 = Ct$1(e3, n2 * h2, 1e-14), l3 = Ct$1(e3, 1, 1e-14);
      if (!(t3 && i2 && l3))
        break;
      e3 /= h2, h2 = this.Wa[++r2 % this.Wa.length];
    }
    if (e3 <= s + 1e-14 && (e3 = s), e3 = Math.max(1, e3), this.ja.length > 0 && (l2 = e3, a2 = 1, o2 = 1e-14, Math.abs(l2 - a2) < o2))
      for (r2 = 0, h2 = this.ja[0]; Ct$1(e3, n2 * h2, 1e-14) && e3 > s + 1e-14; )
        e3 /= h2, h2 = this.ja[++r2 % this.ja.length];
    var l2, a2, o2;
    return e3;
  }
};
let fn$1 = class fn {
  constructor(t2, i, n2, s) {
    this.$a = [], this.Li = t2, this.Fa = i, this.Ua = n2, this.qa = s;
  }
  Ha(t2, i) {
    if (t2 < i)
      throw new Error("high < low");
    const n2 = this.Li.zt(), s = (t2 - i) * this.Ya() / n2, e3 = new dn$1(this.Fa, [2, 2.5, 2]), r2 = new dn$1(this.Fa, [2, 2, 2.5]), h2 = new dn$1(this.Fa, [2.5, 2, 2]), l2 = [];
    return l2.push(e3.Ha(t2, i, s), r2.Ha(t2, i, s), h2.Ha(t2, i, s)), function(t3) {
      if (t3.length < 1)
        throw Error("array is empty");
      let i2 = t3[0];
      for (let n3 = 1; n3 < t3.length; ++n3)
        t3[n3] < i2 && (i2 = t3[n3]);
      return i2;
    }(l2);
  }
  Xa() {
    const t2 = this.Li, i = t2.Pt();
    if (null === i)
      return void (this.$a = []);
    const n2 = t2.zt(), s = this.Ua(n2 - 1, i), e3 = this.Ua(0, i), r2 = this.Li.W().entireTextOnly ? this.Ka() / 2 : 0, h2 = r2, l2 = n2 - 1 - r2, a2 = Math.max(s, e3), o2 = Math.min(s, e3);
    if (a2 === o2)
      return void (this.$a = []);
    let _24 = this.Ha(a2, o2), u2 = a2 % _24;
    u2 += u2 < 0 ? _24 : 0;
    const c2 = a2 >= o2 ? 1 : -1;
    let d2 = null, f2 = 0;
    for (let n3 = a2 - u2; n3 > o2; n3 -= _24) {
      const s2 = this.qa(n3, i, true);
      null !== d2 && Math.abs(s2 - d2) < this.Ya() || (s2 < h2 || s2 > l2 || (f2 < this.$a.length ? (this.$a[f2].Aa = s2, this.$a[f2].Za = t2.Ga(n3)) : this.$a.push({ Aa: s2, Za: t2.Ga(n3) }), f2++, d2 = s2, t2.Ja() && (_24 = this.Ha(n3 * c2, o2))));
    }
    this.$a.length = f2;
  }
  Ea() {
    return this.$a;
  }
  Ka() {
    return this.Li.P();
  }
  Ya() {
    return Math.ceil(2.5 * this.Ka());
  }
};
function vn(t2) {
  return t2.slice().sort((t3, i) => b(t3.Zi()) - b(i.Zi()));
}
var pn$1;
!function(t2) {
  t2[t2.Normal = 0] = "Normal", t2[t2.Logarithmic = 1] = "Logarithmic", t2[t2.Percentage = 2] = "Percentage", t2[t2.IndexedTo100 = 3] = "IndexedTo100";
}(pn$1 || (pn$1 = {}));
const mn$1 = new pt$1(), bn = new vt$1(100, 1);
class wn {
  constructor(t2, i, n2, s) {
    this.Qa = 0, this.io = null, this.Dh = null, this.no = null, this.so = { eo: false, ro: null }, this.ho = 0, this.lo = 0, this.ao = new R(), this.oo = new R(), this._o = [], this.uo = null, this.co = null, this.do = null, this.fo = null, this.da = bn, this.vo = cn$1(null), this.po = t2, this.cn = i, this.mo = n2, this.bo = s, this.wo = new fn$1(this, 100, this.Mo.bind(this), this.xo.bind(this));
  }
  xa() {
    return this.po;
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    if (D$1(this.cn, t2), this.Sa(), void 0 !== t2.mode && this.So({ yr: t2.mode }), void 0 !== t2.scaleMargins) {
      const i = m$1(t2.scaleMargins.top), n2 = m$1(t2.scaleMargins.bottom);
      if (i < 0 || i > 1)
        throw new Error(`Invalid top margin - expect value between 0 and 1, given=${i}`);
      if (n2 < 0 || n2 > 1 || i + n2 > 1)
        throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n2}`);
      if (i + n2 > 1)
        throw new Error(`Invalid margins - sum of margins must be less than 1, given=${i + n2}`);
      this.ko(), this.co = null;
    }
  }
  yo() {
    return this.cn.autoScale;
  }
  Ja() {
    return 1 === this.cn.mode;
  }
  ph() {
    return 2 === this.cn.mode;
  }
  Co() {
    return 3 === this.cn.mode;
  }
  yr() {
    return { Wn: this.cn.autoScale, To: this.cn.invertScale, yr: this.cn.mode };
  }
  So(t2) {
    const i = this.yr();
    let n2 = null;
    void 0 !== t2.Wn && (this.cn.autoScale = t2.Wn), void 0 !== t2.yr && (this.cn.mode = t2.yr, 2 !== t2.yr && 3 !== t2.yr || (this.cn.autoScale = true), this.so.eo = false), 1 === i.yr && t2.yr !== i.yr && (!function(t3, i2) {
      if (null === t3)
        return false;
      const n3 = on$1(t3.Sh(), i2), s2 = on$1(t3.kh(), i2);
      return isFinite(n3) && isFinite(s2);
    }(this.Dh, this.vo) ? this.cn.autoScale = true : (n2 = un$1(this.Dh, this.vo), null !== n2 && this.Po(n2))), 1 === t2.yr && t2.yr !== i.yr && (n2 = _n(this.Dh, this.vo), null !== n2 && this.Po(n2));
    const s = i.yr !== this.cn.mode;
    s && (2 === i.yr || this.ph()) && this.Sa(), s && (3 === i.yr || this.Co()) && this.Sa(), void 0 !== t2.To && i.To !== t2.To && (this.cn.invertScale = t2.To, this.Ro()), this.oo.m(i, this.yr());
  }
  Do() {
    return this.oo;
  }
  P() {
    return this.mo.fontSize;
  }
  zt() {
    return this.Qa;
  }
  Oo(t2) {
    this.Qa !== t2 && (this.Qa = t2, this.ko(), this.co = null);
  }
  Ao() {
    if (this.io)
      return this.io;
    const t2 = this.zt() - this.Vo() - this.Bo();
    return this.io = t2, t2;
  }
  Ah() {
    return this.Io(), this.Dh;
  }
  Po(t2, i) {
    const n2 = this.Dh;
    (i || null === n2 && null !== t2 || null !== n2 && !n2.Mh(t2)) && (this.co = null, this.Dh = t2);
  }
  Fi() {
    return this.Io(), 0 === this.Qa || !this.Dh || this.Dh.Fi();
  }
  zo(t2) {
    return this.To() ? t2 : this.zt() - 1 - t2;
  }
  Ot(t2, i) {
    return this.ph() ? t2 = en$1(t2, i) : this.Co() && (t2 = hn$1(t2, i)), this.xo(t2, i);
  }
  Qs(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e3 = b(this.Ah()), r2 = e3.Sh(), h2 = e3.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = void 0 === n2 ? 0 : n2.from, u2 = void 0 === n2 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e4 = t2[n3], h3 = e4.ct;
      if (isNaN(h3))
        continue;
      let l3 = h3;
      null !== c2 && (l3 = c2(e4.ct, i));
      const _25 = s + o2 * (l3 - r2), u3 = a2 ? _25 : this.Qa - 1 - _25;
      e4.rt = u3;
    }
  }
  me(t2, i, n2) {
    this.Io();
    const s = this.Bo(), e3 = b(this.Ah()), r2 = e3.Sh(), h2 = e3.kh(), l2 = this.Ao() - 1, a2 = this.To(), o2 = l2 / (h2 - r2), _24 = void 0 === n2 ? 0 : n2.from, u2 = void 0 === n2 ? t2.length : n2.to, c2 = this.Eo();
    for (let n3 = _24; n3 < u2; n3++) {
      const e4 = t2[n3];
      let h3 = e4.we, l3 = e4.ge, _25 = e4.Me, u3 = e4.xe;
      null !== c2 && (h3 = c2(e4.we, i), l3 = c2(e4.ge, i), _25 = c2(e4.Me, i), u3 = c2(e4.xe, i));
      let d2 = s + o2 * (h3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2;
      e4.ve = f2, d2 = s + o2 * (l3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.ce = f2, d2 = s + o2 * (_25 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.de = f2, d2 = s + o2 * (u3 - r2), f2 = a2 ? d2 : this.Qa - 1 - d2, e4.pe = f2;
    }
  }
  pn(t2, i) {
    const n2 = this.Mo(t2, i);
    return this.Lo(n2, i);
  }
  Lo(t2, i) {
    let n2 = t2;
    return this.ph() ? n2 = function(t3, i2) {
      return i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i) : this.Co() && (n2 = function(t3, i2) {
      return t3 -= 100, i2 < 0 && (t3 = -t3), t3 / 100 * i2 + i2;
    }(n2, i)), n2;
  }
  Ta() {
    return this._o;
  }
  No() {
    if (this.uo)
      return this.uo;
    let t2 = [];
    for (let i = 0; i < this._o.length; i++) {
      const n2 = this._o[i];
      null === n2.Zi() && n2.Gi(i + 1), t2.push(n2);
    }
    return t2 = vn(t2), this.uo = t2, this.uo;
  }
  Fo(t2) {
    -1 === this._o.indexOf(t2) && (this._o.push(t2), this.Sa(), this.Wo());
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    if (-1 === i)
      throw new Error("source is not attached to scale");
    this._o.splice(i, 1), 0 === this._o.length && (this.So({ Wn: true }), this.Po(null)), this.Sa(), this.Wo();
  }
  Pt() {
    let t2 = null;
    for (const i of this._o) {
      const n2 = i.Pt();
      null !== n2 && ((null === t2 || n2.ia < t2.ia) && (t2 = n2));
    }
    return null === t2 ? null : t2.Vt;
  }
  To() {
    return this.cn.invertScale;
  }
  Ea() {
    const t2 = null === this.Pt();
    if (null !== this.co && (t2 || this.co.Ho === t2))
      return this.co.Ea;
    this.wo.Xa();
    const i = this.wo.Ea();
    return this.co = { Ea: i, Ho: t2 }, this.ao.m(), i;
  }
  $o() {
    return this.ao;
  }
  Uo(t2) {
    this.ph() || this.Co() || null === this.do && null === this.no && (this.Fi() || (this.do = this.Qa - t2, this.no = b(this.Ah()).xh()));
  }
  qo(t2) {
    if (this.ph() || this.Co())
      return;
    if (null === this.do)
      return;
    this.So({ Wn: false }), (t2 = this.Qa - t2) < 0 && (t2 = 0);
    let i = (this.do + 0.2 * (this.Qa - 1)) / (t2 + 0.2 * (this.Qa - 1));
    const n2 = b(this.no).xh();
    i = Math.max(i, 0.1), n2.Ch(i), this.Po(n2);
  }
  Yo() {
    this.ph() || this.Co() || (this.do = null, this.no = null);
  }
  Xo(t2) {
    this.yo() || null === this.fo && null === this.no && (this.Fi() || (this.fo = t2, this.no = b(this.Ah()).xh()));
  }
  Ko(t2) {
    if (this.yo())
      return;
    if (null === this.fo)
      return;
    const i = b(this.Ah()).yh() / (this.Ao() - 1);
    let n2 = t2 - this.fo;
    this.To() && (n2 *= -1);
    const s = n2 * i, e3 = b(this.no).xh();
    e3.Th(s), this.Po(e3, true), this.co = null;
  }
  Zo() {
    this.yo() || null !== this.fo && (this.fo = null, this.no = null);
  }
  ca() {
    return this.da || this.Sa(), this.da;
  }
  Wi(t2, i) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(en$1(t2, i));
      case 3:
        return this.ca().format(hn$1(t2, i));
      default:
        return this.zh(t2);
    }
  }
  Ga(t2) {
    switch (this.cn.mode) {
      case 2:
        return this.Go(t2);
      case 3:
        return this.ca().format(t2);
      default:
        return this.zh(t2);
    }
  }
  Wl(t2) {
    return this.zh(t2, b(this.Jo()).ca());
  }
  jl(t2, i) {
    return t2 = en$1(t2, i), this.Go(t2, mn$1);
  }
  Qo() {
    return this._o;
  }
  t_(t2) {
    this.so = { ro: t2, eo: false };
  }
  On() {
    this._o.forEach((t2) => t2.On());
  }
  Sa() {
    this.co = null;
    const t2 = this.Jo();
    let i = 100;
    null !== t2 && (i = Math.round(1 / t2.ua())), this.da = bn, this.ph() ? (this.da = mn$1, i = 100) : this.Co() ? (this.da = new vt$1(100, 1), i = 100) : null !== t2 && (this.da = t2.ca()), this.wo = new fn$1(this, i, this.Mo.bind(this), this.xo.bind(this)), this.wo.Xa();
  }
  Wo() {
    this.uo = null;
  }
  Jo() {
    return this._o[0] || null;
  }
  Vo() {
    return this.To() ? this.cn.scaleMargins.bottom * this.zt() + this.lo : this.cn.scaleMargins.top * this.zt() + this.ho;
  }
  Bo() {
    return this.To() ? this.cn.scaleMargins.top * this.zt() + this.ho : this.cn.scaleMargins.bottom * this.zt() + this.lo;
  }
  Io() {
    this.so.eo || (this.so.eo = true, this.i_());
  }
  ko() {
    this.io = null;
  }
  xo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    t2 = this.Ja() && t2 ? an$1(t2, this.vo) : t2;
    const n2 = b(this.Ah()), s = this.Bo() + (this.Ao() - 1) * (t2 - n2.Sh()) / n2.yh();
    return this.zo(s);
  }
  Mo(t2, i) {
    if (this.Io(), this.Fi())
      return 0;
    const n2 = this.zo(t2), s = b(this.Ah()), e3 = s.Sh() + s.yh() * ((n2 - this.Bo()) / (this.Ao() - 1));
    return this.Ja() ? on$1(e3, this.vo) : e3;
  }
  Ro() {
    this.co = null, this.wo.Xa();
  }
  i_() {
    const t2 = this.so.ro;
    if (null === t2)
      return;
    let i = null;
    const n2 = this.Qo();
    let s = 0, e3 = 0;
    for (const r3 of n2) {
      if (!r3.Tt())
        continue;
      const n3 = r3.Pt();
      if (null === n3)
        continue;
      const h3 = r3.Rl(t2.Os(), t2.di());
      let l2 = h3 && h3.Ah();
      if (null !== l2) {
        switch (this.cn.mode) {
          case 1:
            l2 = _n(l2, this.vo);
            break;
          case 2:
            l2 = rn$1(l2, n3.Vt);
            break;
          case 3:
            l2 = ln$1(l2, n3.Vt);
        }
        if (i = null === i ? l2 : i.ts(b(l2)), null !== h3) {
          const t3 = h3.Vh();
          null !== t3 && (s = Math.max(s, t3.above), e3 = Math.max(s, t3.below));
        }
      }
    }
    if (s === this.ho && e3 === this.lo || (this.ho = s, this.lo = e3, this.co = null, this.ko()), null !== i) {
      if (i.Sh() === i.kh()) {
        const t3 = this.Jo(), n3 = 5 * (null === t3 || this.ph() || this.Co() ? 1 : t3.ua());
        this.Ja() && (i = un$1(i, this.vo)), i = new Ri(i.Sh() - n3, i.kh() + n3), this.Ja() && (i = _n(i, this.vo));
      }
      if (this.Ja()) {
        const t3 = un$1(i, this.vo), n3 = cn$1(t3);
        if (r2 = n3, h2 = this.vo, r2.La !== h2.La || r2.Na !== h2.Na) {
          const s2 = null !== this.no ? un$1(this.no, this.vo) : null;
          this.vo = n3, i = _n(t3, n3), null !== s2 && (this.no = _n(s2, n3));
        }
      }
      this.Po(i);
    } else
      null === this.Dh && (this.Po(new Ri(-0.5, 0.5)), this.vo = cn$1(null));
    var r2, h2;
    this.so.eo = true;
  }
  Eo() {
    return this.ph() ? en$1 : this.Co() ? hn$1 : this.Ja() ? (t2) => an$1(t2, this.vo) : null;
  }
  n_(t2, i, n2) {
    return void 0 === i ? (void 0 === n2 && (n2 = this.ca()), n2.format(t2)) : i(t2);
  }
  zh(t2, i) {
    return this.n_(t2, this.bo.priceFormatter, i);
  }
  Go(t2, i) {
    return this.n_(t2, this.bo.percentageFormatter, i);
  }
}
let gn$1 = class gn {
  constructor(t2, i) {
    this._o = [], this.s_ = /* @__PURE__ */ new Map(), this.Qa = 0, this.e_ = 0, this.r_ = 1e3, this.uo = null, this.h_ = new R(), this.wl = t2, this.Ui = i, this.l_ = new nn$1(this);
    const n2 = i.W();
    this.a_ = this.o_("left", n2.leftPriceScale), this.__ = this.o_("right", n2.rightPriceScale), this.a_.Do().l(this.u_.bind(this, this.a_), this), this.__.Do().l(this.u_.bind(this, this.__), this), this.c_(n2);
  }
  c_(t2) {
    if (t2.leftPriceScale && this.a_.Nh(t2.leftPriceScale), t2.rightPriceScale && this.__.Nh(t2.rightPriceScale), t2.localization && (this.a_.Sa(), this.__.Sa()), t2.overlayPriceScales) {
      const i = Array.from(this.s_.values());
      for (const n2 of i) {
        const i2 = b(n2[0].At());
        i2.Nh(t2.overlayPriceScales), t2.localization && i2.Sa();
      }
    }
  }
  d_(t2) {
    switch (t2) {
      case "left":
        return this.a_;
      case "right":
        return this.__;
    }
    return this.s_.has(t2) ? m$1(this.s_.get(t2))[0].At() : null;
  }
  S() {
    this.qt().f_().p(this), this.a_.Do().p(this), this.__.Do().p(this), this._o.forEach((t2) => {
      t2.S && t2.S();
    }), this.h_.m();
  }
  v_() {
    return this.r_;
  }
  p_(t2) {
    this.r_ = t2;
  }
  qt() {
    return this.Ui;
  }
  $i() {
    return this.e_;
  }
  zt() {
    return this.Qa;
  }
  m_(t2) {
    this.e_ = t2, this.b_();
  }
  Oo(t2) {
    this.Qa = t2, this.a_.Oo(t2), this.__.Oo(t2), this._o.forEach((i) => {
      if (this.dr(i)) {
        const n2 = i.At();
        null !== n2 && n2.Oo(t2);
      }
    }), this.b_();
  }
  Ta() {
    return this._o;
  }
  dr(t2) {
    const i = t2.At();
    return null === i || this.a_ !== i && this.__ !== i;
  }
  Fo(t2, i, n2) {
    const s = void 0 !== n2 ? n2 : this.g_().w_ + 1;
    this.M_(t2, i, s);
  }
  jo(t2) {
    const i = this._o.indexOf(t2);
    p$1(-1 !== i, "removeDataSource: invalid data source"), this._o.splice(i, 1);
    const n2 = b(t2.At()).xa();
    if (this.s_.has(n2)) {
      const i2 = m$1(this.s_.get(n2)), s2 = i2.indexOf(t2);
      -1 !== s2 && (i2.splice(s2, 1), 0 === i2.length && this.s_.delete(n2));
    }
    const s = t2.At();
    s && s.Ta().indexOf(t2) >= 0 && s.jo(t2), null !== s && (s.Wo(), this.x_(s)), this.uo = null;
  }
  pr(t2) {
    return t2 === this.a_ ? "left" : t2 === this.__ ? "right" : "overlay";
  }
  S_() {
    return this.a_;
  }
  k_() {
    return this.__;
  }
  y_(t2, i) {
    t2.Uo(i);
  }
  C_(t2, i) {
    t2.qo(i), this.b_();
  }
  T_(t2) {
    t2.Yo();
  }
  P_(t2, i) {
    t2.Xo(i);
  }
  R_(t2, i) {
    t2.Ko(i), this.b_();
  }
  D_(t2) {
    t2.Zo();
  }
  b_() {
    this._o.forEach((t2) => {
      t2.On();
    });
  }
  vn() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible && 0 !== this.__.Ta().length ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && 0 !== this.a_.Ta().length ? t2 = this.a_ : 0 !== this._o.length && (t2 = this._o[0].At()), null === t2 && (t2 = this.__), t2;
  }
  vr() {
    let t2 = null;
    return this.Ui.W().rightPriceScale.visible ? t2 = this.__ : this.Ui.W().leftPriceScale.visible && (t2 = this.a_), t2;
  }
  x_(t2) {
    null !== t2 && t2.yo() && this.O_(t2);
  }
  A_(t2) {
    const i = this.wl.Xs();
    t2.So({ Wn: true }), null !== i && t2.t_(i), this.b_();
  }
  V_() {
    this.O_(this.a_), this.O_(this.__);
  }
  B_() {
    this.x_(this.a_), this.x_(this.__), this._o.forEach((t2) => {
      this.dr(t2) && this.x_(t2.At());
    }), this.b_(), this.Ui.Fh();
  }
  No() {
    return null === this.uo && (this.uo = vn(this._o)), this.uo;
  }
  I_() {
    return this.h_;
  }
  z_() {
    return this.l_;
  }
  O_(t2) {
    const i = t2.Qo();
    if (i && i.length > 0 && !this.wl.Fi()) {
      const i2 = this.wl.Xs();
      null !== i2 && t2.t_(i2);
    }
    t2.On();
  }
  g_() {
    const t2 = this.No();
    if (0 === t2.length)
      return { E_: 0, w_: 0 };
    let i = 0, n2 = 0;
    for (let s = 0; s < t2.length; s++) {
      const e3 = t2[s].Zi();
      null !== e3 && (e3 < i && (i = e3), e3 > n2 && (n2 = e3));
    }
    return { E_: i, w_: n2 };
  }
  M_(t2, i, n2) {
    let s = this.d_(i);
    if (null === s && (s = this.o_(i, this.Ui.W().overlayPriceScales)), this._o.push(t2), !ut$1(i)) {
      const n3 = this.s_.get(i) || [];
      n3.push(t2), this.s_.set(i, n3);
    }
    s.Fo(t2), t2.Ji(s), t2.Gi(n2), this.x_(s), this.uo = null;
  }
  u_(t2, i, n2) {
    i.yr !== n2.yr && this.O_(t2);
  }
  o_(t2, i) {
    const n2 = Object.assign({ visible: true, autoScale: true }, I(i)), s = new wn(t2, n2, this.Ui.W().layout, this.Ui.W().localization);
    return s.Oo(this.zt()), s;
  }
};
let Mn$1 = class Mn {
  constructor(t2, i, n2 = 50) {
    this.Ke = 0, this.Ze = 1, this.Ge = 1, this.Qe = /* @__PURE__ */ new Map(), this.Je = /* @__PURE__ */ new Map(), this.L_ = t2, this.N_ = i, this.tr = n2;
  }
  F_(t2) {
    const i = t2.time, n2 = this.N_.cacheKey(i), s = this.Qe.get(n2);
    if (void 0 !== s)
      return s.W_;
    if (this.Ke === this.tr) {
      const t3 = this.Je.get(this.Ge);
      this.Je.delete(this.Ge), this.Qe.delete(m$1(t3)), this.Ge++, this.Ke--;
    }
    const e3 = this.L_(t2);
    return this.Qe.set(n2, { W_: e3, er: this.Ze }), this.Je.set(this.Ze, n2), this.Ke++, this.Ze++, e3;
  }
};
let xn$1 = class xn {
  constructor(t2, i) {
    p$1(t2 <= i, "right should be >= left"), this.j_ = t2, this.H_ = i;
  }
  Os() {
    return this.j_;
  }
  di() {
    return this.H_;
  }
  U_() {
    return this.H_ - this.j_ + 1;
  }
  Kr(t2) {
    return this.j_ <= t2 && t2 <= this.H_;
  }
  Mh(t2) {
    return this.j_ === t2.Os() && this.H_ === t2.di();
  }
};
function Sn(t2, i) {
  return null === t2 || null === i ? t2 === i : t2.Mh(i);
}
let kn$1 = class kn {
  constructor() {
    this.q_ = /* @__PURE__ */ new Map(), this.Qe = null, this.Y_ = false;
  }
  X_(t2) {
    this.Y_ = t2, this.Qe = null;
  }
  K_(t2, i) {
    this.Z_(i), this.Qe = null;
    for (let n2 = i; n2 < t2.length; ++n2) {
      const i2 = t2[n2];
      let s = this.q_.get(i2.timeWeight);
      void 0 === s && (s = [], this.q_.set(i2.timeWeight, s)), s.push({ index: n2, time: i2.time, weight: i2.timeWeight, originalTime: i2.originalTime });
    }
  }
  G_(t2, i) {
    const n2 = Math.ceil(i / t2);
    return null !== this.Qe && this.Qe.J_ === n2 || (this.Qe = { Ea: this.Q_(n2), J_: n2 }), this.Qe.Ea;
  }
  Z_(t2) {
    if (0 === t2)
      return void this.q_.clear();
    const i = [];
    this.q_.forEach((n2, s) => {
      t2 <= n2[0].index ? i.push(s) : n2.splice(Bt$1(n2, t2, (i2) => i2.index < t2), 1 / 0);
    });
    for (const t3 of i)
      this.q_.delete(t3);
  }
  Q_(t2) {
    let i = [];
    for (const n2 of Array.from(this.q_.keys()).sort((t3, i2) => i2 - t3)) {
      if (!this.q_.get(n2))
        continue;
      const s = i;
      i = [];
      const e3 = s.length;
      let r2 = 0;
      const h2 = m$1(this.q_.get(n2)), l2 = h2.length;
      let a2 = 1 / 0, o2 = -1 / 0;
      for (let n3 = 0; n3 < l2; n3++) {
        const l3 = h2[n3], _24 = l3.index;
        for (; r2 < e3; ) {
          const t3 = s[r2], n4 = t3.index;
          if (!(n4 < _24)) {
            a2 = n4;
            break;
          }
          r2++, i.push(t3), o2 = n4, a2 = 1 / 0;
        }
        if (a2 - _24 >= t2 && _24 - o2 >= t2)
          i.push(l3), o2 = _24;
        else if (this.Y_)
          return s;
      }
      for (; r2 < e3; r2++)
        i.push(s[r2]);
    }
    return i;
  }
};
let yn$1 = class yn {
  constructor(t2) {
    this.tu = t2;
  }
  iu() {
    return null === this.tu ? null : new xn$1(Math.floor(this.tu.Os()), Math.ceil(this.tu.di()));
  }
  nu() {
    return this.tu;
  }
  static su() {
    return new yn(null);
  }
};
function Cn(t2, i) {
  return t2.weight > i.weight ? t2 : i;
}
class Tn {
  constructor(t2, i, n2, s) {
    this.e_ = 0, this.eu = null, this.ru = [], this.fo = null, this.do = null, this.hu = new kn$1(), this.lu = /* @__PURE__ */ new Map(), this.au = yn$1.su(), this.ou = true, this._u = new R(), this.uu = new R(), this.cu = new R(), this.du = null, this.fu = null, this.vu = [], this.cn = i, this.bo = n2, this.pu = i.rightOffset, this.mu = i.barSpacing, this.Ui = t2, this.N_ = s, this.bu(), this.hu.X_(i.uniformDistribution);
  }
  W() {
    return this.cn;
  }
  wu(t2) {
    D$1(this.bo, t2), this.gu(), this.bu();
  }
  Nh(t2, i) {
    var n2;
    D$1(this.cn, t2), this.cn.fixLeftEdge && this.Mu(), this.cn.fixRightEdge && this.xu(), void 0 !== t2.barSpacing && this.Ui.Gn(t2.barSpacing), void 0 !== t2.rightOffset && this.Ui.Jn(t2.rightOffset), void 0 !== t2.minBarSpacing && this.Ui.Gn(null !== (n2 = t2.barSpacing) && void 0 !== n2 ? n2 : this.mu), this.gu(), this.bu(), this.cu.m();
  }
  mn(t2) {
    var i, n2;
    return null !== (n2 = null === (i = this.ru[t2]) || void 0 === i ? void 0 : i.time) && void 0 !== n2 ? n2 : null;
  }
  qi(t2) {
    var i;
    return null !== (i = this.ru[t2]) && void 0 !== i ? i : null;
  }
  ya(t2, i) {
    if (this.ru.length < 1)
      return null;
    if (this.N_.key(t2) > this.N_.key(this.ru[this.ru.length - 1].time))
      return i ? this.ru.length - 1 : null;
    const n2 = Bt$1(this.ru, this.N_.key(t2), (t3, i2) => this.N_.key(t3.time) < i2);
    return this.N_.key(t2) < this.N_.key(this.ru[n2].time) ? i ? n2 : null : n2;
  }
  Fi() {
    return 0 === this.e_ || 0 === this.ru.length || null === this.eu;
  }
  ka() {
    return this.ru.length > 0;
  }
  Xs() {
    return this.Su(), this.au.iu();
  }
  ku() {
    return this.Su(), this.au.nu();
  }
  yu() {
    const t2 = this.Xs();
    if (null === t2)
      return null;
    const i = { from: t2.Os(), to: t2.di() };
    return this.Cu(i);
  }
  Cu(t2) {
    const i = Math.round(t2.from), n2 = Math.round(t2.to), s = b(this.Tu()), e3 = b(this.Pu());
    return { from: b(this.qi(Math.max(s, i))), to: b(this.qi(Math.min(e3, n2))) };
  }
  Ru(t2) {
    return { from: b(this.ya(t2.from, true)), to: b(this.ya(t2.to, true)) };
  }
  $i() {
    return this.e_;
  }
  m_(t2) {
    if (!isFinite(t2) || t2 <= 0)
      return;
    if (this.e_ === t2)
      return;
    const i = this.ku(), n2 = this.e_;
    if (this.e_ = t2, this.ou = true, this.cn.lockVisibleTimeRangeOnResize && 0 !== n2) {
      const i2 = this.mu * t2 / n2;
      this.mu = i2;
    }
    if (this.cn.fixLeftEdge && null !== i && i.Os() <= 0) {
      const i2 = n2 - t2;
      this.pu -= Math.round(i2 / this.mu) + 1, this.ou = true;
    }
    this.Du(), this.Ou();
  }
  Et(t2) {
    if (this.Fi() || !A$1(t2))
      return 0;
    const i = this.Au() + this.pu - t2;
    return this.e_ - (i + 0.5) * this.mu - 1;
  }
  Js(t2, i) {
    const n2 = this.Au(), s = void 0 === i ? 0 : i.from, e3 = void 0 === i ? t2.length : i.to;
    for (let i2 = s; i2 < e3; i2++) {
      const s2 = t2[i2].ut, e4 = n2 + this.pu - s2, r2 = this.e_ - (e4 + 0.5) * this.mu - 1;
      t2[i2].et = r2;
    }
  }
  Vu(t2) {
    return Math.ceil(this.Bu(t2));
  }
  Jn(t2) {
    this.ou = true, this.pu = t2, this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  he() {
    return this.mu;
  }
  Gn(t2) {
    this.zu(t2), this.Ou(), this.Ui.Iu(), this.Ui.Fh();
  }
  Eu() {
    return this.pu;
  }
  Ea() {
    if (this.Fi())
      return null;
    if (null !== this.fu)
      return this.fu;
    const t2 = this.mu, i = 5 * (this.Ui.W().layout.fontSize + 4) / 8 * (this.cn.tickMarkMaxCharacterLength || 8), n2 = Math.round(i / t2), s = b(this.Xs()), e3 = Math.max(s.Os(), s.Os() - n2), r2 = Math.max(s.di(), s.di() - n2), h2 = this.hu.G_(t2, i), l2 = this.Tu() + n2, a2 = this.Pu() - n2, o2 = this.Lu(), _24 = this.cn.fixLeftEdge || o2, u2 = this.cn.fixRightEdge || o2;
    let c2 = 0;
    for (const t3 of h2) {
      if (!(e3 <= t3.index && t3.index <= r2))
        continue;
      let n3;
      c2 < this.vu.length ? (n3 = this.vu[c2], n3.coord = this.Et(t3.index), n3.label = this.Nu(t3), n3.weight = t3.weight) : (n3 = { needAlignCoordinate: false, coord: this.Et(t3.index), label: this.Nu(t3), weight: t3.weight }, this.vu.push(n3)), this.mu > i / 2 && !o2 ? n3.needAlignCoordinate = false : n3.needAlignCoordinate = _24 && t3.index <= l2 || u2 && t3.index >= a2, c2++;
    }
    return this.vu.length = c2, this.fu = this.vu, this.vu;
  }
  Fu() {
    this.ou = true, this.Gn(this.cn.barSpacing), this.Jn(this.cn.rightOffset);
  }
  Wu(t2) {
    this.ou = true, this.eu = t2, this.Ou(), this.Mu();
  }
  ju(t2, i) {
    const n2 = this.Bu(t2), s = this.he(), e3 = s + i * (s / 10);
    this.Gn(e3), this.cn.rightBarStaysOnScroll || this.Jn(this.Eu() + (n2 - this.Bu(t2)));
  }
  Uo(t2) {
    this.fo && this.Zo(), null === this.do && null === this.du && (this.Fi() || (this.do = t2, this.Hu()));
  }
  qo(t2) {
    if (null === this.du)
      return;
    const i = yt$1(this.e_ - t2, 0, this.e_), n2 = yt$1(this.e_ - b(this.do), 0, this.e_);
    0 !== i && 0 !== n2 && this.Gn(this.du.he * i / n2);
  }
  Yo() {
    null !== this.do && (this.do = null, this.$u());
  }
  Xo(t2) {
    null === this.fo && null === this.du && (this.Fi() || (this.fo = t2, this.Hu()));
  }
  Ko(t2) {
    if (null === this.fo)
      return;
    const i = (this.fo - t2) / this.he();
    this.pu = b(this.du).Eu + i, this.ou = true, this.Ou();
  }
  Zo() {
    null !== this.fo && (this.fo = null, this.$u());
  }
  Uu() {
    this.qu(this.cn.rightOffset);
  }
  qu(t2, i = 400) {
    if (!isFinite(t2))
      throw new RangeError("offset is required and must be finite number");
    if (!isFinite(i) || i <= 0)
      throw new RangeError("animationDuration (optional) must be finite positive number");
    const n2 = this.pu, s = performance.now();
    this.Ui.Xn({ Yu: (t3) => (t3 - s) / i >= 1, Xu: (e3) => {
      const r2 = (e3 - s) / i;
      return r2 >= 1 ? t2 : n2 + (t2 - n2) * r2;
    } });
  }
  gt(t2, i) {
    this.ou = true, this.ru = t2, this.hu.K_(t2, i), this.Ou();
  }
  Ku() {
    return this._u;
  }
  Zu() {
    return this.uu;
  }
  Gu() {
    return this.cu;
  }
  Au() {
    return this.eu || 0;
  }
  Ju(t2) {
    const i = t2.U_();
    this.zu(this.e_ / i), this.pu = t2.di() - this.Au(), this.Ou(), this.ou = true, this.Ui.Iu(), this.Ui.Fh();
  }
  Qu() {
    const t2 = this.Tu(), i = this.Pu();
    null !== t2 && null !== i && this.Ju(new xn$1(t2, i + this.cn.rightOffset));
  }
  tc(t2) {
    const i = new xn$1(t2.from, t2.to);
    this.Ju(i);
  }
  Yi(t2) {
    return void 0 !== this.bo.timeFormatter ? this.bo.timeFormatter(t2.originalTime) : this.N_.formatHorzItem(t2.time);
  }
  Lu() {
    const { handleScroll: t2, handleScale: i } = this.Ui.W();
    return !(t2.horzTouchDrag || t2.mouseWheel || t2.pressedMouseMove || t2.vertTouchDrag || i.axisDoubleClickReset.time || i.axisPressedMouseMove.time || i.mouseWheel || i.pinch);
  }
  Tu() {
    return 0 === this.ru.length ? null : 0;
  }
  Pu() {
    return 0 === this.ru.length ? null : this.ru.length - 1;
  }
  ic(t2) {
    return (this.e_ - 1 - t2) / this.mu;
  }
  Bu(t2) {
    const i = this.ic(t2), n2 = this.Au() + this.pu - i;
    return Math.round(1e6 * n2) / 1e6;
  }
  zu(t2) {
    const i = this.mu;
    this.mu = t2, this.Du(), i !== this.mu && (this.ou = true, this.nc());
  }
  Su() {
    if (!this.ou)
      return;
    if (this.ou = false, this.Fi())
      return void this.sc(yn$1.su());
    const t2 = this.Au(), i = this.e_ / this.mu, n2 = this.pu + t2, s = new xn$1(n2 - i + 1, n2);
    this.sc(new yn$1(s));
  }
  Du() {
    const t2 = this.ec();
    if (this.mu < t2 && (this.mu = t2, this.ou = true), 0 !== this.e_) {
      const t3 = 0.5 * this.e_;
      this.mu > t3 && (this.mu = t3, this.ou = true);
    }
  }
  ec() {
    return this.cn.fixLeftEdge && this.cn.fixRightEdge && 0 !== this.ru.length ? this.e_ / this.ru.length : this.cn.minBarSpacing;
  }
  Ou() {
    const t2 = this.rc();
    this.pu > t2 && (this.pu = t2, this.ou = true);
    const i = this.hc();
    null !== i && this.pu < i && (this.pu = i, this.ou = true);
  }
  hc() {
    const t2 = this.Tu(), i = this.eu;
    if (null === t2 || null === i)
      return null;
    return t2 - i - 1 + (this.cn.fixLeftEdge ? this.e_ / this.mu : Math.min(2, this.ru.length));
  }
  rc() {
    return this.cn.fixRightEdge ? 0 : this.e_ / this.mu - Math.min(2, this.ru.length);
  }
  Hu() {
    this.du = { he: this.he(), Eu: this.Eu() };
  }
  $u() {
    this.du = null;
  }
  Nu(t2) {
    let i = this.lu.get(t2.weight);
    return void 0 === i && (i = new Mn$1((t3) => this.lc(t3), this.N_), this.lu.set(t2.weight, i)), i.F_(t2);
  }
  lc(t2) {
    return this.N_.formatTickmark(t2, this.bo);
  }
  sc(t2) {
    const i = this.au;
    this.au = t2, Sn(i.iu(), this.au.iu()) || this._u.m(), Sn(i.nu(), this.au.nu()) || this.uu.m(), this.nc();
  }
  nc() {
    this.fu = null;
  }
  gu() {
    this.nc(), this.lu.clear();
  }
  bu() {
    this.N_.updateFormatter(this.bo);
  }
  Mu() {
    if (!this.cn.fixLeftEdge)
      return;
    const t2 = this.Tu();
    if (null === t2)
      return;
    const i = this.Xs();
    if (null === i)
      return;
    const n2 = i.Os() - t2;
    if (n2 < 0) {
      const t3 = this.pu - n2 - 1;
      this.Jn(t3);
    }
    this.Du();
  }
  xu() {
    this.Ou(), this.Du();
  }
}
class Pn extends j {
  constructor(t2) {
    super(), this.ac = /* @__PURE__ */ new Map(), this.Lt = t2;
  }
  Z(t2) {
  }
  J(t2) {
    if (!this.Lt.Tt)
      return;
    const { context: i, mediaSize: n2 } = t2;
    let s = 0;
    for (const t3 of this.Lt.oc) {
      if (0 === t3.Jt.length)
        continue;
      i.font = t3.R;
      const e4 = this._c(i, t3.Jt);
      e4 > n2.width ? t3.ju = n2.width / e4 : t3.ju = 1, s += t3.uc * t3.ju;
    }
    let e3 = 0;
    switch (this.Lt.cc) {
      case "top":
        e3 = 0;
        break;
      case "center":
        e3 = Math.max((n2.height - s) / 2, 0);
        break;
      case "bottom":
        e3 = Math.max(n2.height - s, 0);
    }
    i.fillStyle = this.Lt.O;
    for (const t3 of this.Lt.oc) {
      i.save();
      let s2 = 0;
      switch (this.Lt.dc) {
        case "left":
          i.textAlign = "left", s2 = t3.uc / 2;
          break;
        case "center":
          i.textAlign = "center", s2 = n2.width / 2;
          break;
        case "right":
          i.textAlign = "right", s2 = n2.width - 1 - t3.uc / 2;
      }
      i.translate(s2, e3), i.textBaseline = "top", i.font = t3.R, i.scale(t3.ju, t3.ju), i.fillText(t3.Jt, 0, t3.fc), i.restore(), e3 += t3.uc * t3.ju;
    }
  }
  _c(t2, i) {
    const n2 = this.vc(t2.font);
    let s = n2.get(i);
    return void 0 === s && (s = t2.measureText(i).width, n2.set(i, s)), s;
  }
  vc(t2) {
    let i = this.ac.get(t2);
    return void 0 === i && (i = /* @__PURE__ */ new Map(), this.ac.set(t2, i)), i;
  }
}
class Rn {
  constructor(t2) {
    this.bt = true, this.jt = { Tt: false, O: "", oc: [], cc: "center", dc: "center" }, this.Ht = new Pn(this.jt), this.$t = t2;
  }
  gt() {
    this.bt = true;
  }
  xt() {
    return this.bt && (this.St(), this.bt = false), this.Ht;
  }
  St() {
    const t2 = this.$t.W(), i = this.jt;
    i.Tt = t2.visible, i.Tt && (i.O = t2.color, i.dc = t2.horzAlign, i.cc = t2.vertAlign, i.oc = [{ Jt: t2.text, R: N$1(t2.fontSize, t2.fontFamily, t2.fontStyle), uc: 1.2 * t2.fontSize, fc: 0, ju: 0 }]);
  }
}
let Dn$1 = class Dn extends at$1 {
  constructor(t2, i) {
    super(), this.cn = i, this.wn = new Rn(this);
  }
  Rn() {
    return [];
  }
  Pn() {
    return [this.wn];
  }
  W() {
    return this.cn;
  }
  On() {
    this.wn.gt();
  }
};
var On, An, Vn$1, Bn$1, In;
!function(t2) {
  t2[t2.OnTouchEnd = 0] = "OnTouchEnd", t2[t2.OnNextTap = 1] = "OnNextTap";
}(On || (On = {}));
class zn {
  constructor(t2, i, n2) {
    this.mc = [], this.bc = [], this.e_ = 0, this.wc = null, this.gc = new R(), this.Mc = new R(), this.xc = null, this.Sc = t2, this.cn = i, this.N_ = n2, this.kc = new F$1(this), this.wl = new Tn(this, i.timeScale, this.cn.localization, n2), this.wt = new _t$1(this, i.crosshair), this.yc = new Ji(i.crosshair), this.Cc = new Dn$1(this, i.watermark), this.Tc(), this.mc[0].p_(2e3), this.Pc = this.Rc(0), this.Dc = this.Rc(1);
  }
  $l() {
    this.Oc(ct.es());
  }
  Fh() {
    this.Oc(ct.ss());
  }
  sa() {
    this.Oc(new ct(1));
  }
  Ul(t2) {
    const i = this.Ac(t2);
    this.Oc(i);
  }
  Vc() {
    return this.wc;
  }
  Bc(t2) {
    const i = this.wc;
    this.wc = t2, null !== i && this.Ul(i.Ic), null !== t2 && this.Ul(t2.Ic);
  }
  W() {
    return this.cn;
  }
  Nh(t2) {
    D$1(this.cn, t2), this.mc.forEach((i) => i.c_(t2)), void 0 !== t2.timeScale && this.wl.Nh(t2.timeScale), void 0 !== t2.localization && this.wl.wu(t2.localization), (t2.leftPriceScale || t2.rightPriceScale) && this.gc.m(), this.Pc = this.Rc(0), this.Dc = this.Rc(1), this.$l();
  }
  zc(t2, i) {
    if ("left" === t2)
      return void this.Nh({ leftPriceScale: i });
    if ("right" === t2)
      return void this.Nh({ rightPriceScale: i });
    const n2 = this.Ec(t2);
    null !== n2 && (n2.At.Nh(i), this.gc.m());
  }
  Ec(t2) {
    for (const i of this.mc) {
      const n2 = i.d_(t2);
      if (null !== n2)
        return { Ut: i, At: n2 };
    }
    return null;
  }
  yt() {
    return this.wl;
  }
  Lc() {
    return this.mc;
  }
  Nc() {
    return this.Cc;
  }
  Fc() {
    return this.wt;
  }
  Wc() {
    return this.Mc;
  }
  jc(t2, i) {
    t2.Oo(i), this.Iu();
  }
  m_(t2) {
    this.e_ = t2, this.wl.m_(this.e_), this.mc.forEach((i) => i.m_(t2)), this.Iu();
  }
  Tc(t2) {
    const i = new gn$1(this.wl, this);
    void 0 !== t2 ? this.mc.splice(t2, 0, i) : this.mc.push(i);
    const n2 = void 0 === t2 ? this.mc.length - 1 : t2, s = ct.es();
    return s.Nn(n2, { Fn: 0, Wn: true }), this.Oc(s), i;
  }
  y_(t2, i, n2) {
    t2.y_(i, n2);
  }
  C_(t2, i, n2) {
    t2.C_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2));
  }
  T_(t2, i) {
    t2.T_(i), this.Oc(this.Hc(t2, 2));
  }
  P_(t2, i, n2) {
    i.yo() || t2.P_(i, n2);
  }
  R_(t2, i, n2) {
    i.yo() || (t2.R_(i, n2), this.ql(), this.Oc(this.Hc(t2, 2)));
  }
  D_(t2, i) {
    i.yo() || (t2.D_(i), this.Oc(this.Hc(t2, 2)));
  }
  A_(t2, i) {
    t2.A_(i), this.Oc(this.Hc(t2, 2));
  }
  $c(t2) {
    this.wl.Uo(t2);
  }
  Uc(t2, i) {
    const n2 = this.yt();
    if (n2.Fi() || 0 === i)
      return;
    const s = n2.$i();
    t2 = Math.max(1, Math.min(t2, s)), n2.ju(t2, i), this.Iu();
  }
  qc(t2) {
    this.Yc(0), this.Xc(t2), this.Kc();
  }
  Zc(t2) {
    this.wl.qo(t2), this.Iu();
  }
  Gc() {
    this.wl.Yo(), this.Fh();
  }
  Yc(t2) {
    this.wl.Xo(t2);
  }
  Xc(t2) {
    this.wl.Ko(t2), this.Iu();
  }
  Kc() {
    this.wl.Zo(), this.Fh();
  }
  Mt() {
    return this.bc;
  }
  Jc(t2, i, n2, s, e3) {
    this.wt.gn(t2, i);
    let r2 = NaN, h2 = this.wl.Vu(t2);
    const l2 = this.wl.Xs();
    null !== l2 && (h2 = Math.min(Math.max(l2.Os(), h2), l2.di()));
    const a2 = s.vn(), o2 = a2.Pt();
    null !== o2 && (r2 = a2.pn(i, o2)), r2 = this.yc.Ca(r2, h2, s), this.wt.kn(h2, r2, s), this.sa(), e3 || this.Mc.m(this.wt.kt(), { x: t2, y: i }, n2);
  }
  Qc(t2, i, n2) {
    const s = n2.vn(), e3 = s.Pt(), r2 = s.Ot(t2, b(e3)), h2 = this.wl.ya(i, true), l2 = this.wl.Et(b(h2));
    this.Jc(l2, r2, null, n2, true);
  }
  td(t2) {
    this.Fc().Cn(), this.sa(), t2 || this.Mc.m(null, null, null);
  }
  ql() {
    const t2 = this.wt.Ut();
    if (null !== t2) {
      const i = this.wt.xn(), n2 = this.wt.Sn();
      this.Jc(i, n2, null, t2);
    }
    this.wt.On();
  }
  nd(t2, i, n2) {
    const s = this.wl.mn(0);
    void 0 !== i && void 0 !== n2 && this.wl.gt(i, n2);
    const e3 = this.wl.mn(0), r2 = this.wl.Au(), h2 = this.wl.Xs();
    if (null !== h2 && null !== s && null !== e3) {
      const i2 = h2.Kr(r2), l2 = this.N_.key(s) > this.N_.key(e3), a2 = null !== t2 && t2 > r2 && !l2, o2 = this.wl.W().allowShiftVisibleRangeOnWhitespaceReplacement, _24 = i2 && (!(void 0 === n2) || o2) && this.wl.W().shiftVisibleRangeOnNewBar;
      if (a2 && !_24) {
        const i3 = t2 - r2;
        this.wl.Jn(this.wl.Eu() - i3);
      }
    }
    this.wl.Wu(t2);
  }
  Kl(t2) {
    null !== t2 && t2.B_();
  }
  cr(t2) {
    const i = this.mc.find((i2) => i2.No().includes(t2));
    return void 0 === i ? null : i;
  }
  Iu() {
    this.Cc.On(), this.mc.forEach((t2) => t2.B_()), this.ql();
  }
  S() {
    this.mc.forEach((t2) => t2.S()), this.mc.length = 0, this.cn.localization.priceFormatter = void 0, this.cn.localization.percentageFormatter = void 0, this.cn.localization.timeFormatter = void 0;
  }
  sd() {
    return this.kc;
  }
  mr() {
    return this.kc.W();
  }
  f_() {
    return this.gc;
  }
  ed(t2, i, n2) {
    const s = this.mc[0], e3 = this.rd(i, t2, s, n2);
    return this.bc.push(e3), 1 === this.bc.length ? this.$l() : this.Fh(), e3;
  }
  hd(t2) {
    const i = this.cr(t2), n2 = this.bc.indexOf(t2);
    p$1(-1 !== n2, "Series not found"), this.bc.splice(n2, 1), b(i).jo(t2), t2.S && t2.S();
  }
  Hl(t2, i) {
    const n2 = b(this.cr(t2));
    n2.jo(t2);
    const s = this.Ec(i);
    if (null === s) {
      const s2 = t2.Zi();
      n2.Fo(t2, i, s2);
    } else {
      const e3 = s.Ut === n2 ? t2.Zi() : void 0;
      s.Ut.Fo(t2, i, e3);
    }
  }
  Qu() {
    const t2 = ct.ss();
    t2.$n(), this.Oc(t2);
  }
  ld(t2) {
    const i = ct.ss();
    i.Yn(t2), this.Oc(i);
  }
  Zn() {
    const t2 = ct.ss();
    t2.Zn(), this.Oc(t2);
  }
  Gn(t2) {
    const i = ct.ss();
    i.Gn(t2), this.Oc(i);
  }
  Jn(t2) {
    const i = ct.ss();
    i.Jn(t2), this.Oc(i);
  }
  Xn(t2) {
    const i = ct.ss();
    i.Xn(t2), this.Oc(i);
  }
  Un() {
    const t2 = ct.ss();
    t2.Un(), this.Oc(t2);
  }
  ad() {
    return this.cn.rightPriceScale.visible ? "right" : "left";
  }
  od() {
    return this.Dc;
  }
  q() {
    return this.Pc;
  }
  It(t2) {
    const i = this.Dc, n2 = this.Pc;
    if (i === n2)
      return i;
    if (t2 = Math.max(0, Math.min(100, Math.round(100 * t2))), null === this.xc || this.xc.Ts !== n2 || this.xc.Ps !== i)
      this.xc = { Ts: n2, Ps: i, _d: /* @__PURE__ */ new Map() };
    else {
      const i2 = this.xc._d.get(t2);
      if (void 0 !== i2)
        return i2;
    }
    const s = function(t3, i2, n3) {
      const [s2, e3, r2, h2] = T$1(t3), [l2, a2, o2, _24] = T$1(i2), u2 = [M(s2 + n3 * (l2 - s2)), M(e3 + n3 * (a2 - e3)), M(r2 + n3 * (o2 - r2)), x(h2 + n3 * (_24 - h2))];
      return `rgba(${u2[0]}, ${u2[1]}, ${u2[2]}, ${u2[3]})`;
    }(n2, i, t2 / 100);
    return this.xc._d.set(t2, s), s;
  }
  Hc(t2, i) {
    const n2 = new ct(i);
    if (null !== t2) {
      const s = this.mc.indexOf(t2);
      n2.Nn(s, { Fn: i });
    }
    return n2;
  }
  Ac(t2, i) {
    return void 0 === i && (i = 2), this.Hc(this.cr(t2), i);
  }
  Oc(t2) {
    this.Sc && this.Sc(t2), this.mc.forEach((t3) => t3.z_().Wh().gt());
  }
  rd(t2, i, n2, s) {
    const e3 = new Gi(this, t2, i, n2, s), r2 = void 0 !== t2.priceScaleId ? t2.priceScaleId : this.ad();
    return n2.Fo(e3, r2), ut$1(r2) || e3.Nh(t2), e3;
  }
  Rc(t2) {
    const i = this.cn.layout;
    return "gradient" === i.background.type ? 0 === t2 ? i.background.topColor : i.background.bottomColor : i.background.color;
  }
}
function En(t2) {
  return !O$1(t2) && !V$1(t2);
}
function Ln$1(t2) {
  return O$1(t2);
}
!function(t2) {
  t2[t2.Disabled = 0] = "Disabled", t2[t2.Continuous = 1] = "Continuous", t2[t2.OnDataUpdate = 2] = "OnDataUpdate";
}(An || (An = {})), function(t2) {
  t2[t2.LastBar = 0] = "LastBar", t2[t2.LastVisible = 1] = "LastVisible";
}(Vn$1 || (Vn$1 = {})), function(t2) {
  t2.Solid = "solid", t2.VerticalGradient = "gradient";
}(Bn$1 || (Bn$1 = {})), function(t2) {
  t2[t2.Year = 0] = "Year", t2[t2.Month = 1] = "Month", t2[t2.DayOfMonth = 2] = "DayOfMonth", t2[t2.Time = 3] = "Time", t2[t2.TimeWithSeconds = 4] = "TimeWithSeconds";
}(In || (In = {}));
const Nn = (t2) => t2.getUTCFullYear();
function Fn$1(t2, i, n2) {
  return i.replace(/yyyy/g, ((t3) => ft$1(Nn(t3), 4))(t2)).replace(/yy/g, ((t3) => ft$1(Nn(t3) % 100, 2))(t2)).replace(/MMMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "long" }))(t2, n2)).replace(/MMM/g, ((t3, i2) => new Date(t3.getUTCFullYear(), t3.getUTCMonth(), 1).toLocaleString(i2, { month: "short" }))(t2, n2)).replace(/MM/g, ((t3) => ft$1(((t4) => t4.getUTCMonth() + 1)(t3), 2))(t2)).replace(/dd/g, ((t3) => ft$1(((t4) => t4.getUTCDate())(t3), 2))(t2));
}
let Wn$1 = class Wn {
  constructor(t2 = "yyyy-MM-dd", i = "default") {
    this.ud = t2, this.dd = i;
  }
  F_(t2) {
    return Fn$1(t2, this.ud, this.dd);
  }
};
class jn {
  constructor(t2) {
    this.fd = t2 || "%h:%m:%s";
  }
  F_(t2) {
    return this.fd.replace("%h", ft$1(t2.getUTCHours(), 2)).replace("%m", ft$1(t2.getUTCMinutes(), 2)).replace("%s", ft$1(t2.getUTCSeconds(), 2));
  }
}
const Hn$1 = { vd: "yyyy-MM-dd", pd: "%h:%m:%s", md: " ", bd: "default" };
class $n {
  constructor(t2 = {}) {
    const i = Object.assign(Object.assign({}, Hn$1), t2);
    this.wd = new Wn$1(i.vd, i.bd), this.gd = new jn(i.pd), this.Md = i.md;
  }
  F_(t2) {
    return `${this.wd.F_(t2)}${this.Md}${this.gd.F_(t2)}`;
  }
}
function Un(t2) {
  return 60 * t2 * 60 * 1e3;
}
function qn$1(t2) {
  return 60 * t2 * 1e3;
}
const Yn = [{ xd: (Xn$1 = 1, 1e3 * Xn$1), Sd: 10 }, { xd: qn$1(1), Sd: 20 }, { xd: qn$1(5), Sd: 21 }, { xd: qn$1(30), Sd: 22 }, { xd: Un(1), Sd: 30 }, { xd: Un(3), Sd: 31 }, { xd: Un(6), Sd: 32 }, { xd: Un(12), Sd: 33 }];
var Xn$1;
function Kn$1(t2, i) {
  if (t2.getUTCFullYear() !== i.getUTCFullYear())
    return 70;
  if (t2.getUTCMonth() !== i.getUTCMonth())
    return 60;
  if (t2.getUTCDate() !== i.getUTCDate())
    return 50;
  for (let n2 = Yn.length - 1; n2 >= 0; --n2)
    if (Math.floor(i.getTime() / Yn[n2].xd) !== Math.floor(t2.getTime() / Yn[n2].xd))
      return Yn[n2].Sd;
  return 0;
}
function Zn(t2) {
  let i = t2;
  if (V$1(t2) && (i = Jn$1(t2)), !En(i))
    throw new Error("time must be of type BusinessDay");
  const n2 = new Date(Date.UTC(i.year, i.month - 1, i.day, 0, 0, 0, 0));
  return { kd: Math.round(n2.getTime() / 1e3), yd: i };
}
function Gn$1(t2) {
  if (!Ln$1(t2))
    throw new Error("time must be of type isUTCTimestamp");
  return { kd: t2 };
}
function Jn$1(t2) {
  const i = new Date(t2);
  if (isNaN(i.getTime()))
    throw new Error(`Invalid date string=${t2}, expected format=yyyy-mm-dd`);
  return { day: i.getUTCDate(), month: i.getUTCMonth() + 1, year: i.getUTCFullYear() };
}
function Qn$1(t2) {
  V$1(t2.time) && (t2.time = Jn$1(t2.time));
}
class ts {
  options() {
    return this.cn;
  }
  setOptions(t2) {
    this.cn = t2, this.updateFormatter(t2.localization);
  }
  preprocessData(t2) {
    Array.isArray(t2) ? function(t3) {
      t3.forEach(Qn$1);
    }(t2) : Qn$1(t2);
  }
  createConverterToInternalObj(t2) {
    return b(function(t3) {
      return 0 === t3.length ? null : En(t3[0].time) || V$1(t3[0].time) ? Zn : Gn$1;
    }(t2));
  }
  key(t2) {
    return "object" == typeof t2 && "kd" in t2 ? t2.kd : this.key(this.convertHorzItemToInternal(t2));
  }
  cacheKey(t2) {
    const i = t2;
    return void 0 === i.yd ? new Date(1e3 * i.kd).getTime() : new Date(Date.UTC(i.yd.year, i.yd.month - 1, i.yd.day)).getTime();
  }
  convertHorzItemToInternal(t2) {
    return Ln$1(i = t2) ? Gn$1(i) : En(i) ? Zn(i) : Zn(Jn$1(i));
    var i;
  }
  updateFormatter(t2) {
    if (!this.cn)
      return;
    const i = t2.dateFormat;
    this.cn.timeScale.timeVisible ? this.Cd = new $n({ vd: i, pd: this.cn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m", md: "   ", bd: t2.locale }) : this.Cd = new Wn$1(i, t2.locale);
  }
  formatHorzItem(t2) {
    const i = t2;
    return this.Cd.F_(new Date(1e3 * i.kd));
  }
  formatTickmark(t2, i) {
    const n2 = function(t3, i2, n3) {
      switch (t3) {
        case 0:
        case 10:
          return i2 ? n3 ? 4 : 3 : 2;
        case 20:
        case 21:
        case 22:
        case 30:
        case 31:
        case 32:
        case 33:
          return i2 ? 3 : 2;
        case 50:
          return 2;
        case 60:
          return 1;
        case 70:
          return 0;
      }
    }(t2.weight, this.cn.timeScale.timeVisible, this.cn.timeScale.secondsVisible), s = this.cn.timeScale;
    if (void 0 !== s.tickMarkFormatter) {
      const e3 = s.tickMarkFormatter(t2.originalTime, n2, i.locale);
      if (null !== e3)
        return e3;
    }
    return function(t3, i2, n3) {
      const s2 = {};
      switch (i2) {
        case 0:
          s2.year = "numeric";
          break;
        case 1:
          s2.month = "short";
          break;
        case 2:
          s2.day = "numeric";
          break;
        case 3:
          s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit";
          break;
        case 4:
          s2.hour12 = false, s2.hour = "2-digit", s2.minute = "2-digit", s2.second = "2-digit";
      }
      const e3 = void 0 === t3.yd ? new Date(1e3 * t3.kd) : new Date(Date.UTC(t3.yd.year, t3.yd.month - 1, t3.yd.day));
      return new Date(e3.getUTCFullYear(), e3.getUTCMonth(), e3.getUTCDate(), e3.getUTCHours(), e3.getUTCMinutes(), e3.getUTCSeconds(), e3.getUTCMilliseconds()).toLocaleString(n3, s2);
    }(t2.time, n2, i.locale);
  }
  maxTickMarkWeight(t2) {
    let i = t2.reduce(Cn, t2[0]).weight;
    return i > 30 && i < 50 && (i = 30), i;
  }
  fillWeightsForPoints(t2, i) {
    !function(t3, i2 = 0) {
      if (0 === t3.length)
        return;
      let n2 = 0 === i2 ? null : t3[i2 - 1].time.kd, s = null !== n2 ? new Date(1e3 * n2) : null, e3 = 0;
      for (let r2 = i2; r2 < t3.length; ++r2) {
        const i3 = t3[r2], h2 = new Date(1e3 * i3.time.kd);
        null !== s && (i3.timeWeight = Kn$1(h2, s)), e3 += i3.time.kd - (n2 || i3.time.kd), n2 = i3.time.kd, s = h2;
      }
      if (0 === i2 && t3.length > 1) {
        const i3 = Math.ceil(e3 / (t3.length - 1)), n3 = new Date(1e3 * (t3[0].time.kd - i3));
        t3[0].timeWeight = Kn$1(new Date(1e3 * t3[0].time.kd), n3);
      }
    }(t2, i);
  }
  static Td(t2) {
    return D$1({ localization: { dateFormat: "dd MMM 'yy" } }, null != t2 ? t2 : {});
  }
}
const is = "undefined" != typeof window;
function ns() {
  return !!is && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1;
}
function ss() {
  return !!is && /iPhone|iPad|iPod/.test(window.navigator.platform);
}
function es(t2) {
  return t2 + t2 % 2;
}
function rs(t2, i) {
  return t2.Pd - i.Pd;
}
function hs(t2, i, n2) {
  const s = (t2.Pd - i.Pd) / (t2.ut - i.ut);
  return Math.sign(s) * Math.min(Math.abs(s), n2);
}
class ls {
  constructor(t2, i, n2, s) {
    this.Rd = null, this.Dd = null, this.Od = null, this.Ad = null, this.Vd = null, this.Bd = 0, this.Id = 0, this.zd = t2, this.Ed = i, this.Ld = n2, this.rs = s;
  }
  Nd(t2, i) {
    if (null !== this.Rd) {
      if (this.Rd.ut === i)
        return void (this.Rd.Pd = t2);
      if (Math.abs(this.Rd.Pd - t2) < this.rs)
        return;
    }
    this.Ad = this.Od, this.Od = this.Dd, this.Dd = this.Rd, this.Rd = { ut: i, Pd: t2 };
  }
  Dr(t2, i) {
    if (null === this.Rd || null === this.Dd)
      return;
    if (i - this.Rd.ut > 50)
      return;
    let n2 = 0;
    const s = hs(this.Rd, this.Dd, this.Ed), e3 = rs(this.Rd, this.Dd), r2 = [s], h2 = [e3];
    if (n2 += e3, null !== this.Od) {
      const t3 = hs(this.Dd, this.Od, this.Ed);
      if (Math.sign(t3) === Math.sign(s)) {
        const i2 = rs(this.Dd, this.Od);
        if (r2.push(t3), h2.push(i2), n2 += i2, null !== this.Ad) {
          const t4 = hs(this.Od, this.Ad, this.Ed);
          if (Math.sign(t4) === Math.sign(s)) {
            const i3 = rs(this.Od, this.Ad);
            r2.push(t4), h2.push(i3), n2 += i3;
          }
        }
      }
    }
    let l2 = 0;
    for (let t3 = 0; t3 < r2.length; ++t3)
      l2 += h2[t3] / n2 * r2[t3];
    Math.abs(l2) < this.zd || (this.Vd = { Pd: t2, ut: i }, this.Id = l2, this.Bd = function(t3, i2) {
      const n3 = Math.log(i2);
      return Math.log(1 * n3 / -t3) / n3;
    }(Math.abs(l2), this.Ld));
  }
  Xu(t2) {
    const i = b(this.Vd), n2 = t2 - i.ut;
    return i.Pd + this.Id * (Math.pow(this.Ld, n2) - 1) / Math.log(this.Ld);
  }
  Yu(t2) {
    return null === this.Vd || this.Fd(t2) === this.Bd;
  }
  Fd(t2) {
    const i = t2 - b(this.Vd).ut;
    return Math.min(i, this.Bd);
  }
}
function as(t2, n2) {
  const s = b(t2.ownerDocument).createElement("canvas");
  t2.appendChild(s);
  const e3 = bindTo(s, { type: "device-pixel-content-box", options: { allowResizeObserver: false }, transform: (t3, i) => ({ width: Math.max(t3.width, i.width), height: Math.max(t3.height, i.height) }) });
  return e3.resizeCanvasElement(n2), e3;
}
function os(t2, i, n2, s) {
  t2.G && t2.G(i, n2, s);
}
function _s(t2, i, n2, s) {
  t2.K(i, n2, s);
}
function us(t2, i, n2, s) {
  const e3 = t2(n2, s);
  for (const t3 of e3) {
    const n3 = t3.xt();
    null !== n3 && i(n3);
  }
}
function cs(t2) {
  is && void 0 !== window.chrome && t2.addEventListener("mousedown", (t3) => {
    if (1 === t3.button)
      return t3.preventDefault(), false;
  });
}
class ds {
  constructor(t2, i, n2) {
    this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY }, this.Yd = null, this.Xd = false, this.Kd = null, this.Zd = null, this.Gd = false, this.Jd = false, this.Qd = false, this.tf = null, this.if = null, this.nf = null, this.sf = null, this.ef = null, this.rf = null, this.hf = null, this.lf = 0, this.af = false, this._f = false, this.uf = false, this.cf = 0, this.df = null, this.ff = !ss(), this.vf = (t3) => {
      this.pf(t3);
    }, this.mf = (t3) => {
      if (this.bf(t3)) {
        const i2 = this.wf(t3);
        if (++this.$d, this.Ud && this.$d > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.qd);
          n3 < 30 && !this.Qd && this.xf(i2, this.kf.Sf), this.yf();
        }
      } else {
        const i2 = this.wf(t3);
        if (++this.Wd, this.jd && this.Wd > 1) {
          const { gf: n3 } = this.Mf(ps(t3), this.Hd);
          n3 < 5 && !this.Jd && this.Cf(i2, this.kf.Tf), this.Pf();
        }
      }
    }, this.Rf = t2, this.kf = i, this.cn = n2, this.Df();
  }
  S() {
    null !== this.tf && (this.tf(), this.tf = null), null !== this.if && (this.if(), this.if = null), null !== this.sf && (this.sf(), this.sf = null), null !== this.ef && (this.ef(), this.ef = null), null !== this.rf && (this.rf(), this.rf = null), null !== this.nf && (this.nf(), this.nf = null), this.Of(), this.Pf();
  }
  Af(t2) {
    this.sf && this.sf();
    const i = this.Vf.bind(this);
    if (this.sf = () => {
      this.Rf.removeEventListener("mousemove", i);
    }, this.Rf.addEventListener("mousemove", i), this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Bf), this.ff = true;
  }
  Pf() {
    null !== this.jd && clearTimeout(this.jd), this.Wd = 0, this.jd = null, this.Hd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  yf() {
    null !== this.Ud && clearTimeout(this.Ud), this.$d = 0, this.Ud = null, this.qd = { et: Number.NEGATIVE_INFINITY, rt: Number.POSITIVE_INFINITY };
  }
  Vf(t2) {
    if (this.uf || null !== this.Zd)
      return;
    if (this.bf(t2))
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.If), this.ff = true;
  }
  zf(t2) {
    const i = bs(t2.changedTouches, b(this.df));
    if (null === i)
      return;
    if (this.cf = ms(t2), null !== this.hf)
      return;
    if (this._f)
      return;
    this.af = true;
    const n2 = this.Mf(ps(i), b(this.Zd)), { Ef: s, Lf: e3, gf: r2 } = n2;
    if (this.Gd || !(r2 < 5)) {
      if (!this.Gd) {
        const t3 = 0.5 * s, i2 = e3 >= t3 && !this.cn.Nf(), n3 = t3 > e3 && !this.cn.Ff();
        i2 || n3 || (this._f = true), this.Gd = true, this.Qd = true, this.Of(), this.yf();
      }
      if (!this._f) {
        const n3 = this.wf(t2, i);
        this.xf(n3, this.kf.Wf), vs(t2);
      }
    }
  }
  jf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.Mf(ps(t2), b(this.Kd)), { gf: n2 } = i;
    if (n2 >= 5 && (this.Jd = true, this.Pf()), this.Jd) {
      const i2 = this.wf(t2);
      this.Cf(i2, this.kf.Hf);
    }
  }
  Mf(t2, i) {
    const n2 = Math.abs(i.et - t2.et), s = Math.abs(i.rt - t2.rt);
    return { Ef: n2, Lf: s, gf: n2 + s };
  }
  $f(t2) {
    let i = bs(t2.changedTouches, b(this.df));
    if (null === i && 0 === t2.touches.length && (i = t2.changedTouches[0]), null === i)
      return;
    this.df = null, this.cf = ms(t2), this.Of(), this.Zd = null, this.rf && (this.rf(), this.rf = null);
    const n2 = this.wf(t2, i);
    if (this.xf(n2, this.kf.Uf), ++this.$d, this.Ud && this.$d > 1) {
      const { gf: t3 } = this.Mf(ps(i), this.qd);
      t3 < 30 && !this.Qd && this.xf(n2, this.kf.Sf), this.yf();
    } else
      this.Qd || (this.xf(n2, this.kf.qf), this.kf.qf && vs(t2));
    0 === this.$d && vs(t2), 0 === t2.touches.length && this.Xd && (this.Xd = false, vs(t2));
  }
  pf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.wf(t2);
    if (this.Kd = null, this.uf = false, this.ef && (this.ef(), this.ef = null), ns()) {
      this.Rf.ownerDocument.documentElement.removeEventListener("mouseleave", this.vf);
    }
    if (!this.bf(t2))
      if (this.Cf(i, this.kf.Yf), ++this.Wd, this.jd && this.Wd > 1) {
        const { gf: n2 } = this.Mf(ps(t2), this.Hd);
        n2 < 5 && !this.Jd && this.Cf(i, this.kf.Tf), this.Pf();
      } else
        this.Jd || this.Cf(i, this.kf.Xf);
  }
  Of() {
    null !== this.Yd && (clearTimeout(this.Yd), this.Yd = null);
  }
  Kf(t2) {
    if (null !== this.df)
      return;
    const i = t2.changedTouches[0];
    this.df = i.identifier, this.cf = ms(t2);
    const n2 = this.Rf.ownerDocument.documentElement;
    this.Qd = false, this.Gd = false, this._f = false, this.Zd = ps(i), this.rf && (this.rf(), this.rf = null);
    {
      const i2 = this.zf.bind(this), s2 = this.$f.bind(this);
      this.rf = () => {
        n2.removeEventListener("touchmove", i2), n2.removeEventListener("touchend", s2);
      }, n2.addEventListener("touchmove", i2, { passive: false }), n2.addEventListener("touchend", s2, { passive: false }), this.Of(), this.Yd = setTimeout(this.Zf.bind(this, t2), 240);
    }
    const s = this.wf(t2, i);
    this.xf(s, this.kf.Gf), this.Ud || (this.$d = 0, this.Ud = setTimeout(this.yf.bind(this), 500), this.qd = ps(i));
  }
  Jf(t2) {
    if (0 !== t2.button)
      return;
    const i = this.Rf.ownerDocument.documentElement;
    ns() && i.addEventListener("mouseleave", this.vf), this.Jd = false, this.Kd = ps(t2), this.ef && (this.ef(), this.ef = null);
    {
      const t3 = this.jf.bind(this), n3 = this.pf.bind(this);
      this.ef = () => {
        i.removeEventListener("mousemove", t3), i.removeEventListener("mouseup", n3);
      }, i.addEventListener("mousemove", t3), i.addEventListener("mouseup", n3);
    }
    if (this.uf = true, this.bf(t2))
      return;
    const n2 = this.wf(t2);
    this.Cf(n2, this.kf.Qf), this.jd || (this.Wd = 0, this.jd = setTimeout(this.Pf.bind(this), 500), this.Hd = ps(t2));
  }
  Df() {
    this.Rf.addEventListener("mouseenter", this.Af.bind(this)), this.Rf.addEventListener("touchcancel", this.Of.bind(this));
    {
      const t2 = this.Rf.ownerDocument, i = (t3) => {
        this.kf.tv && (t3.composed && this.Rf.contains(t3.composedPath()[0]) || t3.target && this.Rf.contains(t3.target) || this.kf.tv());
      };
      this.if = () => {
        t2.removeEventListener("touchstart", i);
      }, this.tf = () => {
        t2.removeEventListener("mousedown", i);
      }, t2.addEventListener("mousedown", i), t2.addEventListener("touchstart", i, { passive: true });
    }
    ss() && (this.nf = () => {
      this.Rf.removeEventListener("dblclick", this.mf);
    }, this.Rf.addEventListener("dblclick", this.mf)), this.Rf.addEventListener("mouseleave", this.iv.bind(this)), this.Rf.addEventListener("touchstart", this.Kf.bind(this), { passive: true }), cs(this.Rf), this.Rf.addEventListener("mousedown", this.Jf.bind(this)), this.nv(), this.Rf.addEventListener("touchmove", () => {
    }, { passive: false });
  }
  nv() {
    void 0 === this.kf.sv && void 0 === this.kf.ev && void 0 === this.kf.rv || (this.Rf.addEventListener("touchstart", (t2) => this.hv(t2.touches), { passive: true }), this.Rf.addEventListener("touchmove", (t2) => {
      if (2 === t2.touches.length && null !== this.hf && void 0 !== this.kf.ev) {
        const i = fs(t2.touches[0], t2.touches[1]) / this.lf;
        this.kf.ev(this.hf, i), vs(t2);
      }
    }, { passive: false }), this.Rf.addEventListener("touchend", (t2) => {
      this.hv(t2.touches);
    }));
  }
  hv(t2) {
    1 === t2.length && (this.af = false), 2 !== t2.length || this.af || this.Xd ? this.lv() : this.av(t2);
  }
  av(t2) {
    const i = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    this.hf = { et: (t2[0].clientX - i.left + (t2[1].clientX - i.left)) / 2, rt: (t2[0].clientY - i.top + (t2[1].clientY - i.top)) / 2 }, this.lf = fs(t2[0], t2[1]), void 0 !== this.kf.sv && this.kf.sv(), this.Of();
  }
  lv() {
    null !== this.hf && (this.hf = null, void 0 !== this.kf.rv && this.kf.rv());
  }
  iv(t2) {
    if (this.sf && this.sf(), this.bf(t2))
      return;
    if (!this.ff)
      return;
    const i = this.wf(t2);
    this.Cf(i, this.kf.ov), this.ff = !ss();
  }
  Zf(t2) {
    const i = bs(t2.touches, b(this.df));
    if (null === i)
      return;
    const n2 = this.wf(t2, i);
    this.xf(n2, this.kf._v), this.Qd = true, this.Xd = true;
  }
  bf(t2) {
    return t2.sourceCapabilities && void 0 !== t2.sourceCapabilities.firesTouchEvents ? t2.sourceCapabilities.firesTouchEvents : ms(t2) < this.cf + 500;
  }
  xf(t2, i) {
    i && i.call(this.kf, t2);
  }
  Cf(t2, i) {
    i && i.call(this.kf, t2);
  }
  wf(t2, i) {
    const n2 = i || t2, s = this.Rf.getBoundingClientRect() || { left: 0, top: 0 };
    return { clientX: n2.clientX, clientY: n2.clientY, pageX: n2.pageX, pageY: n2.pageY, screenX: n2.screenX, screenY: n2.screenY, localX: n2.clientX - s.left, localY: n2.clientY - s.top, ctrlKey: t2.ctrlKey, altKey: t2.altKey, shiftKey: t2.shiftKey, metaKey: t2.metaKey, uv: !t2.type.startsWith("mouse") && "contextmenu" !== t2.type && "click" !== t2.type, cv: t2.type, dv: n2.target, fv: t2.view, vv: () => {
      "touchstart" !== t2.type && vs(t2);
    } };
  }
}
function fs(t2, i) {
  const n2 = t2.clientX - i.clientX, s = t2.clientY - i.clientY;
  return Math.sqrt(n2 * n2 + s * s);
}
function vs(t2) {
  t2.cancelable && t2.preventDefault();
}
function ps(t2) {
  return { et: t2.pageX, rt: t2.pageY };
}
function ms(t2) {
  return t2.timeStamp || performance.now();
}
function bs(t2, i) {
  for (let n2 = 0; n2 < t2.length; ++n2)
    if (t2[n2].identifier === i)
      return t2[n2];
  return null;
}
function ws(t2) {
  return { Ic: t2.Ic, pv: { wr: t2.mv.externalId }, bv: t2.mv.cursorStyle };
}
function gs(t2, i, n2) {
  for (const s of t2) {
    const t3 = s.xt();
    if (null !== t3 && t3.br) {
      const e3 = t3.br(i, n2);
      if (null !== e3)
        return { fv: s, pv: e3 };
    }
  }
  return null;
}
function Ms(t2, i) {
  return (n2) => {
    var s, e3, r2, h2;
    return (null !== (e3 = null === (s = n2.At()) || void 0 === s ? void 0 : s.xa()) && void 0 !== e3 ? e3 : "") !== i ? [] : null !== (h2 = null === (r2 = n2.la) || void 0 === r2 ? void 0 : r2.call(n2, t2)) && void 0 !== h2 ? h2 : [];
  };
}
class xs {
  constructor(i, n2, s, e3) {
    this.Li = null, this.wv = null, this.gv = false, this.Mv = new si(200), this.Gr = null, this.xv = 0, this.Sv = false, this.kv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.nn.yv().qt().Fh();
    }, this.nn = i, this.cn = n2, this.mo = n2.layout, this.kc = s, this.Tv = "left" === e3, this.Pv = Ms("normal", e3), this.Rv = Ms("top", e3), this.Dv = Ms("bottom", e3), this.Ov = document.createElement("div"), this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Ov.style.width = "25px", this.Ov.style.left = "0", this.Ov.style.position = "relative", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const r2 = this.Av.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "1", r2.style.left = "0", r2.style.top = "0", this.Vv = as(this.Ov, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const h2 = this.Vv.canvasElement;
    h2.style.position = "absolute", h2.style.zIndex = "2", h2.style.left = "0", h2.style.top = "0";
    const l2 = { Qf: this.Bv.bind(this), Gf: this.Bv.bind(this), Hf: this.Iv.bind(this), Wf: this.Iv.bind(this), tv: this.zv.bind(this), Yf: this.Ev.bind(this), Uf: this.Ev.bind(this), Tf: this.Lv.bind(this), Sf: this.Lv.bind(this), Bf: this.Nv.bind(this), ov: this.Fv.bind(this) };
    this.Wv = new ds(this.Vv.canvasElement, l2, { Nf: () => !this.cn.handleScroll.vertTouchDrag, Ff: () => true });
  }
  S() {
    this.Wv.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), null !== this.Li && this.Li.$o().p(this), this.Li = null;
  }
  jv() {
    return this.Ov;
  }
  P() {
    return this.mo.fontSize;
  }
  Hv() {
    const t2 = this.kc.W();
    return this.Gr !== t2.R && (this.Mv.ir(), this.Gr = t2.R), t2;
  }
  $v() {
    if (null === this.Li)
      return 0;
    let t2 = 0;
    const i = this.Hv(), n2 = b(this.Av.canvasElement.getContext("2d"));
    n2.save();
    const s = this.Li.Ea();
    n2.font = this.Uv(), s.length > 0 && (t2 = Math.max(this.Mv.Si(n2, s[0].Za), this.Mv.Si(n2, s[s.length - 1].Za)));
    const e3 = this.qv();
    for (let i2 = e3.length; i2--; ) {
      const s2 = this.Mv.Si(n2, e3[i2].Jt());
      s2 > t2 && (t2 = s2);
    }
    const r2 = this.Li.Pt();
    if (null !== r2 && null !== this.wv) {
      const i2 = this.Li.pn(1, r2), s2 = this.Li.pn(this.wv.height - 2, r2);
      t2 = Math.max(t2, this.Mv.Si(n2, this.Li.Wi(Math.floor(Math.min(i2, s2)) + 0.11111111111111, r2)), this.Mv.Si(n2, this.Li.Wi(Math.ceil(Math.max(i2, s2)) - 0.11111111111111, r2)));
    }
    n2.restore();
    const h2 = t2 || 34;
    return es(Math.ceil(i.C + i.T + i.B + i.I + 5 + h2));
  }
  Yv(t2) {
    null !== this.wv && equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = true, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = false, this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`);
  }
  Xv() {
    return b(this.wv).width;
  }
  Ji(t2) {
    this.Li !== t2 && (null !== this.Li && this.Li.$o().p(this), this.Li = t2, t2.$o().l(this.ao.bind(this), this));
  }
  At() {
    return this.Li;
  }
  ir() {
    const t2 = this.nn.Kv();
    this.nn.yv().qt().A_(t2, b(this.At()));
  }
  Zv(t2) {
    if (null === this.wv)
      return;
    if (1 !== t2) {
      this.Gv(), this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4), this.Be(t4);
      }), this.nn.Qv(t3, this.Dv), this.tp(t3), this.nn.Qv(t3, this.Pv), this.ip(t3));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.np(i), this.nn.Qv(i, this.Rv));
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  gt() {
    var t2;
    null === (t2 = this.Li) || void 0 === t2 || t2.Ea();
  }
  Bv(t2) {
    if (null === this.Li || this.Li.Fi() || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = true, i.y_(n2, this.Li, t2.localY);
  }
  Iv(t2) {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv(), s = this.Li;
    i.C_(n2, s, t2.localY);
  }
  zv() {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const t2 = this.nn.yv().qt(), i = this.nn.Kv(), n2 = this.Li;
    this.gv && (this.gv = false, t2.T_(i, n2));
  }
  Ev(t2) {
    if (null === this.Li || !this.cn.handleScale.axisPressedMouseMove.price)
      return;
    const i = this.nn.yv().qt(), n2 = this.nn.Kv();
    this.gv = false, i.T_(n2, this.Li);
  }
  Lv(t2) {
    this.cn.handleScale.axisDoubleClickReset.price && this.ir();
  }
  Nv(t2) {
    if (null === this.Li)
      return;
    !this.nn.yv().qt().W().handleScale.axisPressedMouseMove.price || this.Li.ph() || this.Li.Co() || this.rp(1);
  }
  Fv(t2) {
    this.rp(0);
  }
  qv() {
    const t2 = [], i = null === this.Li ? void 0 : this.Li;
    return ((n2) => {
      for (let s = 0; s < n2.length; ++s) {
        const e3 = n2[s].Rn(this.nn.Kv(), i);
        for (let i2 = 0; i2 < e3.length; i2++)
          t2.push(e3[i2]);
      }
    })(this.nn.Kv().No()), t2;
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e3 = this.nn.Kv().qt(), r2 = e3.q(), h2 = e3.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, r2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2 }) {
    if (null === this.wv || null === this.Li || !this.Li.W().borderVisible)
      return;
    t2.fillStyle = this.Li.W().borderColor;
    const s = Math.max(1, Math.floor(this.Hv().C * n2));
    let e3;
    e3 = this.Tv ? i.width - s : 0, t2.fillRect(e3, 0, s, i.height);
  }
  tp(t2) {
    if (null === this.wv || null === this.Li)
      return;
    const i = this.Li.Ea(), n2 = this.Li.W(), s = this.Hv(), e3 = this.Tv ? this.wv.width - s.T : 0;
    n2.borderVisible && n2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: r2, verticalPixelRatio: h2 }) => {
      t3.fillStyle = n2.borderColor;
      const l2 = Math.max(1, Math.floor(h2)), a2 = Math.floor(0.5 * h2), o2 = Math.round(s.T * r2);
      t3.beginPath();
      for (const n3 of i)
        t3.rect(Math.floor(e3 * r2), Math.round(n3.Aa * h2) - a2, o2, l2);
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      var r2;
      t3.font = this.Uv(), t3.fillStyle = null !== (r2 = n2.textColor) && void 0 !== r2 ? r2 : this.mo.textColor, t3.textAlign = this.Tv ? "right" : "left", t3.textBaseline = "middle";
      const h2 = this.Tv ? Math.round(e3 - s.B) : Math.round(e3 + s.T + s.B), l2 = i.map((i2) => this.Mv.xi(t3, i2.Za));
      for (let n3 = i.length; n3--; ) {
        const s2 = i[n3];
        t3.fillText(s2.Za, h2, s2.Aa + l2[n3]);
      }
    });
  }
  Gv() {
    if (null === this.wv || null === this.Li)
      return;
    let t2 = this.wv.height / 2;
    const i = [], n2 = this.Li.No().slice(), s = this.nn.Kv(), e3 = this.Hv();
    this.Li === s.vr() && this.nn.Kv().No().forEach((t3) => {
      s.dr(t3) && n2.push(t3);
    });
    const r2 = this.Li.Ta()[0], h2 = this.Li;
    n2.forEach((n3) => {
      const e4 = n3.Rn(s, h2);
      e4.forEach((t3) => {
        t3.Vi(null), t3.Bi() && i.push(t3);
      }), r2 === n3 && e4.length > 0 && (t2 = e4[0].yi());
    }), i.forEach((t3) => t3.Vi(t3.yi()));
    this.Li.W().alignLabels && this.hp(i, e3, t2);
  }
  hp(t2, i, n2) {
    if (null === this.wv)
      return;
    const s = t2.filter((t3) => t3.yi() <= n2), e3 = t2.filter((t3) => t3.yi() > n2);
    s.sort((t3, i2) => i2.yi() - t3.yi()), s.length && e3.length && e3.push(s[0]), e3.sort((t3, i2) => t3.yi() - i2.yi());
    for (const n3 of t2) {
      const t3 = Math.floor(n3.zt(i) / 2), s2 = n3.yi();
      s2 > -t3 && s2 < t3 && n3.Vi(t3), s2 > this.wv.height - t3 && s2 < this.wv.height + t3 && n3.Vi(this.wv.height - t3);
    }
    for (let t3 = 1; t3 < s.length; t3++) {
      const n3 = s[t3], e4 = s[t3 - 1], r2 = e4.zt(i, false), h2 = n3.yi(), l2 = e4.Ai();
      h2 > l2 - r2 && n3.Vi(l2 - r2);
    }
    for (let t3 = 1; t3 < e3.length; t3++) {
      const n3 = e3[t3], s2 = e3[t3 - 1], r2 = s2.zt(i, true), h2 = n3.yi(), l2 = s2.Ai();
      h2 < l2 + r2 && n3.Vi(l2 + r2);
    }
  }
  ip(t2) {
    if (null === this.wv)
      return;
    const i = this.qv(), n2 = this.Hv(), s = this.Tv ? "right" : "left";
    i.forEach((i2) => {
      if (i2.Ii()) {
        i2.xt(b(this.Li)).K(t2, n2, this.Mv, s);
      }
    });
  }
  np(t2) {
    if (null === this.wv || null === this.Li)
      return;
    const i = this.nn.yv().qt(), n2 = [], s = this.nn.Kv(), e3 = i.Fc().Rn(s, this.Li);
    e3.length && n2.push(e3);
    const r2 = this.Hv(), h2 = this.Tv ? "right" : "left";
    n2.forEach((i2) => {
      i2.forEach((i3) => {
        i3.xt(b(this.Li)).K(t2, r2, this.Mv, h2);
      });
    });
  }
  rp(t2) {
    this.Ov.style.cursor = 1 === t2 ? "ns-resize" : "default";
  }
  ao() {
    const t2 = this.$v();
    this.xv < t2 && this.nn.yv().qt().$l(), this.xv = t2;
  }
  Uv() {
    return N$1(this.mo.fontSize, this.mo.fontFamily);
  }
}
function Ss(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.ra) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function ks(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.Pn) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function ys(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.Qi) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
function Cs(t2, i) {
  var n2, s;
  return null !== (s = null === (n2 = t2.na) || void 0 === n2 ? void 0 : n2.call(t2, i)) && void 0 !== s ? s : [];
}
class Ts {
  constructor(i, n2) {
    this.wv = size({ width: 0, height: 0 }), this.lp = null, this.ap = null, this.op = null, this._p = false, this.up = new R(), this.cp = new R(), this.dp = 0, this.fp = false, this.vp = null, this.pp = false, this.mp = null, this.bp = null, this.Sv = false, this.kv = () => {
      this.Sv || null === this.wp || this.Ui().Fh();
    }, this.Cv = () => {
      this.Sv || null === this.wp || this.Ui().Fh();
    }, this.gp = i, this.wp = n2, this.wp.I_().l(this.Mp.bind(this), this, true), this.xp = document.createElement("td"), this.xp.style.padding = "0", this.xp.style.position = "relative";
    const s = document.createElement("div");
    s.style.width = "100%", s.style.height = "100%", s.style.position = "relative", s.style.overflow = "hidden", this.Sp = document.createElement("td"), this.Sp.style.padding = "0", this.kp = document.createElement("td"), this.kp.style.padding = "0", this.xp.appendChild(s), this.Av = as(s, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const e3 = this.Av.canvasElement;
    e3.style.position = "absolute", e3.style.zIndex = "1", e3.style.left = "0", e3.style.top = "0", this.Vv = as(s, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const r2 = this.Vv.canvasElement;
    r2.style.position = "absolute", r2.style.zIndex = "2", r2.style.left = "0", r2.style.top = "0", this.yp = document.createElement("tr"), this.yp.appendChild(this.Sp), this.yp.appendChild(this.xp), this.yp.appendChild(this.kp), this.Cp(), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => null === this.vp && !this.gp.W().handleScroll.vertTouchDrag, Ff: () => null === this.vp && !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    null !== this.lp && this.lp.S(), null !== this.ap && this.ap.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose(), null !== this.wp && this.wp.I_().p(this), this.Wv.S();
  }
  Kv() {
    return b(this.wp);
  }
  Tp(t2) {
    null !== this.wp && this.wp.I_().p(this), this.wp = t2, null !== this.wp && this.wp.I_().l(Ts.prototype.Mp.bind(this), this, true), this.Cp();
  }
  yv() {
    return this.gp;
  }
  jv() {
    return this.yp;
  }
  Cp() {
    if (null !== this.wp && (this.Pp(), 0 !== this.Ui().Mt().length)) {
      if (null !== this.lp) {
        const t2 = this.wp.S_();
        this.lp.Ji(b(t2));
      }
      if (null !== this.ap) {
        const t2 = this.wp.k_();
        this.ap.Ji(b(t2));
      }
    }
  }
  Rp() {
    null !== this.lp && this.lp.gt(), null !== this.ap && this.ap.gt();
  }
  v_() {
    return null !== this.wp ? this.wp.v_() : 0;
  }
  p_(t2) {
    this.wp && this.wp.p_(t2);
  }
  Bf(t2) {
    if (!this.wp)
      return;
    this.Dp();
    const i = t2.localX, n2 = t2.localY;
    this.Op(i, n2, t2);
  }
  Qf(t2) {
    this.Dp(), this.Ap(), this.Op(t2.localX, t2.localY, t2);
  }
  If(t2) {
    var i;
    if (!this.wp)
      return;
    this.Dp();
    const n2 = t2.localX, s = t2.localY;
    this.Op(n2, s, t2);
    const e3 = this.br(n2, s);
    this.gp.Vp(null !== (i = null == e3 ? void 0 : e3.bv) && void 0 !== i ? i : null), this.Ui().Bc(e3 && { Ic: e3.Ic, pv: e3.pv });
  }
  Xf(t2) {
    null !== this.wp && (this.Dp(), this.Bp(t2));
  }
  Tf(t2) {
    null !== this.wp && this.Ip(this.cp, t2);
  }
  Sf(t2) {
    this.Tf(t2);
  }
  Hf(t2) {
    this.Dp(), this.zp(t2), this.Op(t2.localX, t2.localY, t2);
  }
  Yf(t2) {
    null !== this.wp && (this.Dp(), this.fp = false, this.Ep(t2));
  }
  qf(t2) {
    null !== this.wp && this.Bp(t2);
  }
  _v(t2) {
    if (this.fp = true, null === this.vp) {
      const i = { x: t2.localX, y: t2.localY };
      this.Lp(i, i, t2);
    }
  }
  ov(t2) {
    null !== this.wp && (this.Dp(), this.wp.qt().Bc(null), this.Np());
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  sv() {
    this.dp = 1, this.Ui().Un();
  }
  ev(t2, i) {
    if (!this.gp.W().handleScale.pinch)
      return;
    const n2 = 5 * (i - this.dp);
    this.dp = i, this.Ui().Uc(t2.et, n2);
  }
  Gf(t2) {
    this.fp = false, this.pp = null !== this.vp, this.Ap();
    const i = this.Ui().Fc();
    null !== this.vp && i.Tt() && (this.mp = { x: i.Kt(), y: i.Zt() }, this.vp = { x: t2.localX, y: t2.localY });
  }
  Wf(t2) {
    if (null === this.wp)
      return;
    const i = t2.localX, n2 = t2.localY;
    if (null === this.vp)
      this.zp(t2);
    else {
      this.pp = false;
      const s = b(this.mp), e3 = s.x + (i - this.vp.x), r2 = s.y + (n2 - this.vp.y);
      this.Op(e3, r2, t2);
    }
  }
  Uf(t2) {
    0 === this.yv().W().trackingMode.exitMode && (this.pp = true), this.jp(), this.Ep(t2);
  }
  br(t2, i) {
    const n2 = this.wp;
    return null === n2 ? null : function(t3, i2, n3) {
      const s = t3.No(), e3 = function(t4, i3, n4) {
        var s2, e4;
        let r2, h2;
        for (const o2 of t4) {
          const t5 = null !== (e4 = null === (s2 = o2.oa) || void 0 === s2 ? void 0 : s2.call(o2, i3, n4)) && void 0 !== e4 ? e4 : [];
          for (const i4 of t5)
            l2 = i4.zOrder, (!(a2 = null == r2 ? void 0 : r2.zOrder) || "top" === l2 && "top" !== a2 || "normal" === l2 && "bottom" === a2) && (r2 = i4, h2 = o2);
        }
        var l2, a2;
        return r2 && h2 ? { mv: r2, Ic: h2 } : null;
      }(s, i2, n3);
      if ("top" === (null == e3 ? void 0 : e3.mv.zOrder))
        return ws(e3);
      for (const r2 of s) {
        if (e3 && e3.Ic === r2 && "bottom" !== e3.mv.zOrder && !e3.mv.isBackground)
          return ws(e3);
        const s2 = gs(r2.Pn(t3), i2, n3);
        if (null !== s2)
          return { Ic: r2, fv: s2.fv, pv: s2.pv };
        if (e3 && e3.Ic === r2 && "bottom" !== e3.mv.zOrder && e3.mv.isBackground)
          return ws(e3);
      }
      return (null == e3 ? void 0 : e3.mv) ? ws(e3) : null;
    }(n2, t2, i);
  }
  Hp(i, n2) {
    b("left" === n2 ? this.lp : this.ap).Yv(size({ width: i, height: this.wv.height }));
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Sv = true, this.Av.resizeCanvasElement(t2), this.Vv.resizeCanvasElement(t2), this.Sv = false, this.xp.style.width = t2.width + "px", this.xp.style.height = t2.height + "px");
  }
  Up() {
    const t2 = b(this.wp);
    t2.x_(t2.S_()), t2.x_(t2.k_());
    for (const i of t2.Ta())
      if (t2.dr(i)) {
        const n2 = i.At();
        null !== n2 && t2.x_(n2), i.On();
      }
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (0 === t2)
      return;
    if (null === this.wp)
      return;
    if (t2 > 1 && this.Up(), null !== this.lp && this.lp.Zv(t2), null !== this.ap && this.ap.Zv(t2), 1 !== t2) {
      this.Av.applySuggestedBitmapSize();
      const t3 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== t3 && (t3.useBitmapCoordinateSpace((t4) => {
        this.Jv(t4);
      }), this.wp && (this.qp(t3, Ss), this.Yp(t3), this.Xp(t3), this.qp(t3, ks), this.qp(t3, ys)));
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Kp(i), this.qp(i, Cs));
  }
  Zp() {
    return this.lp;
  }
  Gp() {
    return this.ap;
  }
  Qv(t2, i) {
    this.qp(t2, i);
  }
  Mp() {
    null !== this.wp && this.wp.I_().p(this), this.wp = null;
  }
  Bp(t2) {
    this.Ip(this.up, t2);
  }
  Ip(t2, i) {
    const n2 = i.localX, s = i.localY;
    t2.M() && t2.m(this.Ui().yt().Vu(n2), { x: n2, y: s }, i);
  }
  Jv({ context: t2, bitmapSize: i }) {
    const { width: n2, height: s } = i, e3 = this.Ui(), r2 = e3.q(), h2 = e3.od();
    r2 === h2 ? G$1(t2, 0, 0, n2, s, h2) : it(t2, 0, 0, n2, s, r2, h2);
  }
  Yp(t2) {
    const i = b(this.wp).z_().Wh().xt();
    null !== i && i.K(t2, false);
  }
  Xp(t2) {
    const i = this.Ui().Nc();
    this.Jp(t2, ks, os, i), this.Jp(t2, ks, _s, i);
  }
  Kp(t2) {
    this.Jp(t2, ks, _s, this.Ui().Fc());
  }
  qp(t2, i) {
    const n2 = b(this.wp).No();
    for (const s of n2)
      this.Jp(t2, i, os, s);
    for (const s of n2)
      this.Jp(t2, i, _s, s);
  }
  Jp(t2, i, n2, s) {
    const e3 = b(this.wp), r2 = e3.qt().Vc(), h2 = null !== r2 && r2.Ic === s, l2 = null !== r2 && h2 && void 0 !== r2.pv ? r2.pv.gr : void 0;
    us(i, (i2) => n2(i2, t2, h2, l2), s, e3);
  }
  Pp() {
    if (null === this.wp)
      return;
    const t2 = this.gp, i = this.wp.S_().W().visible, n2 = this.wp.k_().W().visible;
    i || null === this.lp || (this.Sp.removeChild(this.lp.jv()), this.lp.S(), this.lp = null), n2 || null === this.ap || (this.kp.removeChild(this.ap.jv()), this.ap.S(), this.ap = null);
    const s = t2.qt().sd();
    i && null === this.lp && (this.lp = new xs(this, t2.W(), s, "left"), this.Sp.appendChild(this.lp.jv())), n2 && null === this.ap && (this.ap = new xs(this, t2.W(), s, "right"), this.kp.appendChild(this.ap.jv()));
  }
  Qp(t2) {
    return t2.uv && this.fp || null !== this.vp;
  }
  tm(t2) {
    return Math.max(0, Math.min(t2, this.wv.width - 1));
  }
  im(t2) {
    return Math.max(0, Math.min(t2, this.wv.height - 1));
  }
  Op(t2, i, n2) {
    this.Ui().Jc(this.tm(t2), this.im(i), n2, b(this.wp));
  }
  Np() {
    this.Ui().td();
  }
  jp() {
    this.pp && (this.vp = null, this.Np());
  }
  Lp(t2, i, n2) {
    this.vp = t2, this.pp = false, this.Op(i.x, i.y, n2);
    const s = this.Ui().Fc();
    this.mp = { x: s.Kt(), y: s.Zt() };
  }
  Ui() {
    return this.gp.qt();
  }
  Ep(t2) {
    if (!this._p)
      return;
    const i = this.Ui(), n2 = this.Kv();
    if (i.D_(n2, n2.vn()), this.op = null, this._p = false, i.Kc(), null !== this.bp) {
      const t3 = performance.now(), n3 = i.yt();
      this.bp.Dr(n3.Eu(), t3), this.bp.Yu(t3) || i.Xn(this.bp);
    }
  }
  Dp() {
    this.vp = null;
  }
  Ap() {
    if (!this.wp)
      return;
    if (this.Ui().Un(), document.activeElement !== document.body && document.activeElement !== document.documentElement)
      b(document.activeElement).blur();
    else {
      const t2 = document.getSelection();
      null !== t2 && t2.removeAllRanges();
    }
    !this.wp.vn().Fi() && this.Ui().yt().Fi();
  }
  zp(t2) {
    if (null === this.wp)
      return;
    const i = this.Ui(), n2 = i.yt();
    if (n2.Fi())
      return;
    const s = this.gp.W(), e3 = s.handleScroll, r2 = s.kineticScroll;
    if ((!e3.pressedMouseMove || t2.uv) && (!e3.horzTouchDrag && !e3.vertTouchDrag || !t2.uv))
      return;
    const h2 = this.wp.vn(), l2 = performance.now();
    if (null !== this.op || this.Qp(t2) || (this.op = { x: t2.clientX, y: t2.clientY, kd: l2, nm: t2.localX, sm: t2.localY }), null !== this.op && !this._p && (this.op.x !== t2.clientX || this.op.y !== t2.clientY)) {
      if (t2.uv && r2.touch || !t2.uv && r2.mouse) {
        const t3 = n2.he();
        this.bp = new ls(0.2 / t3, 7 / t3, 0.997, 15 / t3), this.bp.Nd(n2.Eu(), this.op.kd);
      } else
        this.bp = null;
      h2.Fi() || i.P_(this.wp, h2, t2.localY), i.Yc(t2.localX), this._p = true;
    }
    this._p && (h2.Fi() || i.R_(this.wp, h2, t2.localY), i.Xc(t2.localX), null !== this.bp && this.bp.Nd(n2.Eu(), l2));
  }
}
class Ps {
  constructor(i, n2, s, e3, r2) {
    this.bt = true, this.wv = size({ width: 0, height: 0 }), this.kv = () => this.Zv(3), this.Tv = "left" === i, this.kc = s.sd, this.cn = n2, this.rm = e3, this.hm = r2, this.Ov = document.createElement("div"), this.Ov.style.width = "25px", this.Ov.style.height = "100%", this.Ov.style.overflow = "hidden", this.Av = as(this.Ov, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
  }
  S() {
    this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.Ov;
  }
  $p() {
    return this.wv;
  }
  Yv(t2) {
    equalSizes(this.wv, t2) || (this.wv = t2, this.Av.resizeCanvasElement(t2), this.Ov.style.width = `${t2.width}px`, this.Ov.style.height = `${t2.height}px`, this.bt = true);
  }
  Zv(t2) {
    if (t2 < 3 && !this.bt)
      return;
    if (0 === this.wv.width || 0 === this.wv.height)
      return;
    this.bt = false, this.Av.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Av);
    null !== i && i.useBitmapCoordinateSpace((t3) => {
      this.Jv(t3), this.Be(t3);
    });
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Be({ context: t2, bitmapSize: i, horizontalPixelRatio: n2, verticalPixelRatio: s }) {
    if (!this.rm())
      return;
    t2.fillStyle = this.cn.timeScale.borderColor;
    const e3 = Math.floor(this.kc.W().C * n2), r2 = Math.floor(this.kc.W().C * s), h2 = this.Tv ? i.width - e3 : 0;
    t2.fillRect(h2, 0, e3, r2);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.hm());
  }
}
function Rs(t2) {
  return (i) => {
    var n2, s;
    return null !== (s = null === (n2 = i.aa) || void 0 === n2 ? void 0 : n2.call(i, t2)) && void 0 !== s ? s : [];
  };
}
const Ds = Rs("normal"), Os = Rs("top"), As = Rs("bottom");
class Vs {
  constructor(i, n2) {
    this.lm = null, this.am = null, this.k = null, this.om = false, this.wv = size({ width: 0, height: 0 }), this._m = new R(), this.Mv = new si(5), this.Sv = false, this.kv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.Cv = () => {
      this.Sv || this.gp.qt().Fh();
    }, this.gp = i, this.N_ = n2, this.cn = i.W().layout, this.um = document.createElement("tr"), this.dm = document.createElement("td"), this.dm.style.padding = "0", this.fm = document.createElement("td"), this.fm.style.padding = "0", this.Ov = document.createElement("td"), this.Ov.style.height = "25px", this.Ov.style.padding = "0", this.vm = document.createElement("div"), this.vm.style.width = "100%", this.vm.style.height = "100%", this.vm.style.position = "relative", this.vm.style.overflow = "hidden", this.Ov.appendChild(this.vm), this.Av = as(this.vm, size({ width: 16, height: 16 })), this.Av.subscribeSuggestedBitmapSizeChanged(this.kv);
    const s = this.Av.canvasElement;
    s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Vv = as(this.vm, size({ width: 16, height: 16 })), this.Vv.subscribeSuggestedBitmapSizeChanged(this.Cv);
    const e3 = this.Vv.canvasElement;
    e3.style.position = "absolute", e3.style.zIndex = "2", e3.style.left = "0", e3.style.top = "0", this.um.appendChild(this.dm), this.um.appendChild(this.Ov), this.um.appendChild(this.fm), this.pm(), this.gp.qt().f_().l(this.pm.bind(this), this), this.Wv = new ds(this.Vv.canvasElement, this, { Nf: () => true, Ff: () => !this.gp.W().handleScroll.horzTouchDrag });
  }
  S() {
    this.Wv.S(), null !== this.lm && this.lm.S(), null !== this.am && this.am.S(), this.Vv.unsubscribeSuggestedBitmapSizeChanged(this.Cv), this.Vv.dispose(), this.Av.unsubscribeSuggestedBitmapSizeChanged(this.kv), this.Av.dispose();
  }
  jv() {
    return this.um;
  }
  bm() {
    return this.lm;
  }
  wm() {
    return this.am;
  }
  Qf(t2) {
    if (this.om)
      return;
    this.om = true;
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.$c(t2.localX);
  }
  Gf(t2) {
    this.Qf(t2);
  }
  tv() {
    const t2 = this.gp.qt();
    !t2.yt().Fi() && this.om && (this.om = false, this.gp.W().handleScale.axisPressedMouseMove.time && t2.Gc());
  }
  Hf(t2) {
    const i = this.gp.qt();
    !i.yt().Fi() && this.gp.W().handleScale.axisPressedMouseMove.time && i.Zc(t2.localX);
  }
  Wf(t2) {
    this.Hf(t2);
  }
  Yf() {
    this.om = false;
    const t2 = this.gp.qt();
    t2.yt().Fi() && !this.gp.W().handleScale.axisPressedMouseMove.time || t2.Gc();
  }
  Uf() {
    this.Yf();
  }
  Tf() {
    this.gp.W().handleScale.axisDoubleClickReset.time && this.gp.qt().Zn();
  }
  Sf() {
    this.Tf();
  }
  Bf() {
    this.gp.qt().W().handleScale.axisPressedMouseMove.time && this.rp(1);
  }
  ov() {
    this.rp(0);
  }
  $p() {
    return this.wv;
  }
  gm() {
    return this._m;
  }
  Mm(i, s, e3) {
    equalSizes(this.wv, i) || (this.wv = i, this.Sv = true, this.Av.resizeCanvasElement(i), this.Vv.resizeCanvasElement(i), this.Sv = false, this.Ov.style.width = `${i.width}px`, this.Ov.style.height = `${i.height}px`, this._m.m(i)), null !== this.lm && this.lm.Yv(size({ width: s, height: i.height })), null !== this.am && this.am.Yv(size({ width: e3, height: i.height }));
  }
  xm() {
    const t2 = this.Sm();
    return Math.ceil(t2.C + t2.T + t2.P + t2.L + t2.V + t2.km);
  }
  gt() {
    this.gp.qt().yt().Ea();
  }
  sp() {
    return this.Av.bitmapSize;
  }
  ep(t2, i, n2) {
    const s = this.sp();
    s.width > 0 && s.height > 0 && t2.drawImage(this.Av.canvasElement, i, n2);
  }
  Zv(t2) {
    if (0 === t2)
      return;
    if (1 !== t2) {
      this.Av.applySuggestedBitmapSize();
      const i2 = tryCreateCanvasRenderingTarget2D(this.Av);
      null !== i2 && (i2.useBitmapCoordinateSpace((t3) => {
        this.Jv(t3), this.Be(t3), this.ym(i2, As);
      }), this.tp(i2), this.ym(i2, Ds)), null !== this.lm && this.lm.Zv(t2), null !== this.am && this.am.Zv(t2);
    }
    this.Vv.applySuggestedBitmapSize();
    const i = tryCreateCanvasRenderingTarget2D(this.Vv);
    null !== i && (i.useBitmapCoordinateSpace(({ context: t3, bitmapSize: i2 }) => {
      t3.clearRect(0, 0, i2.width, i2.height);
    }), this.Cm([...this.gp.qt().Mt(), this.gp.qt().Fc()], i), this.ym(i, Os));
  }
  ym(t2, i) {
    const n2 = this.gp.qt().Mt();
    for (const s of n2)
      us(i, (i2) => os(i2, t2, false, void 0), s, void 0);
    for (const s of n2)
      us(i, (i2) => _s(i2, t2, false, void 0), s, void 0);
  }
  Jv({ context: t2, bitmapSize: i }) {
    G$1(t2, 0, 0, i.width, i.height, this.gp.qt().od());
  }
  Be({ context: t2, bitmapSize: i, verticalPixelRatio: n2 }) {
    if (this.gp.W().timeScale.borderVisible) {
      t2.fillStyle = this.Tm();
      const s = Math.max(1, Math.floor(this.Sm().C * n2));
      t2.fillRect(0, 0, i.width, s);
    }
  }
  tp(t2) {
    const i = this.gp.qt().yt(), n2 = i.Ea();
    if (!n2 || 0 === n2.length)
      return;
    const s = this.N_.maxTickMarkWeight(n2), e3 = this.Sm(), r2 = i.W();
    r2.borderVisible && r2.ticksVisible && t2.useBitmapCoordinateSpace(({ context: t3, horizontalPixelRatio: i2, verticalPixelRatio: s2 }) => {
      t3.strokeStyle = this.Tm(), t3.fillStyle = this.Tm();
      const r3 = Math.max(1, Math.floor(i2)), h2 = Math.floor(0.5 * i2);
      t3.beginPath();
      const l2 = Math.round(e3.T * s2);
      for (let s3 = n2.length; s3--; ) {
        const e4 = Math.round(n2[s3].coord * i2);
        t3.rect(e4 - h2, 0, r3, l2);
      }
      t3.fill();
    }), t2.useMediaCoordinateSpace(({ context: t3 }) => {
      const i2 = e3.C + e3.T + e3.L + e3.P / 2;
      t3.textAlign = "center", t3.textBaseline = "middle", t3.fillStyle = this.$(), t3.font = this.Uv();
      for (const e4 of n2)
        if (e4.weight < s) {
          const n3 = e4.needAlignCoordinate ? this.Pm(t3, e4.coord, e4.label) : e4.coord;
          t3.fillText(e4.label, n3, i2);
        }
      t3.font = this.Rm();
      for (const e4 of n2)
        if (e4.weight >= s) {
          const n3 = e4.needAlignCoordinate ? this.Pm(t3, e4.coord, e4.label) : e4.coord;
          t3.fillText(e4.label, n3, i2);
        }
    });
  }
  Pm(t2, i, n2) {
    const s = this.Mv.Si(t2, n2), e3 = s / 2, r2 = Math.floor(i - e3) + 0.5;
    return r2 < 0 ? i += Math.abs(0 - r2) : r2 + s > this.wv.width && (i -= Math.abs(this.wv.width - (r2 + s))), i;
  }
  Cm(t2, i) {
    const n2 = this.Sm();
    for (const s of t2)
      for (const t3 of s.tn())
        t3.xt().K(i, n2);
  }
  Tm() {
    return this.gp.W().timeScale.borderColor;
  }
  $() {
    return this.cn.textColor;
  }
  j() {
    return this.cn.fontSize;
  }
  Uv() {
    return N$1(this.j(), this.cn.fontFamily);
  }
  Rm() {
    return N$1(this.j(), this.cn.fontFamily, "bold");
  }
  Sm() {
    null === this.k && (this.k = { C: 1, N: NaN, L: NaN, V: NaN, Hi: NaN, T: 5, P: NaN, R: "", ji: new si(), km: 0 });
    const t2 = this.k, i = this.Uv();
    if (t2.R !== i) {
      const n2 = this.j();
      t2.P = n2, t2.R = i, t2.L = 3 * n2 / 12, t2.V = 3 * n2 / 12, t2.Hi = 9 * n2 / 12, t2.N = 0, t2.km = 4 * n2 / 12, t2.ji.ir();
    }
    return this.k;
  }
  rp(t2) {
    this.Ov.style.cursor = 1 === t2 ? "ew-resize" : "default";
  }
  pm() {
    const t2 = this.gp.qt(), i = t2.W();
    i.leftPriceScale.visible || null === this.lm || (this.dm.removeChild(this.lm.jv()), this.lm.S(), this.lm = null), i.rightPriceScale.visible || null === this.am || (this.fm.removeChild(this.am.jv()), this.am.S(), this.am = null);
    const n2 = { sd: this.gp.qt().sd() }, s = () => i.leftPriceScale.borderVisible && t2.yt().W().borderVisible, e3 = () => t2.od();
    i.leftPriceScale.visible && null === this.lm && (this.lm = new Ps("left", i, n2, s, e3), this.dm.appendChild(this.lm.jv())), i.rightPriceScale.visible && null === this.am && (this.am = new Ps("right", i, n2, s, e3), this.fm.appendChild(this.am.jv()));
  }
}
const Bs = !!is && !!navigator.userAgentData && navigator.userAgentData.brands.some((t2) => t2.brand.includes("Chromium")) && !!is && ((null === (Is = null === navigator || void 0 === navigator ? void 0 : navigator.userAgentData) || void 0 === Is ? void 0 : Is.platform) ? "Windows" === navigator.userAgentData.platform : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
var Is;
class zs {
  constructor(t2, i, n2) {
    var s;
    this.Dm = [], this.Om = 0, this.Qa = 0, this.e_ = 0, this.Am = 0, this.Vm = 0, this.Bm = null, this.Im = false, this.up = new R(), this.cp = new R(), this.Mc = new R(), this.zm = null, this.Em = null, this.Lm = t2, this.cn = i, this.N_ = n2, this.um = document.createElement("div"), this.um.classList.add("tv-lightweight-charts"), this.um.style.overflow = "hidden", this.um.style.direction = "ltr", this.um.style.width = "100%", this.um.style.height = "100%", (s = this.um).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.Nm = document.createElement("table"), this.Nm.setAttribute("cellspacing", "0"), this.um.appendChild(this.Nm), this.Fm = this.Wm.bind(this), Es(this.cn) && this.jm(true), this.Ui = new zn(this.Sc.bind(this), this.cn, n2), this.qt().Wc().l(this.Hm.bind(this), this), this.$m = new Vs(this, this.N_), this.Nm.appendChild(this.$m.jv());
    const e3 = i.autoSize && this.Um();
    let r2 = this.cn.width, h2 = this.cn.height;
    if (e3 || 0 === r2 || 0 === h2) {
      const i2 = t2.getBoundingClientRect();
      r2 = r2 || i2.width, h2 = h2 || i2.height;
    }
    this.qm(r2, h2), this.Ym(), t2.appendChild(this.um), this.Xm(), this.Ui.yt().Gu().l(this.Ui.$l.bind(this.Ui), this), this.Ui.f_().l(this.Ui.$l.bind(this.Ui), this);
  }
  qt() {
    return this.Ui;
  }
  W() {
    return this.cn;
  }
  Km() {
    return this.Dm;
  }
  Zm() {
    return this.$m;
  }
  S() {
    this.jm(false), 0 !== this.Om && window.cancelAnimationFrame(this.Om), this.Ui.Wc().p(this), this.Ui.yt().Gu().p(this), this.Ui.f_().p(this), this.Ui.S();
    for (const t2 of this.Dm)
      this.Nm.removeChild(t2.jv()), t2.Fp().p(this), t2.Wp().p(this), t2.S();
    this.Dm = [], b(this.$m).S(), null !== this.um.parentElement && this.um.parentElement.removeChild(this.um), this.Mc.S(), this.up.S(), this.cp.S(), this.Gm();
  }
  qm(i, n2, s = false) {
    if (this.Qa === n2 && this.e_ === i)
      return;
    const e3 = function(i2) {
      const n3 = Math.floor(i2.width), s2 = Math.floor(i2.height);
      return size({ width: n3 - n3 % 2, height: s2 - s2 % 2 });
    }(size({ width: i, height: n2 }));
    this.Qa = e3.height, this.e_ = e3.width;
    const r2 = this.Qa + "px", h2 = this.e_ + "px";
    b(this.um).style.height = r2, b(this.um).style.width = h2, this.Nm.style.height = r2, this.Nm.style.width = h2, s ? this.Jm(ct.es(), performance.now()) : this.Ui.$l();
  }
  Zv(t2) {
    void 0 === t2 && (t2 = ct.es());
    for (let i = 0; i < this.Dm.length; i++)
      this.Dm[i].Zv(t2.Hn(i).Fn);
    this.cn.timeScale.visible && this.$m.Zv(t2.jn());
  }
  Nh(t2) {
    const i = Es(this.cn);
    this.Ui.Nh(t2);
    const n2 = Es(this.cn);
    n2 !== i && this.jm(n2), this.Xm(), this.Qm(t2);
  }
  Fp() {
    return this.up;
  }
  Wp() {
    return this.cp;
  }
  Wc() {
    return this.Mc;
  }
  tb() {
    null !== this.Bm && (this.Jm(this.Bm, performance.now()), this.Bm = null);
    const t2 = this.ib(null), i = document.createElement("canvas");
    i.width = t2.width, i.height = t2.height;
    const n2 = b(i.getContext("2d"));
    return this.ib(n2), i;
  }
  nb(t2) {
    if ("left" === t2 && !this.sb())
      return 0;
    if ("right" === t2 && !this.eb())
      return 0;
    if (0 === this.Dm.length)
      return 0;
    return b("left" === t2 ? this.Dm[0].Zp() : this.Dm[0].Gp()).Xv();
  }
  rb() {
    return this.cn.autoSize && null !== this.zm;
  }
  hb() {
    return this.um;
  }
  Vp(t2) {
    this.Em = t2, this.Em ? this.hb().style.setProperty("cursor", t2) : this.hb().style.removeProperty("cursor");
  }
  lb() {
    return this.Em;
  }
  ab() {
    return m$1(this.Dm[0]).$p();
  }
  Qm(t2) {
    (void 0 !== t2.autoSize || !this.zm || void 0 === t2.width && void 0 === t2.height) && (t2.autoSize && !this.zm && this.Um(), false === t2.autoSize && null !== this.zm && this.Gm(), t2.autoSize || void 0 === t2.width && void 0 === t2.height || this.qm(t2.width || this.e_, t2.height || this.Qa));
  }
  ib(i) {
    let n2 = 0, s = 0;
    const e3 = this.Dm[0], r2 = (t2, n3) => {
      let s2 = 0;
      for (let e4 = 0; e4 < this.Dm.length; e4++) {
        const r3 = this.Dm[e4], h3 = b("left" === t2 ? r3.Zp() : r3.Gp()), l2 = h3.sp();
        null !== i && h3.ep(i, n3, s2), s2 += l2.height;
      }
    };
    if (this.sb()) {
      r2("left", 0);
      n2 += b(e3.Zp()).sp().width;
    }
    for (let t2 = 0; t2 < this.Dm.length; t2++) {
      const e4 = this.Dm[t2], r3 = e4.sp();
      null !== i && e4.ep(i, n2, s), s += r3.height;
    }
    if (n2 += e3.sp().width, this.eb()) {
      r2("right", n2);
      n2 += b(e3.Gp()).sp().width;
    }
    const h2 = (t2, n3, s2) => {
      b("left" === t2 ? this.$m.bm() : this.$m.wm()).ep(b(i), n3, s2);
    };
    if (this.cn.timeScale.visible) {
      const t2 = this.$m.sp();
      if (null !== i) {
        let n3 = 0;
        this.sb() && (h2("left", n3, s), n3 = b(e3.Zp()).sp().width), this.$m.ep(i, n3, s), n3 += t2.width, this.eb() && h2("right", n3, s);
      }
      s += t2.height;
    }
    return size({ width: n2, height: s });
  }
  ob() {
    let i = 0, n2 = 0, s = 0;
    for (const t2 of this.Dm)
      this.sb() && (n2 = Math.max(n2, b(t2.Zp()).$v(), this.cn.leftPriceScale.minimumWidth)), this.eb() && (s = Math.max(s, b(t2.Gp()).$v(), this.cn.rightPriceScale.minimumWidth)), i += t2.v_();
    n2 = es(n2), s = es(s);
    const e3 = this.e_, r2 = this.Qa, h2 = Math.max(e3 - n2 - s, 0), l2 = this.cn.timeScale.visible;
    let a2 = l2 ? Math.max(this.$m.xm(), this.cn.timeScale.minimumHeight) : 0;
    var o2;
    a2 = (o2 = a2) + o2 % 2;
    const _24 = 0 + a2, u2 = r2 < _24 ? 0 : r2 - _24, c2 = u2 / i;
    let d2 = 0;
    for (let i2 = 0; i2 < this.Dm.length; ++i2) {
      const e4 = this.Dm[i2];
      e4.Tp(this.Ui.Lc()[i2]);
      let r3 = 0, l3 = 0;
      l3 = i2 === this.Dm.length - 1 ? u2 - d2 : Math.round(e4.v_() * c2), r3 = Math.max(l3, 2), d2 += r3, e4.Yv(size({ width: h2, height: r3 })), this.sb() && e4.Hp(n2, "left"), this.eb() && e4.Hp(s, "right"), e4.Kv() && this.Ui.jc(e4.Kv(), r3);
    }
    this.$m.Mm(size({ width: l2 ? h2 : 0, height: a2 }), l2 ? n2 : 0, l2 ? s : 0), this.Ui.m_(h2), this.Am !== n2 && (this.Am = n2), this.Vm !== s && (this.Vm = s);
  }
  jm(t2) {
    t2 ? this.um.addEventListener("wheel", this.Fm, { passive: false }) : this.um.removeEventListener("wheel", this.Fm);
  }
  _b(t2) {
    switch (t2.deltaMode) {
      case t2.DOM_DELTA_PAGE:
        return 120;
      case t2.DOM_DELTA_LINE:
        return 32;
    }
    return Bs ? 1 / window.devicePixelRatio : 1;
  }
  Wm(t2) {
    if (!(0 !== t2.deltaX && this.cn.handleScroll.mouseWheel || 0 !== t2.deltaY && this.cn.handleScale.mouseWheel))
      return;
    const i = this._b(t2), n2 = i * t2.deltaX / 100, s = -i * t2.deltaY / 100;
    if (t2.cancelable && t2.preventDefault(), 0 !== s && this.cn.handleScale.mouseWheel) {
      const i2 = Math.sign(s) * Math.min(1, Math.abs(s)), n3 = t2.clientX - this.um.getBoundingClientRect().left;
      this.qt().Uc(n3, i2);
    }
    0 !== n2 && this.cn.handleScroll.mouseWheel && this.qt().qc(-80 * n2);
  }
  Jm(t2, i) {
    var n2;
    const s = t2.jn();
    3 === s && this.ub(), 3 !== s && 2 !== s || (this.cb(t2), this.fb(t2, i), this.$m.gt(), this.Dm.forEach((t3) => {
      t3.Rp();
    }), 3 === (null === (n2 = this.Bm) || void 0 === n2 ? void 0 : n2.jn()) && (this.Bm.ts(t2), this.ub(), this.cb(this.Bm), this.fb(this.Bm, i), t2 = this.Bm, this.Bm = null)), this.Zv(t2);
  }
  fb(t2, i) {
    for (const n2 of t2.Qn())
      this.ns(n2, i);
  }
  cb(t2) {
    const i = this.Ui.Lc();
    for (let n2 = 0; n2 < i.length; n2++)
      t2.Hn(n2).Wn && i[n2].V_();
  }
  ns(t2, i) {
    const n2 = this.Ui.yt();
    switch (t2.qn) {
      case 0:
        n2.Qu();
        break;
      case 1:
        n2.tc(t2.Vt);
        break;
      case 2:
        n2.Gn(t2.Vt);
        break;
      case 3:
        n2.Jn(t2.Vt);
        break;
      case 4:
        n2.Fu();
        break;
      case 5:
        t2.Vt.Yu(i) || n2.Jn(t2.Vt.Xu(i));
    }
  }
  Sc(t2) {
    null !== this.Bm ? this.Bm.ts(t2) : this.Bm = t2, this.Im || (this.Im = true, this.Om = window.requestAnimationFrame((t3) => {
      if (this.Im = false, this.Om = 0, null !== this.Bm) {
        const i = this.Bm;
        this.Bm = null, this.Jm(i, t3);
        for (const n2 of i.Qn())
          if (5 === n2.qn && !n2.Vt.Yu(t3)) {
            this.qt().Xn(n2.Vt);
            break;
          }
      }
    }));
  }
  ub() {
    this.Ym();
  }
  Ym() {
    const t2 = this.Ui.Lc(), i = t2.length, n2 = this.Dm.length;
    for (let t3 = i; t3 < n2; t3++) {
      const t4 = m$1(this.Dm.pop());
      this.Nm.removeChild(t4.jv()), t4.Fp().p(this), t4.Wp().p(this), t4.S();
    }
    for (let s = n2; s < i; s++) {
      const i2 = new Ts(this, t2[s]);
      i2.Fp().l(this.vb.bind(this), this), i2.Wp().l(this.pb.bind(this), this), this.Dm.push(i2), this.Nm.insertBefore(i2.jv(), this.$m.jv());
    }
    for (let n3 = 0; n3 < i; n3++) {
      const i2 = t2[n3], s = this.Dm[n3];
      s.Kv() !== i2 ? s.Tp(i2) : s.Cp();
    }
    this.Xm(), this.ob();
  }
  mb(t2, i, n2) {
    var s;
    const e3 = /* @__PURE__ */ new Map();
    if (null !== t2) {
      this.Ui.Mt().forEach((i2) => {
        const n3 = i2.In().nl(t2);
        null !== n3 && e3.set(i2, n3);
      });
    }
    let r2;
    if (null !== t2) {
      const i2 = null === (s = this.Ui.yt().qi(t2)) || void 0 === s ? void 0 : s.originalTime;
      void 0 !== i2 && (r2 = i2);
    }
    const h2 = this.qt().Vc(), l2 = null !== h2 && h2.Ic instanceof Gi ? h2.Ic : void 0, a2 = null !== h2 && void 0 !== h2.pv ? h2.pv.wr : void 0;
    return { bb: r2, se: null != t2 ? t2 : void 0, wb: null != i ? i : void 0, gb: l2, Mb: e3, xb: a2, Sb: null != n2 ? n2 : void 0 };
  }
  vb(t2, i, n2) {
    this.up.m(() => this.mb(t2, i, n2));
  }
  pb(t2, i, n2) {
    this.cp.m(() => this.mb(t2, i, n2));
  }
  Hm(t2, i, n2) {
    this.Mc.m(() => this.mb(t2, i, n2));
  }
  Xm() {
    const t2 = this.cn.timeScale.visible ? "" : "none";
    this.$m.jv().style.display = t2;
  }
  sb() {
    return this.Dm[0].Kv().S_().W().visible;
  }
  eb() {
    return this.Dm[0].Kv().k_().W().visible;
  }
  Um() {
    return "ResizeObserver" in window && (this.zm = new ResizeObserver((t2) => {
      const i = t2.find((t3) => t3.target === this.Lm);
      i && this.qm(i.contentRect.width, i.contentRect.height);
    }), this.zm.observe(this.Lm, { box: "border-box" }), true);
  }
  Gm() {
    null !== this.zm && this.zm.disconnect(), this.zm = null;
  }
}
function Es(t2) {
  return Boolean(t2.handleScroll.mouseWheel || t2.handleScale.mouseWheel);
}
function Ls(t2, i) {
  var n2 = {};
  for (var s in t2)
    Object.prototype.hasOwnProperty.call(t2, s) && i.indexOf(s) < 0 && (n2[s] = t2[s]);
  if (null != t2 && "function" == typeof Object.getOwnPropertySymbols) {
    var e3 = 0;
    for (s = Object.getOwnPropertySymbols(t2); e3 < s.length; e3++)
      i.indexOf(s[e3]) < 0 && Object.prototype.propertyIsEnumerable.call(t2, s[e3]) && (n2[s[e3]] = t2[s[e3]]);
  }
  return n2;
}
function Ns(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.color && (r2.O = n2.color), r2;
}
function Fs(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.lineColor && (r2._t = n2.lineColor), void 0 !== n2.topColor && (r2.Ts = n2.topColor), void 0 !== n2.bottomColor && (r2.Ps = n2.bottomColor), r2;
}
function Ws(t2, i, n2, s) {
  const e3 = n2.value, r2 = { se: i, ut: t2, Vt: [e3, e3, e3, e3], bb: s };
  return void 0 !== n2.topLineColor && (r2.Pe = n2.topLineColor), void 0 !== n2.bottomLineColor && (r2.Re = n2.bottomLineColor), void 0 !== n2.topFillColor1 && (r2.Se = n2.topFillColor1), void 0 !== n2.topFillColor2 && (r2.ke = n2.topFillColor2), void 0 !== n2.bottomFillColor1 && (r2.ye = n2.bottomFillColor1), void 0 !== n2.bottomFillColor2 && (r2.Ce = n2.bottomFillColor2), r2;
}
function js(t2, i, n2, s) {
  const e3 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return void 0 !== n2.color && (e3.O = n2.color), e3;
}
function Hs(t2, i, n2, s) {
  const e3 = { se: i, ut: t2, Vt: [n2.open, n2.high, n2.low, n2.close], bb: s };
  return void 0 !== n2.color && (e3.O = n2.color), void 0 !== n2.borderColor && (e3.Bt = n2.borderColor), void 0 !== n2.wickColor && (e3.$h = n2.wickColor), e3;
}
function $s(t2, i, n2, s, e3) {
  const r2 = m$1(e3)(n2), h2 = Math.max(...r2), l2 = Math.min(...r2), a2 = r2[r2.length - 1], o2 = [a2, h2, l2, a2], _24 = n2, { time: u2, color: c2 } = _24;
  return { se: i, ut: t2, Vt: o2, bb: s, He: Ls(_24, ["time", "color"]), O: c2 };
}
function Us(t2) {
  return void 0 !== t2.Vt;
}
function qs(t2, i) {
  return void 0 !== i.customValues && (t2.kb = i.customValues), t2;
}
function Ys(t2) {
  return (i, n2, s, e3, r2, h2) => function(t3, i2) {
    return i2 ? i2(t3) : void 0 === (n3 = t3).open && void 0 === n3.value;
    var n3;
  }(s, h2) ? qs({ ut: i, se: n2, bb: e3 }, s) : qs(t2(i, n2, s, e3, r2), s);
}
function Xs(t2) {
  return { Candlestick: Ys(Hs), Bar: Ys(js), Area: Ys(Fs), Baseline: Ys(Ws), Histogram: Ys(Ns), Line: Ys(Ns), Custom: Ys($s) }[t2];
}
function Ks(t2) {
  return { se: 0, yb: /* @__PURE__ */ new Map(), ia: t2 };
}
function Zs(t2, i) {
  if (void 0 !== t2 && 0 !== t2.length)
    return { Cb: i.key(t2[0].ut), Tb: i.key(t2[t2.length - 1].ut) };
}
function Gs(t2) {
  let i;
  return t2.forEach((t3) => {
    void 0 === i && (i = t3.bb);
  }), m$1(i);
}
class Js {
  constructor(t2) {
    this.Pb = /* @__PURE__ */ new Map(), this.Rb = /* @__PURE__ */ new Map(), this.Db = /* @__PURE__ */ new Map(), this.Ob = [], this.N_ = t2;
  }
  S() {
    this.Pb.clear(), this.Rb.clear(), this.Db.clear(), this.Ob = [];
  }
  Ab(t2, i) {
    let n2 = 0 !== this.Pb.size, s = false;
    const e3 = this.Rb.get(t2);
    if (void 0 !== e3)
      if (1 === this.Rb.size)
        n2 = false, s = true, this.Pb.clear();
      else
        for (const i2 of this.Ob)
          i2.pointData.yb.delete(t2) && (s = true);
    let r2 = [];
    if (0 !== i.length) {
      const n3 = i.map((t3) => t3.time), e4 = this.N_.createConverterToInternalObj(i), h3 = Xs(t2.Xh()), l2 = t2.ga(), a2 = t2.Ma();
      r2 = i.map((i2, r3) => {
        const o2 = e4(i2.time), _24 = this.N_.key(o2);
        let u2 = this.Pb.get(_24);
        void 0 === u2 && (u2 = Ks(o2), this.Pb.set(_24, u2), s = true);
        const c2 = h3(o2, u2.se, i2, n3[r3], l2, a2);
        return u2.yb.set(t2, c2), c2;
      });
    }
    n2 && this.Vb(), this.Bb(t2, r2);
    let h2 = -1;
    if (s) {
      const t3 = [];
      this.Pb.forEach((i2) => {
        t3.push({ timeWeight: 0, time: i2.ia, pointData: i2, originalTime: Gs(i2.yb) });
      }), t3.sort((t4, i2) => this.N_.key(t4.time) - this.N_.key(i2.time)), h2 = this.Ib(t3);
    }
    return this.zb(t2, h2, function(t3, i2, n3) {
      const s2 = Zs(t3, n3), e4 = Zs(i2, n3);
      if (void 0 !== s2 && void 0 !== e4)
        return { Xl: s2.Tb >= e4.Tb && s2.Cb >= e4.Cb };
    }(this.Rb.get(t2), e3, this.N_));
  }
  hd(t2) {
    return this.Ab(t2, []);
  }
  Eb(t2, i) {
    const n2 = i;
    !function(t3) {
      void 0 === t3.bb && (t3.bb = t3.time);
    }(n2), this.N_.preprocessData(i);
    const s = this.N_.createConverterToInternalObj([i])(i.time), e3 = this.Db.get(t2);
    if (void 0 !== e3 && this.N_.key(s) < this.N_.key(e3))
      throw new Error(`Cannot update oldest data, last time=${e3}, new time=${s}`);
    let r2 = this.Pb.get(this.N_.key(s));
    const h2 = void 0 === r2;
    void 0 === r2 && (r2 = Ks(s), this.Pb.set(this.N_.key(s), r2));
    const l2 = Xs(t2.Xh()), a2 = t2.ga(), o2 = t2.Ma(), _24 = l2(s, r2.se, i, n2.bb, a2, o2);
    r2.yb.set(t2, _24), this.Lb(t2, _24);
    const u2 = { Xl: Us(_24) };
    if (!h2)
      return this.zb(t2, -1, u2);
    const c2 = { timeWeight: 0, time: r2.ia, pointData: r2, originalTime: Gs(r2.yb) }, d2 = Bt$1(this.Ob, this.N_.key(c2.time), (t3, i2) => this.N_.key(t3.time) < i2);
    this.Ob.splice(d2, 0, c2);
    for (let t3 = d2; t3 < this.Ob.length; ++t3)
      Qs(this.Ob[t3].pointData, t3);
    return this.N_.fillWeightsForPoints(this.Ob, d2), this.zb(t2, d2, u2);
  }
  Lb(t2, i) {
    let n2 = this.Rb.get(t2);
    void 0 === n2 && (n2 = [], this.Rb.set(t2, n2));
    const s = 0 !== n2.length ? n2[n2.length - 1] : null;
    null === s || this.N_.key(i.ut) > this.N_.key(s.ut) ? Us(i) && n2.push(i) : Us(i) ? n2[n2.length - 1] = i : n2.splice(-1, 1), this.Db.set(t2, i.ut);
  }
  Bb(t2, i) {
    0 !== i.length ? (this.Rb.set(t2, i.filter(Us)), this.Db.set(t2, i[i.length - 1].ut)) : (this.Rb.delete(t2), this.Db.delete(t2));
  }
  Vb() {
    for (const t2 of this.Ob)
      0 === t2.pointData.yb.size && this.Pb.delete(this.N_.key(t2.time));
  }
  Ib(t2) {
    let i = -1;
    for (let n2 = 0; n2 < this.Ob.length && n2 < t2.length; ++n2) {
      const s = this.Ob[n2], e3 = t2[n2];
      if (this.N_.key(s.time) !== this.N_.key(e3.time)) {
        i = n2;
        break;
      }
      e3.timeWeight = s.timeWeight, Qs(e3.pointData, n2);
    }
    if (-1 === i && this.Ob.length !== t2.length && (i = Math.min(this.Ob.length, t2.length)), -1 === i)
      return -1;
    for (let n2 = i; n2 < t2.length; ++n2)
      Qs(t2[n2].pointData, n2);
    return this.N_.fillWeightsForPoints(t2, i), this.Ob = t2, i;
  }
  Nb() {
    if (0 === this.Rb.size)
      return null;
    let t2 = 0;
    return this.Rb.forEach((i) => {
      0 !== i.length && (t2 = Math.max(t2, i[i.length - 1].se));
    }), t2;
  }
  zb(t2, i, n2) {
    const s = { Fb: /* @__PURE__ */ new Map(), yt: { Au: this.Nb() } };
    if (-1 !== i)
      this.Rb.forEach((i2, e3) => {
        s.Fb.set(e3, { He: i2, Wb: e3 === t2 ? n2 : void 0 });
      }), this.Rb.has(t2) || s.Fb.set(t2, { He: [], Wb: n2 }), s.yt.jb = this.Ob, s.yt.Hb = i;
    else {
      const i2 = this.Rb.get(t2);
      s.Fb.set(t2, { He: i2 || [], Wb: n2 });
    }
    return s;
  }
}
function Qs(t2, i) {
  t2.se = i, t2.yb.forEach((t3) => {
    t3.se = i;
  });
}
function te$1(t2) {
  const i = { value: t2.Vt[3], time: t2.bb };
  return void 0 !== t2.kb && (i.customValues = t2.kb), i;
}
function ie$1(t2) {
  const i = te$1(t2);
  return void 0 !== t2.O && (i.color = t2.O), i;
}
function ne(t2) {
  const i = te$1(t2);
  return void 0 !== t2._t && (i.lineColor = t2._t), void 0 !== t2.Ts && (i.topColor = t2.Ts), void 0 !== t2.Ps && (i.bottomColor = t2.Ps), i;
}
function se$1(t2) {
  const i = te$1(t2);
  return void 0 !== t2.Pe && (i.topLineColor = t2.Pe), void 0 !== t2.Re && (i.bottomLineColor = t2.Re), void 0 !== t2.Se && (i.topFillColor1 = t2.Se), void 0 !== t2.ke && (i.topFillColor2 = t2.ke), void 0 !== t2.ye && (i.bottomFillColor1 = t2.ye), void 0 !== t2.Ce && (i.bottomFillColor2 = t2.Ce), i;
}
function ee$1(t2) {
  const i = { open: t2.Vt[0], high: t2.Vt[1], low: t2.Vt[2], close: t2.Vt[3], time: t2.bb };
  return void 0 !== t2.kb && (i.customValues = t2.kb), i;
}
function re$1(t2) {
  const i = ee$1(t2);
  return void 0 !== t2.O && (i.color = t2.O), i;
}
function he(t2) {
  const i = ee$1(t2), { O: n2, Bt: s, $h: e3 } = t2;
  return void 0 !== n2 && (i.color = n2), void 0 !== s && (i.borderColor = s), void 0 !== e3 && (i.wickColor = e3), i;
}
function le(t2) {
  return { Area: ne, Line: ie$1, Baseline: se$1, Histogram: ie$1, Bar: re$1, Candlestick: he, Custom: ae$1 }[t2];
}
function ae$1(t2) {
  const i = t2.bb;
  return Object.assign(Object.assign({}, t2.He), { time: i });
}
const oe$1 = { vertLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, horzLine: { color: "#9598A1", width: 1, style: 3, visible: true, labelVisible: true, labelBackgroundColor: "#131722" }, mode: 1 }, _e$1 = { vertLines: { color: "#D6DCDE", style: 0, visible: true }, horzLines: { color: "#D6DCDE", style: 0, visible: true } }, ue = { background: { type: "solid", color: "#FFFFFF" }, textColor: "#191919", fontSize: 12, fontFamily: L$1 }, ce$1 = { autoScale: true, mode: 0, invertScale: false, alignLabels: true, borderVisible: true, borderColor: "#2B2B43", entireTextOnly: false, visible: false, ticksVisible: false, scaleMargins: { bottom: 0.1, top: 0.2 }, minimumWidth: 0 }, de = { rightOffset: 0, barSpacing: 6, minBarSpacing: 0.5, fixLeftEdge: false, fixRightEdge: false, lockVisibleTimeRangeOnResize: false, rightBarStaysOnScroll: false, borderVisible: true, borderColor: "#2B2B43", visible: true, timeVisible: false, secondsVisible: true, shiftVisibleRangeOnNewBar: true, allowShiftVisibleRangeOnWhitespaceReplacement: false, ticksVisible: false, uniformDistribution: false, minimumHeight: 0 }, fe = { color: "rgba(0, 0, 0, 0)", visible: false, fontSize: 48, fontFamily: L$1, fontStyle: "", text: "", horzAlign: "center", vertAlign: "center" };
function ve() {
  return { width: 0, height: 0, autoSize: false, layout: ue, crosshair: oe$1, grid: _e$1, overlayPriceScales: Object.assign({}, ce$1), leftPriceScale: Object.assign(Object.assign({}, ce$1), { visible: false }), rightPriceScale: Object.assign(Object.assign({}, ce$1), { visible: true }), timeScale: de, watermark: fe, localization: { locale: is ? navigator.language : "", dateFormat: "dd MMM 'yy" }, handleScroll: { mouseWheel: true, pressedMouseMove: true, horzTouchDrag: true, vertTouchDrag: true }, handleScale: { axisPressedMouseMove: { time: true, price: true }, axisDoubleClickReset: { time: true, price: true }, mouseWheel: true, pinch: true }, kineticScroll: { mouse: false, touch: true }, trackingMode: { exitMode: 1 } };
}
class pe {
  constructor(t2, i) {
    this.$b = t2, this.Ub = i;
  }
  applyOptions(t2) {
    this.$b.qt().zc(this.Ub, t2);
  }
  options() {
    return this.Li().W();
  }
  width() {
    return ut$1(this.Ub) ? this.$b.nb(this.Ub) : 0;
  }
  Li() {
    return b(this.$b.qt().Ec(this.Ub)).At;
  }
}
function me(t2, i, n2) {
  const s = Ls(t2, ["time", "originalTime"]), e3 = Object.assign({ time: i }, s);
  return void 0 !== n2 && (e3.originalTime = n2), e3;
}
const be = { color: "#FF0000", price: 0, lineStyle: 2, lineWidth: 1, lineVisible: true, axisLabelVisible: true, title: "", axisLabelColor: "", axisLabelTextColor: "" };
class we {
  constructor(t2) {
    this.Bh = t2;
  }
  applyOptions(t2) {
    this.Bh.Nh(t2);
  }
  options() {
    return this.Bh.W();
  }
  qb() {
    return this.Bh;
  }
}
class ge {
  constructor(t2, i, n2, s, e3) {
    this.Yb = new R(), this.Es = t2, this.Xb = i, this.Kb = n2, this.N_ = e3, this.Zb = s;
  }
  S() {
    this.Yb.S();
  }
  priceFormatter() {
    return this.Es.ca();
  }
  priceToCoordinate(t2) {
    const i = this.Es.Pt();
    return null === i ? null : this.Es.At().Ot(t2, i.Vt);
  }
  coordinateToPrice(t2) {
    const i = this.Es.Pt();
    return null === i ? null : this.Es.At().pn(t2, i.Vt);
  }
  barsInLogicalRange(t2) {
    if (null === t2)
      return null;
    const i = new yn$1(new xn$1(t2.from, t2.to)).iu(), n2 = this.Es.In();
    if (n2.Fi())
      return null;
    const s = n2.nl(i.Os(), 1), e3 = n2.nl(i.di(), -1), r2 = b(n2.Qh()), h2 = b(n2.Bn());
    if (null !== s && null !== e3 && s.se > e3.se)
      return { barsBefore: t2.from - r2, barsAfter: h2 - t2.to };
    const l2 = { barsBefore: null === s || s.se === r2 ? t2.from - r2 : s.se - r2, barsAfter: null === e3 || e3.se === h2 ? h2 - t2.to : h2 - e3.se };
    return null !== s && null !== e3 && (l2.from = s.bb, l2.to = e3.bb), l2;
  }
  setData(t2) {
    this.N_, this.Es.Xh(), this.Xb.Gb(this.Es, t2), this.Jb("full");
  }
  update(t2) {
    this.Es.Xh(), this.Xb.Qb(this.Es, t2), this.Jb("update");
  }
  dataByIndex(t2, i) {
    const n2 = this.Es.In().nl(t2, i);
    if (null === n2)
      return null;
    return le(this.seriesType())(n2);
  }
  data() {
    const t2 = le(this.seriesType());
    return this.Es.In().ie().map((i) => t2(i));
  }
  subscribeDataChanged(t2) {
    this.Yb.l(t2);
  }
  unsubscribeDataChanged(t2) {
    this.Yb.v(t2);
  }
  setMarkers(t2) {
    this.N_;
    const i = t2.map((t3) => me(t3, this.N_.convertHorzItemToInternal(t3.time), t3.time));
    this.Es.Zl(i);
  }
  markers() {
    return this.Es.Gl().map((t2) => me(t2, t2.originalTime, void 0));
  }
  applyOptions(t2) {
    this.Es.Nh(t2);
  }
  options() {
    return I(this.Es.W());
  }
  priceScale() {
    return this.Kb.priceScale(this.Es.At().xa());
  }
  createPriceLine(t2) {
    const i = D$1(I(be), t2), n2 = this.Es.Jl(i);
    return new we(n2);
  }
  removePriceLine(t2) {
    this.Es.Ql(t2.qb());
  }
  seriesType() {
    return this.Es.Xh();
  }
  attachPrimitive(t2) {
    this.Es.ba(t2), t2.attached && t2.attached({ chart: this.Zb, series: this, requestUpdate: () => this.Es.qt().$l() });
  }
  detachPrimitive(t2) {
    this.Es.wa(t2), t2.detached && t2.detached();
  }
  Jb(t2) {
    this.Yb.M() && this.Yb.m(t2);
  }
}
let Me$1 = class Me {
  constructor(t2, i, n2) {
    this.tw = new R(), this.uu = new R(), this._m = new R(), this.Ui = t2, this.wl = t2.yt(), this.$m = i, this.wl.Ku().l(this.iw.bind(this)), this.wl.Zu().l(this.nw.bind(this)), this.$m.gm().l(this.sw.bind(this)), this.N_ = n2;
  }
  S() {
    this.wl.Ku().p(this), this.wl.Zu().p(this), this.$m.gm().p(this), this.tw.S(), this.uu.S(), this._m.S();
  }
  scrollPosition() {
    return this.wl.Eu();
  }
  scrollToPosition(t2, i) {
    i ? this.wl.qu(t2, 1e3) : this.Ui.Jn(t2);
  }
  scrollToRealTime() {
    this.wl.Uu();
  }
  getVisibleRange() {
    const t2 = this.wl.yu();
    return null === t2 ? null : { from: t2.from.originalTime, to: t2.to.originalTime };
  }
  setVisibleRange(t2) {
    const i = { from: this.N_.convertHorzItemToInternal(t2.from), to: this.N_.convertHorzItemToInternal(t2.to) }, n2 = this.wl.Ru(i);
    this.Ui.ld(n2);
  }
  getVisibleLogicalRange() {
    const t2 = this.wl.ku();
    return null === t2 ? null : { from: t2.Os(), to: t2.di() };
  }
  setVisibleLogicalRange(t2) {
    p$1(t2.from <= t2.to, "The from index cannot be after the to index."), this.Ui.ld(t2);
  }
  resetTimeScale() {
    this.Ui.Zn();
  }
  fitContent() {
    this.Ui.Qu();
  }
  logicalToCoordinate(t2) {
    const i = this.Ui.yt();
    return i.Fi() ? null : i.Et(t2);
  }
  coordinateToLogical(t2) {
    return this.wl.Fi() ? null : this.wl.Vu(t2);
  }
  timeToCoordinate(t2) {
    const i = this.N_.convertHorzItemToInternal(t2), n2 = this.wl.ya(i, false);
    return null === n2 ? null : this.wl.Et(n2);
  }
  coordinateToTime(t2) {
    const i = this.Ui.yt(), n2 = i.Vu(t2), s = i.qi(n2);
    return null === s ? null : s.originalTime;
  }
  width() {
    return this.$m.$p().width;
  }
  height() {
    return this.$m.$p().height;
  }
  subscribeVisibleTimeRangeChange(t2) {
    this.tw.l(t2);
  }
  unsubscribeVisibleTimeRangeChange(t2) {
    this.tw.v(t2);
  }
  subscribeVisibleLogicalRangeChange(t2) {
    this.uu.l(t2);
  }
  unsubscribeVisibleLogicalRangeChange(t2) {
    this.uu.v(t2);
  }
  subscribeSizeChange(t2) {
    this._m.l(t2);
  }
  unsubscribeSizeChange(t2) {
    this._m.v(t2);
  }
  applyOptions(t2) {
    this.wl.Nh(t2);
  }
  options() {
    return Object.assign(Object.assign({}, I(this.wl.W())), { barSpacing: this.wl.he() });
  }
  iw() {
    this.tw.M() && this.tw.m(this.getVisibleRange());
  }
  nw() {
    this.uu.M() && this.uu.m(this.getVisibleLogicalRange());
  }
  sw(t2) {
    this._m.m(t2.width, t2.height);
  }
};
function xe(t2) {
  if (void 0 === t2 || "custom" === t2.type)
    return;
  const i = t2;
  void 0 !== i.minMove && void 0 === i.precision && (i.precision = function(t3) {
    if (t3 >= 1)
      return 0;
    let i2 = 0;
    for (; i2 < 8; i2++) {
      const n2 = Math.round(t3);
      if (Math.abs(n2 - t3) < 1e-8)
        return i2;
      t3 *= 10;
    }
    return i2;
  }(i.minMove));
}
function Se(t2) {
  return function(t3) {
    if (B$1(t3.handleScale)) {
      const i2 = t3.handleScale;
      t3.handleScale = { axisDoubleClickReset: { time: i2, price: i2 }, axisPressedMouseMove: { time: i2, price: i2 }, mouseWheel: i2, pinch: i2 };
    } else if (void 0 !== t3.handleScale) {
      const { axisPressedMouseMove: i2, axisDoubleClickReset: n2 } = t3.handleScale;
      B$1(i2) && (t3.handleScale.axisPressedMouseMove = { time: i2, price: i2 }), B$1(n2) && (t3.handleScale.axisDoubleClickReset = { time: n2, price: n2 });
    }
    const i = t3.handleScroll;
    B$1(i) && (t3.handleScroll = { horzTouchDrag: i, vertTouchDrag: i, mouseWheel: i, pressedMouseMove: i });
  }(t2), t2;
}
let ke$1 = class ke {
  constructor(t2, i, n2) {
    this.ew = /* @__PURE__ */ new Map(), this.rw = /* @__PURE__ */ new Map(), this.hw = new R(), this.lw = new R(), this.aw = new R(), this.ow = new Js(i);
    const s = void 0 === n2 ? I(ve()) : D$1(I(ve()), Se(n2));
    this.N_ = i, this.$b = new zs(t2, s, i), this.$b.Fp().l((t3) => {
      this.hw.M() && this.hw.m(this._w(t3()));
    }, this), this.$b.Wp().l((t3) => {
      this.lw.M() && this.lw.m(this._w(t3()));
    }, this), this.$b.Wc().l((t3) => {
      this.aw.M() && this.aw.m(this._w(t3()));
    }, this);
    const e3 = this.$b.qt();
    this.uw = new Me$1(e3, this.$b.Zm(), this.N_);
  }
  remove() {
    this.$b.Fp().p(this), this.$b.Wp().p(this), this.$b.Wc().p(this), this.uw.S(), this.$b.S(), this.ew.clear(), this.rw.clear(), this.hw.S(), this.lw.S(), this.aw.S(), this.ow.S();
  }
  resize(t2, i, n2) {
    this.autoSizeActive() || this.$b.qm(t2, i, n2);
  }
  addCustomSeries(t2, i) {
    const n2 = w$1(t2), s = Object.assign(Object.assign({}, _$1), n2.defaultOptions());
    return this.cw("Custom", s, i, n2);
  }
  addAreaSeries(t2) {
    return this.cw("Area", l, t2);
  }
  addBaselineSeries(t2) {
    return this.cw("Baseline", a, t2);
  }
  addBarSeries(t2) {
    return this.cw("Bar", r, t2);
  }
  addCandlestickSeries(t2 = {}) {
    return function(t3) {
      void 0 !== t3.borderColor && (t3.borderUpColor = t3.borderColor, t3.borderDownColor = t3.borderColor), void 0 !== t3.wickColor && (t3.wickUpColor = t3.wickColor, t3.wickDownColor = t3.wickColor);
    }(t2), this.cw("Candlestick", e2, t2);
  }
  addHistogramSeries(t2) {
    return this.cw("Histogram", o, t2);
  }
  addLineSeries(t2) {
    return this.cw("Line", h$1, t2);
  }
  removeSeries(t2) {
    const i = m$1(this.ew.get(t2)), n2 = this.ow.hd(i);
    this.$b.qt().hd(i), this.dw(n2), this.ew.delete(t2), this.rw.delete(i);
  }
  Gb(t2, i) {
    this.dw(this.ow.Ab(t2, i));
  }
  Qb(t2, i) {
    this.dw(this.ow.Eb(t2, i));
  }
  subscribeClick(t2) {
    this.hw.l(t2);
  }
  unsubscribeClick(t2) {
    this.hw.v(t2);
  }
  subscribeCrosshairMove(t2) {
    this.aw.l(t2);
  }
  unsubscribeCrosshairMove(t2) {
    this.aw.v(t2);
  }
  subscribeDblClick(t2) {
    this.lw.l(t2);
  }
  unsubscribeDblClick(t2) {
    this.lw.v(t2);
  }
  priceScale(t2) {
    return new pe(this.$b, t2);
  }
  timeScale() {
    return this.uw;
  }
  applyOptions(t2) {
    this.$b.Nh(Se(t2));
  }
  options() {
    return this.$b.W();
  }
  takeScreenshot() {
    return this.$b.tb();
  }
  autoSizeActive() {
    return this.$b.rb();
  }
  chartElement() {
    return this.$b.hb();
  }
  paneSize() {
    const t2 = this.$b.ab();
    return { height: t2.height, width: t2.width };
  }
  setCrosshairPosition(t2, i, n2) {
    const s = this.ew.get(n2);
    if (void 0 === s)
      return;
    const e3 = this.$b.qt().cr(s);
    null !== e3 && this.$b.qt().Qc(t2, i, e3);
  }
  clearCrosshairPosition() {
    this.$b.qt().td(true);
  }
  cw(t2, i, n2 = {}, s) {
    xe(n2.priceFormat);
    const e3 = D$1(I(u), I(i), n2), r2 = this.$b.qt().ed(t2, e3, s), h2 = new ge(r2, this, this, this, this.N_);
    return this.ew.set(h2, r2), this.rw.set(r2, h2), h2;
  }
  dw(t2) {
    const i = this.$b.qt();
    i.nd(t2.yt.Au, t2.yt.jb, t2.yt.Hb), t2.Fb.forEach((t3, i2) => i2.it(t3.He, t3.Wb)), i.Iu();
  }
  fw(t2) {
    return m$1(this.rw.get(t2));
  }
  _w(t2) {
    const i = /* @__PURE__ */ new Map();
    t2.Mb.forEach((t3, n3) => {
      const s = n3.Xh(), e3 = le(s)(t3);
      if ("Custom" !== s)
        p$1(function(t4) {
          return void 0 !== t4.open || void 0 !== t4.value;
        }(e3));
      else {
        const t4 = n3.Ma();
        p$1(!t4 || false === t4(e3));
      }
      i.set(this.fw(n3), e3);
    });
    const n2 = void 0 === t2.gb ? void 0 : this.fw(t2.gb);
    return { time: t2.bb, logical: t2.se, point: t2.wb, hoveredSeries: n2, hoveredObjectId: t2.xb, seriesData: i, sourceEvent: t2.Sb };
  }
};
function ye(t2, i, n2) {
  let s;
  if (V$1(t2)) {
    const i2 = document.getElementById(t2);
    p$1(null !== i2, `Cannot find element in DOM with id=${t2}`), s = i2;
  } else
    s = t2;
  const e3 = new ke$1(s, i, n2);
  return i.setOptions(e3.options()), e3;
}
function Ce$1(t2, i) {
  return ye(t2, new ts(), ts.Td(i));
}
Object.assign(Object.assign({}, u), _$1);
const skeleton = "_skeleton_13p4i_1";
const style$r = {
  skeleton,
  "skeleton-loading": "_skeleton-loading_13p4i_1"
};
const Skeleton = ({
  fontSize,
  minWidth = "100%"
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$r.skeleton, style: { fontSize, minWidth } });
};
function formatNumber(amount2, maxDigits) {
  let formatted = amount2.toFixed(maxDigits);
  let position2 = formatted.indexOf(".") - 3;
  const start = formatted[0] === "-" ? 1 : 0;
  while (position2 > start) {
    formatted = formatted.slice(0, position2) + "'" + formatted.slice(position2);
    position2 -= 3;
  }
  return formatted;
}
const chart = "_chart_1bo3n_1";
const invisible = "_invisible_1bo3n_7";
const chartUpdatingMessage = "_chartUpdatingMessage_1bo3n_11";
const summary$1 = "_summary_1bo3n_28";
const filters = "_filters_1bo3n_35";
const filterActive = "_filterActive_1bo3n_87";
const arrow = "_arrow_1bo3n_104";
const up = "_up_1bo3n_109";
const down = "_down_1bo3n_113";
const totalValue = "_totalValue_1bo3n_117";
const totalUnit = "_totalUnit_1bo3n_121";
const diffValue = "_diffValue_1bo3n_128";
const diffUnit = "_diffUnit_1bo3n_132";
const chartCanvas = "_chartCanvas_1bo3n_137";
const tooltip = "_tooltip_1bo3n_149";
const toolTipValue = "_toolTipValue_1bo3n_164";
const toolTipUnit = "_toolTipUnit_1bo3n_170";
const toolTipTime = "_toolTipTime_1bo3n_176";
const styles$i = {
  chart,
  invisible,
  chartUpdatingMessage,
  summary: summary$1,
  filters,
  filterActive,
  arrow,
  up,
  down,
  totalValue,
  totalUnit,
  diffValue,
  diffUnit,
  chartCanvas,
  tooltip,
  toolTipValue,
  toolTipUnit,
  toolTipTime
};
const Filters = ({
  display,
  disableFilters,
  disableWeeklyFilters,
  onDisplayWeek,
  onDisplayMonth,
  onDisplayYear,
  onDisplayAll
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.filters, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "week" ? styles$i.filterActive : void 0,
        disabled: disableFilters || disableWeeklyFilters,
        onClick: onDisplayWeek,
        children: t2("chart.filter.week")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "month" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayMonth,
        children: t2("chart.filter.month")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "year" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayYear,
        children: t2("chart.filter.year")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: display === "all" ? styles$i.filterActive : void 0,
        disabled: disableFilters,
        onClick: onDisplayAll,
        children: t2("chart.filter.all")
      }
    )
  ] });
};
let darkmode;
const Darkmode = () => {
  const { isDarkMode } = useDarkmode();
  darkmode = isDarkMode;
  return null;
};
const getDarkmode = () => darkmode;
class Chart extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.ref = reactExports.createRef();
    this.refToolTip = reactExports.createRef();
    this.height = 300;
    this.mobileHeight = 150;
    this.state = {
      display: "all",
      source: "daily",
      toolTipVisible: false,
      toolTipValue: void 0,
      toolTipTop: 0,
      toolTipLeft: 0,
      toolTipTime: 0,
      isMobile: false
    };
    this.hasData = () => {
      return this.props.data.chartDataDaily && this.props.data.chartDataDaily.length > 0;
    };
    this.hasHourlyData = () => {
      return this.props.data.chartDataHourly && this.props.data.chartDataHourly.length > 0;
    };
    this.checkIfMobile = () => {
      this.setState({ isMobile: window.innerWidth <= 640 });
    };
    this.createChart = () => {
      const { data: { chartDataMissing } } = this.props;
      const darkmode2 = getDarkmode();
      if (this.ref.current && this.hasData() && !chartDataMissing) {
        if (!this.chart) {
          const chartWidth = !this.state.isMobile ? this.ref.current.offsetWidth : document.body.clientWidth;
          const chartHeight = !this.state.isMobile ? this.height : this.mobileHeight;
          this.chart = Ce$1(this.ref.current, {
            width: chartWidth,
            height: chartHeight,
            handleScroll: false,
            handleScale: false,
            crosshair: {
              vertLine: {
                visible: false,
                labelVisible: false
              },
              horzLine: {
                visible: false,
                labelVisible: false
              },
              mode: 1
            },
            grid: {
              vertLines: {
                visible: false
              },
              horzLines: {
                color: darkmode2 ? "#333333" : "#dedede",
                style: d.Solid,
                visible: !this.state.isMobile
              }
            },
            layout: {
              background: {
                type: Bn$1.Solid,
                color: darkmode2 ? "#1D1D1B" : "#F5F5F5"
              },
              fontSize: 11,
              fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", "Ubuntu", "Roboto", "Oxygen", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif',
              textColor: darkmode2 ? "#F5F5F5" : "#1D1D1B"
            },
            leftPriceScale: {
              borderVisible: false,
              ticksVisible: false,
              visible: this.props.hideAmounts ? false : !this.state.isMobile,
              entireTextOnly: true
            },
            localization: {
              locale: this.props.i18n.language
            },
            rightPriceScale: {
              visible: false,
              ticksVisible: false
            },
            timeScale: {
              borderVisible: false,
              timeVisible: false,
              visible: !this.state.isMobile
            },
            trackingMode: {
              exitMode: 0
            }
          });
        }
        this.lineSeries = this.chart.addAreaSeries({
          priceLineVisible: false,
          lastValueVisible: false,
          priceFormat: {
            type: "volume"
          },
          topColor: darkmode2 ? "#5E94BF" : "#DFF1FF",
          bottomColor: darkmode2 ? "#1D1D1B" : "#F5F5F5",
          lineColor: "rgba(94, 148, 192, 1)",
          crosshairMarkerRadius: 6
        });
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.timeScale().subscribeVisibleLogicalRangeChange(this.calculateChange);
        this.chart.subscribeCrosshairMove(this.handleCrosshair);
        this.chart.timeScale().fitContent();
        window.addEventListener("resize", this.onResize);
        setTimeout(() => {
          var _a;
          return (_a = this.ref.current) == null ? void 0 : _a.classList.remove(styles$i.invisible);
        }, 200);
      }
    };
    this.onResize = () => {
      this.checkIfMobile();
      if (this.resizeTimerID) {
        clearTimeout(this.resizeTimerID);
      }
      this.resizeTimerID = setTimeout(() => {
        if (!this.chart || !this.ref.current) {
          return;
        }
        const chartWidth = !this.state.isMobile ? this.ref.current.offsetWidth : document.body.clientWidth;
        const chartHeight = !this.state.isMobile ? this.height : this.mobileHeight;
        this.chart.resize(chartWidth, chartHeight);
        this.chart.applyOptions({
          grid: {
            horzLines: {
              visible: !this.state.isMobile
            }
          },
          timeScale: {
            visible: !this.state.isMobile
          },
          leftPriceScale: {
            visible: this.props.hideAmounts ? false : !this.state.isMobile
          }
        });
      }, 200);
    };
    this.getUTCRange = () => {
      const now = /* @__PURE__ */ new Date();
      const utcYear = now.getUTCFullYear();
      const utcMonth = now.getUTCMonth();
      const utcDate = now.getUTCDate();
      const utcHours = now.getUTCHours();
      const to = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      const from2 = new Date(Date.UTC(utcYear, utcMonth, utcDate, utcHours, 0, 0, 0));
      return {
        utcYear,
        utcMonth,
        utcDate,
        to,
        from: from2
      };
    };
    this.displayWeek = () => {
      if (this.state.source !== "hourly" && this.lineSeries && this.props.data.chartDataHourly && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataHourly || []);
        this.setFormattedData(this.props.data.chartDataHourly || []);
        this.chart.applyOptions({ timeScale: { timeVisible: true } });
      }
      this.setState(
        { display: "week", source: "hourly" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcDate, from: from2, to } = this.getUTCRange();
          from2.setUTCDate(utcDate - 7);
          this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayMonth = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily || []);
        this.setFormattedData(this.props.data.chartDataDaily || []);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "month", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcMonth, from: from2, to } = this.getUTCRange();
          from2.setUTCMonth(utcMonth - 1);
          this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayYear = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "year", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          const { utcYear, from: from2, to } = this.getUTCRange();
          from2.setUTCFullYear(utcYear - 1);
          this.chart && this.chart.timeScale().setVisibleRange({
            from: from2.getTime() / 1e3,
            to: to.getTime() / 1e3
          });
        }
      );
    };
    this.displayAll = () => {
      if (this.state.source !== "daily" && this.lineSeries && this.props.data.chartDataDaily && this.chart) {
        this.lineSeries.setData(this.props.data.chartDataDaily);
        this.setFormattedData(this.props.data.chartDataDaily);
        this.chart.applyOptions({ timeScale: { timeVisible: false } });
      }
      this.setState(
        { display: "all", source: "daily" },
        () => {
          if (!this.chart) {
            return;
          }
          this.chart.timeScale().fitContent();
        }
      );
    };
    this.calculateChange = () => {
      const data = this.props.data[this.state.source === "daily" ? "chartDataDaily" : "chartDataHourly"];
      if (!data || !this.chart || !this.lineSeries) {
        return;
      }
      const logicalrange = this.chart.timeScale().getVisibleLogicalRange();
      const visiblerange = this.lineSeries.barsInLogicalRange(logicalrange);
      if (!visiblerange) {
        return;
      }
      const rangeFrom = Math.max(Math.floor(visiblerange.barsBefore), 0);
      if (!data[rangeFrom]) {
        this.setState({ difference: 0, diffSince: "" });
        return;
      }
      const valueFrom = data[rangeFrom].value === 0 ? data[rangeFrom + 1].value : data[rangeFrom].value;
      const valueTo = this.props.data.chartTotal;
      const valueDiff = valueTo ? valueTo - valueFrom : 0;
      this.setState({
        difference: valueDiff / valueFrom * 100,
        diffSince: `${data[rangeFrom].formattedValue} (${this.renderDate(Number(data[rangeFrom].time) * 1e3)})`
      });
    };
    this.handleCrosshair = ({ point, time: time2, seriesData }) => {
      if (!this.refToolTip.current) {
        return;
      }
      const tooltip2 = this.refToolTip.current;
      const parent = tooltip2.parentNode;
      if (!this.lineSeries || !point || !time2 || point.x < 0 || point.x > parent.clientWidth || point.y < 0 || point.y > parent.clientHeight) {
        this.setState({
          toolTipVisible: false
        });
        return;
      }
      const price = seriesData.get(this.lineSeries);
      if (!price) {
        return;
      }
      const coordinate = this.lineSeries.priceToCoordinate(price.value);
      if (!coordinate) {
        return;
      }
      const coordinateY = coordinate - tooltip2.clientHeight > 0 ? coordinate - tooltip2.clientHeight : Math.max(
        0,
        Math.min(
          parent.clientHeight - tooltip2.clientHeight,
          coordinate + 70
        )
      );
      const toolTipTop = Math.floor(Math.max(coordinateY, 0));
      const toolTipLeft = Math.floor(Math.max(40, Math.min(parent.clientWidth - 140, point.x + 40 - 70)));
      this.setState({
        toolTipVisible: true,
        toolTipValue: this.formattedData ? this.formattedData[time2] : "",
        toolTipTop,
        toolTipLeft,
        toolTipTime: time2
      });
    };
    this.renderDate = (date2) => {
      return new Date(date2).toLocaleString(
        this.props.i18n.language,
        {
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          ...this.state.source === "hourly" ? {
            hour: "2-digit",
            minute: "2-digit"
          } : null
        }
      );
    };
  }
  componentDidMount() {
    this.checkIfMobile();
    this.createChart();
  }
  componentWillUnmount() {
    window.removeEventListener("resize", this.onResize);
    if (this.chart) {
      this.chart.timeScale().unsubscribeVisibleLogicalRangeChange(this.calculateChange);
      this.chart.unsubscribeCrosshairMove(this.handleCrosshair);
    }
  }
  componentDidUpdate(prev2) {
    var _a;
    const { chartDataDaily, chartDataHourly } = this.props.data;
    if (!this.chart) {
      this.createChart();
    }
    if (this.lineSeries && prev2.data.chartDataDaily && prev2.data.chartDataHourly && chartDataDaily && chartDataHourly && (prev2.data.chartDataDaily.length !== chartDataDaily.length || prev2.data.chartDataHourly.length !== chartDataHourly.length)) {
      const data = this.state.source === "hourly" ? chartDataHourly : chartDataDaily;
      this.lineSeries.setData(data);
      this.setFormattedData(data);
    }
    if (prev2.hideAmounts !== this.props.hideAmounts) {
      (_a = this.chart) == null ? void 0 : _a.applyOptions({
        leftPriceScale: {
          visible: this.props.hideAmounts ? false : !this.state.isMobile
        }
      });
    }
  }
  setFormattedData(data) {
    this.formattedData = {};
    data.forEach((entry2) => {
      if (this.formattedData) {
        this.formattedData[entry2.time] = entry2.formattedValue;
      }
    });
  }
  render() {
    const {
      t: t2,
      data: {
        lastTimestamp,
        chartDataMissing,
        chartFiat,
        chartIsUpToDate,
        chartTotal,
        formattedChartTotal
      },
      noDataPlaceholder,
      hideAmounts
    } = this.props;
    const {
      difference,
      diffSince,
      display,
      toolTipVisible,
      toolTipValue: toolTipValue2,
      toolTipTop,
      toolTipLeft,
      toolTipTime: toolTipTime2,
      isMobile
    } = this.state;
    const hasDifference = difference && Number.isFinite(difference);
    const hasData = this.hasData();
    const hasHourlyData = this.hasHourlyData();
    const disableFilters = !hasData || chartDataMissing;
    const disableWeeklyFilters = !hasHourlyData || chartDataMissing;
    const showMobileTotalValue = toolTipVisible && !!toolTipValue2 && isMobile;
    const chartFiltersProps = {
      display,
      disableFilters,
      disableWeeklyFilters,
      onDisplayWeek: this.displayWeek,
      onDisplayMonth: this.displayMonth,
      onDisplayYear: this.displayYear,
      onDisplayAll: this.displayAll
    };
    const chartHeight = `${!isMobile ? this.height : this.mobileHeight}px`;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("section", { className: styles$i.chart, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.summary, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.totalValue, children: [
            formattedChartTotal !== null ? (
              // remove trailing zeroes for BTC fiat total
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: !showMobileTotalValue ? formattedChartTotal : toolTipValue2, unit: chartFiat, removeBtcTrailingZeroes: true })
            ) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { minWidth: "220px" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.totalUnit, children: chartTotal !== null && chartFiat })
          ] }),
          !showMobileTotalValue ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: !hasDifference ? "" : styles$i[difference < 0 ? "down" : "up"], title: diffSince, children: hasDifference ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.arrow, children: difference < 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowDown, {}) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles$i.diffValue, children: [
              hideAmounts ? "***" : formatNumber(difference, 2),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.diffUnit, children: "%" })
            ] })
          ] }) : null }) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.diffValue, children: this.renderDate(toolTipTime2 * 1e3) })
        ] }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$i.chartCanvas, style: { minHeight: chartHeight }, children: [
        chartDataMissing ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.chartUpdatingMessage, style: { height: chartHeight }, children: t2("chart.dataMissing") }) : hasData ? !chartIsUpToDate && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$i.chartUpdatingMessage, children: t2("chart.dataOldTimestamp", { time: new Date(lastTimestamp).toLocaleString(this.props.i18n.language) }) }) : noDataPlaceholder,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: this.ref, className: styles$i.invisible }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "span",
          {
            ref: this.refToolTip,
            className: styles$i.tooltip,
            style: { left: toolTipLeft, top: toolTipTop },
            hidden: !toolTipVisible || isMobile,
            children: toolTipValue2 !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: styles$i.toolTipValue, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: toolTipValue2, unit: chartFiat }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.toolTipUnit, children: chartFiat })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: styles$i.toolTipTime, children: this.renderDate(toolTipTime2 * 1e3) })
            ] }) : null
          }
        )
      ] }),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(Filters, { ...chartFiltersProps })
    ] });
  }
}
Chart.defaultProps = {
  data: {
    chartDataMissing: true,
    chartDataDaily: [],
    chartDataHourly: [],
    chartFiat: "USD",
    chartTotal: null,
    formattedChartTotal: null,
    chartIsUpToDate: false,
    lastTimestamp: 0
  },
  hideAmounts: false
};
const HOC$2 = translate()(Chart);
const ArrowUp = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
);
const ArrowDown = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
);
const spinnerContainer$1 = "_spinnerContainer_1akm7_1";
const spinner$1 = "_spinner_1akm7_1";
const changeContent$2 = "_changeContent_1akm7_1";
const style$q = {
  spinnerContainer: spinnerContainer$1,
  spinner: spinner$1,
  changeContent: changeContent$2
};
function AsciiSpinner() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$q.spinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$q.spinner }) });
}
const accountName$4 = "_accountName_i87d0_1";
const balanceTable = "_balanceTable_i87d0_10";
const coincode = "_coincode_i87d0_13";
const coinheader = "_coinheader_i87d0_18";
const dataMissing = "_dataMissing_i87d0_29";
const openFileText = "_openFileText_i87d0_33";
const table = "_table_i87d0_39";
const noAccount = "_noAccount_i87d0_54";
const clickable = "_clickable_i87d0_89";
const summaryTableBalance = "_summaryTableBalance_i87d0_93";
const coinName = "_coinName_i87d0_103";
const coinUnit = "_coinUnit_i87d0_113";
const syncText$1 = "_syncText_i87d0_117";
const showOnTableView = "_showOnTableView_i87d0_121";
const showInCollapsedView = "_showInCollapsedView_i87d0_125";
const subTotal = "_subTotal_i87d0_182";
const style$p = {
  accountName: accountName$4,
  balanceTable,
  coincode,
  coinheader,
  dataMissing,
  openFileText,
  table,
  noAccount,
  clickable,
  summaryTableBalance,
  coinName,
  coinUnit,
  syncText: syncText$1,
  showOnTableView,
  showInCollapsedView,
  subTotal
};
function BalanceRow({ code, name, coinCode, balance: balance2 }) {
  const { t: t2 } = useTranslation();
  const syncStatus2 = useSubscribe(syncAddressesCount(code));
  const nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx(
    "td",
    {
      className: style$p.clickable,
      "data-label": t2("accountSummary.name"),
      onClick: () => route(`/account/${code}`),
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.coinName, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$p.coincode, coinCode, active: true, alt: coinCode }),
        name
      ] })
    }
  );
  if (balance2) {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
      nameCol,
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$p.summaryTableBalance, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.available.amount, unit: balance2.available.unit }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: balance2.available.unit })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2.available, noAction: true }) })
    ] }, `${code}_balance`);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 2, className: style$p.syncText, children: [
      t2("account.syncedAddressesCount", {
        count: syncStatus2 == null ? void 0 : syncStatus2.toString(),
        defaultValue: 0
      }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {})
    ] })
  ] }, `${code}_syncing`);
}
function SubTotalRow({ coinCode, coinName: coinName2, balance: balance2 }) {
  const { t: t2 } = useTranslation();
  const nameCol = /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.total"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.coinName, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { className: style$p.coincode, coinCode, active: true, alt: coinCode }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$p.showOnTableView, children: t2("accountSummary.subtotalWithCoinName", { coinName: coinName2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: style$p.showInCollapsedView, children: coinName2 })
  ] }) });
  if (!balance2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: style$p.subTotal, children: [
    nameCol,
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.balance"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$p.summaryTableBalance, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: balance2.amount, unit: balance2.unit }) }),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: balance2.unit })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { "data-label": t2("accountSummary.fiatBalance"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: balance2, noAction: true }) }) })
  ] }, `${coinCode}_subtotal`);
}
function TotalBalance({ total: total2, fiatUnit }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: total2, unit: fiatUnit }) }),
    " ",
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$p.coinUnit, children: fiatUnit })
  ] });
}
function SummaryBalance({
  accounts,
  connected,
  keystoreName,
  totalBalancePerCoin,
  totalBalance,
  balances,
  keystoreDisambiguatorName
}) {
  const { t: t2 } = useTranslation();
  const getAccountsPerCoin = () => {
    return accounts.reduce((accountPerCoin, account2) => {
      accountPerCoin[account2.coinCode] ? accountPerCoin[account2.coinCode].push(account2) : accountPerCoin[account2.coinCode] = [account2];
      return accountPerCoin;
    }, {});
  };
  const accountsPerCoin = getAccountsPerCoin();
  const coins2 = Object.keys(accountsPerCoin);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$p.accountName, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        keystoreName,
        " ",
        keystoreDisambiguatorName && `(${keystoreDisambiguatorName})`
      ] }),
      connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Badge,
        {
          icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
          type: "success",
          children: t2("device.keystoreConnected")
        }
      ) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$p.balanceTable, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: style$p.table, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("colgroup", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "33%" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("col", { width: "*" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.name") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.balance") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: t2("accountSummary.fiatBalance") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tbody", { children: accounts.length > 0 ? coins2.map((coinCode) => {
        const balanceRows = accountsPerCoin[coinCode].map(
          (account2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            BalanceRow,
            {
              code: account2.code,
              name: account2.name,
              coinCode: account2.coinCode,
              balance: balances && balances[account2.code]
            },
            account2.code
          )
        );
        if ((balanceRows == null ? void 0 : balanceRows.length) > 1) {
          const account2 = accountsPerCoin[coinCode][0];
          balanceRows.push(
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              SubTotalRow,
              {
                coinCode: account2.coinCode,
                coinName: account2.coinName,
                balance: totalBalancePerCoin && totalBalancePerCoin[coinCode]
              },
              account2.coinCode
            )
          );
        }
        return balanceRows;
      }) : /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 3, className: style$p.noAccount, children: t2("accountSummary.noAccount") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("tfoot", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("th", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("accountSummary.total") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("td", { colSpan: 2, children: totalBalance ? /* @__PURE__ */ jsxRuntimeExports.jsx(TotalBalance, { total: totalBalance.total, fiatUnit: totalBalance.fiatUnit }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
      ] }) })
    ] }) })
  ] });
}
const container$f = "_container_1mptn_1";
const main = "_main_1mptn_8";
const walletConnect$1 = "_walletConnect_1mptn_17";
const styles$h = {
  container: container$f,
  main,
  walletConnect: walletConnect$1
};
const BuyReceiveCTA = ({ code, unit: unit2, balanceList, exchangeBuySupported = true, account: account2 }) => {
  const formattedUnit = isBitcoinCoin(unit2) ? "BTC" : unit2;
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  const onBuyCTA = () => route(code ? `/buy/info/${code}` : "/buy/info");
  const onWalletConnect = () => route(`/account/${code}/wallet-connect/dashboard`);
  const onReceiveCTA = () => {
    if (balanceList) {
      if (balanceList.length > 1) {
        route("accounts/select-receive");
        return;
      }
      route(`/account/${code}/receive`);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$h.main}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.looksEmpty") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("accountInfo.buyCTA.information.start") }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$h.container, children: [
      balanceList && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onReceiveCTA, children: formattedUnit ? t2("receive.title", { accountName: formattedUnit }) : t2("receive.title", { accountName: t2("buy.info.crypto") }) }),
      exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onBuyCTA, children: formattedUnit ? t2("accountInfo.buyCTA.buy", { unit: formattedUnit }) : t2("accountInfo.buyCTA.buyCrypto") }),
      account2 && isEthereumBased(account2.coinCode) && !account2.isToken && /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onWalletConnect, className: styles$h.walletConnect, children: isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 28, height: 28 }),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
      ] }) })
    ] })
  ] });
};
const AddBuyReceiveOnEmptyBalances = ({ balances, accounts }) => {
  const mounted = useMountedRef();
  const [supportedAccounts, setSupportedAccounts] = reactExports.useState();
  const onlyHasOneActiveAccount = accounts.length === 1;
  reactExports.useEffect(() => {
    if (mounted.current) {
      getExchangeSupportedAccounts(accounts).then((supportedAccounts2) => {
        if (mounted.current) {
          setSupportedAccounts(supportedAccounts2);
        }
      }).catch(console.error);
    }
  }, [accounts, mounted]);
  if (balances === void 0 || supportedAccounts === void 0) {
    return null;
  }
  const balanceList = accounts.map((account2) => balances[account2.code]).filter((balance2) => !!balance2);
  if (balanceList.some((entry2) => entry2.hasAvailable)) {
    return null;
  }
  if (balanceList.map((entry2) => entry2.available.unit).every(isBitcoinCoin)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { code: onlyHasOneActiveAccount ? accounts[0].code : void 0, unit: "BTC", balanceList });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BuyReceiveCTA, { exchangeBuySupported: supportedAccounts.length > 0, balanceList });
};
function AccountsSummary({
  accounts,
  devices
}) {
  const { t: t2 } = useTranslation();
  const summaryReqTimerID = reactExports.useRef();
  const mounted = useMountedRef();
  const { hideAmounts } = reactExports.useContext(AppContext);
  const accountsByKeystore = getAccountsByKeystore(accounts);
  const [summaryData, setSummaryData] = reactExports.useState();
  const [balancePerCoin, setBalancePerCoin] = reactExports.useState();
  const [accountsTotalBalance, setAccountsTotalBalance] = reactExports.useState();
  const [balances, setBalances] = reactExports.useState();
  const hasCard = useSDCard(devices);
  const getAccountSummary = reactExports.useCallback(async () => {
    if (summaryReqTimerID.current) {
      window.clearTimeout(summaryReqTimerID.current);
    }
    try {
      const summaryData2 = await getSummary();
      if (!mounted.current) {
        return;
      }
      setSummaryData(summaryData2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]);
  const getAccountsBalance$1 = reactExports.useCallback(async () => {
    try {
      const balance2 = await getAccountsBalance();
      if (!mounted.current) {
        return;
      }
      setBalancePerCoin(balance2);
    } catch (err) {
      console.error(err);
    }
  }, [mounted]);
  const getAccountsTotalBalance$1 = reactExports.useCallback(async () => {
    const totalBalance = await getAccountsTotalBalance();
    if (!mounted.current) {
      return;
    }
    if (totalBalance.success) {
      setAccountsTotalBalance(totalBalance.totalBalance);
    } else {
      if (totalBalance.errorCode !== "ratesNotAvailable") {
        console.error(totalBalance.errorMessage);
      } else {
        console.log("rates not available");
      }
    }
  }, [mounted]);
  const onStatusChanged = reactExports.useCallback(async (code) => {
    if (!mounted.current) {
      return;
    }
    const status2 = await getStatus$2(code);
    if (status2.disabled || !mounted.current) {
      return;
    }
    if (!status2.synced) {
      return init(code);
    }
    const balance2 = await getBalance(code);
    if (!mounted.current) {
      return;
    }
    setBalances((prevBalances) => ({
      ...prevBalances,
      [code]: balance2
    }));
  }, [mounted]);
  const update = reactExports.useCallback((code) => {
    if (mounted.current) {
      onStatusChanged(code);
      getAccountSummary();
    }
  }, [getAccountSummary, mounted, onStatusChanged]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      statusChanged$1(update),
      syncdone(update)
    ];
    getAccountSummary();
    getAccountsBalance$1();
    getAccountsTotalBalance$1();
    return () => unsubscribe(subscriptions2);
  }, [getAccountSummary, getAccountsBalance$1, getAccountsTotalBalance$1, update]);
  reactExports.useEffect(() => {
    const delay2 = !summaryData || summaryData.chartDataMissing ? 1e3 : 1e4;
    summaryReqTimerID.current = window.setTimeout(getAccountSummary, delay2);
    return () => {
      if (summaryReqTimerID.current) {
        window.clearTimeout(summaryReqTimerID.current);
      }
    };
  }, [summaryData, getAccountSummary]);
  reactExports.useEffect(() => {
    accounts.forEach((account2) => {
      onStatusChanged(account2.code);
    });
    getAccountsBalance$1();
  }, [onStatusChanged, getAccountsBalance$1, accounts]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("accountSummary.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(View, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          HOC$2,
          {
            hideAmounts,
            data: summaryData,
            noDataPlaceholder: accounts.length && accounts.length <= Object.keys(balances || {}).length ? /* @__PURE__ */ jsxRuntimeExports.jsx(AddBuyReceiveOnEmptyBalances, { accounts, balances }) : void 0
          }
        ),
        accountsByKeystore && accountsByKeystore.map(
          ({ keystore: keystore2, accounts: accounts2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            SummaryBalance,
            {
              keystoreDisambiguatorName: isAmbiguiousName(keystore2.name, accountsByKeystore) ? keystore2.rootFingerprint : void 0,
              connected: keystore2.connected,
              keystoreName: keystore2.name,
              accounts: accounts2,
              totalBalancePerCoin: balancePerCoin ? balancePerCoin[keystore2.rootFingerprint] : void 0,
              totalBalance: accountsTotalBalance ? accountsTotalBalance[keystore2.rootFingerprint] : void 0,
              balances
            },
            keystore2.rootFingerprint
          )
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSummaryDescription") }, "accountSummaryDescription"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: "www.coingecko.com",
          url: "https://www.coingecko.com/"
        },
        text: t2("guide.accountSummaryAmount.text"),
        title: t2("guide.accountSummaryAmount.title")
      } }, "accountSummaryAmount"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.trackingModePortfolioChart") }, "trackingModePortfolioChart")
    ] })
  ] });
}
const URL_CONSTANTS = {
  DOWNLOAD_LINK_GLOBAL: "https://bitbox.swiss/download/?source=bitboxapp",
  DOWNLOAD_LINK_DE: "https://bitbox.swiss/de/download/?source=bitboxapp",
  DOWNLOAD_LINK_ES: "https://bitbox.swiss/es/descargar/?source=bitboxapp"
};
const downloadLinkByLanguage = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return URL_CONSTANTS.DOWNLOAD_LINK_DE;
    case "es":
      return URL_CONSTANTS.DOWNLOAD_LINK_ES;
    default:
      return URL_CONSTANTS.DOWNLOAD_LINK_GLOBAL;
  }
};
const AppDownloadLink = ({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: t2("button.download") });
};
const AppDownloadButton = ({ ...props }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: downloadLinkByLanguage(), ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, children: t2("button.download") }) });
};
const AppUpgradeRequired = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        verticallyCentered: true,
        width: "840px",
        withBottomBar: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("device.appUpradeRequired") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadButton, {}) })
        ]
      }
    )
  ] });
};
const capsWarning = "_capsWarning_1xqma_1";
const style$o = {
  capsWarning
};
function PasswordInput(props) {
  const { seePlaintext, ...rest } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Input$2,
    {
      type: seePlaintext ? "text" : "password",
      ...rest
    }
  );
}
class PasswordSingleInputClass extends reactExports.Component {
  state = {
    password: "",
    seePlaintext: false,
    capsLock: false
  };
  password = reactExports.createRef();
  idPrefix = () => {
    return this.props.idPrefix || "";
  };
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a;
    if (this.props.pattern) {
      this.regex = new RegExp(this.props.pattern);
    }
    if (this.props.autoFocus && ((_a = this.password) == null ? void 0 : _a.current)) {
      this.password.current.focus();
    }
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  tryPaste = (event2) => {
    if (event2.target.type === "password") {
      event2.preventDefault();
      alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      }));
    }
  };
  clear = () => {
    this.setState({
      password: "",
      seePlaintext: false,
      capsLock: false
    });
  };
  validate = () => {
    if (this.regex && this.password.current && !this.password.current.validity.valid) {
      return this.props.onValidPassword(null);
    }
    if (this.state.password) {
      this.props.onValidPassword(this.state.password);
    } else {
      this.props.onValidPassword(null);
    }
  };
  handleFormChange = (event2) => {
    let value = event2.target.value;
    if (event2.target.type === "checkbox") {
      value = event2.target.checked;
    }
    const stateKey = event2.target.id.slice(this.idPrefix().length);
    this.setState({ [stateKey]: value }, this.validate);
  };
  handleCheckCaps = (event2) => {
    const capsLock = hasCaps(event2);
    if (capsLock !== null) {
      this.setState({ capsLock });
    }
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      showLabel
    } = this.props;
    const {
      password: password2,
      seePlaintext,
      capsLock
    } = this.state;
    const warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$o.capsWarning,
        title: t2("password.warning.caps"),
        children: "⇪"
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        autoFocus: true,
        disabled: disabled2,
        type: seePlaintext ? "text" : "password",
        pattern,
        title: title2,
        id: this.idPrefix() + "password",
        label: label2,
        placeholder,
        onInput: this.handleFormChange,
        onPaste: this.tryPaste,
        ref: this.password,
        value: password2,
        labelSection: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: this.idPrefix() + "seePlaintext",
            onChange: this.handleFormChange,
            checked: seePlaintext,
            label: t2("password.show", {
              label: showLabel || label2
            })
          }
        ),
        children: warning2
      }
    );
  }
}
const PasswordSingleInput = withTranslation(null, { withRef: true })(PasswordSingleInputClass);
class PasswordRepeatInputClass extends reactExports.Component {
  state = {
    password: "",
    passwordRepeat: "",
    seePlaintext: false,
    capsLock: false
  };
  password = reactExports.createRef();
  passwordRepeat = reactExports.createRef();
  idPrefix = () => {
    return this.props.idPrefix || "";
  };
  UNSAFE_componentWillMount() {
    window.addEventListener("keydown", this.handleCheckCaps);
  }
  componentDidMount() {
    var _a;
    if (this.props.pattern) {
      this.regex = new RegExp(this.props.pattern);
    }
    if (this.props.autoFocus && ((_a = this.password) == null ? void 0 : _a.current)) {
      this.password.current.focus();
    }
  }
  componentWillUnmount() {
    window.removeEventListener("keydown", this.handleCheckCaps);
  }
  tryPaste = (event2) => {
    if (event2.target.type === "password") {
      event2.preventDefault();
      alertUser(this.props.t("password.warning.paste", {
        label: this.props.label
      }));
    }
  };
  validate = () => {
    if (this.regex && this.password.current && this.passwordRepeat.current && (!this.password.current.validity.valid || !this.passwordRepeat.current.validity.valid)) {
      return this.props.onValidPassword(null);
    }
    if (this.state.password && this.state.password === this.state.passwordRepeat) {
      this.props.onValidPassword(this.state.password);
    } else {
      this.props.onValidPassword(null);
    }
  };
  handleFormChange = (event2) => {
    let value = event2.target.value;
    if (event2.target.type === "checkbox") {
      value = event2.target.checked;
    }
    const stateKey = event2.target.id.slice(this.idPrefix().length);
    this.setState({ [stateKey]: value }, this.validate);
  };
  handleCheckCaps = (event2) => {
    const capsLock = hasCaps(event2);
    if (capsLock != null) {
      this.setState({ capsLock });
    }
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      label: label2,
      placeholder,
      pattern,
      title: title2,
      repeatLabel,
      repeatPlaceholder,
      showLabel
    } = this.props;
    const {
      password: password2,
      passwordRepeat,
      seePlaintext,
      capsLock
    } = this.state;
    const warning2 = capsLock && !seePlaintext && /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        className: style$o.capsWarning,
        title: t2("password.warning.caps"),
        children: "⇪"
      }
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          autoFocus: true,
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "password",
          label: label2,
          placeholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: password2,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: password2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          disabled: disabled2,
          type: seePlaintext ? "text" : "password",
          pattern,
          title: title2,
          id: this.idPrefix() + "passwordRepeat",
          label: repeatLabel,
          placeholder: repeatPlaceholder,
          onInput: this.handleFormChange,
          onPaste: this.tryPaste,
          ref: this.password,
          value: passwordRepeat,
          children: warning2
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        MatchesPattern,
        {
          regex: this.regex,
          text: title2,
          value: passwordRepeat
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Field, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Checkbox,
        {
          id: this.idPrefix() + "seePlaintext",
          onChange: this.handleFormChange,
          checked: seePlaintext,
          label: t2("password.show", {
            label: showLabel || label2
          })
        }
      ) })
    ] });
  }
}
const PasswordRepeatInput = withTranslation(null, { withRef: true })(PasswordRepeatInputClass);
function MatchesPattern({ regex, value = "", text: text2 }) {
  if (!regex || !value.length || regex.test(value)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { color: "var(--color-error)" }, children: text2 });
}
const excludeKeys = /^(Shift|Alt|Backspace|CapsLock|Tab)$/i;
function hasCaps({ key }) {
  if (key.length > 1 || key.toUpperCase() === key.toLowerCase() || excludeKeys.test(key)) {
    return null;
  }
  return key.toUpperCase() === key && key.toLowerCase() !== key && !event.shiftKey;
}
const stateEnum$1 = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
let Unlock$1 = class Unlock extends reactExports.Component {
  state = {
    status: stateEnum$1.DEFAULT,
    errorMessage: "",
    errorCode: null,
    remainingAttempts: null,
    needsLongTouch: false,
    password: ""
  };
  handleFormChange = (password2) => {
    this.setState({ password: password2 });
  };
  validate = () => {
    return this.state.password !== "";
  };
  handleSubmit = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      status: stateEnum$1.WAITING
    });
    apiPost("devices/" + this.props.deviceID + "/login", { password: this.state.password }).then((data) => {
      if (data.success) {
        apiGet("devices/" + this.props.deviceID + "/status").then((status2) => {
          if (status2 === "seeded") {
            console.info("unlock.jsx route to /account-summary");
            route("/account-summary", true);
          }
        });
      }
      if (!data.success) {
        if (data.code) {
          this.setState({ errorCode: data.code });
        }
        if (data.remainingAttempts) {
          this.setState({ remainingAttempts: data.remainingAttempts });
        }
        if (data.needsLongTouch) {
          this.setState({ needsLongTouch: data.needsLongTouch });
        }
        this.setState({ status: stateEnum$1.ERROR, errorMessage: data.errorMessage });
      }
    });
    this.setState({ password: "" });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      status: status2,
      password: password2,
      errorCode,
      errorMessage: errorMessage2,
      remainingAttempts,
      needsLongTouch
    } = this.state;
    let submissionState = null;
    switch (status2) {
      case stateEnum$1.DEFAULT:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("unlock.description") });
        break;
      case stateEnum$1.WAITING:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("unlock.unlocking") });
        break;
      case stateEnum$1.ERROR:
        submissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`unlock.error.e${errorCode}`, {
          defaultValue: errorMessage2,
          remainingAttempts,
          context: needsLongTouch ? "touch" : "normal"
        }) });
        break;
    }
    const darkmode2 = getDarkmode();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content narrow padded isVerticallyCentered", children: [
          darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            submissionState,
            status2 !== stateEnum$1.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordSingleInput,
                {
                  autoFocus: true,
                  id: "password",
                  type: "password",
                  label: t2("unlock.input.label"),
                  disabled: status2 === stateEnum$1.WAITING,
                  placeholder: t2("unlock.input.placeholder"),
                  onValidPassword: this.handleFormChange,
                  value: password2
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  type: "submit",
                  disabled: !this.validate() || status2 === stateEnum$1.WAITING,
                  children: t2("button.unlock")
                }
              ) })
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: darkmode2 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.forgotDevicePassword") }, "guide.unlock.forgotDevicePassword"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.unlock.reset") }, "guide.unlock.reset")
      ] })
    ] });
  }
};
const Unlock$2 = withTranslation()(Unlock$1);
const container$e = "_container_17oq2_1";
const scrollable = "_scrollable_17oq2_17";
const agreements$1 = "_agreements_17oq2_22";
const agreementsLabel = "_agreementsLabel_17oq2_26";
const title$3 = "_title_17oq2_30";
const summary = "_summary_17oq2_36";
const heading = "_heading_17oq2_45";
const content = "_content_17oq2_49";
const verticalButtons = "_verticalButtons_17oq2_60";
const block$1 = "_block_17oq2_72";
const list = "_list_17oq2_85";
const buttons = "_buttons_17oq2_93";
const stepNumber = "_stepNumber_17oq2_98";
const badge$2 = "_badge_17oq2_108";
const waitingLogo = "_waitingLogo_17oq2_113";
const waitingContent = "_waitingContent_17oq2_117";
const waitingText = "_waitingText_17oq2_126";
const waitingDescription = "_waitingDescription_17oq2_134";
const qrcodeContainer = "_qrcodeContainer_17oq2_140";
const style$n = {
  container: container$e,
  scrollable,
  agreements: agreements$1,
  agreementsLabel,
  title: title$3,
  summary,
  heading,
  content,
  verticalButtons,
  block: block$1,
  list,
  buttons,
  stepNumber,
  badge: badge$2,
  waitingLogo,
  waitingContent,
  waitingText,
  waitingDescription,
  qrcodeContainer
};
class Bootloader extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      upgrading: false,
      errMsg: null,
      progress: 0,
      upgradeSuccessful: false
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onEvent);
    this.onStatusChanged();
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  onEvent = (data) => {
    if (data.type !== "device") {
      return;
    }
    switch (data.data) {
      case "bootloaderStatusChanged":
        this.onStatusChanged();
        break;
    }
  };
  onStatusChanged = () => {
    apiGet("devices/" + this.props.deviceID + "/bootloader-status").then(({ upgrading, progress, upgradeSuccessful, errMsg }) => {
      this.setState({
        upgrading,
        progress,
        upgradeSuccessful,
        errMsg
      });
    });
  };
  upgradeFirmware = () => {
    apiPost("devices/" + this.props.deviceID + "/bootloader/upgrade-firmware");
  };
  render() {
    const { t: t2 } = this.props;
    const {
      upgrading,
      progress,
      upgradeSuccessful,
      errMsg
    } = this.state;
    let UpgradeOrStatus;
    if (upgrading) {
      if (upgradeSuccessful) {
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bootloader.success") });
      } else {
        const value = Math.round(progress * 100);
        UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
            value,
            "%"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none text-center", children: t2("bootloader.progress", {
            progress: value
          }) })
        ] });
      }
    } else {
      UpgradeOrStatus = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: this.upgradeFirmware,
          children: t2("bootloader.button")
        }
      ) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$n.container, style$n.scrollable].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        UpgradeOrStatus,
        errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-none", children: errMsg })
      ] })
    ] }) }) }) }) });
  }
}
const Bootloader$1 = withTranslation()(Bootloader);
const container$d = "_container_l7fdu_1";
const danger = "_danger_l7fdu_27";
const children = "_children_l7fdu_31";
const optionalText = "_optionalText_l7fdu_35";
const secondaryText$1 = "_secondaryText_l7fdu_46";
const primaryText$1 = "_primaryText_l7fdu_54";
const icon = "_icon_l7fdu_58";
const disabled$1 = "_disabled_l7fdu_63";
const item$2 = "_item_l7fdu_68";
const style$m = {
  container: container$d,
  danger,
  children,
  optionalText,
  secondaryText: secondaryText$1,
  primaryText: primaryText$1,
  icon,
  disabled: disabled$1,
  item: item$2
};
const SettingsButton = ({
  onClick,
  danger: danger2,
  optionalText: optionalText2,
  secondaryText: secondaryText2,
  disabled: disabled2,
  children: children2,
  optionalIcon
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "button",
    {
      className: [
        style$m.container,
        danger2 ? style$m.danger : "",
        disabled2 === true ? style$m.disabled : ""
      ].join(" "),
      onClick: !disabled2 ? onClick : void 0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$m.children, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.primaryText, children: children2 }),
          secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.secondaryText, children: secondaryText2 }) : null
        ] }),
        optionalText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.optionalText, children: optionalText2 }) : null,
        optionalIcon ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.icon, children: optionalIcon }) : /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round", children: /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "9 18 15 12 9 6" }) })
      ]
    }
  );
};
class UpgradeFirmware extends reactExports.Component {
  state = {
    unlocked: false,
    newVersion: "",
    isConfirming: false,
    activeDialog: false
  };
  upgradeFirmware = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/unlock-bootloader").then((success2) => {
      this.setState({
        unlocked: success2,
        isConfirming: success2
      });
    }).catch(() => {
      this.setState({
        isConfirming: false
      });
    });
  };
  componentDidMount() {
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
  }
  abort = () => {
    this.setState({ activeDialog: false });
  };
  render() {
    const {
      t: t2,
      currentVersion,
      disabled: disabled2,
      asButton
    } = this.props;
    const {
      unlocked,
      newVersion,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("upgradeFirmware.button")
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: () => this.setState({ activeDialog: true }),
          disabled: disabled2,
          optionalText: newVersion,
          children: t2("upgradeFirmware.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: t2("upgradeFirmware.title"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.description", {
          currentVersion,
          newVersion
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.upgradeFirmware, children: t2("button.upgrade") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
        ] })
      ] }),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("upgradeFirmware.title"), includeDefault: !unlocked, children: unlocked ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.unlocked") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { style: { lineHeight: "1.5" }, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("upgradeFirmware.unlocked3") })
        ] })
      ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.locked", {
        currentVersion,
        newVersion
      }) }) })
    ] });
  }
}
const UpgradeFirmware$1 = withTranslation()(UpgradeFirmware);
class RequireUpgrade extends reactExports.Component {
  state = {
    firmwareVersion: null
  };
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({ version }) => {
      this.setState({
        firmwareVersion: version.replace("v", "")
      });
    });
  }
  render() {
    const { t: t2, deviceID } = this.props;
    const { firmwareVersion } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$n.container, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2("upgradeFirmware.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons m-top-half", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion, asButton: true }) })
      ] })
    ] }) });
  }
}
const RequireUpgrade$1 = withTranslation()(RequireUpgrade);
class Goal extends reactExports.Component {
  render() {
    const {
      t: t2,
      onCreate,
      onRestore
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("goal.paragraph") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onCreate, children: t2("goal.buttons.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: onRestore, children: t2("goal.buttons.restore") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) })
    ] }) });
  }
}
const Goal$1 = withTranslation()(Goal);
class SecurityInformation extends reactExports.Component {
  constructor(props) {
    super(props);
    this.handleStart = () => {
      this.setState({ showInfo: false });
    };
    this.state = {
      showInfo: true
    };
  }
  render() {
    const { t: t2, goBack, goal: goal2, children: children2 } = this.props;
    const { showInfo } = this.state;
    if (!showInfo) {
      return children2;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(`securityInformation.${goal2}.title`) }),
        goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description2") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$n.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("securityInformation.create.description4") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("securityInformation.create.description5") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: [style$n.list, "first"].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("securityInformation.restore.description2") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("securityInformation.restore.description3") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "warning", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("deviceTampered") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: goBack,
                children: t2("button.abort")
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) })
    ] }) });
  }
}
const translatedSecutiryInformation = translate()(SecurityInformation);
const STATUS$1 = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
});
class SeedCreateNew extends reactExports.Component {
  state = {
    showInfo: true,
    status: STATUS$1.CHECKING,
    walletName: "",
    backupPassword: "",
    error: "",
    agreements: {
      password_change: false,
      password_required: false,
      funds_access: false
    }
  };
  walletNameInput = reactExports.createRef();
  componentDidMount() {
    this.checkSDcard();
  }
  validate = () => {
    if (!this.walletNameInput.current || !this.walletNameInput.current.validity.valid || !this.validAgreements()) {
      return false;
    }
    return this.state.backupPassword && this.state.walletName !== "";
  };
  handleFormChange = ({ target }) => {
    this.setState({ [target.id]: target.value });
  };
  handleSubmit = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ status: STATUS$1.CREATING, error: "" });
    apiPost("devices/" + this.props.deviceID + "/create-wallet", {
      walletName: this.state.walletName,
      backupPassword: this.state.backupPassword
    }).then((data) => {
      if (!data.success) {
        this.setState({
          status: STATUS$1.ERROR,
          error: this.props.t(`seed.error.e${data.code}`, {
            defaultValue: data.errorMessage
          })
        });
      } else {
        this.props.onSuccess();
      }
      this.setState({ backupPassword: "" });
    });
  };
  setValidBackupPassword = (backupPassword) => {
    this.setState({ backupPassword });
  };
  validAgreements = () => {
    const { agreements: agreements2 } = this.state;
    const invalid = Object.keys(agreements2).map((agr) => agreements2[agr]).includes(false);
    return !invalid;
  };
  handleAgreementChange = ({ target }) => {
    this.setState((state) => ({ agreements: {
      ...state.agreements,
      [target.id]: target.checked
    } }));
  };
  checkSDcard = () => {
    getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
      if (sdcard) {
        return this.setState({ status: STATUS$1.DEFAULT, error: "" });
      }
      this.setState({
        status: STATUS$1.ERROR,
        error: this.props.t("seed.error.e200")
      });
      setTimeout(this.checkSDcard, 2500);
    });
  };
  handleStart = () => {
    this.setState({ showInfo: false });
    this.checkSDcard();
  };
  renderSpinner() {
    switch (this.state.status) {
      case STATUS$1.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("checkSDcard") });
      case STATUS$1.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      goBack
    } = this.props;
    const {
      showInfo,
      status: status2,
      walletName,
      error: error3,
      agreements: agreements2
    } = this.state;
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seed.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seed.info.description4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: this.handleStart,
            disabled: status2 !== STATUS$1.DEFAULT,
            children: t2("seed.info.button")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$2,
          {
            pattern: "^[0-9a-zA-Z-_]{1,31}$",
            autoFocus: true,
            id: "walletName",
            label: t2("seed.walletName.label"),
            disabled: status2 === STATUS$1.CREATING,
            onInput: this.handleFormChange,
            ref: this.walletNameInput,
            value: walletName
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          PasswordRepeatInput,
          {
            label: t2("seed.password.label"),
            repeatPlaceholder: t2("seed.password.repeatPlaceholder"),
            disabled: status2 === STATUS$1.CREATING,
            onValidPassword: this.setValidBackupPassword
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$n.agreements, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-items-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { width: 18, marginRight: 10, position: "relative", bottom: 1 } }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$n.agreementsLabel, children: t2("seed.description") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_change",
            label: t2("seed.agreements.password-change"),
            checked: agreements2.password_change,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "password_required",
            label: t2("seed.agreements.password-required"),
            checked: agreements2.password_required,
            onChange: this.handleAgreementChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "funds_access",
            label: t2("seed.agreements.funds-access"),
            checked: agreements2.funds_access,
            onChange: this.handleAgreementChange
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: true,
            disabled: !this.validate() || status2 === STATUS$1.CREATING,
            children: t2("seed.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2("seed.info.title") }),
          error3 && /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS$1.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }),
          content2,
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
}
const SeedCreateNew$1 = withTranslation()(SeedCreateNew);
const convertDateToLocaleString = (date2, language2) => {
  return new Date(date2).toLocaleString(language2, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "2-digit",
    minute: "2-digit"
  });
};
const stepContext = "_stepContext_g2o2c_1";
const backupsList = "_backupsList_g2o2c_5";
const listContainer$1 = "_listContainer_g2o2c_14";
const item$1 = "_item_g2o2c_24";
const agreements = "_agreements_g2o2c_37";
const emptyText = "_emptyText_g2o2c_41";
const backupItem = "_backupItem_g2o2c_47";
const backupID = "_backupID_g2o2c_52";
const backupButtons = "_backupButtons_g2o2c_59";
const backupStyle = {
  stepContext,
  backupsList,
  listContainer: listContainer$1,
  item: item$1,
  agreements,
  emptyText,
  backupItem,
  backupID,
  backupButtons
};
const BackupsListItem = ({
  backup: backup2,
  disabled: disabled2,
  handleChange,
  onFocus: onFocus2,
  radio: radio2,
  selectedBackup
}) => {
  let date2 = "";
  if (backup2.date && backup2.date !== "") {
    date2 = convertDateToLocaleString(backup2.date, instance.language);
  } else {
    date2 = "unknown";
  }
  return radio2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Radio,
    {
      disabled: !!disabled2,
      checked: selectedBackup === backup2.id,
      onChange: (event2) => {
        handleChange && handleChange(event2.target.value);
      },
      id: backup2.id,
      label: backup2.name && backup2.name !== "" ? backup2.name : backup2.id,
      value: backup2.id,
      onFocus: onFocus2,
      className: backupStyle.backupItem,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-small text-gray", children: date2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-small text-gray", children: [
          "ID: ",
          backup2.id
        ] })
      ]
    }
  ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-medium m-bottom-quarter", children: backup2.name }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupID, children: [
      "ID: ",
      backup2.id
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-small text-gray", children: date2 })
  ] });
};
let Check$1 = class Check extends reactExports.Component {
  state = {
    password: null,
    activeDialog: false,
    message: null
  };
  abort = () => {
    this.setState({
      password: null,
      activeDialog: false,
      message: null
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return this.props.selectedBackup && this.state.password;
  };
  check = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ message: this.props.t("backup.check.checking") });
    apiPost("devices/" + this.props.deviceID + "/backups/check", {
      password: this.state.password,
      filename: this.props.selectedBackup
    }).catch(() => {
    }).then(({ success: success2, matches, errorMessage: errorMessage2 }) => {
      let message2;
      if (success2) {
        if (matches) {
          message2 = this.props.t("backup.check.ok");
        } else {
          message2 = this.props.t("backup.check.notOK");
        }
      } else if (errorMessage2) {
        message2 = errorMessage2;
      }
      this.setState({ message: message2 });
    });
  };
  setValidPassword = (password2) => {
    this.setState({ password: password2 });
  };
  render() {
    const {
      t: t2,
      selectedBackup
    } = this.props;
    const {
      activeDialog,
      message: message2
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          secondary: true,
          disabled: selectedBackup === null,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.check")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.check.title"),
          onClose: this.abort,
          children: message2 ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { minHeight: "3rem" }, children: message2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$13.actions, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") }) })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.check, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordSingleInput,
              {
                label: t2("backup.check.password.label"),
                placeholder: t2("backup.check.password.placeholder"),
                showLabel: t2("backup.check.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: true, disabled: !this.validate(), children: t2("button.check") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
            ] })
          ] })
        }
      )
    ] });
  }
};
const Check$2 = withTranslation()(Check$1);
let Create$1 = class Create extends reactExports.Component {
  state = {
    waiting: false,
    backupName: "",
    recoveryPassword: "",
    activeDialog: false
  };
  abort = () => {
    this.setState({
      waiting: false,
      backupName: "",
      recoveryPassword: "",
      activeDialog: false
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return !this.state.waiting && this.state.backupName !== "";
  };
  create = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({ waiting: true });
    apiPost("devices/" + this.props.deviceID + "/backups/create", {
      backupName: this.state.backupName,
      recoveryPassword: this.state.recoveryPassword
    }).then((data) => {
      this.abort();
      if (!data.success) {
        alertUser(data.errorMessage);
      } else {
        this.props.onCreate();
        if (!data.verification) {
          alertUser(this.props.t("backup.create.verificationFailed"));
        }
      }
    });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      waiting,
      recoveryPassword,
      backupName,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.create")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.create.title"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.create, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: true,
                id: "backupName",
                label: t2("backup.create.name.label"),
                placeholder: t2("backup.create.name.placeholder"),
                onInput: this.handleFormChange,
                value: backupName
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.create.info") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                id: "recoveryPassword",
                label: t2("backup.create.password.label"),
                placeholder: t2("backup.create.password.placeholder"),
                onInput: this.handleFormChange,
                value: recoveryPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", primary: true, disabled: waiting || !this.validate(), children: t2("button.create") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.abort") })
            ] })
          ] })
        }
      )
    ] });
  }
};
const Create$2 = withTranslation()(Create$1);
class Restore extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      isConfirming: false,
      activeDialog: false,
      isLoading: false,
      understand: false,
      password: void 0
    };
    this.abort = () => {
      this.setState({
        isConfirming: false,
        activeDialog: false,
        isLoading: false,
        understand: false,
        password: void 0
      });
    };
    this.validate = () => {
      return this.props.selectedBackup && this.state.password;
    };
    this.restore = (event2) => {
      event2.preventDefault();
      if (!this.validate()) {
        return;
      }
      if (this.props.requireConfirmation) {
        this.setState({
          activeDialog: false,
          isConfirming: true
        });
      } else {
        this.setState({
          activeDialog: false,
          isLoading: true
        });
      }
      apiPost("devices/" + this.props.deviceID + "/backups/restore", {
        password: this.state.password,
        filename: this.props.selectedBackup
      }).then((data) => {
        const { success: success2, didRestore, errorMessage: errorMessage2, code } = data;
        this.abort();
        if (success2) {
          if (didRestore) {
            if (this.props.onRestore) {
              return this.props.onRestore();
            }
            console.info("restore.jsx route to /");
            route("/", true);
          }
        } else {
          alertUser(this.props.t(`backup.restore.error.e${code}`, {
            defaultValue: errorMessage2
          }));
        }
      });
    };
    this.handleUnderstandChange = (e3) => {
      this.setState({ understand: e3.target.checked });
    };
    this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
  }
  render() {
    const {
      t: t2,
      selectedBackup,
      requireConfirmation
    } = this.props;
    const {
      isConfirming,
      activeDialog,
      isLoading,
      understand
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          ...requireConfirmation ? { danger: true } : { primary: true },
          disabled: !selectedBackup,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.restore")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("backup.restore.title"),
          disableEscape: isConfirming || isLoading,
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.restore, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                label: t2("backup.restore.password.label"),
                placeholder: t2("backup.restore.password.placeholder"),
                repeatPlaceholder: t2("backup.restore.password.repeatPlaceholder"),
                showLabel: t2("backup.restore.password.showLabel"),
                onValidPassword: this.setValidPassword
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("backup.restore.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "submit",
                  ...requireConfirmation ? { danger: true } : { primary: true },
                  disabled: !understand || !this.validate() || isConfirming,
                  children: t2("button.restore")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: this.abort,
                  disabled: isConfirming,
                  children: t2("button.back")
                }
              )
            ] })
          ] })
        }
      ),
      isConfirming && requireConfirmation && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.restore.confirmTitle") }),
      isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("backup.restore.restoring") })
    ] });
  }
}
const TranslatedRestore = translate()(Restore);
class Backups extends reactExports.Component {
  constructor(props) {
    super(props);
    this.scrollableContainer = reactExports.createRef();
    this.refresh = () => {
      getDeviceInfo$1(this.props.deviceID).then(({ lock }) => this.setState({ lock }));
      apiGet("devices/" + this.props.deviceID + "/backups/list").then(({ sdCardInserted, backupList, success: success2, errorMessage: errorMessage2 }) => {
        if (success2) {
          this.setState({
            sdCardInserted,
            backupList
          });
        } else if (errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.handleBackuplistChange = (backupID2) => {
      this.setState({ selectedBackup: backupID2 });
    };
    this.scrollIntoView = (event2) => {
      if (!this.scrollableContainer.current) {
        return;
      }
      const target = event2.target;
      const offsetTop = target.offsetTop;
      const offsetHeight = target.parentNode.offsetHeight;
      if (offsetTop > this.scrollableContainer.current.scrollTop + offsetHeight) {
        return;
      }
      const top = Math.max(offsetTop + offsetHeight - this.scrollableContainer.current.offsetHeight, 0);
      this.scrollableContainer.current.scroll({ top, behavior: "smooth" });
    };
    this.state = {
      backupList: [],
      sdCardInserted: null
    };
  }
  componentDidMount() {
    this.refresh();
  }
  render() {
    const {
      t: t2,
      children: children2,
      showCreate = false,
      showRestore = true,
      deviceID,
      requireConfirmation = true,
      onRestore
    } = this.props;
    const { backupList, selectedBackup, sdCardInserted, lock } = this.state;
    if (lock === void 0) {
      return null;
    }
    if (sdCardInserted === false) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box m-top-default", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "first", children: t2("backup.insert") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.refresh, children: t2("backup.insertButton") }),
          children2
        ] })
      ] });
    } else if (!sdCardInserted) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large m-top-default", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("backup.description") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, ref: this.scrollableContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backupList.length ? backupList.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: backup2,
          selectedBackup,
          handleChange: this.handleBackuplistChange,
          onFocus: this.scrollIntoView,
          radio: true
        }
      ) }, backup2.id)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: backupStyle.emptyText, children: t2("backup.noBackups") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        showCreate && !lock && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Create$2,
          {
            onCreate: this.refresh,
            deviceID
          }
        ),
        showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Check$2,
          {
            selectedBackup,
            deviceID
          }
        ),
        showRestore && onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedRestore,
          {
            selectedBackup,
            deviceID,
            onRestore,
            requireConfirmation
          }
        ),
        children2
      ] })
    ] });
  }
}
const TranslatedBackups = translate()(Backups);
const STATUS = Object.freeze({
  DEFAULT: "default",
  CREATING: "creating",
  CHECKING: "checking",
  ERROR: "error"
});
class SeedRestore extends reactExports.Component {
  state = {
    showInfo: true,
    status: STATUS.CHECKING,
    error: ""
  };
  componentDidMount() {
    this.checkSDcard();
  }
  checkSDcard = () => {
    getDeviceInfo$1(this.props.deviceID).then(({ sdcard }) => {
      if (sdcard) {
        return this.setState({ status: STATUS.DEFAULT, error: "" });
      }
      this.setState({
        status: STATUS.ERROR,
        error: this.props.t("seedRestore.error.e200")
      });
      setTimeout(this.checkSDcard, 2500);
    });
  };
  handleStart = () => {
    this.setState({ showInfo: false });
    this.checkSDcard();
  };
  renderSpinner() {
    switch (this.state.status) {
      case STATUS.CHECKING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("checkSDcard") });
      case STATUS.CREATING:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: this.props.t("seed.creating") });
      default:
        return null;
    }
  }
  render() {
    const {
      t: t2,
      deviceID,
      goBack,
      onSuccess
    } = this.props;
    const {
      showInfo,
      status: status2,
      error: error3
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2("seedRestore.info.title") }),
          error3 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: status2 === STATUS.ERROR ? "error" : void 0, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Alert$1, {}),
            error3
          ] }) : null,
          showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ol", { className: "first", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description1") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description2") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("seedRestore.info.description3") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("seedRestore.info.description4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  onClick: this.handleStart,
                  disabled: status2 !== STATUS.DEFAULT,
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            ] })
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
            TranslatedBackups,
            {
              showCreate: false,
              deviceID,
              requireConfirmation: false,
              onRestore: onSuccess,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  secondary: true,
                  onClick: goBack,
                  children: t2("button.abort")
                }
              )
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
        ] })
      ] }),
      this.renderSpinner()
    ] }) });
  }
}
const SeedRestore$1 = withTranslation()(SeedRestore);
const stateEnum = Object.freeze({
  DEFAULT: "default",
  WAITING: "waiting",
  ERROR: "error"
});
class Initialize extends reactExports.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = (event2) => {
      event2.preventDefault();
      if (!this.state.password) {
        return;
      }
      this.setState({
        status: stateEnum.WAITING,
        errorCode: null,
        errorMessage: ""
      });
      apiPost("devices/" + this.props.deviceID + "/set-password", {
        password: this.state.password
      }).then((data) => {
        if (!data.success) {
          if (data.code) {
            this.setState({ errorCode: data.code });
          }
          this.setState({
            status: stateEnum.ERROR,
            errorMessage: data.errorMessage
          });
        }
      });
    };
    this.setValidPassword = (password2) => {
      this.setState({ password: password2 });
    };
    this.handleStart = () => {
      this.setState({ showInfo: false });
    };
    this.state = {
      showInfo: true,
      password: null,
      status: stateEnum.DEFAULT,
      errorCode: null,
      errorMessage: ""
    };
  }
  render() {
    const { t: t2, goBack } = this.props;
    const { showInfo, password: password2, status: status2, errorCode, errorMessage: errorMessage2 } = this.state;
    let formSubmissionState;
    switch (status2) {
      case stateEnum.DEFAULT:
        formSubmissionState = null;
        break;
      case stateEnum.WAITING:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "info", children: t2("initialize.creating") });
        break;
      case stateEnum.ERROR:
        formSubmissionState = /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", children: t2(`initialize.error.e${errorCode}`, {
          defaultValue: errorMessage2
        }) });
    }
    const content2 = showInfo ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("initialize.info.subtitle") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description1") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("initialize.info.description2") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("initialize.info.description3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleStart, children: t2("button.continue") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.handleSubmit, className: "box large", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordRepeatInput,
        {
          pattern: "^.{4,}$",
          label: t2("initialize.input.label"),
          repeatLabel: t2("initialize.input.labelRepeat"),
          repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
          disabled: status2 === stateEnum.WAITING,
          onValidPassword: this.setValidPassword
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "submit",
            primary: true,
            disabled: !password2 || status2 === stateEnum.WAITING,
            children: t2("initialize.create")
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: goBack,
            children: t2("button.abort")
          }
        )
      ] })
    ] });
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(showInfo ? "initialize.info.title" : "setup") }),
        formSubmissionState,
        content2,
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] }) }),
      status2 === stateEnum.WAITING && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("initialize.creating") })
    ] }) });
  }
}
const TranslatedInitialize = translate()(Initialize);
class Success extends reactExports.Component {
  handleGetStarted = () => {
    route("/account-summary", true);
  };
  render() {
    const {
      t: t2,
      handleHideSuccess,
      goal: goal2
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageSwitch, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded narrow isVerticallyCentered", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: [style$n.title, "text-center"].join(" "), children: t2(`success.${goal2}.title`) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { textAlign: "center" }, children: t2(`success.${goal2}.summary`) }),
          goal2 === "create" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$n.summary, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("success.create.info3") })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.handleGetStarted, children: t2("success.getstarted") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: handleHideSuccess, children: t2("sidebar.device") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-top-large", children: getDarkmode() ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, { large: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, { large: true }) })
      ] })
    ] }) }) });
  }
}
const Success$1 = withTranslation()(Success);
class Blink extends reactExports.Component {
  blinkDevice = () => {
    apiPost("devices/" + this.props.deviceID + "/blink");
  };
  render() {
    const { t: t2 } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.blinkDevice, children: t2("blink.button") });
  }
}
const Blink$1 = withTranslation()(Blink);
class LegacyHiddenWallet extends reactExports.Component {
  toggle = () => {
    const newValue = !this.props.newHiddenWallet;
    apiPost("devices/" + this.props.deviceID + "/feature-set", {
      new_hidden_wallet: newValue
    }).then(() => {
      if (newValue) {
        alertUser(this.props.t("legacyhiddenwallet.successDisable"));
      } else {
        alertUser(this.props.t("legacyhiddenwallet.successEnable"));
      }
      if (this.props.onChange) {
        this.props.onChange(newValue);
      }
    });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      newHiddenWallet
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        danger: true,
        disabled: disabled2,
        onclick: this.toggle,
        children: newHiddenWallet ? t2("legacyhiddenwallet.enable") : t2("legacyhiddenwallet.disable")
      }
    );
  }
}
const LegacyHiddenWallet$1 = withTranslation()(LegacyHiddenWallet);
class RandomNumber extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      active: false,
      number: ""
    };
  }
  getRandomNumber = () => {
    apiPost(this.props.apiPrefix + "/random-number").then((number) => {
      this.setState({
        active: true,
        number
      });
    });
  };
  abort = () => {
    this.setState({
      active: false,
      number: void 0
    });
  };
  render() {
    const { t: t2 } = this.props;
    const { number, active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: this.getRandomNumber, children: t2("random.button") }),
      // @ts-ignore Object is possibly 'undefined'.
      active2 && number ? /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogLegacy, { title: "Generate Random Number", onClose: this.abort, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("random.description", {
            // @ts-ignore
            bits: number.length * 4
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { value: number, flexibleHeight: true })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.abort, children: t2("button.ok") }) })
      ] }) : null
    ] });
  }
}
const RandomNumber$1 = withTranslation()(RandomNumber);
class HiddenWallet extends reactExports.Component {
  state = {
    password: null,
    pin: null,
    isConfirming: false,
    activeDialog: false
  };
  abort = () => {
    this.setState({
      password: null,
      isConfirming: false,
      activeDialog: false
    });
  };
  handleFormChange = (event2) => {
    this.setState({ [event2.target.id]: event2.target.value });
  };
  validate = () => {
    return this.state.password && this.state.pin;
  };
  createHiddenWallet = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/set-hidden-password", {
      pin: this.state.pin,
      backupPassword: this.state.password
    }).catch(() => {
    }).then(({ success: success2, didCreate, errorMessage: errorMessage2, code }) => {
      this.abort();
      if (success2) {
        if (didCreate) {
          alertUser(this.props.t("hiddenWallet.success"));
        }
      } else {
        alertUser(this.props.t(`bitbox.error.e${code}`, {
          defaultValue: errorMessage2
        }));
      }
    });
  };
  setValidPassword = (password2) => {
    this.setState({ password: password2 });
  };
  setValidPIN = (pin) => {
    this.setState({ pin });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props;
    const {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.hiddenwallet")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("button.hiddenwallet"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info1HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("hiddenWallet.info2HTML") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.createHiddenWallet, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "pin",
                  pattern: "^.{4,}$",
                  label: t2("hiddenWallet.pinLabel"),
                  repeatLabel: t2("hiddenWallet.pinRepeatLabel"),
                  repeatPlaceholder: t2("hiddenWallet.pinRepeatPlaceholder"),
                  onValidPassword: this.setValidPIN
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                PasswordRepeatInput,
                {
                  idPrefix: "password",
                  label: t2("hiddenWallet.passwordLabel"),
                  repeatPlaceholder: t2("hiddenWallet.passwordPlaceholder"),
                  onValidPassword: this.setValidPassword
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: true, disabled: !this.validate() || isConfirming, children: t2("button.hiddenwallet") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.abort") })
              ] })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.hiddenwallet") })
    ] });
  }
}
const HiddenWallet$1 = withTranslation()(HiddenWallet);
class ChangePIN extends reactExports.Component {
  state = {
    oldPIN: null,
    newPIN: null,
    errorCode: null,
    isConfirming: false,
    activeDialog: false
  };
  abort = () => {
    this.setState({
      oldPIN: null,
      newPIN: null,
      isConfirming: false,
      activeDialog: false
    });
  };
  validate = () => {
    return this.state.newPIN && this.state.oldPIN;
  };
  changePin = (event2) => {
    event2.preventDefault();
    if (!this.validate()) {
      return;
    }
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/change-password", {
      oldPIN: this.state.oldPIN,
      newPIN: this.state.newPIN
    }).catch(() => {
    }).then((data) => {
      this.abort();
      if (!data.success) {
        alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }
    });
  };
  setValidOldPIN = (e3) => {
    this.setState({ oldPIN: e3.target.value });
  };
  setValidNewPIN = (newPIN) => {
    this.setState({ newPIN });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2
    } = this.props;
    const {
      oldPIN,
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          disabled: disabled2,
          onClick: () => this.setState({ activeDialog: true }),
          children: t2("button.changepin")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsx(
        DialogLegacy,
        {
          title: t2("button.changepin"),
          onClose: this.abort,
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.changePin, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "oldPIN",
                label: t2("changePin.oldLabel"),
                value: oldPIN,
                onInput: this.setValidOldPIN
              }
            ),
            t2("changePin.newTitle") && /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { children: t2("changePin.newTitle") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordRepeatInput,
              {
                idPrefix: "newPIN",
                pattern: "^.{4,}$",
                label: t2("initialize.input.label"),
                repeatLabel: t2("initialize.input.labelRepeat"),
                repeatPlaceholder: t2("initialize.input.placeholderRepeat"),
                onValidPassword: this.setValidNewPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", danger: true, disabled: !this.validate() || isConfirming, children: t2("button.changepin") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ] })
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("button.changepin") })
    ] });
  }
}
const ChangePIN$1 = withTranslation()(ChangePIN);
class Reset extends reactExports.Component {
  state = {
    pin: null,
    isConfirming: false,
    activeDialog: false,
    understand: false
  };
  handleUnderstandChange = (e3) => {
    this.setState({ understand: e3.target.checked });
  };
  resetDevice = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/reset", { pin: this.state.pin }).then((data) => {
      this.abort();
      if (data.success) {
        if (data.didReset) {
          route("/", true);
        }
      } else if (data.errorMessage) {
        alertUser(this.props.t(`bitbox.error.e${data.code}`, {
          defaultValue: data.errorMessage
        }));
      }
    });
  };
  setValidPIN = (e3) => {
    this.setState({ pin: e3.target.value });
  };
  abort = () => {
    this.setState({
      pin: null,
      understand: false,
      isConfirming: false,
      activeDialog: false
    });
  };
  render() {
    const { t: t2 } = this.props;
    const {
      isConfirming,
      activeDialog,
      understand,
      pin
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { danger: true, onClick: () => this.setState({ activeDialog: true }), children: t2("reset.title") }),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("reset.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              PasswordInput,
              {
                idPrefix: "pin",
                label: t2("initialize.input.label"),
                value: pin,
                onInput: this.setValidPIN
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$n.agreements, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Checkbox,
              {
                id: "funds_access",
                label: t2("reset.understand"),
                checked: understand,
                onChange: this.handleUnderstandChange
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, disabled: !pin || !understand, onClick: this.resetDevice, children: t2("reset.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, disabled: isConfirming, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("reset.title") }) : null
    ] });
  }
}
const Reset$1 = withTranslation()(Reset);
const appStoreBadge = "" + new URL("app-store-badge.svg", import.meta.url).href;
const playStoreBadge = "" + new URL("google-play-badge.png", import.meta.url).href;
class MobilePairing extends reactExports.Component {
  constructor(props) {
    super(props);
    this.onDeviceStatus = (payload) => {
      if ("type" in payload) {
        const { type: type2, data, deviceID } = payload;
        if (type2 === "device" && deviceID === this.props.deviceID) {
          switch (data) {
            case "pairingStarted":
              this.setState({ status: "started" });
              break;
            case "pairingTimedout":
              if (this.state.status) {
                this.setState({ status: "timeout" });
              }
              break;
            case "pairingPullMessageFailed":
              this.setState({ status: "pullFailed" });
              break;
            case "pairingScanningFailed":
              this.setState({ status: "scanningFailed" });
              break;
            case "pairingAborted":
              this.setState({ status: "aborted" });
              break;
            case "pairingError":
              this.setState({ status: "error" });
              break;
            case "pairingSuccess":
              this.setState({ status: "success" });
              break;
          }
        }
      }
    };
    this.reconnectUnpaired = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        if (!response) {
          return;
        }
        apiPost("devices/" + this.props.deviceID + "/feature-set", {
          pairing: true
        }).then(() => {
          this.props.onPairingEnabled();
          alertUser(this.props.t("pairing.success.text"));
        });
      });
    };
    this.startPairing = () => {
      confirmation(this.props.t("pairing.confirm"), (response) => {
        if (!response) {
          return;
        }
        this.setState({
          channel: null,
          status: "loading"
        });
        apiPost("devices/" + this.props.deviceID + "/pairing/start").then((channel) => {
          if (this.props.deviceLocked) {
            this.setState({
              channel,
              status: "connectOnly"
            });
          } else {
            this.setState({
              channel,
              status: "start"
            });
          }
        });
      });
    };
    this.abort = () => {
      this.setState({
        showQRCode: false,
        status: false
      });
    };
    this.toggleQRCode = () => {
      this.setState({ showQRCode: !this.state.showQRCode });
    };
    this.state = {
      channel: null,
      status: false,
      showQRCode: false
    };
  }
  componentDidMount() {
    this.unsubscribe = apiWebsocket(this.onDeviceStatus);
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  render() {
    const { t: t2, deviceLocked, paired, hasMobileChannel: hasMobileChannel2 } = this.props;
    const { channel, status: status2, showQRCode } = this.state;
    let content2;
    if (status2 === "start") {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "1." }),
            " ",
            t2("pairing.start.step1")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.toggleQRCode, className: "width-1-1", children: t2(`pairing.start.${showQRCode ? "hideAppQRCode" : "revealAppQRCode"}`) }) }),
          showQRCode ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Apple App Store" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", size: 148 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://itunes.apple.com/us/app/digital-bitbox-2fa/id1079896740", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: appStoreBadge, className: style$n.badge }) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-center", children: "Google Play Store" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-center flex-items-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", size: 148 }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("a", { target: "_blank", rel: "noreferrer", href: "https://play.google.com/store/apps/details?id=com.digitalbitbox.tfa", children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: playStoreBadge, className: style$n.badge }) })
              ] })
            ] })
          ] }) }) : null
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-row flex-start m-top-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "m-top-none", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { className: "m-right-quarter", children: "2." }),
            t2("pairing.start.step2")
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: JSON.stringify(channel), size: 196 }) })
        ] }) })
      ] });
    } else if (status2 === "connectOnly") {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsx(QRCode, { tapToCopy: false, data: JSON.stringify({ channel, connectOnly: true }) });
    } else {
      content2 = /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-none", children: t2(`pairing.${status2}.text`) });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          onClick: hasMobileChannel2 && !paired ? this.reconnectUnpaired : this.startPairing,
          optionalText: t2(`deviceSettings.pairing.status.${paired}`),
          children: deviceLocked ? hasMobileChannel2 ? t2("pairing.reconnectOnly.button") : t2("pairing.connectOnly.button") : hasMobileChannel2 && !paired ? t2("pairing.reconnectOnly.button") : t2("pairing.button")
        }
      ),
      status2 && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("pairing.title"),
          onClose: this.abort,
          medium: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-column flex-center flex-items-center", children: channel ? content2 : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("loading") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") }) })
          ]
        }
      )
    ] });
  }
}
const translatedMobilePairing = translate()(MobilePairing);
class DeviceLock extends reactExports.Component {
  state = {
    isConfirming: false,
    activeDialog: false
  };
  resetDevice = () => {
    this.setState({
      activeDialog: false,
      isConfirming: true
    });
    apiPost("devices/" + this.props.deviceID + "/lock").then((didLock) => {
      this.setState({
        isConfirming: false
      });
      if (didLock) {
        this.props.onLock();
      }
    });
  };
  abort = () => {
    this.setState({ activeDialog: false });
  };
  render() {
    const {
      t: t2,
      disabled: disabled2,
      lock
    } = this.props;
    const {
      isConfirming,
      activeDialog
    } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        SettingsButton,
        {
          danger: true,
          onClick: () => this.setState({ activeDialog: true }),
          disabled: disabled2,
          optionalText: t2(`deviceSettings.pairing.lock.${lock}`),
          children: t2("deviceLock.button")
        }
      ),
      activeDialog && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        DialogLegacy,
        {
          title: t2("deviceLock.title"),
          onClose: this.abort,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("deviceLock.condition3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$13.actions, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, onClick: this.resetDevice, children: t2("deviceLock.confirm") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.abort, children: t2("button.back") })
            ] })
          ]
        }
      ),
      isConfirming && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("deviceLock.title") })
    ] });
  }
}
const DeviceLock$1 = withTranslation()(DeviceLock);
const SettingsItem$1 = ({ optionalText: optionalText2, optionalIcon, children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$m.container, style$m.item].join(" "), children: [
    children2,
    optionalText2 && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$m.optionalText, children: optionalText2 }),
    optionalIcon
  ] });
};
class Settings extends reactExports.Component {
  state = {
    firmwareVersion: null,
    newVersion: null,
    lock: true,
    name: null,
    spinner: true,
    sdcard: false,
    serial: "",
    pairing: false,
    mobileChannel: false,
    connected: false,
    newHiddenWallet: true
  };
  componentDidMount() {
    getDeviceInfo$1(this.props.deviceID).then(({
      lock,
      name,
      new_hidden_wallet,
      pairing: pairing2,
      sdcard,
      serial,
      version
    }) => {
      this.setState({
        firmwareVersion: version.replace("v", ""),
        lock,
        name,
        newHiddenWallet: new_hidden_wallet,
        pairing: pairing2,
        sdcard,
        serial,
        spinner: false
      });
    });
    apiGet("devices/" + this.props.deviceID + "/has-mobile-channel").then((mobileChannel) => {
      this.setState({ mobileChannel });
    });
    apiGet("devices/" + this.props.deviceID + "/bundled-firmware-version").then((version) => {
      this.setState({ newVersion: version.replace("v", "") });
    });
    this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "device") {
        if (deviceID !== this.props.deviceID) {
          return;
        }
        switch (data) {
          case "mobileDisconnected":
            this.setState({ connected: false });
            break;
          case "mobileConnected":
            this.setState({ connected: true });
            break;
          case "pairingSuccess":
            this.setState({ pairing: true, mobileChannel: true });
            break;
          case "pairingFalse":
            this.setState({ mobileChannel: false });
            break;
        }
      }
    });
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  render() {
    const {
      t: t2,
      deviceID
    } = this.props;
    const {
      firmwareVersion,
      newVersion,
      lock,
      name,
      spinner: spinner4,
      sdcard,
      serial,
      pairing: pairing2,
      mobileChannel,
      connected,
      newHiddenWallet
    } = this.state;
    const canUpgrade = firmwareVersion && newVersion !== firmwareVersion;
    const paired = pairing2 && mobileChannel;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: name === null ? "" : name || "BitBox" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columnsContainer", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.secrets.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsButton, { onClick: () => route(`/manage-backups/${deviceID}`), children: t2("deviceSettings.secrets.manageBackups") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ChangePIN$1, { deviceID }),
                newHiddenWallet ? /* @__PURE__ */ jsxRuntimeExports.jsx(HiddenWallet$1, { deviceID, disabled: lock }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
                  LegacyHiddenWallet$1,
                  {
                    deviceID,
                    newHiddenWallet,
                    disabled: lock,
                    onChange: (value) => this.setState({ newHiddenWallet: value })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Reset$1, { deviceID })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.pairing.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.pairing.mobile.${connected}`), children: t2("deviceSettings.pairing.mobile.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  translatedMobilePairing,
                  {
                    deviceID,
                    deviceLocked: lock,
                    hasMobileChannel: mobileChannel,
                    paired,
                    onPairingEnabled: () => this.setState({ pairing: true })
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  DeviceLock$1,
                  {
                    lock,
                    deviceID,
                    onLock: () => this.setState({ lock: true }),
                    disabled: lock || !paired
                  }
                )
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.firmware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box slim divide", children: canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(UpgradeFirmware$1, { deviceID, currentVersion: firmwareVersion }) : /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: `${t2("deviceSettings.firmware.version.label")} ${firmwareVersion ? firmwareVersion : t2("loading")}`, children: t2("deviceSettings.firmware.upToDate") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column column-1-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.hardware.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box slim divide", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: serial, children: "Serial number" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsItem$1, { optionalText: t2(`deviceSettings.hardware.sdcard.${sdcard}`), children: t2("deviceSettings.hardware.sdcard.label") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(RandomNumber$1, { apiPrefix: "devices/" + deviceID }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Blink$1, { deviceID })
              ] })
            ] })
          ] })
        ] }) }),
        spinner4 && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("deviceSettings.loading") })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectBitbox") }, "guide.bitbox.ejectBitbox"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.ejectSD") }, "guide.bitbox.ejectSD"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.hiddenWallet") }, "guide.bitbox.hiddenWallet"),
        !lock && newHiddenWallet && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.legacyHiddenWallet"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          LegacyHiddenWallet$1,
          {
            deviceID,
            newHiddenWallet,
            onChange: (value) => this.setState({ newHiddenWallet: value })
          }
        ) }) }, "guide.bitbox.legacyHiddenWallet"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.pairing") }, "guide.bitbox.pairing"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.2FA") }, "guide.bitbox.2FA"),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitbox.disable2FA") }, "guide.bitbox.disable2FA")
      ] })
    ] });
  }
}
const Settings$1 = withTranslation()(Settings);
const DeviceStatus = Object.freeze({
  BOOTLOADER: "bootloader",
  INITIALIZED: "initialized",
  UNINITIALIZED: "uninitialized",
  LOGGED_IN: "logged_in",
  SEEDED: "seeded",
  REQUIRE_FIRMWARE_UPGRADE: "require_firmware_upgrade",
  REQUIRE_APP_UPGRADE: "require_app_upgrade"
});
const GOAL = Object.freeze({
  CREATE: "create",
  RESTORE: "restore"
});
class Device extends reactExports.Component {
  static contextType = AppContext;
  state = {
    firmwareVersion: null,
    deviceRegistered: false,
    deviceStatus: "",
    goal: "",
    success: null
  };
  componentDidMount() {
    this.onDevicesRegisteredChanged();
    this.onDeviceStatusChanged();
    this.unsubscribe = apiWebsocket(({ type: type2, data, deviceID }) => {
      if (type2 === "devices" && data === "registeredChanged") {
        this.onDevicesRegisteredChanged();
      }
      if (type2 === "device" && data === "statusChanged" && deviceID === this.getDeviceID()) {
        this.onDeviceStatusChanged();
      }
    });
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  componentDidUpdate(prevProps) {
    if (this.props.deviceID !== prevProps.deviceID) {
      this.onDevicesRegisteredChanged();
    }
  }
  onDevicesRegisteredChanged = () => {
    apiGet("devices/registered").then((devices) => {
      const deviceIDs = Object.keys(devices);
      const deviceRegistered = deviceIDs.includes(this.getDeviceID());
      this.setState({
        deviceRegistered,
        deviceStatus: null
      }, () => {
        if (this.state.deviceRegistered) {
          this.onDeviceStatusChanged();
        }
      });
    });
  };
  onDeviceStatusChanged = () => {
    if (this.state.deviceRegistered) {
      apiGet("devices/" + this.props.deviceID + "/status").then((deviceStatus) => {
        if (["seeded", "initialized"].includes(deviceStatus)) {
          this.context.setSidebarStatus("");
        } else {
          this.context.setSidebarStatus("forceHidden");
        }
        this.setState({ deviceStatus });
      });
    }
  };
  getDeviceID() {
    return this.props.deviceID || null;
  }
  handleCreate = () => {
    this.setState({ goal: GOAL.CREATE });
  };
  handleRestore = () => {
    this.setState({ goal: GOAL.RESTORE });
  };
  handleBack = () => {
    this.setState({ goal: null });
  };
  handleSuccess = () => {
    this.setState({ success: true });
  };
  render() {
    const {
      deviceID
    } = this.props;
    const {
      deviceRegistered,
      deviceStatus,
      goal: goal2,
      success: success2
    } = this.state;
    if (!deviceRegistered || !deviceStatus) {
      return null;
    }
    if (success2) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Success$1, { goal: goal2, handleHideSuccess: () => this.setState({ success: null }) });
    }
    switch (deviceStatus) {
      case DeviceStatus.BOOTLOADER:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Bootloader$1, { deviceID });
      case DeviceStatus.REQUIRE_FIRMWARE_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(RequireUpgrade$1, { deviceID });
      case DeviceStatus.REQUIRE_APP_UPGRADE:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
      case DeviceStatus.INITIALIZED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Unlock$2, { deviceID });
      case DeviceStatus.UNINITIALIZED:
        if (!goal2) {
          return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(translatedSecutiryInformation, { goal: goal2, goBack: this.handleBack, children: /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedInitialize, { goBack: this.handleBack, deviceID }) });
      case DeviceStatus.LOGGED_IN:
        switch (goal2) {
          case GOAL.CREATE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedCreateNew$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          case GOAL.RESTORE:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              SeedRestore$1,
              {
                goBack: this.handleBack,
                onSuccess: this.handleSuccess,
                deviceID
              }
            );
          default:
            return /* @__PURE__ */ jsxRuntimeExports.jsx(Goal$1, { onCreate: this.handleCreate, onRestore: this.handleRestore });
        }
      case DeviceStatus.SEEDED:
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Settings$1, { deviceID });
      default:
        return null;
    }
  }
}
const BitBox01 = withTranslation()(Device);
const container$c = "_container_6tizs_1";
const primaryText = "_primaryText_6tizs_21";
const isButton = "_isButton_6tizs_27";
const rightContentContainer = "_rightContentContainer_6tizs_32";
const displayedValue = "_displayedValue_6tizs_38";
const withMargin = "_withMargin_6tizs_47";
const secondaryText = "_secondaryText_6tizs_51";
const collapse = "_collapse_6tizs_74";
const hideDisplayedValueOnSmall = "_hideDisplayedValueOnSmall_6tizs_87";
const styles$g = {
  container: container$c,
  primaryText,
  isButton,
  rightContentContainer,
  displayedValue,
  withMargin,
  secondaryText,
  collapse,
  hideDisplayedValueOnSmall
};
const SettingsItem = ({
  className = "",
  collapseOnSmall = false,
  displayedValue: displayedValue2 = "",
  extraComponent,
  hideDisplayedValueOnSmall: hideDisplayedValueOnSmall2 = false,
  onClick,
  secondaryText: secondaryText2,
  settingName: settingName2
}) => {
  const notButton = onClick === void 0;
  const rightContent = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$g.rightContentContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "p",
      {
        className: `
        ${displayedValue2 ? styles$g.displayedValue : ""}
        ${extraComponent ? styles$g.withMargin : ""}
        ${hideDisplayedValueOnSmall2 ? styles$g.hideDisplayedValueOnSmall : ""}
       `,
        children: displayedValue2
      }
    ),
    extraComponent ? extraComponent : null
  ] });
  const content2 = /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
      typeof settingName2 === "string" ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$g.primaryText, children: settingName2 }) : settingName2,
      secondaryText2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$g.secondaryText, children: secondaryText2 }) : null
    ] }),
    rightContent
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: notButton ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${styles$g.container} ${className} 
          ${collapseOnSmall ? styles$g.collapse : ""}`, children: content2 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
    "button",
    {
      className: `${styles$g.container} ${styles$g.isButton} ${className}`,
      onClick,
      children: content2
    }
  ) });
};
const container$b = "_container_1rta5_1";
const active$2 = "_active_1rta5_13";
const styles$f = {
  container: container$b,
  active: active$2
};
const WithSettingsTabs = ({
  children: children2,
  deviceIDs,
  hideMobileMenu,
  hasAccounts
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "hide-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { hideMobileMenu, deviceIDs, hasAccounts }) }),
    children2
  ] });
};
const Tab = ({ name, url, hideMobileMenu }) => {
  if (!hideMobileMenu) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "show-on-small", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: name,
        onClick: () => route(url),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
      }
    ) }, url);
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavLink,
    {
      className: ({ isActive }) => isActive ? `${styles$f.active} hide-on-small` : "hide-on-small",
      to: url,
      children: name
    },
    url
  );
};
const Tabs = ({ deviceIDs, hideMobileMenu, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$f.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.appearance"), url: "/settings/appearance" }, "appearance"),
    hasAccounts ? /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("manageAccounts.title"), url: "/settings/manage-accounts" }, "manage-accounts") : null,
    deviceIDs.map((id2) => /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("sidebar.device"), url: `/settings/device-settings/${id2}` }, `device-${id2}`)),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.advancedSettings"), url: "/settings/advanced-settings" }, "advanced-settings"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Tab, { hideMobileMenu, name: t2("settings.about"), url: "/settings/about" }, "about")
  ] });
};
const ManageBackupSetting = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/manage-backups/${deviceID}`),
      settingName: t2("backup.title"),
      secondaryText: t2("deviceSettings.backups.manageBackups.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
};
const ShowRecoveryWordsSetting = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [inProgress, setInProgress] = reactExports.useState(false);
  const [showDialog, setShowDialog] = reactExports.useState(false);
  const confirmShowWords = async () => {
    setShowDialog(false);
    setInProgress(true);
    await showMnemonic(deviceID);
    setInProgress(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("backup.showMnemonic.title"),
        secondaryText: t2("deviceSettings.backups.showRecoveryWords.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setShowDialog(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ShowMnemonicWaitDialog, { inProgress }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("backup.showMnemonic.title"), open: showDialog, onClose: () => setShowDialog(false), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MultilineMarkup,
        {
          markup: t2("backup.showMnemonic.description"),
          tagName: "span",
          withBreaks: true
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: confirmShowWords, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: () => setShowDialog(false), children: t2("dialog.cancel") })
      ] })
    ] })
  ] });
};
const ShowMnemonicWaitDialog = ({ inProgress }) => {
  const { t: t2 } = useTranslation();
  if (!inProgress) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(TranslatedWaitDialog, { title: t2("backup.showMnemonic.title"), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "span", markup: t2("backup.showMnemonic.warning") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MultilineMarkup,
      {
        markup: t2("backup.showMnemonic.description"),
        tagName: "span",
        withBreaks: true
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Interact.followInstructions") })
  ] });
};
const StartupSettingsWaitDialog = ({ show: show2 }) => {
  const { t: t2 } = useTranslation();
  if (!show2) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("bitbox02Settings.gotoStartupSettings.title"),
      children: t2("bitbox02Settings.gotoStartupSettings.description")
    }
  );
};
const GoToStartupSettings = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [show2, setShow] = reactExports.useState(false);
  const handleGoToStartupSettings = async () => {
    setShow(true);
    await apiPost(`devices/bitbox02/${deviceID}/goto-startup-settings`).catch(console.error);
    setShow(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.gotoStartupSettings.title"),
        secondaryText: t2("deviceSettings.expert.goToStartupSettings.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: handleGoToStartupSettings
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(StartupSettingsWaitDialog, { show: show2 })
  ] });
};
const PassphraseSetting = ({ deviceID, passphraseEnabled }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      onClick: () => route(`/settings/device-settings/passphrase/${deviceID}`),
      settingName: t2("deviceSettings.expert.passphrase.title"),
      secondaryText: t2("deviceSettings.expert.passphrase.description"),
      displayedValue: passphraseEnabled ? t2("generic.enabled_true") : t2("generic.enabled_false"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {})
    }
  );
};
const AttestationCheckSetting = ({ deviceID }) => {
  const [attestation, setAttestation] = reactExports.useState(null);
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    verifyAttestation(deviceID).then(setAttestation);
  }, [deviceID]);
  const icon2 = attestation ? /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { width: 20, height: 20 });
  if (attestation === null) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.attestation.label"),
      secondaryText: t2("deviceSettings.deviceInformation.attestation.description"),
      extraComponent: icon2,
      displayedValue: t2(`deviceSettings.hardware.attestation.${attestation}`),
      hideDisplayedValueOnSmall: true
    }
  );
};
const FirmwareSetting = ({ deviceID, versionInfo, asButton = false }) => {
  const { t: t2 } = useTranslation();
  const [dialogOpen, setDialogOpen] = reactExports.useState(false);
  const [confirming, setConfirming] = reactExports.useState(false);
  const canUpgrade = versionInfo.canUpgrade;
  const secondaryText2 = canUpgrade ? t2("deviceSettings.firmware.upgradeAvailable") : t2("deviceSettings.firmware.upToDate");
  const extraComponent = canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {});
  const handleOpenDialog = canUpgrade ? () => setDialogOpen(true) : void 0;
  const handleUpgradeFirmware = async () => {
    setConfirming(true);
    await upgradeDeviceFirmware(deviceID);
    setConfirming(false);
    setDialogOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    asButton ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleOpenDialog,
        primary: true,
        children: t2("button.upgrade")
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("deviceSettings.firmware.title"),
        secondaryText: secondaryText2,
        onClick: handleOpenDialog,
        displayedValue: versionInfo.currentVersion,
        extraComponent
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      UpgradeDialog,
      {
        open: dialogOpen && canUpgrade,
        versionInfo,
        confirming,
        onUpgradeFirmware: handleUpgradeFirmware,
        onClose: () => setDialogOpen(false)
      }
    )
  ] });
};
const UpgradeDialog = ({
  open: open2,
  versionInfo,
  confirming,
  onUpgradeFirmware,
  onClose
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { onClose, open: open2, title: t2("upgradeFirmware.title"), children: [
    confirming ? t2("confirmOnDevice") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("upgradeFirmware.description", {
      currentVersion: versionInfo.currentVersion,
      newVersion: versionInfo.newVersion
    }) }),
    !confirming && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: onUpgradeFirmware,
          children: t2("button.upgrade")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: onClose, children: t2("button.back") })
    ] })
  ] });
};
const SecureChipSetting = ({ secureChipModel }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("deviceSettings.hardware.securechip"),
      secondaryText: t2("deviceSettings.deviceInformation.securechip.description"),
      displayedValue: secureChipModel
    }
  );
};
const wizardLabel = "_wizardLabel_1tll2_2";
const inputError = "_inputError_1tll2_6";
const errorMessage$1 = "_errorMessage_1tll2_11";
const nameStyle = {
  wizardLabel,
  inputError,
  errorMessage: errorMessage$1
};
const regexInvalid = /[^ -~]/g;
const useValidateDeviceName = (name) => {
  const getDeviceNameValidationError = reactExports.useCallback((name2) => {
    const trimmed = name2.trim();
    regexInvalid.lastIndex = 0;
    if (trimmed.length < 1) {
      return "tooShort";
    }
    if (trimmed.length > 30) {
      return "tooLong";
    }
    if (regexInvalid.test(trimmed)) {
      return "invalidChars";
    }
  }, []);
  const getInvalidCharsInDeviceName = reactExports.useCallback((deviceName) => {
    var _a;
    return (_a = deviceName.match(regexInvalid)) == null ? void 0 : _a.filter(filterUnique).join(", ");
  }, []);
  const { error: error3, invalidChars, nameIsTooShort } = reactExports.useMemo(() => {
    const error22 = getDeviceNameValidationError(name);
    const invalidChars2 = getInvalidCharsInDeviceName(name);
    const nameIsTooShort2 = error22 === "tooShort";
    return { error: error22, invalidChars: invalidChars2, nameIsTooShort: nameIsTooShort2 };
  }, [getDeviceNameValidationError, getInvalidCharsInDeviceName, name]);
  const filterUnique = (value, index2, array) => {
    return array.indexOf(value) === index2;
  };
  return { error: error3, invalidChars, nameIsTooShort };
};
const SetDeviceName = ({
  onDeviceName,
  onBack,
  missingSDCardWarning
}) => {
  const { t: t2 } = useTranslation();
  const [deviceName, setDeviceName2] = reactExports.useState("");
  const { error: error3, invalidChars, nameIsTooShort } = useValidateDeviceName(deviceName);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "form",
    {
      onSubmit: (event2) => {
        event2.preventDefault();
        onDeviceName(deviceName);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          textCenter: true,
          withBottomBar: true,
          verticallyCentered: true,
          width: "600px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepCreate.title"), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreate.description") }),
              missingSDCardWarning && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { className: "m-bottom-half", type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitbox02Wizard.stepCreate.toastMicroSD") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { textAlign: "left", minHeight: "140px", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                autoFocus: true,
                className: `${nameStyle.wizardLabel} ${error3 && !nameIsTooShort ? nameStyle.inputError : ""}`,
                label: t2("bitbox02Wizard.stepCreate.nameLabel"),
                onInput: (e3) => setDeviceName2(e3.target.value),
                placeholder: t2("bitbox02Wizard.stepCreate.namePlaceholder"),
                value: deviceName,
                id: "deviceName",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeviceNameErrorMessage, { error: error3, invalidChars })
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  disabled: !!error3,
                  primary: true,
                  type: "submit",
                  children: t2("button.continue")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onBack,
                  secondary: true,
                  type: "button",
                  children: t2("button.back")
                }
              )
            ] })
          ]
        }
      )
    }
  );
};
const DeviceNameErrorMessage = ({ error: error3, invalidChars }) => {
  const { t: t2 } = useTranslation();
  if (error3 === "tooShort") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { hidden: !error3, className: nameStyle.errorMessage, children: [
    t2(`bitbox02Wizard.stepCreate.error.${error3}`, {
      invalidChars
    }),
    " ",
    t2("bitbox02Wizard.stepCreate.error.genericMessage")
  ] });
};
const SetDeviceNameWithSDCard = ({
  deviceID,
  onDeviceName,
  onBack
}) => {
  const [hasSDCard, setSDCard] = reactExports.useState();
  reactExports.useEffect(() => {
    checkSDCard(deviceID).then(setSDCard);
  }, [deviceID]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SetDeviceName,
    {
      onDeviceName,
      onBack,
      missingSDCardWarning: hasSDCard === false
    }
  );
};
const DeviceNameSetting = ({ deviceName, deviceID }) => {
  const { t: t2 } = useTranslation();
  const [active2, setActive] = reactExports.useState(false);
  const [currentName, setCurrentName] = reactExports.useState(deviceName);
  const [name, setName] = reactExports.useState("");
  const [inProgress, setInProgress] = reactExports.useState(false);
  const updateName = async () => {
    setInProgress(true);
    try {
      const setNameResult = await setDeviceName(deviceID, name);
      if (!setNameResult.success) {
        throw new Error(setNameResult.message);
      }
      const deviceInfoResult = await getDeviceInfo(deviceID);
      if (!deviceInfoResult.success) {
        throw new Error(deviceInfoResult.message);
      }
      setCurrentName(deviceInfoResult.deviceInfo.name);
    } catch (error3) {
      alertUser(t2("bitbox02Settings.deviceName.error"));
      console.error(error3);
    } finally {
      setActive(false);
      setInProgress(false);
    }
  };
  const handleCloseDialog = () => {
    setActive(false);
    setName("");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: t2("bitbox02Settings.deviceName.input"),
        secondaryText: t2("deviceSettings.deviceInformation.deviceName.description"),
        displayedValue: currentName,
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActive(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetDeviceNameDialog,
      {
        open: active2,
        onClose: handleCloseDialog,
        currentName,
        onInputChange: setName,
        name,
        handleUpdateName: updateName
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SetDeviceNameWaitDialog, { inProgress })
  ] });
};
const SetDeviceNameDialog = ({ open: open2, onClose, currentName, onInputChange, name, handleUpdateName }) => {
  const { t: t2 } = useTranslation();
  const { error: error3, invalidChars, nameIsTooShort } = useValidateDeviceName(name);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      onClose,
      title: t2("bitbox02Settings.deviceName.title"),
      small: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "columns half", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("bitbox02Settings.deviceName.current") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-half", children: currentName })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input$2,
              {
                className: `m-none ${error3 && !nameIsTooShort ? nameStyle.inputError : ""}`,
                label: t2("bitbox02Settings.deviceName.input"),
                onInput: (e3) => onInputChange(e3.target.value),
                placeholder: t2("bitbox02Settings.deviceName.placeholder"),
                value: name,
                id: "deviceName"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DeviceNameErrorMessage, { error: error3, invalidChars })
          ] })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            disabled: !!error3,
            onClick: handleUpdateName,
            children: t2("button.ok")
          }
        ) })
      ]
    }
  );
};
const SetDeviceNameWaitDialog = ({ inProgress }) => {
  const { t: t2 } = useTranslation();
  if (!inProgress) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { children: t2("bitbox02Interact.followInstructions") });
};
const settingNameContainer = "_settingNameContainer_usdew_1";
const settingName = "_settingName_usdew_1";
const styles$e = {
  settingNameContainer,
  settingName
};
const FactoryResetSetting = ({ deviceID }) => {
  const [understand, setUnderstand] = reactExports.useState(false);
  const [isConfirming, setIsConfirming] = reactExports.useState(false);
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const abort = () => {
    setUnderstand(false);
    setIsConfirming(false);
    setActiveDialog(false);
  };
  const handleUnderstandChange = (e3) => {
    setUnderstand(e3.target.checked);
  };
  const reset2 = async () => {
    setActiveDialog(false);
    setIsConfirming(true);
    const responseData = await resetDevice(deviceID);
    abort();
    if (!responseData.success) {
      alertUser(t2("reset.notReset"));
    }
  };
  const settingName2 = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$e.settingNameContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WarningOutlined, { width: 16, height: 16 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$e.settingName, children: t2("deviceSettings.expert.factoryReset.title") })
  ] });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        settingName: settingName2,
        secondaryText: t2("deviceSettings.expert.factoryReset.description"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, {}),
        onClick: () => setActiveDialog(true)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FactoryResetDialog,
      {
        open: activeDialog,
        handleCloseDialog: abort,
        isConfirming,
        understand,
        handleUnderstandChange,
        handleReset: reset2
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetWaitDialog, { isConfirming })
  ] });
};
const FactoryResetDialog = ({
  open: open2,
  handleCloseDialog,
  isConfirming,
  understand,
  handleUnderstandChange,
  handleReset
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Dialog,
    {
      open: open2,
      title: t2("reset.title"),
      onClose: handleCloseDialog,
      disabledClose: isConfirming,
      small: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "column", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("reset.description") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: "reset_understand",
              label: t2("reset.understandBB02"),
              checked: understand,
              onChange: handleUnderstandChange
            }
          ) })
        ] }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, disabled: !understand, onClick: handleReset, children: t2("reset.title") }) })
      ]
    }
  );
};
const FactoryResetWaitDialog = ({ isConfirming }) => {
  const { t: t2 } = useTranslation();
  if (!isConfirming) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TranslatedWaitDialog,
    {
      title: t2("reset.title"),
      children: t2("bitbox02Interact.followInstructions")
    }
  );
};
const RootFingerprintSetting = ({ rootFingerprint }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: "Root fingerprint",
      secondaryText: t2("deviceSettings.deviceInformation.rootFingerprint.description"),
      displayedValue: rootFingerprint
    }
  );
};
const section = "_section_18i3w_1";
const skeletonWrapper = "_skeletonWrapper_18i3w_9";
const styles$d = {
  section,
  skeletonWrapper
};
const getLink$1 = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/bitbox02/sicherheit/#device-authenticity-check";
    case "es":
      return "https://bitbox.swiss/es/bitbox02/seguridad/#device-authenticity-check";
    default:
      return "https://bitbox.swiss/bitbox02/security-features/#device-authenticity-check";
  }
};
const ManageDeviceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.device.name") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.secure-chip.link.text"),
        url: "https://bitbox.swiss/blog/bitbox-05-2021-masnee-update/#check-your-secure-chip-variant"
      },
      text: t2("guide.device.secure-chip.text"),
      title: t2("guide.device.secure-chip.title")
    } }, "guide.device.secure-chip"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.device.attestation.link.text"),
        url: getLink$1()
      },
      text: t2("guide.device.attestation.text"),
      title: t2("guide.device.attestation.title")
    } }, "guide.device.attestation")
  ] });
};
const container$a = "_container_1xwzi_1";
const backButton = "_backButton_1xwzi_7";
const headerText = "_headerText_1xwzi_27";
const styles$c = {
  container: container$a,
  backButton,
  headerText
};
const MobileHeader = ({ title: title2, withGuide = false }) => {
  const { t: t2 } = useTranslation();
  const handleClick = () => {
    route("/settings");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$c.container} ${withGuide ? `${styles$c.withGuide}` : ""}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { onClick: handleClick, className: styles$c.backButton, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeftDark, {}),
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.back") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: styles$c.headerText, children: title2 })
  ] });
};
const StyledSkeleton = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$d.skeletonWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, { fontSize: "var(--item-height-xlarge)" }) });
};
const BB02Settings = ({ deviceID, deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("sidebar.device") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: true,
          hasAccounts,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(Content, { deviceID })
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ManageDeviceGuide, {})
  ] }) });
};
const Content = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [deviceInfo, setDeviceInfo] = reactExports.useState();
  const versionInfo = useLoad(() => getVersion(deviceID), [deviceID]);
  const rootFingerprintResult = useLoad(() => getRootFingerprint(deviceID), [deviceID]);
  reactExports.useEffect(() => {
    getDeviceInfo(deviceID).then((result) => {
      if (!result.success) {
        alertUser(t2("genericError"));
        return;
      }
      setDeviceInfo(result.deviceInfo);
    }).catch(console.error);
  }, [deviceID, t2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.backups.title") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ManageBackupSetting, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ShowRecoveryWordsSetting, { deviceID })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("deviceSettings.deviceInformation.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeviceNameSetting,
        {
          deviceName: deviceInfo.name,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AttestationCheckSetting, { deviceID }),
      versionInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        FirmwareSetting,
        {
          deviceID,
          versionInfo
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      deviceInfo && deviceInfo.securechipModel !== "" ? /* @__PURE__ */ jsxRuntimeExports.jsx(SecureChipSetting, { secureChipModel: deviceInfo.securechipModel }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      rootFingerprintResult && rootFingerprintResult.success ? /* @__PURE__ */ jsxRuntimeExports.jsx(RootFingerprintSetting, { rootFingerprint: rootFingerprintResult.rootFingerprint }) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$d.section, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("settings.expert.title") }),
      deviceInfo ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        PassphraseSetting,
        {
          passphraseEnabled: deviceInfo.mnemonicPassphraseEnabled,
          deviceID
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(GoToStartupSettings, { deviceID }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(FactoryResetSetting, { deviceID })
    ] })
  ] });
};
const BitBox02 = ({ deviceID, deviceIDs, hasAccounts }) => {
  const status2 = useSync(
    () => getStatus$1(deviceID),
    (cb2) => statusChanged(deviceID, () => {
      getStatus$1(deviceID).then(cb2);
    })
  );
  if (status2 !== "initialized") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BB02Settings, { deviceID, deviceIDs, hasAccounts });
};
const getStatus = (deviceID) => {
  return apiGet(`devices/bitbox02-bootloader/${deviceID}/status`);
};
const syncStatus = (deviceID) => {
  return (cb2) => {
    return subscribeEndpoint(`devices/bitbox02-bootloader/${deviceID}/status`, cb2);
  };
};
const getVersionInfo = (deviceID) => {
  return apiGet(`devices/bitbox02-bootloader/${deviceID}/version-info`);
};
const upgradeFirmware = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/upgrade-firmware`);
};
const reboot = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/reboot`);
};
const screenRotate = (deviceID) => {
  return apiPost(`devices/bitbox02-bootloader/${deviceID}/screen-rotate`);
};
const getShowFirmwareHash = (deviceID) => {
  return () => {
    return apiGet(`devices/bitbox02-bootloader/${deviceID}/show-firmware-hash-enabled`);
  };
};
const setShowFirmwareHash = (deviceID, enabled) => {
  return apiPost(
    `devices/bitbox02-bootloader/${deviceID}/set-firmware-hash-enabled`,
    enabled
  );
};
const container$9 = "_container_18axn_1";
const style$l = {
  container: container$9
};
const CenteredContent = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "contentWithGuide", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$l.container, children: children2 }) });
};
const container$8 = "_container_14uup_1";
const slider = "_slider_14uup_16";
const style$k = {
  container: container$8,
  slider
};
const Toggle = ({
  className = "",
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("label", { className: `${style$k.container} ${className}`, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        ...props
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$k.slider })
  ] });
};
const ToggleShowFirmwareHash = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const [enabledState, setEnabledState] = reactExports.useState(false);
  const enabledConfig = useLoad(getShowFirmwareHash(deviceID));
  reactExports.useEffect(() => {
    if (enabledConfig !== void 0) {
      setEnabledState(enabledConfig);
    }
  }, [enabledConfig]);
  const handleToggle = (event2) => {
    const enabled = event2.target.checked;
    setShowFirmwareHash(deviceID, enabled);
    setEnabledState(enabled);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("bb02Bootloader.advanced.toggleShowFirmwareHash") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Toggle,
      {
        checked: enabledState,
        id: "togggle-show-firmware-hash",
        onChange: handleToggle
      }
    )
  ] });
};
const BitBox02Bootloader = ({ deviceID }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const status2 = useSync(
    () => getStatus(deviceID),
    syncStatus(deviceID)
  );
  const versionInfo = useLoad(() => getVersionInfo(deviceID));
  if (versionInfo === void 0) {
    return null;
  }
  let contents;
  if (status2 && status2.upgrading) {
    if (status2.upgradeSuccessful) {
      contents = /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "box large", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bb02Bootloader.success", {
        rebootSeconds: status2.rebootSeconds.toString(),
        context: versionInfo.erased ? "install" : ""
      }) }) });
    } else {
      const value = Math.round(status2.progress * 100);
      contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("progress", { value, max: "100", children: [
          value,
          "%"
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { style: { marginBottom: 0 }, children: t2("bootloader.progress", {
          progress: value.toString(),
          context: versionInfo.erased ? "install" : ""
        }) })
      ] });
    }
  } else {
    contents = /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", style: { minHeight: 390 }, children: [
      versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("welcome.getStarted") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "buttons", children: [
        versionInfo.canUpgrade ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: () => upgradeFirmware(deviceID),
            children: t2("bootloader.button", { context: versionInfo.erased ? "install" : "" })
          }
        ) : null,
        !versionInfo.erased && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            secondary: true,
            onClick: () => reboot(deviceID),
            children: t2("bb02Bootloader.abort", { context: !versionInfo.canUpgrade ? "noUpgrade" : "" })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-center", style: { marginTop: 32 }, children: [
        t2("bb02Bootloader.orientation"),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "a",
          {
            onClick: () => screenRotate(deviceID),
            style: { textDecoration: "underline", cursor: "pointer" },
            children: t2("bb02Bootloader.flipscreen")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("details", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("summary", { children: t2("bb02Bootloader.advanced.label") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ToggleShowFirmwareHash, { deviceID })
        ] })
      ] })
    ] });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CenteredContent, { children: [
    isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Inverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02$1, {}),
    status2 && status2.errMsg && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: status2.errMsg }),
    contents
  ] });
};
const Waiting = () => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("welcome.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "content padded narrow isVerticallyCentered", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogo, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "box large", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$n.waitingText, children: t2("welcome.insertDevice") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$n.waitingDescription, children: t2("welcome.insertBitBox02") })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, { children: isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSourceDark, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(SwissMadeOpenSource, {}) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.welcome"), shown: true }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.getDevice.link.text"),
          url: "https://bitbox.shop/"
        },
        text: t2("guide.waiting.getDevice.text"),
        title: t2("guide.waiting.getDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.waiting.lostDevice.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/5-backup/8-wie-kann-ich-ein-bitbox02-wallet-in-ein-drittanbieter-wallet-importieren" : "https://shiftcrypto.support/help/en-us/5-backup/8-how-do-i-restore-my-wallet-if-my-bitbox02-is-lost"
        },
        text: t2("guide.waiting.lostDevice.text"),
        title: t2("guide.waiting.lostDevice.title")
      } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.internet") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.deviceNotRecognized") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.waiting.useWithoutDevice") })
    ] })
  ] });
};
const DeviceSwitch = ({ deviceID, devices, hasAccounts }) => {
  const deviceIDs = Object.keys(devices);
  if (deviceID === null || !deviceIDs.includes(deviceID)) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
  switch (devices[deviceID]) {
    case "bitbox":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox01, { deviceID });
    case "bitbox02":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitBox02,
        {
          deviceID,
          deviceIDs,
          hasAccounts
        }
      );
    case "bitbox02-bootloader":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02Bootloader, { deviceID });
    default:
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Waiting, {});
  }
};
const getBackupList = (deviceID) => {
  return apiGet(`devices/bitbox02/${deviceID}/backups/list`);
};
const subscribeBackupList = (deviceID) => (cb2) => subscribeEndpoint(`devices/bitbox02/${deviceID}/backups/list`, cb2);
const toast = "_toast_4ztjp_1";
const active$1 = "_active_4ztjp_17";
const shifted = "_shifted_4ztjp_21";
const info = "_info_4ztjp_25";
const success$1 = "_success_4ztjp_29";
const warning$1 = "_warning_4ztjp_33";
const style$j = {
  toast,
  active: active$1,
  shifted,
  info,
  success: success$1,
  warning: warning$1
};
class Toast extends reactExports.Component {
  state = {
    active: false
  };
  componentDidMount() {
    setTimeout(this.show, 5);
  }
  show = () => {
    this.setState({ active: true });
  };
  hide = () => {
    this.setState({ active: false });
    if (this.props.onHide) {
      this.props.onHide();
    }
  };
  render() {
    const {
      theme,
      children: children2,
      withGuide
    } = this.props;
    const { active: active2 } = this.state;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        className: [style$j.toast, style$j[theme], active2 ? style$j.active : "", withGuide ? style$j.shifted : ""].join(" "),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: children2 })
      }
    );
  }
}
const Check2 = ({ deviceID, backups, disabled: disabled2 }) => {
  const [activeDialog, setActiveDialog] = reactExports.useState(false);
  const [message2, setMessage] = reactExports.useState("");
  const [foundBackup, setFoundBackup] = reactExports.useState();
  const [userVerified, setUserVerified] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const checkBackup$1 = async () => {
    setMessage(t2("backup.check.confirmTitle"));
    try {
      const result = await checkBackup(deviceID, true);
      if (result.success) {
        const { backupID: backupID2 } = result;
        const foundBackup2 = backups.find((backup2) => backup2.id === backupID2);
        if (!foundBackup2) {
          alertUser(t2("unknownError", { errorMessage: "Not found" }));
          return;
        }
        setActiveDialog(true);
        setFoundBackup(foundBackup2);
      }
      const check = await checkBackup(deviceID, false);
      if (!check.success) {
        setActiveDialog(true);
        setMessage(t2("backup.check.notOK"));
        setUserVerified(true);
        return;
      }
      setMessage(t2("backup.check.success"));
      setUserVerified(true);
    } catch (error3) {
      console.error(error3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        disabled: disabled2,
        onClick: checkBackup$1,
        children: t2("button.check")
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: activeDialog, title: message2, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: (e3) => {
      e3.preventDefault();
      setActiveDialog(false);
      setUserVerified(false);
    }, children: [
      foundBackup !== void 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BackupsListItem,
        {
          backup: foundBackup,
          radio: false
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: userVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          autoFocus: true,
          disabled: !userVerified,
          primary: true,
          type: "submit",
          children: userVerified ? t2("button.ok") : t2("accountInfo.verify")
        }
      ) })
    ] }) })
  ] });
};
const Create2 = ({ deviceID }) => {
  const [creatingBackup, setCreatingBackup] = reactExports.useState(false);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const createBackup$1 = () => {
    setCreatingBackup(true);
    createBackup(deviceID, "sdcard").then((result) => {
      setCreatingBackup(false);
      setDisabled(false);
      if (!result.success) {
        alertUser(t2("backup.create.fail"));
      }
    }).catch(console.error);
  };
  const maybeCreateBackup = async () => {
    setDisabled(true);
    try {
      const check = await checkBackup(deviceID, true);
      if (check.success) {
        confirmation(t2("backup.create.alreadyExists"), (result) => {
          if (result) {
            createBackup$1();
          } else {
            setDisabled(false);
          }
        });
        return;
      }
      createBackup$1();
    } catch (error3) {
      console.error(error3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        disabled: disabled2,
        onClick: maybeCreateBackup,
        children: t2("backup.create.title")
      }
    ),
    creatingBackup && /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("backup.create.title"), children: t2("bitbox02Interact.followInstructions") })
  ] });
};
const BackupsV2 = ({
  deviceID,
  showRestore,
  showCreate,
  showRadio,
  onSelectBackup,
  onRestoreBackup,
  children: children2
}) => {
  const { t: t2 } = useTranslation();
  const [selectedBackup, setSelectedBackup] = reactExports.useState();
  const [restoring, setRestoring] = reactExports.useState(false);
  const [errorText2, setErrorText] = reactExports.useState("");
  const backups = useSync(() => getBackupList(deviceID), subscribeBackupList(deviceID));
  const hasBackups = backups && backups.success && backups !== void 0;
  const hasMoreThanOneBackups = hasBackups && backups.backups.length > 1;
  reactExports.useEffect(() => {
    if (!hasBackups || backups.backups.length === 0) {
      return;
    }
    if (backups.backups.length === 1) {
      setSelectedBackup(backups.backups[0].id);
    }
  }, [backups, hasBackups]);
  const restore = () => {
    if (!hasBackups) {
      return;
    }
    if (!selectedBackup) {
      return;
    }
    const backup2 = backups.backups.find((b2) => b2.id === selectedBackup);
    if (!backup2) {
      return;
    }
    setRestoring(true);
    onSelectBackup && onSelectBackup(backup2);
    restoreBackup(deviceID, selectedBackup).then(({ success: success2 }) => {
      setRestoring(false);
      setErrorText(success2 ? "" : t2("backup.restore.error.general"));
      if (onRestoreBackup) {
        onRestoreBackup(success2);
      }
    });
  };
  if (!hasBackups) {
    if (hasBackups === void 0) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {});
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Error fetching backups" });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.stepContext, children: [
    errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Toast, { theme: "warning", children: errorText2 }),
    showRadio && hasMoreThanOneBackups ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none m-bottom-large", children: t2("backup.restore.subtitle") }) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.backupsList, children: backups.backups.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.listContainer, children: backups.backups.map((backup2) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: backupStyle.item, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      BackupsListItem,
      {
        disabled: restoring,
        backup: backup2,
        selectedBackup,
        handleChange: (b2) => setSelectedBackup(b2),
        onFocus: () => void 0,
        radio: showRadio
      }
    ) }, backup2.id)) }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.noBackups") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: backupStyle.backupButtons, children: [
      showRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          disabled: !selectedBackup || restoring,
          onClick: restore,
          children: t2("button.restore")
        }
      ),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(Create2, { deviceID }),
      showCreate && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Check2,
        {
          deviceID,
          backups: backups.backups ? backups.backups : [],
          disabled: backups.backups.length === 0
        }
      ),
      children2
    ] })
  ] }) });
};
const SDCardCheck = ({ deviceID, children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [sdCardInserted, setSdCardInserted] = reactExports.useState();
  const check = reactExports.useCallback(() => checkSDCard(deviceID).then(setSdCardInserted), [deviceID]);
  reactExports.useEffect(() => {
    check();
  }, [check]);
  if (sdCardInserted === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: !sdCardInserted ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: !sdCardInserted, title: "Check your device", small: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columnsContainer half", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "columns", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "column", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("backup.insert") }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: check,
          children: t2("button.ok")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ButtonLink,
        {
          secondary: true,
          to: `/settings/device-settings/${deviceID}`,
          children: t2("button.back")
        }
      )
    ] })
  ] }) : children2 });
};
class ManageBackups extends reactExports.Component {
  hasDevice = () => {
    return !!this.props.devices[this.props.deviceID];
  };
  UNSAFE_componentWillMount() {
    if (!this.hasDevice()) {
      route("/", true);
    }
  }
  backButton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ButtonLink,
      {
        secondary: true,
        to: `/settings/device-settings/${this.props.deviceID}`,
        children: this.props.t("button.back")
      }
    );
  };
  listBackups = () => {
    switch (this.props.devices[this.props.deviceID]) {
      case "bitbox":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          TranslatedBackups,
          {
            deviceID: this.props.deviceID,
            showCreate: true,
            showRestore: false,
            children: this.backButton()
          }
        );
      case "bitbox02":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SDCardCheck, { deviceID: this.props.deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID: this.props.deviceID,
            showCreate: true,
            showRestore: false,
            showRadio: false,
            children: this.backButton()
          }
        ) });
      default:
        return;
    }
  };
  renderGuide = (t2) => {
    switch (this.props.devices[this.props.deviceID]) {
      case "bitbox":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.whatIsABackup") }, "guide.backups.whatIsABackup"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.encrypt") }, "guide.backups.encrypt"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.check") }, "guide.backups.check"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
        ] });
      case "bitbox02":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.whatIsABackup") }, "guide.backupsBB02.whatIsABackup"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.encrypt"), shown: true }, "guide.backupsBB02.encrypt"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backupsBB02.check") }, "guide.backupsBB02.check"),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.backups.howOften") }, "guide.backups.howOften")
        ] });
      default:
        return null;
    }
  };
  render() {
    const { t: t2 } = this.props;
    if (!this.hasDevice()) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("backup.title") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "subTitle", children: t2("backup.list") }),
          this.listBackups()
        ] })
      ] }) }),
      this.renderGuide(t2)
    ] });
  }
}
const ManageBackups$1 = withTranslation()(ManageBackups);
const getCoinsLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://bitbox.swiss/de/coins/";
    case "es":
      return "https://bitbox.swiss/es/monedas/";
    default:
      return "https://bitbox.swiss/coins/";
  }
};
const AccountGuide$1 = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatAreAccounts") }, "whatAreAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whyIsThisUseful") }, "whyIsThisUseful"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.whatIsRememberWallet") }, "whatIsRememberWallet"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.recoverAccounts") }, "recoverAccounts"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.moveFunds") }, "moveFunds"),
    !hasOnlyBTCAccounts && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.accounts.supportedCoins.link.text"),
          url: getCoinsLink()
        },
        text: t2("guide.accounts.supportedCoins.text"),
        title: t2("guide.accounts.supportedCoins.title")
      } }, "supportedCoins"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howtoAddTokens") }, "howtoAddTokens")
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accounts.howManyAccounts") }, "howManyAccounts")
  ] });
};
const label$2 = "_label_g3ts4_1";
const labelText = "_labelText_g3ts4_5";
const style$i = {
  label: label$2,
  labelText
};
const WatchonlySetting = ({ keystore: keystore2 }) => {
  const { t: t2 } = useTranslation();
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [watchonly, setWatchonly$1] = reactExports.useState();
  const [warningDialogOpen, setWarningDialogOpen] = reactExports.useState(false);
  const config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      setWatchonly$1(keystore2.watchonly);
    }
  }, [config, keystore2]);
  const toggleWatchonly = async () => {
    if (!watchonly) {
      setDisabled(true);
      const { success: success2 } = await setWatchonly(keystore2.rootFingerprint, !watchonly);
      if (success2) {
        setWatchonly$1(!watchonly);
      }
      setDisabled(false);
      return;
    }
    setWarningDialogOpen(true);
    setDisabled(false);
  };
  const handleCloseDialog = () => {
    setWarningDialogOpen(false);
    setDisabled(false);
  };
  const handleConfirmDisableWatchonly = async () => {
    setDisabled(true);
    await setWatchonly(keystore2.rootFingerprint, false);
    setWatchonly$1(false);
    setDisabled(false);
    setWarningDialogOpen(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("newSettings.appearance.remebmerWallet.warningTitle"), medium: true, onClose: handleCloseDialog, open: warningDialogOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.remebmerWallet.warning") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: handleConfirmDisableWatchonly, children: t2("dialog.confirm") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: handleCloseDialog, children: t2("dialog.cancel") })
      ] })
    ] }),
    watchonly !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { className: style$i.label, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$i.labelText, children: t2("newSettings.appearance.remebmerWallet.name") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: watchonly,
          disabled: disabled2,
          onChange: toggleWatchonly
        }
      )
    ] }) : null
  ] });
};
const addAccountBtn = "_addAccountBtn_b53x1_2";
const accountNameInactive = "_accountNameInactive_b53x1_6";
const disabledText = "_disabledText_b53x1_10";
const walletHeader = "_walletHeader_b53x1_15";
const walletTitle = "_walletTitle_b53x1_23";
const setting = "_setting_b53x1_34";
const coinLogo = "_coinLogo_b53x1_48";
const acccountLink = "_acccountLink_b53x1_53";
const editBtn = "_editBtn_b53x1_61";
const toggleLabel$1 = "_toggleLabel_b53x1_73";
const toggleLabelText = "_toggleLabelText_b53x1_79";
const toggle$1 = "_toggle_b53x1_73";
const accountActive = "_accountActive_b53x1_96";
const tokenSection = "_tokenSection_b53x1_100";
const tokenContainer = "_tokenContainer_b53x1_109";
const tokenContainerOpen = "_tokenContainerOpen_b53x1_116";
const token$1 = "_token_b53x1_100";
const tokenIcon = "_tokenIcon_b53x1_158";
const tokenName = "_tokenName_b53x1_163";
const tokenInactive = "_tokenInactive_b53x1_169";
const expandBtn = "_expandBtn_b53x1_174";
const expandBtnOpen = "_expandBtnOpen_b53x1_182";
const watchOnlyContainer = "_watchOnlyContainer_b53x1_195";
const watchOnlyNote = "_watchOnlyNote_b53x1_202";
const watchOnlyAccountHidden = "_watchOnlyAccountHidden_b53x1_207";
const style$h = {
  addAccountBtn,
  accountNameInactive,
  disabledText,
  walletHeader,
  walletTitle,
  setting,
  coinLogo,
  acccountLink,
  editBtn,
  toggleLabel: toggleLabel$1,
  toggleLabelText,
  toggle: toggle$1,
  accountActive,
  tokenSection,
  tokenContainer,
  tokenContainerOpen,
  token: token$1,
  tokenIcon,
  tokenName,
  tokenInactive,
  expandBtn,
  expandBtnOpen,
  watchOnlyContainer,
  watchOnlyNote,
  watchOnlyAccountHidden
};
class ManageAccounts extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      editErrorMessage: void 0,
      showTokens: {},
      currentlyEditedAccount: void 0
    };
    this.renderAccounts = (accounts) => {
      const { showTokens } = this.state;
      const { t: t2 } = this.props;
      return accounts.filter((account2) => !account2.isToken).map((account2) => {
        var _a;
        const active2 = account2.active;
        const tokensVisible = showTokens[account2.code];
        return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.setting, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "div",
            {
              className: `${style$h.acccountLink} ${active2 ? style$h.accountActive : ""}`,
              onClick: () => active2 && route(`/account/${account2.code}`),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: true, active: account2.active, className: `${style$h.coinLogo} m-right-half`, coinCode: account2.coinCode, alt: account2.coinUnit }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: !account2.active ? style$h.accountNameInactive : "", children: [
                  account2.name,
                  " ",
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "unit", children: [
                    "(",
                    account2.coinUnit,
                    ")"
                  ] })
                ] })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-items-center", children: [
            !account2.active ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `text-small ${style$h.disabledText}`, children: t2("generic.enabled_false") }) : null,
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                className: style$h.editBtn,
                onClick: () => this.setState({ currentlyEditedAccount: account2 }),
                transparent: true,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(EditActive, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "hide-on-small", children: t2("manageAccounts.editAccount") })
                ]
              }
            )
          ] }),
          active2 && account2.coinCode === "eth" ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.tokenSection, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$h.tokenContainer} ${tokensVisible ? style$h.tokenContainerOpen : ""}`, children: this.renderTokens(account2.code, account2.activeTokens) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                className: `${style$h.expandBtn} ${tokensVisible ? style$h.expandBtnOpen : ""}`,
                onClick: () => this.toggleShowTokens(account2.code),
                transparent: true,
                children: t2(tokensVisible ? "manageAccounts.settings.hideTokens" : "manageAccounts.settings.showTokens", {
                  activeTokenCount: `${((_a = account2.activeTokens) == null ? void 0 : _a.length) || 0}`
                })
              }
            )
          ] }) : null
        ] }, account2.code);
      });
    };
    this.toggleAccount = (accountCode, active2) => {
      return setAccountActive(accountCode, active2).then(({ success: success2, errorMessage: errorMessage2 }) => {
        if (!success2 && errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.toggleShowTokens = (accountCode) => {
      this.setState(({ showTokens }) => ({
        showTokens: {
          ...showTokens,
          [accountCode]: accountCode in showTokens ? !showTokens[accountCode] : true
        }
      }));
    };
    this.erc20Tokens = [
      { code: "eth-erc20-usdt", name: "Tether USD", unit: "USDT" },
      { code: "eth-erc20-usdc", name: "USD Coin", unit: "USDC" },
      { code: "eth-erc20-link", name: "Chainlink", unit: "LINK" },
      { code: "eth-erc20-bat", name: "Basic Attention Token", unit: "BAT" },
      { code: "eth-erc20-mkr", name: "Maker", unit: "MKR" },
      { code: "eth-erc20-zrx", name: "0x", unit: "ZRX" },
      { code: "eth-erc20-wbtc", name: "Wrapped Bitcoin", unit: "WBTC" },
      { code: "eth-erc20-paxg", name: "Pax Gold", unit: "PAXG" },
      { code: "eth-erc20-dai0x6b17", name: "Dai", unit: "DAI" }
    ];
    this.renderTokens = (ethAccountCode, activeTokens) => {
      return this.erc20Tokens.map((token2) => {
        const activeToken = (activeTokens || []).find((t2) => t2.tokenCode === token2.code);
        const active2 = activeToken !== void 0;
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "div",
          {
            className: `${style$h.token} ${!active2 ? style$h.tokenInactive : ""}`,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `${style$h.acccountLink} ${active2 ? style$h.accountActive : ""}`,
                  onClick: () => activeToken !== void 0 && route(`/account/${activeToken.accountCode}`),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Logo,
                      {
                        active: active2,
                        alt: token2.name,
                        className: style$h.tokenIcon,
                        coinCode: token2.code,
                        stacked: true
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$h.tokenName, children: [
                      token2.name,
                      " (",
                      token2.unit,
                      ")"
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Toggle,
                {
                  checked: active2,
                  className: style$h.toggle,
                  id: token2.code,
                  onChange: () => this.toggleToken(ethAccountCode, token2.code, !active2)
                }
              )
            ]
          },
          token2.code
        );
      });
    };
    this.toggleToken = (ethAccountCode, tokenCode, active2) => {
      setTokenActive(ethAccountCode, tokenCode, active2).then(({ success: success2, errorMessage: errorMessage2 }) => {
        if (!success2 && errorMessage2) {
          alertUser(errorMessage2);
        }
      });
    };
    this.updateAccount = (event2) => {
      event2.preventDefault();
      const { accounts } = this.props;
      const { currentlyEditedAccount } = this.state;
      if (!currentlyEditedAccount) {
        return;
      }
      renameAccount(currentlyEditedAccount.code, currentlyEditedAccount.name).then((result) => {
        if (!result.success) {
          if (result.errorCode) {
            this.setState({ editErrorMessage: this.props.t(`error.${result.errorCode}`) });
          } else if (result.errorMessage) {
            this.setState({ editErrorMessage: result.errorMessage });
          }
          return;
        }
        const account2 = accounts.find(({ code }) => currentlyEditedAccount.code === code);
        if (currentlyEditedAccount.active !== (account2 == null ? void 0 : account2.active)) {
          this.toggleAccount(currentlyEditedAccount.code, currentlyEditedAccount.active);
        }
        this.setState({
          editErrorMessage: void 0,
          currentlyEditedAccount: void 0
        });
      });
    };
  }
  render() {
    const { t: t2, accounts, deviceIDs, hasAccounts } = this.props;
    const { editErrorMessage, currentlyEditedAccount } = this.state;
    const accountsByKeystore = getAccountsByKeystore(accounts);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Header,
          {
            hideSidebarToggler: true,
            title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("settings.title") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("manageAccounts.title") })
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { deviceIDs, hideMobileMenu: true, hasAccounts, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              className: style$h.addAccountBtn,
              primary: true,
              onClick: () => route("/add-account", true),
              children: t2("addAccount.title")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", children: accountsByKeystore.map((keystore2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Column,
            {
              asCard: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$h.walletHeader, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { className: style$h.walletTitle, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                      keystore2.keystore.name,
                      isAmbiguiousName(keystore2.keystore.name, accountsByKeystore) ? (
                        // Disambiguate accounts group by adding the fingerprint.
                        // The most common case where this would happen is when adding accounts from the
                        // same seed using different passphrases.
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                          " ",
                          keystore2.keystore.rootFingerprint
                        ] })
                      ) : null
                    ] }),
                    keystore2.keystore.connected ? /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Badge,
                      {
                        className: "m-right-quarter",
                        icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                        type: "success",
                        children: t2("device.keystoreConnected")
                      }
                    ) : null
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(WatchonlySetting, { keystore: keystore2.keystore })
                ] }),
                this.renderAccounts(keystore2.accounts)
              ]
            },
            keystore2.keystore.rootFingerprint
          )) }),
          currentlyEditedAccount && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Dialog,
            {
              open: !!currentlyEditedAccount,
              onClose: () => this.setState({ currentlyEditedAccount: void 0 }),
              title: t2("manageAccounts.editAccountNameTitle"),
              children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: this.updateAccount, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Message, { type: "error", hidden: !editErrorMessage, children: editErrorMessage }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input$2,
                  {
                    onInput: (e3) => this.setState({ currentlyEditedAccount: { ...currentlyEditedAccount, name: e3.target.value } }),
                    value: currentlyEditedAccount.name
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    className: style$h.toggleLabel,
                    htmlFor: currentlyEditedAccount.code,
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$h.toggleLabelText, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(EyeOpenedDark, {}),
                        t2("newSettings.appearance.enableAccount.title")
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        Toggle,
                        {
                          checked: currentlyEditedAccount.active,
                          className: style$h.toggle,
                          id: currentlyEditedAccount.code,
                          onChange: (event2) => {
                            event2.target.disabled = true;
                            this.setState({
                              currentlyEditedAccount: {
                                ...currentlyEditedAccount,
                                active: event2.target.checked
                              }
                            }, () => event2.target.disabled = false);
                          }
                        }
                      )
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("newSettings.appearance.enableAccount.description") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Button,
                  {
                    disabled: !currentlyEditedAccount.name,
                    primary: true,
                    type: "submit",
                    children: t2("button.update")
                  }
                ) })
              ] })
            }
          )
        ] }) }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AccountGuide$1, { accounts })
    ] });
  }
}
const HOC$1 = translate()(ManageAccounts);
const title$2 = "_title_ahh86_1";
const resetLink = "_resetLink_ahh86_7";
const serversContainer = "_serversContainer_ahh86_11";
const servers = "_servers_ahh86_11";
const server = "_server_ahh86_11";
const serverLabel = "_serverLabel_ahh86_32";
const primary = "_primary_ahh86_82";
const warning = "_warning_ahh86_93";
const textarea$1 = "_textarea_ahh86_104";
const block = "_block_ahh86_112";
const addServer = "_addServer_ahh86_116";
const badge$1 = "_badge_ahh86_140";
const miniSpinnerContainer = "_miniSpinnerContainer_ahh86_152";
const miniSpinner = "_miniSpinner_ahh86_152";
const changeContent$1 = "_changeContent_ahh86_1";
const style$g = {
  title: title$2,
  resetLink,
  serversContainer,
  servers,
  server,
  serverLabel,
  primary,
  warning,
  textarea: textarea$1,
  block,
  addServer,
  badge: badge$1,
  miniSpinnerContainer,
  miniSpinner,
  changeContent: changeContent$1
};
const ElectrumAddServer = ({
  onAdd
}) => {
  const { t: t2 } = useTranslation();
  const [valid, setValid] = reactExports.useState();
  const [electrumServer, setElectrumServer] = reactExports.useState("");
  const [electrumCert, setElectrumCert] = reactExports.useState("");
  const [loadingCheck, setLoadingCheck] = reactExports.useState(false);
  const [loadingCert, setLoadingCert] = reactExports.useState(false);
  const getServer = () => {
    return {
      server: electrumServer.trim(),
      pemCert: electrumCert,
      tls: electrumCert !== ""
    };
  };
  const add = () => {
    onAdd(getServer());
    setElectrumServer("");
    setElectrumCert("");
  };
  const downloadCert = async () => {
    setLoadingCert(true);
    const data = await apiPost("certs/download", electrumServer.trim());
    if (data.success) {
      setElectrumCert(data.pemCert);
    } else {
      alertUser(data.errorMessage);
    }
    setLoadingCert(false);
  };
  const check = async () => {
    setLoadingCheck(true);
    const { success: success2, errorMessage: errorMessage2 } = await apiPost("electrum/check", getServer());
    if (success2) {
      alertUser(t2("settings.electrum.checkSuccess", { host: electrumServer }));
    } else {
      alertUser(t2("settings.electrum.checkFailed") + ":\n" + errorMessage2);
    }
    setValid(success2);
    setLoadingCheck(false);
  };
  const downloadCertButtonDisabled = electrumServer.trim().length === 0 || electrumCert.trim().length > 0 || loadingCert;
  const checkConnectionButtonDisabled = electrumServer.trim().length === 0 || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.addServer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step1-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        name: "electrumServer",
        onInput: (event2) => setElectrumServer(event2.target.value),
        value: electrumServer,
        placeholder: "host:port"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step2-text-tcp") })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: style$g.textarea,
        rows: 10,
        cols: 80,
        name: "electrumCert",
        onInput: (event2) => setElectrumCert(event2.target.value),
        value: electrumCert,
        placeholder: "-----BEGIN CERTIFICATE-----\n...\n-----END CERTIFICATE-----"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$g.block, "flex flex-row flex-end"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: true, disabled: downloadCertButtonDisabled, onClick: downloadCert, children: [
      loadingCert && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
      t2("settings.electrum.download-cert")
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step3-text") }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: ["flex flex-row flex-end spaced", style$g.block].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { primary: true, disabled: checkConnectionButtonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
        loadingCheck ? t2("settings.electrum.checking") : t2("settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, disabled: !valid, onClick: add, children: t2("settings.electrum.add-server") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-start flex-wrap", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$g.badge, children: t2("settings.electrum.step4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("settings.electrum.step4-text") }) })
    ] })
  ] });
};
const ElectrumServer = ({
  onRemove,
  server: server2
}) => {
  const { t: t2 } = useTranslation();
  const [loadingCheck, setLoadingCheck] = reactExports.useState(false);
  const check = async () => {
    setLoadingCheck(true);
    const { success: success2, errorMessage: errorMessage2 } = await apiPost("electrum/check", {
      server: server2.server.trim(),
      pemCert: server2.pemCert,
      tls: server2.tls
    });
    if (success2) {
      alertUser(t2("settings.electrum.checkSuccess", { host: server2.server }));
    } else {
      alertUser(t2("settings.electrum.checkFailed") + ":\n" + errorMessage2);
    }
    setLoadingCheck(false);
  };
  const buttonDisabled = server2.server === "" || server2.tls && server2.pemCert === "" || loadingCheck;
  return /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.server, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.serverLabel, children: [
      server2.server,
      " ",
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: server2.tls ? "TLS" : "TCP" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("button", { className: style$g.primary, disabled: buttonDisabled, onClick: check, children: [
        loadingCheck && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinnerContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$g.miniSpinner }) }),
        loadingCheck ? t2("settings.electrum.checking") : t2("settings.electrum.check")
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$g.warning, onClick: onRemove, children: t2("settings.electrum.remove-server") })
    ] })
  ] }) });
};
const ElectrumServers = ({
  coin
}) => {
  const { t: t2 } = useTranslation();
  const [config, setConfigState] = reactExports.useState();
  const loadConfig = () => {
    getConfig().then(setConfigState);
  };
  reactExports.useEffect(loadConfig, []);
  if (config === void 0) {
    return null;
  }
  const electrumServers = config.backend[coin].electrumServers;
  const save = async (newElectrumServers) => {
    const currentConfig = await getConfig();
    currentConfig.backend[coin].electrumServers = newElectrumServers;
    await setConfig(currentConfig);
    setConfigState(currentConfig);
  };
  const onAdd = (server2) => {
    let newElectrumServers = [...electrumServers, server2];
    save(newElectrumServers);
  };
  const onRemove = (index2) => {
    let newElectrumServers = [...electrumServers];
    newElectrumServers.splice(index2, 1);
    save(newElectrumServers);
  };
  const resetToDefault = () => {
    confirmation(t2("settings.electrum.resetConfirm"), (response) => {
      if (response) {
        getDefaultConfig().then((config2) => {
          save(config2.backend[coin].electrumServers);
        });
      }
    });
  };
  const onRemoveCb = (server2, index2) => () => {
    confirmation(t2("settings.electrum.removeConfirm", { server: server2.server }), (confirmed) => {
      if (confirmed) {
        onRemove(index2);
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$g.serversContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.servers") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            transparent: true,
            className: style$g.resetLink,
            onClick: resetToDefault,
            children: t2("settings.electrum.reset")
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: style$g.servers, children: electrumServers.map((server2, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        ElectrumServer,
        {
          server: server2,
          onRemove: onRemoveCb(server2, index2)
        },
        server2.server + server2.tls.toString() + "-" + index2.toString()
      )) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("hr", {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "row", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h4", { className: "subTitle", children: t2("settings.electrum.add") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumAddServer, { onAdd })
    ] })
  ] });
};
const ElectrumSettings = () => {
  const { t: t2 } = useTranslation();
  const [activeTab, setActiveTab] = reactExports.useState("btc");
  const testing = useLoad(() => getTesting());
  const handleTab = (e3) => {
    const selectedTab = e3.currentTarget.getAttribute("data-tab");
    if (selectedTab !== "btc" && selectedTab !== "ltc") {
      console.error("Unrecognized tab ID");
      return;
    }
    setActiveTab(selectedTab);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "container", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "innerContainer scrollableContainer", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.expert.electrum.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center tabs", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "btc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "btc", children: t2(`settings.electrum.title-${testing ? "tbtc" : "btc"}`) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: ["tab", activeTab === "ltc" ? "active" : ""].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("a", { href: "#", onClick: handleTab, "data-tab": "ltc", children: t2(`settings.electrum.title-${testing ? "tltc" : "ltc"}`) }) })
        ] }),
        activeTab === "btc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tbtc" : "btc"
          },
          testing ? "tbtc" : "btc"
        ),
        activeTab === "ltc" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ElectrumServers,
          {
            coin: testing ? "tltc" : "ltc"
          },
          testing ? "tltc" : "ltc"
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { marginBottom: 20 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          ButtonLink,
          {
            secondary: true,
            to: "/settings",
            children: t2("button.back")
          }
        ) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.what") }, "guide.settings-electrum.what"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.options") }, "guide.settings-electrum.options"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.connection") }, "guide.settings-electrum.connection"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor"),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
        link: {
          text: t2("guide.settings-electrum.instructions.link.text"),
          url: instance.resolvedLanguage === "de" ? "https://shiftcrypto.support/help/de-de/14-privatsphare/29-verbindung-der-bitboxapp-zu-meinem-bitcoin-full-node" : "https://shiftcrypto.support/help/en-us/14-privacy/29-how-to-connect-the-bitboxapp-to-my-own-full-node"
        },
        text: t2("guide.settings-electrum.instructions.text"),
        title: t2("guide.settings-electrum.instructions.title")
      } }, "guide.settings-electrum.instructions")
    ] })
  ] });
};
const INFO_STEPS_ENABLE = 5;
const INFO_STEPS_DISABLE = 0;
const CONTENT_MIN_HEIGHT = "38em";
class Passphrase extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      infoStep: 0,
      status: "info",
      understood: false
    };
    this.togglePassphrase = async () => {
      const { deviceID, t: t2 } = this.props;
      const enable = !this.state.passphraseEnabled;
      this.setState({ status: "progress" });
      try {
        const result = await setMnemonicPassphraseEnabled(deviceID, enable);
        if (!result.success) {
          route(`/settings/device-settings/${deviceID}`);
          alertUser(t2(`passphrase.error.e${result.code}`, {
            defaultValue: result.message || t2("genericError")
          }));
          return;
        }
        const deviceInfoResult = await getDeviceInfo(deviceID);
        if (deviceInfoResult.success) {
          this.setState({
            passphraseEnabled: deviceInfoResult.deviceInfo.mnemonicPassphraseEnabled,
            status: "success"
          });
        }
      } catch (error3) {
        console.error(error3);
      }
    };
    this.stopInfo = () => route(`/settings/device-settings/${this.props.deviceID}`);
    this.continueInfo = () => {
      if (this.state.infoStep === 0) {
        this.togglePassphrase();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep - 1 }));
    };
    this.backInfo = () => {
      if (this.state.infoStep === void 0) {
        return;
      }
      const enabled = this.state.passphraseEnabled;
      if (!enabled && this.state.infoStep >= INFO_STEPS_ENABLE || enabled && this.state.infoStep >= INFO_STEPS_DISABLE) {
        this.stopInfo();
        return;
      }
      this.setState(({ infoStep }) => ({ infoStep: infoStep + 1 }));
    };
    this.renderEnableInfo = () => {
      const { infoStep, understood } = this.state;
      const { t: t2 } = this.props;
      switch (infoStep) {
        case 5:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.intro.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.intro.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.what.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-intro"
          );
        case 4:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.what.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.what.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.why.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-what"
          );
        case 3:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.why.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.why.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.considerations.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-why"
          );
        case 2:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.considerations.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.considerations.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.how.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-considerations"
          );
        case 1:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.how.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.how.message") }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.summary.button") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-how"
          );
        case 0:
          return /* @__PURE__ */ jsxRuntimeExports.jsxs(
            View,
            {
              fullscreen: true,
              minHeight: CONTENT_MIN_HEIGHT,
              onClose: this.stopInfo,
              verticallyCentered: true,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.summary.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.0") }, "info-1"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.1") }, "info-2"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.2") }, "info-3"),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.summary.understandList.3") }, "info-4")
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: understood ? "success" : "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Checkbox,
                    {
                      onChange: (e3) => {
                        var _a;
                        return this.setState({ understood: (_a = e3.target) == null ? void 0 : _a.checked });
                      },
                      id: "understood",
                      checked: understood,
                      label: t2("passphrase.summary.understand"),
                      checkboxStyle: understood ? "success" : "warning"
                    }
                  ) })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, disabled: !understood, children: t2("passphrase.enable") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
                ] })
              ]
            },
            "step-summary"
          );
        default:
          console.error(`invalid infoStep ${infoStep}`);
          return;
      }
    };
    this.renderDisableInfo = () => {
      const { t: t2 } = this.props;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          minHeight: CONTENT_MIN_HEIGHT,
          onClose: this.stopInfo,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("passphrase.disable") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("passphrase.disableInfo.message") }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: this.continueInfo, children: t2("passphrase.disableInfo.button") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: this.backInfo, children: t2("button.back") })
            ] })
          ]
        },
        "step-disable-info1"
      );
    };
  }
  componentDidMount() {
    getDeviceInfo(this.props.deviceID).then((result) => {
      if (!result.success) {
        console.error(result.message);
        alertUser(this.props.t("genericError"));
        return;
      }
      const { mnemonicPassphraseEnabled } = result.deviceInfo;
      this.setState({
        // before enabling/disabling we show 1 or more pages to inform about the feature
        // each page has a continue button that jumps to the next or finally toggles passphrase
        // infoStep counts down in decreasing order
        infoStep: mnemonicPassphraseEnabled ? INFO_STEPS_DISABLE : INFO_STEPS_ENABLE,
        passphraseEnabled: mnemonicPassphraseEnabled
      });
    }).catch(console.error);
  }
  render() {
    const { t: t2 } = this.props;
    const { passphraseEnabled, status: status2 } = this.state;
    if (passphraseEnabled === void 0) {
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      status2 === "info" && (passphraseEnabled ? this.renderDisableInfo() : this.renderEnableInfo()),
      status2 === "progress" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          minHeight: CONTENT_MIN_HEIGHT,
          textCenter: true,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                title: t2(passphraseEnabled ? "passphrase.progressDisable.title" : "passphrase.progressEnable.title"),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SimpleMarkup,
                  {
                    tagName: "p",
                    markup: t2(passphraseEnabled ? "passphrase.progressDisable.message" : "passphrase.progressEnable.message")
                  }
                )
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
          ]
        },
        "progress"
      ),
      status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fullscreen: true,
          verticallyCentered: true,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ViewHeader,
              {
                small: true,
                title: t2(passphraseEnabled ? "passphrase.successDisabled.title" : "passphrase.successEnabled.title")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2(passphraseEnabled ? "passphrase.successDisabled.message" : "passphrase.successEnabled.message") }),
              passphraseEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { style: { paddingLeft: "var(--space-default)" }, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.0") }, "tip-1"),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "li", markup: t2("passphrase.successEnabled.tipsList.1") }, "tip-2")
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2(
                passphraseEnabled ? "passphrase.successDisabled.messageEnd" : "passphrase.successEnabled.messageEnd"
              ) })
            ] })
          ]
        },
        "progress"
      )
    ] });
  }
}
const HOC = translate()(Passphrase);
const getBitsuranceURL = () => {
  return apiGet("bitsurance/url");
};
const bitsuranceLookup = (code = "") => {
  return apiPost("bitsurance/lookup", { code });
};
const syncContainer = "_syncContainer_nrzbt_1";
const progressBar = "_progressBar_nrzbt_8";
const progressValue = "_progressValue_nrzbt_14";
const syncMessage = "_syncMessage_nrzbt_21";
const syncText = "_syncText_nrzbt_33";
const spinnerContainer = "_spinnerContainer_nrzbt_39";
const spinner = "_spinner_nrzbt_39";
const changeContent = "_changeContent_nrzbt_1";
const style$f = {
  syncContainer,
  progressBar,
  progressValue,
  syncMessage,
  syncText,
  spinnerContainer,
  spinner,
  changeContent
};
const HeadersSync = ({ coinCode }) => {
  const { i18n, t: t2 } = useTranslation();
  const status2 = useSubscribe(subscribeCoinHeaders(coinCode));
  const [hidden, setHidden] = reactExports.useState(false);
  const mounted = useMountedRef();
  reactExports.useEffect(() => {
    if (mounted.current && status2 && status2.tip === status2.targetHeight) {
      setTimeout(() => setHidden(true), 4e3);
    }
  }, [mounted, status2]);
  if (!status2 || hidden) {
    return null;
  }
  const total2 = status2.targetHeight - status2.tipAtInitTime;
  const value = 100 * (status2.tip - status2.tipAtInitTime) / total2;
  const loaded = !total2 || value >= 100;
  const formatted = new Intl.NumberFormat(i18n.language).format(status2.tip);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncMessage, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$f.syncText, children: [
        t2("headerssync.blocksSynced", { blocks: formatted }),
        " ",
        !loaded && `(${Math.ceil(value)}%)`
      ] }),
      !loaded ? /* @__PURE__ */ jsxRuntimeExports.jsx(AsciiSpinner, {}) : null
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { "data-testid": "progress-bar", className: style$f.progressBar, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$f.progressValue, style: { width: `${value}%` } }) })
  ] });
};
const container$7 = "_container_13974_1";
const background = "_background_13974_6";
const foreground = "_foreground_13974_7";
const complete = "_complete_13974_19";
const pending = "_pending_13974_23";
const generic = "_generic_13974_24";
const error2 = "_error_13974_28";
const style$e = {
  container: container$7,
  background,
  foreground,
  complete,
  pending,
  generic,
  error: error2
};
const ProgressRing = ({
  className,
  generic: generic2,
  isComplete,
  isError,
  value,
  width
}) => {
  const radius = (width - 3) / 2;
  const circumference = radius * 2 * Math.PI;
  const progress = isError ? 100 : value / 100;
  const offset = circumference * (1 - progress);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "svg",
    {
      className: [style$e.container, className ? className : ""].join(" "),
      width,
      height: width,
      style: { minWidth: width },
      viewBox: `0 0 ${width} ${width}`,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: style$e.background,
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "circle",
          {
            className: [
              style$e.foreground,
              !generic2 && isComplete ? style$e.complete : style$e.pending,
              generic2 && style$e.generic,
              isError && style$e.error
            ].join(" "),
            cx: width / 2,
            cy: width / 2,
            r: radius,
            strokeWidth: 3,
            strokeDashoffset: offset,
            strokeDasharray: circumference
          }
        )
      ]
    }
  );
};
const txArrowType = "_txArrowType_m24u9_1";
const txArrowTypeIn = "_txArrowTypeIn_m24u9_6";
const txArrowTypeOut = "_txArrowTypeOut_m24u9_10";
const txArrowTypeSelf = "_txArrowTypeSelf_m24u9_14";
const style$d = {
  txArrowType,
  txArrowTypeIn,
  txArrowTypeOut,
  txArrowTypeSelf
};
const ArrowIn = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeIn}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "5", x2: "12", y2: "19" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "19 12 12 19 5 12" })
    ]
  }
);
const ArrowOut = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeOut}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "12", y1: "19", x2: "12", y2: "5" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "5 12 12 5 19 12" })
    ]
  }
);
const ArrowSelf = () => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  "svg",
  {
    className: `${style$d.txArrowType} ${style$d.txArrowTypeSelf}`,
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    strokeWidth: "2",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("line", { x1: "5", y1: "12", x2: "19", y2: "12" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("polyline", { points: "12 5 19 12 12 19" })
    ]
  }
);
const container$6 = "_container_j1azs_1";
const row$1 = "_row_j1azs_5";
const date$1 = "_date_j1azs_15";
const address$1 = "_address_j1azs_19";
const badge = "_badge_j1azs_24";
const statusIndicator = "_statusIndicator_j1azs_29";
const statusIndicatorComplete = "_statusIndicatorComplete_j1azs_37";
const statusIndicatorPending = "_statusIndicatorPending_j1azs_41";
const statusIndicatorFailed = "_statusIndicatorFailed_j1azs_45";
const status$1 = "_status_j1azs_29";
const fiat$1 = "_fiat_j1azs_53";
const amount = "_amount_j1azs_57";
const amountOverflow = "_amountOverflow_j1azs_62";
const send$1 = "_send_j1azs_74";
const receive$1 = "_receive_j1azs_78";
const failed$1 = "_failed_j1azs_82";
const currency$1 = "_currency_j1azs_86";
const currencyUnit = "_currencyUnit_j1azs_90";
const action$1 = "_action_j1azs_101";
const label$1 = "_label_j1azs_112";
const columnLabel = "_columnLabel_j1azs_117";
const inlineLabel = "_inlineLabel_j1azs_118";
const inlineValue = "_inlineValue_j1azs_132";
const fee = "_fee_j1azs_136";
const transactionId = "_transactionId_j1azs_140";
const detail = "_detail_j1azs_145";
const detailInput = "_detailInput_j1azs_146";
const textOnlyInput = "_textOnlyInput_j1azs_163";
const editButton = "_editButton_j1azs_171";
const addresses = "_addresses_j1azs_211";
const detailAddresses = "_detailAddresses_j1azs_222";
const detailAddress = "_detailAddress_j1azs_222";
const first = "_first_j1azs_235";
const style$c = {
  container: container$6,
  row: row$1,
  date: date$1,
  address: address$1,
  badge,
  statusIndicator,
  statusIndicatorComplete,
  statusIndicatorPending,
  statusIndicatorFailed,
  status: status$1,
  fiat: fiat$1,
  amount,
  amountOverflow,
  send: send$1,
  receive: receive$1,
  failed: failed$1,
  currency: currency$1,
  currencyUnit,
  action: action$1,
  label: label$1,
  columnLabel,
  inlineLabel,
  inlineValue,
  fee,
  transactionId,
  detail,
  detailInput,
  textOnlyInput,
  editButton,
  addresses,
  detailAddresses,
  detailAddress,
  first
};
function Note({ accountCode, note: note2, internalID }) {
  const { isDarkMode } = useDarkmode();
  const { t: t2 } = useTranslation();
  const [newNote, setNewNote] = reactExports.useState(note2);
  const [editMode, setEditMode] = reactExports.useState(!note2);
  const inputRef = reactExports.useRef(null);
  const editButtonRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (editMode && inputRef.current) {
      inputRef.current.focus();
    }
  }, [editMode]);
  const handleNoteInput = (e3) => {
    const target = e3.target;
    setNewNote(target.value);
  };
  const handleEdit = (e3) => {
    e3.preventDefault();
    if (editMode && note2 !== newNote) {
      postNotesTx(accountCode, {
        internalTxID: internalID,
        note: newNote
      }).catch(console.error);
    }
    setEditMode(!editMode);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleEdit, className: style$c.detailInput, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "note", children: t2("note.title") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$2,
      {
        align: "right",
        autoFocus: editMode,
        className: style$c.textOnlyInput,
        readOnly: !editMode,
        type: "text",
        id: "note",
        transparent: true,
        placeholder: t2("note.input.placeholder"),
        value: newNote,
        maxLength: 256,
        onInput: handleNoteInput,
        ref: inputRef
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: style$c.editButton,
        onClick: handleEdit,
        title: t2(`transaction.note.${editMode ? "save" : "edit"}`),
        type: "button",
        ref: editButtonRef,
        children: editMode ? isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SaveLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Save, {}) : isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(EditLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Edit, {})
      }
    )
  ] });
}
const container$5 = "_container_1x5wu_1";
const header$2 = "_header_1x5wu_6";
const columns = "_columns_1x5wu_18";
const headers = "_headers_1x5wu_28";
const columnGroup = "_columnGroup_1x5wu_34";
const type = "_type_1x5wu_47";
const date = "_date_1x5wu_53";
const activity = "_activity_1x5wu_58";
const status = "_status_1x5wu_64";
const fiat = "_fiat_1x5wu_69";
const currency = "_currency_1x5wu_75";
const action = "_action_1x5wu_81";
const empty = "_empty_1x5wu_88";
const hideOnMedium = "_hideOnMedium_1x5wu_104";
const showOnMedium = "_showOnMedium_1x5wu_114";
const style$b = {
  container: container$5,
  header: header$2,
  columns,
  headers,
  columnGroup,
  type,
  date,
  activity,
  status,
  fiat,
  currency,
  action,
  empty,
  hideOnMedium,
  showOnMedium
};
const Transaction = ({
  accountCode,
  index: index2,
  internalID,
  explorerURL,
  type: type2,
  amount: amount2,
  feeRatePerKb,
  numConfirmations,
  numConfirmationsComplete,
  time: time2,
  addresses: addresses2,
  status: status2,
  note: note2 = ""
}) => {
  const { i18n, t: t2 } = useTranslation();
  const [transactionDialog, setTransactionDialog] = reactExports.useState(false);
  const [transactionInfo, setTransactionInfo] = reactExports.useState();
  const parseTimeShort = (time22) => {
    const options2 = {
      year: "numeric",
      month: "numeric",
      day: "numeric"
    };
    return new Date(Date.parse(time22)).toLocaleString(i18n.language, options2);
  };
  const showDetails = () => {
    getTransaction(accountCode, internalID).then((transaction2) => {
      if (!transaction2) {
        console.error("Unable to retrieve transaction " + internalID);
        return null;
      }
      setTransactionInfo(transaction2);
      setTransactionDialog(true);
    }).catch(console.error);
  };
  const arrow2 = status2 === "failed" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Warning, { style: { maxWidth: "18px" } }) : type2 === "receive" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIn, {}) : type2 === "send" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowOut, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowSelf, {});
  const sign = type2 === "send" && "−" || type2 === "receive" && "+" || "";
  const typeClassName = status2 === "failed" && style$c.failed || type2 === "send" && style$c.send || type2 === "receive" && style$c.receive || "";
  const sDate = time2 ? parseTimeShort(time2) : "---";
  const statusText = t2(`transaction.status.${status2}`);
  const progress = numConfirmations < numConfirmationsComplete ? numConfirmations / numConfirmationsComplete * 100 : 100;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.container, index2 === 0 ? style$c.first : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$b.columns, style$c.row].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.columnGroup, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.type, children: arrow2 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.date, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.columnLabel, children: [
            t2("transaction.details.date"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.date, children: sDate })
        ] }),
        note2 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.activity, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.address, children: note2 }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.activity, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.label, children: t2(type2 === "receive" ? "transaction.tx.received" : "transaction.tx.sent") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.address, children: [
            addresses2[0],
            addresses2.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.badge, children: [
              "(+",
              addresses2.length - 1,
              ")"
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$b.action, style$b.hideOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$c.action, onClick: showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.columnGroup, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.status, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.columnLabel, children: [
            t2("transaction.details.status"),
            ":"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ProgressRing,
            {
              className: "m-right-quarter",
              width: 14,
              value: progress,
              isComplete: numConfirmations >= numConfirmationsComplete
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.status, children: statusText })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.fiat, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: true }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$b.currency} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: `${style$c.amount} ${style$c.amountOverflow}`,
            "data-unit": ` ${amount2.unit}`,
            children: [
              sign,
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.currencyUnit, children: [
                " ",
                amount2.unit
              ] })
            ]
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$b.action, style$b.showOnMedium].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { type: "button", className: style$c.action, onClick: showDetails, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ExpandIcon, { expand: !transactionDialog }) }) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: transactionDialog,
        title: t2("transaction.details.title"),
        onClose: () => setTransactionDialog(false),
        slim: true,
        medium: true,
        children: transactionInfo && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Note,
            {
              accountCode,
              internalID,
              note: note2
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: arrow2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.confirmation") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: numConfirmations })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.status") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "flex flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                ProgressRing,
                {
                  className: "m-right-quarter",
                  width: 14,
                  value: progress,
                  isComplete: numConfirmations >= numConfirmationsComplete
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.status, children: [
                statusText,
                " ",
                status2 === "pending" && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { children: [
                  "(",
                  numConfirmations,
                  "/",
                  numConfirmationsComplete,
                  ")"
                ] })
              ] })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.date") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: sDate })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiat") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: amount2, sign, noAction: true }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.fiatAtTime") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$c.fiat} ${typeClassName}`, children: transactionInfo.amountAtTime ? /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { amount: transactionInfo.amountAtTime, sign, noAction: true }) : /* @__PURE__ */ jsxRuntimeExports.jsx(FiatConversion, { noAction: true }) }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.amount") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: typeClassName, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$c.amount, children: [
                sign,
                /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: amount2.amount, unit: amount2.unit })
              ] }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: transactionInfo.amount.unit })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.fee") }),
            transactionInfo.fee && transactionInfo.fee.amount ? /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { title: feeRatePerKb.amount ? feeRatePerKb.amount + " " + feeRatePerKb.unit + "/Kb" : "", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Amount, { amount: transactionInfo.fee.amount, unit: transactionInfo.fee.unit }),
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: transactionInfo.fee.unit })
            ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "---" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.detail, style$c.addresses].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.details.address") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.detailAddresses, children: transactionInfo.addresses.map((address2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyableInput,
              {
                alignRight: true,
                borderLess: true,
                flexibleHeight: true,
                className: style$c.detailAddress,
                value: address2
              },
              address2
            )) })
          ] }),
          transactionInfo.gas ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.gas") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.gas })
          ] }) : null,
          transactionInfo.nonce !== null ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "Nonce" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: transactionInfo.nonce })
          ] }) : null,
          transactionInfo.weight ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.weight") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.weight,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "WU" })
            ] })
          ] }) : null,
          transactionInfo.vsize ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.vsize") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.vsize,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "b" })
            ] })
          ] }) : null,
          transactionInfo.size ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$c.detail, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.size") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
              transactionInfo.size,
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$c.currencyUnit, children: "b" })
            ] })
          ] }) : null,
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$c.detail, style$c.addresses].join(" "), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: t2("transaction.explorer") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$c.detailAddresses, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              CopyableInput,
              {
                alignRight: true,
                borderLess: true,
                flexibleHeight: true,
                className: style$c.detailAddress,
                value: transactionInfo.txID
              }
            ) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$c.detail, "flex-center"].join(" "), children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            A$3,
            {
              href: explorerURL + transactionInfo.txID,
              title: `${t2("transaction.explorerTitle")}
${explorerURL}${transactionInfo.txID}`,
              children: t2("transaction.explorerTitle")
            }
          ) })
        ] })
      }
    )
  ] });
};
const Transactions = ({
  accountCode,
  explorerURL,
  transactions: transactions2,
  handleExport
}) => {
  const { t: t2 } = useTranslation();
  const csvExportDisabled = runningInAndroid();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$b.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge", children: t2("accountSummary.transactionHistory") }),
      !csvExportDisabled && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          transparent: true,
          onClick: handleExport,
          title: t2("account.exportTransactions"),
          children: t2("account.export")
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$b.columns, style$b.headers, style$b.showOnMedium].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.type, children: t2("transaction.details.type") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.date, children: t2("transaction.details.date") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.activity, children: t2("transaction.details.activity") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.status, children: t2("transaction.details.status") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.fiat, children: t2("transaction.details.fiatAmount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.currency, children: t2("transaction.details.amount") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$b.action, children: " " })
    ] }),
    transactions2 && transactions2.success && transactions2.list.length > 0 ? transactions2.list.map((props, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Transaction,
      {
        accountCode,
        explorerURL,
        index: index2,
        ...props
      },
      props.internalID
    )) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `flex flex-row flex-center ${style$b.empty}`, children: transactions2 && !transactions2.success ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.errorLoadTransactions") }) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("transactions.placeholder") }) })
  ] });
};
const container$4 = "_container_1x7yq_1";
const header$1 = "_header_1x7yq_12";
const actionsContainer = "_actionsContainer_1x7yq_23";
const buy = "_buy_1x7yq_30";
const receive = "_receive_1x7yq_31";
const walletConnect = "_walletConnect_1x7yq_32";
const send = "_send_1x7yq_33";
const withWalletConnect = "_withWalletConnect_1x7yq_56";
const disabled = "_disabled_1x7yq_68";
const accountIcon = "_accountIcon_1x7yq_77";
const style$a = {
  container: container$4,
  header: header$1,
  actionsContainer,
  buy,
  receive,
  walletConnect,
  send,
  withWalletConnect,
  disabled,
  accountIcon
};
const ActionButtons = ({ canSend, code, coinCode, exchangeBuySupported, account: account2 }) => {
  const { t: t2 } = useTranslation();
  const navigate2 = useNavigate();
  const walletConnectEnabled = isEthereumBased(account2.coinCode) && !account2.isToken;
  const isLargeTablet = useMediaQuery("(max-width: 830px)");
  const sendLink = `/account/${code}/send`;
  const maybeRouteSend = async (e3) => {
    e3.preventDefault();
    const connectResult = await connectKeystore(code);
    if (connectResult.success) {
      navigate2(sendLink);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${style$a.actionsContainer} ${walletConnectEnabled ? style$a.withWalletConnect : ""}`, children: [
    canSend ? /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: sendLink, className: style$a.send, onClick: isEthereumBased(coinCode) ? maybeRouteSend : void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.send") }) }, "sendLink") : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$a.send} ${style$a.disabled}`, children: t2("button.send") }, "sendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/account/${code}/receive`, className: style$a.receive, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.receive") }) }, "receive"),
    exchangeBuySupported && /* @__PURE__ */ jsxRuntimeExports.jsx(Link, { to: `/buy/info/${code}`, className: style$a.buy, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("button.buy") }) }, "buy"),
    walletConnectEnabled && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/wallet-connect/dashboard`, className: style$a.walletConnect, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { width: 24 }),
      " ",
      !isLargeTablet && /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Wallet Connect" })
    ] }, "wallet-connect")
  ] });
};
function AccountGuide({
  account: account2,
  unit: unit2,
  hasNoBalance,
  hasIncomingBalance,
  hasTransactions
}) {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountDescription") }, "accountDescription"),
    hasNoBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountSendDisabled", {
      unit: unit2
    }) }, "accountSendDisabled"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountReload") }, "accountReload"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionLabel") }, "accountTransactionLabel"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionTime") }, "accountTransactionTime"),
    hasTransactions && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesGeneric") }, "accountTransactionAttributesGeneric"),
    hasTransactions && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionAttributesBTC") }, "accountTransactionAttributesBTC"),
    hasIncomingBalance && /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountIncomingBalance") }, "accountIncomingBalance"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountTransactionConfirmation") }, "accountTransactionConfirmation"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.accountFiat") }, "accountFiat"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "accountRates"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "CoinTracking",
        url: "https://cointracking.info/import/bitbox/?ref=BITBOX"
      },
      text: t2("guide.cointracking.text"),
      title: t2("guide.cointracking.title")
    } }, "cointracking")
  ] });
}
function Account({
  accounts,
  code,
  devices
}) {
  const { t: t2 } = useTranslation();
  const [balance2, setBalance] = reactExports.useState();
  const [status2, setStatus] = reactExports.useState();
  const [syncedAddressesCount, setSyncedAddressesCount] = reactExports.useState();
  const [transactions2, setTransactions] = reactExports.useState();
  const [usesProxy, setUsesProxy] = reactExports.useState();
  const [insured2, setInsured] = reactExports.useState(false);
  const [uncoveredFunds, setUncoveredFunds] = reactExports.useState([]);
  const [stateCode, setStateCode] = reactExports.useState();
  const supportedExchanges = useLoad(getExchangeBuySupported(code), [code]);
  const account2 = accounts && accounts.find((acct) => acct.code === code);
  const getBitsuranceGuideLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://bitbox.swiss/redirects/bitsurance-segwit-migration-guide-de/";
      default:
        return "https://bitbox.swiss/redirects/bitsurance-segwit-migration-guide-en/";
    }
  };
  const checkUncoveredUTXOs = reactExports.useCallback(async () => {
    const uncoveredScripts = [];
    const utxos = await getUTXOs(code);
    utxos.forEach((utxo2) => {
      if (utxo2.scriptType !== "p2wpkh" && !uncoveredScripts.includes(utxo2.scriptType)) {
        uncoveredScripts.push(utxo2.scriptType);
      }
    });
    setUncoveredFunds(uncoveredScripts.map(getScriptName));
  }, [code]);
  const maybeCheckBitsuranceStatus = reactExports.useCallback(async () => {
    if (account2 == null ? void 0 : account2.bitsuranceStatus) {
      const insuredAccounts = await bitsuranceLookup(code);
      if (!insuredAccounts.success) {
        alertUser(insuredAccounts.errorMessage || t2("genericError"));
        return;
      }
      const config = await getConfig();
      let cancelledAccounts = config.frontend.bitsuranceNotifyCancellation;
      if (cancelledAccounts == null ? void 0 : cancelledAccounts.some((accountCode) => accountCode === code)) {
        alertUser(t2("account.insuranceExpired"));
        config.frontend.bitsuranceNotifyCancellation = cancelledAccounts.filter((accountCode) => accountCode !== code);
        setConfig(config);
      }
      let bitsuranceAccount2 = insuredAccounts.bitsuranceAccounts[0];
      if (bitsuranceAccount2.status === "active") {
        setInsured(true);
        checkUncoveredUTXOs();
        return;
      }
    }
    setInsured(false);
  }, [t2, account2, code, checkUncoveredUTXOs]);
  reactExports.useEffect(() => {
    maybeCheckBitsuranceStatus();
    getConfig().then(({ backend }) => setUsesProxy(backend.proxy.useProxy));
  }, [maybeCheckBitsuranceStatus]);
  const hasCard = useSDCard(devices, [code]);
  const onAccountChanged = reactExports.useCallback((code2, status22) => {
    if (!code2 || status22 === void 0 || status22.fatalError) {
      return;
    }
    if (status22.synced && status22.offlineError === null) {
      const currentCode = code2;
      Promise.all([
        getBalance(currentCode).then((newBalance) => {
          if (currentCode !== code2) {
            return;
          }
          setBalance(newBalance);
        }),
        getTransactionList(code2).then((newTransactions) => {
          if (currentCode !== code2) {
            return;
          }
          setTransactions(newTransactions);
        })
      ]).catch(console.error);
    } else {
      setBalance(void 0);
      setTransactions(void 0);
    }
  }, []);
  const onStatusChanged = reactExports.useCallback(() => {
    const currentCode = code;
    if (!currentCode) {
      return;
    }
    getStatus$2(currentCode).then(async (status22) => {
      if (currentCode !== code) {
        return;
      }
      setStatus(status22);
      if (!status22.disabled && !status22.synced) {
        await init(currentCode).catch(console.error);
      }
      onAccountChanged(code, status22);
    }).catch(console.error);
  }, [onAccountChanged, code]);
  reactExports.useEffect(() => {
    const subscriptions2 = [
      syncAddressesCount(code)(setSyncedAddressesCount),
      statusChanged$1((eventCode) => eventCode === code && onStatusChanged()),
      syncdone((eventCode) => eventCode === code && onAccountChanged(code, status2))
    ];
    return () => unsubscribe(subscriptions2);
  }, [code, onAccountChanged, onStatusChanged, status2]);
  function exportAccount$1() {
    if (status2 === void 0 || status2.fatalError) {
      return;
    }
    exportAccount(code).then((result) => {
      if (result !== null && !result.success) {
        alertUser(result.errorMessage);
      }
    }).catch(console.error);
  }
  reactExports.useEffect(() => {
    setStateCode(code);
    setBalance(void 0);
    setStatus(void 0);
    setSyncedAddressesCount(0);
    setTransactions(void 0);
    onStatusChanged();
  }, [code, onStatusChanged]);
  const hasDataLoaded = balance2 !== void 0 && transactions2 !== void 0;
  if (stateCode !== code) {
    return null;
  }
  if (!account2 || status2 === void 0) {
    return null;
  }
  if (status2.fatalError) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("account.fatalError") });
  }
  if (status2.offlineError !== null) {
    const offlineErrorTextLines = [];
    offlineErrorTextLines.push(t2("account.reconnecting"));
    offlineErrorTextLines.push(status2.offlineError);
    if (usesProxy) {
      offlineErrorTextLines.push(t2("account.maybeProxyError"));
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: offlineErrorTextLines.join("\n") });
  }
  if (!status2.synced) {
    const text2 = syncedAddressesCount !== void 0 && syncedAddressesCount > 1 ? "\n" + t2("account.syncedAddressesCount", {
      count: syncedAddressesCount.toString(),
      defaultValue: 0
    }) : "";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: t2("account.initializing") + text2 });
  }
  if (!hasDataLoaded) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: true, text: "" });
  }
  const exchangeBuySupported = supportedExchanges && supportedExchanges.exchanges.length > 0;
  const isAccountEmpty = balance2 && !balance2.hasAvailable && !balance2.hasIncoming && transactions2 && transactions2.success && transactions2.list.length === 0;
  const actionButtonsProps = {
    code,
    coinCode: account2.coinCode,
    canSend: balance2 && balance2.hasAvailable,
    exchangeBuySupported,
    account: account2
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { hidden: !hasCard, type: "warning", children: t2("warning.sdcard") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: insured2 && uncoveredFunds.length !== 0, medium: true, title: t2("account.warning"), onClose: () => setUncoveredFunds([]), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "p", markup: t2("account.uncoveredFunds", {
          name: account2.name,
          uncovered: uncoveredFunds
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: getBitsuranceGuideLink(), children: t2("account.uncoveredFundsLink") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Header,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs("h2", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: account2.name }),
            insured2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Insured, {})
          ] }),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { to: `/account/${code}/info`, title: t2("accountInfo.title"), className: "flex flex-row flex-items-center m-left-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$a.accountIcon }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("accountInfo.label") })
            ] })
          ]
        }
      ),
      status2.synced && hasDataLoaded && isBitcoinBased(account2.coinCode) && /* @__PURE__ */ jsxRuntimeExports.jsx(HeadersSync, { coinCode: account2.coinCode }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "innerContainer scrollableContainer", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "content padded", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column flex-reverse-mobile", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile hide-on-small", children: t2("accountSummary.availableBalance") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-item-center flex-column-mobile flex-reverse-mobile", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Balance, { balance: balance2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "labelXLarge flex-self-start-mobile show-on-small", children: t2("accountSummary.availableBalance") }),
            !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(ActionButtons, { ...actionButtonsProps })
          ] })
        ] }),
        isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          BuyReceiveCTA,
          {
            account: account2,
            code,
            exchangeBuySupported,
            unit: balance2.available.unit,
            balanceList: [balance2]
          }
        ),
        !isAccountEmpty && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Transactions,
          {
            accountCode: code,
            handleExport: exportAccount$1,
            explorerURL: account2.blockExplorerTxPrefix,
            transactions: transactions2
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AccountGuide,
      {
        account: account2,
        unit: balance2 == null ? void 0 : balance2.available.unit,
        hasIncomingBalance: balance2 && balance2.hasIncoming,
        hasTransactions: transactions2 !== void 0 && transactions2.success && transactions2.list.length > 0,
        hasNoBalance: balance2 && balance2.available.amount === "0"
      }
    )
  ] });
}
const ReceiveAccountsSelector = ({ activeAccounts }) => {
  const [code, setCode] = reactExports.useState("");
  const { t: t2 } = useTranslation();
  const handleProceed = () => {
    route(`/account/${code}/receive`);
  };
  const hasOnlyBTCAccounts = activeAccounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const title2 = t2("receive.title", { accountName: hasOnlyBTCAccounts ? "Bitcoin" : t2("buy.info.crypto") });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: title2 }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: activeAccounts && activeAccounts.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      GroupedAccountSelector,
      {
        title: t2("receive.selectAccount"),
        accounts: activeAccounts,
        selected: code,
        onChange: setCode,
        onProceed: handleProceed
      }
    ) }) })
  ] });
};
const DarkmodeToggleSetting = () => {
  const { t: t2 } = useTranslation();
  const { toggleDarkmode, isDarkMode } = useDarkmode();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("darkmode.toggle"),
      secondaryText: t2("newSettings.appearance.darkmode.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(Toggle, { checked: isDarkMode, onChange: () => toggleDarkmode(!isDarkMode) })
    }
  );
};
const dropdown = "_dropdown_1uw27_1";
const select$2 = "_select_1uw27_10";
const dropdownStyles = {
  dropdown,
  select: select$2
};
const DropdownIndicator2 = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) });
};
const Option2 = (props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.Option, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
};
const SingleValue2 = (props) => {
  const { label: label2 } = props.data;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(components.SingleValue, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }) });
};
const SingleDropdown = ({ options: options2, handleChange, defaultValue }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: dropdownStyles.select,
      classNamePrefix: "react-select",
      isSearchable: true,
      defaultValue,
      components: { IndicatorSeparator: () => null, DropdownIndicator: DropdownIndicator2, SingleValue: SingleValue2, Option: Option2 },
      onChange: (selected2) => {
        if (selected2) {
          const value = (selected2 == null ? void 0 : selected2.value) || "";
          handleChange(value);
        }
      },
      options: options2
    }
  );
};
const DefaultCurrencyDropdownSetting = () => {
  var _a;
  const { t: t2 } = useTranslation();
  const { selectFiat, updateDefaultFiat, defaultCurrency: defaultCurrency2, activeCurrencies } = reactExports.useContext(RatesContext);
  const valueLabel = (_a = currenciesWithDisplayName.find((fiat2) => fiat2.currency === defaultCurrency2)) == null ? void 0 : _a.displayName;
  const defaultValueLabel = valueLabel ? `${valueLabel} (${defaultCurrency2})` : defaultCurrency2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.defaultCurrency.title"),
      secondaryText: t2("newSettings.appearance.defaultCurrency.description"),
      collapseOnSmall: true,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedCurrencies,
          handleChange: async (fiat2) => {
            updateDefaultFiat(fiat2);
            if (!activeCurrencies.includes(fiat2)) {
              await selectFiat(fiat2);
            }
          },
          defaultValue: {
            label: defaultValueLabel,
            value: defaultCurrency2
          }
        }
      )
    }
  );
};
const DisplaySatsToggleSetting = () => {
  const { t: t2 } = useTranslation();
  const fetchedConfig = useLoad(getConfig);
  const [displayAsSAT, setDisplayAsSAT] = reactExports.useState();
  const { updateRatesConfig } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (fetchedConfig) {
      setDisplayAsSAT(fetchedConfig.backend.btcUnit === "sat");
    }
  }, [fetchedConfig]);
  const handleToggleSatsUnit = async () => {
    const toggleDdisplayAsSAT = !displayAsSAT;
    const unit2 = toggleDdisplayAsSAT ? "sat" : "default";
    setDisplayAsSAT(toggleDdisplayAsSAT);
    await setConfig({
      backend: { btcUnit: unit2 }
    });
    updateRatesConfig();
    const result = await setBtcUnit(unit2);
    if (!result.success) {
      alertUser(t2("genericError"));
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.useSats"),
      secondaryText: t2("newSettings.appearance.toggleSats.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: displayAsSAT !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: displayAsSAT,
          onChange: handleToggleSatsUnit
        }
      ) : null })
    }
  ) });
};
const LanguageDropdownSetting = () => {
  const { i18n, t: t2 } = useTranslation();
  const selectedLanguage = defaultLanguages[getSelectedIndex(defaultLanguages, i18n)];
  const formattedLanguages = defaultLanguages.map((lang) => ({ label: lang.display, value: lang.code }));
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.language.title"),
      secondaryText: t2("newSettings.appearance.language.description"),
      collapseOnSmall: true,
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        SingleDropdown,
        {
          options: formattedLanguages,
          handleChange: i18n.changeLanguage,
          defaultValue: { label: selectedLanguage.display, value: selectedLanguage.code }
        }
      )
    }
  );
};
const select$1 = "_select_1j2fm_1";
const hideMultiSelect = "_hideMultiSelect_1j2fm_30";
const defaultCurrency = "_defaultCurrency_1j2fm_51";
const defaultLabel = "_defaultLabel_1j2fm_55";
const activeCurrenciesDropdownStyle = {
  select: select$1,
  hideMultiSelect,
  defaultCurrency,
  defaultLabel
};
const ActiveCurrenciesDropdown = ({
  options: options2,
  defaultCurrency: defaultCurrency2,
  activeCurrencies
}) => {
  const [formattedActiveCurrencies, setFormattedActiveCurrencies] = reactExports.useState([]);
  const [search, setSearch] = reactExports.useState("");
  const { t: t2 } = useTranslation();
  const { unselectFiat, selectFiat } = reactExports.useContext(RatesContext);
  reactExports.useEffect(() => {
    if (activeCurrencies.length > 0) {
      const formattedSelectedCurrencies = activeCurrencies.map((currency2) => ({ label: currency2, value: currency2 }));
      setFormattedActiveCurrencies(formattedSelectedCurrencies);
    }
  }, [activeCurrencies]);
  const DropdownIndicator3 = (props) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(components.DropdownIndicator, { ...props, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: dropdownStyles.dropdown }) });
  };
  const Option3 = (props) => {
    const { label: label2, value } = props.data;
    const selected2 = formattedActiveCurrencies.findIndex((currency2) => currency2.value === value) >= 0;
    const isDefaultCurrency = defaultCurrency2 === value;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(components.Option, { ...props, className: `${isDefaultCurrency ? activeCurrenciesDropdownStyle.defaultCurrency : ""}`, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: label2 }),
      isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: activeCurrenciesDropdownStyle.defaultLabel, children: t2("fiat.default") }) : null,
      selected2 && !isDefaultCurrency ? /* @__PURE__ */ jsxRuntimeExports.jsx(SelectedCheckLight, {}) : null
    ] });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    StateManagedSelect$1,
    {
      className: `
         ${dropdownStyles.select}
         ${activeCurrenciesDropdownStyle.select}
         ${search.length > 0 ? activeCurrenciesDropdownStyle.hideMultiSelect : ""}
         `,
      classNamePrefix: "react-select",
      isSearchable: true,
      isClearable: false,
      components: { DropdownIndicator: DropdownIndicator3, IndicatorSeparator: () => null, MultiValueRemove: () => null, Option: Option3 },
      isMulti: true,
      closeMenuOnSelect: false,
      hideSelectedOptions: false,
      value: [...formattedActiveCurrencies].reverse(),
      onInputChange: (newValue) => setSearch(newValue),
      onChange: async (_24, meta) => {
        switch (meta.action) {
          case "select-option":
            if (meta.option) {
              await selectFiat(meta.option.value);
            }
            break;
          case "deselect-option":
            if (meta.option && meta.option.value !== defaultCurrency2) {
              await unselectFiat(meta.option.value);
            }
        }
      },
      options: options2
    }
  );
};
const ActiveCurrenciesDropdownSetting = () => {
  const { t: t2 } = useTranslation();
  const { activeCurrencies, defaultCurrency: defaultCurrency2 } = reactExports.useContext(RatesContext);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      collapseOnSmall: true,
      settingName: t2("newSettings.appearance.activeCurrencies.title"),
      secondaryText: t2("newSettings.appearance.activeCurrencies.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ActiveCurrenciesDropdown,
        {
          options: formattedCurrencies,
          defaultCurrency: defaultCurrency2,
          activeCurrencies
        }
      )
    }
  );
};
const HideAmountsSetting = () => {
  const { t: t2 } = useTranslation();
  const { setHideAmounts } = reactExports.useContext(AppContext);
  const [allowHideAmounts, setAllowHideAmounts] = reactExports.useState();
  const config = useLoad(getConfig);
  reactExports.useEffect(() => {
    if (config) {
      if (config.frontend.allowHideAmounts === void 0) {
        setAllowHideAmounts(false);
        return;
      }
      setAllowHideAmounts(config.frontend.allowHideAmounts);
    }
  }, [config]);
  const toggleAllowHideAmounts = async () => {
    if (allowHideAmounts) {
      setHideAmounts(false);
      await setConfig({
        frontend: { hideAmounts: false }
      });
    }
    setAllowHideAmounts(!allowHideAmounts);
    await setConfig({
      frontend: { allowHideAmounts: !allowHideAmounts }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.appearance.hideAmounts.title"),
      secondaryText: t2("newSettings.appearance.hideAmounts.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: allowHideAmounts !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: allowHideAmounts,
          onChange: toggleAllowHideAmounts
        }
      ) : null })
    }
  );
};
const Appearance = ({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.appearance") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(WithSettingsTabs, { hasAccounts, hideMobileMenu: true, deviceIDs, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultCurrencyDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ActiveCurrenciesDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LanguageDropdownSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DarkmodeToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DisplaySatsToggleSetting, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsSetting, {})
      ] }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AppearanceGuide, {})
  ] });
};
const AppearanceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.sats") }, "guide.settings.sats"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: "www.coingecko.com",
        url: "https://www.coingecko.com/"
      },
      text: t2("guide.accountRates.text"),
      title: t2("guide.accountRates.title")
    } }, "guide.accountRates")
  ] });
};
const MobileSettings = ({ deviceIDs, hasAccounts }) => {
  const isMobile = useMediaQuery("(max-width: 768px)");
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (!isMobile) {
      route("/settings/appearance");
    }
  }, [isMobile]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("settings.title") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Tabs, { deviceIDs, hasAccounts }) }) })
  ] });
};
const AppVersion = () => {
  const { t: t2 } = useTranslation();
  const version = useLoad(getVersion$1);
  const update = useLoad(getUpdate);
  const secondaryText2 = !!update ? t2("settings.info.out-of-date") : t2("settings.info.up-to-date");
  const icon2 = !!update ? /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 8, height: 8 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {});
  const versionNumber = !!version ? version : "-";
  if (update === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(StyledSkeleton, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.about.appVersion.title"),
      secondaryText: secondaryText2,
      displayedValue: versionNumber,
      extraComponent: icon2,
      onClick: update ? () => open(downloadLinkByLanguage()) : void 0
    }
  );
};
const About = ({ deviceIDs, hasAccounts }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.about") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WithSettingsTabs, { deviceIDs, hideMobileMenu: true, hasAccounts, children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppVersion, {}) }) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AboutGuide, {})
  ] });
};
const AboutGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Guide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings.servers") }, "guide.settings.servers") });
};
const EnableCustomFeesToggleSetting = ({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleFee = async (e3) => {
    const config = await setConfig({
      frontend: {
        "expertFee": e3.target.checked
      }
    });
    onChangeConfig(config);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.fee"),
      secondaryText: t2("newSettings.advancedSettings.customFees.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.expertFee) || false,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
};
const EnableCoinControlSetting = ({ frontendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleFee = async (e3) => {
    const config = await setConfig({
      frontend: {
        "coinControl": e3.target.checked
      }
    });
    onChangeConfig(config);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.coinControl"),
      secondaryText: t2("newSettings.advancedSettings.coinControl.description"),
      extraComponent: frontendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (frontendConfig == null ? void 0 : frontendConfig.coinControl) || false,
          onChange: handleToggleFee
        }
      ) : null
    }
  );
};
const ConnectFullNodeSetting = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("settings.expert.electrum.title"),
      onClick: () => route("/settings/electrum"),
      secondaryText: t2("settings.expert.electrum.description"),
      extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ChevronRightDark,
        {
          width: 24,
          height: 24
        }
      )
    }
  );
};
const TorProxyDialog = ({ open: open2, proxyConfig, onCloseDialog, onChangeConfig, handleShowRestartMessage }) => {
  const [proxyAddress, setProxyAddress] = reactExports.useState();
  const { t: t2 } = useTranslation();
  reactExports.useEffect(() => {
    if (proxyConfig) {
      setProxyAddress(proxyConfig.proxyAddress);
    }
  }, [proxyConfig]);
  const handleSetProxyButton = async () => {
    if (!proxyConfig || proxyAddress === void 0) {
      return;
    }
    const proxy = proxyConfig;
    proxy.proxyAddress = proxyAddress.trim();
    const result = await socksProxyCheck(proxy.proxyAddress);
    const { success: success2, errorMessage: errorMessage2 } = result;
    if (success2) {
      await setProxyConfig(proxy);
    } else {
      alertUser(errorMessage2 || t2("account.fatalError"));
    }
  };
  const setProxyConfig = async (proxyConfig2) => {
    const config = await setConfig({
      backend: { proxy: proxyConfig2 }
    });
    setProxyAddress(proxyConfig2.proxyAddress);
    onChangeConfig(config);
    handleShowRestartMessage(true);
  };
  const handleToggleProxy = async (e3) => {
    if (!proxyConfig) {
      return;
    }
    const proxy = { ...proxyConfig, useProxy: e3.target.checked };
    await setProxyConfig(proxy);
  };
  const handleInputChange = (e3) => {
    setProxyAddress(e3.target.value);
    handleShowRestartMessage(false);
  };
  if (!proxyConfig || proxyConfig === void 0 || proxyAddress === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, onClose: onCloseDialog, title: t2("settings.expert.setProxyAddress"), small: true, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-row flex-between flex-items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-none", children: t2("settings.expert.useProxy") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          id: "useProxy",
          checked: proxyConfig.useProxy,
          onChange: handleToggleProxy
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input$2,
        {
          name: "proxyAddress",
          onInput: handleInputChange,
          value: proxyAddress,
          placeholder: "127.0.0.1:9050",
          disabled: !proxyConfig.useProxy
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          primary: true,
          onClick: handleSetProxyButton,
          disabled: !proxyConfig.useProxy || proxyAddress === proxyConfig.proxyAddress,
          children: t2("settings.expert.setProxyAddress")
        }
      ) })
    ] })
  ] });
};
const inlineMessage = "_inlineMessage_gi9x3_1";
const success = "_success_gi9x3_7";
const left = "_left_gi9x3_12";
const close = "_close_gi9x3_16";
const style$9 = {
  inlineMessage,
  success,
  left,
  close
};
class InlineMessage extends reactExports.Component {
  deactivate = () => {
    this.props.onEnd();
  };
  render() {
    const {
      type: type2,
      message: message2,
      align
    } = this.props;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$9.inlineMessage, style$9[type2], align ? style$9[align] : ""].join(" "), children: [
      message2,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$9.close, onClick: this.deactivate, children: "✕" })
    ] });
  }
}
const settingItem = "_settingItem_6ge6v_3";
const styles$b = {
  settingItem
};
const EnableTorProxySetting = ({ proxyConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const [showTorProxyDialog, setShowTorProxyDialog] = reactExports.useState(false);
  const [showRestartMessage, setShowRestartMessage] = reactExports.useState(false);
  const proxyEnabled = proxyConfig ? proxyConfig.useProxy : false;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    showRestartMessage ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      InlineMessage,
      {
        type: "success",
        align: "left",
        message: t2("settings.restart"),
        onEnd: () => setShowRestartMessage(false)
      }
    ) : null,
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SettingsItem,
      {
        className: styles$b.settingItem,
        settingName: t2("settings.expert.useProxy"),
        onClick: () => setShowTorProxyDialog(true),
        secondaryText: t2("newSettings.advancedSettings.torProxy.description"),
        displayedValue: proxyEnabled ? t2("generic.enabled_true") : t2("generic.enabled_false"),
        extraComponent: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRightDark, { width: 24, height: 24 })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TorProxyDialog,
      {
        open: showTorProxyDialog,
        proxyConfig,
        onCloseDialog: () => setShowTorProxyDialog(false),
        onChangeConfig,
        handleShowRestartMessage: setShowRestartMessage
      }
    )
  ] });
};
const EnableAuthSetting = ({ backendConfig, onChangeConfig }) => {
  const { t: t2 } = useTranslation();
  const handleToggleAuth = async (e3) => {
    const unsubscribe2 = subscribeAuth((data) => {
      if (data.typ === "auth-ok") {
        updateConfig(!e3.target.checked);
        unsubscribe2();
      }
      if (data.typ === "auth-canceled") {
        unsubscribe2();
      }
    });
    forceAuth();
  };
  const updateConfig = async (auth2) => {
    const config = await setConfig({
      backend: { authentication: auth2 }
    });
    onAuthSettingChanged();
    onChangeConfig(config);
  };
  if (!runningInAndroid()) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SettingsItem,
    {
      settingName: t2("newSettings.advancedSettings.authentication.title"),
      secondaryText: t2("newSettings.advancedSettings.authentication.description"),
      extraComponent: backendConfig !== void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Toggle,
        {
          checked: (backendConfig == null ? void 0 : backendConfig.authentication) || false,
          onChange: handleToggleAuth
        }
      ) : null
    }
  );
};
const AdvancedSettings = ({ deviceIDs, hasAccounts }) => {
  var _a;
  const { t: t2 } = useTranslation();
  const fetchedConfig = useLoad(getConfig);
  const [config, setConfig2] = reactExports.useState();
  const frontendConfig = config == null ? void 0 : config.frontend;
  const backendConfig = config == null ? void 0 : config.backend;
  const proxyConfig = (_a = config == null ? void 0 : config.backend) == null ? void 0 : _a.proxy;
  reactExports.useEffect(() => {
    setConfig2(fetchedConfig);
  }, [fetchedConfig]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          hideSidebarToggler: true,
          title: /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "hide-on-small", children: t2("sidebar.settings") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MobileHeader, { withGuide: true, title: t2("settings.advancedSettings") })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        WithSettingsTabs,
        {
          deviceIDs,
          hideMobileMenu: true,
          hasAccounts,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCustomFeesToggleSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableCoinControlSetting, { frontendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableAuthSetting, { backendConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(EnableTorProxySetting, { proxyConfig, onChangeConfig: setConfig2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectFullNodeSetting, {})
          ]
        }
      ) }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AdvancedSettingsGuide, {})
  ] });
};
const AdvancedSettingsGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.why") }, "guide.settings-electrum.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.settings-electrum.tor") }, "guide.settings-electrum.tor")
  ] });
};
const getLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://www.bitsurance.eu/de/bitbox/";
    default:
      return "https://www.bitsurance.eu/en/bitbox/";
  }
};
const getPrivacyPolicyLink = () => {
  switch (instance.resolvedLanguage) {
    case "de":
      return "https://www.bitsurance.eu/datenschutz/";
    default:
      return "https://www.bitsurance.eu/en/dataprotection/";
  }
};
const BitsuranceGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.why"), shown: true }, "guide.bitsurance.why"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.who") }, "guide.bitsurance.who"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.what") }, "guide.bitsurance.what"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.status") }, "guide.bitsurance.status"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: t2("guide.bitsurance.renew") }, "guide.bitsurance.renew"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.bitsurance.privacy.link.text"),
        url: getPrivacyPolicyLink()
      },
      text: t2("guide.bitsurance.privacy.text"),
      title: t2("guide.bitsurance.privacy.title")
    } }, "guide.bitsurance.privacy"),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Entry, { entry: {
      link: {
        text: t2("guide.bitsurance.faq.link.text"),
        url: getLink()
      },
      text: t2("guide.bitsurance.faq.text"),
      title: t2("guide.bitsurance.faq.title")
    } }, "guide.bitsurance.faq")
  ] });
};
const cardBody = "_cardBody_16ttw_1";
const cardBody2 = "_cardBody2_16ttw_6";
const clean = "_clean_16ttw_11";
const ctaButton = "_ctaButton_16ttw_21";
const errorMessage = "_errorMessage_16ttw_37";
const gridContainer = "_gridContainer_16ttw_41";
const noVspace = "_noVspace_16ttw_45";
const title$1 = "_title_16ttw_51";
const style$8 = {
  cardBody,
  cardBody2,
  clean,
  ctaButton,
  errorMessage,
  gridContainer,
  noVspace,
  title: title$1
};
const Bitsurance = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const [insuredAccounts, setInsuredAccounts] = reactExports.useState([]);
  const [redirecting, setRedirecting] = reactExports.useState(true);
  const [scanDone, setScanDone] = reactExports.useState(false);
  const [scanLoading, setScanLoading] = reactExports.useState(false);
  const amount2 = "100.000€";
  reactExports.useEffect(() => {
    if (accounts.some(({ bitsuranceStatus }) => bitsuranceStatus)) {
      route("bitsurance/dashboard");
    } else {
      setRedirecting(false);
    }
    return () => setInsuredAccounts([]);
  }, [accounts]);
  const detect2 = async (redirectToDashboard) => {
    setScanLoading(true);
    setScanDone(false);
    setInsuredAccounts([]);
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    const insuredAccountsCodes = response.bitsuranceAccounts.map((account2) => account2.status ? account2.code : null);
    const insured2 = accounts.filter(({ code }) => insuredAccountsCodes.includes(code));
    setInsuredAccounts(insured2);
    setScanDone(true);
    setScanLoading(false);
    if (insured2.length && redirectToDashboard) {
      route("bitsurance/dashboard");
    }
  };
  const getBitsurancePageLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://www.bitsurance.eu/de/bitbox/";
      default:
        return "https://www.bitsurance.eu/en/bitbox/";
    }
  };
  const maybeProceed = async () => {
    await detect2(false);
    route("bitsurance/account");
  };
  if (redirecting) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("sidebar.insurance") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.noVspace, children: t2("bitsurance.intro.text1", { amount: amount2 }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$8.gridContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { col: "2", textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$8.title, children: t2("bitsurance.insure.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody, children: t2("bitsurance.insure.text") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: style$8.clean, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem1") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem2") })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Checked, {}),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: t2("bitsurance.insure.listItem3") })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$8.cardBody2, children: [
              t2("bitsurance.insure.text2"),
              " ",
              " ",
              /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: getBitsurancePageLink(), children: t2("bitsurance.intro.link") }),
              "."
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody2, children: t2("bitsurance.insure.text3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnButtons, { className: style$8.ctaButton, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: maybeProceed, primary: true, children: t2("bitsurance.insure.button") }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: style$8.title, children: t2("bitsurance.detect.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$8.cardBody, children: t2("bitsurance.detect.text") }),
            !insuredAccounts.length && scanDone && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$8.cardBody2} ${style$8.errorMessage}`, children: t2("bitsurance.detect.notInsured") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(ColumnButtons, { className: style$8.ctaButton, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                onClick: () => detect2(true),
                disabled: scanLoading,
                secondary: true,
                children: [
                  isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(SyncLight, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Sync, {}),
                  t2("bitsurance.detect.button")
                ]
              }
            ) })
          ] })
        ] }) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] }) });
};
const BitsuranceAccount = ({ code, accounts }) => {
  const [selected2, setSelected] = reactExports.useState(code);
  const [disabled2, setDisabled] = reactExports.useState(false);
  const [btcAccounts, setBtcAccounts] = reactExports.useState();
  const { t: t2 } = useTranslation();
  const handleChangeAccount = (selected22) => {
    setSelected(selected22);
  };
  const detect2 = reactExports.useCallback(async () => {
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    const insurableAccounts = accounts.filter((account2) => account2.coinCode === "btc" && (!account2.bitsuranceStatus || account2.bitsuranceStatus === "canceled" || account2.bitsuranceStatus === "refused"));
    setBtcAccounts(insurableAccounts);
  }, [accounts]);
  reactExports.useEffect(() => {
    detect2();
  }, [detect2]);
  reactExports.useEffect(() => {
    if (btcAccounts !== void 0 && btcAccounts.length === 1) {
      connectKeystore(btcAccounts[0].code).then((connectResult) => {
        if (!connectResult.success) {
          return;
        }
        route(`/bitsurance/widget/${btcAccounts[0].code}`);
      });
    }
  }, [btcAccounts]);
  const handleProceed = async () => {
    setDisabled(true);
    try {
      const connectResult = await connectKeystore(selected2);
      if (!connectResult.success) {
        return;
      }
    } finally {
      setDisabled(false);
    }
    route(`/bitsurance/widget/${selected2}`);
  };
  if (btcAccounts === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Main, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(GuidedContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("bitsuranceAccount.title") }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { width: "550px", verticallyCentered: true, fullscreen: false, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: btcAccounts.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: t2("bitsuranceAccount.noAccount") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(
        GroupedAccountSelector,
        {
          title: t2("bitsuranceAccount.select"),
          disabled: disabled2,
          accounts: btcAccounts,
          selected: selected2,
          onChange: handleChangeAccount,
          onProceed: handleProceed
        }
      ) }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] }) });
};
const BitsuranceTerms = ({ onAgreedTerms }) => {
  const { t: t2 } = useTranslation();
  const handleSkipDisclaimer = (e3) => {
    setConfig({ frontend: { skipBitsuranceDisclaimer: e3.target.checked } });
  };
  const getPrivacyLink = () => {
    switch (instance.resolvedLanguage) {
      case "de":
        return "https://www.bitsurance.eu/datenschutz";
      default:
        return "https://www.bitsurance.eu/en/dataprotection/";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$Q.disclaimer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text1") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text2") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text3") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitsurance.terms.text4") }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
        t2("bitsurance.terms.text5"),
        " ",
        /* @__PURE__ */ jsxRuntimeExports.jsxs(A$3, { href: getPrivacyLink(), children: [
          t2("bitsurance.terms.link"),
          "."
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center m-bottom-quarter", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "skip_disclaimer",
        label: t2("buy.info.skip"),
        onChange: handleSkipDisclaimer
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "buttons text-center m-bottom-xlarge", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        primary: true,
        onClick: onAgreedTerms,
        children: t2("buy.info.continue")
      }
    ) })
  ] });
};
const container$3 = "_container_yg57j_1";
const iframe = "_iframe_yg57j_12";
const header = "_header_yg57j_18";
const style$7 = {
  container: container$3,
  iframe,
  header
};
const BitsuranceWidget = ({ code }) => {
  const { t: t2 } = useTranslation();
  const [height, setHeight] = reactExports.useState(0);
  const [iframeLoaded, setIframeLoaded] = reactExports.useState(false);
  const [agreedTerms, setAgreedTerms] = reactExports.useState(false);
  const iframeURL = useLoad(getBitsuranceURL);
  const config = useLoad(getConfig);
  const accountInfo2 = useLoad(getInfo(code));
  const ref = reactExports.createRef();
  const iframeRef = reactExports.createRef();
  let signing = false;
  let resizeTimerID = void 0;
  reactExports.useEffect(() => {
    if (config) {
      setAgreedTerms(config.frontend.skipBitsuranceDisclaimer);
    }
  }, [config]);
  reactExports.useEffect(() => {
    onResize();
    window.addEventListener("resize", onResize);
    window.addEventListener("message", onMessage);
    return () => {
      window.removeEventListener("resize", onResize);
      window.removeEventListener("message", onMessage);
    };
  });
  const onResize = () => {
    if (resizeTimerID) {
      clearTimeout(resizeTimerID);
    }
    resizeTimerID = setTimeout(() => {
      if (!ref.current) {
        return;
      }
      setHeight(ref.current.offsetHeight);
    }, 200);
  };
  const sendAddressWithXPub = (address2, sig, xpub) => {
    var _a;
    const { current } = iframeRef;
    if (!current) {
      return;
    }
    const message2 = dist.serializeMessage({
      version: dist.MessageVersion.V0,
      type: dist.V0MessageType.Address,
      bitcoinAddress: address2,
      extendedPublicKey: xpub,
      signature: sig
    });
    (_a = current.contentWindow) == null ? void 0 : _a.postMessage(message2, "*");
  };
  const getXPub = (wantedScriptType) => {
    var _a;
    let xpubConfig = accountInfo2 == null ? void 0 : accountInfo2.signingConfigurations.find(
      (config2) => {
        var _a2;
        return ((_a2 = config2.bitcoinSimple) == null ? void 0 : _a2.scriptType) === wantedScriptType;
      }
    );
    return (_a = xpubConfig == null ? void 0 : xpubConfig.bitcoinSimple) == null ? void 0 : _a.keyInfo.xpub;
  };
  const handleRequestAddress = (message2) => {
    signing = true;
    const addressType = message2.withScriptType ? String(message2.withScriptType) : "p2wpkh";
    const withMessageSignature = message2.withMessageSignature ? message2.withMessageSignature : "";
    const withExtendedPublicKey = !!message2.withExtendedPublicKey;
    signAddress(
      addressType,
      withMessageSignature,
      code
    ).then((response) => {
      signing = false;
      if (response.success) {
        if (withExtendedPublicKey) {
          const xpub = getXPub(addressType);
          if (xpub) {
            sendAddressWithXPub(response.address, response.signature, xpub);
          } else {
            alertUser(t2("bitsuranceAccount.errorNoXpub"));
          }
        } else {
          sendAddressWithXPub(response.address, response.signature, "");
        }
      } else {
        if (!["userAbort", "wrongKeystore"].includes(response.errorCode || "")) {
          alertUser(t2("unknownError", { errorMessage: response.errorMessage }));
          console.log("error: " + response.errorMessage);
        }
      }
    });
  };
  const onMessage = (m2) => {
    if (!iframeURL || !code) {
      return;
    }
    if (m2.origin !== new URL(iframeURL).origin) {
      return;
    }
    try {
      let message2 = JSON.parse(m2.data);
      if ((message2 == null ? void 0 : message2.type) === "showInsuranceDashboard") {
        route("bitsurance/dashboard");
        return;
      }
      message2 = dist.parseMessage(m2.data);
      switch (message2.type) {
        case dist.V0MessageType.RequestAddress:
          if (!signing) {
            handleRequestAddress(message2);
          }
          break;
      }
    } catch (e3) {
      console.log(e3);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "contentWithGuide", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$7.header, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("bitsuranceAccount.title") }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: style$7.container, children: !agreedTerms ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        BitsuranceTerms,
        {
          onAgreedTerms: () => setAgreedTerms(true)
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { height }, children: [
        !iframeLoaded && /* @__PURE__ */ jsxRuntimeExports.jsx(Spinner, { guideExists: false, text: t2("loading") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          "iframe",
          {
            onLoad: () => {
              setIframeLoaded(true);
            },
            ref: iframeRef,
            title: "Bitsurance",
            width: "100%",
            height,
            frameBorder: "0",
            className: style$7.iframe,
            allow: "camera; payment",
            src: iframeURL
          }
        )
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] });
};
const text$1 = "_text_1dsup_1";
const accountName$3 = "_accountName_1dsup_6";
const accountsContainer = "_accountsContainer_1dsup_11";
const button = "_button_1dsup_17";
const coverageContainer = "_coverageContainer_1dsup_29";
const headerContainer$2 = "_headerContainer_1dsup_33";
const link$2 = "_link_1dsup_39";
const row = "_row_1dsup_43";
const statusContainer = "_statusContainer_1dsup_49";
const subtle = "_subtle_1dsup_53";
const title = "_title_1dsup_57";
const keystore = "_keystore_1dsup_63";
const style$6 = {
  text: text$1,
  accountName: accountName$3,
  accountsContainer,
  button,
  coverageContainer,
  headerContainer: headerContainer$2,
  link: link$2,
  row,
  statusContainer,
  subtle,
  title,
  keystore
};
const AccountStatusIcon = ({ status: status2 }) => {
  switch (status2) {
    case "active":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GreenDot, { width: 14, height: 20 });
    case "processing":
    case "waitpayment":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(YellowDot, { width: 14, height: 20 });
    case "refused":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 14, height: 20 });
    case "inactive":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(OrangeDot, { width: 14, height: 20 });
    case "canceled":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RedDot, { width: 14, height: 20 });
  }
};
const BitsuranceDashboard = ({ accounts }) => {
  const { t: t2 } = useTranslation();
  const mounted = useMountedRef();
  const [balances, setBalances] = reactExports.useState();
  const [insurances, setInsurances] = reactExports.useState();
  const [accountsByKeystore, setAccountsByKeystore] = reactExports.useState();
  const anyAccountInsured = (keystore2) => {
    var _a;
    return (_a = keystore2.accounts) == null ? void 0 : _a.some((account2) => !!account2.bitsuranceStatus);
  };
  const fetchInsurances = reactExports.useCallback(async () => {
    const response = await bitsuranceLookup();
    if (!response.success) {
      alertUser(response.errorMessage);
      return;
    }
    let accountsInsurance = {};
    response.bitsuranceAccounts.forEach((insurance) => {
      accountsInsurance[insurance.code] = insurance;
    });
    setInsurances(accountsInsurance);
  }, []);
  reactExports.useEffect(() => {
    setAccountsByKeystore(getAccountsByKeystore(accounts));
    fetchInsurances();
  }, [fetchInsurances, accounts]);
  reactExports.useEffect(() => {
    accountsByKeystore == null ? void 0 : accountsByKeystore.forEach((keystore2) => {
      keystore2.accounts.filter((account2) => !!account2.bitsuranceStatus).forEach((account2) => {
        getBalance(account2.code).then((balance2) => {
          if (!mounted.current) {
            return;
          }
          setBalances((prevBalances) => ({
            ...prevBalances,
            [account2.code]: balance2
          }));
        });
      });
    });
    return () => {
      setBalances(void 0);
    };
  }, [accountsByKeystore, mounted]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, { title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("sidebar.insurance") }), children: /* @__PURE__ */ jsxRuntimeExports.jsx(HideAmountsButton, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$6.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: style$6.title, children: t2("bitsurance.dashboard.title") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              className: style$6.button,
              primary: true,
              onClick: () => route("bitsurance/account"),
              title: t2("account.exportTransactions"),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "+" }),
                t2("bitsurance.dashboard.button")
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$6.accountsContainer, children: (accountsByKeystore == null ? void 0 : accountsByKeystore.length) && insurances ? accountsByKeystore.map(({ accounts: accounts2, keystore: keystore2 }) => anyAccountInsured({ accounts: accounts2, keystore: keystore2 }) && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$6.keystore, children: [
            keystore2.name,
            isAmbiguiousName(keystore2.name, accountsByKeystore) ? (
              // Disambiguate accounts group by adding the fingerprint.
              // The most common case where this would happen is when adding accounts from the
              // same seed using different passphrases.
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: style$6.subtle, children: [
                " (",
                keystore2.rootFingerprint,
                ")"
              ] })
            ) : null
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: (accounts2 == null ? void 0 : accounts2.length) ? accounts2.map((account2) => insurances && insurances[account2.code] ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$6.row, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-items-center", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} ${style$6.accountName}`, children: accounts2.filter((ac2) => ac2.code === account2.code).map((ac2) => ac2.name) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `${style$6.text} ${style$6.subtle}`, children: balances && balances[account2.code] ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Amount,
                  {
                    amount: balances[account2.code].available.amount,
                    unit: balances[account2.code].available.unit,
                    removeBtcTrailingZeroes: true
                  }
                ),
                ` ${balances[account2.code].available.unit}`
              ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton, {}) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "m-top-half m-bottom-half", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} ${style$6.subtle} m-bottom-quarter`, children: t2("bitsurance.dashboard.coverage") }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: style$6.text, children: [
                insurances[account2.code].details.maxCoverageFormatted,
                " ",
                insurances[account2.code].details.currency
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column-mobile", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(AccountStatusIcon, { status: insurances[account2.code].status }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${style$6.text} m-left-quarter m-right-half`, children: t2("bitsurance.dashboard." + insurances[account2.code].status) })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                A$3,
                {
                  className: `${style$6.text} ${style$6.link} m-top-quarter-on-small`,
                  href: insurances[account2.code].details.support,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(ExternalLink, { width: 16 }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "m-left-quarter", children: t2("bitsurance.dashboard.supportLink") })
                  ] })
                }
              )
            ] })
          ] }, account2.code) : null) : /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) })
        ] }, keystore2.rootFingerprint)) : /* @__PURE__ */ jsxRuntimeExports.jsx(HorizontallyCenteredSpinner, {}) })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceGuide, {})
  ] });
};
const WCWeb3WalletContext = reactExports.createContext({});
const WCGuide = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Guide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.whatIsWalletConnect")
      },
      "guide.walletConnect.whatIsWalletConnect"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.supportedNetworks")
      },
      "guide.walletConnect.supportedNetworks"
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Entry,
      {
        entry: t2("guide.walletConnect.noPreviousConnections")
      },
      "guide.walletConnect.noPreviousConnections"
    )
  ] });
};
const SUPPORTED_CHAINS = {
  "eip155:1": {
    name: "Etherum mainnet",
    icon: reactExports.createElement(ETHLogo)
  },
  "eip155:5": {
    name: "Ethereum goerli",
    icon: reactExports.createElement(ETHLogo)
  }
};
const EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  /**
     * Many dapps will request an 'eth_signTypedData' but in reality expect 'eth_signTypedData_v4'
     * because that's basically the standard. V4 is assumed, but not necessarily asked for specifically.
     * There aren't many uses of V3 in the wild, but leaving in just in case and returning a v4 signature instead,
     * the dapp can validate this anyway
     */
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction"
};
const getAddressFromEIPString = (address2) => {
  const parts = address2.split(":");
  return parts.length > 2 ? parts[2] : "";
};
const truncateAddress = (address2) => {
  if (!address2) {
    return "";
  }
  return `${address2.substring(0, 6)}...${address2.substring(address2.length - 6)}`;
};
const getTopicFromURI = (wcURI) => {
  try {
    return wcURI.split(":")[1].split("@")[0];
  } catch {
    return "";
  }
};
const pairingHasEverBeenRejected = (topic, web3wallet) => {
  return web3wallet.core.history.values.findIndex((history) => history.topic === topic && history.response && "error" in history.response) >= 0;
};
const rejectMessage = (id2) => {
  return {
    id: id2,
    jsonrpc: "2.0",
    error: {
      code: 5e3,
      message: "User rejected."
    }
  };
};
const decodeEthMessage = (hex) => {
  hex = hex.trim();
  if (hex.startsWith("0x")) {
    hex = hex.substring(2);
  }
  if (hex.length % 2 !== 0 || !/^[0-9a-fA-F]*$/.test(hex)) {
    console.error("Invalid hex string");
    return null;
  }
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < bytes.length; i++) {
    const byte = parseInt(hex.substring(i * 2, i * 2 + 2), 16);
    if (isNaN(byte)) {
      console.error("Invalid byte in hex string");
      return null;
    }
    bytes[i] = byte;
  }
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(bytes);
};
const headerContainer$1 = "_headerContainer_j3vgp_1";
const accountName$2 = "_accountName_j3vgp_28";
const receiveAddress$3 = "_receiveAddress_j3vgp_32";
const styles$a = {
  headerContainer: headerContainer$1,
  accountName: accountName$2,
  receiveAddress: receiveAddress$3
};
const WCHeader = ({ receiveAddress: receiveAddress2, accountName: accountName2 }) => {
  const displayedReceiveAddress = truncateAddress(receiveAddress2);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$a.headerContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDefaultLogo, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { children: "WalletConnect" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.accountName, children: accountName2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$a.receiveAddress, children: displayedReceiveAddress })
  ] });
};
const formContainer = "_formContainer_redt2_1";
const formButtonsContainer = "_formButtonsContainer_redt2_6";
const inputWithIcon = "_inputWithIcon_redt2_12";
const mobileQRScanner = "_mobileQRScanner_redt2_30";
const styles$9 = {
  formContainer,
  formButtonsContainer,
  inputWithIcon,
  mobileQRScanner
};
const MobileQRScanner = ({ onQRScanned }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$9.mobileQRScanner, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRVideo, { onResult: onQRScanned }) });
};
const WCConnectForm = ({
  code,
  uri,
  onInputChange,
  onSubmit,
  connectLoading
}) => {
  const { t: t2 } = useTranslation();
  const isMobile = useMediaQuery("(max-width: 768px)");
  const [activeScanQR, setActiveScanQR] = reactExports.useState(isMobile);
  const showMobileQRReader = isMobile;
  const showQRButton = !isMobile;
  const toggleScanQR = () => {
    if (activeScanQR) {
      setActiveScanQR(false);
      return;
    }
    setActiveScanQR(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.formContainer, children: [
    showMobileQRReader && /* @__PURE__ */ jsxRuntimeExports.jsx(MobileQRScanner, { onQRScanned: onSubmit }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "form",
      {
        onSubmit: (e3) => {
          e3.preventDefault();
          onSubmit(uri);
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input$2,
            {
              label: t2("walletConnect.connect.dappLabel"),
              className: showQRButton ? styles$9.inputWithIcon : "",
              value: uri,
              readOnly: connectLoading,
              onInput: (e3) => onInputChange(e3.target.value.replace(/\s/g, "")),
              children: showQRButton && !connectLoading && /* @__PURE__ */ jsxRuntimeExports.jsx(ScanQRButton, { onClick: toggleScanQR })
            }
          ),
          activeScanQR && !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ScanQRDialog,
            {
              toggleScanQR,
              onChangeActiveScanQR: setActiveScanQR,
              parseQRResult: (uri2) => onSubmit(uri2)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$9.formButtonsContainer, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading,
                secondary: true,
                onClick: () => route(`/account/${code}/wallet-connect/dashboard`),
                children: t2("dialog.cancel")
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                disabled: connectLoading || !uri,
                type: "submit",
                primary: true,
                children: t2("walletConnect.connect.button")
              }
            )
          ] })
        ]
      }
    )
  ] });
};
var chacha20poly1305 = {};
var chacha = {};
var binary = {};
var int = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  function imulShim(a2, b2) {
    var ah2 = a2 >>> 16 & 65535, al2 = a2 & 65535;
    var bh2 = b2 >>> 16 & 65535, bl2 = b2 & 65535;
    return al2 * bl2 + (ah2 * bl2 + al2 * bh2 << 16 >>> 0) | 0;
  }
  exports.mul = Math.imul || imulShim;
  function add(a2, b2) {
    return a2 + b2 | 0;
  }
  exports.add = add;
  function sub(a2, b2) {
    return a2 - b2 | 0;
  }
  exports.sub = sub;
  function rotl(x2, n2) {
    return x2 << n2 | x2 >>> 32 - n2;
  }
  exports.rotl = rotl;
  function rotr(x2, n2) {
    return x2 << 32 - n2 | x2 >>> n2;
  }
  exports.rotr = rotr;
  function isIntegerShim(n2) {
    return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2;
  }
  exports.isInteger = Number.isInteger || isIntegerShim;
  exports.MAX_SAFE_INTEGER = 9007199254740991;
  exports.isSafeInteger = function(n2) {
    return exports.isInteger(n2) && (n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER);
  };
})(int);
Object.defineProperty(binary, "__esModule", { value: true });
var int_1 = int;
function readInt16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
}
binary.readInt16BE = readInt16BE;
function readUint16BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
}
binary.readUint16BE = readUint16BE;
function readInt16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
}
binary.readInt16LE = readInt16LE;
function readUint16LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint16LE = readUint16LE;
function writeUint16BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 8;
  out[offset + 1] = value >>> 0;
  return out;
}
binary.writeUint16BE = writeUint16BE;
binary.writeInt16BE = writeUint16BE;
function writeUint16LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(2);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  return out;
}
binary.writeUint16LE = writeUint16LE;
binary.writeInt16LE = writeUint16LE;
function readInt32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
}
binary.readInt32BE = readInt32BE;
function readUint32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
}
binary.readUint32BE = readUint32BE;
function readInt32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
}
binary.readInt32LE = readInt32LE;
function readUint32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
}
binary.readUint32LE = readUint32LE;
function writeUint32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 24;
  out[offset + 1] = value >>> 16;
  out[offset + 2] = value >>> 8;
  out[offset + 3] = value >>> 0;
  return out;
}
binary.writeUint32BE = writeUint32BE;
binary.writeInt32BE = writeUint32BE;
function writeUint32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  out[offset + 0] = value >>> 0;
  out[offset + 1] = value >>> 8;
  out[offset + 2] = value >>> 16;
  out[offset + 3] = value >>> 24;
  return out;
}
binary.writeUint32LE = writeUint32LE;
binary.writeInt32LE = writeUint32LE;
function readInt64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readInt32BE(array, offset);
  var lo = readInt32BE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64BE = readInt64BE;
function readUint64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var hi2 = readUint32BE(array, offset);
  var lo = readUint32BE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64BE = readUint64BE;
function readInt64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readInt32LE(array, offset);
  var hi2 = readInt32LE(array, offset + 4);
  return hi2 * 4294967296 + lo - (lo >> 31) * 4294967296;
}
binary.readInt64LE = readInt64LE;
function readUint64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var lo = readUint32LE(array, offset);
  var hi2 = readUint32LE(array, offset + 4);
  return hi2 * 4294967296 + lo;
}
binary.readUint64LE = readUint64LE;
function writeUint64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32BE(value / 4294967296 >>> 0, out, offset);
  writeUint32BE(value >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64BE = writeUint64BE;
binary.writeInt64BE = writeUint64BE;
function writeUint64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  writeUint32LE(value >>> 0, out, offset);
  writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
  return out;
}
binary.writeUint64LE = writeUint64LE;
binary.writeInt64LE = writeUint64LE;
function readUintBE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintBE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintBE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    result += array[i] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintBE = readUintBE;
function readUintLE(bitLength, array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("readUintLE supports only bitLengths divisible by 8");
  }
  if (bitLength / 8 > array.length - offset) {
    throw new Error("readUintLE: array is too short for the given bitLength");
  }
  var result = 0;
  var mul = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    result += array[i] * mul;
    mul *= 256;
  }
  return result;
}
binary.readUintLE = readUintLE;
function writeUintBE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintBE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintBE value must be an integer");
  }
  var div = 1;
  for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintBE = writeUintBE;
function writeUintLE(bitLength, value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(bitLength / 8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (bitLength % 8 !== 0) {
    throw new Error("writeUintLE supports only bitLengths divisible by 8");
  }
  if (!int_1.isSafeInteger(value)) {
    throw new Error("writeUintLE value must be an integer");
  }
  var div = 1;
  for (var i = offset; i < offset + bitLength / 8; i++) {
    out[i] = value / div & 255;
    div *= 256;
  }
  return out;
}
binary.writeUintLE = writeUintLE;
function readFloat32BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset);
}
binary.readFloat32BE = readFloat32BE;
function readFloat32LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat32(offset, true);
}
binary.readFloat32LE = readFloat32LE;
function readFloat64BE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset);
}
binary.readFloat64BE = readFloat64BE;
function readFloat64LE(array, offset) {
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
  return view.getFloat64(offset, true);
}
binary.readFloat64LE = readFloat64LE;
function writeFloat32BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value);
  return out;
}
binary.writeFloat32BE = writeFloat32BE;
function writeFloat32LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(4);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat32(offset, value, true);
  return out;
}
binary.writeFloat32LE = writeFloat32LE;
function writeFloat64BE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value);
  return out;
}
binary.writeFloat64BE = writeFloat64BE;
function writeFloat64LE(value, out, offset) {
  if (out === void 0) {
    out = new Uint8Array(8);
  }
  if (offset === void 0) {
    offset = 0;
  }
  var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
  view.setFloat64(offset, value, true);
  return out;
}
binary.writeFloat64LE = writeFloat64LE;
var wipe$1 = {};
Object.defineProperty(wipe$1, "__esModule", { value: true });
function wipe(array) {
  for (var i = 0; i < array.length; i++) {
    array[i] = 0;
  }
  return array;
}
wipe$1.wipe = wipe;
Object.defineProperty(chacha, "__esModule", { value: true });
var binary_1 = binary;
var wipe_1$3 = wipe$1;
var ROUNDS = 20;
function core(out, input2, key) {
  var j0 = 1634760805;
  var j1 = 857760878;
  var j2 = 2036477234;
  var j3 = 1797285236;
  var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
  var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
  var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
  var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
  var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
  var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
  var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
  var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
  var j12 = input2[3] << 24 | input2[2] << 16 | input2[1] << 8 | input2[0];
  var j13 = input2[7] << 24 | input2[6] << 16 | input2[5] << 8 | input2[4];
  var j14 = input2[11] << 24 | input2[10] << 16 | input2[9] << 8 | input2[8];
  var j15 = input2[15] << 24 | input2[14] << 16 | input2[13] << 8 | input2[12];
  var x0 = j0;
  var x1 = j1;
  var x2 = j2;
  var x3 = j3;
  var x4 = j4;
  var x5 = j5;
  var x6 = j6;
  var x7 = j7;
  var x8 = j8;
  var x9 = j9;
  var x10 = j10;
  var x11 = j11;
  var x12 = j12;
  var x13 = j13;
  var x14 = j14;
  var x15 = j15;
  for (var i = 0; i < ROUNDS; i += 2) {
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x2 = x2 + x6 | 0;
    x14 ^= x2;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x10 = x10 + x14 | 0;
    x6 ^= x10;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x3 = x3 + x7 | 0;
    x15 ^= x3;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x11 = x11 + x15 | 0;
    x7 ^= x11;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x1 = x1 + x5 | 0;
    x13 ^= x1;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x9 = x9 + x13 | 0;
    x5 ^= x9;
    x5 = x5 >>> 32 - 7 | x5 << 7;
    x0 = x0 + x4 | 0;
    x12 ^= x0;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x8 = x8 + x12 | 0;
    x4 ^= x8;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 16 | x15 << 16;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 12 | x5 << 12;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 16 | x12 << 16;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 12 | x6 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 16 | x13 << 16;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 12 | x7 << 12;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 16 | x14 << 16;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 12 | x4 << 12;
    x2 = x2 + x7 | 0;
    x13 ^= x2;
    x13 = x13 >>> 32 - 8 | x13 << 8;
    x8 = x8 + x13 | 0;
    x7 ^= x8;
    x7 = x7 >>> 32 - 7 | x7 << 7;
    x3 = x3 + x4 | 0;
    x14 ^= x3;
    x14 = x14 >>> 32 - 8 | x14 << 8;
    x9 = x9 + x14 | 0;
    x4 ^= x9;
    x4 = x4 >>> 32 - 7 | x4 << 7;
    x1 = x1 + x6 | 0;
    x12 ^= x1;
    x12 = x12 >>> 32 - 8 | x12 << 8;
    x11 = x11 + x12 | 0;
    x6 ^= x11;
    x6 = x6 >>> 32 - 7 | x6 << 7;
    x0 = x0 + x5 | 0;
    x15 ^= x0;
    x15 = x15 >>> 32 - 8 | x15 << 8;
    x10 = x10 + x15 | 0;
    x5 ^= x10;
    x5 = x5 >>> 32 - 7 | x5 << 7;
  }
  binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
  binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
  binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
  binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
  binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
  binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
  binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
  binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
  binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
  binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
  binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
  binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
  binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
  binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
  binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
  binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
}
function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  if (key.length !== 32) {
    throw new Error("ChaCha: key size must be 32 bytes");
  }
  if (dst.length < src2.length) {
    throw new Error("ChaCha: destination is shorter than source");
  }
  var nc2;
  var counterLength;
  if (nonceInplaceCounterLength === 0) {
    if (nonce.length !== 8 && nonce.length !== 12) {
      throw new Error("ChaCha nonce must be 8 or 12 bytes");
    }
    nc2 = new Uint8Array(16);
    counterLength = nc2.length - nonce.length;
    nc2.set(nonce, counterLength);
  } else {
    if (nonce.length !== 16) {
      throw new Error("ChaCha nonce with counter must be 16 bytes");
    }
    nc2 = nonce;
    counterLength = nonceInplaceCounterLength;
  }
  var block2 = new Uint8Array(64);
  for (var i = 0; i < src2.length; i += 64) {
    core(block2, nc2, key);
    for (var j2 = i; j2 < i + 64 && j2 < src2.length; j2++) {
      dst[j2] = src2[j2] ^ block2[j2 - i];
    }
    incrementCounter(nc2, 0, counterLength);
  }
  wipe_1$3.wipe(block2);
  if (nonceInplaceCounterLength === 0) {
    wipe_1$3.wipe(nc2);
  }
  return dst;
}
chacha.streamXOR = streamXOR;
function stream(key, nonce, dst, nonceInplaceCounterLength) {
  if (nonceInplaceCounterLength === void 0) {
    nonceInplaceCounterLength = 0;
  }
  wipe_1$3.wipe(dst);
  return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
chacha.stream = stream;
function incrementCounter(counter, pos, len) {
  var carry = 1;
  while (len--) {
    carry = carry + (counter[pos] & 255) | 0;
    counter[pos] = carry & 255;
    carry >>>= 8;
    pos++;
  }
  if (carry > 0) {
    throw new Error("ChaCha: counter overflow");
  }
}
var poly1305 = {};
var constantTime = {};
Object.defineProperty(constantTime, "__esModule", { value: true });
function select(subject, resultIfOne, resultIfZero) {
  return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
}
constantTime.select = select;
function lessOrEqual(a2, b2) {
  return (a2 | 0) - (b2 | 0) - 1 >>> 31 & 1;
}
constantTime.lessOrEqual = lessOrEqual;
function compare(a2, b2) {
  if (a2.length !== b2.length) {
    return 0;
  }
  var result = 0;
  for (var i = 0; i < a2.length; i++) {
    result |= a2[i] ^ b2[i];
  }
  return 1 & result - 1 >>> 8;
}
constantTime.compare = compare;
function equal$1(a2, b2) {
  if (a2.length === 0 || b2.length === 0) {
    return false;
  }
  return compare(a2, b2) !== 0;
}
constantTime.equal = equal$1;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var constant_time_12 = constantTime;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 16;
  var Poly1305 = (
    /** @class */
    function() {
      function Poly13052(key) {
        this.digestLength = exports.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m2, mpos, bytes) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
          var t0 = m2[mpos + 0] | m2[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m2[mpos + 2] | m2[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m2[mpos + 4] | m2[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m2[mpos + 6] | m2[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m2[mpos + 8] | m2[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m2[mpos + 10] | m2[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m2[mpos + 12] | m2[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m2[mpos + 14] | m2[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c2 = 0;
          var d0 = c2;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c2 = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c2 += d0 >>> 13;
          d0 &= 8191;
          var d1 = c2;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c2 = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c2 += d1 >>> 13;
          d1 &= 8191;
          var d2 = c2;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c2 = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c2 += d2 >>> 13;
          d2 &= 8191;
          var d3 = c2;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c2 = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c2 += d3 >>> 13;
          d3 &= 8191;
          var d4 = c2;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c2 = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c2 += d4 >>> 13;
          d4 &= 8191;
          var d5 = c2;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c2 = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c2 += d5 >>> 13;
          d5 &= 8191;
          var d6 = c2;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c2 = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c2 += d6 >>> 13;
          d6 &= 8191;
          var d7 = c2;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c2 = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c2 += d7 >>> 13;
          d7 &= 8191;
          var d8 = c2;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c2 = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c2 += d8 >>> 13;
          d8 &= 8191;
          var d9 = c2;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c2 = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c2 += d9 >>> 13;
          d9 &= 8191;
          c2 = (c2 << 2) + c2 | 0;
          c2 = c2 + d0 | 0;
          d0 = c2 & 8191;
          c2 = c2 >>> 13;
          d1 += c2;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g2 = new Uint16Array(10);
        var c2;
        var mask;
        var f2;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c2;
          c2 = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c2 * 5;
        c2 = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c2;
        c2 = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c2;
        g2[0] = this._h[0] + 5;
        c2 = g2[0] >>> 13;
        g2[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g2[i] = this._h[i] + c2;
          c2 = g2[i] >>> 13;
          g2[i] &= 8191;
        }
        g2[9] -= 1 << 13;
        mask = (c2 ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g2[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g2[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f2 = this._h[0] + this._pad[0];
        this._h[0] = f2 & 65535;
        for (i = 1; i < 8; i++) {
          f2 = (this._h[i] + this._pad[i] | 0) + (f2 >>> 16) | 0;
          this._h[i] = f2 & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m2) {
        var mpos = 0;
        var bytes = m2.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes) {
            want = bytes;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m2[mpos + i];
          }
          bytes -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this._blocks(m2, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (var i = 0; i < bytes; i++) {
            this._buffer[this._leftover + i] = m2[mpos + i];
          }
          this._leftover += bytes;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._r);
        wipe_12.wipe(this._h);
        wipe_12.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }()
  );
  exports.Poly1305 = Poly1305;
  function oneTimeAuth(key, data) {
    var h2 = new Poly1305(key);
    h2.update(data);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.oneTimeAuth = oneTimeAuth;
  function equal2(a2, b2) {
    if (a2.length !== exports.DIGEST_LENGTH || b2.length !== exports.DIGEST_LENGTH) {
      return false;
    }
    return constant_time_12.equal(a2, b2);
  }
  exports.equal = equal2;
})(poly1305);
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var chacha_1 = chacha;
  var poly1305_1 = poly1305;
  var wipe_12 = wipe$1;
  var binary_12 = binary;
  var constant_time_12 = constantTime;
  exports.KEY_LENGTH = 32;
  exports.NONCE_LENGTH = 12;
  exports.TAG_LENGTH = 16;
  var ZEROS = new Uint8Array(16);
  var ChaCha20Poly1305 = (
    /** @class */
    function() {
      function ChaCha20Poly13052(key) {
        this.nonceLength = exports.NONCE_LENGTH;
        this.tagLength = exports.TAG_LENGTH;
        if (key.length !== exports.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_12.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_12.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_12.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h2 = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h2.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h2.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h2.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h2.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length2 = new Uint8Array(8);
        if (associatedData) {
          binary_12.writeUint64LE(associatedData.length, length2);
        }
        h2.update(length2);
        binary_12.writeUint64LE(ciphertext.length, length2);
        h2.update(length2);
        var tag = h2.digest();
        for (var i = 0; i < tag.length; i++) {
          tagOut[i] = tag[i];
        }
        h2.clean();
        wipe_12.wipe(tag);
        wipe_12.wipe(length2);
      };
      return ChaCha20Poly13052;
    }()
  );
  exports.ChaCha20Poly1305 = ChaCha20Poly1305;
})(chacha20poly1305);
var hkdf = {};
var hmac$1 = {};
var hash = {};
Object.defineProperty(hash, "__esModule", { value: true });
function isSerializableHash(h2) {
  return typeof h2.saveState !== "undefined" && typeof h2.restoreState !== "undefined" && typeof h2.cleanSavedState !== "undefined";
}
hash.isSerializableHash = isSerializableHash;
Object.defineProperty(hmac$1, "__esModule", { value: true });
var hash_1 = hash;
var constant_time_1 = constantTime;
var wipe_1$2 = wipe$1;
var HMAC = (
  /** @class */
  function() {
    function HMAC2(hash2, key) {
      this._finished = false;
      this._inner = new hash2();
      this._outer = new hash2();
      this.blockSize = this._outer.blockSize;
      this.digestLength = this._outer.digestLength;
      var pad = new Uint8Array(this.blockSize);
      if (key.length > this.blockSize) {
        this._inner.update(key).finish(pad).clean();
      } else {
        pad.set(key);
      }
      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 54;
      }
      this._inner.update(pad);
      for (var i = 0; i < pad.length; i++) {
        pad[i] ^= 54 ^ 92;
      }
      this._outer.update(pad);
      if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
        this._innerKeyedState = this._inner.saveState();
        this._outerKeyedState = this._outer.saveState();
      }
      wipe_1$2.wipe(pad);
    }
    HMAC2.prototype.reset = function() {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
      }
      this._inner.restoreState(this._innerKeyedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.clean = function() {
      if (hash_1.isSerializableHash(this._inner)) {
        this._inner.cleanSavedState(this._innerKeyedState);
      }
      if (hash_1.isSerializableHash(this._outer)) {
        this._outer.cleanSavedState(this._outerKeyedState);
      }
      this._inner.clean();
      this._outer.clean();
    };
    HMAC2.prototype.update = function(data) {
      this._inner.update(data);
      return this;
    };
    HMAC2.prototype.finish = function(out) {
      if (this._finished) {
        this._outer.finish(out);
        return this;
      }
      this._inner.finish(out);
      this._outer.update(out.subarray(0, this.digestLength)).finish(out);
      this._finished = true;
      return this;
    };
    HMAC2.prototype.digest = function() {
      var out = new Uint8Array(this.digestLength);
      this.finish(out);
      return out;
    };
    HMAC2.prototype.saveState = function() {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't saveState() because hash doesn't implement it");
      }
      return this._inner.saveState();
    };
    HMAC2.prototype.restoreState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
        throw new Error("hmac: can't restoreState() because hash doesn't implement it");
      }
      this._inner.restoreState(savedState);
      this._outer.restoreState(this._outerKeyedState);
      this._finished = false;
      return this;
    };
    HMAC2.prototype.cleanSavedState = function(savedState) {
      if (!hash_1.isSerializableHash(this._inner)) {
        throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
      }
      this._inner.cleanSavedState(savedState);
    };
    return HMAC2;
  }()
);
hmac$1.HMAC = HMAC;
function hmac(hash2, key, data) {
  var h2 = new HMAC(hash2, key);
  h2.update(data);
  var digest = h2.digest();
  h2.clean();
  return digest;
}
hmac$1.hmac = hmac;
hmac$1.equal = constant_time_1.equal;
Object.defineProperty(hkdf, "__esModule", { value: true });
var hmac_1 = hmac$1;
var wipe_1$1 = wipe$1;
var HKDF = (
  /** @class */
  function() {
    function HKDF2(hash2, key, salt, info2) {
      if (salt === void 0) {
        salt = new Uint8Array(0);
      }
      this._counter = new Uint8Array(1);
      this._hash = hash2;
      this._info = info2;
      var okm = hmac_1.hmac(this._hash, salt, key);
      this._hmac = new hmac_1.HMAC(hash2, okm);
      this._buffer = new Uint8Array(this._hmac.digestLength);
      this._bufpos = this._buffer.length;
    }
    HKDF2.prototype._fillBuffer = function() {
      this._counter[0]++;
      var ctr = this._counter[0];
      if (ctr === 0) {
        throw new Error("hkdf: cannot expand more");
      }
      this._hmac.reset();
      if (ctr > 1) {
        this._hmac.update(this._buffer);
      }
      if (this._info) {
        this._hmac.update(this._info);
      }
      this._hmac.update(this._counter);
      this._hmac.finish(this._buffer);
      this._bufpos = 0;
    };
    HKDF2.prototype.expand = function(length2) {
      var out = new Uint8Array(length2);
      for (var i = 0; i < out.length; i++) {
        if (this._bufpos === this._buffer.length) {
          this._fillBuffer();
        }
        out[i] = this._buffer[this._bufpos++];
      }
      return out;
    };
    HKDF2.prototype.clean = function() {
      this._hmac.clean();
      wipe_1$1.wipe(this._buffer);
      wipe_1$1.wipe(this._counter);
      this._bufpos = 0;
    };
    return HKDF2;
  }()
);
var HKDF_1 = hkdf.HKDF = HKDF;
var random = {};
var system = {};
var browser = {};
Object.defineProperty(browser, "__esModule", { value: true });
browser.BrowserRandomSource = void 0;
const QUOTA = 65536;
class BrowserRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
    if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
      this._crypto = browserCrypto;
      this.isAvailable = true;
      this.isInstantiated = true;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Browser random byte generator is not available.");
    }
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i += QUOTA) {
      this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
    }
    return out;
  }
}
browser.BrowserRandomSource = BrowserRandomSource;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var node = {};
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
Object.defineProperty(node, "__esModule", { value: true });
node.NodeRandomSource = void 0;
const wipe_1 = wipe$1;
class NodeRandomSource {
  constructor() {
    this.isAvailable = false;
    this.isInstantiated = false;
    if (typeof commonjsRequire !== "undefined") {
      const nodeCrypto = require$$0$1;
      if (nodeCrypto && nodeCrypto.randomBytes) {
        this._crypto = nodeCrypto;
        this.isAvailable = true;
        this.isInstantiated = true;
      }
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable || !this._crypto) {
      throw new Error("Node.js random byte generator is not available.");
    }
    let buffer = this._crypto.randomBytes(length2);
    if (buffer.length !== length2) {
      throw new Error("NodeRandomSource: got fewer bytes than requested");
    }
    const out = new Uint8Array(length2);
    for (let i = 0; i < out.length; i++) {
      out[i] = buffer[i];
    }
    (0, wipe_1.wipe)(buffer);
    return out;
  }
}
node.NodeRandomSource = NodeRandomSource;
Object.defineProperty(system, "__esModule", { value: true });
system.SystemRandomSource = void 0;
const browser_1 = browser;
const node_1 = node;
class SystemRandomSource {
  constructor() {
    this.isAvailable = false;
    this.name = "";
    this._source = new browser_1.BrowserRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Browser";
      return;
    }
    this._source = new node_1.NodeRandomSource();
    if (this._source.isAvailable) {
      this.isAvailable = true;
      this.name = "Node";
      return;
    }
  }
  randomBytes(length2) {
    if (!this.isAvailable) {
      throw new Error("System random byte generator is not available.");
    }
    return this._source.randomBytes(length2);
  }
}
system.SystemRandomSource = SystemRandomSource;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
  const system_1 = system;
  const binary_12 = binary;
  const wipe_12 = wipe$1;
  exports.defaultRandomSource = new system_1.SystemRandomSource();
  function randomBytes(length2, prng = exports.defaultRandomSource) {
    return prng.randomBytes(length2);
  }
  exports.randomBytes = randomBytes;
  function randomUint32(prng = exports.defaultRandomSource) {
    const buf = randomBytes(4, prng);
    const result = (0, binary_12.readUint32LE)(buf);
    (0, wipe_12.wipe)(buf);
    return result;
  }
  exports.randomUint32 = randomUint32;
  const ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
  function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    if (charset.length < 2) {
      throw new Error("randomString charset is too short");
    }
    if (charset.length > 256) {
      throw new Error("randomString charset is too long");
    }
    let out = "";
    const charsLen = charset.length;
    const maxByte = 256 - 256 % charsLen;
    while (length2 > 0) {
      const buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
      for (let i = 0; i < buf.length && length2 > 0; i++) {
        const randomByte = buf[i];
        if (randomByte < maxByte) {
          out += charset.charAt(randomByte % charsLen);
          length2--;
        }
      }
      (0, wipe_12.wipe)(buf);
    }
    return out;
  }
  exports.randomString = randomString;
  function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
    const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
    return randomString(length2, charset, prng);
  }
  exports.randomStringForEntropy = randomStringForEntropy;
})(random);
var sha256 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var binary_12 = binary;
  var wipe_12 = wipe$1;
  exports.DIGEST_LENGTH = 32;
  exports.BLOCK_SIZE = 64;
  var SHA256 = (
    /** @class */
    function() {
      function SHA2562() {
        this.digestLength = exports.DIGEST_LENGTH;
        this.blockSize = exports.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_12.wipe(this._buffer);
        wipe_12.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left2 = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left2] = 128;
          for (var i = left2 + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_12.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_12.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_12.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_12.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_12.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }()
  );
  exports.SHA256 = SHA256;
  var K2 = new Int32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  function hashBlocks(w2, v2, p2, pos, len) {
    while (len >= 64) {
      var a2 = v2[0];
      var b2 = v2[1];
      var c2 = v2[2];
      var d2 = v2[3];
      var e3 = v2[4];
      var f2 = v2[5];
      var g2 = v2[6];
      var h2 = v2[7];
      for (var i = 0; i < 16; i++) {
        var j2 = pos + i * 4;
        w2[i] = binary_12.readUint32BE(p2, j2);
      }
      for (var i = 16; i < 64; i++) {
        var u2 = w2[i - 2];
        var t1 = (u2 >>> 17 | u2 << 32 - 17) ^ (u2 >>> 19 | u2 << 32 - 19) ^ u2 >>> 10;
        u2 = w2[i - 15];
        var t2 = (u2 >>> 7 | u2 << 32 - 7) ^ (u2 >>> 18 | u2 << 32 - 18) ^ u2 >>> 3;
        w2[i] = (t1 + w2[i - 7] | 0) + (t2 + w2[i - 16] | 0);
      }
      for (var i = 0; i < 64; i++) {
        var t1 = (((e3 >>> 6 | e3 << 32 - 6) ^ (e3 >>> 11 | e3 << 32 - 11) ^ (e3 >>> 25 | e3 << 32 - 25)) + (e3 & f2 ^ ~e3 & g2) | 0) + (h2 + (K2[i] + w2[i] | 0) | 0) | 0;
        var t2 = ((a2 >>> 2 | a2 << 32 - 2) ^ (a2 >>> 13 | a2 << 32 - 13) ^ (a2 >>> 22 | a2 << 32 - 22)) + (a2 & b2 ^ a2 & c2 ^ b2 & c2) | 0;
        h2 = g2;
        g2 = f2;
        f2 = e3;
        e3 = d2 + t1 | 0;
        d2 = c2;
        c2 = b2;
        b2 = a2;
        a2 = t1 + t2 | 0;
      }
      v2[0] += a2;
      v2[1] += b2;
      v2[2] += c2;
      v2[3] += d2;
      v2[4] += e3;
      v2[5] += f2;
      v2[6] += g2;
      v2[7] += h2;
      pos += 64;
      len -= 64;
    }
    return pos;
  }
  function hash2(data) {
    var h2 = new SHA256();
    h2.update(data);
    var digest = h2.digest();
    h2.clean();
    return digest;
  }
  exports.hash = hash2;
})(sha256);
var x25519 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sharedKey = exports.generateKeyPair = exports.generateKeyPairFromSeed = exports.scalarMultBase = exports.scalarMult = exports.SHARED_KEY_LENGTH = exports.SECRET_KEY_LENGTH = exports.PUBLIC_KEY_LENGTH = void 0;
  const random_1 = random;
  const wipe_12 = wipe$1;
  exports.PUBLIC_KEY_LENGTH = 32;
  exports.SECRET_KEY_LENGTH = 32;
  exports.SHARED_KEY_LENGTH = 32;
  function gf(init2) {
    const r2 = new Float64Array(16);
    if (init2) {
      for (let i = 0; i < init2.length; i++) {
        r2[i] = init2[i];
      }
    }
    return r2;
  }
  const _92 = new Uint8Array(32);
  _92[0] = 9;
  const _121665 = gf([56129, 1]);
  function car25519(o2) {
    let c2 = 1;
    for (let i = 0; i < 16; i++) {
      let v2 = o2[i] + c2 + 65535;
      c2 = Math.floor(v2 / 65536);
      o2[i] = v2 - c2 * 65536;
    }
    o2[0] += c2 - 1 + 37 * (c2 - 1);
  }
  function sel25519(p2, q2, b2) {
    const c2 = ~(b2 - 1);
    for (let i = 0; i < 16; i++) {
      const t2 = c2 & (p2[i] ^ q2[i]);
      p2[i] ^= t2;
      q2[i] ^= t2;
    }
  }
  function pack25519(o2, n2) {
    const m2 = gf();
    const t2 = gf();
    for (let i = 0; i < 16; i++) {
      t2[i] = n2[i];
    }
    car25519(t2);
    car25519(t2);
    car25519(t2);
    for (let j2 = 0; j2 < 2; j2++) {
      m2[0] = t2[0] - 65517;
      for (let i = 1; i < 15; i++) {
        m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
        m2[i - 1] &= 65535;
      }
      m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
      const b2 = m2[15] >> 16 & 1;
      m2[14] &= 65535;
      sel25519(t2, m2, 1 - b2);
    }
    for (let i = 0; i < 16; i++) {
      o2[2 * i] = t2[i] & 255;
      o2[2 * i + 1] = t2[i] >> 8;
    }
  }
  function unpack25519(o2, n2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = n2[2 * i] + (n2[2 * i + 1] << 8);
    }
    o2[15] &= 32767;
  }
  function add(o2, a2, b2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = a2[i] + b2[i];
    }
  }
  function sub(o2, a2, b2) {
    for (let i = 0; i < 16; i++) {
      o2[i] = a2[i] - b2[i];
    }
  }
  function mul(o2, a2, b2) {
    let v2, c2, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
    v2 = a2[0];
    t0 += v2 * b0;
    t1 += v2 * b1;
    t2 += v2 * b22;
    t3 += v2 * b3;
    t4 += v2 * b4;
    t5 += v2 * b5;
    t6 += v2 * b6;
    t7 += v2 * b7;
    t8 += v2 * b8;
    t9 += v2 * b9;
    t10 += v2 * b10;
    t11 += v2 * b11;
    t12 += v2 * b12;
    t13 += v2 * b13;
    t14 += v2 * b14;
    t15 += v2 * b15;
    v2 = a2[1];
    t1 += v2 * b0;
    t2 += v2 * b1;
    t3 += v2 * b22;
    t4 += v2 * b3;
    t5 += v2 * b4;
    t6 += v2 * b5;
    t7 += v2 * b6;
    t8 += v2 * b7;
    t9 += v2 * b8;
    t10 += v2 * b9;
    t11 += v2 * b10;
    t12 += v2 * b11;
    t13 += v2 * b12;
    t14 += v2 * b13;
    t15 += v2 * b14;
    t16 += v2 * b15;
    v2 = a2[2];
    t2 += v2 * b0;
    t3 += v2 * b1;
    t4 += v2 * b22;
    t5 += v2 * b3;
    t6 += v2 * b4;
    t7 += v2 * b5;
    t8 += v2 * b6;
    t9 += v2 * b7;
    t10 += v2 * b8;
    t11 += v2 * b9;
    t12 += v2 * b10;
    t13 += v2 * b11;
    t14 += v2 * b12;
    t15 += v2 * b13;
    t16 += v2 * b14;
    t17 += v2 * b15;
    v2 = a2[3];
    t3 += v2 * b0;
    t4 += v2 * b1;
    t5 += v2 * b22;
    t6 += v2 * b3;
    t7 += v2 * b4;
    t8 += v2 * b5;
    t9 += v2 * b6;
    t10 += v2 * b7;
    t11 += v2 * b8;
    t12 += v2 * b9;
    t13 += v2 * b10;
    t14 += v2 * b11;
    t15 += v2 * b12;
    t16 += v2 * b13;
    t17 += v2 * b14;
    t18 += v2 * b15;
    v2 = a2[4];
    t4 += v2 * b0;
    t5 += v2 * b1;
    t6 += v2 * b22;
    t7 += v2 * b3;
    t8 += v2 * b4;
    t9 += v2 * b5;
    t10 += v2 * b6;
    t11 += v2 * b7;
    t12 += v2 * b8;
    t13 += v2 * b9;
    t14 += v2 * b10;
    t15 += v2 * b11;
    t16 += v2 * b12;
    t17 += v2 * b13;
    t18 += v2 * b14;
    t19 += v2 * b15;
    v2 = a2[5];
    t5 += v2 * b0;
    t6 += v2 * b1;
    t7 += v2 * b22;
    t8 += v2 * b3;
    t9 += v2 * b4;
    t10 += v2 * b5;
    t11 += v2 * b6;
    t12 += v2 * b7;
    t13 += v2 * b8;
    t14 += v2 * b9;
    t15 += v2 * b10;
    t16 += v2 * b11;
    t17 += v2 * b12;
    t18 += v2 * b13;
    t19 += v2 * b14;
    t20 += v2 * b15;
    v2 = a2[6];
    t6 += v2 * b0;
    t7 += v2 * b1;
    t8 += v2 * b22;
    t9 += v2 * b3;
    t10 += v2 * b4;
    t11 += v2 * b5;
    t12 += v2 * b6;
    t13 += v2 * b7;
    t14 += v2 * b8;
    t15 += v2 * b9;
    t16 += v2 * b10;
    t17 += v2 * b11;
    t18 += v2 * b12;
    t19 += v2 * b13;
    t20 += v2 * b14;
    t21 += v2 * b15;
    v2 = a2[7];
    t7 += v2 * b0;
    t8 += v2 * b1;
    t9 += v2 * b22;
    t10 += v2 * b3;
    t11 += v2 * b4;
    t12 += v2 * b5;
    t13 += v2 * b6;
    t14 += v2 * b7;
    t15 += v2 * b8;
    t16 += v2 * b9;
    t17 += v2 * b10;
    t18 += v2 * b11;
    t19 += v2 * b12;
    t20 += v2 * b13;
    t21 += v2 * b14;
    t22 += v2 * b15;
    v2 = a2[8];
    t8 += v2 * b0;
    t9 += v2 * b1;
    t10 += v2 * b22;
    t11 += v2 * b3;
    t12 += v2 * b4;
    t13 += v2 * b5;
    t14 += v2 * b6;
    t15 += v2 * b7;
    t16 += v2 * b8;
    t17 += v2 * b9;
    t18 += v2 * b10;
    t19 += v2 * b11;
    t20 += v2 * b12;
    t21 += v2 * b13;
    t22 += v2 * b14;
    t23 += v2 * b15;
    v2 = a2[9];
    t9 += v2 * b0;
    t10 += v2 * b1;
    t11 += v2 * b22;
    t12 += v2 * b3;
    t13 += v2 * b4;
    t14 += v2 * b5;
    t15 += v2 * b6;
    t16 += v2 * b7;
    t17 += v2 * b8;
    t18 += v2 * b9;
    t19 += v2 * b10;
    t20 += v2 * b11;
    t21 += v2 * b12;
    t22 += v2 * b13;
    t23 += v2 * b14;
    t24 += v2 * b15;
    v2 = a2[10];
    t10 += v2 * b0;
    t11 += v2 * b1;
    t12 += v2 * b22;
    t13 += v2 * b3;
    t14 += v2 * b4;
    t15 += v2 * b5;
    t16 += v2 * b6;
    t17 += v2 * b7;
    t18 += v2 * b8;
    t19 += v2 * b9;
    t20 += v2 * b10;
    t21 += v2 * b11;
    t22 += v2 * b12;
    t23 += v2 * b13;
    t24 += v2 * b14;
    t25 += v2 * b15;
    v2 = a2[11];
    t11 += v2 * b0;
    t12 += v2 * b1;
    t13 += v2 * b22;
    t14 += v2 * b3;
    t15 += v2 * b4;
    t16 += v2 * b5;
    t17 += v2 * b6;
    t18 += v2 * b7;
    t19 += v2 * b8;
    t20 += v2 * b9;
    t21 += v2 * b10;
    t22 += v2 * b11;
    t23 += v2 * b12;
    t24 += v2 * b13;
    t25 += v2 * b14;
    t26 += v2 * b15;
    v2 = a2[12];
    t12 += v2 * b0;
    t13 += v2 * b1;
    t14 += v2 * b22;
    t15 += v2 * b3;
    t16 += v2 * b4;
    t17 += v2 * b5;
    t18 += v2 * b6;
    t19 += v2 * b7;
    t20 += v2 * b8;
    t21 += v2 * b9;
    t22 += v2 * b10;
    t23 += v2 * b11;
    t24 += v2 * b12;
    t25 += v2 * b13;
    t26 += v2 * b14;
    t27 += v2 * b15;
    v2 = a2[13];
    t13 += v2 * b0;
    t14 += v2 * b1;
    t15 += v2 * b22;
    t16 += v2 * b3;
    t17 += v2 * b4;
    t18 += v2 * b5;
    t19 += v2 * b6;
    t20 += v2 * b7;
    t21 += v2 * b8;
    t22 += v2 * b9;
    t23 += v2 * b10;
    t24 += v2 * b11;
    t25 += v2 * b12;
    t26 += v2 * b13;
    t27 += v2 * b14;
    t28 += v2 * b15;
    v2 = a2[14];
    t14 += v2 * b0;
    t15 += v2 * b1;
    t16 += v2 * b22;
    t17 += v2 * b3;
    t18 += v2 * b4;
    t19 += v2 * b5;
    t20 += v2 * b6;
    t21 += v2 * b7;
    t22 += v2 * b8;
    t23 += v2 * b9;
    t24 += v2 * b10;
    t25 += v2 * b11;
    t26 += v2 * b12;
    t27 += v2 * b13;
    t28 += v2 * b14;
    t29 += v2 * b15;
    v2 = a2[15];
    t15 += v2 * b0;
    t16 += v2 * b1;
    t17 += v2 * b22;
    t18 += v2 * b3;
    t19 += v2 * b4;
    t20 += v2 * b5;
    t21 += v2 * b6;
    t22 += v2 * b7;
    t23 += v2 * b8;
    t24 += v2 * b9;
    t25 += v2 * b10;
    t26 += v2 * b11;
    t27 += v2 * b12;
    t28 += v2 * b13;
    t29 += v2 * b14;
    t30 += v2 * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    c2 = 1;
    v2 = t0 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t0 = v2 - c2 * 65536;
    v2 = t1 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t1 = v2 - c2 * 65536;
    v2 = t2 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t2 = v2 - c2 * 65536;
    v2 = t3 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t3 = v2 - c2 * 65536;
    v2 = t4 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t4 = v2 - c2 * 65536;
    v2 = t5 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t5 = v2 - c2 * 65536;
    v2 = t6 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t6 = v2 - c2 * 65536;
    v2 = t7 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t7 = v2 - c2 * 65536;
    v2 = t8 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t8 = v2 - c2 * 65536;
    v2 = t9 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t9 = v2 - c2 * 65536;
    v2 = t10 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t10 = v2 - c2 * 65536;
    v2 = t11 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t11 = v2 - c2 * 65536;
    v2 = t12 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t12 = v2 - c2 * 65536;
    v2 = t13 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t13 = v2 - c2 * 65536;
    v2 = t14 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t14 = v2 - c2 * 65536;
    v2 = t15 + c2 + 65535;
    c2 = Math.floor(v2 / 65536);
    t15 = v2 - c2 * 65536;
    t0 += c2 - 1 + 37 * (c2 - 1);
    o2[0] = t0;
    o2[1] = t1;
    o2[2] = t2;
    o2[3] = t3;
    o2[4] = t4;
    o2[5] = t5;
    o2[6] = t6;
    o2[7] = t7;
    o2[8] = t8;
    o2[9] = t9;
    o2[10] = t10;
    o2[11] = t11;
    o2[12] = t12;
    o2[13] = t13;
    o2[14] = t14;
    o2[15] = t15;
  }
  function square(o2, a2) {
    mul(o2, a2, a2);
  }
  function inv25519(o2, inp) {
    const c2 = gf();
    for (let i = 0; i < 16; i++) {
      c2[i] = inp[i];
    }
    for (let i = 253; i >= 0; i--) {
      square(c2, c2);
      if (i !== 2 && i !== 4) {
        mul(c2, c2, inp);
      }
    }
    for (let i = 0; i < 16; i++) {
      o2[i] = c2[i];
    }
  }
  function scalarMult(n2, p2) {
    const z2 = new Uint8Array(32);
    const x2 = new Float64Array(80);
    const a2 = gf(), b2 = gf(), c2 = gf(), d2 = gf(), e3 = gf(), f2 = gf();
    for (let i = 0; i < 31; i++) {
      z2[i] = n2[i];
    }
    z2[31] = n2[31] & 127 | 64;
    z2[0] &= 248;
    unpack25519(x2, p2);
    for (let i = 0; i < 16; i++) {
      b2[i] = x2[i];
    }
    a2[0] = d2[0] = 1;
    for (let i = 254; i >= 0; --i) {
      const r2 = z2[i >>> 3] >>> (i & 7) & 1;
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
      add(e3, a2, c2);
      sub(a2, a2, c2);
      add(c2, b2, d2);
      sub(b2, b2, d2);
      square(d2, e3);
      square(f2, a2);
      mul(a2, c2, a2);
      mul(c2, b2, e3);
      add(e3, a2, c2);
      sub(a2, a2, c2);
      square(b2, a2);
      sub(c2, d2, f2);
      mul(a2, c2, _121665);
      add(a2, a2, d2);
      mul(c2, c2, a2);
      mul(a2, d2, f2);
      mul(d2, b2, x2);
      square(b2, e3);
      sel25519(a2, b2, r2);
      sel25519(c2, d2, r2);
    }
    for (let i = 0; i < 16; i++) {
      x2[i + 16] = a2[i];
      x2[i + 32] = c2[i];
      x2[i + 48] = b2[i];
      x2[i + 64] = d2[i];
    }
    const x32 = x2.subarray(32);
    const x16 = x2.subarray(16);
    inv25519(x32, x32);
    mul(x16, x16, x32);
    const q2 = new Uint8Array(32);
    pack25519(q2, x16);
    return q2;
  }
  exports.scalarMult = scalarMult;
  function scalarMultBase(n2) {
    return scalarMult(n2, _92);
  }
  exports.scalarMultBase = scalarMultBase;
  function generateKeyPairFromSeed(seed2) {
    if (seed2.length !== exports.SECRET_KEY_LENGTH) {
      throw new Error(`x25519: seed must be ${exports.SECRET_KEY_LENGTH} bytes`);
    }
    const secretKey = new Uint8Array(seed2);
    const publicKey = scalarMultBase(secretKey);
    return {
      publicKey,
      secretKey
    };
  }
  exports.generateKeyPairFromSeed = generateKeyPairFromSeed;
  function generateKeyPair(prng) {
    const seed2 = (0, random_1.randomBytes)(32, prng);
    const result = generateKeyPairFromSeed(seed2);
    (0, wipe_12.wipe)(seed2);
    return result;
  }
  exports.generateKeyPair = generateKeyPair;
  function sharedKey(mySecretKey, theirPublicKey, rejectZero = false) {
    if (mySecretKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect secret key length");
    }
    if (theirPublicKey.length !== exports.PUBLIC_KEY_LENGTH) {
      throw new Error("X25519: incorrect public key length");
    }
    const result = scalarMult(mySecretKey, theirPublicKey);
    if (rejectZero) {
      let zeros = 0;
      for (let i = 0; i < result.length; i++) {
        zeros |= result[i];
      }
      if (zeros === 0) {
        throw new Error("X25519: invalid shared key");
      }
    }
    return result;
  }
  exports.sharedKey = sharedKey;
})(x25519);
function asUint8Array(buf) {
  if (globalThis.Buffer != null) {
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return buf;
}
function allocUnsafe(size2 = 0) {
  if (globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null) {
    return asUint8Array(globalThis.Buffer.allocUnsafe(size2));
  }
  return new Uint8Array(size2);
}
function concat(arrays, length2) {
  if (!length2) {
    length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output2 = allocUnsafe(length2);
  let offset = 0;
  for (const arr of arrays) {
    output2.set(arr, offset);
    offset += arr.length;
  }
  return asUint8Array(output2);
}
function base(ALPHABET, name) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j2 = 0; j2 < BASE_MAP.length; j2++) {
    BASE_MAP[j2] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x2 = ALPHABET.charAt(i);
    var xc2 = x2.charCodeAt(0);
    if (BASE_MAP[xc2] !== 255) {
      throw new TypeError(x2 + " is ambiguous");
    }
    BASE_MAP[xc2] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode2(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length2 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size2 = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size2);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size2 - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      pbegin++;
    }
    var it2 = size2 - length2;
    while (it2 !== size2 && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size2; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length2 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size2 = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size2);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size2 - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length2 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size2 - length2;
    while (it4 !== size2 && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size2 - it4));
    var j3 = zeroes;
    while (it4 !== size2) {
      vch[j3++] = b256[it4++];
    }
    return vch;
  }
  function decode2(string2) {
    var buffer = decodeUnsafe(string2);
    if (buffer) {
      return buffer;
    }
    throw new Error(`Non-${name} character`);
  }
  return {
    encode: encode2,
    decodeUnsafe,
    decode: decode2
  };
}
var src = base;
var _brrp__multiformats_scope_baseX = src;
const coerce = (o2) => {
  if (o2 instanceof Uint8Array && o2.constructor.name === "Uint8Array")
    return o2;
  if (o2 instanceof ArrayBuffer)
    return new Uint8Array(o2);
  if (ArrayBuffer.isView(o2)) {
    return new Uint8Array(o2.buffer, o2.byteOffset, o2.byteLength);
  }
  throw new Error("Unknown type, must be binary type");
};
const fromString$1 = (str) => new TextEncoder().encode(str);
const toString$1 = (b2) => new TextDecoder().decode(b2);
class Encoder {
  constructor(name, prefix2, baseEncode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
  }
  encode(bytes) {
    if (bytes instanceof Uint8Array) {
      return `${this.prefix}${this.baseEncode(bytes)}`;
    } else {
      throw Error("Unknown type, must be binary type");
    }
  }
}
class Decoder {
  constructor(name, prefix2, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    if (prefix2.codePointAt(0) === void 0) {
      throw new Error("Invalid prefix character");
    }
    this.prefixCodePoint = prefix2.codePointAt(0);
    this.baseDecode = baseDecode;
  }
  decode(text2) {
    if (typeof text2 === "string") {
      if (text2.codePointAt(0) !== this.prefixCodePoint) {
        throw Error(`Unable to decode multibase string ${JSON.stringify(text2)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      }
      return this.baseDecode(text2.slice(this.prefix.length));
    } else {
      throw Error("Can only multibase decode strings");
    }
  }
  or(decoder) {
    return or(this, decoder);
  }
}
class ComposedDecoder {
  constructor(decoders) {
    this.decoders = decoders;
  }
  or(decoder) {
    return or(this, decoder);
  }
  decode(input2) {
    const prefix2 = input2[0];
    const decoder = this.decoders[prefix2];
    if (decoder) {
      return decoder.decode(input2);
    } else {
      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input2)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
    }
  }
}
const or = (left2, right) => new ComposedDecoder({
  ...left2.decoders || { [left2.prefix]: left2 },
  ...right.decoders || { [right.prefix]: right }
});
class Codec {
  constructor(name, prefix2, baseEncode, baseDecode) {
    this.name = name;
    this.prefix = prefix2;
    this.baseEncode = baseEncode;
    this.baseDecode = baseDecode;
    this.encoder = new Encoder(name, prefix2, baseEncode);
    this.decoder = new Decoder(name, prefix2, baseDecode);
  }
  encode(input2) {
    return this.encoder.encode(input2);
  }
  decode(input2) {
    return this.decoder.decode(input2);
  }
}
const from = ({ name, prefix: prefix2, encode: encode2, decode: decode2 }) => new Codec(name, prefix2, encode2, decode2);
const baseX = ({ prefix: prefix2, name, alphabet: alphabet2 }) => {
  const { encode: encode2, decode: decode2 } = _brrp__multiformats_scope_baseX(alphabet2, name);
  return from({
    prefix: prefix2,
    name,
    encode: encode2,
    decode: (text2) => coerce(decode2(text2))
  });
};
const decode$2 = (string2, alphabet2, bitsPerChar, name) => {
  const codes = {};
  for (let i = 0; i < alphabet2.length; ++i) {
    codes[alphabet2[i]] = i;
  }
  let end2 = string2.length;
  while (string2[end2 - 1] === "=") {
    --end2;
  }
  const out = new Uint8Array(end2 * bitsPerChar / 8 | 0);
  let bits = 0;
  let buffer = 0;
  let written = 0;
  for (let i = 0; i < end2; ++i) {
    const value = codes[string2[i]];
    if (value === void 0) {
      throw new SyntaxError(`Non-${name} character`);
    }
    buffer = buffer << bitsPerChar | value;
    bits += bitsPerChar;
    if (bits >= 8) {
      bits -= 8;
      out[written++] = 255 & buffer >> bits;
    }
  }
  if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
    throw new SyntaxError("Unexpected end of data");
  }
  return out;
};
const encode$1 = (data, alphabet2, bitsPerChar) => {
  const pad = alphabet2[alphabet2.length - 1] === "=";
  const mask = (1 << bitsPerChar) - 1;
  let out = "";
  let bits = 0;
  let buffer = 0;
  for (let i = 0; i < data.length; ++i) {
    buffer = buffer << 8 | data[i];
    bits += 8;
    while (bits > bitsPerChar) {
      bits -= bitsPerChar;
      out += alphabet2[mask & buffer >> bits];
    }
  }
  if (bits) {
    out += alphabet2[mask & buffer << bitsPerChar - bits];
  }
  if (pad) {
    while (out.length * bitsPerChar & 7) {
      out += "=";
    }
  }
  return out;
};
const rfc4648 = ({ name, prefix: prefix2, bitsPerChar, alphabet: alphabet2 }) => {
  return from({
    prefix: prefix2,
    name,
    encode(input2) {
      return encode$1(input2, alphabet2, bitsPerChar);
    },
    decode(input2) {
      return decode$2(input2, alphabet2, bitsPerChar, name);
    }
  });
};
const identity = from({
  prefix: "\0",
  name: "identity",
  encode: (buf) => toString$1(buf),
  decode: (str) => fromString$1(str)
});
const identityBase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  identity
}, Symbol.toStringTag, { value: "Module" }));
const base2 = rfc4648({
  prefix: "0",
  name: "base2",
  alphabet: "01",
  bitsPerChar: 1
});
const base2$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base2
}, Symbol.toStringTag, { value: "Module" }));
const base8 = rfc4648({
  prefix: "7",
  name: "base8",
  alphabet: "01234567",
  bitsPerChar: 3
});
const base8$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base8
}, Symbol.toStringTag, { value: "Module" }));
const base10 = baseX({
  prefix: "9",
  name: "base10",
  alphabet: "0123456789"
});
const base10$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base10
}, Symbol.toStringTag, { value: "Module" }));
const base16 = rfc4648({
  prefix: "f",
  name: "base16",
  alphabet: "0123456789abcdef",
  bitsPerChar: 4
});
const base16upper = rfc4648({
  prefix: "F",
  name: "base16upper",
  alphabet: "0123456789ABCDEF",
  bitsPerChar: 4
});
const base16$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base16,
  base16upper
}, Symbol.toStringTag, { value: "Module" }));
const base32 = rfc4648({
  prefix: "b",
  name: "base32",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567",
  bitsPerChar: 5
});
const base32upper = rfc4648({
  prefix: "B",
  name: "base32upper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
  bitsPerChar: 5
});
const base32pad = rfc4648({
  prefix: "c",
  name: "base32pad",
  alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
  bitsPerChar: 5
});
const base32padupper = rfc4648({
  prefix: "C",
  name: "base32padupper",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
  bitsPerChar: 5
});
const base32hex = rfc4648({
  prefix: "v",
  name: "base32hex",
  alphabet: "0123456789abcdefghijklmnopqrstuv",
  bitsPerChar: 5
});
const base32hexupper = rfc4648({
  prefix: "V",
  name: "base32hexupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
  bitsPerChar: 5
});
const base32hexpad = rfc4648({
  prefix: "t",
  name: "base32hexpad",
  alphabet: "0123456789abcdefghijklmnopqrstuv=",
  bitsPerChar: 5
});
const base32hexpadupper = rfc4648({
  prefix: "T",
  name: "base32hexpadupper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
  bitsPerChar: 5
});
const base32z = rfc4648({
  prefix: "h",
  name: "base32z",
  alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
  bitsPerChar: 5
});
const base32$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base32,
  base32hex,
  base32hexpad,
  base32hexpadupper,
  base32hexupper,
  base32pad,
  base32padupper,
  base32upper,
  base32z
}, Symbol.toStringTag, { value: "Module" }));
const base36 = baseX({
  prefix: "k",
  name: "base36",
  alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
});
const base36upper = baseX({
  prefix: "K",
  name: "base36upper",
  alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
});
const base36$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base36,
  base36upper
}, Symbol.toStringTag, { value: "Module" }));
const base58btc = baseX({
  name: "base58btc",
  prefix: "z",
  alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
});
const base58flickr = baseX({
  name: "base58flickr",
  prefix: "Z",
  alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
});
const base58 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base58btc,
  base58flickr
}, Symbol.toStringTag, { value: "Module" }));
const base64 = rfc4648({
  prefix: "m",
  name: "base64",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  bitsPerChar: 6
});
const base64pad = rfc4648({
  prefix: "M",
  name: "base64pad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
  bitsPerChar: 6
});
const base64url = rfc4648({
  prefix: "u",
  name: "base64url",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
  bitsPerChar: 6
});
const base64urlpad = rfc4648({
  prefix: "U",
  name: "base64urlpad",
  alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
  bitsPerChar: 6
});
const base64$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base64,
  base64pad,
  base64url,
  base64urlpad
}, Symbol.toStringTag, { value: "Module" }));
const alphabet = Array.from("🚀🪐☄🛰🌌🌑🌒🌓🌔🌕🌖🌗🌘🌍🌏🌎🐉☀💻🖥💾💿😂❤😍🤣😊🙏💕😭😘👍😅👏😁🔥🥰💔💖💙😢🤔😆🙄💪😉☺👌🤗💜😔😎😇🌹🤦🎉💞✌✨🤷😱😌🌸🙌😋💗💚😏💛🙂💓🤩😄😀🖤😃💯🙈👇🎶😒🤭❣😜💋👀😪😑💥🙋😞😩😡🤪👊🥳😥🤤👉💃😳✋😚😝😴🌟😬🙃🍀🌷😻😓⭐✅🥺🌈😈🤘💦✔😣🏃💐☹🎊💘😠☝😕🌺🎂🌻😐🖕💝🙊😹🗣💫💀👑🎵🤞😛🔴😤🌼😫⚽🤙☕🏆🤫👈😮🙆🍻🍃🐶💁😲🌿🧡🎁⚡🌞🎈❌✊👋😰🤨😶🤝🚶💰🍓💢🤟🙁🚨💨🤬✈🎀🍺🤓😙💟🌱😖👶🥴▶➡❓💎💸⬇😨🌚🦋😷🕺⚠🙅😟😵👎🤲🤠🤧📌🔵💅🧐🐾🍒😗🤑🌊🤯🐷☎💧😯💆👆🎤🙇🍑❄🌴💣🐸💌📍🥀🤢👅💡💩👐📸👻🤐🤮🎼🥵🚩🍎🍊👼💍📣🥂");
const alphabetBytesToChars = alphabet.reduce((p2, c2, i) => {
  p2[i] = c2;
  return p2;
}, []);
const alphabetCharsToBytes = alphabet.reduce((p2, c2, i) => {
  p2[c2.codePointAt(0)] = i;
  return p2;
}, []);
function encode(data) {
  return data.reduce((p2, c2) => {
    p2 += alphabetBytesToChars[c2];
    return p2;
  }, "");
}
function decode$1(str) {
  const byts = [];
  for (const char2 of str) {
    const byt = alphabetCharsToBytes[char2.codePointAt(0)];
    if (byt === void 0) {
      throw new Error(`Non-base256emoji character: ${char2}`);
    }
    byts.push(byt);
  }
  return new Uint8Array(byts);
}
const base256emoji = from({
  prefix: "🚀",
  name: "base256emoji",
  encode,
  decode: decode$1
});
const base256emoji$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  base256emoji
}, Symbol.toStringTag, { value: "Module" }));
new TextEncoder();
new TextDecoder();
const bases = {
  ...identityBase,
  ...base2$1,
  ...base8$1,
  ...base10$1,
  ...base16$1,
  ...base32$1,
  ...base36$1,
  ...base58,
  ...base64$1,
  ...base256emoji$1
};
function createCodec(name, prefix2, encode2, decode2) {
  return {
    name,
    prefix: prefix2,
    encoder: {
      name,
      prefix: prefix2,
      encode: encode2
    },
    decoder: { decode: decode2 }
  };
}
const string = createCodec("utf8", "u", (buf) => {
  const decoder = new TextDecoder("utf8");
  return "u" + decoder.decode(buf);
}, (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str.substring(1));
});
const ascii = createCodec("ascii", "a", (buf) => {
  let string2 = "a";
  for (let i = 0; i < buf.length; i++) {
    string2 += String.fromCharCode(buf[i]);
  }
  return string2;
}, (str) => {
  str = str.substring(1);
  const buf = allocUnsafe(str.length);
  for (let i = 0; i < str.length; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
});
const BASES = {
  utf8: string,
  "utf-8": string,
  hex: bases.base16,
  latin1: ascii,
  ascii,
  binary: ascii,
  ...bases
};
function fromString(string2, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return asUint8Array(globalThis.Buffer.from(string2, "utf-8"));
  }
  return base3.decoder.decode(`${base3.prefix}${string2}`);
}
function toString(array, encoding = "utf8") {
  const base3 = BASES[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  if ((encoding === "utf8" || encoding === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null) {
    return globalThis.Buffer.from(array.buffer, array.byteOffset, array.byteLength).toString("utf8");
  }
  return base3.encoder.encode(array).substring(1);
}
var __spreadArray = globalThis && globalThis.__spreadArray || function(to, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from2.length, ar; i < l2; i++) {
      if (ar || !(i in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i);
        ar[i] = from2[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from2));
};
var BrowserInfo = (
  /** @class */
  function() {
    function BrowserInfo2(name, version, os2) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  function() {
    function NodeInfo2(version) {
      this.version = version;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  function() {
    function SearchBotDeviceInfo2(name, version, os2, bot) {
      this.name = name;
      this.version = version;
      this.os = os2;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua2) {
  return ua2 !== "" && userAgentRules.reduce(function(matched, _a) {
    var browser2 = _a[0], regex = _a[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua2);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua2) {
  var matchedRule = matchUserAgent(ua2);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match2 = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match2[1] && match2[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version = versionParts.join(".");
  var os2 = detectOS(ua2);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua2);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version, os2, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version, os2);
}
function detectOS(ua2) {
  for (var ii2 = 0, count = operatingSystemRules.length; ii2 < count; ii2++) {
    var _a = operatingSystemRules[ii2], os2 = _a[0], regex = _a[1];
    var match2 = regex.exec(ua2);
    if (match2) {
      return os2;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode2 = typeof process !== "undefined" && process.version;
  return isNode2 ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count) {
  var output2 = [];
  for (var ii2 = 0; ii2 < count; ii2++) {
    output2.push("0");
  }
  return output2;
}
var cjs$2 = {};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s, e3) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r2 = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d2 = decorators[i])
        r2 = (c2 < 3 ? d2(r2) : c2 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e3) {
        reject2(e3);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e3) {
        reject2(e3);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _24 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_24)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _24.label++;
            return { value: op[1], done: false };
          case 5:
            _24.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _24.ops.pop();
            _24.trys.pop();
            continue;
          default:
            if (!(t2 = _24.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _24 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _24.label = op[1];
              break;
            }
            if (op[0] === 6 && _24.label < t2[1]) {
              _24.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _24.label < t2[2]) {
              _24.label = t2[2];
              _24.ops.push(op);
              break;
            }
            if (t2[2])
              _24.ops.pop();
            _24.trys.pop();
            continue;
        }
        op = body.call(thisArg, _24);
      } catch (e3) {
        op = [6, e3];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __createBinding(o2, m2, k2, k22) {
  if (k22 === void 0)
    k22 = k2;
  o2[k22] = m2[k2];
}
function __exportStar(m2, exports) {
  for (var p2 in m2)
    if (p2 !== "default" && !exports.hasOwnProperty(p2))
      exports[p2] = m2[p2];
}
function __values(o2) {
  var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o2[s], i = 0;
  if (m2)
    return m2.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i++], done: !o2 };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o2, n2) {
  var m2 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m2)
    return o2;
  var i = m2.call(o2), r2, ar = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
      ar.push(r2.value);
  } catch (error3) {
    e3 = { error: error3 };
  } finally {
    try {
      if (r2 && !r2.done && (m2 = i["return"]))
        m2.call(i);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il2 = arguments.length; i < il2; i++)
    s += arguments[i].length;
  for (var r2 = Array(s), k2 = 0, i = 0; i < il2; i++)
    for (var a2 = arguments[i], j2 = 0, jl2 = a2.length; j2 < jl2; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  function resume(n2, v2) {
    try {
      step2(g2[n2](v2));
    } catch (e3) {
      settle(q2[0][3], e3);
    }
  }
  function step2(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject2) : settle(q2[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject2(value) {
    resume("throw", value);
  }
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i, p2;
  return i = {}, verb("next"), verb("throw", function(e3) {
    throw e3;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n2, f2) {
    i[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: n2 === "return" } : f2 ? f2(v2) : v2;
    } : f2;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject2) {
        v2 = o2[n2](v2), settle(resolve, reject2, v2.done, v2.value);
      });
    };
  }
  function settle(resolve, reject2, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject2);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule)
    return mod;
  var result = {};
  if (mod != null) {
    for (var k2 in mod)
      if (Object.hasOwnProperty.call(mod, k2))
        result[k2] = mod[k2];
  }
  result.default = mod;
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, privateMap) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to get private field on non-instance");
  }
  return privateMap.get(receiver);
}
function __classPrivateFieldSet(receiver, privateMap, value) {
  if (!privateMap.has(receiver)) {
    throw new TypeError("attempted to set private field on non-instance");
  }
  privateMap.set(receiver, value);
  return value;
}
const tslib_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __createBinding,
  __decorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault,
  __importStar,
  __makeTemplateObject,
  __metadata,
  __param,
  __read,
  __rest,
  __spread,
  __spreadArrays,
  __values
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6);
var utils = {};
var delay = {};
var hasRequiredDelay;
function requireDelay() {
  if (hasRequiredDelay)
    return delay;
  hasRequiredDelay = 1;
  Object.defineProperty(delay, "__esModule", { value: true });
  delay.delay = void 0;
  function delay$1(timeout) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(true);
      }, timeout);
    });
  }
  delay.delay = delay$1;
  return delay;
}
var convert = {};
var constants = {};
var misc = {};
var hasRequiredMisc;
function requireMisc() {
  if (hasRequiredMisc)
    return misc;
  hasRequiredMisc = 1;
  Object.defineProperty(misc, "__esModule", { value: true });
  misc.ONE_THOUSAND = misc.ONE_HUNDRED = void 0;
  misc.ONE_HUNDRED = 100;
  misc.ONE_THOUSAND = 1e3;
  return misc;
}
var time = {};
var hasRequiredTime;
function requireTime() {
  if (hasRequiredTime)
    return time;
  hasRequiredTime = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ONE_YEAR = exports.FOUR_WEEKS = exports.THREE_WEEKS = exports.TWO_WEEKS = exports.ONE_WEEK = exports.THIRTY_DAYS = exports.SEVEN_DAYS = exports.FIVE_DAYS = exports.THREE_DAYS = exports.ONE_DAY = exports.TWENTY_FOUR_HOURS = exports.TWELVE_HOURS = exports.SIX_HOURS = exports.THREE_HOURS = exports.ONE_HOUR = exports.SIXTY_MINUTES = exports.THIRTY_MINUTES = exports.TEN_MINUTES = exports.FIVE_MINUTES = exports.ONE_MINUTE = exports.SIXTY_SECONDS = exports.THIRTY_SECONDS = exports.TEN_SECONDS = exports.FIVE_SECONDS = exports.ONE_SECOND = void 0;
    exports.ONE_SECOND = 1;
    exports.FIVE_SECONDS = 5;
    exports.TEN_SECONDS = 10;
    exports.THIRTY_SECONDS = 30;
    exports.SIXTY_SECONDS = 60;
    exports.ONE_MINUTE = exports.SIXTY_SECONDS;
    exports.FIVE_MINUTES = exports.ONE_MINUTE * 5;
    exports.TEN_MINUTES = exports.ONE_MINUTE * 10;
    exports.THIRTY_MINUTES = exports.ONE_MINUTE * 30;
    exports.SIXTY_MINUTES = exports.ONE_MINUTE * 60;
    exports.ONE_HOUR = exports.SIXTY_MINUTES;
    exports.THREE_HOURS = exports.ONE_HOUR * 3;
    exports.SIX_HOURS = exports.ONE_HOUR * 6;
    exports.TWELVE_HOURS = exports.ONE_HOUR * 12;
    exports.TWENTY_FOUR_HOURS = exports.ONE_HOUR * 24;
    exports.ONE_DAY = exports.TWENTY_FOUR_HOURS;
    exports.THREE_DAYS = exports.ONE_DAY * 3;
    exports.FIVE_DAYS = exports.ONE_DAY * 5;
    exports.SEVEN_DAYS = exports.ONE_DAY * 7;
    exports.THIRTY_DAYS = exports.ONE_DAY * 30;
    exports.ONE_WEEK = exports.SEVEN_DAYS;
    exports.TWO_WEEKS = exports.ONE_WEEK * 2;
    exports.THREE_WEEKS = exports.ONE_WEEK * 3;
    exports.FOUR_WEEKS = exports.ONE_WEEK * 4;
    exports.ONE_YEAR = exports.ONE_DAY * 365;
  })(time);
  return time;
}
var hasRequiredConstants;
function requireConstants() {
  if (hasRequiredConstants)
    return constants;
  hasRequiredConstants = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireMisc(), exports);
    tslib_1.__exportStar(requireTime(), exports);
  })(constants);
  return constants;
}
var hasRequiredConvert;
function requireConvert() {
  if (hasRequiredConvert)
    return convert;
  hasRequiredConvert = 1;
  Object.defineProperty(convert, "__esModule", { value: true });
  convert.fromMiliseconds = convert.toMiliseconds = void 0;
  const constants_1 = requireConstants();
  function toMiliseconds(seconds) {
    return seconds * constants_1.ONE_THOUSAND;
  }
  convert.toMiliseconds = toMiliseconds;
  function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / constants_1.ONE_THOUSAND);
  }
  convert.fromMiliseconds = fromMiliseconds;
  return convert;
}
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireDelay(), exports);
    tslib_1.__exportStar(requireConvert(), exports);
  })(utils);
  return utils;
}
var watch$1 = {};
var hasRequiredWatch$1;
function requireWatch$1() {
  if (hasRequiredWatch$1)
    return watch$1;
  hasRequiredWatch$1 = 1;
  Object.defineProperty(watch$1, "__esModule", { value: true });
  watch$1.Watch = void 0;
  class Watch {
    constructor() {
      this.timestamps = /* @__PURE__ */ new Map();
    }
    start(label2) {
      if (this.timestamps.has(label2)) {
        throw new Error(`Watch already started for label: ${label2}`);
      }
      this.timestamps.set(label2, { started: Date.now() });
    }
    stop(label2) {
      const timestamp = this.get(label2);
      if (typeof timestamp.elapsed !== "undefined") {
        throw new Error(`Watch already stopped for label: ${label2}`);
      }
      const elapsed = Date.now() - timestamp.started;
      this.timestamps.set(label2, { started: timestamp.started, elapsed });
    }
    get(label2) {
      const timestamp = this.timestamps.get(label2);
      if (typeof timestamp === "undefined") {
        throw new Error(`No timestamp found for label: ${label2}`);
      }
      return timestamp;
    }
    elapsed(label2) {
      const timestamp = this.get(label2);
      const elapsed = timestamp.elapsed || Date.now() - timestamp.started;
      return elapsed;
    }
  }
  watch$1.Watch = Watch;
  watch$1.default = Watch;
  return watch$1;
}
var types = {};
var watch = {};
var hasRequiredWatch;
function requireWatch() {
  if (hasRequiredWatch)
    return watch;
  hasRequiredWatch = 1;
  Object.defineProperty(watch, "__esModule", { value: true });
  watch.IWatch = void 0;
  class IWatch {
  }
  watch.IWatch = IWatch;
  return watch;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes)
    return types;
  hasRequiredTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    const tslib_1 = require$$0;
    tslib_1.__exportStar(requireWatch(), exports);
  })(types);
  return types;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  const tslib_1 = require$$0;
  tslib_1.__exportStar(requireUtils(), exports);
  tslib_1.__exportStar(requireWatch$1(), exports);
  tslib_1.__exportStar(requireTypes(), exports);
  tslib_1.__exportStar(requireConstants(), exports);
})(cjs$2);
var cjs$1 = {};
Object.defineProperty(cjs$1, "__esModule", { value: true });
cjs$1.getLocalStorage = cjs$1.getLocalStorageOrThrow = cjs$1.getCrypto = cjs$1.getCryptoOrThrow = getLocation_1 = cjs$1.getLocation = cjs$1.getLocationOrThrow = getNavigator_1 = cjs$1.getNavigator = cjs$1.getNavigatorOrThrow = getDocument_1 = cjs$1.getDocument = cjs$1.getDocumentOrThrow = cjs$1.getFromWindowOrThrow = cjs$1.getFromWindow = void 0;
function getFromWindow(name) {
  let res = void 0;
  if (typeof window !== "undefined" && typeof window[name] !== "undefined") {
    res = window[name];
  }
  return res;
}
cjs$1.getFromWindow = getFromWindow;
function getFromWindowOrThrow(name) {
  const res = getFromWindow(name);
  if (!res) {
    throw new Error(`${name} is not defined in Window`);
  }
  return res;
}
cjs$1.getFromWindowOrThrow = getFromWindowOrThrow;
function getDocumentOrThrow() {
  return getFromWindowOrThrow("document");
}
cjs$1.getDocumentOrThrow = getDocumentOrThrow;
function getDocument() {
  return getFromWindow("document");
}
var getDocument_1 = cjs$1.getDocument = getDocument;
function getNavigatorOrThrow() {
  return getFromWindowOrThrow("navigator");
}
cjs$1.getNavigatorOrThrow = getNavigatorOrThrow;
function getNavigator() {
  return getFromWindow("navigator");
}
var getNavigator_1 = cjs$1.getNavigator = getNavigator;
function getLocationOrThrow() {
  return getFromWindowOrThrow("location");
}
cjs$1.getLocationOrThrow = getLocationOrThrow;
function getLocation() {
  return getFromWindow("location");
}
var getLocation_1 = cjs$1.getLocation = getLocation;
function getCryptoOrThrow() {
  return getFromWindowOrThrow("crypto");
}
cjs$1.getCryptoOrThrow = getCryptoOrThrow;
function getCrypto() {
  return getFromWindow("crypto");
}
cjs$1.getCrypto = getCrypto;
function getLocalStorageOrThrow() {
  return getFromWindowOrThrow("localStorage");
}
cjs$1.getLocalStorageOrThrow = getLocalStorageOrThrow;
function getLocalStorage() {
  return getFromWindow("localStorage");
}
cjs$1.getLocalStorage = getLocalStorage;
var cjs = {};
Object.defineProperty(cjs, "__esModule", { value: true });
var getWindowMetadata_1 = cjs.getWindowMetadata = void 0;
const window_getters_1 = cjs$1;
function getWindowMetadata() {
  let doc;
  let loc;
  try {
    doc = window_getters_1.getDocumentOrThrow();
    loc = window_getters_1.getLocationOrThrow();
  } catch (e3) {
    return null;
  }
  function getIcons() {
    const links = doc.getElementsByTagName("link");
    const icons2 = [];
    for (let i = 0; i < links.length; i++) {
      const link2 = links[i];
      const rel = link2.getAttribute("rel");
      if (rel) {
        if (rel.toLowerCase().indexOf("icon") > -1) {
          const href = link2.getAttribute("href");
          if (href) {
            if (href.toLowerCase().indexOf("https:") === -1 && href.toLowerCase().indexOf("http:") === -1 && href.indexOf("//") !== 0) {
              let absoluteHref = loc.protocol + "//" + loc.host;
              if (href.indexOf("/") === 0) {
                absoluteHref += href;
              } else {
                const path = loc.pathname.split("/");
                path.pop();
                const finalPath = path.join("/");
                absoluteHref += finalPath + "/" + href;
              }
              icons2.push(absoluteHref);
            } else if (href.indexOf("//") === 0) {
              const absoluteUrl = loc.protocol + href;
              icons2.push(absoluteUrl);
            } else {
              icons2.push(href);
            }
          }
        }
      }
    }
    return icons2;
  }
  function getWindowMetadataOfAny(...args) {
    const metaTags = doc.getElementsByTagName("meta");
    for (let i = 0; i < metaTags.length; i++) {
      const tag = metaTags[i];
      const attributes = ["itemprop", "property", "name"].map((target) => tag.getAttribute(target)).filter((attr) => {
        if (attr) {
          return args.includes(attr);
        }
        return false;
      });
      if (attributes.length && attributes) {
        const content2 = tag.getAttribute("content");
        if (content2) {
          return content2;
        }
      }
    }
    return "";
  }
  function getName() {
    let name2 = getWindowMetadataOfAny("name", "og:site_name", "og:title", "twitter:title");
    if (!name2) {
      name2 = doc.title;
    }
    return name2;
  }
  function getDescription() {
    const description3 = getWindowMetadataOfAny("description", "og:description", "twitter:description", "keywords");
    return description3;
  }
  const name = getName();
  const description2 = getDescription();
  const url = loc.origin;
  const icons = getIcons();
  const meta = {
    description: description2,
    url,
    icons,
    name
  };
  return meta;
}
getWindowMetadata_1 = cjs.getWindowMetadata = getWindowMetadata;
var queryString = {};
var strictUriEncode = (str) => encodeURIComponent(str).replace(/[!'()*]/g, (x2) => `%${x2.charCodeAt(0).toString(16).toUpperCase()}`);
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components2, split) {
  try {
    return [decodeURIComponent(components2.join(""))];
  } catch (err) {
  }
  if (components2.length === 1) {
    return components2;
  }
  split = split || 1;
  var left2 = components2.slice(0, split);
  var right = components2.slice(split);
  return Array.prototype.concat.call([], decodeComponents(left2), decodeComponents(right));
}
function decode(input2) {
  try {
    return decodeURIComponent(input2);
  } catch (err) {
    var tokens = input2.match(singleMatcher) || [];
    for (var i = 1; i < tokens.length; i++) {
      input2 = decodeComponents(tokens, i).join("");
      tokens = input2.match(singleMatcher) || [];
    }
    return input2;
  }
}
function customDecodeURIComponent(input2) {
  var replaceMap = {
    "%FE%FF": "��",
    "%FF%FE": "��"
  };
  var match2 = multiMatcher.exec(input2);
  while (match2) {
    try {
      replaceMap[match2[0]] = decodeURIComponent(match2[0]);
    } catch (err) {
      var result = decode(match2[0]);
      if (result !== match2[0]) {
        replaceMap[match2[0]] = result;
      }
    }
    match2 = multiMatcher.exec(input2);
  }
  replaceMap["%C2"] = "�";
  var entries = Object.keys(replaceMap);
  for (var i = 0; i < entries.length; i++) {
    var key = entries[i];
    input2 = input2.replace(new RegExp(key, "g"), replaceMap[key]);
  }
  return input2;
}
var decodeUriComponent = function(encodedURI) {
  if (typeof encodedURI !== "string") {
    throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
  }
  try {
    encodedURI = encodedURI.replace(/\+/g, " ");
    return decodeURIComponent(encodedURI);
  } catch (err) {
    return customDecodeURIComponent(encodedURI);
  }
};
var splitOnFirst = (string2, separator2) => {
  if (!(typeof string2 === "string" && typeof separator2 === "string")) {
    throw new TypeError("Expected the arguments to be of type `string`");
  }
  if (separator2 === "") {
    return [string2];
  }
  const separatorIndex = string2.indexOf(separator2);
  if (separatorIndex === -1) {
    return [string2];
  }
  return [
    string2.slice(0, separatorIndex),
    string2.slice(separatorIndex + separator2.length)
  ];
};
var filterObj = function(obj, predicate) {
  var ret = {};
  var keys = Object.keys(obj);
  var isArr = Array.isArray(predicate);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var val = obj[key];
    if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
      ret[key] = val;
    }
  }
  return ret;
};
(function(exports) {
  const strictUriEncode$1 = strictUriEncode;
  const decodeComponent = decodeUriComponent;
  const splitOnFirst$1 = splitOnFirst;
  const filterObject = filterObj;
  const isNullOrUndefined = (value) => value === null || value === void 0;
  const encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
  function encoderForArrayFormat(options2) {
    switch (options2.arrayFormat) {
      case "index":
        return (key) => (result, value) => {
          const index2 = result.length;
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[", index2, "]"].join("")];
          }
          return [
            ...result,
            [encode2(key, options2), "[", encode2(index2, options2), "]=", encode2(value, options2)].join("")
          ];
        };
      case "bracket":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), "[]"].join("")];
          }
          return [...result, [encode2(key, options2), "[]=", encode2(value, options2)].join("")];
        };
      case "colon-list-separator":
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, [encode2(key, options2), ":list="].join("")];
          }
          return [...result, [encode2(key, options2), ":list=", encode2(value, options2)].join("")];
        };
      case "comma":
      case "separator":
      case "bracket-separator": {
        const keyValueSep = options2.arrayFormat === "bracket-separator" ? "[]=" : "=";
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          value = value === null ? "" : value;
          if (result.length === 0) {
            return [[encode2(key, options2), keyValueSep, encode2(value, options2)].join("")];
          }
          return [[result, encode2(value, options2)].join(options2.arrayFormatSeparator)];
        };
      }
      default:
        return (key) => (result, value) => {
          if (value === void 0 || options2.skipNull && value === null || options2.skipEmptyString && value === "") {
            return result;
          }
          if (value === null) {
            return [...result, encode2(key, options2)];
          }
          return [...result, [encode2(key, options2), "=", encode2(value, options2)].join("")];
        };
    }
  }
  function parserForArrayFormat(options2) {
    let result;
    switch (options2.arrayFormat) {
      case "index":
        return (key, value, accumulator) => {
          result = /\[(\d*)\]$/.exec(key);
          key = key.replace(/\[\d*\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = {};
          }
          accumulator[key][result[1]] = value;
        };
      case "bracket":
        return (key, value, accumulator) => {
          result = /(\[\])$/.exec(key);
          key = key.replace(/\[\]$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "colon-list-separator":
        return (key, value, accumulator) => {
          result = /(:list)$/.exec(key);
          key = key.replace(/:list$/, "");
          if (!result) {
            accumulator[key] = value;
            return;
          }
          if (accumulator[key] === void 0) {
            accumulator[key] = [value];
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
      case "comma":
      case "separator":
        return (key, value, accumulator) => {
          const isArray2 = typeof value === "string" && value.includes(options2.arrayFormatSeparator);
          const isEncodedArray = typeof value === "string" && !isArray2 && decode2(value, options2).includes(options2.arrayFormatSeparator);
          value = isEncodedArray ? decode2(value, options2) : value;
          const newValue = isArray2 || isEncodedArray ? value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2)) : value === null ? value : decode2(value, options2);
          accumulator[key] = newValue;
        };
      case "bracket-separator":
        return (key, value, accumulator) => {
          const isArray2 = /(\[\])$/.test(key);
          key = key.replace(/\[\]$/, "");
          if (!isArray2) {
            accumulator[key] = value ? decode2(value, options2) : value;
            return;
          }
          const arrayValue = value === null ? [] : value.split(options2.arrayFormatSeparator).map((item2) => decode2(item2, options2));
          if (accumulator[key] === void 0) {
            accumulator[key] = arrayValue;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], arrayValue);
        };
      default:
        return (key, value, accumulator) => {
          if (accumulator[key] === void 0) {
            accumulator[key] = value;
            return;
          }
          accumulator[key] = [].concat(accumulator[key], value);
        };
    }
  }
  function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
      throw new TypeError("arrayFormatSeparator must be single character string");
    }
  }
  function encode2(value, options2) {
    if (options2.encode) {
      return options2.strict ? strictUriEncode$1(value) : encodeURIComponent(value);
    }
    return value;
  }
  function decode2(value, options2) {
    if (options2.decode) {
      return decodeComponent(value);
    }
    return value;
  }
  function keysSorter(input2) {
    if (Array.isArray(input2)) {
      return input2.sort();
    }
    if (typeof input2 === "object") {
      return keysSorter(Object.keys(input2)).sort((a2, b2) => Number(a2) - Number(b2)).map((key) => input2[key]);
    }
    return input2;
  }
  function removeHash(input2) {
    const hashStart = input2.indexOf("#");
    if (hashStart !== -1) {
      input2 = input2.slice(0, hashStart);
    }
    return input2;
  }
  function getHash(url) {
    let hash2 = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
      hash2 = url.slice(hashStart);
    }
    return hash2;
  }
  function extract(input2) {
    input2 = removeHash(input2);
    const queryStart = input2.indexOf("?");
    if (queryStart === -1) {
      return "";
    }
    return input2.slice(queryStart + 1);
  }
  function parseValue(value, options2) {
    if (options2.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === "string" && value.trim() !== "")) {
      value = Number(value);
    } else if (options2.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
      value = value.toLowerCase() === "true";
    }
    return value;
  }
  function parse2(query, options2) {
    options2 = Object.assign({
      decode: true,
      sort: true,
      arrayFormat: "none",
      arrayFormatSeparator: ",",
      parseNumbers: false,
      parseBooleans: false
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options2);
    const ret = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
      return ret;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
      return ret;
    }
    for (const param of query.split("&")) {
      if (param === "") {
        continue;
      }
      let [key, value] = splitOnFirst$1(options2.decode ? param.replace(/\+/g, " ") : param, "=");
      value = value === void 0 ? null : ["comma", "separator", "bracket-separator"].includes(options2.arrayFormat) ? value : decode2(value, options2);
      formatter(decode2(key, options2), value, ret);
    }
    for (const key of Object.keys(ret)) {
      const value = ret[key];
      if (typeof value === "object" && value !== null) {
        for (const k2 of Object.keys(value)) {
          value[k2] = parseValue(value[k2], options2);
        }
      } else {
        ret[key] = parseValue(value, options2);
      }
    }
    if (options2.sort === false) {
      return ret;
    }
    return (options2.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options2.sort)).reduce((result, key) => {
      const value = ret[key];
      if (Boolean(value) && typeof value === "object" && !Array.isArray(value)) {
        result[key] = keysSorter(value);
      } else {
        result[key] = value;
      }
      return result;
    }, /* @__PURE__ */ Object.create(null));
  }
  exports.extract = extract;
  exports.parse = parse2;
  exports.stringify = (object, options2) => {
    if (!object) {
      return "";
    }
    options2 = Object.assign({
      encode: true,
      strict: true,
      arrayFormat: "none",
      arrayFormatSeparator: ","
    }, options2);
    validateArrayFormatSeparator(options2.arrayFormatSeparator);
    const shouldFilter = (key) => options2.skipNull && isNullOrUndefined(object[key]) || options2.skipEmptyString && object[key] === "";
    const formatter = encoderForArrayFormat(options2);
    const objectCopy = {};
    for (const key of Object.keys(object)) {
      if (!shouldFilter(key)) {
        objectCopy[key] = object[key];
      }
    }
    const keys = Object.keys(objectCopy);
    if (options2.sort !== false) {
      keys.sort(options2.sort);
    }
    return keys.map((key) => {
      const value = object[key];
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return encode2(key, options2);
      }
      if (Array.isArray(value)) {
        if (value.length === 0 && options2.arrayFormat === "bracket-separator") {
          return encode2(key, options2) + "[]";
        }
        return value.reduce(formatter(key), []).join("&");
      }
      return encode2(key, options2) + "=" + encode2(value, options2);
    }).filter((x2) => x2.length > 0).join("&");
  };
  exports.parseUrl = (url, options2) => {
    options2 = Object.assign({
      decode: true
    }, options2);
    const [url_, hash2] = splitOnFirst$1(url, "#");
    return Object.assign(
      {
        url: url_.split("?")[0] || "",
        query: parse2(extract(url), options2)
      },
      options2 && options2.parseFragmentIdentifier && hash2 ? { fragmentIdentifier: decode2(hash2, options2) } : {}
    );
  };
  exports.stringifyUrl = (object, options2) => {
    options2 = Object.assign({
      encode: true,
      strict: true,
      [encodeFragmentIdentifier]: true
    }, options2);
    const url = removeHash(object.url).split("?")[0] || "";
    const queryFromUrl = exports.extract(object.url);
    const parsedQueryFromUrl = exports.parse(queryFromUrl, { sort: false });
    const query = Object.assign(parsedQueryFromUrl, object.query);
    let queryString2 = exports.stringify(query, options2);
    if (queryString2) {
      queryString2 = `?${queryString2}`;
    }
    let hash2 = getHash(object.url);
    if (object.fragmentIdentifier) {
      hash2 = `#${options2[encodeFragmentIdentifier] ? encode2(object.fragmentIdentifier, options2) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString2}${hash2}`;
  };
  exports.pick = (input2, filter, options2) => {
    options2 = Object.assign({
      parseFragmentIdentifier: true,
      [encodeFragmentIdentifier]: false
    }, options2);
    const { url, query, fragmentIdentifier } = exports.parseUrl(input2, options2);
    return exports.stringifyUrl({
      url,
      query: filterObject(query, filter),
      fragmentIdentifier
    }, options2);
  };
  exports.exclude = (input2, filter, options2) => {
    const exclusionFilter = Array.isArray(filter) ? (key) => !filter.includes(key) : (key, value) => !filter(key, value);
    return exports.pick(input2, exclusionFilter, options2);
  };
})(queryString);
const RELAY_JSONRPC = {
  waku: {
    publish: "waku_publish",
    batchPublish: "waku_batchPublish",
    subscribe: "waku_subscribe",
    batchSubscribe: "waku_batchSubscribe",
    subscription: "waku_subscription",
    unsubscribe: "waku_unsubscribe",
    batchUnsubscribe: "waku_batchUnsubscribe"
  },
  irn: {
    publish: "irn_publish",
    batchPublish: "irn_batchPublish",
    subscribe: "irn_subscribe",
    batchSubscribe: "irn_batchSubscribe",
    subscription: "irn_subscription",
    unsubscribe: "irn_unsubscribe",
    batchUnsubscribe: "irn_batchUnsubscribe"
  },
  iridium: {
    publish: "iridium_publish",
    batchPublish: "iridium_batchPublish",
    subscribe: "iridium_subscribe",
    batchSubscribe: "iridium_batchSubscribe",
    subscription: "iridium_subscription",
    unsubscribe: "iridium_unsubscribe",
    batchUnsubscribe: "iridium_batchUnsubscribe"
  }
};
function L(e3, n2) {
  return e3.includes(":") ? [e3] : n2.chains || [];
}
const J = "base10", p = "base16", F2 = "base64pad", H2 = "utf8", Q = 0, _23 = 1, Dn2 = 0, Ie = 1, Z = 12, X2 = 32;
function kn2() {
  const e3 = x25519.generateKeyPair();
  return { privateKey: toString(e3.secretKey, p), publicKey: toString(e3.publicKey, p) };
}
function Vn() {
  const e3 = random.randomBytes(X2);
  return toString(e3, p);
}
function Mn2(e3, n2) {
  const t2 = x25519.sharedKey(fromString(e3, p), fromString(n2, p), true), r2 = new HKDF_1(sha256.SHA256, t2).expand(X2);
  return toString(r2, p);
}
function Kn(e3) {
  const n2 = sha256.hash(fromString(e3, p));
  return toString(n2, p);
}
function Ln(e3) {
  const n2 = sha256.hash(fromString(e3, H2));
  return toString(n2, p);
}
function Pe(e3) {
  return fromString(`${e3}`, J);
}
function $(e3) {
  return Number(toString(e3, J));
}
function xn2(e3) {
  const n2 = Pe(typeof e3.type < "u" ? e3.type : Q);
  if ($(n2) === _23 && typeof e3.senderPublicKey > "u")
    throw new Error("Missing sender public key for type 1 envelope");
  const t2 = typeof e3.senderPublicKey < "u" ? fromString(e3.senderPublicKey, p) : void 0, r2 = typeof e3.iv < "u" ? fromString(e3.iv, p) : random.randomBytes(Z), o2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e3.symKey, p)).seal(r2, fromString(e3.message, H2));
  return Re({ type: n2, sealed: o2, iv: r2, senderPublicKey: t2 });
}
function Fn(e3) {
  const n2 = new chacha20poly1305.ChaCha20Poly1305(fromString(e3.symKey, p)), { sealed: t2, iv: r2 } = ee(e3.encoded), o2 = n2.open(r2, t2);
  if (o2 === null)
    throw new Error("Failed to decrypt");
  return toString(o2, H2);
}
function Re(e3) {
  if ($(e3.type) === _23) {
    if (typeof e3.senderPublicKey > "u")
      throw new Error("Missing sender public key for type 1 envelope");
    return toString(concat([e3.type, e3.senderPublicKey, e3.iv, e3.sealed]), F2);
  }
  return toString(concat([e3.type, e3.iv, e3.sealed]), F2);
}
function ee(e3) {
  const n2 = fromString(e3, F2), t2 = n2.slice(Dn2, Ie), r2 = Ie;
  if ($(t2) === _23) {
    const d2 = r2 + X2, l2 = d2 + Z, c2 = n2.slice(r2, d2), u2 = n2.slice(d2, l2), a2 = n2.slice(l2);
    return { type: t2, sealed: a2, iv: u2, senderPublicKey: c2 };
  }
  const o2 = r2 + Z, s = n2.slice(r2, o2), i = n2.slice(o2);
  return { type: t2, sealed: i, iv: s };
}
function Hn(e3, n2) {
  const t2 = ee(e3);
  return Te({ type: $(t2.type), senderPublicKey: typeof t2.senderPublicKey < "u" ? toString(t2.senderPublicKey, p) : void 0, receiverPublicKey: n2 == null ? void 0 : n2.receiverPublicKey });
}
function Te(e3) {
  const n2 = (e3 == null ? void 0 : e3.type) || Q;
  if (n2 === _23) {
    if (typeof (e3 == null ? void 0 : e3.senderPublicKey) > "u")
      throw new Error("missing sender public key");
    if (typeof (e3 == null ? void 0 : e3.receiverPublicKey) > "u")
      throw new Error("missing receiver public key");
  }
  return { type: n2, senderPublicKey: e3 == null ? void 0 : e3.senderPublicKey, receiverPublicKey: e3 == null ? void 0 : e3.receiverPublicKey };
}
function qn(e3) {
  return e3.type === _23 && typeof e3.senderPublicKey == "string" && typeof e3.receiverPublicKey == "string";
}
var Bn = Object.defineProperty, Ae = Object.getOwnPropertySymbols, Gn = Object.prototype.hasOwnProperty, Wn2 = Object.prototype.propertyIsEnumerable, Ue = (e3, n2, t2) => n2 in e3 ? Bn(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, _e = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Gn.call(n2, t2) && Ue(e3, t2, n2[t2]);
  if (Ae)
    for (var t2 of Ae(n2))
      Wn2.call(n2, t2) && Ue(e3, t2, n2[t2]);
  return e3;
};
const Ce = "ReactNative", m = { reactNative: "react-native", node: "node", browser: "browser", unknown: "unknown" }, $e = "js";
function te() {
  return typeof process < "u" && typeof process.versions < "u" && typeof process.versions.node < "u";
}
function C() {
  return !getDocument_1() && !!getNavigator_1() && navigator.product === Ce;
}
function D() {
  return !te() && !!getNavigator_1();
}
function T() {
  return C() ? m.reactNative : te() ? m.node : D() ? m.browser : m.unknown;
}
function Jn() {
  var e3;
  try {
    return C() && typeof global < "u" && typeof (global == null ? void 0 : global.Application) < "u" ? (e3 = global.Application) == null ? void 0 : e3.applicationId : void 0;
  } catch {
    return;
  }
}
function De(e3, n2) {
  let t2 = queryString.parse(e3);
  return t2 = _e(_e({}, t2), n2), e3 = queryString.stringify(t2), e3;
}
function Qn() {
  return getWindowMetadata_1() || { name: "", description: "", url: "", icons: [""] };
}
function ke2() {
  if (T() === m.reactNative && typeof global < "u" && typeof (global == null ? void 0 : global.Platform) < "u") {
    const { OS: t2, Version: r2 } = global.Platform;
    return [t2, r2].join("-");
  }
  const e3 = detect();
  if (e3 === null)
    return "unknown";
  const n2 = e3.os ? e3.os.replace(" ", "").toLowerCase() : "unknown";
  return e3.type === "browser" ? [n2, e3.name, e3.version].join("-") : [n2, e3.version].join("-");
}
function Ve() {
  var e3;
  const n2 = T();
  return n2 === m.browser ? [n2, ((e3 = getLocation_1()) == null ? void 0 : e3.host) || "unknown"].join(":") : n2;
}
function Me2(e3, n2, t2) {
  const r2 = ke2(), o2 = Ve();
  return [[e3, n2].join("-"), [$e, t2].join("-"), r2, o2].join("/");
}
function Xn({ protocol: e3, version: n2, relayUrl: t2, sdkVersion: r2, auth: o2, projectId: s, useOnCloseEvent: i, bundleId: d2 }) {
  const l2 = t2.split("?"), c2 = Me2(e3, n2, r2), u2 = { auth: o2, ua: c2, projectId: s, useOnCloseEvent: i || void 0, origin: d2 || void 0 }, a2 = De(l2[1] || "", u2);
  return l2[0] + "?" + a2;
}
function O(e3, n2) {
  return e3.filter((t2) => n2.includes(t2)).length === e3.length;
}
function rt(e3) {
  return Object.fromEntries(e3.entries());
}
function ot(e3) {
  return new Map(Object.entries(e3));
}
function at2(e3 = cjs$2.FIVE_MINUTES, n2) {
  const t2 = cjs$2.toMiliseconds(e3 || cjs$2.FIVE_MINUTES);
  let r2, o2, s;
  return { resolve: (i) => {
    s && r2 && (clearTimeout(s), r2(i));
  }, reject: (i) => {
    s && o2 && (clearTimeout(s), o2(i));
  }, done: () => new Promise((i, d2) => {
    s = setTimeout(() => {
      d2(new Error(n2));
    }, t2), r2 = i, o2 = d2;
  }) };
}
function ut(e3, n2, t2) {
  return new Promise(async (r2, o2) => {
    const s = setTimeout(() => o2(new Error(t2)), n2);
    try {
      const i = await e3;
      r2(i);
    } catch (i) {
      o2(i);
    }
    clearTimeout(s);
  });
}
function re(e3, n2) {
  if (typeof n2 == "string" && n2.startsWith(`${e3}:`))
    return n2;
  if (e3.toLowerCase() === "topic") {
    if (typeof n2 != "string")
      throw new Error('Value must be "string" for expirer target type: topic');
    return `topic:${n2}`;
  } else if (e3.toLowerCase() === "id") {
    if (typeof n2 != "number")
      throw new Error('Value must be "number" for expirer target type: id');
    return `id:${n2}`;
  }
  throw new Error(`Unknown expirer target type: ${e3}`);
}
function lt2(e3) {
  return re("topic", e3);
}
function dt(e3) {
  return re("id", e3);
}
function ft(e3) {
  const [n2, t2] = e3.split(":"), r2 = { id: void 0, topic: void 0 };
  if (n2 === "topic" && typeof t2 == "string")
    r2.topic = t2;
  else if (n2 === "id" && Number.isInteger(Number(t2)))
    r2.id = Number(t2);
  else
    throw new Error(`Invalid target, expected id:number or topic:string, got ${n2}:${t2}`);
  return r2;
}
function pt2(e3, n2) {
  return cjs$2.fromMiliseconds((n2 || Date.now()) + cjs$2.toMiliseconds(e3));
}
function mt2(e3) {
  return Date.now() >= cjs$2.toMiliseconds(e3);
}
function yt(e3, n2) {
  return `${e3}${n2 ? `:${n2}` : ""}`;
}
function S(e3 = [], n2 = []) {
  return [.../* @__PURE__ */ new Set([...e3, ...n2])];
}
async function ht2({ id: e3, topic: n2, wcDeepLink: t2 }) {
  try {
    if (!t2)
      return;
    const r2 = typeof t2 == "string" ? JSON.parse(t2) : t2;
    let o2 = r2 == null ? void 0 : r2.href;
    if (typeof o2 != "string")
      return;
    o2.endsWith("/") && (o2 = o2.slice(0, -1));
    const s = `${o2}/wc?requestId=${e3}&sessionTopic=${n2}`, i = T();
    i === m.browser ? s.startsWith("https://") ? window.open(s, "_blank", "noreferrer noopener") : window.open(s, "_self", "noreferrer noopener") : i === m.reactNative && typeof (global == null ? void 0 : global.Linking) < "u" && await global.Linking.openURL(s);
  } catch (r2) {
    console.error(r2);
  }
}
async function gt(e3, n2) {
  try {
    return await e3.getItem(n2) || (D() ? localStorage.getItem(n2) : void 0);
  } catch (t2) {
    console.error(t2);
  }
}
const Fe = "irn";
function vt2(e3) {
  return (e3 == null ? void 0 : e3.relay) || { protocol: Fe };
}
function Et(e3) {
  const n2 = RELAY_JSONRPC[e3];
  if (typeof n2 > "u")
    throw new Error(`Relay Protocol not supported: ${e3}`);
  return n2;
}
var bt = Object.defineProperty, He = Object.getOwnPropertySymbols, Nt2 = Object.prototype.hasOwnProperty, Ot2 = Object.prototype.propertyIsEnumerable, qe = (e3, n2, t2) => n2 in e3 ? bt(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, St = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    Nt2.call(n2, t2) && qe(e3, t2, n2[t2]);
  if (He)
    for (var t2 of He(n2))
      Ot2.call(n2, t2) && qe(e3, t2, n2[t2]);
  return e3;
};
function Be(e3, n2 = "-") {
  const t2 = {}, r2 = "relay" + n2;
  return Object.keys(e3).forEach((o2) => {
    if (o2.startsWith(r2)) {
      const s = o2.replace(r2, ""), i = e3[o2];
      t2[s] = i;
    }
  }), t2;
}
function wt(e3) {
  e3 = e3.includes("wc://") ? e3.replace("wc://", "") : e3, e3 = e3.includes("wc:") ? e3.replace("wc:", "") : e3;
  const n2 = e3.indexOf(":"), t2 = e3.indexOf("?") !== -1 ? e3.indexOf("?") : void 0, r2 = e3.substring(0, n2), o2 = e3.substring(n2 + 1, t2).split("@"), s = typeof t2 < "u" ? e3.substring(t2) : "", i = queryString.parse(s);
  return { protocol: r2, topic: Ge(o2[0]), version: parseInt(o2[1], 10), symKey: i.symKey, relay: Be(i) };
}
function Ge(e3) {
  return e3.startsWith("//") ? e3.substring(2) : e3;
}
function We(e3, n2 = "-") {
  const t2 = "relay", r2 = {};
  return Object.keys(e3).forEach((o2) => {
    const s = t2 + n2 + o2;
    e3[o2] && (r2[s] = e3[o2]);
  }), r2;
}
function It(e3) {
  return `${e3.protocol}:${e3.topic}@${e3.version}?` + queryString.stringify(St({ symKey: e3.symKey }, We(e3.relay)));
}
var Pt2 = Object.defineProperty, Rt2 = Object.defineProperties, Tt = Object.getOwnPropertyDescriptors, ze = Object.getOwnPropertySymbols, At2 = Object.prototype.hasOwnProperty, Ut2 = Object.prototype.propertyIsEnumerable, Ye = (e3, n2, t2) => n2 in e3 ? Pt2(e3, n2, { enumerable: true, configurable: true, writable: true, value: t2 }) : e3[n2] = t2, _t2 = (e3, n2) => {
  for (var t2 in n2 || (n2 = {}))
    At2.call(n2, t2) && Ye(e3, t2, n2[t2]);
  if (ze)
    for (var t2 of ze(n2))
      Ut2.call(n2, t2) && Ye(e3, t2, n2[t2]);
  return e3;
}, Ct = (e3, n2) => Rt2(e3, Tt(n2));
function A(e3) {
  const n2 = [];
  return e3.forEach((t2) => {
    const [r2, o2] = t2.split(":");
    n2.push(`${r2}:${o2}`);
  }), n2;
}
function Je(e3) {
  const n2 = [];
  return Object.values(e3).forEach((t2) => {
    n2.push(...A(t2.accounts));
  }), n2;
}
function Qe(e3, n2) {
  const t2 = [];
  return Object.values(e3).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.methods);
  }), t2;
}
function Ze(e3, n2) {
  const t2 = [];
  return Object.values(e3).forEach((r2) => {
    A(r2.accounts).includes(n2) && t2.push(...r2.events);
  }), t2;
}
function jt2(e3, n2) {
  const t2 = un(e3, n2);
  if (t2)
    throw new Error(t2.message);
  const r2 = {};
  for (const [o2, s] of Object.entries(e3))
    r2[o2] = { methods: s.methods, events: s.events, chains: s.accounts.map((i) => `${i.split(":")[0]}:${i.split(":")[1]}`) };
  return r2;
}
function $t2(e3) {
  const { proposal: { requiredNamespaces: n2, optionalNamespaces: t2 = {} }, supportedNamespaces: r2 } = e3, o2 = se(n2), s = se(t2), i = {};
  Object.keys(r2).forEach((c2) => {
    const u2 = r2[c2].chains, a2 = r2[c2].methods, b2 = r2[c2].events, I2 = r2[c2].accounts;
    u2.forEach((y2) => {
      if (!I2.some((f2) => f2.includes(y2)))
        throw new Error(`No accounts provided for chain ${y2} in namespace ${c2}`);
    }), i[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  });
  const d2 = dn2(n2, i, "approve()");
  if (d2)
    throw new Error(d2.message);
  const l2 = {};
  return !Object.keys(n2).length && !Object.keys(t2).length ? i : (Object.keys(o2).forEach((c2) => {
    const u2 = r2[c2].chains.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.chains) == null ? void 0 : g2.includes(y2);
    }), a2 = r2[c2].methods.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.methods) == null ? void 0 : g2.includes(y2);
    }), b2 = r2[c2].events.filter((y2) => {
      var f2, g2;
      return (g2 = (f2 = o2[c2]) == null ? void 0 : f2.events) == null ? void 0 : g2.includes(y2);
    }), I2 = u2.map((y2) => r2[c2].accounts.filter((f2) => f2.includes(`${y2}:`))).flat();
    l2[c2] = { chains: u2, methods: a2, events: b2, accounts: I2 };
  }), Object.keys(s).forEach((c2) => {
    var u2, a2, b2, I2, y2, f2;
    if (!r2[c2])
      return;
    const g2 = (a2 = (u2 = s[c2]) == null ? void 0 : u2.chains) == null ? void 0 : a2.filter((P2) => r2[c2].chains.includes(P2)), vn2 = r2[c2].methods.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.methods) == null ? void 0 : j2.includes(P2);
    }), En2 = r2[c2].events.filter((P2) => {
      var R2, j2;
      return (j2 = (R2 = s[c2]) == null ? void 0 : R2.events) == null ? void 0 : j2.includes(P2);
    }), bn2 = g2 == null ? void 0 : g2.map((P2) => r2[c2].accounts.filter((R2) => R2.includes(`${P2}:`))).flat();
    l2[c2] = { chains: S((b2 = l2[c2]) == null ? void 0 : b2.chains, g2), methods: S((I2 = l2[c2]) == null ? void 0 : I2.methods, vn2), events: S((y2 = l2[c2]) == null ? void 0 : y2.events, En2), accounts: S((f2 = l2[c2]) == null ? void 0 : f2.accounts, bn2) };
  }), l2);
}
function oe(e3) {
  return e3.includes(":");
}
function Xe(e3) {
  return oe(e3) ? e3.split(":")[0] : e3;
}
function se(e3) {
  var n2, t2, r2;
  const o2 = {};
  if (!B(e3))
    return o2;
  for (const [s, i] of Object.entries(e3)) {
    const d2 = oe(s) ? [s] : i.chains, l2 = i.methods || [], c2 = i.events || [], u2 = Xe(s);
    o2[u2] = Ct(_t2({}, o2[u2]), { chains: S(d2, (n2 = o2[u2]) == null ? void 0 : n2.chains), methods: S(l2, (t2 = o2[u2]) == null ? void 0 : t2.methods), events: S(c2, (r2 = o2[u2]) == null ? void 0 : r2.events) });
  }
  return o2;
}
const en = { INVALID_METHOD: { message: "Invalid method.", code: 1001 }, INVALID_EVENT: { message: "Invalid event.", code: 1002 }, INVALID_UPDATE_REQUEST: { message: "Invalid update request.", code: 1003 }, INVALID_EXTEND_REQUEST: { message: "Invalid extend request.", code: 1004 }, INVALID_SESSION_SETTLE_REQUEST: { message: "Invalid session settle request.", code: 1005 }, UNAUTHORIZED_METHOD: { message: "Unauthorized method.", code: 3001 }, UNAUTHORIZED_EVENT: { message: "Unauthorized event.", code: 3002 }, UNAUTHORIZED_UPDATE_REQUEST: { message: "Unauthorized update request.", code: 3003 }, UNAUTHORIZED_EXTEND_REQUEST: { message: "Unauthorized extend request.", code: 3004 }, USER_REJECTED: { message: "User rejected.", code: 5e3 }, USER_REJECTED_CHAINS: { message: "User rejected chains.", code: 5001 }, USER_REJECTED_METHODS: { message: "User rejected methods.", code: 5002 }, USER_REJECTED_EVENTS: { message: "User rejected events.", code: 5003 }, UNSUPPORTED_CHAINS: { message: "Unsupported chains.", code: 5100 }, UNSUPPORTED_METHODS: { message: "Unsupported methods.", code: 5101 }, UNSUPPORTED_EVENTS: { message: "Unsupported events.", code: 5102 }, UNSUPPORTED_ACCOUNTS: { message: "Unsupported accounts.", code: 5103 }, UNSUPPORTED_NAMESPACE_KEY: { message: "Unsupported namespace key.", code: 5104 }, USER_DISCONNECTED: { message: "User disconnected.", code: 6e3 }, SESSION_SETTLEMENT_FAILED: { message: "Session settlement failed.", code: 7e3 }, WC_METHOD_UNSUPPORTED: { message: "Unsupported wc_ method.", code: 10001 } }, nn2 = { NOT_INITIALIZED: { message: "Not initialized.", code: 1 }, NO_MATCHING_KEY: { message: "No matching key.", code: 2 }, RESTORE_WILL_OVERRIDE: { message: "Restore will override.", code: 3 }, RESUBSCRIBED: { message: "Resubscribed.", code: 4 }, MISSING_OR_INVALID: { message: "Missing or invalid.", code: 5 }, EXPIRED: { message: "Expired.", code: 6 }, UNKNOWN_TYPE: { message: "Unknown type.", code: 7 }, MISMATCHED_TOPIC: { message: "Mismatched topic.", code: 8 }, NON_CONFORMING_NAMESPACES: { message: "Non conforming namespaces.", code: 9 } };
function N(e3, n2) {
  const { message: t2, code: r2 } = nn2[e3];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function U(e3, n2) {
  const { message: t2, code: r2 } = en[e3];
  return { message: n2 ? `${t2} ${n2}` : t2, code: r2 };
}
function k(e3, n2) {
  return Array.isArray(e3) ? typeof n2 < "u" && e3.length ? e3.every(n2) : true : false;
}
function B(e3) {
  return Object.getPrototypeOf(e3) === Object.prototype && Object.keys(e3).length;
}
function w(e3) {
  return typeof e3 > "u";
}
function h(e3, n2) {
  return n2 && w(e3) ? true : typeof e3 == "string" && !!e3.trim().length;
}
function G(e3, n2) {
  return n2 && w(e3) ? true : typeof e3 == "number" && !isNaN(e3);
}
function Dt(e3, n2) {
  const { requiredNamespaces: t2 } = n2, r2 = Object.keys(e3.namespaces), o2 = Object.keys(t2);
  let s = true;
  return O(o2, r2) ? (r2.forEach((i) => {
    const { accounts: d2, methods: l2, events: c2 } = e3.namespaces[i], u2 = A(d2), a2 = t2[i];
    (!O(L(i, a2), u2) || !O(a2.methods, l2) || !O(a2.events, c2)) && (s = false);
  }), s) : false;
}
function V(e3) {
  return h(e3, false) && e3.includes(":") ? e3.split(":").length === 2 : false;
}
function tn2(e3) {
  if (h(e3, false) && e3.includes(":")) {
    const n2 = e3.split(":");
    if (n2.length === 3) {
      const t2 = n2[0] + ":" + n2[1];
      return !!n2[2] && V(t2);
    }
  }
  return false;
}
function kt$1(e3) {
  if (h(e3, false))
    try {
      return typeof new URL(e3) < "u";
    } catch {
      return false;
    }
  return false;
}
function Vt(e3) {
  var n2;
  return (n2 = e3 == null ? void 0 : e3.proposer) == null ? void 0 : n2.publicKey;
}
function Mt$1(e3) {
  return e3 == null ? void 0 : e3.topic;
}
function Kt2(e3, n2) {
  let t2 = null;
  return h(e3 == null ? void 0 : e3.publicKey, false) || (t2 = N("MISSING_OR_INVALID", `${n2} controller public key should be a string`)), t2;
}
function ie(e3) {
  let n2 = true;
  return k(e3) ? e3.length && (n2 = e3.every((t2) => h(t2, false))) : n2 = false, n2;
}
function rn(e3, n2, t2) {
  let r2 = null;
  return k(n2) && n2.length ? n2.forEach((o2) => {
    r2 || V(o2) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chain ${o2} should be a string and conform to "namespace:chainId" format`));
  }) : V(e3) || (r2 = U("UNSUPPORTED_CHAINS", `${t2}, chains must be defined as "namespace:chainId" e.g. "eip155:1": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: ["eip155:1", "eip155:5"] }`)), r2;
}
function on(e3, n2, t2) {
  let r2 = null;
  return Object.entries(e3).forEach(([o2, s]) => {
    if (r2)
      return;
    const i = rn(o2, L(o2, s), `${n2} ${t2}`);
    i && (r2 = i);
  }), r2;
}
function sn(e3, n2) {
  let t2 = null;
  return k(e3) ? e3.forEach((r2) => {
    t2 || tn2(r2) || (t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, account ${r2} should be a string and conform to "namespace:chainId:address" format`));
  }) : t2 = U("UNSUPPORTED_ACCOUNTS", `${n2}, accounts should be an array of strings conforming to "namespace:chainId:address" format`), t2;
}
function cn(e3, n2) {
  let t2 = null;
  return Object.values(e3).forEach((r2) => {
    if (t2)
      return;
    const o2 = sn(r2 == null ? void 0 : r2.accounts, `${n2} namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function an(e3, n2) {
  let t2 = null;
  return ie(e3 == null ? void 0 : e3.methods) ? ie(e3 == null ? void 0 : e3.events) || (t2 = U("UNSUPPORTED_EVENTS", `${n2}, events should be an array of strings or empty array for no events`)) : t2 = U("UNSUPPORTED_METHODS", `${n2}, methods should be an array of strings or empty array for no methods`), t2;
}
function ce(e3, n2) {
  let t2 = null;
  return Object.values(e3).forEach((r2) => {
    if (t2)
      return;
    const o2 = an(r2, `${n2}, namespace`);
    o2 && (t2 = o2);
  }), t2;
}
function Lt(e3, n2, t2) {
  let r2 = null;
  if (e3 && B(e3)) {
    const o2 = ce(e3, n2);
    o2 && (r2 = o2);
    const s = on(e3, n2, t2);
    s && (r2 = s);
  } else
    r2 = N("MISSING_OR_INVALID", `${n2}, ${t2} should be an object with data`);
  return r2;
}
function un(e3, n2) {
  let t2 = null;
  if (e3 && B(e3)) {
    const r2 = ce(e3, n2);
    r2 && (t2 = r2);
    const o2 = cn(e3, n2);
    o2 && (t2 = o2);
  } else
    t2 = N("MISSING_OR_INVALID", `${n2}, namespaces should be an object with data`);
  return t2;
}
function ln(e3) {
  return h(e3.protocol, true);
}
function xt(e3, n2) {
  let t2 = false;
  return n2 && !e3 ? t2 = true : e3 && k(e3) && e3.length && e3.forEach((r2) => {
    t2 = ln(r2);
  }), t2;
}
function Ft2(e3) {
  return typeof e3 == "number";
}
function Ht2(e3) {
  return typeof e3 < "u" && typeof e3 !== null;
}
function qt2(e3) {
  return !(!e3 || typeof e3 != "object" || !e3.code || !G(e3.code, false) || !e3.message || !h(e3.message, false));
}
function Bt(e3) {
  return !(w(e3) || !h(e3.method, false));
}
function Gt2(e3) {
  return !(w(e3) || w(e3.result) && w(e3.error) || !G(e3.id, false) || !h(e3.jsonrpc, false));
}
function Wt2(e3) {
  return !(w(e3) || !h(e3.name, false));
}
function zt(e3, n2) {
  return !(!V(n2) || !Je(e3).includes(n2));
}
function Yt2(e3, n2, t2) {
  return h(t2, false) ? Qe(e3, n2).includes(t2) : false;
}
function Jt(e3, n2, t2) {
  return h(t2, false) ? Ze(e3, n2).includes(t2) : false;
}
function dn2(e3, n2, t2) {
  let r2 = null;
  const o2 = Qt2(e3), s = Zt2(n2), i = Object.keys(o2), d2 = Object.keys(s), l2 = fn2(Object.keys(e3)), c2 = fn2(Object.keys(n2)), u2 = l2.filter((a2) => !c2.includes(a2));
  return u2.length && (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces keys don't satisfy requiredNamespaces.
      Required: ${u2.toString()}
      Received: ${Object.keys(n2).toString()}`)), O(i, d2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces chains don't satisfy required namespaces.
      Required: ${i.toString()}
      Approved: ${d2.toString()}`)), Object.keys(n2).forEach((a2) => {
    if (!a2.includes(":") || r2)
      return;
    const b2 = A(n2[a2].accounts);
    b2.includes(a2) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces accounts don't satisfy namespace accounts for ${a2}
        Required: ${a2}
        Approved: ${b2.toString()}`));
  }), i.forEach((a2) => {
    r2 || (O(o2[a2].methods, s[a2].methods) ? O(o2[a2].events, s[a2].events) || (r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces events don't satisfy namespace events for ${a2}`)) : r2 = N("NON_CONFORMING_NAMESPACES", `${t2} namespaces methods don't satisfy namespace methods for ${a2}`));
  }), r2;
}
function Qt2(e3) {
  const n2 = {};
  return Object.keys(e3).forEach((t2) => {
    var r2;
    t2.includes(":") ? n2[t2] = e3[t2] : (r2 = e3[t2].chains) == null || r2.forEach((o2) => {
      n2[o2] = { methods: e3[t2].methods, events: e3[t2].events };
    });
  }), n2;
}
function fn2(e3) {
  return [...new Set(e3.map((n2) => n2.includes(":") ? n2.split(":")[0] : n2))];
}
function Zt2(e3) {
  const n2 = {};
  return Object.keys(e3).forEach((t2) => {
    if (t2.includes(":"))
      n2[t2] = e3[t2];
    else {
      const r2 = A(e3[t2].accounts);
      r2 == null ? void 0 : r2.forEach((o2) => {
        n2[o2] = { accounts: e3[t2].accounts.filter((s) => s.includes(`${o2}:`)), methods: e3[t2].methods, events: e3[t2].events };
      });
    }
  }), n2;
}
function Xt2(e3, n2) {
  return G(e3, false) && e3 <= n2.max && e3 >= n2.min;
}
function er() {
  const e3 = T();
  return new Promise((n2) => {
    switch (e3) {
      case m.browser:
        n2(pn());
        break;
      case m.reactNative:
        n2(mn());
        break;
      case m.node:
        n2(yn2());
        break;
      default:
        n2(true);
    }
  });
}
function pn() {
  return D() && (navigator == null ? void 0 : navigator.onLine);
}
async function mn() {
  if (C() && typeof global < "u" && global != null && global.NetInfo) {
    const e3 = await (global == null ? void 0 : global.NetInfo.fetch());
    return e3 == null ? void 0 : e3.isConnected;
  }
  return true;
}
function yn2() {
  return true;
}
function nr(e3) {
  switch (T()) {
    case m.browser:
      hn(e3);
      break;
    case m.reactNative:
      gn2(e3);
      break;
  }
}
function hn(e3) {
  !C() && D() && (window.addEventListener("online", () => e3(true)), window.addEventListener("offline", () => e3(false)));
}
function gn2(e3) {
  C() && typeof global < "u" && global != null && global.NetInfo && (global == null ? void 0 : global.NetInfo.addEventListener((n2) => e3(n2 == null ? void 0 : n2.isConnected)));
}
const ae = {};
class tr {
  static get(n2) {
    return ae[n2];
  }
  static set(n2, t2) {
    ae[n2] = t2;
  }
  static delete(n2) {
    delete ae[n2];
  }
}
const buttonsContainer = "_buttonsContainer_yg3s8_1";
const container$2 = "_container_yg3s8_7";
const connectionRequest = "_connectionRequest_yg3s8_12";
const receiveAddress$2 = "_receiveAddress_yg3s8_16";
const pairingDetailContainer = "_pairingDetailContainer_yg3s8_21";
const metadata = "_metadata_yg3s8_32";
const styles$8 = {
  buttonsContainer,
  container: container$2,
  connectionRequest,
  receiveAddress: receiveAddress$2,
  pairingDetailContainer,
  metadata
};
const PairingContainer = ({ pairingMetadata }) => {
  const { name, description: description2, url, icons } = pairingMetadata;
  const hasIcon = icons && icons.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.pairingDetailContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: description2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$8.metadata, children: url })
    ] }),
    hasIcon && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: icons[0], alt: "logo" })
  ] });
};
const WCIncomingPairing = ({
  currentProposal,
  pairingMetadata,
  receiveAddress: receiveAddress2,
  onReject,
  onApprove
}) => {
  const [pairingLoading, setPairingLoading] = reactExports.useState(false);
  const { web3wallet } = reactExports.useContext(WCWeb3WalletContext);
  const { t: t2 } = useTranslation();
  const handleApprovePairing = async () => {
    setPairingLoading(true);
    try {
      const { id: id2, params } = currentProposal;
      const { requiredNamespaces } = params;
      const eipList = Object.values(requiredNamespaces);
      const accounts = eipList.flatMap((eip) => {
        var _a;
        return ((_a = eip.chains) == null ? void 0 : _a.map((chain) => `${chain}:${receiveAddress2}`)) || [];
      });
      const chains = eipList.flatMap(
        (proposal) => proposal.chains ? proposal.chains.filter((chain) => Object.keys(SUPPORTED_CHAINS).includes(chain)) : []
      );
      const namespaces = $t2({
        proposal: params,
        supportedNamespaces: {
          eip155: {
            chains,
            methods: ["eth_sendTransaction", "eth_signTransaction", "eth_sign", "personal_sign", "eth_signTypedData", "eth_signTypedData_v4"],
            events: ["accountsChanged", "chainChanged"],
            accounts
          }
        }
      });
      await (web3wallet == null ? void 0 : web3wallet.approveSession({
        id: id2,
        namespaces
      }));
      onApprove();
    } catch (e3) {
      console.error(`Wallet connect approve pairing error ${e3}`);
      console.error(e3);
      if (e3.message.includes("Non conforming namespaces")) {
        alertUser(t2(
          "walletConnect.invalidPairingChain",
          {
            chains: "\n•Ethereum \n•Ethereum (Goerli)"
          }
        ));
      } else {
        alertUser(e3.messsage);
      }
      await handleRejectPairing();
    } finally {
      setPairingLoading(false);
    }
  };
  const handleRejectPairing = async () => {
    setPairingLoading(true);
    await (web3wallet == null ? void 0 : web3wallet.rejectSession({
      id: currentProposal.id,
      reason: U("USER_REJECTED_METHODS")
    }));
    onReject();
    setPairingLoading(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$8.connectionRequest, children: [
      t2("walletConnect.pairingRequest.title"),
      ":"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PairingContainer, { pairingMetadata }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$8.receiveAddress, children: [
      t2("accountInfo.address"),
      ": ",
      receiveAddress2
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$8.buttonsContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, secondary: true, onClick: handleRejectPairing, children: t2("walletConnect.pairingRequest.reject") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { disabled: pairingLoading, primary: true, onClick: handleApprovePairing, children: t2("walletConnect.pairingRequest.approve") })
    ] })
  ] });
};
const container$1 = "_container_1h5wj_1";
const successIcon$1 = "_successIcon_1h5wj_7";
const successText$1 = "_successText_1h5wj_12";
const styles$7 = {
  container: container$1,
  successIcon: successIcon$1,
  successText: successText$1
};
const WCSuccessPairing = ({ accountCode }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$7.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles$7.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$7.successText, children: t2("walletConnect.pairingSuccess") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: () => route(`/account/${accountCode}/wallet-connect/dashboard`), children: t2("button.done") })
  ] });
};
const ConnectScreenWalletConnect = ({
  code,
  accounts
}) => {
  var _a;
  const [uri, setUri] = reactExports.useState("");
  const [status2, setStatus] = reactExports.useState("connect");
  const [loading2, setLoading] = reactExports.useState(false);
  const { web3wallet, isWalletInitialized, pair } = reactExports.useContext(WCWeb3WalletContext);
  const [currentProposal, setCurrentProposal] = reactExports.useState();
  const { t: t2 } = useTranslation();
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const onSessionProposal = reactExports.useCallback(
    (proposal) => {
      setUri("");
      setLoading(false);
      setStatus("incoming_pairing");
      setCurrentProposal(proposal);
    },
    []
  );
  reactExports.useEffect(() => {
    if (isWalletInitialized) {
      web3wallet == null ? void 0 : web3wallet.on("session_proposal", onSessionProposal);
      return () => {
        web3wallet == null ? void 0 : web3wallet.off("session_proposal", onSessionProposal);
      };
    }
  }, [onSessionProposal, isWalletInitialized, web3wallet]);
  const handleApprovePairingStates = () => {
    setStatus("success");
    setUri("");
    setCurrentProposal(void 0);
  };
  const handleRejectPairingStates = () => {
    setStatus("connect");
    setUri("");
    setCurrentProposal(void 0);
  };
  const handleConnect = async (uri2) => {
    if (!uri2) {
      return;
    }
    setLoading(true);
    try {
      await pair({ uri: uri2 });
    } catch (err) {
      if (err.message.includes("Missing or invalid. pair()")) {
        alertUser(`${t2("walletConnect.connect.invalidPairingUri")}: ${uri2}`);
      } else {
        alertUser(err.message);
      }
      setUri("");
      setLoading(false);
    }
  };
  if (!receiveAddresses || !isWalletInitialized) {
    return null;
  }
  const accountName2 = ((_a = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a.name) || "";
  const receiveAddress2 = receiveAddresses[0].addresses[0].address;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        View,
        {
          fitContent: true,
          verticallyCentered: true,
          width: "620px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCHeader,
              {
                accountName: accountName2,
                receiveAddress: receiveAddress2
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
              status2 === "connect" && /* @__PURE__ */ jsxRuntimeExports.jsx(
                WCConnectForm,
                {
                  connectLoading: loading2,
                  code,
                  uri,
                  onInputChange: setUri,
                  onSubmit: async (uri2) => {
                    await handleConnect(uri2);
                  }
                }
              ),
              status2 === "incoming_pairing" && currentProposal && /* @__PURE__ */ jsxRuntimeExports.jsx(
                WCIncomingPairing,
                {
                  currentProposal,
                  pairingMetadata: currentProposal.params.proposer.metadata,
                  receiveAddress: receiveAddress2,
                  onApprove: handleApprovePairingStates,
                  onReject: handleRejectPairingStates
                }
              ),
              status2 === "success" && /* @__PURE__ */ jsxRuntimeExports.jsx(WCSuccessPairing, { accountCode: code })
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
};
const container = "_container_1jggi_1";
const textDataContainer = "_textDataContainer_1jggi_16";
const receiveAddress$1 = "_receiveAddress_1jggi_21";
const accountName$1 = "_accountName_1jggi_26";
const dAppMetadataAndIconContainer = "_dAppMetadataAndIconContainer_1jggi_33";
const dAppNameAndUrlContainer = "_dAppNameAndUrlContainer_1jggi_48";
const dappUrl = "_dappUrl_1jggi_54";
const accountNameAndWalletContainer = "_accountNameAndWalletContainer_1jggi_58";
const buttonAndIconContainer = "_buttonAndIconContainer_1jggi_63";
const buttonDisconnect = "_buttonDisconnect_1jggi_69";
const styles$6 = {
  container,
  textDataContainer,
  receiveAddress: receiveAddress$1,
  accountName: accountName$1,
  dAppMetadataAndIconContainer,
  dAppNameAndUrlContainer,
  dappUrl,
  accountNameAndWalletContainer,
  buttonAndIconContainer,
  buttonDisconnect
};
const TextData = ({ accountName: accountName2, receiveAddress: receiveAddress2, dAppName, dAppUrl, iconUrl }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.textDataContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.accountNameAndWalletContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.accountName, children: accountName2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} hide-on-small`, children: receiveAddress2 })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$6.receiveAddress} show-on-small`, children: receiveAddress2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppMetadataAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.dAppNameAndUrlContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: dAppName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$6.dappUrl, children: dAppUrl })
      ] }),
      iconUrl && /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "hide-on-small", src: iconUrl, alt: "dApp icon" })
    ] })
  ] });
};
const WCSessionCard = ({ metadata: metadata2, receiveAddress: receiveAddress2, onDisconnect }) => {
  const { t: t2 } = useTranslation();
  const { name, url, icons } = metadata2;
  const accountDetail = useLoad(() => getEthAccountCodeAndNameByAddress(receiveAddress2), []);
  const truncatedAddress = truncateAddress(receiveAddress2);
  const accountName2 = accountDetail && accountDetail.success ? accountDetail.name : "";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.container, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TextData,
      {
        accountName: accountName2,
        receiveAddress: truncatedAddress,
        dAppName: name,
        dAppUrl: url,
        iconUrl: icons[0]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$6.buttonAndIconContainer, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: "show-on-small", src: icons[0], alt: "logo" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$6.buttonDisconnect, onClick: onDisconnect, danger: true, children: t2("settings.electrum.remove-server") })
    ] })
  ] });
};
const buttonNewConnection = "_buttonNewConnection_13so1_1";
const headerContainer = "_headerContainer_13so1_5";
const receiveAddress = "_receiveAddress_13so1_16";
const noConnectedSessions = "_noConnectedSessions_13so1_22";
const separator = "_separator_13so1_30";
const sessionCardsContainer = "_sessionCardsContainer_13so1_37";
const allSessionsHeading = "_allSessionsHeading_13so1_42";
const styles$5 = {
  buttonNewConnection,
  headerContainer,
  receiveAddress,
  noConnectedSessions,
  separator,
  sessionCardsContainer,
  allSessionsHeading
};
const DashboardWalletConnect = ({ code, accounts }) => {
  var _a;
  const { t: t2 } = useTranslation();
  const { web3wallet, isWalletInitialized, initializeWeb3Wallet } = reactExports.useContext(WCWeb3WalletContext);
  const [sessions, setSessions] = reactExports.useState();
  const receiveAddresses = useLoad(getReceiveAddressList(code));
  const updateSessions = reactExports.useCallback(() => {
    const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || []);
    setSessions(activeSessions);
  }, [web3wallet]);
  reactExports.useEffect(() => {
    if (!web3wallet) {
      initializeWeb3Wallet();
      return;
    }
    updateSessions();
  }, [initializeWeb3Wallet, updateSessions, web3wallet]);
  reactExports.useEffect(() => {
    if (isWalletInitialized) {
      web3wallet == null ? void 0 : web3wallet.on("session_delete", updateSessions);
      return () => {
        web3wallet == null ? void 0 : web3wallet.off("session_delete", updateSessions);
      };
    }
  }, [isWalletInitialized, updateSessions, web3wallet]);
  const handleDisconnectSession = async (topic) => {
    await (web3wallet == null ? void 0 : web3wallet.disconnectSession({
      topic,
      reason: U("USER_DISCONNECTED")
    }));
    updateSessions();
  };
  if (!receiveAddresses || !isWalletInitialized) {
    return null;
  }
  const receiveAddress2 = truncateAddress(receiveAddresses[0].addresses[0].address);
  const accountName2 = ((_a = accounts && accounts.find((acct) => acct.code === code)) == null ? void 0 : _a.name) || "";
  const hasSession = sessions && sessions.length > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(GuideWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GuidedContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Status,
        {
          type: "info",
          dismissible: "walletConnectDisclaimerDismissed",
          children: t2("walletConnect.dashboard.disclaimer")
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Header,
        {
          title: /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { children: t2("walletConnect.walletConnect") })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(View, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.headerContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: accountName2 }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.receiveAddress, children: receiveAddress2 })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { className: styles$5.buttonNewConnection, onClick: () => route(`/account/${code}/wallet-connect/connect`), primary: true, children: t2("walletConnect.dashboard.newConnection") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("hr", { className: styles$5.separator }),
        hasSession && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$5.sessionCardsContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.allSessionsHeading, children: t2("walletConnect.dashboard.allSessions") }),
          sessions.map(
            (session) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              WCSessionCard,
              {
                receiveAddress: getAddressFromEIPString(session.namespaces["eip155"].accounts[0]),
                metadata: session.peer.metadata,
                onDisconnect: () => handleDisconnectSession(session.topic)
              },
              session.topic
            )
          )
        ] }),
        !hasSession && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$5.noConnectedSessions, children: t2("walletConnect.dashboard.noConnectedSessions") })
      ] }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(WCGuide, {})
  ] });
};
const InjectParams = ({ children: children2 }) => {
  const params = useParams();
  return React.cloneElement(children2, params);
};
const AppRouter = ({ devices, deviceIDs, devicesKey, accounts, activeAccounts }) => {
  const hasAccounts = accounts.length > 0;
  const Homepage = /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch-default")
  );
  const Device2 = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeviceSwitch,
    {
      deviceID: null,
      devices,
      hasAccounts
    },
    devicesKey("device-switch")
  ) });
  const Acc = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Account,
    {
      code: "",
      devices,
      accounts: activeAccounts
    }
  ) });
  const AccountsSummaryEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AccountsSummary,
    {
      devices,
      accounts: activeAccounts
    }
  ) });
  const AccSend = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    SendWrapper,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) });
  const AccReceive = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Receive,
    {
      code: "",
      devices,
      deviceIDs,
      accounts: activeAccounts
    }
  ) });
  const AccInfo = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Info,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BitsuranceAccountEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BitsuranceAccount,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BitsuranceWidgetEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BitsuranceWidget,
    {
      code: ""
    }
  ) });
  const AccDashboardWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    DashboardWalletConnect,
    {
      accounts: activeAccounts,
      code: ""
    }
  ) });
  const AccConnectScreenWC = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ConnectScreenWalletConnect,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const BuyInfoEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    BuyInfo,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const MoonpayEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Moonpay,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const ExchangeEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Exchange,
    {
      code: "",
      accounts: activeAccounts
    }
  ) });
  const PocketEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Pocket,
    {
      code: ""
    }
  ) });
  const PassphraseEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(HOC, { deviceID: "" }) });
  const ManageBackupsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ManageBackups$1,
    {
      devices
    },
    devicesKey("manage-backups")
  ) });
  const MobileSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MobileSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AppearanceEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Appearance,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AboutEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    About,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const AdvancedSettingsEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdvancedSettings,
    {
      deviceIDs,
      hasAccounts
    }
  ) });
  const ReceiveAccountsSelectorEl = /* @__PURE__ */ jsxRuntimeExports.jsx(InjectParams, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReceiveAccountsSelector, { activeAccounts }) });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Routes, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "/", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: Homepage }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account/:code", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: Acc }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "send", element: AccSend }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "receive", element: AccReceive }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "info", element: AccInfo }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/connect", element: AccConnectScreenWC }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "wallet-connect/dashboard", element: AccDashboardWC })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "add-account", element: /* @__PURE__ */ jsxRuntimeExports.jsx(AddAccount, { accounts }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "account-summary", element: AccountsSummaryEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "buy", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "info", element: BuyInfoEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BuyInfoEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BuyInfoEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "moonpay/:code", element: MoonpayEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "pocket/:code", element: PocketEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "exchange/:code", element: ExchangeEl })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-backups/:deviceID", element: ManageBackupsEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "accounts/select-receive", element: ReceiveAccountsSelectorEl }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "bitsurance", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "bitsurance", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Bitsurance, { accounts: activeAccounts }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "account", element: BitsuranceAccountEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BitsuranceAccountEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BitsuranceAccountEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "widget", element: BitsuranceWidgetEl, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: BitsuranceWidgetEl }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: ":code", element: BitsuranceWidgetEl })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "dashboard", element: /* @__PURE__ */ jsxRuntimeExports.jsx(BitsuranceDashboard, { accounts: activeAccounts }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Route, { path: "settings", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { index: true, element: MobileSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "appearance", element: AppearanceEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "about", element: AboutEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/:deviceID", element: Device2 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "device-settings/passphrase/:deviceID", element: PassphraseEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "advanced-settings", element: AdvancedSettingsEl }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "electrum", element: /* @__PURE__ */ jsxRuntimeExports.jsx(ElectrumSettings, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "manage-accounts", element: /* @__PURE__ */ jsxRuntimeExports.jsx(
        HOC$1,
        {
          accounts,
          deviceIDs,
          hasAccounts
        },
        "manage-accounts"
      ) })
    ] })
  ] }) });
};
const FirmwareUpgradeRequired = ({
  deviceID,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        verticallyCentered: true,
        textCenter: true,
        width: "840px",
        withBottomBar: true,
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("upgradeFirmware.label") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            FirmwareSetting,
            {
              asButton: true,
              deviceID,
              versionInfo
            }
          ) }) })
        ]
      }
    )
  ] });
};
const PasswordGestureVideo = "" + new URL("password-gestures.webm", import.meta.url).href;
const passwordGesturesWrapper = "_passwordGesturesWrapper_mvckk_1";
const passwordGestures = "_passwordGestures_mvckk_1";
const styles$4 = {
  passwordGesturesWrapper,
  passwordGestures
};
function isVideoPlaying(video) {
  return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
}
function replayVideo(ref) {
  if (ref && !isVideoPlaying(ref)) {
    ref.muted = true;
    ref.play();
  }
}
const PasswordEntry = () => {
  let ref = reactExports.createRef();
  reactExports.useEffect(() => {
    if (ref.current) {
      replayVideo(ref.current);
    }
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$4.passwordGesturesWrapper, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    "video",
    {
      autoPlay: true,
      ref,
      className: styles$4.passwordGestures,
      loop: true,
      muted: true,
      height: "338",
      width: "600",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("source", { src: PasswordGestureVideo, type: "video/webm" })
    }
  ) });
};
const Unlock2 = ({ attestation }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "690px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("button.unlock"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepConnected.unlock") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: attestation === false ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { children: t2("bitbox02Wizard.attestationFailed") }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
};
const Pairing = ({
  attestation,
  deviceID,
  pairingFailed
}) => {
  const { t: t2 } = useTranslation();
  const [hash2, setHash] = reactExports.useState("");
  const [deviceVerified, setDeviceVerified] = reactExports.useState(false);
  const onChannelHashChanged = reactExports.useCallback(() => {
    getChannelHash(deviceID).then(({ hash: hash22, deviceVerified: deviceVerified2 }) => {
      setHash(hash22);
      setDeviceVerified(deviceVerified2);
    });
  }, [deviceID]);
  reactExports.useEffect(onChannelHashChanged, [deviceID, onChannelHashChanged]);
  reactExports.useEffect(() => {
    return channelHashChanged(deviceID, onChannelHashChanged);
  }, [deviceID, onChannelHashChanged]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "670px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.pairing.title"), children: pairingFailed ? /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: t2("bitbox02Wizard.pairing.failed") }, "pairingFailed") : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: deviceVerified ? t2("bitbox02Wizard.pairing.paired") : t2("bitbox02Wizard.pairing.unpaired") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { fullWidth: true, children: [
          attestation === false && !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", className: "m-bottom-half", children: t2("bitbox02Wizard.attestationFailed") }),
          !pairingFailed && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { children: hash2 }),
            !deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: !pairingFailed && deviceVerified && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: () => verifyChannelHash(deviceID, true),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  );
};
const toggle = "_toggle_1t1vc_1";
const toggleLabel = "_toggleLabel_1t1vc_7";
const textIcon = "_textIcon_1t1vc_14";
const cardHeight = "_cardHeight_1t1vc_21";
const style$5 = {
  toggle,
  toggleLabel,
  textIcon,
  cardHeight
};
const SetupOptions = ({
  onSelectSetup,
  versionInfo
}) => {
  const { t: t2 } = useTranslation();
  const [advanced, setAdvanced] = reactExports.useState(false);
  const [withMnemonic, setWithMnemonic] = reactExports.useState(false);
  const [with12Words, setWith12Words] = reactExports.useState(false);
  if (advanced) {
    const {
      canBackupWithRecoveryWords,
      // supported with firmware v9.13.0
      canCreate12Words
      // supported with firmware v9.6.0
    } = versionInfo;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      View,
      {
        fullscreen: true,
        textCenter: true,
        verticallyCentered: true,
        withBottomBar: true,
        width: "1100px",
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("seed.create") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Grid, { col: "1", textAlign: "left", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("bitbox02Wizard.advanced.title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-mnemonic",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canBackupWithRecoveryWords && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.skipSDCardLabel") }),
                      " ",
                      !canBackupWithRecoveryWords && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: withMnemonic,
                    disabled: !canBackupWithRecoveryWords,
                    id: "with-mnemonic",
                    onChange: () => setWithMnemonic(!withMnemonic)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.skipSDCardText") }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$5.toggle, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  Label,
                  {
                    htmlFor: "with-12words",
                    className: style$5.toggleLabel,
                    style: {
                      ...!canCreate12Words && { color: "var(--color-disabled)" }
                    },
                    children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { children: t2("bitbox02Wizard.advanced.seed12WordLabel") }),
                      " ",
                      !canCreate12Words && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { style: { color: "var(--color-warning)" }, children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
                        "(",
                        t2("bitbox02Wizard.advanced.outOfDate"),
                        ")"
                      ] })
                    ]
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Toggle,
                  {
                    checked: with12Words,
                    disabled: !canCreate12Words,
                    id: "with-12words",
                    onChange: () => setWith12Words(!with12Words)
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.seed12WordText") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-top-quarter m-bottom-default", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("small", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
                t2("bitbox02Wizard.advanced.seed12WordInfo")
              ] }) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { inline: true, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic,
                    with12Words
                  }),
                  primary: true,
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => {
                    setWithMnemonic(false);
                    setWith12Words(false);
                    setAdvanced(false);
                  },
                  secondary: true,
                  children: t2("button.back")
                }
              )
            ] })
          ] }) }) })
        ]
      }
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "1100px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("bitbox02Wizard.stepUninitialized.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Info$1, { className: style$5.textIcon }),
          t2("bitbox02Wizard.initialize.tip")
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { fullWidth: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Grid, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, className: style$5.cardHeight, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.create") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  primary: true,
                  onClick: () => onSelectSetup("create-wallet", {
                    withMnemonic: false,
                    with12Words: false
                  }),
                  children: t2("seed.create")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => setAdvanced(true),
                  transparent: true,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx("small", { children: t2("bitbox02Wizard.advanced.button") })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Column, { asCard: true, className: style$5.cardHeight, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "title", children: t2("button.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepUninitialized.restore") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(ColumnButtons, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-sdcard"),
                  secondary: true,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMicroSD")
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: () => onSelectSetup("restore-mnemonic"),
                  secondary: true,
                  children: t2("bitbox02Wizard.stepUninitialized.restoreMnemonic")
                }
              )
            ] })
          ] })
        ] }) })
      ]
    }
  );
};
const Wait = ({ title: title2, text: text2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      width: "720px",
      verticallyCentered: true,
      textCenter: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: title2, children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: text2 ? text2 : t2("bitbox02Interact.followInstructions") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}) })
      ]
    }
  );
};
const wizardCheckbox = "_wizardCheckbox_1shxj_2";
const style$4 = {
  wizardCheckbox
};
const ChecklistWalletCreate = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  const [agree1, setAgree1] = reactExports.useState(false);
  const [agree2, setAgree2] = reactExports.useState(false);
  const [agree3, setAgree3] = reactExports.useState(false);
  const [agree4, setAgree4] = reactExports.useState(false);
  const [agree5, setAgree5] = reactExports.useState(false);
  const handleContinue = () => {
    setAgree1(false);
    setAgree2(false);
    setAgree3(false);
    setAgree4(false);
    setAgree5(false);
    onContinue();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackup") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
};
const ChecklistWalletCreateMnemonic = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  const [agree1, setAgree1] = reactExports.useState(false);
  const [agree2, setAgree2] = reactExports.useState(false);
  const [agree3, setAgree3] = reactExports.useState(false);
  const [agree4, setAgree4] = reactExports.useState(false);
  const [agree5, setAgree5] = reactExports.useState(false);
  const handleContinue = () => {
    setAgree1(false);
    setAgree2(false);
    setAgree3(false);
    setAgree4(false);
    setAgree5(false);
    onContinue();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.create.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.createBackupMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepBackup.beforeProceed") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree1(!agree1),
              className: style$4.wizardCheckbox,
              id: "agreement1",
              checked: agree1,
              label: t2("bitbox02Wizard.backup.userConfirmation1")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree2(!agree2),
              className: style$4.wizardCheckbox,
              id: "agreement2",
              checked: agree2,
              label: t2("bitbox02Wizard.backup.userConfirmation2")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree3(!agree3),
              className: style$4.wizardCheckbox,
              id: "agreement3",
              checked: agree3,
              label: t2("bitbox02Wizard.backup.userConfirmation3")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree4(!agree4),
              className: style$4.wizardCheckbox,
              id: "agreement4",
              checked: agree4,
              label: t2("bitbox02Wizard.backup.userConfirmation4")
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              onChange: () => setAgree5(!agree5),
              className: style$4.wizardCheckbox,
              id: "agreement5",
              checked: agree5,
              label: t2("bitbox02Wizard.backup.userConfirmation5mnemonic")
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            primary: true,
            onClick: handleContinue,
            disabled: !(agree1 && agree2 && agree3 && agree4 && agree5),
            children: t2("button.continue")
          }
        ) })
      ]
    }
  ) });
};
const SetPassword = ({ errorText: errorText2 }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "600px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewHeader, { title: t2("bitbox02Wizard.stepPassword.title"), children: [
          errorText2 && /* @__PURE__ */ jsxRuntimeExports.jsx(Status, { type: "warning", children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: errorText2 }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {}) })
      ]
    }
  );
};
const SetPasswordWithBackup = ({
  forBackup
}) => {
  const { i18n, t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle"), children: forBackup ? /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(MultilineMarkup, { tagName: "div", markup: t2("backup.restore.selectedBackup", {
            backupName: forBackup.name,
            createdDateTime: convertDateToLocaleString(forBackup.date, i18n.language)
          }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-small text-ellipsis", children: [
            "ID:",
            " ",
            forBackup.id
          ] })
        ] }) : null }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepPassword.useControls") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(PasswordEntry, {})
        ] })
      ]
    }
  );
};
const WithSDCard = ({
  children: children2,
  deviceID
}) => {
  const { t: t2 } = useTranslation();
  const [hasSDCard, setSDCard] = reactExports.useState();
  const ensureSDCard = reactExports.useCallback(async () => {
    try {
      const sdCardInserted = await checkSDCard(deviceID);
      setSDCard(sdCardInserted);
      if (sdCardInserted) {
        return;
      }
      const result = await insertSDCard(deviceID);
      setSDCard(result.success);
      if (result.success) {
        return;
      }
      if (result.message) {
        alertUser(result.message, { asDialog: false });
      }
    } catch (error3) {
      console.error(error3);
    }
  }, [deviceID]);
  reactExports.useEffect(() => {
    ensureSDCard();
  }, [ensureSDCard]);
  if (hasSDCard) {
    return children2;
  }
  if (hasSDCard === void 0) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(View, { fullscreen: true, textCenter: true, verticallyCentered: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: "Checking microSD card" }) });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Wait,
    {
      title: t2("bitbox02Wizard.stepInsertSD.insertSDcardTitle"),
      text: t2("bitbox02Wizard.stepInsertSD.insertSDCard")
    }
  );
};
const CreateWallet = ({
  backupType,
  backupSeedLength,
  deviceID,
  isSeeded,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  const isMounted = useMountedRef();
  const [status2, setStatus] = reactExports.useState("intro");
  const [errorText2, setErrorText] = reactExports.useState("");
  const ensurePassword = async () => {
    setStatus("setPassword");
    try {
      const result = await setPassword(deviceID, backupSeedLength);
      if (!result.success) {
        if (result.code === errUserAbort) {
          alertUser(t2("bitbox02Wizard.stepPassword.e104"), {
            asDialog: false,
            callback: () => onAbort()
          });
          setErrorText("");
        } else {
          setErrorText(t2("bitbox02Wizard.noPasswordMatch"));
          if (isMounted.current) {
            ensurePassword();
          }
        }
        return;
      }
      setErrorText("");
      setStatus("showDisclaimer");
    } catch (error3) {
      console.error(error3);
    }
  };
  const setDeviceName$1 = async (deviceName) => {
    setStatus("setName");
    try {
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText22 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText22 || t2("genericError"), {
          asDialog: false,
          callback: () => onAbort()
        });
        return;
      }
      ensurePassword();
    } catch (error3) {
      console.error(error3);
    }
  };
  const createBackup$1 = async () => {
    setStatus("createBackup");
    try {
      const result = await createBackup(
        deviceID,
        backupType === "mnemonic" ? "recovery-words" : "sdcard"
      );
      if (!result.success) {
        if (result.code === errUserAbort) {
          alertUser(t2("bitbox02Wizard.createBackupAborted"), {
            asDialog: false,
            callback: () => onAbort()
          });
        } else {
          alertUser(t2("bitbox02Wizard.createBackupFailed"), { asDialog: false });
        }
      }
    } catch (error3) {
      console.error(error3);
    }
  };
  if (isSeeded) {
    if (status2 === "showDisclaimer") {
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreate, { onContinue: createBackup$1 }) });
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(ChecklistWalletCreateMnemonic, { onContinue: createBackup$1 });
      }
    }
    if (status2 === "createBackup") {
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmDate"),
              text: t2("bitbox02Interact.confirmDateText")
            }
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Wait,
            {
              title: t2("bitbox02Interact.confirmWords", {
                amount: backupSeedLength === 16 ? "12" : "24"
              }),
              text: t2("bitbox02Interact.confirmWordsText")
            }
          );
      }
    }
  }
  switch (status2) {
    case "intro":
      switch (backupType) {
        case "sdcard":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceNameWithSDCard,
            {
              deviceID,
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-sdcard"
          );
        case "mnemonic":
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            SetDeviceName,
            {
              onDeviceName: setDeviceName$1,
              onBack: onAbort
            },
            "set-devicename-mnemonic"
          );
      }
      break;
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetPassword,
        {
          errorText: errorText2
        }
      );
    default:
      return null;
  }
};
const RestoreFromSDCardBackup = ({
  deviceID,
  onSelectBackup,
  onRestoreBackup,
  onBack
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("backup.restore.confirmTitle") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BackupsV2,
          {
            deviceID,
            showRestore: true,
            showRadio: true,
            onSelectBackup,
            onRestoreBackup,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                secondary: true,
                onClick: onBack,
                children: t2("button.back")
              }
            )
          }
        ) })
      ]
    }
  );
};
const RestoreFromSDCard = ({
  deviceID,
  onAbort
}) => {
  const [status2, setStatus] = reactExports.useState("restore");
  const [backup2, setBackup] = reactExports.useState();
  const onSelectBackup = (backup22) => {
    setStatus("setPassword");
    setBackup(backup22);
  };
  const onRestoreBackup = (success2) => {
    if (!success2) {
      onAbort();
      return;
    }
    setBackup(void 0);
  };
  switch (status2) {
    case "restore":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(WithSDCard, { deviceID, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        RestoreFromSDCardBackup,
        {
          deviceID,
          onSelectBackup,
          onRestoreBackup,
          onBack: onAbort
        }
      ) });
    case "setPassword":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SetPasswordWithBackup, { forBackup: backup2 });
  }
};
const RestoreFromMnemonic = ({
  deviceID,
  onAbort
}) => {
  const { t: t2 } = useTranslation();
  const [status2, setStatus] = reactExports.useState("intro");
  const restoreMnemonic = () => {
    restoreFromMnemonic(deviceID).then((result) => {
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Wizard.restoreFromMnemonic.e104") : t2("bitbox02Wizard.restoreFromMnemonic.failed");
        alertUser(errorText2, {
          asDialog: false,
          callback: () => onAbort()
        });
      }
    }).catch(console.error);
  };
  const setDeviceName$1 = async (deviceName) => {
    try {
      setStatus("setName");
      const result = await setDeviceName(deviceID, deviceName);
      if (!result.success) {
        const errorText2 = result.code === errUserAbort ? t2("bitbox02Settings.deviceName.error_104") : result.message;
        alertUser(errorText2 || t2("genericError"), {
          asDialog: false,
          callback: () => onAbort()
        });
        return;
      }
      setStatus("restoreMnemonic");
      restoreMnemonic();
    } catch (error3) {
      console.error(error3);
    }
  };
  switch (status2) {
    case "intro":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        SetDeviceName,
        {
          missingSDCardWarning: false,
          onDeviceName: setDeviceName$1,
          onBack: onAbort
        }
      );
    case "setName":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Wait, { title: t2("bitbox02Interact.confirmName") });
    case "restoreMnemonic":
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Wait,
        {
          title: t2("bitbox02Interact.followInstructionsMnemonicTitle"),
          text: t2("bitbox02Interact.followInstructionsMnemonic")
        }
      );
  }
};
const CreateWalletSuccess = ({
  backupType,
  onContinue
}) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fitContent: true,
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.success.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.success") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { withIcon: "success", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: backupType === "sdcard" ? t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") : t2("bitbox02Wizard.stepCreateSuccess.storeMnemonic") }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const RestoreFromSDCardSuccess = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("bitbox02Wizard.stepCreateSuccess.removeMicroSD") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const RestoreFromMnemonicSuccess = ({ onContinue }) => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      width: "700px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("bitbox02Wizard.stepBackupSuccess.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { textAlign: "left", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "m-bottom-default", children: t2("bitbox02Wizard.stepBackupSuccess.fundsSafe") }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation1") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation2") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation3") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation4") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("li", { children: t2("bitbox02Wizard.backup.userConfirmation5mnemonic") })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: onContinue, children: t2("success.getstarted") }) })
      ]
    }
  );
};
const Wizard = ({ deviceID }) => {
  const navigate2 = useNavigate();
  const versionInfo = useLoad(() => getVersion(deviceID));
  const attestation = useSync(
    () => verifyAttestation(deviceID),
    (cb2) => attestationCheckDone(deviceID, () => {
      verifyAttestation(deviceID).then(cb2);
    })
  );
  const [appStatus, setAppStatus] = reactExports.useState("");
  const [createOptions, setCreateOptions] = reactExports.useState();
  const [showWizard, setShowWizard] = reactExports.useState(false);
  const [unlockOnly, setUnlockOnly] = reactExports.useState(true);
  const status2 = useSync(
    () => getStatus$1(deviceID),
    (cb2) => statusChanged(deviceID, () => {
      getStatus$1(deviceID).then(cb2);
    })
  );
  const handleGetStarted = () => {
    setShowWizard(false);
    navigate2("/account-summary");
  };
  reactExports.useEffect(() => {
    if (status2 === void 0) {
      return;
    }
    if (!showWizard && ["connected", "unpaired", "pairingFailed", "uninitialized", "seeded"].includes(status2)) {
      setShowWizard(true);
    }
    if (unlockOnly && ["uninitialized", "seeded"].includes(status2)) {
      setUnlockOnly(false);
    }
  }, [status2, showWizard, unlockOnly]);
  const handleAbort = () => {
    setAppStatus("");
    setCreateOptions(void 0);
  };
  if (status2 === void 0) {
    return null;
  }
  if (!versionInfo) {
    return null;
  }
  if (status2 === "require_firmware_upgrade") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      FirmwareUpgradeRequired,
      {
        deviceID,
        versionInfo
      }
    );
  }
  if (status2 === "require_app_upgrade") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(AppUpgradeRequired, {});
  }
  if (!showWizard) {
    return null;
  }
  if (appStatus === "" && status2 === "initialized") {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Main, { children: [
    status2 === "connected" ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Unlock2,
      {
        attestation
      },
      "unlock"
    ) : null,
    (status2 === "unpaired" || status2 === "pairingFailed") && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Pairing,
      {
        deviceID,
        attestation,
        pairingFailed: status2 === "pairingFailed"
      },
      "pairing"
    ),
    !unlockOnly && appStatus === "" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      SetupOptions,
      {
        versionInfo,
        onSelectSetup: (type2, createOptions2) => {
          setAppStatus(type2);
          setCreateOptions(createOptions2);
        }
      },
      "choose-setup"
    ),
    !unlockOnly && appStatus === "create-wallet" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateWallet,
      {
        backupType: (createOptions == null ? void 0 : createOptions.withMnemonic) ? "mnemonic" : "sdcard",
        backupSeedLength: (createOptions == null ? void 0 : createOptions.with12Words) ? 16 : 32,
        deviceID,
        isSeeded: status2 === "seeded",
        onAbort: handleAbort
      }
    ),
    !unlockOnly && appStatus === "restore-sdcard" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RestoreFromSDCard,
      {
        deviceID,
        onAbort: handleAbort
      },
      "restore-sdcard"
    ),
    !unlockOnly && appStatus === "restore-mnemonic" && status2 !== "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      RestoreFromMnemonic,
      {
        deviceID,
        onAbort: handleAbort
      },
      "restore-mnemonic"
    ),
    appStatus === "create-wallet" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CreateWalletSuccess,
      {
        backupType: (createOptions == null ? void 0 : createOptions.withMnemonic) ? "mnemonic" : "sdcard",
        onContinue: handleGetStarted
      },
      "success"
    ),
    appStatus === "restore-sdcard" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromSDCardSuccess, { onContinue: handleGetStarted }, "backup-success"),
    appStatus === "restore-mnemonic" && status2 === "initialized" && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreFromMnemonicSuccess, { onContinue: handleGetStarted }, "backup-mnemonic-success")
  ] });
};
const syncNewTxs = (cb2) => {
  return subscribe("newTxs", (event2) => {
    if (event2.type === "backend") {
      cb2(event2.meta);
    }
  });
};
class ConnectedApp extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      connected: true
    };
  }
  componentDidMount() {
    this.unsubscribe = backendConnected((connected) => this.setState({ connected }));
  }
  componentWillUnmount() {
    this.unsubscribe();
  }
  render() {
    const { children: children2 } = this.props;
    const { connected } = this.state;
    if (!connected) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "app", style: { padding: 40 }, children: "The WebSocket closed. Please restart the backend and reload this page." });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: children2 });
  }
}
const cancel = () => {
  return apiPost("aopp/cancel");
};
const approve = () => {
  return apiPost("aopp/approve");
};
const chooseAccount = (accountCode) => {
  return apiPost("aopp/choose-account", { accountCode });
};
const getAOPP = () => {
  return apiGet("aopp");
};
const subscribeAOPP = (cb2) => {
  return subscribeEndpoint("aopp", cb2);
};
const isArray = Array.isArray;
const keyList = Object.keys;
const hasProp = Object.prototype.hasOwnProperty;
function equal(a2, b2) {
  if (Object.is(a2, b2)) {
    return true;
  }
  if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
    let arrA = isArray(a2), arrB = isArray(b2), i, length2, key;
    if (arrA && arrB) {
      length2 = a2.length;
      if (length2 !== b2.length) {
        return false;
      }
      for (i = 0; i < length2; i++) {
        if (!equal(a2[i], b2[i])) {
          return false;
        }
      }
      return true;
    }
    if (arrA !== arrB) {
      return false;
    }
    let keys = keyList(a2);
    length2 = keys.length;
    if (length2 !== keyList(b2).length) {
      return false;
    }
    for (i = 0; i < length2; i++) {
      if (!hasProp.call(b2, keys[i])) {
        return false;
      }
    }
    for (i = 0; i < length2; i++) {
      key = keys[i];
      if (!equal(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return false;
}
const VerifyAddress = ({ accountCode, address: address2, addressID }) => {
  const [verifying, setVerifying] = reactExports.useState(false);
  const { t: t2 } = useTranslation();
  const verifyAddress2 = async () => {
    setVerifying(true);
    await verifyAddress$1(accountCode, addressID);
    setVerifying(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-column", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: verifyAddress2, children: t2("receive.verifyBitBox02") }),
    verifying ? /* @__PURE__ */ jsxRuntimeExports.jsx(TranslatedWaitDialog, { title: t2("receive.verifyBitBox02"), children: address2 }) : null
  ] });
};
const logo = "_logo_rqpye_1";
const prominent = "_prominent_rqpye_9";
const hostname = "_hostname_rqpye_22";
const capitalized = "_capitalized_rqpye_31";
const styles$3 = {
  logo,
  prominent,
  hostname,
  capitalized
};
const AOPPGroupLogo = "" + new URL("aoppgroup.svg", import.meta.url).href;
const BitcoinSuisseLogo = "" + new URL("bitcoin_suisse.png", import.meta.url).href;
const BittrLogo = "" + new URL("bittr.png", import.meta.url).href;
const BityLogo = "" + new URL("bity.png", import.meta.url).href;
const PocketBitcoinLogo = "" + new URL("pocketbitcoin.svg", import.meta.url).href;
const VASPLogoMap = {
  "demo.aopp.group": AOPPGroupLogo,
  "testing.aopp.group": AOPPGroupLogo,
  "bitcoinsuisse.com": BitcoinSuisseLogo,
  "bity.com": BityLogo,
  "getbittr.com": BittrLogo,
  "pocketbitcoin.com": PocketBitcoinLogo
};
const VASPHostnameMap = {
  "demo.aopp.group": "AOPP.group",
  "testing.aopp.group": "AOPP.group"
};
const Vasp = ({
  fallback,
  hostname: hostname2,
  prominent: prominent2,
  withLogoText
}) => {
  const hasLogo = hostname2 in VASPLogoMap;
  if (!hasLogo) {
    return fallback || /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$3.hostname, children: hostname2 });
  }
  const logoClasses = prominent2 ? `${styles$3.logo} ${styles$3.prominent}` : styles$3.logo;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: logoClasses, src: VASPLogoMap[hostname2], alt: hostname2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: `${styles$3.hostname} ${styles$3.capitalized}`, children: hostname2 in VASPHostnameMap ? VASPHostnameMap[hostname2] : hostname2 }),
    withLogoText ? /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: withLogoText }) : null
  ] });
};
const banner = "_banner_yebbr_1";
const smallIcon = "_smallIcon_yebbr_10";
const successText = "_successText_yebbr_15";
const proceed = "_proceed_yebbr_28";
const message = "_message_yebbr_33";
const styles$2 = {
  banner,
  smallIcon,
  successText,
  proceed,
  message
};
const Banner$1 = ({ children: children2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.banner, children: children2 });
const domain = (callback2) => new URL(callback2).host;
class Aopp extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = {
      accountCode: "",
      aopp: void 0
    };
    this.chooseAccount = (e3) => {
      if (this.state.accountCode) {
        chooseAccount(this.state.accountCode);
      }
      e3.preventDefault();
    };
  }
  componentDidMount() {
    this.setAccountCodeDefault();
    this.unsubscribe = subscribeAOPP((aopp2) => this.updateAOPP(aopp2));
    getAOPP().then((aopp2) => this.setState({ aopp: aopp2 }));
  }
  componentWillUnmount() {
    if (this.unsubscribe) {
      this.unsubscribe();
    }
  }
  updateAOPP(aopp2) {
    let shouldUpdateAccountCodeDefault = false;
    this.setState((currentState) => {
      var _a, _b;
      if ((aopp2 == null ? void 0 : aopp2.state) === "choosing-account" && (((_a = currentState.aopp) == null ? void 0 : _a.state) !== "choosing-account" || !equal(aopp2.accounts, (_b = currentState.aopp) == null ? void 0 : _b.accounts))) {
        shouldUpdateAccountCodeDefault = true;
      }
      return { aopp: aopp2 };
    }, () => {
      if (shouldUpdateAccountCodeDefault) {
        this.setAccountCodeDefault();
      }
    });
  }
  setAccountCodeDefault() {
    const { aopp: aopp2 } = this.state;
    if (aopp2 === void 0 || aopp2.state !== "choosing-account") {
      return;
    }
    if (aopp2.accounts.length) {
      this.setState({ accountCode: aopp2.accounts[0].code });
    }
  }
  render() {
    const { t: t2 } = this.props;
    const { accountCode, aopp: aopp2 } = this.state;
    if (!aopp2) {
      return null;
    }
    switch (aopp2.state) {
      case "error":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.errorTitle"), children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Message, { type: "error", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$2.smallIcon }),
                t2(`error.${aopp2.errorCode}`, { host: domain(aopp2.callback) })
              ] }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { danger: true, onClick: cancel, children: t2("button.dismiss") }) })
            ]
          }
        );
      case "inactive":
        return null;
      case "user-approval":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), withAppLogo: true }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Vasp,
                {
                  prominent: true,
                  hostname: domain(aopp2.callback),
                  fallback: /* @__PURE__ */ jsxRuntimeExports.jsx(SimpleMarkup, { tagName: "p", markup: t2("aopp.addressRequest", {
                    host: `<strong>${domain(aopp2.callback)}</strong>`
                  }) }),
                  withLogoText: t2("aopp.addressRequestWithLogo")
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: approve, children: t2("button.continue") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        );
      case "awaiting-keystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(Banner$1, { children: t2("aopp.banner") });
      case "choosing-account": {
        const options2 = aopp2.accounts.map((account2) => {
          return {
            text: account2.name,
            value: account2.code
          };
        });
        return /* @__PURE__ */ jsxRuntimeExports.jsx("form", { onSubmit: this.chooseAccount, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Select$1,
                {
                  label: t2("buy.info.selectLabel"),
                  options: options2,
                  value: accountCode,
                  onChange: (e3) => {
                    var _a;
                    return this.setState({ accountCode: (_a = e3.target) == null ? void 0 : _a.value });
                  },
                  id: "account"
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: t2("button.next") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") })
              ] })
            ]
          }
        ) });
      }
      case "syncing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.syncing") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancel, children: t2("dialog.cancel") }) })
            ]
          }
        );
      case "signing":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("aopp.title"), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Vasp, { hostname: domain(aopp2.callback) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("aopp.signing") }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: true, flexibleHeight: true, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
              ] })
            ]
          }
        );
      case "success":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(
          View,
          {
            fitContent: true,
            fullscreen: true,
            textCenter: true,
            verticallyCentered: true,
            width: "580px",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewContent, { withIcon: "success", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.successText, children: t2("aopp.success.title") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$2.proceed, children: t2("aopp.success.message", { host: domain(aopp2.callback) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelAddress") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(CopyableInput, { alignLeft: true, flexibleHeight: true, value: aopp2.address })
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Field, { style: { marginBottom: 0 }, children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { children: t2("aopp.labelMessage") }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: styles$2.message, children: aopp2.message })
                ] })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ViewButtons, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, onClick: cancel, children: t2("button.done") }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  VerifyAddress,
                  {
                    accountCode: aopp2.accountCode,
                    address: aopp2.address,
                    addressID: aopp2.addressID
                  }
                )
              ] })
            ]
          }
        );
    }
  }
}
const translateHOC = translate()(Aopp);
const getBanner = (msgKey) => {
  return apiGet(`banners/${msgKey}`);
};
const syncBanner = (msgKey, cb2) => {
  return subscribeEndpoint(`banners/${msgKey}`, cb2);
};
const link$1 = "_link_4u2en_1";
const style$3 = {
  link: link$1
};
const Banner = ({ msgKey }) => {
  const { i18n, t: t2 } = useTranslation();
  const [banner2, setBanner] = reactExports.useState();
  reactExports.useEffect(() => {
    getBanner(msgKey).then(setBanner);
    syncBanner(msgKey, setBanner);
  }, [msgKey]);
  if (!banner2 || !i18n.options.fallbackLng) {
    return null;
  }
  const { message: message2, link: link2 } = banner2;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Status,
    {
      dismissible: banner2.dismissible ? `banner-${msgKey}-${banner2.id}` : "",
      type: banner2.type ? banner2.type : "warning",
      children: [
        message2[i18n.resolvedLanguage] || message2[i18n.options.fallbackLng[0]],
        " ",
        link2 && /* @__PURE__ */ jsxRuntimeExports.jsx(A$3, { href: link2.href, className: style$3.link, children: link2.text || t2("clickHere") })
      ]
    }
  );
};
const SkipForTesting = () => {
  const [dialog2, setDialog] = reactExports.useState(false);
  const show2 = useLoad(() => Promise.resolve(false));
  const [testPIN, setTestPIN] = reactExports.useState("");
  const registerTestingDevice = async (e3) => {
    e3.preventDefault();
    await testRegister(testPIN);
    setDialog(false);
  };
  if (!show2) {
    return null;
  }
  const title2 = "Unlock software keystore";
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("button", { onClick: () => setDialog(true), children: title2 }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: dialog2, title: title2, onClose: () => setDialog(false), children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: registerTestingDevice, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        PasswordSingleInput,
        {
          type: "password",
          autoFocus: true,
          label: "Test Password",
          onValidPassword: setTestPIN,
          value: testPIN
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { primary: true, type: "submit", children: "Unlock" }) })
    ] }) })
  ] });
};
const bitboxContainer = "_bitboxContainer_1nxo8_1";
const failed = "_failed_1nxo8_18";
const bitboxImage = "_bitboxImage_1nxo8_24";
const cancelIcon = "_cancelIcon_1nxo8_29";
const text = "_text_1nxo8_35";
const styles$1 = {
  bitboxContainer,
  failed,
  bitboxImage,
  cancelIcon,
  text
};
function KeystoreConnectPrompt() {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const [data, reset2] = useSubscribeReset(syncConnectKeystore());
  const cancelAndReset = () => {
    reset2();
    cancelConnectKeystore();
  };
  const errorMessage2 = (errorCode) => {
    switch (errorCode) {
      case "wrongKeystore":
        return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          t2("error.wrongKeystore"),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
          t2("error.wrongKeystore2")
        ] });
      case "timeout":
        return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: t2("error.keystoreTimeout") });
      default:
        return null;
    }
  };
  if (!data) {
    return null;
  }
  switch (data.typ) {
    case "connect":
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: true, open: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: styles$1.text, children: [
          data.keystoreName === "" ? t2("connectKeystore.promptNoName") : t2("connectKeystore.promptWithName", { name: data.keystoreName }),
          "."
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles$1.bitboxContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancelConnectKeystore, children: t2("dialog.cancel") }) })
      ] });
    case "error":
      const err = errorMessage2(data.errorCode);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { title: t2("welcome.connect"), medium: true, open: true, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles$1.text, children: err ? err : data.errorMessage }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: `${styles$1.bitboxContainer} ${styles$1.failed}`, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cancel, { className: styles$1.cancelIcon }),
          isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedLight, { className: styles$1.bitboxImage }) : /* @__PURE__ */ jsxRuntimeExports.jsx(BitBox02StylizedDark, { className: styles$1.bitboxImage }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogButtons$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { secondary: true, onClick: cancelAndReset, children: t2("dialog.cancel") }) })
      ] });
    default:
      return null;
  }
}
const getUsingMobileData = () => {
  return apiGet("using-mobile-data");
};
const subscribeUsingMobileData = (cb2) => subscribeEndpoint("using-mobile-data", cb2);
const MobileDataWarning = () => {
  const { t: t2 } = useTranslation();
  const isUsingMobileData = useSync(getUsingMobileData, subscribeUsingMobileData);
  if (isUsingMobileData === void 0) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Status,
    {
      dismissible: "mobile-data-warning",
      type: "warning",
      hidden: !isUsingMobileData,
      children: t2("mobile.usingMobileDataWarning")
    }
  );
};
const coins = "" + new URL("coins.svg", import.meta.url).href;
const shieldIcon = "" + new URL("shield_grey.svg", import.meta.url).href;
const linechart = "" + new URL("linechart.svg", import.meta.url).href;
const settings = "" + new URL("settings-alt.svg", import.meta.url).href;
const settingsGrey = "" + new URL("settings-alt_disabled.svg", import.meta.url).href;
const closeButton = "_closeButton_1xwfn_1";
const sidebarOverlay = "_sidebarOverlay_1xwfn_13";
const active = "_active_1xwfn_26";
const sidebar = "_sidebar_1xwfn_13";
const end = "_end_1xwfn_47";
const forceShow = "_forceShow_1xwfn_52";
const sidebarLogoContainer = "_sidebarLogoContainer_1xwfn_56";
const sidebarHeaderContainer = "_sidebarHeaderContainer_1xwfn_75";
const sidebarPortfolio = "_sidebarPortfolio_1xwfn_85";
const sidebarHeader = "_sidebarHeader_1xwfn_75";
const sidebarIconVisible = "_sidebarIconVisible_1xwfn_95";
const sidebarIconHidden = "_sidebarIconHidden_1xwfn_99";
const sidebarItem = "_sidebarItem_1xwfn_103";
const sidebarArrow = "_sidebarArrow_1xwfn_121";
const sidebarActive = "_sidebarActive_1xwfn_125";
const activeGroup = "_activeGroup_1xwfn_130";
const single = "_single_1xwfn_136";
const sidebarLabel = "_sidebarLabel_1xwfn_141";
const sidebarSubmenu = "_sidebarSubmenu_1xwfn_197";
const sidebarContainer = "_sidebarContainer_1xwfn_216";
const forceHide = "_forceHide_1xwfn_216";
const style$2 = {
  closeButton,
  sidebarOverlay,
  active,
  sidebar,
  end,
  forceShow,
  sidebarLogoContainer,
  sidebarHeaderContainer,
  sidebarPortfolio,
  sidebarHeader,
  sidebarIconVisible,
  sidebarIconHidden,
  sidebarItem,
  sidebarArrow,
  sidebarActive,
  activeGroup,
  single,
  sidebarLabel,
  sidebarSubmenu,
  sidebarContainer,
  forceHide
};
const GetAccountLink = ({
  coinCode,
  code,
  name,
  handleSidebarItemClick
}) => {
  const { pathname } = useLocation();
  const active2 = pathname === `/account/${code}` || pathname.startsWith(`/account/${code}/`);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Link,
    {
      className: active2 ? style$2.sidebarActive : "",
      to: `/account/${code}`,
      onClick: handleSidebarItemClick,
      title: name,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { stacked: true, coinCode, alt: name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: name })
      ]
    }
  ) });
};
const Sidebar = ({
  deviceIDs,
  accounts
}) => {
  const { t: t2 } = useTranslation();
  const { pathname } = useLocation();
  const { activeSidebar, sidebarStatus, toggleSidebar } = reactExports.useContext(AppContext);
  reactExports.useEffect(() => {
    const swipe = {
      active: false,
      x: 0,
      y: 0
    };
    const handleTouchStart = (event2) => {
      const touch = event2.touches[0];
      swipe.x = touch.clientX;
      swipe.y = touch.clientY;
    };
    const handleTouchMove = (event2) => {
      if (sidebarStatus !== "forceHidden" && event2.changedTouches && event2.changedTouches.length) {
        swipe.active = true;
      }
    };
    const handleTouchEnd = (event2) => {
      if (sidebarStatus !== "forceHidden") {
        const touch = event2.changedTouches[0];
        const travelX = Math.abs(touch.clientX - swipe.x);
        const travelY = Math.abs(touch.clientY - swipe.y);
        const validSwipe = window.innerWidth <= 901 && swipe.active && travelY < 100 && travelX > 70;
        if (!activeSidebar && validSwipe && swipe.x < 60 || activeSidebar && validSwipe && swipe.x > 230) {
          toggleSidebar();
        }
        swipe.x = 0;
        swipe.y = 0;
        swipe.active = false;
      }
    };
    document.addEventListener("touchstart", handleTouchStart);
    document.addEventListener("touchmove", handleTouchMove);
    document.addEventListener("touchend", handleTouchEnd);
    return () => {
      document.removeEventListener("touchstart", handleTouchStart);
      document.removeEventListener("touchmove", handleTouchMove);
      document.removeEventListener("touchend", handleTouchEnd);
    };
  }, [activeSidebar, sidebarStatus, toggleSidebar]);
  const [keystores, setKeystores] = reactExports.useState();
  reactExports.useEffect(() => {
    getKeystores().then((keystores2) => {
      setKeystores(keystores2);
    });
    return subscribeKeystores(setKeystores);
  }, []);
  const handleSidebarItemClick = (event2) => {
    const el2 = event2.target.closest("a");
    if (el2.classList.contains("sidebarActive") && window.innerWidth <= 901) {
      toggleSidebar();
    }
  };
  const hidden = sidebarStatus === "forceHidden";
  const hasOnlyBTCAccounts = accounts.every(({ coinCode }) => isBitcoinOnly(coinCode));
  const accountsByKeystore = getAccountsByKeystore(accounts);
  const userInSpecificAccountBuyPage = pathname.startsWith("/buy");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: [style$2.sidebarContainer, hidden ? style$2.forceHide : ""].join(" "), children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$2.sidebarOverlay, activeSidebar ? style$2.active : ""].join(" "), onClick: toggleSidebar }, "overlay"),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("nav", { className: [style$2.sidebar, activeSidebar ? style$2.forceShow : ""].join(" "), children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: style$2.sidebarLogoContainer, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Link,
          {
            to: accounts.length ? "/account-summary" : "/",
            onClick: handleSidebarItemClick,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(AppLogoInverted, { className: style$2.sidebarLogo })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: style$2.closeButton, onClick: toggleSidebar, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseXWhite, {}) })
      ] }, "app-logo"),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: `${style$2.sidebarItem} ${style$2.sidebarPortfolio}`, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
          to: "/account-summary",
          title: t2("accountSummary.title"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: linechart }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("accountSummary.title") })
          ]
        }
      ) }, "account-summary") : null,
      accountsByKeystore.map((keystore2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarHeaderContainer, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          "span",
          {
            className: style$2.sidebarHeader,
            hidden: !keystore2.accounts.length,
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "p-right-quarter", children: [
                `${keystore2.keystore.name} `,
                isAmbiguiousName(keystore2.keystore.name, accountsByKeystore) ? (
                  // Disambiguate accounts group by adding the fingerprint.
                  // The most common case where this would happen is when adding accounts from the
                  // same seed using different passphrases.
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    " (",
                    keystore2.keystore.rootFingerprint,
                    ")"
                  ] })
                ) : null
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Badge,
                {
                  className: keystore2.keystore.connected ? style$2.sidebarIconVisible : style$2.sidebarIconHidden,
                  icon: (props) => /* @__PURE__ */ jsxRuntimeExports.jsx(USBSuccess, { ...props }),
                  type: "success",
                  title: t2("device.keystoreConnected")
                }
              )
            ]
          }
        ) }),
        keystore2.accounts.map((acc) => /* @__PURE__ */ jsxRuntimeExports.jsx(GetAccountLink, { ...acc, handleSidebarItemClick }, `account-${acc.code}`))
      ] }, `keystore-${keystore2.keystore.rootFingerprint}`)),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: [style$2.sidebarHeaderContainer, style$2.end].join(" ") }, "services"),
      accounts.length ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          NavLink,
          {
            className: ({ isActive }) => isActive || userInSpecificAccountBuyPage ? style$2.sidebarActive : "",
            to: "/buy/info",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: coins, alt: t2("sidebar.exchanges") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: hasOnlyBTCAccounts ? t2("accountInfo.buyCTA.buy", { unit: "Bitcoin" }) : t2("sidebar.buy") })
            ]
          }
        ) }, "buy"),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          NavLink,
          {
            className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
            to: "/bitsurance/bitsurance",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.single, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: shieldIcon, alt: t2("sidebar.insurance") }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("sidebar.insurance") })
            ]
          }
        ) }, "insurance")
      ] }) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style$2.sidebarItem, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavLink,
        {
          className: ({ isActive }) => isActive ? style$2.sidebarActive : "",
          to: "/settings",
          title: t2("sidebar.settings"),
          onClick: handleSidebarItemClick,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "stacked", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: settingsGrey, alt: t2("sidebar.settings") }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("img", { draggable: false, src: settings, alt: t2("sidebar.settings") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: style$2.sidebarLabel, children: t2("sidebar.settings") })
          ]
        }
      ) }, "settings"),
      !keystores || keystores.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForTesting, {}) : null,
      debug
    ] })
  ] });
};
const link = "_link_13in7_1";
const style$1 = {
  link
};
const Update = () => {
  const { t: t2 } = useTranslation();
  const file = useLoad(getUpdate);
  if (!file) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Status, { dismissible: `update-${file.version}`, type: "info", children: [
    t2("app.upgrade", {
      current: file.current,
      version: file.version
    }),
    file.description,
    " ",
    !runningInAndroid() && /* @__PURE__ */ jsxRuntimeExports.jsx(AppDownloadLink, { className: style$1.link })
  ] });
};
const auth = "_auth_xdrxz_1";
const style = {
  auth
};
const AuthRequired = () => {
  const { t: t2 } = useTranslation();
  const [authRequired, setAuthRequired] = reactExports.useState(false);
  const [authenticating, setAuthenticating] = reactExports.useState(false);
  const authForced = reactExports.useRef(false);
  const newAuthentication = () => {
    setAuthenticating(true);
    authenticate(authForced.current);
  };
  reactExports.useEffect(() => {
    const unsubscribe2 = subscribeAuth((data) => {
      switch (data.typ) {
        case "auth-forced":
          authForced.current = true;
          break;
        case "auth-required":
          setAuthRequired((prevAuthRequired) => {
            if (!prevAuthRequired) {
              newAuthentication();
            }
            return true;
          });
          break;
        case "auth-err":
          setAuthenticating(false);
          break;
        case "auth-canceled":
          if (authForced.current) {
            setAuthRequired(false);
            authForced.current = false;
          } else {
            setAuthenticating(false);
          }
          break;
        case "auth-ok":
          setAuthRequired(false);
          authForced.current = false;
      }
    });
    setAuthRequired(true);
    newAuthentication();
    return unsubscribe2;
  }, []);
  if (!authRequired) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: style.auth, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    View,
    {
      fullscreen: true,
      textCenter: true,
      verticallyCentered: true,
      withBottomBar: true,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewHeader, { small: true, title: t2("auth.title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewContent, { children: void 0, minHeight: "0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ViewButtons, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            autoFocus: true,
            primary: true,
            hidden: authForced.current,
            disabled: authenticating,
            onClick: newAuthentication,
            children: t2("auth.authButton")
          }
        ) })
      ]
    }
  ) });
};
const fetchAccountNameAndAddress = async (address2) => {
  const accountDetail = await getEthAccountCodeAndNameByAddress(address2);
  if (!accountDetail.success) {
    console.log("Failed in fetching account name and code");
    return { accountName: "", accountCode: "" };
  }
  const { code, name } = accountDetail;
  return { accountName: name, accountCode: code };
};
async function handleWcEthSignRequest(method, args) {
  switch (method) {
    case EIP155_SIGNING_METHODS.ETH_SIGN:
    case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      await ethSignHandler(args, method);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V3:
    case EIP155_SIGNING_METHODS.ETH_SIGN_TYPED_DATA_V4:
      await ethSignTypedDataHandler(args);
      break;
    case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
    case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
      await ethSignOrSendTransactionHandler(args, method);
      break;
    default:
      console.log(`${method} is unsupported`);
  }
}
async function ethSignHandler({ params, launchSignDialog, topic, id: id2, currentSession }, method) {
  const isPersonalSign = method === EIP155_SIGNING_METHODS.PERSONAL_SIGN;
  const requestParams = params.request.params;
  const accountAddress = isPersonalSign ? requestParams[1] : requestParams[0];
  const signingData = isPersonalSign ? requestParams[0] : requestParams[1];
  const decoded = decodeEthMessage(signingData);
  if (decoded === null) {
    alertUser(t$1("walletConnect.signingRequest.decodeError"));
    return;
  }
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  const apiCaller = async () => {
    const result = await ethSignMessage(accountCode, signingData);
    if (!result.success) {
      return { success: false, error: result };
    }
    return {
      response: { id: id2, jsonrpc: "2.0", result: result.signature },
      success: true
    };
  };
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: decoded,
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signMessage")
    }
  });
}
async function ethSignTypedDataHandler({ params, launchSignDialog, topic, id: id2, currentSession }) {
  const requestParams = params.request.params;
  const accountAddress = requestParams[0];
  const data = requestParams[1];
  let typedData;
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  try {
    typedData = JSON.parse(data);
  } catch (e3) {
    console.error("Failed to parse JSON", e3);
    alertUser(t$1("walletConnect.signingRequest.dataParsingError"));
    return;
  }
  const apiCaller = async () => {
    var _a;
    const chainId = ((_a = typedData == null ? void 0 : typedData.domain) == null ? void 0 : _a.chainId) ? Number(typedData.domain.chainId) : Number(params.chainId.replace(/^eip155:/, ""));
    const result = await ethSignTypedMessage(accountCode, chainId, data);
    if (result.success) {
      const response = { id: id2, jsonrpc: "2.0", result: result.signature };
      return { response, success: true };
    }
    return { success: false, error: result };
  };
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(typedData, null, 2),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: t$1("walletConnect.signingRequest.method.signTypedData")
    }
  });
}
async function ethSignOrSendTransactionHandler(args, method) {
  const isSendAndSign = method === EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION;
  const { params, launchSignDialog, topic, id: id2, currentSession } = args;
  const requestParams = params.request.params;
  const accountAddress = requestParams[0].from;
  const data = requestParams[0];
  const { accountName: accountName2, accountCode } = await fetchAccountNameAndAddress(accountAddress);
  const apiCaller = async () => {
    const chainId = Number(params.chainId.replace(/^eip155:/, ""));
    const result = await ethSignWalletConnectTx(accountCode, isSendAndSign, chainId, data);
    if (result.success) {
      const response = { id: id2, jsonrpc: "2.0", result: isSendAndSign ? result.txHash : result.rawTx };
      return { response, success: true };
    }
    return { success: false, error: result };
  };
  const formattedMethod = isSendAndSign ? t$1("walletConnect.signingRequest.method.sendTransaction") : t$1("walletConnect.signingRequest.method.signTransaction");
  launchSignDialog({
    topic,
    id: id2,
    apiCaller,
    dialogContent: {
      signingData: JSON.stringify(data),
      currentSession,
      accountName: accountName2,
      accountAddress,
      chain: params.chainId,
      method: formattedMethod
    }
  });
}
const accountName = "_accountName_gsa52_1";
const accountNameAndAddress = "_accountNameAndAddress_gsa52_6";
const address = "_address_gsa52_10";
const animationAndTextContainer = "_animationAndTextContainer_gsa52_16";
const chainContainer = "_chainContainer_gsa52_28";
const itemText = "_itemText_gsa52_33";
const dappIcon = "_dappIcon_gsa52_42";
const item = "_item_gsa52_33";
const label = "_label_gsa52_62";
const listContainer = "_listContainer_gsa52_68";
const outerContainer = "_outerContainer_gsa52_77";
const successIcon = "_successIcon_gsa52_84";
const textarea = "_textarea_gsa52_89";
const titleContainer = "_titleContainer_gsa52_97";
const styles = {
  accountName,
  accountNameAndAddress,
  address,
  animationAndTextContainer,
  chainContainer,
  itemText,
  dappIcon,
  item,
  label,
  listContainer,
  outerContainer,
  successIcon,
  textarea,
  titleContainer
};
const ConfirmOnBB02 = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("confirmOnDevice") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(PointToBitBox02, {})
  ] });
};
const RequestSuccessfullySigned = () => {
  const { t: t2 } = useTranslation();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.animationAndTextContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AnimatedChecked, { className: styles.successIcon }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("walletConnect.signingRequest.successfullySigned") })
  ] });
};
const WCIncomingSignRequestDialog = ({
  open: open2,
  onAccept,
  onReject,
  content: content2,
  stage
}) => {
  const { t: t2 } = useTranslation();
  const { isDarkMode } = useDarkmode();
  const { accountAddress, accountName: accountName2, signingData, chain, method, currentSession } = content2;
  const formattedChain = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].name : chain;
  const chainIcon = chain in SUPPORTED_CHAINS ? SUPPORTED_CHAINS[chain].icon : null;
  const metadata2 = currentSession.peer.metadata;
  const maxTextAreaRows = 20;
  const signingDataHeight = signingData.toString().split("\n").length + 3;
  const textAreaRows = signingDataHeight > maxTextAreaRows ? maxTextAreaRows : signingDataHeight;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: open2, large: true, onClose: onReject, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.titleContainer, children: [
      isDarkMode ? /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectLight, { height: 32, width: 32 }) : /* @__PURE__ */ jsxRuntimeExports.jsx(WalletConnectDark, { height: 40, width: 40 }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { children: t2("walletConnect.signingRequest.walletConnectRequest") })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.outerContainer, children: [
      stage !== "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("ul", { className: styles.listContainer, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.account") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: styles.accountNameAndAddress, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.accountName, children: /* @__PURE__ */ jsxRuntimeExports.jsx("b", { children: accountName2 }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.address, children: truncateAddress(accountAddress) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.chain") }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: styles.chainContainer, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: formattedChain }),
              chainIcon
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.dapp") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: metadata2.name })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("transaction.details.type") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.itemText, children: method })
          ] }),
          signingData && /* @__PURE__ */ jsxRuntimeExports.jsxs("li", { className: styles.item, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: styles.label, children: t2("walletConnect.signingRequest.data") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", { rows: textAreaRows, className: styles.textarea, readOnly: true, value: signingData.toString() })
          ] })
        ] }),
        stage === "confirming" && /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmOnBB02, {}),
        stage === "initial" && /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogButtons$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onAccept, primary: true, type: "submit", children: t2("button.continue") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: onReject, secondary: true, type: "submit", children: t2("dialog.cancel") })
        ] })
      ] }),
      stage === "accepted" && /* @__PURE__ */ jsxRuntimeExports.jsx(RequestSuccessfullySigned, {})
    ] })
  ] });
};
const WCSigningRequest = () => {
  const { web3wallet, isWalletInitialized } = reactExports.useContext(WCWeb3WalletContext);
  const [dialogOpen, setDialogOpen] = reactExports.useState(false);
  const [dialogContent, setDialogContent] = reactExports.useState();
  const [stage, setStage] = reactExports.useState("initial");
  const signMessageApiCallerRef = reactExports.useRef();
  const requestDataRef = reactExports.useRef();
  const launchSignDialog = ({ topic, id: id2, apiCaller, dialogContent: dialogContent2 }) => {
    const { signingData, currentSession, accountAddress, accountName: accountName2, chain, method } = dialogContent2;
    requestDataRef.current = { topic, id: id2 };
    signMessageApiCallerRef.current = apiCaller;
    setDialogContent({
      accountAddress,
      accountName: accountName2,
      signingData,
      chain,
      currentSession,
      method
    });
    setDialogOpen(true);
  };
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized) {
      return;
    }
    const onSessionRequest = async (requestEvent) => {
      const { topic, params, id: id2 } = requestEvent;
      const activeSessions = Object.values((web3wallet == null ? void 0 : web3wallet.getActiveSessions()) || {});
      const currentSession = activeSessions.find((session) => session.topic === topic);
      if (currentSession) {
        const handlerArgs = {
          topic,
          id: id2,
          params,
          currentSession,
          launchSignDialog
        };
        await handleWcEthSignRequest(params.request.method, handlerArgs);
      }
    };
    web3wallet == null ? void 0 : web3wallet.on("session_request", onSessionRequest);
    return () => {
      web3wallet == null ? void 0 : web3wallet.off("session_request", onSessionRequest);
    };
  }, [isWalletInitialized, web3wallet]);
  const handleRejectBtn = async () => {
    setDialogOpen(false);
    const requestData = requestDataRef.current;
    if (requestData) {
      const { topic, id: id2 } = requestData;
      await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
    }
  };
  const handleAcceptBtn = async () => {
    const apiCaller = signMessageApiCallerRef.current;
    const requestData = requestDataRef.current;
    if (apiCaller && requestData) {
      setStage("confirming");
      const { topic, id: id2 } = requestData;
      const { response, success: success2, error: error3 } = await apiCaller();
      if (success2) {
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response }));
        setStage("accepted");
        setTimeout(() => {
          setDialogOpen(false);
          setStage("initial");
        }, 5e3);
      } else if (error3.aborted) {
        setStage("initial");
        setDialogOpen(false);
        await (web3wallet == null ? void 0 : web3wallet.respondSessionRequest({ topic, response: rejectMessage(id2) }));
      } else {
        setStage("initial");
        const { errorMessage: errorMessage2 } = error3;
        alertUser(errorMessage2 ? errorMessage2 : t$1("pairing.error.text"));
      }
    }
  };
  if (!dialogContent || !dialogOpen) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCIncomingSignRequestDialog,
    {
      content: dialogContent,
      open: dialogOpen,
      stage,
      onAccept: handleAcceptBtn,
      onReject: handleRejectBtn
    }
  );
};
const setDarkTheme = (isDark) => {
  return apiPost("set-dark-theme", isDark);
};
const detectDarkTheme = () => {
  return apiGet("detect-dark-theme");
};
const DarkModeProvider = ({ children: children2 }) => {
  const [isDarkMode, setIsDarkMode] = reactExports.useState(false);
  const androidPrefersDarkMode = useMediaQuery("(prefers-color-scheme: dark)");
  const setAppTheme = reactExports.useCallback(() => {
    setDarkTheme(isDarkMode);
    if (isDarkMode) {
      document.body.classList.add("dark-mode");
      document.body.classList.remove("light-mode");
    } else {
      document.body.classList.remove("dark-mode");
      document.body.classList.add("light-mode");
    }
  }, [isDarkMode]);
  reactExports.useEffect(() => {
    getConfig().then((config) => {
      if (!!config.frontend && "darkmode" in config.frontend) {
        setIsDarkMode(config.frontend.darkmode);
        return;
      }
      if (runningInAndroid()) {
        setIsDarkMode(androidPrefersDarkMode);
      } else {
        detectDarkTheme().then(setIsDarkMode);
      }
    }).catch(console.error);
  }, [androidPrefersDarkMode]);
  reactExports.useEffect(() => {
    setAppTheme();
  }, [isDarkMode, setAppTheme]);
  const toggleDarkmode = (darkmode2) => {
    setIsDarkMode(darkmode2);
    getConfig().then(async (config) => {
      let preferredDarkMode;
      if (runningInAndroid()) {
        preferredDarkMode = androidPrefersDarkMode;
      } else {
        preferredDarkMode = await detectDarkTheme();
      }
      if (preferredDarkMode === darkmode2) {
        const { darkmode: darkmode22, ...frontend } = config.frontend;
        setConfig({
          frontend: {
            ...frontend,
            darkmode: void 0
          }
        });
      } else {
        setConfig({
          frontend: {
            ...config.frontend,
            darkmode: darkmode2
          }
        });
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeContext.Provider, { value: { isDarkMode, toggleDarkmode }, children: children2 });
};
const AppProvider = ({ children: children2 }) => {
  const [guideShown, setGuideShown] = reactExports.useState(false);
  const [guideExists, setGuideExists] = reactExports.useState(false);
  const [hideAmounts, setHideAmounts] = reactExports.useState(false);
  const [activeSidebar, setActiveSidebar] = reactExports.useState(false);
  const [sidebarStatus, setSidebarStatus] = reactExports.useState("");
  const toggleGuide = () => {
    setConfig({ frontend: { guideShown: !guideShown } });
    setGuideShown((prev2) => !prev2);
  };
  const toggleHideAmounts = () => {
    setConfig({ frontend: { hideAmounts: !hideAmounts } });
    setHideAmounts((prev2) => !prev2);
  };
  const toggleSidebar = () => {
    setActiveSidebar((prev2) => !prev2);
  };
  reactExports.useEffect(() => {
    getConfig().then(({ frontend }) => {
      if (frontend) {
        if (frontend.guideShown !== void 0) {
          setGuideShown(frontend.guideShown);
        }
        if (frontend.hideAmounts !== void 0) {
          setHideAmounts(frontend.hideAmounts);
        }
      } else {
        setGuideShown(true);
      }
    });
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    AppContext.Provider,
    {
      value: {
        activeSidebar,
        toggleGuide,
        guideShown,
        guideExists,
        hideAmounts,
        sidebarStatus,
        setActiveSidebar,
        setGuideShown,
        setGuideExists,
        setSidebarStatus,
        setHideAmounts,
        toggleHideAmounts,
        toggleSidebar
      },
      children: children2
    }
  );
};
const WCWeb3WalletProvider = ({ children: children2 }) => {
  const { t: t2 } = useTranslation();
  const [web3wallet, setWeb3wallet] = reactExports.useState();
  const [isWalletInitialized, setIsWalletInitialized] = reactExports.useState(false);
  const config = useLoad(getConfig);
  const hasUsedWC = config && config.frontend && config.frontend.hasUsedWalletConnect;
  const initializeWeb3Wallet = async () => {
    try {
      const { Core } = await __vitePreload(() => import("./index.es.js").then((n2) => n2.l), true ? [] : void 0, import.meta.url);
      const { Web3Wallet } = await __vitePreload(() => import("./index.es2.js"), true ? [] : void 0, import.meta.url);
      const core2 = new Core({
        projectId: "89733df088867a1a1bf644013addd6cc"
      });
      const wallet = await Web3Wallet.init({
        core: core2,
        metadata: {
          name: "BitBox",
          description: "BitBox02 hardware wallet",
          url: "https://bitbox.swiss",
          icons: ["https://bitbox.swiss/assets/images/logos/dbb-logo.png"]
        }
      });
      setWeb3wallet(wallet);
      setIsWalletInitialized(true);
    } catch (err) {
      console.log("Error for initializing", err);
    }
  };
  reactExports.useEffect(() => {
    if (!web3wallet && !isWalletInitialized && hasUsedWC) {
      initializeWeb3Wallet();
    }
  }, [isWalletInitialized, web3wallet, hasUsedWC]);
  const pair = async (params) => {
    if (!web3wallet) {
      return;
    }
    try {
      const { uri } = params;
      const topic = getTopicFromURI(uri);
      const hasEverBeenRejected = pairingHasEverBeenRejected(topic, web3wallet);
      if (hasEverBeenRejected) {
        throw new Error(t2("walletConnect.useNewUri"));
      }
      await (web3wallet == null ? void 0 : web3wallet.core.pairing.pair({ uri }));
      setConfig({ frontend: { hasUsedWalletConnect: true } });
    } catch (e3) {
      console.error(`Wallet connect attempt to pair error ${e3}`);
      if (e3.message.includes("Pairing already exists")) {
        throw new Error(t2("walletConnect.useNewUri"));
      }
      throw new Error(e3.message);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    WCWeb3WalletContext.Provider,
    {
      value: {
        initializeWeb3Wallet,
        isWalletInitialized,
        web3wallet,
        pair
      },
      children: children2
    }
  );
};
const RatesProvider = ({ children: children2 }) => {
  const [defaultCurrency2, setDefaultCurrency] = reactExports.useState("USD");
  const [activeCurrencies, setActiveCurrencies] = reactExports.useState(["USD", "EUR", "CHF"]);
  const [btcUnit, setBtcUnit2] = reactExports.useState("default");
  reactExports.useEffect(() => {
    updateRatesConfig();
  }, []);
  const updateRatesConfig = async () => {
    var _a, _b, _c;
    const appConf = await getConfig();
    if ((_a = appConf.backend) == null ? void 0 : _a.mainFiat) {
      setDefaultCurrency(appConf.backend.mainFiat);
    }
    if (((_b = appConf.backend) == null ? void 0 : _b.fiatList) && ((_c = appConf.backend) == null ? void 0 : _c.btcUnit)) {
      setActiveCurrencies(appConf.backend.fiatList);
      setBtcUnit2(appConf.backend.btcUnit);
    }
  };
  const rotateFiat = () => {
    const index2 = activeCurrencies.indexOf(defaultCurrency2);
    const fiat2 = activeCurrencies[(index2 + 1) % activeCurrencies.length];
    updateDefaultFiat(fiat2);
  };
  const updateDefaultFiat = (fiat2) => {
    if (!activeCurrencies.includes(fiat2)) {
      selectFiat(fiat2);
    }
    setDefaultCurrency(fiat2);
    setConfig({ backend: { mainFiat: fiat2 } });
  };
  const selectFiat = async (fiat2) => {
    const selected2 = [...activeCurrencies, fiat2];
    await setConfig({ backend: { fiatList: selected2 } });
    handleChangeSelectedFiat(selected2);
  };
  const unselectFiat = async (fiat2) => {
    const selected2 = activeCurrencies.filter((item2) => !equal(item2, fiat2));
    await setConfig({ backend: { fiatList: selected2 } });
    handleChangeSelectedFiat(selected2);
  };
  const handleChangeSelectedFiat = (selected2) => {
    setActiveCurrencies(selected2);
    reinitializeAccounts();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RatesContext.Provider,
    {
      value: {
        defaultCurrency: defaultCurrency2,
        activeCurrencies,
        btcUnit,
        rotateFiat,
        selectFiat,
        updateDefaultFiat,
        updateRatesConfig,
        unselectFiat
      },
      children: children2
    }
  );
};
const Providers = ({ children: children2 }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AppProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DarkModeProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RatesProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(WCWeb3WalletProvider, { children: children2 }) }) }) });
};
const App = () => {
  const { t: t2 } = useTranslation();
  const navigate2 = useNavigate();
  const accounts = useDefault(useSync(getAccounts, syncAccountsList), []);
  const devices = useDefault(useSync(getDeviceList, syncDeviceList), {});
  const prevDevices = usePrevious(devices);
  reactExports.useEffect(() => {
    return syncNewTxs((meta) => {
      notifyUser(t2("notification.newTxs", {
        count: meta.count,
        accountName: meta.accountName
      }));
    });
  }, [t2]);
  const maybeRoute = reactExports.useCallback(() => {
    const currentURL = window.location.pathname;
    const isIndex = currentURL === "/" || currentURL === "/index.html" || currentURL === "/android_asset/web/index.html";
    const inAccounts = currentURL.startsWith("/account/");
    if (isIndex && currentURL !== "/" && (!accounts || accounts.length === 0)) {
      navigate2("/");
      return;
    }
    if (accounts.length === 0 && (currentURL.startsWith("/account-summary") || currentURL.startsWith("/add-account") || currentURL.startsWith("/settings/manage-accounts"))) {
      navigate2("/");
      return;
    }
    if (Object.keys(devices).length === 0 && currentURL.startsWith("/settings/device-settings/")) {
      navigate2("/");
      return;
    }
    if (inAccounts && !accounts.some((account2) => currentURL.startsWith("/account/" + account2.code))) {
      navigate2("/");
      return;
    }
    if (isIndex && accounts.length) {
      navigate2("/account-summary");
      return;
    }
    if (accounts.length === 0 && currentURL.startsWith("/buy/")) {
      navigate2("/");
      return;
    }
    if (accounts.length === 0 && currentURL.startsWith("/bitsurance/")) {
      navigate2("/");
      return;
    }
  }, [accounts, devices, navigate2]);
  reactExports.useEffect(() => {
    const oldDeviceIDList = Object.keys(prevDevices || {});
    const newDeviceIDList = Object.keys(devices);
    if (newDeviceIDList.length > 0 && newDeviceIDList[0] !== oldDeviceIDList[0]) {
      const productName = devices[newDeviceIDList[0]];
      if (productName === "bitbox" || productName === "bitbox02-bootloader") {
        navigate2(`settings/device-settings/${newDeviceIDList[0]}`);
        return;
      }
    }
    maybeRoute();
  }, [devices, maybeRoute, navigate2, prevDevices]);
  const devicesKey = (prefix2) => {
    return prefix2 + ":" + JSON.stringify(devices, Object.keys(devices).sort());
  };
  const deviceIDs = Object.keys(devices);
  const activeAccounts = accounts.filter((acct) => acct.active);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ConnectedApp, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Providers, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Darkmode, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "app", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AuthRequired, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Sidebar,
        {
          accounts: activeAccounts,
          deviceIDs
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "appContent flex flex-column flex-1", style: { minWidth: 0 }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Update, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox01" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Banner, { msgKey: "bitbox02" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MobileDataWarning, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(WCSigningRequest, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(translateHOC, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(KeystoreConnectPrompt, {}),
        Object.entries(devices).map(([deviceID, productName]) => {
          if (productName === "bitbox02") {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Wizard,
              {
                deviceID
              }
            ) }, deviceID);
          }
          return null;
        }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AppRouter,
          {
            accounts,
            activeAccounts,
            deviceIDs,
            devices,
            devicesKey
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(RouterWatcher, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Alert, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Confirm, {})
    ] })
  ] }) });
};
const index = "";
const rootEl = document.getElementById("root");
const root = createRoot(rootEl);
root.render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(I18nextProvider, { i18n: instance, children: /* @__PURE__ */ jsxRuntimeExports.jsx(React.Suspense, { fallback: null, children: /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) }) }) }) })
);
export {
  Vn as $,
  Bt as A,
  B,
  ft as C,
  D,
  require$$0 as E,
  Ft2 as F,
  Gt2 as G,
  Ht2 as H,
  binary as I,
  Jt as J,
  Kn as K,
  Ln as L,
  wipe$1 as M,
  N,
  random as O,
  fromString as P,
  Qn as Q,
  toString as R,
  concat as S,
  rt as T,
  U,
  ot as V,
  Wt2 as W,
  Xt2 as X,
  Yt2 as Y,
  kn2 as Z,
  _23 as _,
  getAugmentedNamespace as a,
  Mn2 as a0,
  Te as a1,
  qn as a2,
  xn2 as a3,
  Hn as a4,
  Fn as a5,
  ee as a6,
  $ as a7,
  vt2 as a8,
  Et as a9,
  ut as aa,
  k as ab,
  Jn as ac,
  er as ad,
  Xn as ae,
  nr as af,
  Vt as ag,
  Mt$1 as ah,
  It as ai,
  wt as aj,
  lt2 as ak,
  dt as al,
  C as am,
  te as an,
  p as ao,
  cjs$2 as b,
  commonjsGlobal as c,
  at2 as d,
  gt as e,
  Dt as f,
  getDefaultExportFromCjs as g,
  ht2 as h,
  Lt as i,
  jt2 as j,
  kt$1 as k,
  dn2 as l,
  mt2 as m,
  h as n,
  ln as o,
  pt2 as p,
  qt2 as q,
  require$$0$1 as r,
  sha256 as s,
  tr as t,
  un as u,
  Kt2 as v,
  w,
  xt as x,
  yt as y,
  zt as z
};
